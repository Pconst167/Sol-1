0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT SEGMENT
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408 05 0B         syscall sys_terminate_proc
0011   040A             
0012   040A             strcpy:
0013   040A F8 00 00      enter 0 ; (push bp; mov bp, sp)
0014   040D             ; char *psrc; 
0015   040D 52 02 00      sub sp, 2
0016   0410             ; char *pdest; 
0017   0410 52 02 00      sub sp, 2
0018   0413             ; psrc = src; 
0019   0413 FA FF FF      lea d, [bp + -1] ; $psrc
0020   0416 DA            push d
0021   0417 FA 07 00      lea d, [bp + 7] ; $src
0022   041A 2A            mov b, [d]
0023   041B E7            pop d
0024   041C FD 43         mov [d], b
0025   041E             ; pdest = dest; 
0026   041E FA FD FF      lea d, [bp + -3] ; $pdest
0027   0421 DA            push d
0028   0422 FA 05 00      lea d, [bp + 5] ; $dest
0029   0425 2A            mov b, [d]
0030   0426 E7            pop d
0031   0427 FD 43         mov [d], b
0032   0429             ; while(*psrc) *pdest++ = *psrc++; 
0033   0429             _while1_cond:
0034   0429 FA FF FF      lea d, [bp + -1] ; $psrc
0035   042C 2A            mov b, [d]
0036   042D 74            mov d, b
0037   042E 32            mov bl, [d]
0038   042F A7 00         mov bh, 0
0039   0431 C0 00 00      cmp b, 0
0040   0434 C6 5C 04      je _while1_exit
0041   0437             _while1_block:
0042   0437             ; *pdest++ = *psrc++; 
0043   0437 FA FD FF      lea d, [bp + -3] ; $pdest
0044   043A 2A            mov b, [d]
0045   043B FD 77         inc b
0046   043D FA FD FF      lea d, [bp + -3] ; $pdest
0047   0440 FD 43         mov [d], b
0048   0442 FD 7D         dec b
0049   0444 D8            push b
0050   0445 FA FF FF      lea d, [bp + -1] ; $psrc
0051   0448 2A            mov b, [d]
0052   0449 FD 77         inc b
0053   044B FA FF FF      lea d, [bp + -1] ; $psrc
0054   044E FD 43         mov [d], b
0055   0450 FD 7D         dec b
0056   0452 74            mov d, b
0057   0453 32            mov bl, [d]
0058   0454 A7 00         mov bh, 0
0059   0456 E7            pop d
0060   0457 FD 3E         mov [d], bl
0061   0459 0A 29 04      jmp _while1_cond
0062   045C             _while1_exit:
0063   045C             ; *pdest = '\0'; 
0064   045C FA FD FF      lea d, [bp + -3] ; $pdest
0065   045F 2A            mov b, [d]
0066   0460 D8            push b
0067   0461 26 00 00      mov b, $0
0068   0464 E7            pop d
0069   0465 FD 3E         mov [d], bl
0070   0467 F9            leave
0071   0468 09            ret
0072   0469             
0073   0469             strcmp:
0074   0469 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0075   046C             ; while (*s1 && (*s1 == *s2)) { 
0076   046C             _while2_cond:
0077   046C FA 05 00      lea d, [bp + 5] ; $s1
0078   046F 2A            mov b, [d]
0079   0470 74            mov d, b
0080   0471 32            mov bl, [d]
0081   0472 A7 00         mov bh, 0
0082   0474             ; --- START LOGICAL AND
0083   0474 D7            push a
0084   0475 11            mov a, b
0085   0476 FA 05 00      lea d, [bp + 5] ; $s1
0086   0479 2A            mov b, [d]
0087   047A 74            mov d, b
0088   047B 32            mov bl, [d]
0089   047C A7 00         mov bh, 0
0090   047E             ; --- START RELATIONAL
0091   047E D7            push a
0092   047F 11            mov a, b
0093   0480 FA 07 00      lea d, [bp + 7] ; $s2
0094   0483 2A            mov b, [d]
0095   0484 74            mov d, b
0096   0485 32            mov bl, [d]
0097   0486 A7 00         mov bh, 0
0098   0488 B0            cmp a, b
0099   0489 FD 71         seq ; ==
0100   048B E4            pop a
0101   048C             ; --- END RELATIONAL
0102   048C FD A7         sand a, b
0103   048E E4            pop a
0104   048F             ; --- END LOGICAL AND
0105   048F C0 00 00      cmp b, 0
0106   0492 C6 B2 04      je _while2_exit
0107   0495             _while2_block:
0108   0495             ; s1++; 
0109   0495 FA 05 00      lea d, [bp + 5] ; $s1
0110   0498 2A            mov b, [d]
0111   0499 FD 77         inc b
0112   049B FA 05 00      lea d, [bp + 5] ; $s1
0113   049E FD 43         mov [d], b
0114   04A0 FD 7D         dec b
0115   04A2             ; s2++; 
0116   04A2 FA 07 00      lea d, [bp + 7] ; $s2
0117   04A5 2A            mov b, [d]
0118   04A6 FD 77         inc b
0119   04A8 FA 07 00      lea d, [bp + 7] ; $s2
0120   04AB FD 43         mov [d], b
0121   04AD FD 7D         dec b
0122   04AF 0A 6C 04      jmp _while2_cond
0123   04B2             _while2_exit:
0124   04B2             ; return *s1 - *s2; 
0125   04B2 FA 05 00      lea d, [bp + 5] ; $s1
0126   04B5 2A            mov b, [d]
0127   04B6 74            mov d, b
0128   04B7 32            mov bl, [d]
0129   04B8 A7 00         mov bh, 0
0130   04BA             ; --- START TERMS
0131   04BA D7            push a
0132   04BB 11            mov a, b
0133   04BC FA 07 00      lea d, [bp + 7] ; $s2
0134   04BF 2A            mov b, [d]
0135   04C0 74            mov d, b
0136   04C1 32            mov bl, [d]
0137   04C2 A7 00         mov bh, 0
0138   04C4 60            sub a, b
0139   04C5 27            mov b, a
0140   04C6 E4            pop a
0141   04C7             ; --- END TERMS
0142   04C7 F9            leave
0143   04C8 09            ret
0144   04C9             
0145   04C9             strncmp:
0146   04C9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0147   04CC F9            leave
0148   04CD 09            ret
0149   04CE             
0150   04CE             strcat:
0151   04CE F8 00 00      enter 0 ; (push bp; mov bp, sp)
0152   04D1             ; int dest_len; 
0153   04D1 52 02 00      sub sp, 2
0154   04D4             ; int i; 
0155   04D4 52 02 00      sub sp, 2
0156   04D7             ; dest_len = strlen(dest); 
0157   04D7 FA FF FF      lea d, [bp + -1] ; $dest_len
0158   04DA DA            push d
0159   04DB FA 05 00      lea d, [bp + 5] ; $dest
0160   04DE 2A            mov b, [d]
0161   04DF FD AB         swp b
0162   04E1 D8            push b
0163   04E2 07 84 05      call strlen
0164   04E5 51 02 00      add sp, 2
0165   04E8 E7            pop d
0166   04E9 FD 43         mov [d], b
0167   04EB             ; for (i = 0; src[i] != 0; i=i+1) { 
0168   04EB             _for3_init:
0169   04EB FA FD FF      lea d, [bp + -3] ; $i
0170   04EE DA            push d
0171   04EF 26 00 00      mov b, $0
0172   04F2 E7            pop d
0173   04F3 FD 43         mov [d], b
0174   04F5             _for3_cond:
0175   04F5 FA 07 00      lea d, [bp + 7] ; $src
0176   04F8 FD 2A         mov d, [d]
0177   04FA D7            push a
0178   04FB DA            push d
0179   04FC FA FD FF      lea d, [bp + -3] ; $i
0180   04FF 2A            mov b, [d]
0181   0500 E7            pop d
0182   0501 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0183   0505 E4            pop a
0184   0506 32            mov bl, [d]
0185   0507 A7 00         mov bh, 0
0186   0509             ; --- START RELATIONAL
0187   0509 D7            push a
0188   050A 11            mov a, b
0189   050B 26 00 00      mov b, $0
0190   050E B0            cmp a, b
0191   050F FD 72         sneq ; !=
0192   0511 E4            pop a
0193   0512             ; --- END RELATIONAL
0194   0512 C0 00 00      cmp b, 0
0195   0515 C6 5E 05      je _for3_exit
0196   0518             _for3_block:
0197   0518             ; dest[dest_len + i] = src[i]; 
0198   0518 FA 05 00      lea d, [bp + 5] ; $dest
0199   051B FD 2A         mov d, [d]
0200   051D D7            push a
0201   051E DA            push d
0202   051F FA FF FF      lea d, [bp + -1] ; $dest_len
0203   0522 2A            mov b, [d]
0204   0523             ; --- START TERMS
0205   0523 D7            push a
0206   0524 11            mov a, b
0207   0525 FA FD FF      lea d, [bp + -3] ; $i
0208   0528 2A            mov b, [d]
0209   0529 56            add b, a
0210   052A E4            pop a
0211   052B             ; --- END TERMS
0212   052B E7            pop d
0213   052C FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0214   0530 E4            pop a
0215   0531 DA            push d
0216   0532 FA 07 00      lea d, [bp + 7] ; $src
0217   0535 FD 2A         mov d, [d]
0218   0537 D7            push a
0219   0538 DA            push d
0220   0539 FA FD FF      lea d, [bp + -3] ; $i
0221   053C 2A            mov b, [d]
0222   053D E7            pop d
0223   053E FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0224   0542 E4            pop a
0225   0543 32            mov bl, [d]
0226   0544 A7 00         mov bh, 0
0227   0546 E7            pop d
0228   0547 FD 3E         mov [d], bl
0229   0549             _for3_update:
0230   0549 FA FD FF      lea d, [bp + -3] ; $i
0231   054C DA            push d
0232   054D FA FD FF      lea d, [bp + -3] ; $i
0233   0550 2A            mov b, [d]
0234   0551             ; --- START TERMS
0235   0551 D7            push a
0236   0552 11            mov a, b
0237   0553 26 01 00      mov b, $1
0238   0556 56            add b, a
0239   0557 E4            pop a
0240   0558             ; --- END TERMS
0241   0558 E7            pop d
0242   0559 FD 43         mov [d], b
0243   055B 0A F5 04      jmp _for3_cond
0244   055E             _for3_exit:
0245   055E             ; dest[dest_len + i] = 0; 
0246   055E FA 05 00      lea d, [bp + 5] ; $dest
0247   0561 FD 2A         mov d, [d]
0248   0563 D7            push a
0249   0564 DA            push d
0250   0565 FA FF FF      lea d, [bp + -1] ; $dest_len
0251   0568 2A            mov b, [d]
0252   0569             ; --- START TERMS
0253   0569 D7            push a
0254   056A 11            mov a, b
0255   056B FA FD FF      lea d, [bp + -3] ; $i
0256   056E 2A            mov b, [d]
0257   056F 56            add b, a
0258   0570 E4            pop a
0259   0571             ; --- END TERMS
0260   0571 E7            pop d
0261   0572 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0262   0576 E4            pop a
0263   0577 DA            push d
0264   0578 26 00 00      mov b, $0
0265   057B E7            pop d
0266   057C FD 3E         mov [d], bl
0267   057E             ; return dest; 
0268   057E FA 05 00      lea d, [bp + 5] ; $dest
0269   0581 2A            mov b, [d]
0270   0582 F9            leave
0271   0583 09            ret
0272   0584             
0273   0584             strlen:
0274   0584 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0275   0587             ; int length; 
0276   0587 52 02 00      sub sp, 2
0277   058A             ; length = 0; 
0278   058A FA FF FF      lea d, [bp + -1] ; $length
0279   058D DA            push d
0280   058E 26 00 00      mov b, $0
0281   0591 E7            pop d
0282   0592 FD 43         mov [d], b
0283   0594             ; while (str[length] != 0) { 
0284   0594             _while4_cond:
0285   0594 FA 05 00      lea d, [bp + 5] ; $str
0286   0597 FD 2A         mov d, [d]
0287   0599 D7            push a
0288   059A DA            push d
0289   059B FA FF FF      lea d, [bp + -1] ; $length
0290   059E 2A            mov b, [d]
0291   059F E7            pop d
0292   05A0 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0293   05A4 E4            pop a
0294   05A5 32            mov bl, [d]
0295   05A6 A7 00         mov bh, 0
0296   05A8             ; --- START RELATIONAL
0297   05A8 D7            push a
0298   05A9 11            mov a, b
0299   05AA 26 00 00      mov b, $0
0300   05AD B0            cmp a, b
0301   05AE FD 72         sneq ; !=
0302   05B0 E4            pop a
0303   05B1             ; --- END RELATIONAL
0304   05B1 C0 00 00      cmp b, 0
0305   05B4 C6 C7 05      je _while4_exit
0306   05B7             _while4_block:
0307   05B7             ; length++; 
0308   05B7 FA FF FF      lea d, [bp + -1] ; $length
0309   05BA 2A            mov b, [d]
0310   05BB FD 77         inc b
0311   05BD FA FF FF      lea d, [bp + -1] ; $length
0312   05C0 FD 43         mov [d], b
0313   05C2 FD 7D         dec b
0314   05C4 0A 94 05      jmp _while4_cond
0315   05C7             _while4_exit:
0316   05C7             ; return length; 
0317   05C7 FA FF FF      lea d, [bp + -1] ; $length
0318   05CA 2A            mov b, [d]
0319   05CB F9            leave
0320   05CC 09            ret
0321   05CD             
0322   05CD             exit:
0323   05CD F8 00 00      enter 0 ; (push bp; mov bp, sp)
0324   05D0             
0325   05D0             ; --- BEGIN INLINE ASM SEGMENT
0326   05D0 05 0B         syscall sys_terminate_proc
0327   05D2             ; --- END INLINE ASM SEGMENT
0328   05D2             
0329   05D2 F9            leave
0330   05D3 09            ret
0331   05D4             
0332   05D4             memset:
0333   05D4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0334   05D7             ; int i; 
0335   05D7 52 02 00      sub sp, 2
0336   05DA             ; for(i = 0; i < size; i++){ 
0337   05DA             _for5_init:
0338   05DA FA FF FF      lea d, [bp + -1] ; $i
0339   05DD DA            push d
0340   05DE 26 00 00      mov b, $0
0341   05E1 E7            pop d
0342   05E2 FD 43         mov [d], b
0343   05E4             _for5_cond:
0344   05E4 FA FF FF      lea d, [bp + -1] ; $i
0345   05E7 2A            mov b, [d]
0346   05E8             ; --- START RELATIONAL
0347   05E8 D7            push a
0348   05E9 11            mov a, b
0349   05EA FA 08 00      lea d, [bp + 8] ; $size
0350   05ED 2A            mov b, [d]
0351   05EE B0            cmp a, b
0352   05EF FD 73         slt ; < (signed)
0353   05F1 E4            pop a
0354   05F2             ; --- END RELATIONAL
0355   05F2 C0 00 00      cmp b, 0
0356   05F5 C6 1E 06      je _for5_exit
0357   05F8             _for5_block:
0358   05F8             ; *(s+i) = c; 
0359   05F8 FA 05 00      lea d, [bp + 5] ; $s
0360   05FB 2A            mov b, [d]
0361   05FC             ; --- START TERMS
0362   05FC D7            push a
0363   05FD 11            mov a, b
0364   05FE FA FF FF      lea d, [bp + -1] ; $i
0365   0601 2A            mov b, [d]
0366   0602 56            add b, a
0367   0603 E4            pop a
0368   0604             ; --- END TERMS
0369   0604 D8            push b
0370   0605 FA 07 00      lea d, [bp + 7] ; $c
0371   0608 32            mov bl, [d]
0372   0609 A7 00         mov bh, 0
0373   060B E7            pop d
0374   060C FD 3E         mov [d], bl
0375   060E             _for5_update:
0376   060E FA FF FF      lea d, [bp + -1] ; $i
0377   0611 2A            mov b, [d]
0378   0612 FD 77         inc b
0379   0614 FA FF FF      lea d, [bp + -1] ; $i
0380   0617 FD 43         mov [d], b
0381   0619 FD 7D         dec b
0382   061B 0A E4 05      jmp _for5_cond
0383   061E             _for5_exit:
0384   061E             ; return s; 
0385   061E FA 05 00      lea d, [bp + 5] ; $s
0386   0621 2A            mov b, [d]
0387   0622 F9            leave
0388   0623 09            ret
0389   0624             
0390   0624             atoi:
0391   0624 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0392   0627             ; int result = 0;  // Initialize result 
0393   0627 52 02 00      sub sp, 2
0394   062A             ; --- START LOCAL VAR INITIALIZATION
0395   062A FA FF FF      lea d, [bp + -1] ; $result
0396   062D DA            push d
0397   062E 26 00 00      mov b, $0
0398   0631 E7            pop d
0399   0632 FD 43         mov [d], b
0400   0634             ; --- END LOCAL VAR INITIALIZATION
0401   0634             ; int sign = 1;    // Initialize sign as positive 
0402   0634 52 02 00      sub sp, 2
0403   0637             ; --- START LOCAL VAR INITIALIZATION
0404   0637 FA FD FF      lea d, [bp + -3] ; $sign
0405   063A DA            push d
0406   063B 26 01 00      mov b, $1
0407   063E E7            pop d
0408   063F FD 43         mov [d], b
0409   0641             ; --- END LOCAL VAR INITIALIZATION
0410   0641             ; while (*str == ' ') str++; 
0411   0641             _while6_cond:
0412   0641 FA 05 00      lea d, [bp + 5] ; $str
0413   0644 2A            mov b, [d]
0414   0645 74            mov d, b
0415   0646 32            mov bl, [d]
0416   0647 A7 00         mov bh, 0
0417   0649             ; --- START RELATIONAL
0418   0649 D7            push a
0419   064A 11            mov a, b
0420   064B 26 20 00      mov b, $20
0421   064E B0            cmp a, b
0422   064F FD 71         seq ; ==
0423   0651 E4            pop a
0424   0652             ; --- END RELATIONAL
0425   0652 C0 00 00      cmp b, 0
0426   0655 C6 68 06      je _while6_exit
0427   0658             _while6_block:
0428   0658             ; str++; 
0429   0658 FA 05 00      lea d, [bp + 5] ; $str
0430   065B 2A            mov b, [d]
0431   065C FD 77         inc b
0432   065E FA 05 00      lea d, [bp + 5] ; $str
0433   0661 FD 43         mov [d], b
0434   0663 FD 7D         dec b
0435   0665 0A 41 06      jmp _while6_cond
0436   0668             _while6_exit:
0437   0668             ; if (*str == '-' || *str == '+') { 
0438   0668             _if7_cond:
0439   0668 FA 05 00      lea d, [bp + 5] ; $str
0440   066B 2A            mov b, [d]
0441   066C 74            mov d, b
0442   066D 32            mov bl, [d]
0443   066E A7 00         mov bh, 0
0444   0670             ; --- START RELATIONAL
0445   0670 D7            push a
0446   0671 11            mov a, b
0447   0672 26 2D 00      mov b, $2d
0448   0675 B0            cmp a, b
0449   0676 FD 71         seq ; ==
0450   0678 E4            pop a
0451   0679             ; --- END RELATIONAL
0452   0679             ; --- START LOGICAL OR
0453   0679 D7            push a
0454   067A 11            mov a, b
0455   067B FA 05 00      lea d, [bp + 5] ; $str
0456   067E 2A            mov b, [d]
0457   067F 74            mov d, b
0458   0680 32            mov bl, [d]
0459   0681 A7 00         mov bh, 0
0460   0683             ; --- START RELATIONAL
0461   0683 D7            push a
0462   0684 11            mov a, b
0463   0685 26 2B 00      mov b, $2b
0464   0688 B0            cmp a, b
0465   0689 FD 71         seq ; ==
0466   068B E4            pop a
0467   068C             ; --- END RELATIONAL
0468   068C FD A8         sor a, b ; ||
0469   068E E4            pop a
0470   068F             ; --- END LOGICAL OR
0471   068F C0 00 00      cmp b, 0
0472   0692 C6 CB 06      je _if7_exit
0473   0695             _if7_true:
0474   0695             ; if (*str == '-') sign = -1; 
0475   0695             _if8_cond:
0476   0695 FA 05 00      lea d, [bp + 5] ; $str
0477   0698 2A            mov b, [d]
0478   0699 74            mov d, b
0479   069A 32            mov bl, [d]
0480   069B A7 00         mov bh, 0
0481   069D             ; --- START RELATIONAL
0482   069D D7            push a
0483   069E 11            mov a, b
0484   069F 26 2D 00      mov b, $2d
0485   06A2 B0            cmp a, b
0486   06A3 FD 71         seq ; ==
0487   06A5 E4            pop a
0488   06A6             ; --- END RELATIONAL
0489   06A6 C0 00 00      cmp b, 0
0490   06A9 C6 BB 06      je _if8_exit
0491   06AC             _if8_true:
0492   06AC             ; sign = -1; 
0493   06AC FA FD FF      lea d, [bp + -3] ; $sign
0494   06AF DA            push d
0495   06B0 26 01 00      mov b, $1
0496   06B3 FD 97         neg b
0497   06B5 E7            pop d
0498   06B6 FD 43         mov [d], b
0499   06B8 0A BB 06      jmp _if8_exit
0500   06BB             _if8_exit:
0501   06BB             ; str++; 
0502   06BB FA 05 00      lea d, [bp + 5] ; $str
0503   06BE 2A            mov b, [d]
0504   06BF FD 77         inc b
0505   06C1 FA 05 00      lea d, [bp + 5] ; $str
0506   06C4 FD 43         mov [d], b
0507   06C6 FD 7D         dec b
0508   06C8 0A CB 06      jmp _if7_exit
0509   06CB             _if7_exit:
0510   06CB             ; while (*str >= '0' && *str <= '9') { 
0511   06CB             _while9_cond:
0512   06CB FA 05 00      lea d, [bp + 5] ; $str
0513   06CE 2A            mov b, [d]
0514   06CF 74            mov d, b
0515   06D0 32            mov bl, [d]
0516   06D1 A7 00         mov bh, 0
0517   06D3             ; --- START RELATIONAL
0518   06D3 D7            push a
0519   06D4 11            mov a, b
0520   06D5 26 30 00      mov b, $30
0521   06D8 B0            cmp a, b
0522   06D9 FD 82         sgeu ; >= (unsigned)
0523   06DB E4            pop a
0524   06DC             ; --- END RELATIONAL
0525   06DC             ; --- START LOGICAL AND
0526   06DC D7            push a
0527   06DD 11            mov a, b
0528   06DE FA 05 00      lea d, [bp + 5] ; $str
0529   06E1 2A            mov b, [d]
0530   06E2 74            mov d, b
0531   06E3 32            mov bl, [d]
0532   06E4 A7 00         mov bh, 0
0533   06E6             ; --- START RELATIONAL
0534   06E6 D7            push a
0535   06E7 11            mov a, b
0536   06E8 26 39 00      mov b, $39
0537   06EB B0            cmp a, b
0538   06EC FD 76         sleu ; <= (unsigned)
0539   06EE E4            pop a
0540   06EF             ; --- END RELATIONAL
0541   06EF FD A7         sand a, b
0542   06F1 E4            pop a
0543   06F2             ; --- END LOGICAL AND
0544   06F2 C0 00 00      cmp b, 0
0545   06F5 C6 30 07      je _while9_exit
0546   06F8             _while9_block:
0547   06F8             ; result = result * 10 + (*str - '0'); 
0548   06F8 FA FF FF      lea d, [bp + -1] ; $result
0549   06FB DA            push d
0550   06FC FA FF FF      lea d, [bp + -1] ; $result
0551   06FF 2A            mov b, [d]
0552   0700             ; --- START FACTORS
0553   0700 D7            push a
0554   0701 11            mov a, b
0555   0702 26 0A 00      mov b, $a
0556   0705 AC            mul a, b ; *
0557   0706 11            mov a, b
0558   0707 27            mov b, a
0559   0708 E4            pop a
0560   0709             ; --- END FACTORS
0561   0709             ; --- START TERMS
0562   0709 D7            push a
0563   070A 11            mov a, b
0564   070B FA 05 00      lea d, [bp + 5] ; $str
0565   070E 2A            mov b, [d]
0566   070F 74            mov d, b
0567   0710 32            mov bl, [d]
0568   0711 A7 00         mov bh, 0
0569   0713             ; --- START TERMS
0570   0713 D7            push a
0571   0714 11            mov a, b
0572   0715 26 30 00      mov b, $30
0573   0718 60            sub a, b
0574   0719 27            mov b, a
0575   071A E4            pop a
0576   071B             ; --- END TERMS
0577   071B 56            add b, a
0578   071C E4            pop a
0579   071D             ; --- END TERMS
0580   071D E7            pop d
0581   071E FD 43         mov [d], b
0582   0720             ; str++; 
0583   0720 FA 05 00      lea d, [bp + 5] ; $str
0584   0723 2A            mov b, [d]
0585   0724 FD 77         inc b
0586   0726 FA 05 00      lea d, [bp + 5] ; $str
0587   0729 FD 43         mov [d], b
0588   072B FD 7D         dec b
0589   072D 0A CB 06      jmp _while9_cond
0590   0730             _while9_exit:
0591   0730             ; return sign * result; 
0592   0730 FA FD FF      lea d, [bp + -3] ; $sign
0593   0733 2A            mov b, [d]
0594   0734             ; --- START FACTORS
0595   0734 D7            push a
0596   0735 11            mov a, b
0597   0736 FA FF FF      lea d, [bp + -1] ; $result
0598   0739 2A            mov b, [d]
0599   073A AC            mul a, b ; *
0600   073B 11            mov a, b
0601   073C 27            mov b, a
0602   073D E4            pop a
0603   073E             ; --- END FACTORS
0604   073E F9            leave
0605   073F 09            ret
0606   0740             
0607   0740             rand:
0608   0740 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0609   0743             ; int  sec; 
0610   0743 52 02 00      sub sp, 2
0611   0746             
0612   0746             ; --- BEGIN INLINE ASM SEGMENT
0613   0746 19 00         mov al, 0
0614   0748 05 01         syscall sys_rtc					
0615   074A 1A            mov al, ah
0616   074B FA FF FF      lea d, [bp + -1] ; $sec
0617   074E 1E            mov al, [d]
0618   074F 22 00         mov ah, 0
0619   0751             ; --- END INLINE ASM SEGMENT
0620   0751             
0621   0751             ; return sec; 
0622   0751 FA FF FF      lea d, [bp + -1] ; $sec
0623   0754 2A            mov b, [d]
0624   0755 F9            leave
0625   0756 09            ret
0626   0757             
0627   0757             alloc:
0628   0757 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0629   075A             ; heap_top = heap_top + bytes; 
0630   075A 3B C2 1F      mov d, _heap_top ; $heap_top
0631   075D DA            push d
0632   075E 3B C2 1F      mov d, _heap_top ; $heap_top
0633   0761 2A            mov b, [d]
0634   0762             ; --- START TERMS
0635   0762 D7            push a
0636   0763 11            mov a, b
0637   0764 FA 05 00      lea d, [bp + 5] ; $bytes
0638   0767 2A            mov b, [d]
0639   0768 56            add b, a
0640   0769 E4            pop a
0641   076A             ; --- END TERMS
0642   076A E7            pop d
0643   076B FD 43         mov [d], b
0644   076D             ; return heap_top - bytes; 
0645   076D 3B C2 1F      mov d, _heap_top ; $heap_top
0646   0770 2A            mov b, [d]
0647   0771             ; --- START TERMS
0648   0771 D7            push a
0649   0772 11            mov a, b
0650   0773 FA 05 00      lea d, [bp + 5] ; $bytes
0651   0776 2A            mov b, [d]
0652   0777 60            sub a, b
0653   0778 27            mov b, a
0654   0779 E4            pop a
0655   077A             ; --- END TERMS
0656   077A F9            leave
0657   077B 09            ret
0658   077C             
0659   077C             free:
0660   077C F8 00 00      enter 0 ; (push bp; mov bp, sp)
0661   077F             ; return heap_top = heap_top - bytes; 
0662   077F 3B C2 1F      mov d, _heap_top ; $heap_top
0663   0782 DA            push d
0664   0783 3B C2 1F      mov d, _heap_top ; $heap_top
0665   0786 2A            mov b, [d]
0666   0787             ; --- START TERMS
0667   0787 D7            push a
0668   0788 11            mov a, b
0669   0789 FA 05 00      lea d, [bp + 5] ; $bytes
0670   078C 2A            mov b, [d]
0671   078D 60            sub a, b
0672   078E 27            mov b, a
0673   078F E4            pop a
0674   0790             ; --- END TERMS
0675   0790 E7            pop d
0676   0791 FD 43         mov [d], b
0677   0793 F9            leave
0678   0794 09            ret
0679   0795             
0680   0795             fopen:
0681   0795 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0682   0798             ; FILE *fp; 
0683   0798 52 02 00      sub sp, 2
0684   079B             ; static int max_handle = 0; 
0685   079B 52 02 00      sub sp, 2
0686   079E             ; fp = alloc(sizeof(FILE)); 
0687   079E FA FF FF      lea d, [bp + -1] ; $fp
0688   07A1 DA            push d
0689   07A2 26 04 01      mov b, 260
0690   07A5 FD AB         swp b
0691   07A7 D8            push b
0692   07A8 07 57 07      call alloc
0693   07AB 51 02 00      add sp, 2
0694   07AE E7            pop d
0695   07AF FD 43         mov [d], b
0696   07B1             ; strcpy(fp->filename, filename); 
0697   07B1 FA 05 00      lea d, [bp + 5] ; $filename
0698   07B4 2A            mov b, [d]
0699   07B5 FD AB         swp b
0700   07B7 D8            push b
0701   07B8 FA FF FF      lea d, [bp + -1] ; $fp
0702   07BB FD 2A         mov d, [d]
0703   07BD 58 02 00      add d, 2
0704   07C0 2D            mov b, d
0705   07C1 FD AB         swp b
0706   07C3 D8            push b
0707   07C4 07 0A 04      call strcpy
0708   07C7 51 04 00      add sp, 4
0709   07CA             ; fp->handle = max_handle; 
0710   07CA FA FF FF      lea d, [bp + -1] ; $fp
0711   07CD FD 2A         mov d, [d]
0712   07CF 58 00 00      add d, 0
0713   07D2 DA            push d
0714   07D3 3B 7C 1F      mov d, st_fopen_max_handle ; static max_handle
0715   07D6 2A            mov b, [d]
0716   07D7 E7            pop d
0717   07D8 FD 43         mov [d], b
0718   07DA             ; fp->mode = mode; 
0719   07DA FA FF FF      lea d, [bp + -1] ; $fp
0720   07DD FD 2A         mov d, [d]
0721   07DF 58 02 01      add d, 258
0722   07E2 DA            push d
0723   07E3 FA 07 00      lea d, [bp + 7] ; $mode
0724   07E6 32            mov bl, [d]
0725   07E7 A7 00         mov bh, 0
0726   07E9 E7            pop d
0727   07EA FD 3E         mov [d], bl
0728   07EC             ; fp->loc = 0; 
0729   07EC FA FF FF      lea d, [bp + -1] ; $fp
0730   07EF FD 2A         mov d, [d]
0731   07F1 58 03 01      add d, 259
0732   07F4 DA            push d
0733   07F5 26 00 00      mov b, $0
0734   07F8 E7            pop d
0735   07F9 FD 3E         mov [d], bl
0736   07FB             ; max_handle++; 
0737   07FB 3B 7C 1F      mov d, st_fopen_max_handle ; static max_handle
0738   07FE 2A            mov b, [d]
0739   07FF FD 77         inc b
0740   0801 3B 7C 1F      mov d, st_fopen_max_handle ; static max_handle
0741   0804 FD 43         mov [d], b
0742   0806 FD 7D         dec b
0743   0808 F9            leave
0744   0809 09            ret
0745   080A             
0746   080A             fclose:
0747   080A F8 00 00      enter 0 ; (push bp; mov bp, sp)
0748   080D             ; free(sizeof(FILE)); 
0749   080D 26 04 01      mov b, 260
0750   0810 FD AB         swp b
0751   0812 D8            push b
0752   0813 07 7C 07      call free
0753   0816 51 02 00      add sp, 2
0754   0819 F9            leave
0755   081A 09            ret
0756   081B             
0757   081B             printf:
0758   081B F8 00 00      enter 0 ; (push bp; mov bp, sp)
0759   081E             ; char *p, *format_p; 
0760   081E 52 02 00      sub sp, 2
0761   0821 52 02 00      sub sp, 2
0762   0824             ; format_p = format; 
0763   0824 FA FD FF      lea d, [bp + -3] ; $format_p
0764   0827 DA            push d
0765   0828 FA 05 00      lea d, [bp + 5] ; $format
0766   082B 2A            mov b, [d]
0767   082C E7            pop d
0768   082D FD 43         mov [d], b
0769   082F             ; p = &format + 2; 
0770   082F FA FF FF      lea d, [bp + -1] ; $p
0771   0832 DA            push d
0772   0833 FA 05 00      lea d, [bp + 5] ; $format
0773   0836 2D            mov b, d
0774   0837             ; --- START TERMS
0775   0837 D7            push a
0776   0838 11            mov a, b
0777   0839 26 02 00      mov b, $2
0778   083C 56            add b, a
0779   083D E4            pop a
0780   083E             ; --- END TERMS
0781   083E E7            pop d
0782   083F FD 43         mov [d], b
0783   0841             ; for(;;){ 
0784   0841             _for10_init:
0785   0841             _for10_cond:
0786   0841             _for10_block:
0787   0841             ; if(!*format_p) break; 
0788   0841             _if11_cond:
0789   0841 FA FD FF      lea d, [bp + -3] ; $format_p
0790   0844 2A            mov b, [d]
0791   0845 74            mov d, b
0792   0846 32            mov bl, [d]
0793   0847 A7 00         mov bh, 0
0794   0849 C0 00 00      cmp b, 0
0795   084C FD 71         seq ; !
0796   084E C0 00 00      cmp b, 0
0797   0851 C6 5A 08      je _if11_else
0798   0854             _if11_true:
0799   0854             ; break; 
0800   0854 0A 81 0A      jmp _for10_exit ; for break
0801   0857 0A 7E 0A      jmp _if11_exit
0802   085A             _if11_else:
0803   085A             ; if(*format_p == '%'){ 
0804   085A             _if12_cond:
0805   085A FA FD FF      lea d, [bp + -3] ; $format_p
0806   085D 2A            mov b, [d]
0807   085E 74            mov d, b
0808   085F 32            mov bl, [d]
0809   0860 A7 00         mov bh, 0
0810   0862             ; --- START RELATIONAL
0811   0862 D7            push a
0812   0863 11            mov a, b
0813   0864 26 25 00      mov b, $25
0814   0867 B0            cmp a, b
0815   0868 FD 71         seq ; ==
0816   086A E4            pop a
0817   086B             ; --- END RELATIONAL
0818   086B C0 00 00      cmp b, 0
0819   086E C6 62 0A      je _if12_else
0820   0871             _if12_true:
0821   0871             ; format_p++; 
0822   0871 FA FD FF      lea d, [bp + -3] ; $format_p
0823   0874 2A            mov b, [d]
0824   0875 FD 77         inc b
0825   0877 FA FD FF      lea d, [bp + -3] ; $format_p
0826   087A FD 43         mov [d], b
0827   087C FD 7D         dec b
0828   087E             ; switch(*format_p){ 
0829   087E             _switch13_expr:
0830   087E FA FD FF      lea d, [bp + -3] ; $format_p
0831   0881 2A            mov b, [d]
0832   0882 74            mov d, b
0833   0883 32            mov bl, [d]
0834   0884 A7 00         mov bh, 0
0835   0886             _switch13_comparisons:
0836   0886 C1 6C         cmp bl, $6c
0837   0888 C6 B4 08      je _switch13_case0
0838   088B C1 4C         cmp bl, $4c
0839   088D C6 B4 08      je _switch13_case1
0840   0890 C1 64         cmp bl, $64
0841   0892 C6 A2 09      je _switch13_case2
0842   0895 C1 69         cmp bl, $69
0843   0897 C6 A2 09      je _switch13_case3
0844   089A C1 75         cmp bl, $75
0845   089C C6 C6 09      je _switch13_case4
0846   089F C1 78         cmp bl, $78
0847   08A1 C6 EA 09      je _switch13_case5
0848   08A4 C1 63         cmp bl, $63
0849   08A6 C6 08 0A      je _switch13_case6
0850   08A9 C1 73         cmp bl, $73
0851   08AB C6 27 0A      je _switch13_case7
0852   08AE 0A 46 0A      jmp _switch13_default
0853   08B1 0A 52 0A      jmp _switch13_exit
0854   08B4             _switch13_case0:
0855   08B4             _switch13_case1:
0856   08B4             ; format_p++; 
0857   08B4 FA FD FF      lea d, [bp + -3] ; $format_p
0858   08B7 2A            mov b, [d]
0859   08B8 FD 77         inc b
0860   08BA FA FD FF      lea d, [bp + -3] ; $format_p
0861   08BD FD 43         mov [d], b
0862   08BF FD 7D         dec b
0863   08C1             ; if(*format_p == 'd' || *format_p == 'i') 
0864   08C1             _if14_cond:
0865   08C1 FA FD FF      lea d, [bp + -3] ; $format_p
0866   08C4 2A            mov b, [d]
0867   08C5 74            mov d, b
0868   08C6 32            mov bl, [d]
0869   08C7 A7 00         mov bh, 0
0870   08C9             ; --- START RELATIONAL
0871   08C9 D7            push a
0872   08CA 11            mov a, b
0873   08CB 26 64 00      mov b, $64
0874   08CE B0            cmp a, b
0875   08CF FD 71         seq ; ==
0876   08D1 E4            pop a
0877   08D2             ; --- END RELATIONAL
0878   08D2             ; --- START LOGICAL OR
0879   08D2 D7            push a
0880   08D3 11            mov a, b
0881   08D4 FA FD FF      lea d, [bp + -3] ; $format_p
0882   08D7 2A            mov b, [d]
0883   08D8 74            mov d, b
0884   08D9 32            mov bl, [d]
0885   08DA A7 00         mov bh, 0
0886   08DC             ; --- START RELATIONAL
0887   08DC D7            push a
0888   08DD 11            mov a, b
0889   08DE 26 69 00      mov b, $69
0890   08E1 B0            cmp a, b
0891   08E2 FD 71         seq ; ==
0892   08E4 E4            pop a
0893   08E5             ; --- END RELATIONAL
0894   08E5 FD A8         sor a, b ; ||
0895   08E7 E4            pop a
0896   08E8             ; --- END LOGICAL OR
0897   08E8 C0 00 00      cmp b, 0
0898   08EB C6 10 09      je _if14_else
0899   08EE             _if14_true:
0900   08EE             ; print_signed_long(*(long *)p); 
0901   08EE FA FF FF      lea d, [bp + -1] ; $p
0902   08F1 2A            mov b, [d]
0903   08F2 AB            snex b
0904   08F3 FD 39         mov c, b
0905   08F5 74            mov d, b
0906   08F6 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0907   08F9 FD 39         mov c, b ; And place it into C
0908   08FB 2A            mov b, [d] ; Lower Word in B
0909   08FC FD 79         mov g, b
0910   08FE 28            mov b, c
0911   08FF FD AB         swp b
0912   0901 D8            push b
0913   0902 FD 27         mov b, g
0914   0904 FD AB         swp b
0915   0906 D8            push b
0916   0907 07 72 12      call print_signed_long
0917   090A 51 04 00      add sp, 4
0918   090D 0A 8D 09      jmp _if14_exit
0919   0910             _if14_else:
0920   0910             ; if(*format_p == 'u') 
0921   0910             _if15_cond:
0922   0910 FA FD FF      lea d, [bp + -3] ; $format_p
0923   0913 2A            mov b, [d]
0924   0914 74            mov d, b
0925   0915 32            mov bl, [d]
0926   0916 A7 00         mov bh, 0
0927   0918             ; --- START RELATIONAL
0928   0918 D7            push a
0929   0919 11            mov a, b
0930   091A 26 75 00      mov b, $75
0931   091D B0            cmp a, b
0932   091E FD 71         seq ; ==
0933   0920 E4            pop a
0934   0921             ; --- END RELATIONAL
0935   0921 C0 00 00      cmp b, 0
0936   0924 C6 4B 09      je _if15_else
0937   0927             _if15_true:
0938   0927             ; print_unsigned_long(*(unsigned long *)p); 
0939   0927 FA FF FF      lea d, [bp + -1] ; $p
0940   092A 2A            mov b, [d]
0941   092B A7 00         mov bh, 0
0942   092D 38 00 00      mov c, 0
0943   0930 74            mov d, b
0944   0931 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0945   0934 FD 39         mov c, b ; And place it into C
0946   0936 2A            mov b, [d] ; Lower Word in B
0947   0937 FD 79         mov g, b
0948   0939 28            mov b, c
0949   093A FD AB         swp b
0950   093C D8            push b
0951   093D FD 27         mov b, g
0952   093F FD AB         swp b
0953   0941 D8            push b
0954   0942 07 B2 15      call print_unsigned_long
0955   0945 51 04 00      add sp, 4
0956   0948 0A 8D 09      jmp _if15_exit
0957   094B             _if15_else:
0958   094B             ; if(*format_p == 'x') 
0959   094B             _if16_cond:
0960   094B FA FD FF      lea d, [bp + -3] ; $format_p
0961   094E 2A            mov b, [d]
0962   094F 74            mov d, b
0963   0950 32            mov bl, [d]
0964   0951 A7 00         mov bh, 0
0965   0953             ; --- START RELATIONAL
0966   0953 D7            push a
0967   0954 11            mov a, b
0968   0955 26 78 00      mov b, $78
0969   0958 B0            cmp a, b
0970   0959 FD 71         seq ; ==
0971   095B E4            pop a
0972   095C             ; --- END RELATIONAL
0973   095C C0 00 00      cmp b, 0
0974   095F C6 81 09      je _if16_else
0975   0962             _if16_true:
0976   0962             ; printx32(*(long int *)p); 
0977   0962 FA FF FF      lea d, [bp + -1] ; $p
0978   0965 2A            mov b, [d]
0979   0966 74            mov d, b
0980   0967 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0981   096A FD 39         mov c, b ; And place it into C
0982   096C 2A            mov b, [d] ; Lower Word in B
0983   096D FD 79         mov g, b
0984   096F 28            mov b, c
0985   0970 FD AB         swp b
0986   0972 D8            push b
0987   0973 FD 27         mov b, g
0988   0975 FD AB         swp b
0989   0977 D8            push b
0990   0978 07 E7 0F      call printx32
0991   097B 51 04 00      add sp, 4
0992   097E 0A 8D 09      jmp _if16_exit
0993   0981             _if16_else:
0994   0981             ; err("Unexpected format in printf."); 
0995   0981 26 7E 1F      mov b, _s0 ; "Unexpected format in printf."
0996   0984 FD AB         swp b
0997   0986 D8            push b
0998   0987 07 D5 0F      call err
0999   098A 51 02 00      add sp, 2
1000   098D             _if16_exit:
1001   098D             _if15_exit:
1002   098D             _if14_exit:
1003   098D             ; p = p + 4; 
1004   098D FA FF FF      lea d, [bp + -1] ; $p
1005   0990 DA            push d
1006   0991 FA FF FF      lea d, [bp + -1] ; $p
1007   0994 2A            mov b, [d]
1008   0995             ; --- START TERMS
1009   0995 D7            push a
1010   0996 11            mov a, b
1011   0997 26 04 00      mov b, $4
1012   099A 56            add b, a
1013   099B E4            pop a
1014   099C             ; --- END TERMS
1015   099C E7            pop d
1016   099D FD 43         mov [d], b
1017   099F             ; break; 
1018   099F 0A 52 0A      jmp _switch13_exit ; case break
1019   09A2             _switch13_case2:
1020   09A2             _switch13_case3:
1021   09A2             ; print_signed(*(int*)p); 
1022   09A2 FA FF FF      lea d, [bp + -1] ; $p
1023   09A5 2A            mov b, [d]
1024   09A6 74            mov d, b
1025   09A7 2A            mov b, [d]
1026   09A8 FD AB         swp b
1027   09AA D8            push b
1028   09AB 07 7B 11      call print_signed
1029   09AE 51 02 00      add sp, 2
1030   09B1             ; p = p + 2; 
1031   09B1 FA FF FF      lea d, [bp + -1] ; $p
1032   09B4 DA            push d
1033   09B5 FA FF FF      lea d, [bp + -1] ; $p
1034   09B8 2A            mov b, [d]
1035   09B9             ; --- START TERMS
1036   09B9 D7            push a
1037   09BA 11            mov a, b
1038   09BB 26 02 00      mov b, $2
1039   09BE 56            add b, a
1040   09BF E4            pop a
1041   09C0             ; --- END TERMS
1042   09C0 E7            pop d
1043   09C1 FD 43         mov [d], b
1044   09C3             ; break; 
1045   09C3 0A 52 0A      jmp _switch13_exit ; case break
1046   09C6             _switch13_case4:
1047   09C6             ; print_unsigned(*(unsigned int*)p); 
1048   09C6 FA FF FF      lea d, [bp + -1] ; $p
1049   09C9 2A            mov b, [d]
1050   09CA 74            mov d, b
1051   09CB 2A            mov b, [d]
1052   09CC FD AB         swp b
1053   09CE D8            push b
1054   09CF 07 B7 18      call print_unsigned
1055   09D2 51 02 00      add sp, 2
1056   09D5             ; p = p + 2; 
1057   09D5 FA FF FF      lea d, [bp + -1] ; $p
1058   09D8 DA            push d
1059   09D9 FA FF FF      lea d, [bp + -1] ; $p
1060   09DC 2A            mov b, [d]
1061   09DD             ; --- START TERMS
1062   09DD D7            push a
1063   09DE 11            mov a, b
1064   09DF 26 02 00      mov b, $2
1065   09E2 56            add b, a
1066   09E3 E4            pop a
1067   09E4             ; --- END TERMS
1068   09E4 E7            pop d
1069   09E5 FD 43         mov [d], b
1070   09E7             ; break; 
1071   09E7 0A 52 0A      jmp _switch13_exit ; case break
1072   09EA             _switch13_case5:
1073   09EA             
1074   09EA             ; --- BEGIN INLINE ASM SEGMENT
1075   09EA FA FF FF      lea d, [bp + -1] ; $p
1076   09ED FD 2A         mov d, [d]
1077   09EF 2A            mov b, [d]
1078   09F0 07 7C 1E      call print_u16x
1079   09F3             ; --- END INLINE ASM SEGMENT
1080   09F3             
1081   09F3             ; p = p + 2; 
1082   09F3 FA FF FF      lea d, [bp + -1] ; $p
1083   09F6 DA            push d
1084   09F7 FA FF FF      lea d, [bp + -1] ; $p
1085   09FA 2A            mov b, [d]
1086   09FB             ; --- START TERMS
1087   09FB D7            push a
1088   09FC 11            mov a, b
1089   09FD 26 02 00      mov b, $2
1090   0A00 56            add b, a
1091   0A01 E4            pop a
1092   0A02             ; --- END TERMS
1093   0A02 E7            pop d
1094   0A03 FD 43         mov [d], b
1095   0A05             ; break; 
1096   0A05 0A 52 0A      jmp _switch13_exit ; case break
1097   0A08             _switch13_case6:
1098   0A08             
1099   0A08             ; --- BEGIN INLINE ASM SEGMENT
1100   0A08 FA FF FF      lea d, [bp + -1] ; $p
1101   0A0B FD 2A         mov d, [d]
1102   0A0D 1E            mov al, [d]
1103   0A0E 23            mov ah, al
1104   0A0F 07 DA 1C      call _putchar
1105   0A12             ; --- END INLINE ASM SEGMENT
1106   0A12             
1107   0A12             ; p = p + 1; 
1108   0A12 FA FF FF      lea d, [bp + -1] ; $p
1109   0A15 DA            push d
1110   0A16 FA FF FF      lea d, [bp + -1] ; $p
1111   0A19 2A            mov b, [d]
1112   0A1A             ; --- START TERMS
1113   0A1A D7            push a
1114   0A1B 11            mov a, b
1115   0A1C 26 01 00      mov b, $1
1116   0A1F 56            add b, a
1117   0A20 E4            pop a
1118   0A21             ; --- END TERMS
1119   0A21 E7            pop d
1120   0A22 FD 43         mov [d], b
1121   0A24             ; break; 
1122   0A24 0A 52 0A      jmp _switch13_exit ; case break
1123   0A27             _switch13_case7:
1124   0A27             
1125   0A27             ; --- BEGIN INLINE ASM SEGMENT
1126   0A27 FA FF FF      lea d, [bp + -1] ; $p
1127   0A2A FD 2A         mov d, [d]
1128   0A2C FD 2A         mov d, [d]
1129   0A2E 07 24 1E      call _puts
1130   0A31             ; --- END INLINE ASM SEGMENT
1131   0A31             
1132   0A31             ; p = p + 2; 
1133   0A31 FA FF FF      lea d, [bp + -1] ; $p
1134   0A34 DA            push d
1135   0A35 FA FF FF      lea d, [bp + -1] ; $p
1136   0A38 2A            mov b, [d]
1137   0A39             ; --- START TERMS
1138   0A39 D7            push a
1139   0A3A 11            mov a, b
1140   0A3B 26 02 00      mov b, $2
1141   0A3E 56            add b, a
1142   0A3F E4            pop a
1143   0A40             ; --- END TERMS
1144   0A40 E7            pop d
1145   0A41 FD 43         mov [d], b
1146   0A43             ; break; 
1147   0A43 0A 52 0A      jmp _switch13_exit ; case break
1148   0A46             _switch13_default:
1149   0A46             ; print("Error: Unknown argument type.\n"); 
1150   0A46 26 9B 1F      mov b, _s1 ; "Error: Unknown argument type.\n"
1151   0A49 FD AB         swp b
1152   0A4B D8            push b
1153   0A4C 07 2B 1B      call print
1154   0A4F 51 02 00      add sp, 2
1155   0A52             _switch13_exit:
1156   0A52             ; format_p++; 
1157   0A52 FA FD FF      lea d, [bp + -3] ; $format_p
1158   0A55 2A            mov b, [d]
1159   0A56 FD 77         inc b
1160   0A58 FA FD FF      lea d, [bp + -3] ; $format_p
1161   0A5B FD 43         mov [d], b
1162   0A5D FD 7D         dec b
1163   0A5F 0A 7E 0A      jmp _if12_exit
1164   0A62             _if12_else:
1165   0A62             ; putchar(*format_p); 
1166   0A62 FA FD FF      lea d, [bp + -3] ; $format_p
1167   0A65 2A            mov b, [d]
1168   0A66 74            mov d, b
1169   0A67 32            mov bl, [d]
1170   0A68 A7 00         mov bh, 0
1171   0A6A DD            push bl
1172   0A6B 07 E3 1A      call putchar
1173   0A6E 51 01 00      add sp, 1
1174   0A71             ; format_p++; 
1175   0A71 FA FD FF      lea d, [bp + -3] ; $format_p
1176   0A74 2A            mov b, [d]
1177   0A75 FD 77         inc b
1178   0A77 FA FD FF      lea d, [bp + -3] ; $format_p
1179   0A7A FD 43         mov [d], b
1180   0A7C FD 7D         dec b
1181   0A7E             _if12_exit:
1182   0A7E             _if11_exit:
1183   0A7E             _for10_update:
1184   0A7E 0A 41 08      jmp _for10_cond
1185   0A81             _for10_exit:
1186   0A81 F9            leave
1187   0A82 09            ret
1188   0A83             
1189   0A83             scanf:
1190   0A83 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1191   0A86             ; char *p, *format_p; 
1192   0A86 52 02 00      sub sp, 2
1193   0A89 52 02 00      sub sp, 2
1194   0A8C             ; char c; 
1195   0A8C 52 01 00      sub sp, 1
1196   0A8F             ; int i; 
1197   0A8F 52 02 00      sub sp, 2
1198   0A92             ; char input_string[  512                    ]; 
1199   0A92 52 00 02      sub sp, 512
1200   0A95             ; format_p = format; 
1201   0A95 FA FD FF      lea d, [bp + -3] ; $format_p
1202   0A98 DA            push d
1203   0A99 FA 05 00      lea d, [bp + 5] ; $format
1204   0A9C 2A            mov b, [d]
1205   0A9D E7            pop d
1206   0A9E FD 43         mov [d], b
1207   0AA0             ; p = &format + 2; 
1208   0AA0 FA FF FF      lea d, [bp + -1] ; $p
1209   0AA3 DA            push d
1210   0AA4 FA 05 00      lea d, [bp + 5] ; $format
1211   0AA7 2D            mov b, d
1212   0AA8             ; --- START TERMS
1213   0AA8 D7            push a
1214   0AA9 11            mov a, b
1215   0AAA 26 02 00      mov b, $2
1216   0AAD 56            add b, a
1217   0AAE E4            pop a
1218   0AAF             ; --- END TERMS
1219   0AAF E7            pop d
1220   0AB0 FD 43         mov [d], b
1221   0AB2             ; for(;;){ 
1222   0AB2             _for17_init:
1223   0AB2             _for17_cond:
1224   0AB2             _for17_block:
1225   0AB2             ; if(!*format_p) break; 
1226   0AB2             _if18_cond:
1227   0AB2 FA FD FF      lea d, [bp + -3] ; $format_p
1228   0AB5 2A            mov b, [d]
1229   0AB6 74            mov d, b
1230   0AB7 32            mov bl, [d]
1231   0AB8 A7 00         mov bh, 0
1232   0ABA C0 00 00      cmp b, 0
1233   0ABD FD 71         seq ; !
1234   0ABF C0 00 00      cmp b, 0
1235   0AC2 C6 CB 0A      je _if18_else
1236   0AC5             _if18_true:
1237   0AC5             ; break; 
1238   0AC5 0A CC 0C      jmp _for17_exit ; for break
1239   0AC8 0A C9 0C      jmp _if18_exit
1240   0ACB             _if18_else:
1241   0ACB             ; if(*format_p == '%'){ 
1242   0ACB             _if19_cond:
1243   0ACB FA FD FF      lea d, [bp + -3] ; $format_p
1244   0ACE 2A            mov b, [d]
1245   0ACF 74            mov d, b
1246   0AD0 32            mov bl, [d]
1247   0AD1 A7 00         mov bh, 0
1248   0AD3             ; --- START RELATIONAL
1249   0AD3 D7            push a
1250   0AD4 11            mov a, b
1251   0AD5 26 25 00      mov b, $25
1252   0AD8 B0            cmp a, b
1253   0AD9 FD 71         seq ; ==
1254   0ADB E4            pop a
1255   0ADC             ; --- END RELATIONAL
1256   0ADC C0 00 00      cmp b, 0
1257   0ADF C6 AD 0C      je _if19_else
1258   0AE2             _if19_true:
1259   0AE2             ; format_p++; 
1260   0AE2 FA FD FF      lea d, [bp + -3] ; $format_p
1261   0AE5 2A            mov b, [d]
1262   0AE6 FD 77         inc b
1263   0AE8 FA FD FF      lea d, [bp + -3] ; $format_p
1264   0AEB FD 43         mov [d], b
1265   0AED FD 7D         dec b
1266   0AEF             ; switch(*format_p){ 
1267   0AEF             _switch20_expr:
1268   0AEF FA FD FF      lea d, [bp + -3] ; $format_p
1269   0AF2 2A            mov b, [d]
1270   0AF3 74            mov d, b
1271   0AF4 32            mov bl, [d]
1272   0AF5 A7 00         mov bh, 0
1273   0AF7             _switch20_comparisons:
1274   0AF7 C1 6C         cmp bl, $6c
1275   0AF9 C6 25 0B      je _switch20_case0
1276   0AFC C1 4C         cmp bl, $4c
1277   0AFE C6 25 0B      je _switch20_case1
1278   0B01 C1 64         cmp bl, $64
1279   0B03 C6 B7 0B      je _switch20_case2
1280   0B06 C1 69         cmp bl, $69
1281   0B08 C6 B7 0B      je _switch20_case3
1282   0B0B C1 75         cmp bl, $75
1283   0B0D C6 E4 0B      je _switch20_case4
1284   0B10 C1 78         cmp bl, $78
1285   0B12 C6 11 0C      je _switch20_case5
1286   0B15 C1 63         cmp bl, $63
1287   0B17 C6 26 0C      je _switch20_case6
1288   0B1A C1 73         cmp bl, $73
1289   0B1C C6 59 0C      je _switch20_case7
1290   0B1F 0A 91 0C      jmp _switch20_default
1291   0B22 0A 9D 0C      jmp _switch20_exit
1292   0B25             _switch20_case0:
1293   0B25             _switch20_case1:
1294   0B25             ; format_p++; 
1295   0B25 FA FD FF      lea d, [bp + -3] ; $format_p
1296   0B28 2A            mov b, [d]
1297   0B29 FD 77         inc b
1298   0B2B FA FD FF      lea d, [bp + -3] ; $format_p
1299   0B2E FD 43         mov [d], b
1300   0B30 FD 7D         dec b
1301   0B32             ; if(*format_p == 'd' || *format_p == 'i'); 
1302   0B32             _if21_cond:
1303   0B32 FA FD FF      lea d, [bp + -3] ; $format_p
1304   0B35 2A            mov b, [d]
1305   0B36 74            mov d, b
1306   0B37 32            mov bl, [d]
1307   0B38 A7 00         mov bh, 0
1308   0B3A             ; --- START RELATIONAL
1309   0B3A D7            push a
1310   0B3B 11            mov a, b
1311   0B3C 26 64 00      mov b, $64
1312   0B3F B0            cmp a, b
1313   0B40 FD 71         seq ; ==
1314   0B42 E4            pop a
1315   0B43             ; --- END RELATIONAL
1316   0B43             ; --- START LOGICAL OR
1317   0B43 D7            push a
1318   0B44 11            mov a, b
1319   0B45 FA FD FF      lea d, [bp + -3] ; $format_p
1320   0B48 2A            mov b, [d]
1321   0B49 74            mov d, b
1322   0B4A 32            mov bl, [d]
1323   0B4B A7 00         mov bh, 0
1324   0B4D             ; --- START RELATIONAL
1325   0B4D D7            push a
1326   0B4E 11            mov a, b
1327   0B4F 26 69 00      mov b, $69
1328   0B52 B0            cmp a, b
1329   0B53 FD 71         seq ; ==
1330   0B55 E4            pop a
1331   0B56             ; --- END RELATIONAL
1332   0B56 FD A8         sor a, b ; ||
1333   0B58 E4            pop a
1334   0B59             ; --- END LOGICAL OR
1335   0B59 C0 00 00      cmp b, 0
1336   0B5C C6 62 0B      je _if21_else
1337   0B5F             _if21_true:
1338   0B5F             ; ; 
1339   0B5F 0A A2 0B      jmp _if21_exit
1340   0B62             _if21_else:
1341   0B62             ; if(*format_p == 'u'); 
1342   0B62             _if22_cond:
1343   0B62 FA FD FF      lea d, [bp + -3] ; $format_p
1344   0B65 2A            mov b, [d]
1345   0B66 74            mov d, b
1346   0B67 32            mov bl, [d]
1347   0B68 A7 00         mov bh, 0
1348   0B6A             ; --- START RELATIONAL
1349   0B6A D7            push a
1350   0B6B 11            mov a, b
1351   0B6C 26 75 00      mov b, $75
1352   0B6F B0            cmp a, b
1353   0B70 FD 71         seq ; ==
1354   0B72 E4            pop a
1355   0B73             ; --- END RELATIONAL
1356   0B73 C0 00 00      cmp b, 0
1357   0B76 C6 7C 0B      je _if22_else
1358   0B79             _if22_true:
1359   0B79             ; ; 
1360   0B79 0A A2 0B      jmp _if22_exit
1361   0B7C             _if22_else:
1362   0B7C             ; if(*format_p == 'x'); 
1363   0B7C             _if23_cond:
1364   0B7C FA FD FF      lea d, [bp + -3] ; $format_p
1365   0B7F 2A            mov b, [d]
1366   0B80 74            mov d, b
1367   0B81 32            mov bl, [d]
1368   0B82 A7 00         mov bh, 0
1369   0B84             ; --- START RELATIONAL
1370   0B84 D7            push a
1371   0B85 11            mov a, b
1372   0B86 26 78 00      mov b, $78
1373   0B89 B0            cmp a, b
1374   0B8A FD 71         seq ; ==
1375   0B8C E4            pop a
1376   0B8D             ; --- END RELATIONAL
1377   0B8D C0 00 00      cmp b, 0
1378   0B90 C6 96 0B      je _if23_else
1379   0B93             _if23_true:
1380   0B93             ; ; 
1381   0B93 0A A2 0B      jmp _if23_exit
1382   0B96             _if23_else:
1383   0B96             ; err("Unexpected format in printf."); 
1384   0B96 26 7E 1F      mov b, _s0 ; "Unexpected format in printf."
1385   0B99 FD AB         swp b
1386   0B9B D8            push b
1387   0B9C 07 D5 0F      call err
1388   0B9F 51 02 00      add sp, 2
1389   0BA2             _if23_exit:
1390   0BA2             _if22_exit:
1391   0BA2             _if21_exit:
1392   0BA2             ; p = p + 4; 
1393   0BA2 FA FF FF      lea d, [bp + -1] ; $p
1394   0BA5 DA            push d
1395   0BA6 FA FF FF      lea d, [bp + -1] ; $p
1396   0BA9 2A            mov b, [d]
1397   0BAA             ; --- START TERMS
1398   0BAA D7            push a
1399   0BAB 11            mov a, b
1400   0BAC 26 04 00      mov b, $4
1401   0BAF 56            add b, a
1402   0BB0 E4            pop a
1403   0BB1             ; --- END TERMS
1404   0BB1 E7            pop d
1405   0BB2 FD 43         mov [d], b
1406   0BB4             ; break; 
1407   0BB4 0A 9D 0C      jmp _switch20_exit ; case break
1408   0BB7             _switch20_case2:
1409   0BB7             _switch20_case3:
1410   0BB7             ; i = scann(); 
1411   0BB7 FA FA FF      lea d, [bp + -6] ; $i
1412   0BBA DA            push d
1413   0BBB 07 06 1B      call scann
1414   0BBE E7            pop d
1415   0BBF FD 43         mov [d], b
1416   0BC1             ; **(int **)p = i; 
1417   0BC1 FA FF FF      lea d, [bp + -1] ; $p
1418   0BC4 2A            mov b, [d]
1419   0BC5 74            mov d, b
1420   0BC6 2A            mov b, [d]
1421   0BC7 D8            push b
1422   0BC8 FA FA FF      lea d, [bp + -6] ; $i
1423   0BCB 2A            mov b, [d]
1424   0BCC E7            pop d
1425   0BCD FD 43         mov [d], b
1426   0BCF             ; p = p + 2; 
1427   0BCF FA FF FF      lea d, [bp + -1] ; $p
1428   0BD2 DA            push d
1429   0BD3 FA FF FF      lea d, [bp + -1] ; $p
1430   0BD6 2A            mov b, [d]
1431   0BD7             ; --- START TERMS
1432   0BD7 D7            push a
1433   0BD8 11            mov a, b
1434   0BD9 26 02 00      mov b, $2
1435   0BDC 56            add b, a
1436   0BDD E4            pop a
1437   0BDE             ; --- END TERMS
1438   0BDE E7            pop d
1439   0BDF FD 43         mov [d], b
1440   0BE1             ; break; 
1441   0BE1 0A 9D 0C      jmp _switch20_exit ; case break
1442   0BE4             _switch20_case4:
1443   0BE4             ; i = scann(); 
1444   0BE4 FA FA FF      lea d, [bp + -6] ; $i
1445   0BE7 DA            push d
1446   0BE8 07 06 1B      call scann
1447   0BEB E7            pop d
1448   0BEC FD 43         mov [d], b
1449   0BEE             ; **(int **)p = i; 
1450   0BEE FA FF FF      lea d, [bp + -1] ; $p
1451   0BF1 2A            mov b, [d]
1452   0BF2 74            mov d, b
1453   0BF3 2A            mov b, [d]
1454   0BF4 D8            push b
1455   0BF5 FA FA FF      lea d, [bp + -6] ; $i
1456   0BF8 2A            mov b, [d]
1457   0BF9 E7            pop d
1458   0BFA FD 43         mov [d], b
1459   0BFC             ; p = p + 2; 
1460   0BFC FA FF FF      lea d, [bp + -1] ; $p
1461   0BFF DA            push d
1462   0C00 FA FF FF      lea d, [bp + -1] ; $p
1463   0C03 2A            mov b, [d]
1464   0C04             ; --- START TERMS
1465   0C04 D7            push a
1466   0C05 11            mov a, b
1467   0C06 26 02 00      mov b, $2
1468   0C09 56            add b, a
1469   0C0A E4            pop a
1470   0C0B             ; --- END TERMS
1471   0C0B E7            pop d
1472   0C0C FD 43         mov [d], b
1473   0C0E             ; break; 
1474   0C0E 0A 9D 0C      jmp _switch20_exit ; case break
1475   0C11             _switch20_case5:
1476   0C11             ; p = p + 2; 
1477   0C11 FA FF FF      lea d, [bp + -1] ; $p
1478   0C14 DA            push d
1479   0C15 FA FF FF      lea d, [bp + -1] ; $p
1480   0C18 2A            mov b, [d]
1481   0C19             ; --- START TERMS
1482   0C19 D7            push a
1483   0C1A 11            mov a, b
1484   0C1B 26 02 00      mov b, $2
1485   0C1E 56            add b, a
1486   0C1F E4            pop a
1487   0C20             ; --- END TERMS
1488   0C20 E7            pop d
1489   0C21 FD 43         mov [d], b
1490   0C23             ; break; 
1491   0C23 0A 9D 0C      jmp _switch20_exit ; case break
1492   0C26             _switch20_case6:
1493   0C26             ; c = getchar(); 
1494   0C26 FA FC FF      lea d, [bp + -4] ; $c
1495   0C29 DA            push d
1496   0C2A 07 F0 1A      call getchar
1497   0C2D E7            pop d
1498   0C2E FD 3E         mov [d], bl
1499   0C30             ; **(char **)p = *(char *)c; 
1500   0C30 FA FF FF      lea d, [bp + -1] ; $p
1501   0C33 2A            mov b, [d]
1502   0C34 74            mov d, b
1503   0C35 2A            mov b, [d]
1504   0C36 D8            push b
1505   0C37 FA FC FF      lea d, [bp + -4] ; $c
1506   0C3A 32            mov bl, [d]
1507   0C3B A7 00         mov bh, 0
1508   0C3D 74            mov d, b
1509   0C3E 32            mov bl, [d]
1510   0C3F A7 00         mov bh, 0
1511   0C41 E7            pop d
1512   0C42 FD 43         mov [d], b
1513   0C44             ; p = p + 1; 
1514   0C44 FA FF FF      lea d, [bp + -1] ; $p
1515   0C47 DA            push d
1516   0C48 FA FF FF      lea d, [bp + -1] ; $p
1517   0C4B 2A            mov b, [d]
1518   0C4C             ; --- START TERMS
1519   0C4C D7            push a
1520   0C4D 11            mov a, b
1521   0C4E 26 01 00      mov b, $1
1522   0C51 56            add b, a
1523   0C52 E4            pop a
1524   0C53             ; --- END TERMS
1525   0C53 E7            pop d
1526   0C54 FD 43         mov [d], b
1527   0C56             ; break; 
1528   0C56 0A 9D 0C      jmp _switch20_exit ; case break
1529   0C59             _switch20_case7:
1530   0C59             ; gets(input_string); 
1531   0C59 FA FA FD      lea d, [bp + -518] ; $input_string
1532   0C5C 2D            mov b, d
1533   0C5D FD AB         swp b
1534   0C5F D8            push b
1535   0C60 07 61 11      call gets
1536   0C63 51 02 00      add sp, 2
1537   0C66             ; strcpy(*(char **)p, input_string); 
1538   0C66 FA FA FD      lea d, [bp + -518] ; $input_string
1539   0C69 2D            mov b, d
1540   0C6A FD AB         swp b
1541   0C6C D8            push b
1542   0C6D FA FF FF      lea d, [bp + -1] ; $p
1543   0C70 2A            mov b, [d]
1544   0C71 74            mov d, b
1545   0C72 2A            mov b, [d]
1546   0C73 FD AB         swp b
1547   0C75 D8            push b
1548   0C76 07 0A 04      call strcpy
1549   0C79 51 04 00      add sp, 4
1550   0C7C             ; p = p + 2; 
1551   0C7C FA FF FF      lea d, [bp + -1] ; $p
1552   0C7F DA            push d
1553   0C80 FA FF FF      lea d, [bp + -1] ; $p
1554   0C83 2A            mov b, [d]
1555   0C84             ; --- START TERMS
1556   0C84 D7            push a
1557   0C85 11            mov a, b
1558   0C86 26 02 00      mov b, $2
1559   0C89 56            add b, a
1560   0C8A E4            pop a
1561   0C8B             ; --- END TERMS
1562   0C8B E7            pop d
1563   0C8C FD 43         mov [d], b
1564   0C8E             ; break; 
1565   0C8E 0A 9D 0C      jmp _switch20_exit ; case break
1566   0C91             _switch20_default:
1567   0C91             ; print("Error: Unknown argument type.\n"); 
1568   0C91 26 9B 1F      mov b, _s1 ; "Error: Unknown argument type.\n"
1569   0C94 FD AB         swp b
1570   0C96 D8            push b
1571   0C97 07 2B 1B      call print
1572   0C9A 51 02 00      add sp, 2
1573   0C9D             _switch20_exit:
1574   0C9D             ; format_p++; 
1575   0C9D FA FD FF      lea d, [bp + -3] ; $format_p
1576   0CA0 2A            mov b, [d]
1577   0CA1 FD 77         inc b
1578   0CA3 FA FD FF      lea d, [bp + -3] ; $format_p
1579   0CA6 FD 43         mov [d], b
1580   0CA8 FD 7D         dec b
1581   0CAA 0A C9 0C      jmp _if19_exit
1582   0CAD             _if19_else:
1583   0CAD             ; putchar(*format_p); 
1584   0CAD FA FD FF      lea d, [bp + -3] ; $format_p
1585   0CB0 2A            mov b, [d]
1586   0CB1 74            mov d, b
1587   0CB2 32            mov bl, [d]
1588   0CB3 A7 00         mov bh, 0
1589   0CB5 DD            push bl
1590   0CB6 07 E3 1A      call putchar
1591   0CB9 51 01 00      add sp, 1
1592   0CBC             ; format_p++; 
1593   0CBC FA FD FF      lea d, [bp + -3] ; $format_p
1594   0CBF 2A            mov b, [d]
1595   0CC0 FD 77         inc b
1596   0CC2 FA FD FF      lea d, [bp + -3] ; $format_p
1597   0CC5 FD 43         mov [d], b
1598   0CC7 FD 7D         dec b
1599   0CC9             _if19_exit:
1600   0CC9             _if18_exit:
1601   0CC9             _for17_update:
1602   0CC9 0A B2 0A      jmp _for17_cond
1603   0CCC             _for17_exit:
1604   0CCC F9            leave
1605   0CCD 09            ret
1606   0CCE             
1607   0CCE             sprintf:
1608   0CCE F8 00 00      enter 0 ; (push bp; mov bp, sp)
1609   0CD1             ; char *p, *format_p; 
1610   0CD1 52 02 00      sub sp, 2
1611   0CD4 52 02 00      sub sp, 2
1612   0CD7             ; char *sp; 
1613   0CD7 52 02 00      sub sp, 2
1614   0CDA             ; sp = dest; 
1615   0CDA FA FB FF      lea d, [bp + -5] ; $sp
1616   0CDD DA            push d
1617   0CDE FA 05 00      lea d, [bp + 5] ; $dest
1618   0CE1 2A            mov b, [d]
1619   0CE2 E7            pop d
1620   0CE3 FD 43         mov [d], b
1621   0CE5             ; format_p = format; 
1622   0CE5 FA FD FF      lea d, [bp + -3] ; $format_p
1623   0CE8 DA            push d
1624   0CE9 FA 07 00      lea d, [bp + 7] ; $format
1625   0CEC 2A            mov b, [d]
1626   0CED E7            pop d
1627   0CEE FD 43         mov [d], b
1628   0CF0             ; p = &format + 2; 
1629   0CF0 FA FF FF      lea d, [bp + -1] ; $p
1630   0CF3 DA            push d
1631   0CF4 FA 07 00      lea d, [bp + 7] ; $format
1632   0CF7 2D            mov b, d
1633   0CF8             ; --- START TERMS
1634   0CF8 D7            push a
1635   0CF9 11            mov a, b
1636   0CFA 26 02 00      mov b, $2
1637   0CFD 56            add b, a
1638   0CFE E4            pop a
1639   0CFF             ; --- END TERMS
1640   0CFF E7            pop d
1641   0D00 FD 43         mov [d], b
1642   0D02             ; for(;;){ 
1643   0D02             _for24_init:
1644   0D02             _for24_cond:
1645   0D02             _for24_block:
1646   0D02             ; if(!*format_p) break; 
1647   0D02             _if25_cond:
1648   0D02 FA FD FF      lea d, [bp + -3] ; $format_p
1649   0D05 2A            mov b, [d]
1650   0D06 74            mov d, b
1651   0D07 32            mov bl, [d]
1652   0D08 A7 00         mov bh, 0
1653   0D0A C0 00 00      cmp b, 0
1654   0D0D FD 71         seq ; !
1655   0D0F C0 00 00      cmp b, 0
1656   0D12 C6 1B 0D      je _if25_else
1657   0D15             _if25_true:
1658   0D15             ; break; 
1659   0D15 0A BB 0F      jmp _for24_exit ; for break
1660   0D18 0A B8 0F      jmp _if25_exit
1661   0D1B             _if25_else:
1662   0D1B             ; if(*format_p == '%'){ 
1663   0D1B             _if26_cond:
1664   0D1B FA FD FF      lea d, [bp + -3] ; $format_p
1665   0D1E 2A            mov b, [d]
1666   0D1F 74            mov d, b
1667   0D20 32            mov bl, [d]
1668   0D21 A7 00         mov bh, 0
1669   0D23             ; --- START RELATIONAL
1670   0D23 D7            push a
1671   0D24 11            mov a, b
1672   0D25 26 25 00      mov b, $25
1673   0D28 B0            cmp a, b
1674   0D29 FD 71         seq ; ==
1675   0D2B E4            pop a
1676   0D2C             ; --- END RELATIONAL
1677   0D2C C0 00 00      cmp b, 0
1678   0D2F C6 96 0F      je _if26_else
1679   0D32             _if26_true:
1680   0D32             ; format_p++; 
1681   0D32 FA FD FF      lea d, [bp + -3] ; $format_p
1682   0D35 2A            mov b, [d]
1683   0D36 FD 77         inc b
1684   0D38 FA FD FF      lea d, [bp + -3] ; $format_p
1685   0D3B FD 43         mov [d], b
1686   0D3D FD 7D         dec b
1687   0D3F             ; switch(*format_p){ 
1688   0D3F             _switch27_expr:
1689   0D3F FA FD FF      lea d, [bp + -3] ; $format_p
1690   0D42 2A            mov b, [d]
1691   0D43 74            mov d, b
1692   0D44 32            mov bl, [d]
1693   0D45 A7 00         mov bh, 0
1694   0D47             _switch27_comparisons:
1695   0D47 C1 6C         cmp bl, $6c
1696   0D49 C6 75 0D      je _switch27_case0
1697   0D4C C1 4C         cmp bl, $4c
1698   0D4E C6 75 0D      je _switch27_case1
1699   0D51 C1 64         cmp bl, $64
1700   0D53 C6 63 0E      je _switch27_case2
1701   0D56 C1 69         cmp bl, $69
1702   0D58 C6 63 0E      je _switch27_case3
1703   0D5B C1 75         cmp bl, $75
1704   0D5D C6 9D 0E      je _switch27_case4
1705   0D60 C1 78         cmp bl, $78
1706   0D62 C6 D7 0E      je _switch27_case5
1707   0D65 C1 63         cmp bl, $63
1708   0D67 C6 F5 0E      je _switch27_case6
1709   0D6A C1 73         cmp bl, $73
1710   0D6C C6 23 0F      je _switch27_case7
1711   0D6F 0A 7A 0F      jmp _switch27_default
1712   0D72 0A 86 0F      jmp _switch27_exit
1713   0D75             _switch27_case0:
1714   0D75             _switch27_case1:
1715   0D75             ; format_p++; 
1716   0D75 FA FD FF      lea d, [bp + -3] ; $format_p
1717   0D78 2A            mov b, [d]
1718   0D79 FD 77         inc b
1719   0D7B FA FD FF      lea d, [bp + -3] ; $format_p
1720   0D7E FD 43         mov [d], b
1721   0D80 FD 7D         dec b
1722   0D82             ; if(*format_p == 'd' || *format_p == 'i') 
1723   0D82             _if28_cond:
1724   0D82 FA FD FF      lea d, [bp + -3] ; $format_p
1725   0D85 2A            mov b, [d]
1726   0D86 74            mov d, b
1727   0D87 32            mov bl, [d]
1728   0D88 A7 00         mov bh, 0
1729   0D8A             ; --- START RELATIONAL
1730   0D8A D7            push a
1731   0D8B 11            mov a, b
1732   0D8C 26 64 00      mov b, $64
1733   0D8F B0            cmp a, b
1734   0D90 FD 71         seq ; ==
1735   0D92 E4            pop a
1736   0D93             ; --- END RELATIONAL
1737   0D93             ; --- START LOGICAL OR
1738   0D93 D7            push a
1739   0D94 11            mov a, b
1740   0D95 FA FD FF      lea d, [bp + -3] ; $format_p
1741   0D98 2A            mov b, [d]
1742   0D99 74            mov d, b
1743   0D9A 32            mov bl, [d]
1744   0D9B A7 00         mov bh, 0
1745   0D9D             ; --- START RELATIONAL
1746   0D9D D7            push a
1747   0D9E 11            mov a, b
1748   0D9F 26 69 00      mov b, $69
1749   0DA2 B0            cmp a, b
1750   0DA3 FD 71         seq ; ==
1751   0DA5 E4            pop a
1752   0DA6             ; --- END RELATIONAL
1753   0DA6 FD A8         sor a, b ; ||
1754   0DA8 E4            pop a
1755   0DA9             ; --- END LOGICAL OR
1756   0DA9 C0 00 00      cmp b, 0
1757   0DAC C6 D1 0D      je _if28_else
1758   0DAF             _if28_true:
1759   0DAF             ; print_signed_long(*(long *)p); 
1760   0DAF FA FF FF      lea d, [bp + -1] ; $p
1761   0DB2 2A            mov b, [d]
1762   0DB3 AB            snex b
1763   0DB4 FD 39         mov c, b
1764   0DB6 74            mov d, b
1765   0DB7 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1766   0DBA FD 39         mov c, b ; And place it into C
1767   0DBC 2A            mov b, [d] ; Lower Word in B
1768   0DBD FD 79         mov g, b
1769   0DBF 28            mov b, c
1770   0DC0 FD AB         swp b
1771   0DC2 D8            push b
1772   0DC3 FD 27         mov b, g
1773   0DC5 FD AB         swp b
1774   0DC7 D8            push b
1775   0DC8 07 72 12      call print_signed_long
1776   0DCB 51 04 00      add sp, 4
1777   0DCE 0A 4E 0E      jmp _if28_exit
1778   0DD1             _if28_else:
1779   0DD1             ; if(*format_p == 'u') 
1780   0DD1             _if29_cond:
1781   0DD1 FA FD FF      lea d, [bp + -3] ; $format_p
1782   0DD4 2A            mov b, [d]
1783   0DD5 74            mov d, b
1784   0DD6 32            mov bl, [d]
1785   0DD7 A7 00         mov bh, 0
1786   0DD9             ; --- START RELATIONAL
1787   0DD9 D7            push a
1788   0DDA 11            mov a, b
1789   0DDB 26 75 00      mov b, $75
1790   0DDE B0            cmp a, b
1791   0DDF FD 71         seq ; ==
1792   0DE1 E4            pop a
1793   0DE2             ; --- END RELATIONAL
1794   0DE2 C0 00 00      cmp b, 0
1795   0DE5 C6 0C 0E      je _if29_else
1796   0DE8             _if29_true:
1797   0DE8             ; print_unsigned_long(*(unsigned long *)p); 
1798   0DE8 FA FF FF      lea d, [bp + -1] ; $p
1799   0DEB 2A            mov b, [d]
1800   0DEC A7 00         mov bh, 0
1801   0DEE 38 00 00      mov c, 0
1802   0DF1 74            mov d, b
1803   0DF2 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1804   0DF5 FD 39         mov c, b ; And place it into C
1805   0DF7 2A            mov b, [d] ; Lower Word in B
1806   0DF8 FD 79         mov g, b
1807   0DFA 28            mov b, c
1808   0DFB FD AB         swp b
1809   0DFD D8            push b
1810   0DFE FD 27         mov b, g
1811   0E00 FD AB         swp b
1812   0E02 D8            push b
1813   0E03 07 B2 15      call print_unsigned_long
1814   0E06 51 04 00      add sp, 4
1815   0E09 0A 4E 0E      jmp _if29_exit
1816   0E0C             _if29_else:
1817   0E0C             ; if(*format_p == 'x') 
1818   0E0C             _if30_cond:
1819   0E0C FA FD FF      lea d, [bp + -3] ; $format_p
1820   0E0F 2A            mov b, [d]
1821   0E10 74            mov d, b
1822   0E11 32            mov bl, [d]
1823   0E12 A7 00         mov bh, 0
1824   0E14             ; --- START RELATIONAL
1825   0E14 D7            push a
1826   0E15 11            mov a, b
1827   0E16 26 78 00      mov b, $78
1828   0E19 B0            cmp a, b
1829   0E1A FD 71         seq ; ==
1830   0E1C E4            pop a
1831   0E1D             ; --- END RELATIONAL
1832   0E1D C0 00 00      cmp b, 0
1833   0E20 C6 42 0E      je _if30_else
1834   0E23             _if30_true:
1835   0E23             ; printx32(*(long int *)p); 
1836   0E23 FA FF FF      lea d, [bp + -1] ; $p
1837   0E26 2A            mov b, [d]
1838   0E27 74            mov d, b
1839   0E28 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1840   0E2B FD 39         mov c, b ; And place it into C
1841   0E2D 2A            mov b, [d] ; Lower Word in B
1842   0E2E FD 79         mov g, b
1843   0E30 28            mov b, c
1844   0E31 FD AB         swp b
1845   0E33 D8            push b
1846   0E34 FD 27         mov b, g
1847   0E36 FD AB         swp b
1848   0E38 D8            push b
1849   0E39 07 E7 0F      call printx32
1850   0E3C 51 04 00      add sp, 4
1851   0E3F 0A 4E 0E      jmp _if30_exit
1852   0E42             _if30_else:
1853   0E42             ; err("Unexpected format in printf."); 
1854   0E42 26 7E 1F      mov b, _s0 ; "Unexpected format in printf."
1855   0E45 FD AB         swp b
1856   0E47 D8            push b
1857   0E48 07 D5 0F      call err
1858   0E4B 51 02 00      add sp, 2
1859   0E4E             _if30_exit:
1860   0E4E             _if29_exit:
1861   0E4E             _if28_exit:
1862   0E4E             ; p = p + 4; 
1863   0E4E FA FF FF      lea d, [bp + -1] ; $p
1864   0E51 DA            push d
1865   0E52 FA FF FF      lea d, [bp + -1] ; $p
1866   0E55 2A            mov b, [d]
1867   0E56             ; --- START TERMS
1868   0E56 D7            push a
1869   0E57 11            mov a, b
1870   0E58 26 04 00      mov b, $4
1871   0E5B 56            add b, a
1872   0E5C E4            pop a
1873   0E5D             ; --- END TERMS
1874   0E5D E7            pop d
1875   0E5E FD 43         mov [d], b
1876   0E60             ; break; 
1877   0E60 0A 86 0F      jmp _switch27_exit ; case break
1878   0E63             _switch27_case2:
1879   0E63             _switch27_case3:
1880   0E63             ; sp = sp + sprint_signed(sp, *(int*)p); 
1881   0E63 FA FB FF      lea d, [bp + -5] ; $sp
1882   0E66 DA            push d
1883   0E67 FA FB FF      lea d, [bp + -5] ; $sp
1884   0E6A 2A            mov b, [d]
1885   0E6B             ; --- START TERMS
1886   0E6B D7            push a
1887   0E6C 11            mov a, b
1888   0E6D FA FF FF      lea d, [bp + -1] ; $p
1889   0E70 2A            mov b, [d]
1890   0E71 74            mov d, b
1891   0E72 2A            mov b, [d]
1892   0E73 FD AB         swp b
1893   0E75 D8            push b
1894   0E76 FA FB FF      lea d, [bp + -5] ; $sp
1895   0E79 2A            mov b, [d]
1896   0E7A FD AB         swp b
1897   0E7C D8            push b
1898   0E7D 07 81 19      call sprint_signed
1899   0E80 51 04 00      add sp, 4
1900   0E83 56            add b, a
1901   0E84 E4            pop a
1902   0E85             ; --- END TERMS
1903   0E85 E7            pop d
1904   0E86 FD 43         mov [d], b
1905   0E88             ; p = p + 2; 
1906   0E88 FA FF FF      lea d, [bp + -1] ; $p
1907   0E8B DA            push d
1908   0E8C FA FF FF      lea d, [bp + -1] ; $p
1909   0E8F 2A            mov b, [d]
1910   0E90             ; --- START TERMS
1911   0E90 D7            push a
1912   0E91 11            mov a, b
1913   0E92 26 02 00      mov b, $2
1914   0E95 56            add b, a
1915   0E96 E4            pop a
1916   0E97             ; --- END TERMS
1917   0E97 E7            pop d
1918   0E98 FD 43         mov [d], b
1919   0E9A             ; break; 
1920   0E9A 0A 86 0F      jmp _switch27_exit ; case break
1921   0E9D             _switch27_case4:
1922   0E9D             ; sp = sp + sprint_unsigned(sp, *(unsigned int*)p); 
1923   0E9D FA FB FF      lea d, [bp + -5] ; $sp
1924   0EA0 DA            push d
1925   0EA1 FA FB FF      lea d, [bp + -5] ; $sp
1926   0EA4 2A            mov b, [d]
1927   0EA5             ; --- START TERMS
1928   0EA5 D7            push a
1929   0EA6 11            mov a, b
1930   0EA7 FA FF FF      lea d, [bp + -1] ; $p
1931   0EAA 2A            mov b, [d]
1932   0EAB 74            mov d, b
1933   0EAC 2A            mov b, [d]
1934   0EAD FD AB         swp b
1935   0EAF D8            push b
1936   0EB0 FA FB FF      lea d, [bp + -5] ; $sp
1937   0EB3 2A            mov b, [d]
1938   0EB4 FD AB         swp b
1939   0EB6 D8            push b
1940   0EB7 07 AD 17      call sprint_unsigned
1941   0EBA 51 04 00      add sp, 4
1942   0EBD 56            add b, a
1943   0EBE E4            pop a
1944   0EBF             ; --- END TERMS
1945   0EBF E7            pop d
1946   0EC0 FD 43         mov [d], b
1947   0EC2             ; p = p + 2; 
1948   0EC2 FA FF FF      lea d, [bp + -1] ; $p
1949   0EC5 DA            push d
1950   0EC6 FA FF FF      lea d, [bp + -1] ; $p
1951   0EC9 2A            mov b, [d]
1952   0ECA             ; --- START TERMS
1953   0ECA D7            push a
1954   0ECB 11            mov a, b
1955   0ECC 26 02 00      mov b, $2
1956   0ECF 56            add b, a
1957   0ED0 E4            pop a
1958   0ED1             ; --- END TERMS
1959   0ED1 E7            pop d
1960   0ED2 FD 43         mov [d], b
1961   0ED4             ; break; 
1962   0ED4 0A 86 0F      jmp _switch27_exit ; case break
1963   0ED7             _switch27_case5:
1964   0ED7             
1965   0ED7             ; --- BEGIN INLINE ASM SEGMENT
1966   0ED7 FA FF FF      lea d, [bp + -1] ; $p
1967   0EDA FD 2A         mov d, [d]
1968   0EDC 2A            mov b, [d]
1969   0EDD 07 7C 1E      call print_u16x
1970   0EE0             ; --- END INLINE ASM SEGMENT
1971   0EE0             
1972   0EE0             ; p = p + 2; 
1973   0EE0 FA FF FF      lea d, [bp + -1] ; $p
1974   0EE3 DA            push d
1975   0EE4 FA FF FF      lea d, [bp + -1] ; $p
1976   0EE7 2A            mov b, [d]
1977   0EE8             ; --- START TERMS
1978   0EE8 D7            push a
1979   0EE9 11            mov a, b
1980   0EEA 26 02 00      mov b, $2
1981   0EED 56            add b, a
1982   0EEE E4            pop a
1983   0EEF             ; --- END TERMS
1984   0EEF E7            pop d
1985   0EF0 FD 43         mov [d], b
1986   0EF2             ; break; 
1987   0EF2 0A 86 0F      jmp _switch27_exit ; case break
1988   0EF5             _switch27_case6:
1989   0EF5             ; *sp++ = *(char *)p; 
1990   0EF5 FA FB FF      lea d, [bp + -5] ; $sp
1991   0EF8 2A            mov b, [d]
1992   0EF9 FD 77         inc b
1993   0EFB FA FB FF      lea d, [bp + -5] ; $sp
1994   0EFE FD 43         mov [d], b
1995   0F00 FD 7D         dec b
1996   0F02 D8            push b
1997   0F03 FA FF FF      lea d, [bp + -1] ; $p
1998   0F06 2A            mov b, [d]
1999   0F07 74            mov d, b
2000   0F08 32            mov bl, [d]
2001   0F09 A7 00         mov bh, 0
2002   0F0B E7            pop d
2003   0F0C FD 3E         mov [d], bl
2004   0F0E             ; p = p + 1; 
2005   0F0E FA FF FF      lea d, [bp + -1] ; $p
2006   0F11 DA            push d
2007   0F12 FA FF FF      lea d, [bp + -1] ; $p
2008   0F15 2A            mov b, [d]
2009   0F16             ; --- START TERMS
2010   0F16 D7            push a
2011   0F17 11            mov a, b
2012   0F18 26 01 00      mov b, $1
2013   0F1B 56            add b, a
2014   0F1C E4            pop a
2015   0F1D             ; --- END TERMS
2016   0F1D E7            pop d
2017   0F1E FD 43         mov [d], b
2018   0F20             ; break; 
2019   0F20 0A 86 0F      jmp _switch27_exit ; case break
2020   0F23             _switch27_case7:
2021   0F23             ; int len = strlen(*(char **)p); 
2022   0F23 52 02 00      sub sp, 2
2023   0F26             ; --- START LOCAL VAR INITIALIZATION
2024   0F26 FA F9 FF      lea d, [bp + -7] ; $len
2025   0F29 DA            push d
2026   0F2A FA FF FF      lea d, [bp + -1] ; $p
2027   0F2D 2A            mov b, [d]
2028   0F2E 74            mov d, b
2029   0F2F 2A            mov b, [d]
2030   0F30 FD AB         swp b
2031   0F32 D8            push b
2032   0F33 07 84 05      call strlen
2033   0F36 51 02 00      add sp, 2
2034   0F39 E7            pop d
2035   0F3A FD 43         mov [d], b
2036   0F3C             ; --- END LOCAL VAR INITIALIZATION
2037   0F3C             ; strcpy(sp, *(char **)p); 
2038   0F3C FA FF FF      lea d, [bp + -1] ; $p
2039   0F3F 2A            mov b, [d]
2040   0F40 74            mov d, b
2041   0F41 2A            mov b, [d]
2042   0F42 FD AB         swp b
2043   0F44 D8            push b
2044   0F45 FA FB FF      lea d, [bp + -5] ; $sp
2045   0F48 2A            mov b, [d]
2046   0F49 FD AB         swp b
2047   0F4B D8            push b
2048   0F4C 07 0A 04      call strcpy
2049   0F4F 51 04 00      add sp, 4
2050   0F52             ; sp = sp + len; 
2051   0F52 FA FB FF      lea d, [bp + -5] ; $sp
2052   0F55 DA            push d
2053   0F56 FA FB FF      lea d, [bp + -5] ; $sp
2054   0F59 2A            mov b, [d]
2055   0F5A             ; --- START TERMS
2056   0F5A D7            push a
2057   0F5B 11            mov a, b
2058   0F5C FA F9 FF      lea d, [bp + -7] ; $len
2059   0F5F 2A            mov b, [d]
2060   0F60 56            add b, a
2061   0F61 E4            pop a
2062   0F62             ; --- END TERMS
2063   0F62 E7            pop d
2064   0F63 FD 43         mov [d], b
2065   0F65             ; p = p + 2; 
2066   0F65 FA FF FF      lea d, [bp + -1] ; $p
2067   0F68 DA            push d
2068   0F69 FA FF FF      lea d, [bp + -1] ; $p
2069   0F6C 2A            mov b, [d]
2070   0F6D             ; --- START TERMS
2071   0F6D D7            push a
2072   0F6E 11            mov a, b
2073   0F6F 26 02 00      mov b, $2
2074   0F72 56            add b, a
2075   0F73 E4            pop a
2076   0F74             ; --- END TERMS
2077   0F74 E7            pop d
2078   0F75 FD 43         mov [d], b
2079   0F77             ; break; 
2080   0F77 0A 86 0F      jmp _switch27_exit ; case break
2081   0F7A             _switch27_default:
2082   0F7A             ; print("Error: Unknown argument type.\n"); 
2083   0F7A 26 9B 1F      mov b, _s1 ; "Error: Unknown argument type.\n"
2084   0F7D FD AB         swp b
2085   0F7F D8            push b
2086   0F80 07 2B 1B      call print
2087   0F83 51 02 00      add sp, 2
2088   0F86             _switch27_exit:
2089   0F86             ; format_p++; 
2090   0F86 FA FD FF      lea d, [bp + -3] ; $format_p
2091   0F89 2A            mov b, [d]
2092   0F8A FD 77         inc b
2093   0F8C FA FD FF      lea d, [bp + -3] ; $format_p
2094   0F8F FD 43         mov [d], b
2095   0F91 FD 7D         dec b
2096   0F93 0A B8 0F      jmp _if26_exit
2097   0F96             _if26_else:
2098   0F96             ; *sp++ = *format_p++; 
2099   0F96 FA FB FF      lea d, [bp + -5] ; $sp
2100   0F99 2A            mov b, [d]
2101   0F9A FD 77         inc b
2102   0F9C FA FB FF      lea d, [bp + -5] ; $sp
2103   0F9F FD 43         mov [d], b
2104   0FA1 FD 7D         dec b
2105   0FA3 D8            push b
2106   0FA4 FA FD FF      lea d, [bp + -3] ; $format_p
2107   0FA7 2A            mov b, [d]
2108   0FA8 FD 77         inc b
2109   0FAA FA FD FF      lea d, [bp + -3] ; $format_p
2110   0FAD FD 43         mov [d], b
2111   0FAF FD 7D         dec b
2112   0FB1 74            mov d, b
2113   0FB2 32            mov bl, [d]
2114   0FB3 A7 00         mov bh, 0
2115   0FB5 E7            pop d
2116   0FB6 FD 3E         mov [d], bl
2117   0FB8             _if26_exit:
2118   0FB8             _if25_exit:
2119   0FB8             _for24_update:
2120   0FB8 0A 02 0D      jmp _for24_cond
2121   0FBB             _for24_exit:
2122   0FBB             ; *sp = '\0'; 
2123   0FBB FA FB FF      lea d, [bp + -5] ; $sp
2124   0FBE 2A            mov b, [d]
2125   0FBF D8            push b
2126   0FC0 26 00 00      mov b, $0
2127   0FC3 E7            pop d
2128   0FC4 FD 3E         mov [d], bl
2129   0FC6             ; return sp - dest; // return total number of chars written 
2130   0FC6 FA FB FF      lea d, [bp + -5] ; $sp
2131   0FC9 2A            mov b, [d]
2132   0FCA             ; --- START TERMS
2133   0FCA D7            push a
2134   0FCB 11            mov a, b
2135   0FCC FA 05 00      lea d, [bp + 5] ; $dest
2136   0FCF 2A            mov b, [d]
2137   0FD0 60            sub a, b
2138   0FD1 27            mov b, a
2139   0FD2 E4            pop a
2140   0FD3             ; --- END TERMS
2141   0FD3 F9            leave
2142   0FD4 09            ret
2143   0FD5             
2144   0FD5             err:
2145   0FD5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2146   0FD8             ; print(e); 
2147   0FD8 FA 05 00      lea d, [bp + 5] ; $e
2148   0FDB 2A            mov b, [d]
2149   0FDC FD AB         swp b
2150   0FDE D8            push b
2151   0FDF 07 2B 1B      call print
2152   0FE2 51 02 00      add sp, 2
2153   0FE5 F9            leave
2154   0FE6 09            ret
2155   0FE7             
2156   0FE7             printx32:
2157   0FE7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2158   0FEA             
2159   0FEA             ; --- BEGIN INLINE ASM SEGMENT
2160   0FEA FA 05 00      lea d, [bp + 5] ; $hex
2161   0FED 2B 02 00      mov b, [d+2]
2162   0FF0 07 7C 1E      call print_u16x
2163   0FF3 2A            mov b, [d]
2164   0FF4 07 7C 1E      call print_u16x
2165   0FF7             ; --- END INLINE ASM SEGMENT
2166   0FF7             
2167   0FF7 F9            leave
2168   0FF8 09            ret
2169   0FF9             
2170   0FF9             printx16:
2171   0FF9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2172   0FFC             
2173   0FFC             ; --- BEGIN INLINE ASM SEGMENT
2174   0FFC FA 05 00      lea d, [bp + 5] ; $hex
2175   0FFF 2A            mov b, [d]
2176   1000 07 7C 1E      call print_u16x
2177   1003             ; --- END INLINE ASM SEGMENT
2178   1003             
2179   1003 F9            leave
2180   1004 09            ret
2181   1005             
2182   1005             printx8:
2183   1005 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2184   1008             
2185   1008             ; --- BEGIN INLINE ASM SEGMENT
2186   1008 FA 05 00      lea d, [bp + 5] ; $hex
2187   100B 32            mov bl, [d]
2188   100C 07 C0 1E      call print_u8x
2189   100F             ; --- END INLINE ASM SEGMENT
2190   100F             
2191   100F F9            leave
2192   1010 09            ret
2193   1011             
2194   1011             hex_str_to_int:
2195   1011 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2196   1014             ; int value = 0; 
2197   1014 52 02 00      sub sp, 2
2198   1017             ; --- START LOCAL VAR INITIALIZATION
2199   1017 FA FF FF      lea d, [bp + -1] ; $value
2200   101A DA            push d
2201   101B 26 00 00      mov b, $0
2202   101E E7            pop d
2203   101F FD 43         mov [d], b
2204   1021             ; --- END LOCAL VAR INITIALIZATION
2205   1021             ; int i; 
2206   1021 52 02 00      sub sp, 2
2207   1024             ; char hex_char; 
2208   1024 52 01 00      sub sp, 1
2209   1027             ; int len; 
2210   1027 52 02 00      sub sp, 2
2211   102A             ; len = strlen(hex_string); 
2212   102A FA FA FF      lea d, [bp + -6] ; $len
2213   102D DA            push d
2214   102E FA 05 00      lea d, [bp + 5] ; $hex_string
2215   1031 2A            mov b, [d]
2216   1032 FD AB         swp b
2217   1034 D8            push b
2218   1035 07 84 05      call strlen
2219   1038 51 02 00      add sp, 2
2220   103B E7            pop d
2221   103C FD 43         mov [d], b
2222   103E             ; for (i = 0; i < len; i++) { 
2223   103E             _for31_init:
2224   103E FA FD FF      lea d, [bp + -3] ; $i
2225   1041 DA            push d
2226   1042 26 00 00      mov b, $0
2227   1045 E7            pop d
2228   1046 FD 43         mov [d], b
2229   1048             _for31_cond:
2230   1048 FA FD FF      lea d, [bp + -3] ; $i
2231   104B 2A            mov b, [d]
2232   104C             ; --- START RELATIONAL
2233   104C D7            push a
2234   104D 11            mov a, b
2235   104E FA FA FF      lea d, [bp + -6] ; $len
2236   1051 2A            mov b, [d]
2237   1052 B0            cmp a, b
2238   1053 FD 73         slt ; < (signed)
2239   1055 E4            pop a
2240   1056             ; --- END RELATIONAL
2241   1056 C0 00 00      cmp b, 0
2242   1059 C6 5B 11      je _for31_exit
2243   105C             _for31_block:
2244   105C             ; hex_char = hex_string[i]; 
2245   105C FA FC FF      lea d, [bp + -4] ; $hex_char
2246   105F DA            push d
2247   1060 FA 05 00      lea d, [bp + 5] ; $hex_string
2248   1063 FD 2A         mov d, [d]
2249   1065 D7            push a
2250   1066 DA            push d
2251   1067 FA FD FF      lea d, [bp + -3] ; $i
2252   106A 2A            mov b, [d]
2253   106B E7            pop d
2254   106C FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
2255   1070 E4            pop a
2256   1071 32            mov bl, [d]
2257   1072 A7 00         mov bh, 0
2258   1074 E7            pop d
2259   1075 FD 3E         mov [d], bl
2260   1077             ; if (hex_char >= 'a' && hex_char <= 'f')  
2261   1077             _if32_cond:
2262   1077 FA FC FF      lea d, [bp + -4] ; $hex_char
2263   107A 32            mov bl, [d]
2264   107B A7 00         mov bh, 0
2265   107D             ; --- START RELATIONAL
2266   107D D7            push a
2267   107E 11            mov a, b
2268   107F 26 61 00      mov b, $61
2269   1082 B0            cmp a, b
2270   1083 FD 80         sge ; >=
2271   1085 E4            pop a
2272   1086             ; --- END RELATIONAL
2273   1086             ; --- START LOGICAL AND
2274   1086 D7            push a
2275   1087 11            mov a, b
2276   1088 FA FC FF      lea d, [bp + -4] ; $hex_char
2277   108B 32            mov bl, [d]
2278   108C A7 00         mov bh, 0
2279   108E             ; --- START RELATIONAL
2280   108E D7            push a
2281   108F 11            mov a, b
2282   1090 26 66 00      mov b, $66
2283   1093 B0            cmp a, b
2284   1094 FD 74         sle ; <= (signed)
2285   1096 E4            pop a
2286   1097             ; --- END RELATIONAL
2287   1097 FD A7         sand a, b
2288   1099 E4            pop a
2289   109A             ; --- END LOGICAL AND
2290   109A C0 00 00      cmp b, 0
2291   109D C6 CE 10      je _if32_else
2292   10A0             _if32_true:
2293   10A0             ; value = (value * 16) + (hex_char - 'a' + 10); 
2294   10A0 FA FF FF      lea d, [bp + -1] ; $value
2295   10A3 DA            push d
2296   10A4 FA FF FF      lea d, [bp + -1] ; $value
2297   10A7 2A            mov b, [d]
2298   10A8             ; --- START FACTORS
2299   10A8 D7            push a
2300   10A9 11            mov a, b
2301   10AA 26 10 00      mov b, $10
2302   10AD AC            mul a, b ; *
2303   10AE 11            mov a, b
2304   10AF 27            mov b, a
2305   10B0 E4            pop a
2306   10B1             ; --- END FACTORS
2307   10B1             ; --- START TERMS
2308   10B1 D7            push a
2309   10B2 11            mov a, b
2310   10B3 FA FC FF      lea d, [bp + -4] ; $hex_char
2311   10B6 32            mov bl, [d]
2312   10B7 A7 00         mov bh, 0
2313   10B9             ; --- START TERMS
2314   10B9 D7            push a
2315   10BA 11            mov a, b
2316   10BB 26 61 00      mov b, $61
2317   10BE 60            sub a, b
2318   10BF 27            mov b, a
2319   10C0 11            mov a, b
2320   10C1 26 0A 00      mov b, $a
2321   10C4 56            add b, a
2322   10C5 E4            pop a
2323   10C6             ; --- END TERMS
2324   10C6 56            add b, a
2325   10C7 E4            pop a
2326   10C8             ; --- END TERMS
2327   10C8 E7            pop d
2328   10C9 FD 43         mov [d], b
2329   10CB 0A 4B 11      jmp _if32_exit
2330   10CE             _if32_else:
2331   10CE             ; if (hex_char >= 'A' && hex_char <= 'F')  
2332   10CE             _if33_cond:
2333   10CE FA FC FF      lea d, [bp + -4] ; $hex_char
2334   10D1 32            mov bl, [d]
2335   10D2 A7 00         mov bh, 0
2336   10D4             ; --- START RELATIONAL
2337   10D4 D7            push a
2338   10D5 11            mov a, b
2339   10D6 26 41 00      mov b, $41
2340   10D9 B0            cmp a, b
2341   10DA FD 80         sge ; >=
2342   10DC E4            pop a
2343   10DD             ; --- END RELATIONAL
2344   10DD             ; --- START LOGICAL AND
2345   10DD D7            push a
2346   10DE 11            mov a, b
2347   10DF FA FC FF      lea d, [bp + -4] ; $hex_char
2348   10E2 32            mov bl, [d]
2349   10E3 A7 00         mov bh, 0
2350   10E5             ; --- START RELATIONAL
2351   10E5 D7            push a
2352   10E6 11            mov a, b
2353   10E7 26 46 00      mov b, $46
2354   10EA B0            cmp a, b
2355   10EB FD 74         sle ; <= (signed)
2356   10ED E4            pop a
2357   10EE             ; --- END RELATIONAL
2358   10EE FD A7         sand a, b
2359   10F0 E4            pop a
2360   10F1             ; --- END LOGICAL AND
2361   10F1 C0 00 00      cmp b, 0
2362   10F4 C6 25 11      je _if33_else
2363   10F7             _if33_true:
2364   10F7             ; value = (value * 16) + (hex_char - 'A' + 10); 
2365   10F7 FA FF FF      lea d, [bp + -1] ; $value
2366   10FA DA            push d
2367   10FB FA FF FF      lea d, [bp + -1] ; $value
2368   10FE 2A            mov b, [d]
2369   10FF             ; --- START FACTORS
2370   10FF D7            push a
2371   1100 11            mov a, b
2372   1101 26 10 00      mov b, $10
2373   1104 AC            mul a, b ; *
2374   1105 11            mov a, b
2375   1106 27            mov b, a
2376   1107 E4            pop a
2377   1108             ; --- END FACTORS
2378   1108             ; --- START TERMS
2379   1108 D7            push a
2380   1109 11            mov a, b
2381   110A FA FC FF      lea d, [bp + -4] ; $hex_char
2382   110D 32            mov bl, [d]
2383   110E A7 00         mov bh, 0
2384   1110             ; --- START TERMS
2385   1110 D7            push a
2386   1111 11            mov a, b
2387   1112 26 41 00      mov b, $41
2388   1115 60            sub a, b
2389   1116 27            mov b, a
2390   1117 11            mov a, b
2391   1118 26 0A 00      mov b, $a
2392   111B 56            add b, a
2393   111C E4            pop a
2394   111D             ; --- END TERMS
2395   111D 56            add b, a
2396   111E E4            pop a
2397   111F             ; --- END TERMS
2398   111F E7            pop d
2399   1120 FD 43         mov [d], b
2400   1122 0A 4B 11      jmp _if33_exit
2401   1125             _if33_else:
2402   1125             ; value = (value * 16) + (hex_char - '0'); 
2403   1125 FA FF FF      lea d, [bp + -1] ; $value
2404   1128 DA            push d
2405   1129 FA FF FF      lea d, [bp + -1] ; $value
2406   112C 2A            mov b, [d]
2407   112D             ; --- START FACTORS
2408   112D D7            push a
2409   112E 11            mov a, b
2410   112F 26 10 00      mov b, $10
2411   1132 AC            mul a, b ; *
2412   1133 11            mov a, b
2413   1134 27            mov b, a
2414   1135 E4            pop a
2415   1136             ; --- END FACTORS
2416   1136             ; --- START TERMS
2417   1136 D7            push a
2418   1137 11            mov a, b
2419   1138 FA FC FF      lea d, [bp + -4] ; $hex_char
2420   113B 32            mov bl, [d]
2421   113C A7 00         mov bh, 0
2422   113E             ; --- START TERMS
2423   113E D7            push a
2424   113F 11            mov a, b
2425   1140 26 30 00      mov b, $30
2426   1143 60            sub a, b
2427   1144 27            mov b, a
2428   1145 E4            pop a
2429   1146             ; --- END TERMS
2430   1146 56            add b, a
2431   1147 E4            pop a
2432   1148             ; --- END TERMS
2433   1148 E7            pop d
2434   1149 FD 43         mov [d], b
2435   114B             _if33_exit:
2436   114B             _if32_exit:
2437   114B             _for31_update:
2438   114B FA FD FF      lea d, [bp + -3] ; $i
2439   114E 2A            mov b, [d]
2440   114F FD 77         inc b
2441   1151 FA FD FF      lea d, [bp + -3] ; $i
2442   1154 FD 43         mov [d], b
2443   1156 FD 7D         dec b
2444   1158 0A 48 10      jmp _for31_cond
2445   115B             _for31_exit:
2446   115B             ; return value; 
2447   115B FA FF FF      lea d, [bp + -1] ; $value
2448   115E 2A            mov b, [d]
2449   115F F9            leave
2450   1160 09            ret
2451   1161             
2452   1161             gets:
2453   1161 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2454   1164             
2455   1164             ; --- BEGIN INLINE ASM SEGMENT
2456   1164 FA 05 00      lea d, [bp + 5] ; $s
2457   1167 15            mov a, [d]
2458   1168 3C            mov d, a
2459   1169 07 E1 1C      call _gets
2460   116C             ; --- END INLINE ASM SEGMENT
2461   116C             
2462   116C             ; return strlen(s); 
2463   116C FA 05 00      lea d, [bp + 5] ; $s
2464   116F 2A            mov b, [d]
2465   1170 FD AB         swp b
2466   1172 D8            push b
2467   1173 07 84 05      call strlen
2468   1176 51 02 00      add sp, 2
2469   1179 F9            leave
2470   117A 09            ret
2471   117B             
2472   117B             print_signed:
2473   117B F8 00 00      enter 0 ; (push bp; mov bp, sp)
2474   117E             ; char digits[5]; 
2475   117E 52 05 00      sub sp, 5
2476   1181             ; int i = 0; 
2477   1181 52 02 00      sub sp, 2
2478   1184             ; --- START LOCAL VAR INITIALIZATION
2479   1184 FA FA FF      lea d, [bp + -6] ; $i
2480   1187 DA            push d
2481   1188 26 00 00      mov b, $0
2482   118B E7            pop d
2483   118C FD 43         mov [d], b
2484   118E             ; --- END LOCAL VAR INITIALIZATION
2485   118E             ; if (num < 0) { 
2486   118E             _if34_cond:
2487   118E FA 05 00      lea d, [bp + 5] ; $num
2488   1191 2A            mov b, [d]
2489   1192             ; --- START RELATIONAL
2490   1192 D7            push a
2491   1193 11            mov a, b
2492   1194 26 00 00      mov b, $0
2493   1197 B0            cmp a, b
2494   1198 FD 73         slt ; < (signed)
2495   119A E4            pop a
2496   119B             ; --- END RELATIONAL
2497   119B C0 00 00      cmp b, 0
2498   119E C6 BB 11      je _if34_else
2499   11A1             _if34_true:
2500   11A1             ; putchar('-'); 
2501   11A1 26 2D 00      mov b, $2d
2502   11A4 DD            push bl
2503   11A5 07 E3 1A      call putchar
2504   11A8 51 01 00      add sp, 1
2505   11AB             ; num = -num; 
2506   11AB FA 05 00      lea d, [bp + 5] ; $num
2507   11AE DA            push d
2508   11AF FA 05 00      lea d, [bp + 5] ; $num
2509   11B2 2A            mov b, [d]
2510   11B3 FD 97         neg b
2511   11B5 E7            pop d
2512   11B6 FD 43         mov [d], b
2513   11B8 0A DD 11      jmp _if34_exit
2514   11BB             _if34_else:
2515   11BB             ; if (num == 0) { 
2516   11BB             _if35_cond:
2517   11BB FA 05 00      lea d, [bp + 5] ; $num
2518   11BE 2A            mov b, [d]
2519   11BF             ; --- START RELATIONAL
2520   11BF D7            push a
2521   11C0 11            mov a, b
2522   11C1 26 00 00      mov b, $0
2523   11C4 B0            cmp a, b
2524   11C5 FD 71         seq ; ==
2525   11C7 E4            pop a
2526   11C8             ; --- END RELATIONAL
2527   11C8 C0 00 00      cmp b, 0
2528   11CB C6 DD 11      je _if35_exit
2529   11CE             _if35_true:
2530   11CE             ; putchar('0'); 
2531   11CE 26 30 00      mov b, $30
2532   11D1 DD            push bl
2533   11D2 07 E3 1A      call putchar
2534   11D5 51 01 00      add sp, 1
2535   11D8             ; return; 
2536   11D8 F9            leave
2537   11D9 09            ret
2538   11DA 0A DD 11      jmp _if35_exit
2539   11DD             _if35_exit:
2540   11DD             _if34_exit:
2541   11DD             ; while (num > 0) { 
2542   11DD             _while36_cond:
2543   11DD FA 05 00      lea d, [bp + 5] ; $num
2544   11E0 2A            mov b, [d]
2545   11E1             ; --- START RELATIONAL
2546   11E1 D7            push a
2547   11E2 11            mov a, b
2548   11E3 26 00 00      mov b, $0
2549   11E6 B0            cmp a, b
2550   11E7 FD 7F         sgt ; >
2551   11E9 E4            pop a
2552   11EA             ; --- END RELATIONAL
2553   11EA C0 00 00      cmp b, 0
2554   11ED C6 37 12      je _while36_exit
2555   11F0             _while36_block:
2556   11F0             ; digits[i] = '0' + (num % 10); 
2557   11F0 FA FC FF      lea d, [bp + -4] ; $digits
2558   11F3 D7            push a
2559   11F4 DA            push d
2560   11F5 FA FA FF      lea d, [bp + -6] ; $i
2561   11F8 2A            mov b, [d]
2562   11F9 E7            pop d
2563   11FA 5A            add d, b
2564   11FB E4            pop a
2565   11FC DA            push d
2566   11FD 26 30 00      mov b, $30
2567   1200             ; --- START TERMS
2568   1200 D7            push a
2569   1201 11            mov a, b
2570   1202 FA 05 00      lea d, [bp + 5] ; $num
2571   1205 2A            mov b, [d]
2572   1206             ; --- START FACTORS
2573   1206 D7            push a
2574   1207 11            mov a, b
2575   1208 26 0A 00      mov b, $a
2576   120B AE            div a, b ; 
2577   120C 11            mov a, b
2578   120D 27            mov b, a
2579   120E E4            pop a
2580   120F             ; --- END FACTORS
2581   120F 56            add b, a
2582   1210 E4            pop a
2583   1211             ; --- END TERMS
2584   1211 E7            pop d
2585   1212 FD 3E         mov [d], bl
2586   1214             ; num = num / 10; 
2587   1214 FA 05 00      lea d, [bp + 5] ; $num
2588   1217 DA            push d
2589   1218 FA 05 00      lea d, [bp + 5] ; $num
2590   121B 2A            mov b, [d]
2591   121C             ; --- START FACTORS
2592   121C D7            push a
2593   121D 11            mov a, b
2594   121E 26 0A 00      mov b, $a
2595   1221 AE            div a, b
2596   1222 27            mov b, a
2597   1223 E4            pop a
2598   1224             ; --- END FACTORS
2599   1224 E7            pop d
2600   1225 FD 43         mov [d], b
2601   1227             ; i++; 
2602   1227 FA FA FF      lea d, [bp + -6] ; $i
2603   122A 2A            mov b, [d]
2604   122B FD 77         inc b
2605   122D FA FA FF      lea d, [bp + -6] ; $i
2606   1230 FD 43         mov [d], b
2607   1232 FD 7D         dec b
2608   1234 0A DD 11      jmp _while36_cond
2609   1237             _while36_exit:
2610   1237             ; while (i > 0) { 
2611   1237             _while37_cond:
2612   1237 FA FA FF      lea d, [bp + -6] ; $i
2613   123A 2A            mov b, [d]
2614   123B             ; --- START RELATIONAL
2615   123B D7            push a
2616   123C 11            mov a, b
2617   123D 26 00 00      mov b, $0
2618   1240 B0            cmp a, b
2619   1241 FD 7F         sgt ; >
2620   1243 E4            pop a
2621   1244             ; --- END RELATIONAL
2622   1244 C0 00 00      cmp b, 0
2623   1247 C6 70 12      je _while37_exit
2624   124A             _while37_block:
2625   124A             ; i--; 
2626   124A FA FA FF      lea d, [bp + -6] ; $i
2627   124D 2A            mov b, [d]
2628   124E FD 7D         dec b
2629   1250 FA FA FF      lea d, [bp + -6] ; $i
2630   1253 FD 43         mov [d], b
2631   1255 FD 77         inc b
2632   1257             ; putchar(digits[i]); 
2633   1257 FA FC FF      lea d, [bp + -4] ; $digits
2634   125A D7            push a
2635   125B DA            push d
2636   125C FA FA FF      lea d, [bp + -6] ; $i
2637   125F 2A            mov b, [d]
2638   1260 E7            pop d
2639   1261 5A            add d, b
2640   1262 E4            pop a
2641   1263 32            mov bl, [d]
2642   1264 A7 00         mov bh, 0
2643   1266 DD            push bl
2644   1267 07 E3 1A      call putchar
2645   126A 51 01 00      add sp, 1
2646   126D 0A 37 12      jmp _while37_cond
2647   1270             _while37_exit:
2648   1270 F9            leave
2649   1271 09            ret
2650   1272             
2651   1272             print_signed_long:
2652   1272 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2653   1275             ; char digits[10]; 
2654   1275 52 0A 00      sub sp, 10
2655   1278             ; int i = 0; 
2656   1278 52 02 00      sub sp, 2
2657   127B             ; --- START LOCAL VAR INITIALIZATION
2658   127B FA F5 FF      lea d, [bp + -11] ; $i
2659   127E DA            push d
2660   127F 26 00 00      mov b, $0
2661   1282 E7            pop d
2662   1283 FD 43         mov [d], b
2663   1285             ; --- END LOCAL VAR INITIALIZATION
2664   1285             ; if (num < 0) { 
2665   1285             _if38_cond:
2666   1285 FA 05 00      lea d, [bp + 5] ; $num
2667   1288 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2668   128B FD 39         mov c, b ; And place it into C
2669   128D 2A            mov b, [d] ; Lower Word in B
2670   128E             ; --- START RELATIONAL
2671   128E D7            push a
2672   128F FD D8         push g
2673   1291 11            mov a, b
2674   1292 FD 7A         mov g, c
2675   1294 26 00 00      mov b, $0
2676   1297 38 00 00      mov c, 0
2677   129A FD AF 00 00   cmp32 ga, cb
2677   129E 00 00 00 00 
2677   12A2 00 00 00 00 
2677   12A6 00 00 00 00 
2677   12AA 00 00 00 00 
2677   12AE 00 00 00 00 
2677   12B2 00 00 00 00 
2677   12B6 00 00 00 00 
2677   12BA 00 00 00 00 
2677   12BE 00 00 00 00 
2677   12C2 00 00 00 00 
2677   12C6 00 00 00 00 
2677   12CA 00 00 00 00 
2677   12CE 00 00 00 00 
2677   12D2 00 00 00 00 
2677   12D6 00 00 00 00 
2677   12DA 00 00 00 00 
2677   12DE 00 00 00 00 
2677   12E2 00 00 00 00 
2677   12E6 00 00 00 00 
2677   12EA 00 00 00 00 
2677   12EE 00 00 00 00 
2677   12F2 00 00 00 00 
2677   12F6 00 00 00 00 
2677   12FA 00 00 00 00 
2677   12FE 00 00 00 00 
2677   1302 00 00 00 00 
2677   1306 00 00 00 00 
2677   130A 00 00 00 00 
2677   130E 00 00 00 00 
2677   1312 00 00 00 00 
2677   1316 00 00 00 00 
2677   131A 00 00 00 00 
2677   131E 00 00 00 00 
2677   1322 00 00 00 00 
2677   1326 00 00 00 00 
2677   132A 00 00 00 00 
2677   132E 00 00 00 00 
2677   1332 00 00 00 00 
2677   1336 00 00 00 00 
2677   133A 00 00 00 00 
2677   133E 00 00 00 00 
2677   1342 00 00 00 00 
2677   1346 00 00 00 00 
2677   134A 00 00 00 00 
2677   134E 00 00 00 00 
2677   1352 00 00 00 00 
2677   1356 00 00 00 00 
2677   135A 00 00 00 00 
2677   135E 00 00 00 00 
2677   1362 00 00 00 00 
2677   1366 00 00 00 00 
2677   136A 00 00 00 00 
2677   136E 00 00 00 00 
2677   1372 00 00 00 00 
2677   1376 00 00 00 00 
2677   137A 00 00 00 00 
2677   137E 00 00 00 00 
2677   1382 00 00 00 00 
2677   1386 00 00 00 00 
2677   138A 00 00 00 00 
2677   138E 00 00 00 00 
2677   1392 00 00 00 00 
2677   1396 00 00 00 00 
2677   139A 00 
2678   139B FD 73         slt ; <
2679   139D FD F1         pop g
2680   139F E4            pop a
2681   13A0             ; --- END RELATIONAL
2682   13A0 C0 00 00      cmp b, 0
2683   13A3 C6 CA 13      je _if38_else
2684   13A6             _if38_true:
2685   13A6             ; putchar('-'); 
2686   13A6 26 2D 00      mov b, $2d
2687   13A9 DD            push bl
2688   13AA 07 E3 1A      call putchar
2689   13AD 51 01 00      add sp, 1
2690   13B0             ; num = -num; 
2691   13B0 FA 05 00      lea d, [bp + 5] ; $num
2692   13B3 DA            push d
2693   13B4 FA 05 00      lea d, [bp + 5] ; $num
2694   13B7 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2695   13BA FD 39         mov c, b ; And place it into C
2696   13BC 2A            mov b, [d] ; Lower Word in B
2697   13BD FD 97         neg b
2698   13BF E7            pop d
2699   13C0 FD 43         mov [d], b
2700   13C2 28            mov b, c
2701   13C3 FD 44 02 00   mov [d + 2], b
2702   13C7 0A FA 14      jmp _if38_exit
2703   13CA             _if38_else:
2704   13CA             ; if (num == 0) { 
2705   13CA             _if39_cond:
2706   13CA FA 05 00      lea d, [bp + 5] ; $num
2707   13CD 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2708   13D0 FD 39         mov c, b ; And place it into C
2709   13D2 2A            mov b, [d] ; Lower Word in B
2710   13D3             ; --- START RELATIONAL
2711   13D3 D7            push a
2712   13D4 FD D8         push g
2713   13D6 11            mov a, b
2714   13D7 FD 7A         mov g, c
2715   13D9 26 00 00      mov b, $0
2716   13DC 38 00 00      mov c, 0
2717   13DF FD AF 00 00   cmp32 ga, cb
2717   13E3 00 00 00 00 
2717   13E7 00 00 00 00 
2717   13EB 00 00 00 00 
2717   13EF 00 00 00 00 
2717   13F3 00 00 00 00 
2717   13F7 00 00 00 00 
2717   13FB 00 00 00 00 
2717   13FF 00 00 00 00 
2717   1403 00 00 00 00 
2717   1407 00 00 00 00 
2717   140B 00 00 00 00 
2717   140F 00 00 00 00 
2717   1413 00 00 00 00 
2717   1417 00 00 00 00 
2717   141B 00 00 00 00 
2717   141F 00 00 00 00 
2717   1423 00 00 00 00 
2717   1427 00 00 00 00 
2717   142B 00 00 00 00 
2717   142F 00 00 00 00 
2717   1433 00 00 00 00 
2717   1437 00 00 00 00 
2717   143B 00 00 00 00 
2717   143F 00 00 00 00 
2717   1443 00 00 00 00 
2717   1447 00 00 00 00 
2717   144B 00 00 00 00 
2717   144F 00 00 00 00 
2717   1453 00 00 00 00 
2717   1457 00 00 00 00 
2717   145B 00 00 00 00 
2717   145F 00 00 00 00 
2717   1463 00 00 00 00 
2717   1467 00 00 00 00 
2717   146B 00 00 00 00 
2717   146F 00 00 00 00 
2717   1473 00 00 00 00 
2717   1477 00 00 00 00 
2717   147B 00 00 00 00 
2717   147F 00 00 00 00 
2717   1483 00 00 00 00 
2717   1487 00 00 00 00 
2717   148B 00 00 00 00 
2717   148F 00 00 00 00 
2717   1493 00 00 00 00 
2717   1497 00 00 00 00 
2717   149B 00 00 00 00 
2717   149F 00 00 00 00 
2717   14A3 00 00 00 00 
2717   14A7 00 00 00 00 
2717   14AB 00 00 00 00 
2717   14AF 00 00 00 00 
2717   14B3 00 00 00 00 
2717   14B7 00 00 00 00 
2717   14BB 00 00 00 00 
2717   14BF 00 00 00 00 
2717   14C3 00 00 00 00 
2717   14C7 00 00 00 00 
2717   14CB 00 00 00 00 
2717   14CF 00 00 00 00 
2717   14D3 00 00 00 00 
2717   14D7 00 00 00 00 
2717   14DB 00 00 00 00 
2717   14DF 00 
2718   14E0 FD 71         seq ; ==
2719   14E2 FD F1         pop g
2720   14E4 E4            pop a
2721   14E5             ; --- END RELATIONAL
2722   14E5 C0 00 00      cmp b, 0
2723   14E8 C6 FA 14      je _if39_exit
2724   14EB             _if39_true:
2725   14EB             ; putchar('0'); 
2726   14EB 26 30 00      mov b, $30
2727   14EE DD            push bl
2728   14EF 07 E3 1A      call putchar
2729   14F2 51 01 00      add sp, 1
2730   14F5             ; return; 
2731   14F5 F9            leave
2732   14F6 09            ret
2733   14F7 0A FA 14      jmp _if39_exit
2734   14FA             _if39_exit:
2735   14FA             _if38_exit:
2736   14FA             ; while (num > 0) { 
2737   14FA             _while40_cond:
2738   14FA FA 05 00      lea d, [bp + 5] ; $num
2739   14FD 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2740   1500 FD 39         mov c, b ; And place it into C
2741   1502 2A            mov b, [d] ; Lower Word in B
2742   1503             ; --- START RELATIONAL
2743   1503 D7            push a
2744   1504 FD D8         push g
2745   1506 11            mov a, b
2746   1507 FD 7A         mov g, c
2747   1509 26 00 00      mov b, $0
2748   150C 38 00 00      mov c, 0
2749   150F FD 7F         sgt
2750   1511 FD F1         pop g
2751   1513 E4            pop a
2752   1514             ; --- END RELATIONAL
2753   1514 C0 00 00      cmp b, 0
2754   1517 C6 77 15      je _while40_exit
2755   151A             _while40_block:
2756   151A             ; digits[i] = '0' + (num % 10); 
2757   151A FA F7 FF      lea d, [bp + -9] ; $digits
2758   151D D7            push a
2759   151E DA            push d
2760   151F FA F5 FF      lea d, [bp + -11] ; $i
2761   1522 2A            mov b, [d]
2762   1523 E7            pop d
2763   1524 5A            add d, b
2764   1525 E4            pop a
2765   1526 DA            push d
2766   1527 26 30 00      mov b, $30
2767   152A             ; --- START TERMS
2768   152A D7            push a
2769   152B 11            mov a, b
2770   152C FA 05 00      lea d, [bp + 5] ; $num
2771   152F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2772   1532 FD 39         mov c, b ; And place it into C
2773   1534 2A            mov b, [d] ; Lower Word in B
2774   1535             ; --- START FACTORS
2775   1535 D7            push a
2776   1536 11            mov a, b
2777   1537 26 0A 00      mov b, $a
2778   153A AE            div a, b ; 
2779   153B 11            mov a, b
2780   153C 27            mov b, a
2781   153D E4            pop a
2782   153E             ; --- END FACTORS
2783   153E 54            add a, b
2784   153F D7            push a
2785   1540 FD 12         mov a, g
2786   1542 28            mov b, c
2787   1543 5C            adc a, b
2788   1544 39            mov c, a
2789   1545 E5            pop b
2790   1546 E4            pop a
2791   1547             ; --- END TERMS
2792   1547 E7            pop d
2793   1548 FD 3E         mov [d], bl
2794   154A             ; num = num / 10; 
2795   154A FA 05 00      lea d, [bp + 5] ; $num
2796   154D DA            push d
2797   154E FA 05 00      lea d, [bp + 5] ; $num
2798   1551 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2799   1554 FD 39         mov c, b ; And place it into C
2800   1556 2A            mov b, [d] ; Lower Word in B
2801   1557             ; --- START FACTORS
2802   1557 D7            push a
2803   1558 11            mov a, b
2804   1559 26 0A 00      mov b, $a
2805   155C AE            div a, b
2806   155D 27            mov b, a
2807   155E E4            pop a
2808   155F             ; --- END FACTORS
2809   155F E7            pop d
2810   1560 FD 43         mov [d], b
2811   1562 28            mov b, c
2812   1563 FD 44 02 00   mov [d + 2], b
2813   1567             ; i++; 
2814   1567 FA F5 FF      lea d, [bp + -11] ; $i
2815   156A 2A            mov b, [d]
2816   156B FD 77         inc b
2817   156D FA F5 FF      lea d, [bp + -11] ; $i
2818   1570 FD 43         mov [d], b
2819   1572 FD 7D         dec b
2820   1574 0A FA 14      jmp _while40_cond
2821   1577             _while40_exit:
2822   1577             ; while (i > 0) { 
2823   1577             _while41_cond:
2824   1577 FA F5 FF      lea d, [bp + -11] ; $i
2825   157A 2A            mov b, [d]
2826   157B             ; --- START RELATIONAL
2827   157B D7            push a
2828   157C 11            mov a, b
2829   157D 26 00 00      mov b, $0
2830   1580 B0            cmp a, b
2831   1581 FD 7F         sgt ; >
2832   1583 E4            pop a
2833   1584             ; --- END RELATIONAL
2834   1584 C0 00 00      cmp b, 0
2835   1587 C6 B0 15      je _while41_exit
2836   158A             _while41_block:
2837   158A             ; i--; 
2838   158A FA F5 FF      lea d, [bp + -11] ; $i
2839   158D 2A            mov b, [d]
2840   158E FD 7D         dec b
2841   1590 FA F5 FF      lea d, [bp + -11] ; $i
2842   1593 FD 43         mov [d], b
2843   1595 FD 77         inc b
2844   1597             ; putchar(digits[i]); 
2845   1597 FA F7 FF      lea d, [bp + -9] ; $digits
2846   159A D7            push a
2847   159B DA            push d
2848   159C FA F5 FF      lea d, [bp + -11] ; $i
2849   159F 2A            mov b, [d]
2850   15A0 E7            pop d
2851   15A1 5A            add d, b
2852   15A2 E4            pop a
2853   15A3 32            mov bl, [d]
2854   15A4 A7 00         mov bh, 0
2855   15A6 DD            push bl
2856   15A7 07 E3 1A      call putchar
2857   15AA 51 01 00      add sp, 1
2858   15AD 0A 77 15      jmp _while41_cond
2859   15B0             _while41_exit:
2860   15B0 F9            leave
2861   15B1 09            ret
2862   15B2             
2863   15B2             print_unsigned_long:
2864   15B2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2865   15B5             ; char digits[10]; 
2866   15B5 52 0A 00      sub sp, 10
2867   15B8             ; int i; 
2868   15B8 52 02 00      sub sp, 2
2869   15BB             ; i = 0; 
2870   15BB FA F5 FF      lea d, [bp + -11] ; $i
2871   15BE DA            push d
2872   15BF 26 00 00      mov b, $0
2873   15C2 E7            pop d
2874   15C3 FD 43         mov [d], b
2875   15C5             ; if(num == 0){ 
2876   15C5             _if42_cond:
2877   15C5 FA 05 00      lea d, [bp + 5] ; $num
2878   15C8 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2879   15CB FD 39         mov c, b ; And place it into C
2880   15CD 2A            mov b, [d] ; Lower Word in B
2881   15CE             ; --- START RELATIONAL
2882   15CE D7            push a
2883   15CF FD D8         push g
2884   15D1 11            mov a, b
2885   15D2 FD 7A         mov g, c
2886   15D4 26 00 00      mov b, $0
2887   15D7 38 00 00      mov c, 0
2888   15DA FD AF 00 00   cmp32 ga, cb
2888   15DE 00 00 00 00 
2888   15E2 00 00 00 00 
2888   15E6 00 00 00 00 
2888   15EA 00 00 00 00 
2888   15EE 00 00 00 00 
2888   15F2 00 00 00 00 
2888   15F6 00 00 00 00 
2888   15FA 00 00 00 00 
2888   15FE 00 00 00 00 
2888   1602 00 00 00 00 
2888   1606 00 00 00 00 
2888   160A 00 00 00 00 
2888   160E 00 00 00 00 
2888   1612 00 00 00 00 
2888   1616 00 00 00 00 
2888   161A 00 00 00 00 
2888   161E 00 00 00 00 
2888   1622 00 00 00 00 
2888   1626 00 00 00 00 
2888   162A 00 00 00 00 
2888   162E 00 00 00 00 
2888   1632 00 00 00 00 
2888   1636 00 00 00 00 
2888   163A 00 00 00 00 
2888   163E 00 00 00 00 
2888   1642 00 00 00 00 
2888   1646 00 00 00 00 
2888   164A 00 00 00 00 
2888   164E 00 00 00 00 
2888   1652 00 00 00 00 
2888   1656 00 00 00 00 
2888   165A 00 00 00 00 
2888   165E 00 00 00 00 
2888   1662 00 00 00 00 
2888   1666 00 00 00 00 
2888   166A 00 00 00 00 
2888   166E 00 00 00 00 
2888   1672 00 00 00 00 
2888   1676 00 00 00 00 
2888   167A 00 00 00 00 
2888   167E 00 00 00 00 
2888   1682 00 00 00 00 
2888   1686 00 00 00 00 
2888   168A 00 00 00 00 
2888   168E 00 00 00 00 
2888   1692 00 00 00 00 
2888   1696 00 00 00 00 
2888   169A 00 00 00 00 
2888   169E 00 00 00 00 
2888   16A2 00 00 00 00 
2888   16A6 00 00 00 00 
2888   16AA 00 00 00 00 
2888   16AE 00 00 00 00 
2888   16B2 00 00 00 00 
2888   16B6 00 00 00 00 
2888   16BA 00 00 00 00 
2888   16BE 00 00 00 00 
2888   16C2 00 00 00 00 
2888   16C6 00 00 00 00 
2888   16CA 00 00 00 00 
2888   16CE 00 00 00 00 
2888   16D2 00 00 00 00 
2888   16D6 00 00 00 00 
2888   16DA 00 
2889   16DB FD 71         seq ; ==
2890   16DD FD F1         pop g
2891   16DF E4            pop a
2892   16E0             ; --- END RELATIONAL
2893   16E0 C0 00 00      cmp b, 0
2894   16E3 C6 F5 16      je _if42_exit
2895   16E6             _if42_true:
2896   16E6             ; putchar('0'); 
2897   16E6 26 30 00      mov b, $30
2898   16E9 DD            push bl
2899   16EA 07 E3 1A      call putchar
2900   16ED 51 01 00      add sp, 1
2901   16F0             ; return; 
2902   16F0 F9            leave
2903   16F1 09            ret
2904   16F2 0A F5 16      jmp _if42_exit
2905   16F5             _if42_exit:
2906   16F5             ; while (num > 0) { 
2907   16F5             _while43_cond:
2908   16F5 FA 05 00      lea d, [bp + 5] ; $num
2909   16F8 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2910   16FB FD 39         mov c, b ; And place it into C
2911   16FD 2A            mov b, [d] ; Lower Word in B
2912   16FE             ; --- START RELATIONAL
2913   16FE D7            push a
2914   16FF FD D8         push g
2915   1701 11            mov a, b
2916   1702 FD 7A         mov g, c
2917   1704 26 00 00      mov b, $0
2918   1707 38 00 00      mov c, 0
2919   170A FD 81         sgu
2920   170C FD F1         pop g
2921   170E E4            pop a
2922   170F             ; --- END RELATIONAL
2923   170F C0 00 00      cmp b, 0
2924   1712 C6 72 17      je _while43_exit
2925   1715             _while43_block:
2926   1715             ; digits[i] = '0' + (num % 10); 
2927   1715 FA F7 FF      lea d, [bp + -9] ; $digits
2928   1718 D7            push a
2929   1719 DA            push d
2930   171A FA F5 FF      lea d, [bp + -11] ; $i
2931   171D 2A            mov b, [d]
2932   171E E7            pop d
2933   171F 5A            add d, b
2934   1720 E4            pop a
2935   1721 DA            push d
2936   1722 26 30 00      mov b, $30
2937   1725             ; --- START TERMS
2938   1725 D7            push a
2939   1726 11            mov a, b
2940   1727 FA 05 00      lea d, [bp + 5] ; $num
2941   172A 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2942   172D FD 39         mov c, b ; And place it into C
2943   172F 2A            mov b, [d] ; Lower Word in B
2944   1730             ; --- START FACTORS
2945   1730 D7            push a
2946   1731 11            mov a, b
2947   1732 26 0A 00      mov b, $a
2948   1735 AE            div a, b ; 
2949   1736 11            mov a, b
2950   1737 27            mov b, a
2951   1738 E4            pop a
2952   1739             ; --- END FACTORS
2953   1739 54            add a, b
2954   173A D7            push a
2955   173B FD 12         mov a, g
2956   173D 28            mov b, c
2957   173E 5C            adc a, b
2958   173F 39            mov c, a
2959   1740 E5            pop b
2960   1741 E4            pop a
2961   1742             ; --- END TERMS
2962   1742 E7            pop d
2963   1743 FD 3E         mov [d], bl
2964   1745             ; num = num / 10; 
2965   1745 FA 05 00      lea d, [bp + 5] ; $num
2966   1748 DA            push d
2967   1749 FA 05 00      lea d, [bp + 5] ; $num
2968   174C 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2969   174F FD 39         mov c, b ; And place it into C
2970   1751 2A            mov b, [d] ; Lower Word in B
2971   1752             ; --- START FACTORS
2972   1752 D7            push a
2973   1753 11            mov a, b
2974   1754 26 0A 00      mov b, $a
2975   1757 AE            div a, b
2976   1758 27            mov b, a
2977   1759 E4            pop a
2978   175A             ; --- END FACTORS
2979   175A E7            pop d
2980   175B FD 43         mov [d], b
2981   175D 28            mov b, c
2982   175E FD 44 02 00   mov [d + 2], b
2983   1762             ; i++; 
2984   1762 FA F5 FF      lea d, [bp + -11] ; $i
2985   1765 2A            mov b, [d]
2986   1766 FD 77         inc b
2987   1768 FA F5 FF      lea d, [bp + -11] ; $i
2988   176B FD 43         mov [d], b
2989   176D FD 7D         dec b
2990   176F 0A F5 16      jmp _while43_cond
2991   1772             _while43_exit:
2992   1772             ; while (i > 0) { 
2993   1772             _while44_cond:
2994   1772 FA F5 FF      lea d, [bp + -11] ; $i
2995   1775 2A            mov b, [d]
2996   1776             ; --- START RELATIONAL
2997   1776 D7            push a
2998   1777 11            mov a, b
2999   1778 26 00 00      mov b, $0
3000   177B B0            cmp a, b
3001   177C FD 7F         sgt ; >
3002   177E E4            pop a
3003   177F             ; --- END RELATIONAL
3004   177F C0 00 00      cmp b, 0
3005   1782 C6 AB 17      je _while44_exit
3006   1785             _while44_block:
3007   1785             ; i--; 
3008   1785 FA F5 FF      lea d, [bp + -11] ; $i
3009   1788 2A            mov b, [d]
3010   1789 FD 7D         dec b
3011   178B FA F5 FF      lea d, [bp + -11] ; $i
3012   178E FD 43         mov [d], b
3013   1790 FD 77         inc b
3014   1792             ; putchar(digits[i]); 
3015   1792 FA F7 FF      lea d, [bp + -9] ; $digits
3016   1795 D7            push a
3017   1796 DA            push d
3018   1797 FA F5 FF      lea d, [bp + -11] ; $i
3019   179A 2A            mov b, [d]
3020   179B E7            pop d
3021   179C 5A            add d, b
3022   179D E4            pop a
3023   179E 32            mov bl, [d]
3024   179F A7 00         mov bh, 0
3025   17A1 DD            push bl
3026   17A2 07 E3 1A      call putchar
3027   17A5 51 01 00      add sp, 1
3028   17A8 0A 72 17      jmp _while44_cond
3029   17AB             _while44_exit:
3030   17AB F9            leave
3031   17AC 09            ret
3032   17AD             
3033   17AD             sprint_unsigned:
3034   17AD F8 00 00      enter 0 ; (push bp; mov bp, sp)
3035   17B0             ; char digits[5]; 
3036   17B0 52 05 00      sub sp, 5
3037   17B3             ; int i; 
3038   17B3 52 02 00      sub sp, 2
3039   17B6             ; int len = 0; 
3040   17B6 52 02 00      sub sp, 2
3041   17B9             ; --- START LOCAL VAR INITIALIZATION
3042   17B9 FA F8 FF      lea d, [bp + -8] ; $len
3043   17BC DA            push d
3044   17BD 26 00 00      mov b, $0
3045   17C0 E7            pop d
3046   17C1 FD 43         mov [d], b
3047   17C3             ; --- END LOCAL VAR INITIALIZATION
3048   17C3             ; i = 0; 
3049   17C3 FA FA FF      lea d, [bp + -6] ; $i
3050   17C6 DA            push d
3051   17C7 26 00 00      mov b, $0
3052   17CA E7            pop d
3053   17CB FD 43         mov [d], b
3054   17CD             ; if(num == 0){ 
3055   17CD             _if45_cond:
3056   17CD FA 07 00      lea d, [bp + 7] ; $num
3057   17D0 2A            mov b, [d]
3058   17D1             ; --- START RELATIONAL
3059   17D1 D7            push a
3060   17D2 11            mov a, b
3061   17D3 26 00 00      mov b, $0
3062   17D6 B0            cmp a, b
3063   17D7 FD 71         seq ; ==
3064   17D9 E4            pop a
3065   17DA             ; --- END RELATIONAL
3066   17DA C0 00 00      cmp b, 0
3067   17DD C6 FC 17      je _if45_exit
3068   17E0             _if45_true:
3069   17E0             ; *dest++ = '0'; 
3070   17E0 FA 05 00      lea d, [bp + 5] ; $dest
3071   17E3 2A            mov b, [d]
3072   17E4 FD 77         inc b
3073   17E6 FA 05 00      lea d, [bp + 5] ; $dest
3074   17E9 FD 43         mov [d], b
3075   17EB FD 7D         dec b
3076   17ED D8            push b
3077   17EE 26 30 00      mov b, $30
3078   17F1 E7            pop d
3079   17F2 FD 3E         mov [d], bl
3080   17F4             ; return 1; 
3081   17F4 26 01 00      mov b, $1
3082   17F7 F9            leave
3083   17F8 09            ret
3084   17F9 0A FC 17      jmp _if45_exit
3085   17FC             _if45_exit:
3086   17FC             ; while (num > 0) { 
3087   17FC             _while46_cond:
3088   17FC FA 07 00      lea d, [bp + 7] ; $num
3089   17FF 2A            mov b, [d]
3090   1800             ; --- START RELATIONAL
3091   1800 D7            push a
3092   1801 11            mov a, b
3093   1802 26 00 00      mov b, $0
3094   1805 B0            cmp a, b
3095   1806 FD 81         sgu ; > (unsigned)
3096   1808 E4            pop a
3097   1809             ; --- END RELATIONAL
3098   1809 C0 00 00      cmp b, 0
3099   180C C6 56 18      je _while46_exit
3100   180F             _while46_block:
3101   180F             ; digits[i] = '0' + (num % 10); 
3102   180F FA FC FF      lea d, [bp + -4] ; $digits
3103   1812 D7            push a
3104   1813 DA            push d
3105   1814 FA FA FF      lea d, [bp + -6] ; $i
3106   1817 2A            mov b, [d]
3107   1818 E7            pop d
3108   1819 5A            add d, b
3109   181A E4            pop a
3110   181B DA            push d
3111   181C 26 30 00      mov b, $30
3112   181F             ; --- START TERMS
3113   181F D7            push a
3114   1820 11            mov a, b
3115   1821 FA 07 00      lea d, [bp + 7] ; $num
3116   1824 2A            mov b, [d]
3117   1825             ; --- START FACTORS
3118   1825 D7            push a
3119   1826 11            mov a, b
3120   1827 26 0A 00      mov b, $a
3121   182A AE            div a, b ; 
3122   182B 11            mov a, b
3123   182C 27            mov b, a
3124   182D E4            pop a
3125   182E             ; --- END FACTORS
3126   182E 56            add b, a
3127   182F E4            pop a
3128   1830             ; --- END TERMS
3129   1830 E7            pop d
3130   1831 FD 3E         mov [d], bl
3131   1833             ; num = num / 10; 
3132   1833 FA 07 00      lea d, [bp + 7] ; $num
3133   1836 DA            push d
3134   1837 FA 07 00      lea d, [bp + 7] ; $num
3135   183A 2A            mov b, [d]
3136   183B             ; --- START FACTORS
3137   183B D7            push a
3138   183C 11            mov a, b
3139   183D 26 0A 00      mov b, $a
3140   1840 AE            div a, b
3141   1841 27            mov b, a
3142   1842 E4            pop a
3143   1843             ; --- END FACTORS
3144   1843 E7            pop d
3145   1844 FD 43         mov [d], b
3146   1846             ; i++; 
3147   1846 FA FA FF      lea d, [bp + -6] ; $i
3148   1849 2A            mov b, [d]
3149   184A FD 77         inc b
3150   184C FA FA FF      lea d, [bp + -6] ; $i
3151   184F FD 43         mov [d], b
3152   1851 FD 7D         dec b
3153   1853 0A FC 17      jmp _while46_cond
3154   1856             _while46_exit:
3155   1856             ; while (i > 0) { 
3156   1856             _while47_cond:
3157   1856 FA FA FF      lea d, [bp + -6] ; $i
3158   1859 2A            mov b, [d]
3159   185A             ; --- START RELATIONAL
3160   185A D7            push a
3161   185B 11            mov a, b
3162   185C 26 00 00      mov b, $0
3163   185F B0            cmp a, b
3164   1860 FD 7F         sgt ; >
3165   1862 E4            pop a
3166   1863             ; --- END RELATIONAL
3167   1863 C0 00 00      cmp b, 0
3168   1866 C6 A6 18      je _while47_exit
3169   1869             _while47_block:
3170   1869             ; i--; 
3171   1869 FA FA FF      lea d, [bp + -6] ; $i
3172   186C 2A            mov b, [d]
3173   186D FD 7D         dec b
3174   186F FA FA FF      lea d, [bp + -6] ; $i
3175   1872 FD 43         mov [d], b
3176   1874 FD 77         inc b
3177   1876             ; *dest++ = digits[i]; 
3178   1876 FA 05 00      lea d, [bp + 5] ; $dest
3179   1879 2A            mov b, [d]
3180   187A FD 77         inc b
3181   187C FA 05 00      lea d, [bp + 5] ; $dest
3182   187F FD 43         mov [d], b
3183   1881 FD 7D         dec b
3184   1883 D8            push b
3185   1884 FA FC FF      lea d, [bp + -4] ; $digits
3186   1887 D7            push a
3187   1888 DA            push d
3188   1889 FA FA FF      lea d, [bp + -6] ; $i
3189   188C 2A            mov b, [d]
3190   188D E7            pop d
3191   188E 5A            add d, b
3192   188F E4            pop a
3193   1890 32            mov bl, [d]
3194   1891 A7 00         mov bh, 0
3195   1893 E7            pop d
3196   1894 FD 3E         mov [d], bl
3197   1896             ; len++; 
3198   1896 FA F8 FF      lea d, [bp + -8] ; $len
3199   1899 2A            mov b, [d]
3200   189A FD 77         inc b
3201   189C FA F8 FF      lea d, [bp + -8] ; $len
3202   189F FD 43         mov [d], b
3203   18A1 FD 7D         dec b
3204   18A3 0A 56 18      jmp _while47_cond
3205   18A6             _while47_exit:
3206   18A6             ; *dest = '\0'; 
3207   18A6 FA 05 00      lea d, [bp + 5] ; $dest
3208   18A9 2A            mov b, [d]
3209   18AA D8            push b
3210   18AB 26 00 00      mov b, $0
3211   18AE E7            pop d
3212   18AF FD 3E         mov [d], bl
3213   18B1             ; return len; 
3214   18B1 FA F8 FF      lea d, [bp + -8] ; $len
3215   18B4 2A            mov b, [d]
3216   18B5 F9            leave
3217   18B6 09            ret
3218   18B7             
3219   18B7             print_unsigned:
3220   18B7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3221   18BA             ; char digits[5]; 
3222   18BA 52 05 00      sub sp, 5
3223   18BD             ; int i; 
3224   18BD 52 02 00      sub sp, 2
3225   18C0             ; i = 0; 
3226   18C0 FA FA FF      lea d, [bp + -6] ; $i
3227   18C3 DA            push d
3228   18C4 26 00 00      mov b, $0
3229   18C7 E7            pop d
3230   18C8 FD 43         mov [d], b
3231   18CA             ; if(num == 0){ 
3232   18CA             _if48_cond:
3233   18CA FA 05 00      lea d, [bp + 5] ; $num
3234   18CD 2A            mov b, [d]
3235   18CE             ; --- START RELATIONAL
3236   18CE D7            push a
3237   18CF 11            mov a, b
3238   18D0 26 00 00      mov b, $0
3239   18D3 B0            cmp a, b
3240   18D4 FD 71         seq ; ==
3241   18D6 E4            pop a
3242   18D7             ; --- END RELATIONAL
3243   18D7 C0 00 00      cmp b, 0
3244   18DA C6 EC 18      je _if48_exit
3245   18DD             _if48_true:
3246   18DD             ; putchar('0'); 
3247   18DD 26 30 00      mov b, $30
3248   18E0 DD            push bl
3249   18E1 07 E3 1A      call putchar
3250   18E4 51 01 00      add sp, 1
3251   18E7             ; return; 
3252   18E7 F9            leave
3253   18E8 09            ret
3254   18E9 0A EC 18      jmp _if48_exit
3255   18EC             _if48_exit:
3256   18EC             ; while (num > 0) { 
3257   18EC             _while49_cond:
3258   18EC FA 05 00      lea d, [bp + 5] ; $num
3259   18EF 2A            mov b, [d]
3260   18F0             ; --- START RELATIONAL
3261   18F0 D7            push a
3262   18F1 11            mov a, b
3263   18F2 26 00 00      mov b, $0
3264   18F5 B0            cmp a, b
3265   18F6 FD 81         sgu ; > (unsigned)
3266   18F8 E4            pop a
3267   18F9             ; --- END RELATIONAL
3268   18F9 C0 00 00      cmp b, 0
3269   18FC C6 46 19      je _while49_exit
3270   18FF             _while49_block:
3271   18FF             ; digits[i] = '0' + (num % 10); 
3272   18FF FA FC FF      lea d, [bp + -4] ; $digits
3273   1902 D7            push a
3274   1903 DA            push d
3275   1904 FA FA FF      lea d, [bp + -6] ; $i
3276   1907 2A            mov b, [d]
3277   1908 E7            pop d
3278   1909 5A            add d, b
3279   190A E4            pop a
3280   190B DA            push d
3281   190C 26 30 00      mov b, $30
3282   190F             ; --- START TERMS
3283   190F D7            push a
3284   1910 11            mov a, b
3285   1911 FA 05 00      lea d, [bp + 5] ; $num
3286   1914 2A            mov b, [d]
3287   1915             ; --- START FACTORS
3288   1915 D7            push a
3289   1916 11            mov a, b
3290   1917 26 0A 00      mov b, $a
3291   191A AE            div a, b ; 
3292   191B 11            mov a, b
3293   191C 27            mov b, a
3294   191D E4            pop a
3295   191E             ; --- END FACTORS
3296   191E 56            add b, a
3297   191F E4            pop a
3298   1920             ; --- END TERMS
3299   1920 E7            pop d
3300   1921 FD 3E         mov [d], bl
3301   1923             ; num = num / 10; 
3302   1923 FA 05 00      lea d, [bp + 5] ; $num
3303   1926 DA            push d
3304   1927 FA 05 00      lea d, [bp + 5] ; $num
3305   192A 2A            mov b, [d]
3306   192B             ; --- START FACTORS
3307   192B D7            push a
3308   192C 11            mov a, b
3309   192D 26 0A 00      mov b, $a
3310   1930 AE            div a, b
3311   1931 27            mov b, a
3312   1932 E4            pop a
3313   1933             ; --- END FACTORS
3314   1933 E7            pop d
3315   1934 FD 43         mov [d], b
3316   1936             ; i++; 
3317   1936 FA FA FF      lea d, [bp + -6] ; $i
3318   1939 2A            mov b, [d]
3319   193A FD 77         inc b
3320   193C FA FA FF      lea d, [bp + -6] ; $i
3321   193F FD 43         mov [d], b
3322   1941 FD 7D         dec b
3323   1943 0A EC 18      jmp _while49_cond
3324   1946             _while49_exit:
3325   1946             ; while (i > 0) { 
3326   1946             _while50_cond:
3327   1946 FA FA FF      lea d, [bp + -6] ; $i
3328   1949 2A            mov b, [d]
3329   194A             ; --- START RELATIONAL
3330   194A D7            push a
3331   194B 11            mov a, b
3332   194C 26 00 00      mov b, $0
3333   194F B0            cmp a, b
3334   1950 FD 7F         sgt ; >
3335   1952 E4            pop a
3336   1953             ; --- END RELATIONAL
3337   1953 C0 00 00      cmp b, 0
3338   1956 C6 7F 19      je _while50_exit
3339   1959             _while50_block:
3340   1959             ; i--; 
3341   1959 FA FA FF      lea d, [bp + -6] ; $i
3342   195C 2A            mov b, [d]
3343   195D FD 7D         dec b
3344   195F FA FA FF      lea d, [bp + -6] ; $i
3345   1962 FD 43         mov [d], b
3346   1964 FD 77         inc b
3347   1966             ; putchar(digits[i]); 
3348   1966 FA FC FF      lea d, [bp + -4] ; $digits
3349   1969 D7            push a
3350   196A DA            push d
3351   196B FA FA FF      lea d, [bp + -6] ; $i
3352   196E 2A            mov b, [d]
3353   196F E7            pop d
3354   1970 5A            add d, b
3355   1971 E4            pop a
3356   1972 32            mov bl, [d]
3357   1973 A7 00         mov bh, 0
3358   1975 DD            push bl
3359   1976 07 E3 1A      call putchar
3360   1979 51 01 00      add sp, 1
3361   197C 0A 46 19      jmp _while50_cond
3362   197F             _while50_exit:
3363   197F F9            leave
3364   1980 09            ret
3365   1981             
3366   1981             sprint_signed:
3367   1981 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3368   1984             ; char digits[5]; 
3369   1984 52 05 00      sub sp, 5
3370   1987             ; int i = 0; 
3371   1987 52 02 00      sub sp, 2
3372   198A             ; --- START LOCAL VAR INITIALIZATION
3373   198A FA FA FF      lea d, [bp + -6] ; $i
3374   198D DA            push d
3375   198E 26 00 00      mov b, $0
3376   1991 E7            pop d
3377   1992 FD 43         mov [d], b
3378   1994             ; --- END LOCAL VAR INITIALIZATION
3379   1994             ; int len = 0; 
3380   1994 52 02 00      sub sp, 2
3381   1997             ; --- START LOCAL VAR INITIALIZATION
3382   1997 FA F8 FF      lea d, [bp + -8] ; $len
3383   199A DA            push d
3384   199B 26 00 00      mov b, $0
3385   199E E7            pop d
3386   199F FD 43         mov [d], b
3387   19A1             ; --- END LOCAL VAR INITIALIZATION
3388   19A1             ; if (num < 0) { 
3389   19A1             _if51_cond:
3390   19A1 FA 07 00      lea d, [bp + 7] ; $num
3391   19A4 2A            mov b, [d]
3392   19A5             ; --- START RELATIONAL
3393   19A5 D7            push a
3394   19A6 11            mov a, b
3395   19A7 26 00 00      mov b, $0
3396   19AA B0            cmp a, b
3397   19AB FD 73         slt ; < (signed)
3398   19AD E4            pop a
3399   19AE             ; --- END RELATIONAL
3400   19AE C0 00 00      cmp b, 0
3401   19B1 C6 E5 19      je _if51_else
3402   19B4             _if51_true:
3403   19B4             ; *dest++ = '-'; 
3404   19B4 FA 05 00      lea d, [bp + 5] ; $dest
3405   19B7 2A            mov b, [d]
3406   19B8 FD 77         inc b
3407   19BA FA 05 00      lea d, [bp + 5] ; $dest
3408   19BD FD 43         mov [d], b
3409   19BF FD 7D         dec b
3410   19C1 D8            push b
3411   19C2 26 2D 00      mov b, $2d
3412   19C5 E7            pop d
3413   19C6 FD 3E         mov [d], bl
3414   19C8             ; num = -num; 
3415   19C8 FA 07 00      lea d, [bp + 7] ; $num
3416   19CB DA            push d
3417   19CC FA 07 00      lea d, [bp + 7] ; $num
3418   19CF 2A            mov b, [d]
3419   19D0 FD 97         neg b
3420   19D2 E7            pop d
3421   19D3 FD 43         mov [d], b
3422   19D5             ; len++; 
3423   19D5 FA F8 FF      lea d, [bp + -8] ; $len
3424   19D8 2A            mov b, [d]
3425   19D9 FD 77         inc b
3426   19DB FA F8 FF      lea d, [bp + -8] ; $len
3427   19DE FD 43         mov [d], b
3428   19E0 FD 7D         dec b
3429   19E2 0A 1F 1A      jmp _if51_exit
3430   19E5             _if51_else:
3431   19E5             ; if (num == 0) { 
3432   19E5             _if52_cond:
3433   19E5 FA 07 00      lea d, [bp + 7] ; $num
3434   19E8 2A            mov b, [d]
3435   19E9             ; --- START RELATIONAL
3436   19E9 D7            push a
3437   19EA 11            mov a, b
3438   19EB 26 00 00      mov b, $0
3439   19EE B0            cmp a, b
3440   19EF FD 71         seq ; ==
3441   19F1 E4            pop a
3442   19F2             ; --- END RELATIONAL
3443   19F2 C0 00 00      cmp b, 0
3444   19F5 C6 1F 1A      je _if52_exit
3445   19F8             _if52_true:
3446   19F8             ; *dest++ = '0'; 
3447   19F8 FA 05 00      lea d, [bp + 5] ; $dest
3448   19FB 2A            mov b, [d]
3449   19FC FD 77         inc b
3450   19FE FA 05 00      lea d, [bp + 5] ; $dest
3451   1A01 FD 43         mov [d], b
3452   1A03 FD 7D         dec b
3453   1A05 D8            push b
3454   1A06 26 30 00      mov b, $30
3455   1A09 E7            pop d
3456   1A0A FD 3E         mov [d], bl
3457   1A0C             ; *dest = '\0'; 
3458   1A0C FA 05 00      lea d, [bp + 5] ; $dest
3459   1A0F 2A            mov b, [d]
3460   1A10 D8            push b
3461   1A11 26 00 00      mov b, $0
3462   1A14 E7            pop d
3463   1A15 FD 3E         mov [d], bl
3464   1A17             ; return 1; 
3465   1A17 26 01 00      mov b, $1
3466   1A1A F9            leave
3467   1A1B 09            ret
3468   1A1C 0A 1F 1A      jmp _if52_exit
3469   1A1F             _if52_exit:
3470   1A1F             _if51_exit:
3471   1A1F             ; while (num > 0) { 
3472   1A1F             _while53_cond:
3473   1A1F FA 07 00      lea d, [bp + 7] ; $num
3474   1A22 2A            mov b, [d]
3475   1A23             ; --- START RELATIONAL
3476   1A23 D7            push a
3477   1A24 11            mov a, b
3478   1A25 26 00 00      mov b, $0
3479   1A28 B0            cmp a, b
3480   1A29 FD 7F         sgt ; >
3481   1A2B E4            pop a
3482   1A2C             ; --- END RELATIONAL
3483   1A2C C0 00 00      cmp b, 0
3484   1A2F C6 79 1A      je _while53_exit
3485   1A32             _while53_block:
3486   1A32             ; digits[i] = '0' + (num % 10); 
3487   1A32 FA FC FF      lea d, [bp + -4] ; $digits
3488   1A35 D7            push a
3489   1A36 DA            push d
3490   1A37 FA FA FF      lea d, [bp + -6] ; $i
3491   1A3A 2A            mov b, [d]
3492   1A3B E7            pop d
3493   1A3C 5A            add d, b
3494   1A3D E4            pop a
3495   1A3E DA            push d
3496   1A3F 26 30 00      mov b, $30
3497   1A42             ; --- START TERMS
3498   1A42 D7            push a
3499   1A43 11            mov a, b
3500   1A44 FA 07 00      lea d, [bp + 7] ; $num
3501   1A47 2A            mov b, [d]
3502   1A48             ; --- START FACTORS
3503   1A48 D7            push a
3504   1A49 11            mov a, b
3505   1A4A 26 0A 00      mov b, $a
3506   1A4D AE            div a, b ; 
3507   1A4E 11            mov a, b
3508   1A4F 27            mov b, a
3509   1A50 E4            pop a
3510   1A51             ; --- END FACTORS
3511   1A51 56            add b, a
3512   1A52 E4            pop a
3513   1A53             ; --- END TERMS
3514   1A53 E7            pop d
3515   1A54 FD 3E         mov [d], bl
3516   1A56             ; num = num / 10; 
3517   1A56 FA 07 00      lea d, [bp + 7] ; $num
3518   1A59 DA            push d
3519   1A5A FA 07 00      lea d, [bp + 7] ; $num
3520   1A5D 2A            mov b, [d]
3521   1A5E             ; --- START FACTORS
3522   1A5E D7            push a
3523   1A5F 11            mov a, b
3524   1A60 26 0A 00      mov b, $a
3525   1A63 AE            div a, b
3526   1A64 27            mov b, a
3527   1A65 E4            pop a
3528   1A66             ; --- END FACTORS
3529   1A66 E7            pop d
3530   1A67 FD 43         mov [d], b
3531   1A69             ; i++; 
3532   1A69 FA FA FF      lea d, [bp + -6] ; $i
3533   1A6C 2A            mov b, [d]
3534   1A6D FD 77         inc b
3535   1A6F FA FA FF      lea d, [bp + -6] ; $i
3536   1A72 FD 43         mov [d], b
3537   1A74 FD 7D         dec b
3538   1A76 0A 1F 1A      jmp _while53_cond
3539   1A79             _while53_exit:
3540   1A79             ; while (i > 0) { 
3541   1A79             _while54_cond:
3542   1A79 FA FA FF      lea d, [bp + -6] ; $i
3543   1A7C 2A            mov b, [d]
3544   1A7D             ; --- START RELATIONAL
3545   1A7D D7            push a
3546   1A7E 11            mov a, b
3547   1A7F 26 00 00      mov b, $0
3548   1A82 B0            cmp a, b
3549   1A83 FD 7F         sgt ; >
3550   1A85 E4            pop a
3551   1A86             ; --- END RELATIONAL
3552   1A86 C0 00 00      cmp b, 0
3553   1A89 C6 C9 1A      je _while54_exit
3554   1A8C             _while54_block:
3555   1A8C             ; i--; 
3556   1A8C FA FA FF      lea d, [bp + -6] ; $i
3557   1A8F 2A            mov b, [d]
3558   1A90 FD 7D         dec b
3559   1A92 FA FA FF      lea d, [bp + -6] ; $i
3560   1A95 FD 43         mov [d], b
3561   1A97 FD 77         inc b
3562   1A99             ; *dest++ = digits[i]; 
3563   1A99 FA 05 00      lea d, [bp + 5] ; $dest
3564   1A9C 2A            mov b, [d]
3565   1A9D FD 77         inc b
3566   1A9F FA 05 00      lea d, [bp + 5] ; $dest
3567   1AA2 FD 43         mov [d], b
3568   1AA4 FD 7D         dec b
3569   1AA6 D8            push b
3570   1AA7 FA FC FF      lea d, [bp + -4] ; $digits
3571   1AAA D7            push a
3572   1AAB DA            push d
3573   1AAC FA FA FF      lea d, [bp + -6] ; $i
3574   1AAF 2A            mov b, [d]
3575   1AB0 E7            pop d
3576   1AB1 5A            add d, b
3577   1AB2 E4            pop a
3578   1AB3 32            mov bl, [d]
3579   1AB4 A7 00         mov bh, 0
3580   1AB6 E7            pop d
3581   1AB7 FD 3E         mov [d], bl
3582   1AB9             ; len++; 
3583   1AB9 FA F8 FF      lea d, [bp + -8] ; $len
3584   1ABC 2A            mov b, [d]
3585   1ABD FD 77         inc b
3586   1ABF FA F8 FF      lea d, [bp + -8] ; $len
3587   1AC2 FD 43         mov [d], b
3588   1AC4 FD 7D         dec b
3589   1AC6 0A 79 1A      jmp _while54_cond
3590   1AC9             _while54_exit:
3591   1AC9             ; *dest = '\0'; 
3592   1AC9 FA 05 00      lea d, [bp + 5] ; $dest
3593   1ACC 2A            mov b, [d]
3594   1ACD D8            push b
3595   1ACE 26 00 00      mov b, $0
3596   1AD1 E7            pop d
3597   1AD2 FD 3E         mov [d], bl
3598   1AD4             ; return len; 
3599   1AD4 FA F8 FF      lea d, [bp + -8] ; $len
3600   1AD7 2A            mov b, [d]
3601   1AD8 F9            leave
3602   1AD9 09            ret
3603   1ADA             
3604   1ADA             date:
3605   1ADA F8 00 00      enter 0 ; (push bp; mov bp, sp)
3606   1ADD             
3607   1ADD             ; --- BEGIN INLINE ASM SEGMENT
3608   1ADD 19 00         mov al, 0 
3609   1ADF 05 07         syscall sys_datetime
3610   1AE1             ; --- END INLINE ASM SEGMENT
3611   1AE1             
3612   1AE1 F9            leave
3613   1AE2 09            ret
3614   1AE3             
3615   1AE3             putchar:
3616   1AE3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3617   1AE6             
3618   1AE6             ; --- BEGIN INLINE ASM SEGMENT
3619   1AE6 FA 05 00      lea d, [bp + 5] ; $c
3620   1AE9 1E            mov al, [d]
3621   1AEA 23            mov ah, al
3622   1AEB 07 DA 1C      call _putchar
3623   1AEE             ; --- END INLINE ASM SEGMENT
3624   1AEE             
3625   1AEE F9            leave
3626   1AEF 09            ret
3627   1AF0             
3628   1AF0             getchar:
3629   1AF0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3630   1AF3             ; char c; 
3631   1AF3 52 01 00      sub sp, 1
3632   1AF6             
3633   1AF6             ; --- BEGIN INLINE ASM SEGMENT
3634   1AF6 07 D3 1C      call getch
3635   1AF9 1A            mov al, ah
3636   1AFA FA 00 00      lea d, [bp + 0] ; $c
3637   1AFD 3E            mov [d], al
3638   1AFE             ; --- END INLINE ASM SEGMENT
3639   1AFE             
3640   1AFE             ; return c; 
3641   1AFE FA 00 00      lea d, [bp + 0] ; $c
3642   1B01 32            mov bl, [d]
3643   1B02 A7 00         mov bh, 0
3644   1B04 F9            leave
3645   1B05 09            ret
3646   1B06             
3647   1B06             scann:
3648   1B06 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3649   1B09             ; int m; 
3650   1B09 52 02 00      sub sp, 2
3651   1B0C             
3652   1B0C             ; --- BEGIN INLINE ASM SEGMENT
3653   1B0C 07 1E 1F      call scan_u16d
3654   1B0F FA FF FF      lea d, [bp + -1] ; $m
3655   1B12 43            mov [d], a
3656   1B13             ; --- END INLINE ASM SEGMENT
3657   1B13             
3658   1B13             ; return m; 
3659   1B13 FA FF FF      lea d, [bp + -1] ; $m
3660   1B16 2A            mov b, [d]
3661   1B17 F9            leave
3662   1B18 09            ret
3663   1B19             
3664   1B19             puts:
3665   1B19 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3666   1B1C             
3667   1B1C             ; --- BEGIN INLINE ASM SEGMENT
3668   1B1C FA 05 00      lea d, [bp + 5] ; $s
3669   1B1F 15            mov a, [d]
3670   1B20 3C            mov d, a
3671   1B21 07 24 1E      call _puts
3672   1B24 10 00 0A      mov a, $0A00
3673   1B27 05 03         syscall sys_io
3674   1B29             ; --- END INLINE ASM SEGMENT
3675   1B29             
3676   1B29 F9            leave
3677   1B2A 09            ret
3678   1B2B             
3679   1B2B             print:
3680   1B2B F8 00 00      enter 0 ; (push bp; mov bp, sp)
3681   1B2E             
3682   1B2E             ; --- BEGIN INLINE ASM SEGMENT
3683   1B2E FA 05 00      lea d, [bp + 5] ; $s
3684   1B31 FD 2A         mov d, [d]
3685   1B33 07 24 1E      call _puts
3686   1B36             ; --- END INLINE ASM SEGMENT
3687   1B36             
3688   1B36 F9            leave
3689   1B37 09            ret
3690   1B38             
3691   1B38             getparam:
3692   1B38 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3693   1B3B             ; char data; 
3694   1B3B 52 01 00      sub sp, 1
3695   1B3E             
3696   1B3E             ; --- BEGIN INLINE ASM SEGMENT
3697   1B3E 19 04         mov al, 4
3698   1B40 FA 05 00      lea d, [bp + 5] ; $address
3699   1B43 FD 2A         mov d, [d]
3700   1B45 05 0C         syscall sys_system
3701   1B47 FA 00 00      lea d, [bp + 0] ; $data
3702   1B4A FD 3E         mov [d], bl
3703   1B4C             ; --- END INLINE ASM SEGMENT
3704   1B4C             
3705   1B4C             ; return data; 
3706   1B4C FA 00 00      lea d, [bp + 0] ; $data
3707   1B4F 32            mov bl, [d]
3708   1B50 A7 00         mov bh, 0
3709   1B52 F9            leave
3710   1B53 09            ret
3711   1B54             
3712   1B54             clear:
3713   1B54 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3714   1B57             ; print("\033[2J\033[H"); 
3715   1B57 26 BA 1F      mov b, _s2 ; "\033[2J\033[H"
3716   1B5A FD AB         swp b
3717   1B5C D8            push b
3718   1B5D 07 2B 1B      call print
3719   1B60 51 02 00      add sp, 2
3720   1B63 F9            leave
3721   1B64 09            ret
3722   1B65             
3723   1B65             abs:
3724   1B65 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3725   1B68             ; return i < 0 ? -i : i; 
3726   1B68             _ternary55_cond:
3727   1B68 FA 05 00      lea d, [bp + 5] ; $i
3728   1B6B 2A            mov b, [d]
3729   1B6C             ; --- START RELATIONAL
3730   1B6C D7            push a
3731   1B6D 11            mov a, b
3732   1B6E 26 00 00      mov b, $0
3733   1B71 B0            cmp a, b
3734   1B72 FD 73         slt ; < (signed)
3735   1B74 E4            pop a
3736   1B75             ; --- END RELATIONAL
3737   1B75 C0 00 00      cmp b, 0
3738   1B78 C6 84 1B      je _ternary55_false
3739   1B7B             _ternary55_true:
3740   1B7B FA 05 00      lea d, [bp + 5] ; $i
3741   1B7E 2A            mov b, [d]
3742   1B7F FD 97         neg b
3743   1B81 0A 88 1B      jmp _ternary55_exit
3744   1B84             _ternary55_false:
3745   1B84 FA 05 00      lea d, [bp + 5] ; $i
3746   1B87 2A            mov b, [d]
3747   1B88             _ternary55_exit:
3748   1B88 F9            leave
3749   1B89 09            ret
3750   1B8A             
3751   1B8A             loadfile:
3752   1B8A F8 00 00      enter 0 ; (push bp; mov bp, sp)
3753   1B8D             
3754   1B8D             ; --- BEGIN INLINE ASM SEGMENT
3755   1B8D FA 07 00      lea d, [bp + 7] ; $destination
3756   1B90 15            mov a, [d]
3757   1B91 4F            mov di, a
3758   1B92 FA 05 00      lea d, [bp + 5] ; $filename
3759   1B95 FD 2A         mov d, [d]
3760   1B97 19 14         mov al, 20
3761   1B99 05 04         syscall sys_filesystem
3762   1B9B             ; --- END INLINE ASM SEGMENT
3763   1B9B             
3764   1B9B F9            leave
3765   1B9C 09            ret
3766   1B9D             
3767   1B9D             create_file:
3768   1B9D F8 00 00      enter 0 ; (push bp; mov bp, sp)
3769   1BA0 F9            leave
3770   1BA1 09            ret
3771   1BA2             
3772   1BA2             delete_file:
3773   1BA2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3774   1BA5             
3775   1BA5             ; --- BEGIN INLINE ASM SEGMENT
3776   1BA5 FA 05 00      lea d, [bp + 5] ; $filename
3777   1BA8 19 0A         mov al, 10
3778   1BAA 05 04         syscall sys_filesystem
3779   1BAC             ; --- END INLINE ASM SEGMENT
3780   1BAC             
3781   1BAC F9            leave
3782   1BAD 09            ret
3783   1BAE             
3784   1BAE             load_hex:
3785   1BAE F8 00 00      enter 0 ; (push bp; mov bp, sp)
3786   1BB1             ; char *temp; 
3787   1BB1 52 02 00      sub sp, 2
3788   1BB4             ; temp = alloc(32768); 
3789   1BB4 FA FF FF      lea d, [bp + -1] ; $temp
3790   1BB7 DA            push d
3791   1BB8 26 00 80      mov b, $8000
3792   1BBB FD AB         swp b
3793   1BBD D8            push b
3794   1BBE 07 57 07      call alloc
3795   1BC1 51 02 00      add sp, 2
3796   1BC4 E7            pop d
3797   1BC5 FD 43         mov [d], b
3798   1BC7             
3799   1BC7             ; --- BEGIN INLINE ASM SEGMENT
3800   1BC7               
3801   1BC7               
3802   1BC7               
3803   1BC7             _load_hex:
3804   1BC7 FA 05 00      lea d, [bp + 5] ; $destination
3805   1BCA FD 2A         mov d, [d]
3806   1BCC FD 50         mov di, d
3807   1BCE FA FF FF      lea d, [bp + -1] ; $temp
3808   1BD1 FD 2A         mov d, [d]
3809   1BD3 38 00 00      mov c, 0
3810   1BD6 48            mov a, sp
3811   1BD7 77            inc a
3812   1BD8 3C            mov d, a          
3813   1BD9 07 E1 1C      call _gets        
3814   1BDC 4D            mov si, a
3815   1BDD             __load_hex_loop:
3816   1BDD F6            lodsb             
3817   1BDE B9 00         cmp al, 0         
3818   1BE0 C6 EE 1B      jz __load_hex_ret
3819   1BE3 36            mov bh, al
3820   1BE4 F6            lodsb
3821   1BE5 2F            mov bl, al
3822   1BE6 07 98 1C      call _atoi        
3823   1BE9 F7            stosb             
3824   1BEA 78            inc c
3825   1BEB 0A DD 1B      jmp __load_hex_loop
3826   1BEE             __load_hex_ret:
3827   1BEE             ; --- END INLINE ASM SEGMENT
3828   1BEE             
3829   1BEE F9            leave
3830   1BEF 09            ret
3831   1BF0             
3832   1BF0             include_stdio_asm:
3833   1BF0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3834   1BF3             
3835   1BF3             ; --- BEGIN INLINE ASM SEGMENT
3836   1BF3             .include "lib/asm/stdio.asm"
0001+  1BF3             ;-----------------------------------------------------------------------------
0002+  1BF3             ; stdio.s
0003+  1BF3             ;-----------------------------------------------------------------------------
0004+  1BF3             .include "lib/asm/string.asm"
0001++ 1BF3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 1BF3             ; string.s
0003++ 1BF3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 1BF3             
0005++ 1BF3             
0006++ 1BF3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 1BF3             ; _strrev
0008++ 1BF3             ; reverse a string
0009++ 1BF3             ; D = string address
0010++ 1BF3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 1BF3             ; 01234
0012++ 1BF3             _strrev:
0013++ 1BF3 4B          	pusha
0014++ 1BF4 07 3A 1C    	call _strlen	; length in C
0015++ 1BF7 12          	mov a, c
0016++ 1BF8 AF 01 00    	cmp a, 1
0017++ 1BFB D0 15 1C    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 1BFE 7D          	dec a
0019++ 1BFF FD 4E       	mov si, d	; beginning of string
0020++ 1C01 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 1C03 59          	add d, a	; end of string
0022++ 1C04 12          	mov a, c
0023++ 1C05 FD 9B       	shr a		; divide by 2
0024++ 1C07 39          	mov c, a	; C now counts the steps
0025++ 1C08             _strrev_L0:
0026++ 1C08 32          	mov bl, [d]	; save load right-side char into BL
0027++ 1C09 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 1C0A 3E          	mov [d], al	; store left char into right side
0029++ 1C0B 1B          	mov al, bl
0030++ 1C0C F7          	stosb		; store right-side char into left-side; increase DI
0031++ 1C0D 7E          	dec c
0032++ 1C0E 7F          	dec d
0033++ 1C0F C2 00 00    	cmp c, 0
0034++ 1C12 C7 08 1C    	jne _strrev_L0
0035++ 1C15             _strrev_end:
0036++ 1C15 4C          	popa
0037++ 1C16 09          	ret
0038++ 1C17             	
0039++ 1C17             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 1C17             ; _strchr
0041++ 1C17             ; search string in D for char in AL
0042++ 1C17             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 1C17             _strchr:
0044++ 1C17             _strchr_L0:
0045++ 1C17 32          	mov bl, [d]
0046++ 1C18 C1 00       	cmp bl, 0
0047++ 1C1A C6 25 1C    	je _strchr_end
0048++ 1C1D BA          	cmp al, bl
0049++ 1C1E C6 25 1C    	je _strchr_end
0050++ 1C21 79          	inc d
0051++ 1C22 0A 17 1C    	jmp _strchr_L0
0052++ 1C25             _strchr_end:
0053++ 1C25 1B          	mov al, bl
0054++ 1C26 09          	ret
0055++ 1C27             
0056++ 1C27             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 1C27             ; _strstr
0058++ 1C27             ; find sub-string
0059++ 1C27             ; str1 in SI
0060++ 1C27             ; str2 in DI
0061++ 1C27             ; SI points to end of source string
0062++ 1C27             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 1C27             _strstr:
0064++ 1C27 DB          	push al
0065++ 1C28 DA          	push d
0066++ 1C29 E3          	push di
0067++ 1C2A             _strstr_loop:
0068++ 1C2A F3          	cmpsb					; compare a byte of the strings
0069++ 1C2B C7 36 1C    	jne _strstr_ret
0070++ 1C2E FC 00 00    	lea d, [di + 0]
0071++ 1C31 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1C33 C7 2A 1C    	jne _strstr_loop				; equal chars but not at end
0073++ 1C36             _strstr_ret:
0074++ 1C36 F0          	pop di
0075++ 1C37 E7          	pop d
0076++ 1C38 E8          	pop al
0077++ 1C39 09          	ret
0078++ 1C3A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1C3A             ; length of null terminated string
0080++ 1C3A             ; result in C
0081++ 1C3A             ; pointer in D
0082++ 1C3A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1C3A             _strlen:
0084++ 1C3A DA          	push d
0085++ 1C3B 38 00 00    	mov c, 0
0086++ 1C3E             _strlen_L1:
0087++ 1C3E BD 00       	cmp byte [d], 0
0088++ 1C40 C6 48 1C    	je _strlen_ret
0089++ 1C43 79          	inc d
0090++ 1C44 78          	inc c
0091++ 1C45 0A 3E 1C    	jmp _strlen_L1
0092++ 1C48             _strlen_ret:
0093++ 1C48 E7          	pop d
0094++ 1C49 09          	ret
0095++ 1C4A             
0096++ 1C4A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1C4A             ; STRCMP
0098++ 1C4A             ; compare two strings
0099++ 1C4A             ; str1 in SI
0100++ 1C4A             ; str2 in DI
0101++ 1C4A             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 1C4A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1C4A             _strcmp:
0104++ 1C4A DB          	push al
0105++ 1C4B DA          	push d
0106++ 1C4C E3          	push di
0107++ 1C4D E2          	push si
0108++ 1C4E             _strcmp_loop:
0109++ 1C4E F3          	cmpsb					; compare a byte of the strings
0110++ 1C4F C7 5A 1C    	jne _strcmp_ret
0111++ 1C52 FB FF FF    	lea d, [si +- 1]
0112++ 1C55 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1C57 C7 4E 1C    	jne _strcmp_loop				; equal chars but not at end
0114++ 1C5A             _strcmp_ret:
0115++ 1C5A EF          	pop si
0116++ 1C5B F0          	pop di
0117++ 1C5C E7          	pop d
0118++ 1C5D E8          	pop al
0119++ 1C5E 09          	ret
0120++ 1C5F             
0121++ 1C5F             
0122++ 1C5F             ; STRCPY
0123++ 1C5F             ; copy null terminated string from SI to DI
0124++ 1C5F             ; source in SI
0125++ 1C5F             ; destination in DI
0126++ 1C5F             _strcpy:
0127++ 1C5F E2          	push si
0128++ 1C60 E3          	push di
0129++ 1C61 DB          	push al
0130++ 1C62             _strcpy_L1:
0131++ 1C62 F6          	lodsb
0132++ 1C63 F7          	stosb
0133++ 1C64 B9 00       	cmp al, 0
0134++ 1C66 C7 62 1C    	jne _strcpy_L1
0135++ 1C69             _strcpy_end:
0136++ 1C69 E8          	pop al
0137++ 1C6A F0          	pop di
0138++ 1C6B EF          	pop si
0139++ 1C6C 09          	ret
0140++ 1C6D             
0141++ 1C6D             ; STRCAT
0142++ 1C6D             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 1C6D             ; source in SI
0144++ 1C6D             ; destination in DI
0145++ 1C6D             _strcat:
0146++ 1C6D E2          	push si
0147++ 1C6E E3          	push di
0148++ 1C6F D7          	push a
0149++ 1C70 DA          	push d
0150++ 1C71 50          	mov a, di
0151++ 1C72 3C          	mov d, a
0152++ 1C73             _strcat_goto_end_L1:
0153++ 1C73 BD 00       	cmp byte[d], 0
0154++ 1C75 C6 7C 1C    	je _strcat_start
0155++ 1C78 79          	inc d
0156++ 1C79 0A 73 1C    	jmp _strcat_goto_end_L1
0157++ 1C7C             _strcat_start:
0158++ 1C7C FD 50       	mov di, d
0159++ 1C7E             _strcat_L1:
0160++ 1C7E F6          	lodsb
0161++ 1C7F F7          	stosb
0162++ 1C80 B9 00       	cmp al, 0
0163++ 1C82 C7 7E 1C    	jne _strcat_L1
0164++ 1C85             _strcat_end:
0165++ 1C85 E7          	pop d
0166++ 1C86 E4          	pop a
0167++ 1C87 F0          	pop di
0168++ 1C88 EF          	pop si
0169++ 1C89 09          	ret
0170++ 1C8A             
0171++ 1C8A             
0005+  1C8A             
0006+  1C8A             ;-----------------------------------------------------------------------------
0007+  1C8A             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0008+  1C8A             ; ASCII in BL
0009+  1C8A             ; result in AL
0010+  1C8A             ; ascii for F = 0100 0110
0011+  1C8A             ; ascii for 9 = 0011 1001
0012+  1C8A             ;-----------------------------------------------------------------------------
0013+  1C8A             hex_ascii_encode:
0014+  1C8A 1B            mov al, bl
0015+  1C8B 93 40         test al, $40        ; test if letter or number
0016+  1C8D C7 93 1C      jnz hex_letter
0017+  1C90 87 0F         and al, $0F        ; get number
0018+  1C92 09            ret
0019+  1C93             hex_letter:
0020+  1C93 87 0F         and al, $0F        ; get letter
0021+  1C95 6A 09         add al, 9
0022+  1C97 09            ret
0023+  1C98             
0024+  1C98             ;-----------------------------------------------------------------------------
0025+  1C98             ; ATOI
0026+  1C98             ; 2 letter hex string in B
0027+  1C98             ; 8bit integer returned in AL
0028+  1C98             ;-----------------------------------------------------------------------------
0029+  1C98             _atoi:
0030+  1C98 D8            push b
0031+  1C99 07 8A 1C      call hex_ascii_encode      ; convert BL to 4bit code in AL
0032+  1C9C 30            mov bl, bh
0033+  1C9D DB            push al          ; save a
0034+  1C9E 07 8A 1C      call hex_ascii_encode
0035+  1CA1 EA            pop bl  
0036+  1CA2 FD 9E 04      shl al, 4
0037+  1CA5 8C            or al, bl
0038+  1CA6 E5            pop b
0039+  1CA7 09            ret  
0040+  1CA8             
0041+  1CA8             
0042+  1CA8             ;-----------------------------------------------------------------------------
0043+  1CA8             ; ITOA
0044+  1CA8             ; 8bit value in BL
0045+  1CA8             ; 2 byte ASCII result in A
0046+  1CA8             ;-----------------------------------------------------------------------------
0047+  1CA8             _itoa:
0048+  1CA8 DA            push d
0049+  1CA9 D8            push b
0050+  1CAA A7 00         mov bh, 0
0051+  1CAC FD A4 04      shr bl, 4  
0052+  1CAF 74            mov d, b
0053+  1CB0 1F 58 1F      mov al, [d + s_hex_digits]
0054+  1CB3 23            mov ah, al
0055+  1CB4               
0056+  1CB4 E5            pop b
0057+  1CB5 D8            push b
0058+  1CB6 A7 00         mov bh, 0
0059+  1CB8 FD 87 0F      and bl, $0F
0060+  1CBB 74            mov d, b
0061+  1CBC 1F 58 1F      mov al, [d + s_hex_digits]
0062+  1CBF E5            pop b
0063+  1CC0 E7            pop d
0064+  1CC1 09            ret
0065+  1CC2             
0066+  1CC2             ;-----------------------------------------------------------------------------
0067+  1CC2             ; HEX STRING TO BINARY
0068+  1CC2             ; di = destination address
0069+  1CC2             ; si = source
0070+  1CC2             ;-----------------------------------------------------------------------------
0071+  1CC2             _hex_to_int:
0072+  1CC2             _hex_to_int_L1:
0073+  1CC2 F6            lodsb          ; load from [SI] to AL
0074+  1CC3 B9 00         cmp al, 0        ; check if ASCII 0
0075+  1CC5 C6 D2 1C      jz _hex_to_int_ret
0076+  1CC8 36            mov bh, al
0077+  1CC9 F6            lodsb
0078+  1CCA 2F            mov bl, al
0079+  1CCB 07 98 1C      call _atoi        ; convert ASCII byte in B to int (to AL)
0080+  1CCE F7            stosb          ; store AL to [DI]
0081+  1CCF 0A C2 1C      jmp _hex_to_int_L1
0082+  1CD2             _hex_to_int_ret:
0083+  1CD2 09            ret    
0084+  1CD3             
0085+  1CD3             ;-----------------------------------------------------------------------------
0086+  1CD3             ; GETCHAR
0087+  1CD3             ; char in ah
0088+  1CD3             ;-----------------------------------------------------------------------------
0089+  1CD3             getch:
0090+  1CD3 DB            push al
0091+  1CD4             getch_retry:
0092+  1CD4 19 01         mov al, 1
0093+  1CD6 05 03         syscall sys_io      ; receive in AH
0094+  1CD8 E8            pop al
0095+  1CD9 09            ret
0096+  1CDA             
0097+  1CDA             ;-----------------------------------------------------------------------------
0098+  1CDA             ; PUTCHAR
0099+  1CDA             ; char in ah
0100+  1CDA             ;-----------------------------------------------------------------------------
0101+  1CDA             _putchar:
0102+  1CDA D7            push a
0103+  1CDB 19 00         mov al, 0
0104+  1CDD 05 03         syscall sys_io      ; char in AH
0105+  1CDF E4            pop a
0106+  1CE0 09            ret
0107+  1CE1             
0108+  1CE1             ;-----------------------------------------------------------------------------
0109+  1CE1             ;; INPUT A STRING
0110+  1CE1             ;; terminates with null
0111+  1CE1             ;; pointer in D
0112+  1CE1             ;-----------------------------------------------------------------------------
0113+  1CE1             _gets:
0114+  1CE1 D7            push a
0115+  1CE2 DA            push d
0116+  1CE3             _gets_loop:
0117+  1CE3 19 01         mov al, 1
0118+  1CE5 05 03         syscall sys_io      ; receive in AH
0119+  1CE7 B9 00         cmp al, 0        ; check error code (AL)
0120+  1CE9 C6 E3 1C      je _gets_loop      ; if no char received, retry
0121+  1CEC             
0122+  1CEC 76 1B         cmp ah, 27
0123+  1CEE C6 0F 1D      je _gets_ansi_esc
0124+  1CF1 76 0A         cmp ah, $0A        ; LF
0125+  1CF3 C6 7A 1D      je _gets_end
0126+  1CF6 76 0D         cmp ah, $0D        ; CR
0127+  1CF8 C6 7A 1D      je _gets_end
0128+  1CFB 76 5C         cmp ah, $5C        ; '\\'
0129+  1CFD C6 3B 1D      je _gets_escape
0130+  1D00               
0131+  1D00 76 08         cmp ah, $08      ; check for backspace
0132+  1D02 C6 0B 1D      je _gets_backspace
0133+  1D05             
0134+  1D05 1A            mov al, ah
0135+  1D06 3E            mov [d], al
0136+  1D07 79            inc d
0137+  1D08 0A E3 1C      jmp _gets_loop
0138+  1D0B             _gets_backspace:
0139+  1D0B 7F            dec d
0140+  1D0C 0A E3 1C      jmp _gets_loop
0141+  1D0F             _gets_ansi_esc:
0142+  1D0F 19 01         mov al, 1
0143+  1D11 05 03         syscall sys_io        ; receive in AH without echo
0144+  1D13 B9 00         cmp al, 0          ; check error code (AL)
0145+  1D15 C6 0F 1D      je _gets_ansi_esc    ; if no char received, retry
0146+  1D18 76 5B         cmp ah, '['
0147+  1D1A C7 E3 1C      jne _gets_loop
0148+  1D1D             _gets_ansi_esc_2:
0149+  1D1D 19 01         mov al, 1
0150+  1D1F 05 03         syscall sys_io          ; receive in AH without echo
0151+  1D21 B9 00         cmp al, 0            ; check error code (AL)
0152+  1D23 C6 1D 1D      je _gets_ansi_esc_2  ; if no char received, retry
0153+  1D26 76 44         cmp ah, 'D'
0154+  1D28 C6 33 1D      je _gets_left_arrow
0155+  1D2B 76 43         cmp ah, 'C'
0156+  1D2D C6 37 1D      je _gets_right_arrow
0157+  1D30 0A E3 1C      jmp _gets_loop
0158+  1D33             _gets_left_arrow:
0159+  1D33 7F            dec d
0160+  1D34 0A E3 1C      jmp _gets_loop
0161+  1D37             _gets_right_arrow:
0162+  1D37 79            inc d
0163+  1D38 0A E3 1C      jmp _gets_loop
0164+  1D3B             _gets_escape:
0165+  1D3B 19 01         mov al, 1
0166+  1D3D 05 03         syscall sys_io      ; receive in AH
0167+  1D3F B9 00         cmp al, 0        ; check error code (AL)
0168+  1D41 C6 3B 1D      je _gets_escape      ; if no char received, retry
0169+  1D44 76 6E         cmp ah, 'n'
0170+  1D46 C6 65 1D      je _gets_LF
0171+  1D49 76 72         cmp ah, 'r'
0172+  1D4B C6 6C 1D      je _gets_CR
0173+  1D4E 76 30         cmp ah, '0'
0174+  1D50 C6 73 1D      je _gets_NULL
0175+  1D53 76 5C         cmp ah, $5C  ; '\'
0176+  1D55 C6 5E 1D      je _gets_slash
0177+  1D58 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0178+  1D59 3E            mov [d], al
0179+  1D5A 79            inc d
0180+  1D5B 0A E3 1C      jmp _gets_loop
0181+  1D5E             _gets_slash:
0182+  1D5E 19 5C         mov al, $5C
0183+  1D60 3E            mov [d], al
0184+  1D61 79            inc d
0185+  1D62 0A E3 1C      jmp _gets_loop
0186+  1D65             _gets_LF:
0187+  1D65 19 0A         mov al, $0A
0188+  1D67 3E            mov [d], al
0189+  1D68 79            inc d
0190+  1D69 0A E3 1C      jmp _gets_loop
0191+  1D6C             _gets_CR:
0192+  1D6C 19 0D         mov al, $0D
0193+  1D6E 3E            mov [d], al
0194+  1D6F 79            inc d
0195+  1D70 0A E3 1C      jmp _gets_loop
0196+  1D73             _gets_NULL:
0197+  1D73 19 00         mov al, $00
0198+  1D75 3E            mov [d], al
0199+  1D76 79            inc d
0200+  1D77 0A E3 1C      jmp _gets_loop
0201+  1D7A             _gets_end:
0202+  1D7A 19 00         mov al, 0
0203+  1D7C 3E            mov [d], al        ; terminate string
0204+  1D7D E7            pop d
0205+  1D7E E4            pop a
0206+  1D7F 09            ret
0207+  1D80             
0208+  1D80             ;-----------------------------------------------------------------------------
0209+  1D80             ;; INPUT TEXT
0210+  1D80             ;; terminated with CTRL+D
0211+  1D80             ;; pointer in D
0212+  1D80             ;-----------------------------------------------------------------------------
0213+  1D80             _gettxt:
0214+  1D80 D7            push a
0215+  1D81 DA            push d
0216+  1D82             _gettxt_loop:
0217+  1D82 19 01         mov al, 1
0218+  1D84 05 03         syscall sys_io      ; receive in AH
0219+  1D86 B9 00         cmp al, 0        ; check error code (AL)
0220+  1D88 C6 82 1D      je _gettxt_loop    ; if no char received, retry
0221+  1D8B 76 04         cmp ah, 4      ; EOT
0222+  1D8D C6 CB 1D      je _gettxt_end
0223+  1D90 76 08         cmp ah, $08      ; check for backspace
0224+  1D92 C6 C7 1D      je _gettxt_backspace
0225+  1D95 76 5C         cmp ah, $5C        ; '\'
0226+  1D97 C6 A0 1D      je _gettxt_escape
0227+  1D9A 1A            mov al, ah
0228+  1D9B 3E            mov [d], al
0229+  1D9C 79            inc d
0230+  1D9D 0A 82 1D      jmp _gettxt_loop
0231+  1DA0             _gettxt_escape:
0232+  1DA0 19 01         mov al, 1
0233+  1DA2 05 03         syscall sys_io      ; receive in AH
0234+  1DA4 B9 00         cmp al, 0        ; check error code (AL)
0235+  1DA6 C6 A0 1D      je _gettxt_escape    ; if no char received, retry
0236+  1DA9 76 6E         cmp ah, 'n'
0237+  1DAB C6 B9 1D      je _gettxt_LF
0238+  1DAE 76 72         cmp ah, 'r'
0239+  1DB0 C6 C0 1D      je _gettxt_CR
0240+  1DB3 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0241+  1DB4 3E            mov [d], al
0242+  1DB5 79            inc d
0243+  1DB6 0A 82 1D      jmp _gettxt_loop
0244+  1DB9             _gettxt_LF:
0245+  1DB9 19 0A         mov al, $0A
0246+  1DBB 3E            mov [d], al
0247+  1DBC 79            inc d
0248+  1DBD 0A 82 1D      jmp _gettxt_loop
0249+  1DC0             _gettxt_CR:
0250+  1DC0 19 0D         mov al, $0D
0251+  1DC2 3E            mov [d], al
0252+  1DC3 79            inc d
0253+  1DC4 0A 82 1D      jmp _gettxt_loop
0254+  1DC7             _gettxt_backspace:
0255+  1DC7 7F            dec d
0256+  1DC8 0A 82 1D      jmp _gettxt_loop
0257+  1DCB             _gettxt_end:
0258+  1DCB 19 00         mov al, 0
0259+  1DCD 3E            mov [d], al        ; terminate string
0260+  1DCE E7            pop d
0261+  1DCF E4            pop a
0262+  1DD0 09            ret
0263+  1DD1             
0264+  1DD1             ;-----------------------------------------------------------------------------
0265+  1DD1             ; PRINT NEW LINE
0266+  1DD1             ;-----------------------------------------------------------------------------
0267+  1DD1             printnl:
0268+  1DD1 D7            push a
0269+  1DD2 10 00 0A      mov a, $0A00
0270+  1DD5 05 03         syscall sys_io
0271+  1DD7 10 00 0D      mov a, $0D00
0272+  1DDA 05 03         syscall sys_io
0273+  1DDC E4            pop a
0274+  1DDD 09            ret
0275+  1DDE             
0276+  1DDE             ;-----------------------------------------------------------------------------
0277+  1DDE             ; _strtoint
0278+  1DDE             ; 4 digit hex string number in d
0279+  1DDE             ; integer returned in A
0280+  1DDE             ;-----------------------------------------------------------------------------
0281+  1DDE             _strtointx:
0282+  1DDE D8            push b
0283+  1DDF 32            mov bl, [d]
0284+  1DE0 37            mov bh, bl
0285+  1DE1 33 01 00      mov bl, [d + 1]
0286+  1DE4 07 98 1C      call _atoi        ; convert to int in AL
0287+  1DE7 23            mov ah, al        ; move to AH
0288+  1DE8 33 02 00      mov bl, [d + 2]
0289+  1DEB 37            mov bh, bl
0290+  1DEC 33 03 00      mov bl, [d + 3]
0291+  1DEF 07 98 1C      call _atoi        ; convert to int in AL
0292+  1DF2 E5            pop b
0293+  1DF3 09            ret
0294+  1DF4             
0295+  1DF4             ;-----------------------------------------------------------------------------
0296+  1DF4             ; _strtoint
0297+  1DF4             ; 5 digit base10 string number in d
0298+  1DF4             ; integer returned in A
0299+  1DF4             ;-----------------------------------------------------------------------------
0300+  1DF4             _strtoint:
0301+  1DF4 E2            push si
0302+  1DF5 D8            push b
0303+  1DF6 D9            push c
0304+  1DF7 DA            push d
0305+  1DF8 07 3A 1C      call _strlen      ; get string length in C
0306+  1DFB 7E            dec c
0307+  1DFC FD 4E         mov si, d
0308+  1DFE 12            mov a, c
0309+  1DFF FD 99         shl a
0310+  1E01 3B 70 1F      mov d, table_power
0311+  1E04 59            add d, a
0312+  1E05 38 00 00      mov c, 0
0313+  1E08             _strtoint_L0:
0314+  1E08 F6            lodsb      ; load ASCII to al
0315+  1E09 B9 00         cmp al, 0
0316+  1E0B C6 1E 1E      je _strtoint_end
0317+  1E0E 6F 30         sub al, $30    ; make into integer
0318+  1E10 22 00         mov ah, 0
0319+  1E12 2A            mov b, [d]
0320+  1E13 AC            mul a, b      ; result in B since it fits in 16bits
0321+  1E14 11            mov a, b
0322+  1E15 28            mov b, c
0323+  1E16 54            add a, b
0324+  1E17 39            mov c, a
0325+  1E18 63 02 00      sub d, 2
0326+  1E1B 0A 08 1E      jmp _strtoint_L0
0327+  1E1E             _strtoint_end:
0328+  1E1E 12            mov a, c
0329+  1E1F E7            pop d
0330+  1E20 E6            pop c
0331+  1E21 E5            pop b
0332+  1E22 EF            pop si
0333+  1E23 09            ret
0334+  1E24             
0335+  1E24             ;-----------------------------------------------------------------------------
0336+  1E24             ; PRINT NULL TERMINATED STRING
0337+  1E24             ; pointer in D
0338+  1E24             ;-----------------------------------------------------------------------------
0339+  1E24             _puts:
0340+  1E24 D7            push a
0341+  1E25 DA            push d
0342+  1E26             _puts_L1:
0343+  1E26 1E            mov al, [d]
0344+  1E27 B9 00         cmp al, 0
0345+  1E29 C6 35 1E      jz _puts_END
0346+  1E2C 23            mov ah, al
0347+  1E2D 19 00         mov al, 0
0348+  1E2F 05 03         syscall sys_io
0349+  1E31 79            inc d
0350+  1E32 0A 26 1E      jmp _puts_L1
0351+  1E35             _puts_END:
0352+  1E35 E7            pop d
0353+  1E36 E4            pop a
0354+  1E37 09            ret
0355+  1E38             
0356+  1E38             ;-----------------------------------------------------------------------------
0357+  1E38             ; PRINT N SIZE STRING
0358+  1E38             ; pointer in D
0359+  1E38             ; size in C
0360+  1E38             ;-----------------------------------------------------------------------------
0361+  1E38             _putsn:
0362+  1E38 DB            push al
0363+  1E39 DA            push d
0364+  1E3A D9            push c
0365+  1E3B             _putsn_L0:
0366+  1E3B 1E            mov al, [d]
0367+  1E3C 23            mov ah, al
0368+  1E3D 19 00         mov al, 0
0369+  1E3F 05 03         syscall sys_io
0370+  1E41 79            inc d
0371+  1E42 7E            dec c  
0372+  1E43 C2 00 00      cmp c, 0
0373+  1E46 C7 3B 1E      jne _putsn_L0
0374+  1E49             _putsn_end:
0375+  1E49 E6            pop c
0376+  1E4A E7            pop d
0377+  1E4B E8            pop al
0378+  1E4C 09            ret
0379+  1E4D             
0380+  1E4D             ;-----------------------------------------------------------------------------
0381+  1E4D             ; print 16bit decimal number
0382+  1E4D             ; input number in A
0383+  1E4D             ;-----------------------------------------------------------------------------
0384+  1E4D             print_u16d:
0385+  1E4D D7            push a
0386+  1E4E D8            push b
0387+  1E4F 26 10 27      mov b, 10000
0388+  1E52 AE            div a, b      ; get 10000's coeff.
0389+  1E53 07 75 1E      call print_number
0390+  1E56 11            mov a, b
0391+  1E57 26 E8 03      mov b, 1000
0392+  1E5A AE            div a, b      ; get 1000's coeff.
0393+  1E5B 07 75 1E      call print_number
0394+  1E5E 11            mov a, b
0395+  1E5F 26 64 00      mov b, 100
0396+  1E62 AE            div a, b
0397+  1E63 07 75 1E      call print_number
0398+  1E66 11            mov a, b
0399+  1E67 26 0A 00      mov b, 10
0400+  1E6A AE            div a, b
0401+  1E6B 07 75 1E      call print_number
0402+  1E6E 1B            mov al, bl      ; 1's coeff in bl
0403+  1E6F 07 75 1E      call print_number
0404+  1E72 E5            pop b
0405+  1E73 E4            pop a
0406+  1E74 09            ret
0407+  1E75             
0408+  1E75             ;-----------------------------------------------------------------------------
0409+  1E75             ; print AL
0410+  1E75             ;-----------------------------------------------------------------------------
0411+  1E75             print_number:
0412+  1E75 6A 30         add al, $30
0413+  1E77 23            mov ah, al
0414+  1E78 07 DA 1C      call _putchar
0415+  1E7B 09            ret
0416+  1E7C             
0417+  1E7C             ;-----------------------------------------------------------------------------
0418+  1E7C             ; PRINT 16BIT HEX INTEGER
0419+  1E7C             ; integer value in reg B
0420+  1E7C             ;-----------------------------------------------------------------------------
0421+  1E7C             print_u16x:
0422+  1E7C D7            push a
0423+  1E7D D8            push b
0424+  1E7E DD            push bl
0425+  1E7F 30            mov bl, bh
0426+  1E80 07 A8 1C      call _itoa        ; convert bh to char in A
0427+  1E83 2F            mov bl, al        ; save al
0428+  1E84 19 00         mov al, 0
0429+  1E86 05 03         syscall sys_io        ; display AH
0430+  1E88 24            mov ah, bl        ; retrieve al
0431+  1E89 19 00         mov al, 0
0432+  1E8B 05 03         syscall sys_io        ; display AL
0433+  1E8D             
0434+  1E8D EA            pop bl
0435+  1E8E 07 A8 1C      call _itoa        ; convert bh to char in A
0436+  1E91 2F            mov bl, al        ; save al
0437+  1E92 19 00         mov al, 0
0438+  1E94 05 03         syscall sys_io        ; display AH
0439+  1E96 24            mov ah, bl        ; retrieve al
0440+  1E97 19 00         mov al, 0
0441+  1E99 05 03         syscall sys_io        ; display AL
0442+  1E9B             
0443+  1E9B E5            pop b
0444+  1E9C E4            pop a
0445+  1E9D 09            ret
0446+  1E9E             
0447+  1E9E             ;-----------------------------------------------------------------------------
0448+  1E9E             ; INPUT 16BIT HEX INTEGER
0449+  1E9E             ; read 16bit integer into A
0450+  1E9E             ;-----------------------------------------------------------------------------
0451+  1E9E             scan_u16x:
0452+  1E9E F8 10 00      enter 16
0453+  1EA1 D8            push b
0454+  1EA2 DA            push d
0455+  1EA3             
0456+  1EA3 FA F1 FF      lea d, [bp + -15]
0457+  1EA6 07 E1 1C      call _gets        ; get number
0458+  1EA9             
0459+  1EA9 32            mov bl, [d]
0460+  1EAA 37            mov bh, bl
0461+  1EAB 33 01 00      mov bl, [d + 1]
0462+  1EAE 07 98 1C      call _atoi        ; convert to int in AL
0463+  1EB1 23            mov ah, al        ; move to AH
0464+  1EB2             
0465+  1EB2 33 02 00      mov bl, [d + 2]
0466+  1EB5 37            mov bh, bl
0467+  1EB6 33 03 00      mov bl, [d + 3]
0468+  1EB9 07 98 1C      call _atoi        ; convert to int in AL
0469+  1EBC             
0470+  1EBC E7            pop d
0471+  1EBD E5            pop b
0472+  1EBE F9            leave
0473+  1EBF 09            ret
0474+  1EC0             
0475+  1EC0             ;-----------------------------------------------------------------------------
0476+  1EC0             ; PRINT 8bit HEX INTEGER
0477+  1EC0             ; integer value in reg bl
0478+  1EC0             ;-----------------------------------------------------------------------------
0479+  1EC0             print_u8x:
0480+  1EC0 D7            push a
0481+  1EC1 DD            push bl
0482+  1EC2             
0483+  1EC2 07 A8 1C      call _itoa        ; convert bl to char in A
0484+  1EC5 2F            mov bl, al        ; save al
0485+  1EC6 19 00         mov al, 0
0486+  1EC8 05 03         syscall sys_io        ; display AH
0487+  1ECA 24            mov ah, bl        ; retrieve al
0488+  1ECB 19 00         mov al, 0
0489+  1ECD 05 03         syscall sys_io        ; display AL
0490+  1ECF             
0491+  1ECF EA            pop bl
0492+  1ED0 E4            pop a
0493+  1ED1 09            ret
0494+  1ED2             
0495+  1ED2             ;-----------------------------------------------------------------------------
0496+  1ED2             ; print 8bit decimal unsigned number
0497+  1ED2             ; input number in AL
0498+  1ED2             ;-----------------------------------------------------------------------------
0499+  1ED2             print_u8d:
0500+  1ED2 D7            push a
0501+  1ED3 D8            push b
0502+  1ED4             
0503+  1ED4 22 00         mov ah, 0
0504+  1ED6 26 64 00      mov b, 100
0505+  1ED9 AE            div a, b
0506+  1EDA D8            push b      ; save remainder
0507+  1EDB B9 00         cmp al, 0
0508+  1EDD C6 E7 1E      je skip100
0509+  1EE0 6A 30         add al, $30
0510+  1EE2 23            mov ah, al
0511+  1EE3 19 00         mov al, 0
0512+  1EE5 05 03         syscall sys_io  ; print coeff
0513+  1EE7             skip100:
0514+  1EE7 E4            pop a
0515+  1EE8 22 00         mov ah, 0
0516+  1EEA 26 0A 00      mov b, 10
0517+  1EED AE            div a, b
0518+  1EEE D8            push b      ; save remainder
0519+  1EEF B9 00         cmp al, 0
0520+  1EF1 C6 FB 1E      je skip10
0521+  1EF4 6A 30         add al, $30
0522+  1EF6 23            mov ah, al
0523+  1EF7 19 00         mov al, 0
0524+  1EF9 05 03         syscall sys_io  ; print coeff
0525+  1EFB             skip10:
0526+  1EFB E4            pop a
0527+  1EFC 1B            mov al, bl
0528+  1EFD 6A 30         add al, $30
0529+  1EFF 23            mov ah, al
0530+  1F00 19 00         mov al, 0
0531+  1F02 05 03         syscall sys_io  ; print coeff
0532+  1F04 E5            pop b
0533+  1F05 E4            pop a
0534+  1F06 09            ret
0535+  1F07             
0536+  1F07             ;-----------------------------------------------------------------------------
0537+  1F07             ; INPUT 8BIT HEX INTEGER
0538+  1F07             ; read 8bit integer into AL
0539+  1F07             ;-----------------------------------------------------------------------------
0540+  1F07             scan_u8x:
0541+  1F07 F8 04 00      enter 4
0542+  1F0A D8            push b
0543+  1F0B DA            push d
0544+  1F0C             
0545+  1F0C FA FD FF      lea d, [bp + -3]
0546+  1F0F 07 E1 1C      call _gets        ; get number
0547+  1F12             
0548+  1F12 32            mov bl, [d]
0549+  1F13 37            mov bh, bl
0550+  1F14 33 01 00      mov bl, [d + 1]
0551+  1F17 07 98 1C      call _atoi        ; convert to int in AL
0552+  1F1A             
0553+  1F1A E7            pop d
0554+  1F1B E5            pop b
0555+  1F1C F9            leave
0556+  1F1D 09            ret
0557+  1F1E             
0558+  1F1E             ;-----------------------------------------------------------------------------
0559+  1F1E             ; input decimal number
0560+  1F1E             ; result in A
0561+  1F1E             ; 655'\0'
0562+  1F1E             ; low--------high
0563+  1F1E             ;-----------------------------------------------------------------------------
0564+  1F1E             scan_u16d:
0565+  1F1E F8 08 00      enter 8
0566+  1F21 E2            push si
0567+  1F22 D8            push b
0568+  1F23 D9            push c
0569+  1F24 DA            push d
0570+  1F25 FA F9 FF      lea d, [bp +- 7]
0571+  1F28 07 E1 1C      call _gets
0572+  1F2B 07 3A 1C      call _strlen      ; get string length in C
0573+  1F2E 7E            dec c
0574+  1F2F FD 4E         mov si, d
0575+  1F31 12            mov a, c
0576+  1F32 FD 99         shl a
0577+  1F34 3B 70 1F      mov d, table_power
0578+  1F37 59            add d, a
0579+  1F38 38 00 00      mov c, 0
0580+  1F3B             mul_loop:
0581+  1F3B F6            lodsb      ; load ASCII to al
0582+  1F3C B9 00         cmp al, 0
0583+  1F3E C6 51 1F      je mul_exit
0584+  1F41 6F 30         sub al, $30    ; make into integer
0585+  1F43 22 00         mov ah, 0
0586+  1F45 2A            mov b, [d]
0587+  1F46 AC            mul a, b      ; result in B since it fits in 16bits
0588+  1F47 11            mov a, b
0589+  1F48 28            mov b, c
0590+  1F49 54            add a, b
0591+  1F4A 39            mov c, a
0592+  1F4B 63 02 00      sub d, 2
0593+  1F4E 0A 3B 1F      jmp mul_loop
0594+  1F51             mul_exit:
0595+  1F51 12            mov a, c
0596+  1F52 E7            pop d
0597+  1F53 E6            pop c
0598+  1F54 E5            pop b
0599+  1F55 EF            pop si
0600+  1F56 F9            leave
0601+  1F57 09            ret
0602+  1F58             
0603+  1F58 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0603+  1F5C 34 35 36 37 
0603+  1F60 38 39 41 42 
0603+  1F64 43 44 45 46 
0604+  1F68 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0604+  1F6C 1B 5B 48 00 
0605+  1F70             
0606+  1F70             table_power:
0607+  1F70 01 00         .dw 1
0608+  1F72 0A 00         .dw 10
0609+  1F74 64 00         .dw 100
0610+  1F76 E8 03         .dw 1000
0611+  1F78 10 27         .dw 100003837   1F7A             ; --- END INLINE ASM SEGMENT
3838   1F7A             
3839   1F7A F9            leave
3840   1F7B 09            ret
3841   1F7C             ; --- END TEXT SEGMENT
3842   1F7C             
3843   1F7C             ; --- BEGIN DATA SEGMENT
3844   1F7C 00 00       st_fopen_max_handle: .dw 0
3845   1F7E 55 6E 65 78 _s0: .db "Unexpected format in printf.", 0
3845   1F82 70 65 63 74 
3845   1F86 65 64 20 66 
3845   1F8A 6F 72 6D 61 
3845   1F8E 74 20 69 6E 
3845   1F92 20 70 72 69 
3845   1F96 6E 74 66 2E 
3845   1F9A 00 
3846   1F9B 45 72 72 6F _s1: .db "Error: Unknown argument type.\n", 0
3846   1F9F 72 3A 20 55 
3846   1FA3 6E 6B 6E 6F 
3846   1FA7 77 6E 20 61 
3846   1FAB 72 67 75 6D 
3846   1FAF 65 6E 74 20 
3846   1FB3 74 79 70 65 
3846   1FB7 2E 0A 00 
3847   1FBA 1B 5B 32 4A _s2: .db "\033[2J\033[H", 0
3847   1FBE 1B 5B 48 00 
3848   1FC2             
3849   1FC2 C4 1F       _heap_top: .dw _heap
3850   1FC4 00          _heap: .db 0
3851   1FC5             ; --- END DATA SEGMENT
3852   1FC5             
3853   1FC5             .end
tasm: Number of errors = 0
