0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT SEGMENT
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; printf("Hello World" 
0011   0408             ; --- START FUNCTION CALL
0012   0408 26 25 0D      mov b, _s0 ; "Hello WorldMy name is Sol-1And this is a multi-line string"
0013   040B FD AB         swp b
0014   040D D8            push b
0015   040E 07 16 04      call printf
0016   0411 51 02 00      add sp, 2
0017   0414             ; --- END FUNCTION CALL
0018   0414 05 0B         syscall sys_terminate_proc
0019   0416             
0020   0416             printf:
0021   0416 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0022   0419             ; char *p, *format_p; 
0023   0419 52 02 00      sub sp, 2
0024   041C 52 02 00      sub sp, 2
0025   041F             ; format_p = format; 
0026   041F FA FD FF      lea d, [bp + -3] ; $format_p
0027   0422 DA            push d
0028   0423 FA 05 00      lea d, [bp + 5] ; $format
0029   0426 2A            mov b, [d]
0030   0427 38 00 00      mov c, 0
0031   042A E7            pop d
0032   042B FD 43         mov [d], b
0033   042D             ; p = &format + 2; 
0034   042D FA FF FF      lea d, [bp + -1] ; $p
0035   0430 DA            push d
0036   0431 FA 05 00      lea d, [bp + 5] ; $format
0037   0434 2D            mov b, d
0038   0435             ; --- START TERMS
0039   0435 D7            push a
0040   0436 11            mov a, b
0041   0437 FD 2E 02 00   mov32 cb, $00000002
0041   043B 00 00 
0042   043D 56            add b, a
0043   043E E4            pop a
0044   043F             ; --- END TERMS
0045   043F E7            pop d
0046   0440 FD 43         mov [d], b
0047   0442             ; for(;;){ 
0048   0442             _for1_init:
0049   0442             _for1_cond:
0050   0442             _for1_block:
0051   0442             ; if(!*format_p) break; 
0052   0442             _if2_cond:
0053   0442 FA FD FF      lea d, [bp + -3] ; $format_p
0054   0445 2A            mov b, [d]
0055   0446 38 00 00      mov c, 0
0056   0449 74            mov d, b
0057   044A 32            mov bl, [d]
0058   044B A7 00         mov bh, 0
0059   044D 38 00 00      mov c, 0
0060   0450 C0 00 00      cmp b, 0
0061   0453 FD 71         seq ; !
0062   0455 C0 00 00      cmp b, 0
0063   0458 C6 61 04      je _if2_else
0064   045B             _if2_TRUE:
0065   045B             ; break; 
0066   045B 0A 11 07      jmp _for1_exit ; for break
0067   045E 0A 0E 07      jmp _if2_exit
0068   0461             _if2_else:
0069   0461             ; if(*format_p == '%'){ 
0070   0461             _if3_cond:
0071   0461 FA FD FF      lea d, [bp + -3] ; $format_p
0072   0464 2A            mov b, [d]
0073   0465 38 00 00      mov c, 0
0074   0468 74            mov d, b
0075   0469 32            mov bl, [d]
0076   046A A7 00         mov bh, 0
0077   046C 38 00 00      mov c, 0
0078   046F             ; --- START RELATIONAL
0079   046F D7            push a
0080   0470 11            mov a, b
0081   0471 FD 2E 25 00   mov32 cb, $00000025
0081   0475 00 00 
0082   0477 B0            cmp a, b
0083   0478 FD 71         seq ; ==
0084   047A E4            pop a
0085   047B             ; --- END RELATIONAL
0086   047B C0 00 00      cmp b, 0
0087   047E C6 E9 06      je _if3_else
0088   0481             _if3_TRUE:
0089   0481             ; format_p++; 
0090   0481 FA FD FF      lea d, [bp + -3] ; $format_p
0091   0484 2A            mov b, [d]
0092   0485 38 00 00      mov c, 0
0093   0488 FD 77         inc b
0094   048A FA FD FF      lea d, [bp + -3] ; $format_p
0095   048D FD 43         mov [d], b
0096   048F FD 7D         dec b
0097   0491             ; switch(*format_p){ 
0098   0491             _switch4_expr:
0099   0491 FA FD FF      lea d, [bp + -3] ; $format_p
0100   0494 2A            mov b, [d]
0101   0495 38 00 00      mov c, 0
0102   0498 74            mov d, b
0103   0499 32            mov bl, [d]
0104   049A A7 00         mov bh, 0
0105   049C 38 00 00      mov c, 0
0106   049F             _switch4_comparisons:
0107   049F C1 6C         cmp bl, $6c
0108   04A1 C6 CD 04      je _switch4_case0
0109   04A4 C1 4C         cmp bl, $4c
0110   04A6 C6 CD 04      je _switch4_case1
0111   04A9 C1 64         cmp bl, $64
0112   04AB C6 DD 05      je _switch4_case2
0113   04AE C1 69         cmp bl, $69
0114   04B0 C6 DD 05      je _switch4_case3
0115   04B3 C1 75         cmp bl, $75
0116   04B5 C6 0D 06      je _switch4_case4
0117   04B8 C1 78         cmp bl, $78
0118   04BA C6 3D 06      je _switch4_case5
0119   04BD C1 63         cmp bl, $63
0120   04BF C6 6D 06      je _switch4_case6
0121   04C2 C1 73         cmp bl, $73
0122   04C4 C6 9D 06      je _switch4_case7
0123   04C7 0A CA 06      jmp _switch4_default
0124   04CA 0A D6 06      jmp _switch4_exit
0125   04CD             _switch4_case0:
0126   04CD             _switch4_case1:
0127   04CD             ; format_p++; 
0128   04CD FA FD FF      lea d, [bp + -3] ; $format_p
0129   04D0 2A            mov b, [d]
0130   04D1 38 00 00      mov c, 0
0131   04D4 FD 77         inc b
0132   04D6 FA FD FF      lea d, [bp + -3] ; $format_p
0133   04D9 FD 43         mov [d], b
0134   04DB FD 7D         dec b
0135   04DD             ; if(*format_p == 'd' || *format_p == 'i') 
0136   04DD             _if5_cond:
0137   04DD FA FD FF      lea d, [bp + -3] ; $format_p
0138   04E0 2A            mov b, [d]
0139   04E1 38 00 00      mov c, 0
0140   04E4 74            mov d, b
0141   04E5 32            mov bl, [d]
0142   04E6 A7 00         mov bh, 0
0143   04E8 38 00 00      mov c, 0
0144   04EB             ; --- START RELATIONAL
0145   04EB D7            push a
0146   04EC 11            mov a, b
0147   04ED FD 2E 64 00   mov32 cb, $00000064
0147   04F1 00 00 
0148   04F3 B0            cmp a, b
0149   04F4 FD 71         seq ; ==
0150   04F6 E4            pop a
0151   04F7             ; --- END RELATIONAL
0152   04F7             ; --- START LOGICAL OR
0153   04F7 D7            push a
0154   04F8 11            mov a, b
0155   04F9 FA FD FF      lea d, [bp + -3] ; $format_p
0156   04FC 2A            mov b, [d]
0157   04FD 38 00 00      mov c, 0
0158   0500 74            mov d, b
0159   0501 32            mov bl, [d]
0160   0502 A7 00         mov bh, 0
0161   0504 38 00 00      mov c, 0
0162   0507             ; --- START RELATIONAL
0163   0507 D7            push a
0164   0508 11            mov a, b
0165   0509 FD 2E 69 00   mov32 cb, $00000069
0165   050D 00 00 
0166   050F B0            cmp a, b
0167   0510 FD 71         seq ; ==
0168   0512 E4            pop a
0169   0513             ; --- END RELATIONAL
0170   0513 FD A8         sor a, b ; ||
0171   0515 E4            pop a
0172   0516             ; --- END LOGICAL OR
0173   0516 C0 00 00      cmp b, 0
0174   0519 C6 3A 05      je _if5_else
0175   051C             _if5_TRUE:
0176   051C             ; print_signed_long(*(long *)p); 
0177   051C             ; --- START FUNCTION CALL
0178   051C FA FF FF      lea d, [bp + -1] ; $p
0179   051F 2A            mov b, [d]
0180   0520 38 00 00      mov c, 0
0181   0523 74            mov d, b
0182   0524 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0183   0527 FD 39         mov c, b ; And place it into C
0184   0529 2A            mov b, [d] ; Lower Word in B
0185   052A 12            mov a, c
0186   052B FD AA         swp a
0187   052D D7            push a
0188   052E FD AB         swp b
0189   0530 D8            push b
0190   0531 07 13 07      call print_signed_long
0191   0534 51 04 00      add sp, 4
0192   0537             ; --- END FUNCTION CALL
0193   0537 0A C2 05      jmp _if5_exit
0194   053A             _if5_else:
0195   053A             ; if(*format_p == 'u') 
0196   053A             _if6_cond:
0197   053A FA FD FF      lea d, [bp + -3] ; $format_p
0198   053D 2A            mov b, [d]
0199   053E 38 00 00      mov c, 0
0200   0541 74            mov d, b
0201   0542 32            mov bl, [d]
0202   0543 A7 00         mov bh, 0
0203   0545 38 00 00      mov c, 0
0204   0548             ; --- START RELATIONAL
0205   0548 D7            push a
0206   0549 11            mov a, b
0207   054A FD 2E 75 00   mov32 cb, $00000075
0207   054E 00 00 
0208   0550 B0            cmp a, b
0209   0551 FD 71         seq ; ==
0210   0553 E4            pop a
0211   0554             ; --- END RELATIONAL
0212   0554 C0 00 00      cmp b, 0
0213   0557 C6 78 05      je _if6_else
0214   055A             _if6_TRUE:
0215   055A             ; print_unsigned_long(*(unsigned long *)p); 
0216   055A             ; --- START FUNCTION CALL
0217   055A FA FF FF      lea d, [bp + -1] ; $p
0218   055D 2A            mov b, [d]
0219   055E 38 00 00      mov c, 0
0220   0561 74            mov d, b
0221   0562 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0222   0565 FD 39         mov c, b ; And place it into C
0223   0567 2A            mov b, [d] ; Lower Word in B
0224   0568 12            mov a, c
0225   0569 FD AA         swp a
0226   056B D7            push a
0227   056C FD AB         swp b
0228   056E D8            push b
0229   056F 07 A6 08      call print_unsigned_long
0230   0572 51 04 00      add sp, 4
0231   0575             ; --- END FUNCTION CALL
0232   0575 0A C2 05      jmp _if6_exit
0233   0578             _if6_else:
0234   0578             ; if(*format_p == 'x') 
0235   0578             _if7_cond:
0236   0578 FA FD FF      lea d, [bp + -3] ; $format_p
0237   057B 2A            mov b, [d]
0238   057C 38 00 00      mov c, 0
0239   057F 74            mov d, b
0240   0580 32            mov bl, [d]
0241   0581 A7 00         mov bh, 0
0242   0583 38 00 00      mov c, 0
0243   0586             ; --- START RELATIONAL
0244   0586 D7            push a
0245   0587 11            mov a, b
0246   0588 FD 2E 78 00   mov32 cb, $00000078
0246   058C 00 00 
0247   058E B0            cmp a, b
0248   058F FD 71         seq ; ==
0249   0591 E4            pop a
0250   0592             ; --- END RELATIONAL
0251   0592 C0 00 00      cmp b, 0
0252   0595 C6 B6 05      je _if7_else
0253   0598             _if7_TRUE:
0254   0598             ; printx32(*(long int *)p); 
0255   0598             ; --- START FUNCTION CALL
0256   0598 FA FF FF      lea d, [bp + -1] ; $p
0257   059B 2A            mov b, [d]
0258   059C 38 00 00      mov c, 0
0259   059F 74            mov d, b
0260   05A0 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0261   05A3 FD 39         mov c, b ; And place it into C
0262   05A5 2A            mov b, [d] ; Lower Word in B
0263   05A6 12            mov a, c
0264   05A7 FD AA         swp a
0265   05A9 D7            push a
0266   05AA FD AB         swp b
0267   05AC D8            push b
0268   05AD 07 DA 09      call printx32
0269   05B0 51 04 00      add sp, 4
0270   05B3             ; --- END FUNCTION CALL
0271   05B3 0A C2 05      jmp _if7_exit
0272   05B6             _if7_else:
0273   05B6             ; err("Unexpected format in printf."); 
0274   05B6             ; --- START FUNCTION CALL
0275   05B6 26 60 0D      mov b, _s1 ; "Unexpected format in printf."
0276   05B9 FD AB         swp b
0277   05BB D8            push b
0278   05BC 07 3A 0A      call err
0279   05BF 51 02 00      add sp, 2
0280   05C2             ; --- END FUNCTION CALL
0281   05C2             _if7_exit:
0282   05C2             _if6_exit:
0283   05C2             _if5_exit:
0284   05C2             ; p = p + 4; 
0285   05C2 FA FF FF      lea d, [bp + -1] ; $p
0286   05C5 DA            push d
0287   05C6 FA FF FF      lea d, [bp + -1] ; $p
0288   05C9 2A            mov b, [d]
0289   05CA 38 00 00      mov c, 0
0290   05CD             ; --- START TERMS
0291   05CD D7            push a
0292   05CE 11            mov a, b
0293   05CF FD 2E 04 00   mov32 cb, $00000004
0293   05D3 00 00 
0294   05D5 56            add b, a
0295   05D6 E4            pop a
0296   05D7             ; --- END TERMS
0297   05D7 E7            pop d
0298   05D8 FD 43         mov [d], b
0299   05DA             ; break; 
0300   05DA 0A D6 06      jmp _switch4_exit ; case break
0301   05DD             _switch4_case2:
0302   05DD             _switch4_case3:
0303   05DD             ; print_signed(*(int*)p); 
0304   05DD             ; --- START FUNCTION CALL
0305   05DD FA FF FF      lea d, [bp + -1] ; $p
0306   05E0 2A            mov b, [d]
0307   05E1 38 00 00      mov c, 0
0308   05E4 74            mov d, b
0309   05E5 2A            mov b, [d]
0310   05E6 38 00 00      mov c, 0
0311   05E9 FD AB         swp b
0312   05EB D8            push b
0313   05EC 07 68 0A      call print_signed
0314   05EF 51 02 00      add sp, 2
0315   05F2             ; --- END FUNCTION CALL
0316   05F2             ; p = p + 2; 
0317   05F2 FA FF FF      lea d, [bp + -1] ; $p
0318   05F5 DA            push d
0319   05F6 FA FF FF      lea d, [bp + -1] ; $p
0320   05F9 2A            mov b, [d]
0321   05FA 38 00 00      mov c, 0
0322   05FD             ; --- START TERMS
0323   05FD D7            push a
0324   05FE 11            mov a, b
0325   05FF FD 2E 02 00   mov32 cb, $00000002
0325   0603 00 00 
0326   0605 56            add b, a
0327   0606 E4            pop a
0328   0607             ; --- END TERMS
0329   0607 E7            pop d
0330   0608 FD 43         mov [d], b
0331   060A             ; break; 
0332   060A 0A D6 06      jmp _switch4_exit ; case break
0333   060D             _switch4_case4:
0334   060D             ; print_unsigned(*(unsigned int*)p); 
0335   060D             ; --- START FUNCTION CALL
0336   060D FA FF FF      lea d, [bp + -1] ; $p
0337   0610 2A            mov b, [d]
0338   0611 38 00 00      mov c, 0
0339   0614 74            mov d, b
0340   0615 2A            mov b, [d]
0341   0616 38 00 00      mov c, 0
0342   0619 FD AB         swp b
0343   061B D8            push b
0344   061C 07 B9 0B      call print_unsigned
0345   061F 51 02 00      add sp, 2
0346   0622             ; --- END FUNCTION CALL
0347   0622             ; p = p + 2; 
0348   0622 FA FF FF      lea d, [bp + -1] ; $p
0349   0625 DA            push d
0350   0626 FA FF FF      lea d, [bp + -1] ; $p
0351   0629 2A            mov b, [d]
0352   062A 38 00 00      mov c, 0
0353   062D             ; --- START TERMS
0354   062D D7            push a
0355   062E 11            mov a, b
0356   062F FD 2E 02 00   mov32 cb, $00000002
0356   0633 00 00 
0357   0635 56            add b, a
0358   0636 E4            pop a
0359   0637             ; --- END TERMS
0360   0637 E7            pop d
0361   0638 FD 43         mov [d], b
0362   063A             ; break; 
0363   063A 0A D6 06      jmp _switch4_exit ; case break
0364   063D             _switch4_case5:
0365   063D             ; printx16(*(int*)p); 
0366   063D             ; --- START FUNCTION CALL
0367   063D FA FF FF      lea d, [bp + -1] ; $p
0368   0640 2A            mov b, [d]
0369   0641 38 00 00      mov c, 0
0370   0644 74            mov d, b
0371   0645 2A            mov b, [d]
0372   0646 38 00 00      mov c, 0
0373   0649 FD AB         swp b
0374   064B D8            push b
0375   064C 07 D1 0C      call printx16
0376   064F 51 02 00      add sp, 2
0377   0652             ; --- END FUNCTION CALL
0378   0652             ; p = p + 2; 
0379   0652 FA FF FF      lea d, [bp + -1] ; $p
0380   0655 DA            push d
0381   0656 FA FF FF      lea d, [bp + -1] ; $p
0382   0659 2A            mov b, [d]
0383   065A 38 00 00      mov c, 0
0384   065D             ; --- START TERMS
0385   065D D7            push a
0386   065E 11            mov a, b
0387   065F FD 2E 02 00   mov32 cb, $00000002
0387   0663 00 00 
0388   0665 56            add b, a
0389   0666 E4            pop a
0390   0667             ; --- END TERMS
0391   0667 E7            pop d
0392   0668 FD 43         mov [d], b
0393   066A             ; break; 
0394   066A 0A D6 06      jmp _switch4_exit ; case break
0395   066D             _switch4_case6:
0396   066D             ; putchar(*(char*)p); 
0397   066D             ; --- START FUNCTION CALL
0398   066D FA FF FF      lea d, [bp + -1] ; $p
0399   0670 2A            mov b, [d]
0400   0671 38 00 00      mov c, 0
0401   0674 74            mov d, b
0402   0675 32            mov bl, [d]
0403   0676 A7 00         mov bh, 0
0404   0678 38 00 00      mov c, 0
0405   067B DD            push bl
0406   067C 07 98 08      call putchar
0407   067F 51 01 00      add sp, 1
0408   0682             ; --- END FUNCTION CALL
0409   0682             ; p = p + 2; 
0410   0682 FA FF FF      lea d, [bp + -1] ; $p
0411   0685 DA            push d
0412   0686 FA FF FF      lea d, [bp + -1] ; $p
0413   0689 2A            mov b, [d]
0414   068A 38 00 00      mov c, 0
0415   068D             ; --- START TERMS
0416   068D D7            push a
0417   068E 11            mov a, b
0418   068F FD 2E 02 00   mov32 cb, $00000002
0418   0693 00 00 
0419   0695 56            add b, a
0420   0696 E4            pop a
0421   0697             ; --- END TERMS
0422   0697 E7            pop d
0423   0698 FD 43         mov [d], b
0424   069A             ; break; 
0425   069A 0A D6 06      jmp _switch4_exit ; case break
0426   069D             _switch4_case7:
0427   069D             ; print(*(char**)p); 
0428   069D             ; --- START FUNCTION CALL
0429   069D FA FF FF      lea d, [bp + -1] ; $p
0430   06A0 2A            mov b, [d]
0431   06A1 38 00 00      mov c, 0
0432   06A4 74            mov d, b
0433   06A5 2A            mov b, [d]
0434   06A6 FD AB         swp b
0435   06A8 D8            push b
0436   06A9 07 4F 0A      call print
0437   06AC 51 02 00      add sp, 2
0438   06AF             ; --- END FUNCTION CALL
0439   06AF             ; p = p + 2; 
0440   06AF FA FF FF      lea d, [bp + -1] ; $p
0441   06B2 DA            push d
0442   06B3 FA FF FF      lea d, [bp + -1] ; $p
0443   06B6 2A            mov b, [d]
0444   06B7 38 00 00      mov c, 0
0445   06BA             ; --- START TERMS
0446   06BA D7            push a
0447   06BB 11            mov a, b
0448   06BC FD 2E 02 00   mov32 cb, $00000002
0448   06C0 00 00 
0449   06C2 56            add b, a
0450   06C3 E4            pop a
0451   06C4             ; --- END TERMS
0452   06C4 E7            pop d
0453   06C5 FD 43         mov [d], b
0454   06C7             ; break; 
0455   06C7 0A D6 06      jmp _switch4_exit ; case break
0456   06CA             _switch4_default:
0457   06CA             ; print("Error: Unknown argument type.\n"); 
0458   06CA             ; --- START FUNCTION CALL
0459   06CA 26 7D 0D      mov b, _s2 ; "Error: Unknown argument type.\n"
0460   06CD FD AB         swp b
0461   06CF D8            push b
0462   06D0 07 4F 0A      call print
0463   06D3 51 02 00      add sp, 2
0464   06D6             ; --- END FUNCTION CALL
0465   06D6             _switch4_exit:
0466   06D6             ; format_p++; 
0467   06D6 FA FD FF      lea d, [bp + -3] ; $format_p
0468   06D9 2A            mov b, [d]
0469   06DA 38 00 00      mov c, 0
0470   06DD FD 77         inc b
0471   06DF FA FD FF      lea d, [bp + -3] ; $format_p
0472   06E2 FD 43         mov [d], b
0473   06E4 FD 7D         dec b
0474   06E6 0A 0E 07      jmp _if3_exit
0475   06E9             _if3_else:
0476   06E9             ; putchar(*format_p); 
0477   06E9             ; --- START FUNCTION CALL
0478   06E9 FA FD FF      lea d, [bp + -3] ; $format_p
0479   06EC 2A            mov b, [d]
0480   06ED 38 00 00      mov c, 0
0481   06F0 74            mov d, b
0482   06F1 32            mov bl, [d]
0483   06F2 A7 00         mov bh, 0
0484   06F4 38 00 00      mov c, 0
0485   06F7 DD            push bl
0486   06F8 07 98 08      call putchar
0487   06FB 51 01 00      add sp, 1
0488   06FE             ; --- END FUNCTION CALL
0489   06FE             ; format_p++; 
0490   06FE FA FD FF      lea d, [bp + -3] ; $format_p
0491   0701 2A            mov b, [d]
0492   0702 38 00 00      mov c, 0
0493   0705 FD 77         inc b
0494   0707 FA FD FF      lea d, [bp + -3] ; $format_p
0495   070A FD 43         mov [d], b
0496   070C FD 7D         dec b
0497   070E             _if3_exit:
0498   070E             _if2_exit:
0499   070E             _for1_update:
0500   070E 0A 42 04      jmp _for1_cond
0501   0711             _for1_exit:
0502   0711 F9            leave
0503   0712 09            ret
0504   0713             
0505   0713             print_signed_long:
0506   0713 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0507   0716             ; char digits[10]; 
0508   0716 52 0A 00      sub sp, 10
0509   0719             ; int i = 0; 
0510   0719 52 02 00      sub sp, 2
0511   071C             ; --- START LOCAL VAR INITIALIZATION
0512   071C FA F5 FF      lea d, [bp + -11] ; $i
0513   071F DA            push d
0514   0720 FD 2E 00 00   mov32 cb, $00000000
0514   0724 00 00 
0515   0726 E7            pop d
0516   0727 FD 43         mov [d], b
0517   0729             ; --- END LOCAL VAR INITIALIZATION
0518   0729             ; if (num < 0) { 
0519   0729             _if8_cond:
0520   0729 FA 05 00      lea d, [bp + 5] ; $num
0521   072C 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0522   072F FD 39         mov c, b ; And place it into C
0523   0731 2A            mov b, [d] ; Lower Word in B
0524   0732             ; --- START RELATIONAL
0525   0732 D7            push a
0526   0733 FD D8         push g
0527   0735 11            mov a, b
0528   0736 FD 7A         mov g, c
0529   0738 FD 2E 00 00   mov32 cb, $00000000
0529   073C 00 00 
0530   073E FD AF         cmp32 ga, cb
0531   0740 FD 73         slt ; <
0532   0742 FD F1         pop g
0533   0744 E4            pop a
0534   0745             ; --- END RELATIONAL
0535   0745 C0 00 00      cmp b, 0
0536   0748 C6 7A 07      je _if8_else
0537   074B             _if8_TRUE:
0538   074B             ; putchar('-'); 
0539   074B             ; --- START FUNCTION CALL
0540   074B FD 2E 2D 00   mov32 cb, $0000002d
0540   074F 00 00 
0541   0751 DD            push bl
0542   0752 07 98 08      call putchar
0543   0755 51 01 00      add sp, 1
0544   0758             ; --- END FUNCTION CALL
0545   0758             ; num = -num; 
0546   0758 FA 05 00      lea d, [bp + 5] ; $num
0547   075B DA            push d
0548   075C FA 05 00      lea d, [bp + 5] ; $num
0549   075F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0550   0762 FD 39         mov c, b ; And place it into C
0551   0764 2A            mov b, [d] ; Lower Word in B
0552   0765 12            mov a, c
0553   0766 95            not a
0554   0767 97            not b
0555   0768 55 01 00      add b, 1
0556   076B 5B 00 00      adc a, 0
0557   076E 39            mov c, a
0558   076F E7            pop d
0559   0770 FD 43         mov [d], b
0560   0772 28            mov b, c
0561   0773 FD 44 02 00   mov [d + 2], b
0562   0777 0A AE 07      jmp _if8_exit
0563   077A             _if8_else:
0564   077A             ; if (num == 0) { 
0565   077A             _if9_cond:
0566   077A FA 05 00      lea d, [bp + 5] ; $num
0567   077D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0568   0780 FD 39         mov c, b ; And place it into C
0569   0782 2A            mov b, [d] ; Lower Word in B
0570   0783             ; --- START RELATIONAL
0571   0783 D7            push a
0572   0784 FD D8         push g
0573   0786 11            mov a, b
0574   0787 FD 7A         mov g, c
0575   0789 FD 2E 00 00   mov32 cb, $00000000
0575   078D 00 00 
0576   078F FD AF         cmp32 ga, cb
0577   0791 FD 71         seq ; ==
0578   0793 FD F1         pop g
0579   0795 E4            pop a
0580   0796             ; --- END RELATIONAL
0581   0796 C0 00 00      cmp b, 0
0582   0799 C6 AE 07      je _if9_exit
0583   079C             _if9_TRUE:
0584   079C             ; putchar('0'); 
0585   079C             ; --- START FUNCTION CALL
0586   079C FD 2E 30 00   mov32 cb, $00000030
0586   07A0 00 00 
0587   07A2 DD            push bl
0588   07A3 07 98 08      call putchar
0589   07A6 51 01 00      add sp, 1
0590   07A9             ; --- END FUNCTION CALL
0591   07A9             ; return; 
0592   07A9 F9            leave
0593   07AA 09            ret
0594   07AB 0A AE 07      jmp _if9_exit
0595   07AE             _if9_exit:
0596   07AE             _if8_exit:
0597   07AE             ; while (num > 0) { 
0598   07AE             _while10_cond:
0599   07AE FA 05 00      lea d, [bp + 5] ; $num
0600   07B1 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0601   07B4 FD 39         mov c, b ; And place it into C
0602   07B6 2A            mov b, [d] ; Lower Word in B
0603   07B7             ; --- START RELATIONAL
0604   07B7 D7            push a
0605   07B8 FD D8         push g
0606   07BA 11            mov a, b
0607   07BB FD 7A         mov g, c
0608   07BD FD 2E 00 00   mov32 cb, $00000000
0608   07C1 00 00 
0609   07C3 FD AF         cmp32 ga, cb
0610   07C5 FD 7F         sgt
0611   07C7 FD F1         pop g
0612   07C9 E4            pop a
0613   07CA             ; --- END RELATIONAL
0614   07CA C0 00 00      cmp b, 0
0615   07CD C6 4E 08      je _while10_exit
0616   07D0             _while10_block:
0617   07D0             ; digits[i] = '0' + (num % 10); 
0618   07D0 FA F7 FF      lea d, [bp + -9] ; $digits
0619   07D3 D7            push a
0620   07D4 DA            push d
0621   07D5 FA F5 FF      lea d, [bp + -11] ; $i
0622   07D8 2A            mov b, [d]
0623   07D9 38 00 00      mov c, 0
0624   07DC E7            pop d
0625   07DD 5A            add d, b
0626   07DE E4            pop a
0627   07DF DA            push d
0628   07E0 FD 2E 30 00   mov32 cb, $00000030
0628   07E4 00 00 
0629   07E6             ; --- START TERMS
0630   07E6 D7            push a
0631   07E7 11            mov a, b
0632   07E8 FA 05 00      lea d, [bp + 5] ; $num
0633   07EB 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0634   07EE FD 39         mov c, b ; And place it into C
0635   07F0 2A            mov b, [d] ; Lower Word in B
0636   07F1             ; --- START FACTORS
0637   07F1 D7            push a
0638   07F2 FD D8         push g
0639   07F4 11            mov a, b
0640   07F5 FD 7A         mov g, c
0641   07F7 FD 2E 0A 00   mov32 cb, $0000000a
0641   07FB 00 00 
0642   07FD FD D8         push g ; save 'g' as the div instruction uses it
0643   07FF AE            div a, b ; %, a: quotient, b: remainder
0644   0800 11            mov a, b
0645   0801 FD F1         pop g
0646   0803 FD 38         mov c, g
0647   0805 27            mov b, a
0648   0806 FD F1         pop g
0649   0808 E4            pop a
0650   0809             ; --- END FACTORS
0651   0809 FD 15         add32 cb, ga
0652   080B E4            pop a
0653   080C             ; --- END TERMS
0654   080C E7            pop d
0655   080D FD 3E         mov [d], bl
0656   080F             ; num = num / 10; 
0657   080F FA 05 00      lea d, [bp + 5] ; $num
0658   0812 DA            push d
0659   0813 FA 05 00      lea d, [bp + 5] ; $num
0660   0816 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0661   0819 FD 39         mov c, b ; And place it into C
0662   081B 2A            mov b, [d] ; Lower Word in B
0663   081C             ; --- START FACTORS
0664   081C D7            push a
0665   081D FD D8         push g
0666   081F 11            mov a, b
0667   0820 FD 7A         mov g, c
0668   0822 FD 2E 0A 00   mov32 cb, $0000000a
0668   0826 00 00 
0669   0828 FD D8         push g ; save 'g' as the div instruction uses it
0670   082A AE            div a, b ; /, a: quotient, b: remainder
0671   082B FD F1         pop g
0672   082D FD 38         mov c, g
0673   082F 27            mov b, a
0674   0830 FD F1         pop g
0675   0832 E4            pop a
0676   0833             ; --- END FACTORS
0677   0833 E7            pop d
0678   0834 FD 43         mov [d], b
0679   0836 28            mov b, c
0680   0837 FD 44 02 00   mov [d + 2], b
0681   083B             ; i++; 
0682   083B FA F5 FF      lea d, [bp + -11] ; $i
0683   083E 2A            mov b, [d]
0684   083F 38 00 00      mov c, 0
0685   0842 11            mov a, b
0686   0843 FD 77         inc b
0687   0845 FA F5 FF      lea d, [bp + -11] ; $i
0688   0848 FD 43         mov [d], b
0689   084A 27            mov b, a
0690   084B 0A AE 07      jmp _while10_cond
0691   084E             _while10_exit:
0692   084E             ; while (i > 0) { 
0693   084E             _while17_cond:
0694   084E FA F5 FF      lea d, [bp + -11] ; $i
0695   0851 2A            mov b, [d]
0696   0852 38 00 00      mov c, 0
0697   0855             ; --- START RELATIONAL
0698   0855 D7            push a
0699   0856 11            mov a, b
0700   0857 FD 2E 00 00   mov32 cb, $00000000
0700   085B 00 00 
0701   085D B0            cmp a, b
0702   085E FD 7F         sgt ; >
0703   0860 E4            pop a
0704   0861             ; --- END RELATIONAL
0705   0861 C0 00 00      cmp b, 0
0706   0864 C6 96 08      je _while17_exit
0707   0867             _while17_block:
0708   0867             ; i--; 
0709   0867 FA F5 FF      lea d, [bp + -11] ; $i
0710   086A 2A            mov b, [d]
0711   086B 38 00 00      mov c, 0
0712   086E 11            mov a, b
0713   086F FD 7D         dec b
0714   0871 FA F5 FF      lea d, [bp + -11] ; $i
0715   0874 FD 43         mov [d], b
0716   0876 27            mov b, a
0717   0877             ; putchar(digits[i]); 
0718   0877             ; --- START FUNCTION CALL
0719   0877 FA F7 FF      lea d, [bp + -9] ; $digits
0720   087A D7            push a
0721   087B DA            push d
0722   087C FA F5 FF      lea d, [bp + -11] ; $i
0723   087F 2A            mov b, [d]
0724   0880 38 00 00      mov c, 0
0725   0883 E7            pop d
0726   0884 5A            add d, b
0727   0885 E4            pop a
0728   0886 32            mov bl, [d]
0729   0887 A7 00         mov bh, 0
0730   0889 38 00 00      mov c, 0
0731   088C DD            push bl
0732   088D 07 98 08      call putchar
0733   0890 51 01 00      add sp, 1
0734   0893             ; --- END FUNCTION CALL
0735   0893 0A 4E 08      jmp _while17_cond
0736   0896             _while17_exit:
0737   0896 F9            leave
0738   0897 09            ret
0739   0898             
0740   0898             putchar:
0741   0898 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0742   089B             ; --- BEGIN INLINE ASM SEGMENT
0743   089B FA 05 00      lea d, [bp + 5] ; $c
0744   089E 1E            mov al, [d]
0745   089F 23            mov ah, al
0746   08A0 19 00         mov al, 0
0747   08A2 05 03         syscall sys_io      ; char in AH
0748   08A4             ; --- END INLINE ASM SEGMENT
0749   08A4 F9            leave
0750   08A5 09            ret
0751   08A6             
0752   08A6             print_unsigned_long:
0753   08A6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0754   08A9             ; char digits[10]; 
0755   08A9 52 0A 00      sub sp, 10
0756   08AC             ; int i; 
0757   08AC 52 02 00      sub sp, 2
0758   08AF             ; i = 0; 
0759   08AF FA F5 FF      lea d, [bp + -11] ; $i
0760   08B2 DA            push d
0761   08B3 FD 2E 00 00   mov32 cb, $00000000
0761   08B7 00 00 
0762   08B9 E7            pop d
0763   08BA FD 43         mov [d], b
0764   08BC             ; if(num == 0){ 
0765   08BC             _if18_cond:
0766   08BC FA 05 00      lea d, [bp + 5] ; $num
0767   08BF 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0768   08C2 FD 39         mov c, b ; And place it into C
0769   08C4 2A            mov b, [d] ; Lower Word in B
0770   08C5             ; --- START RELATIONAL
0771   08C5 D7            push a
0772   08C6 FD D8         push g
0773   08C8 11            mov a, b
0774   08C9 FD 7A         mov g, c
0775   08CB FD 2E 00 00   mov32 cb, $00000000
0775   08CF 00 00 
0776   08D1 FD AF         cmp32 ga, cb
0777   08D3 FD 71         seq ; ==
0778   08D5 FD F1         pop g
0779   08D7 E4            pop a
0780   08D8             ; --- END RELATIONAL
0781   08D8 C0 00 00      cmp b, 0
0782   08DB C6 F0 08      je _if18_exit
0783   08DE             _if18_TRUE:
0784   08DE             ; putchar('0'); 
0785   08DE             ; --- START FUNCTION CALL
0786   08DE FD 2E 30 00   mov32 cb, $00000030
0786   08E2 00 00 
0787   08E4 DD            push bl
0788   08E5 07 98 08      call putchar
0789   08E8 51 01 00      add sp, 1
0790   08EB             ; --- END FUNCTION CALL
0791   08EB             ; return; 
0792   08EB F9            leave
0793   08EC 09            ret
0794   08ED 0A F0 08      jmp _if18_exit
0795   08F0             _if18_exit:
0796   08F0             ; while (num > 0) { 
0797   08F0             _while19_cond:
0798   08F0 FA 05 00      lea d, [bp + 5] ; $num
0799   08F3 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0800   08F6 FD 39         mov c, b ; And place it into C
0801   08F8 2A            mov b, [d] ; Lower Word in B
0802   08F9             ; --- START RELATIONAL
0803   08F9 D7            push a
0804   08FA FD D8         push g
0805   08FC 11            mov a, b
0806   08FD FD 7A         mov g, c
0807   08FF FD 2E 00 00   mov32 cb, $00000000
0807   0903 00 00 
0808   0905 FD AF         cmp32 ga, cb
0809   0907 FD 81         sgu
0810   0909 FD F1         pop g
0811   090B E4            pop a
0812   090C             ; --- END RELATIONAL
0813   090C C0 00 00      cmp b, 0
0814   090F C6 90 09      je _while19_exit
0815   0912             _while19_block:
0816   0912             ; digits[i] = '0' + (num % 10); 
0817   0912 FA F7 FF      lea d, [bp + -9] ; $digits
0818   0915 D7            push a
0819   0916 DA            push d
0820   0917 FA F5 FF      lea d, [bp + -11] ; $i
0821   091A 2A            mov b, [d]
0822   091B 38 00 00      mov c, 0
0823   091E E7            pop d
0824   091F 5A            add d, b
0825   0920 E4            pop a
0826   0921 DA            push d
0827   0922 FD 2E 30 00   mov32 cb, $00000030
0827   0926 00 00 
0828   0928             ; --- START TERMS
0829   0928 D7            push a
0830   0929 11            mov a, b
0831   092A FA 05 00      lea d, [bp + 5] ; $num
0832   092D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0833   0930 FD 39         mov c, b ; And place it into C
0834   0932 2A            mov b, [d] ; Lower Word in B
0835   0933             ; --- START FACTORS
0836   0933 D7            push a
0837   0934 FD D8         push g
0838   0936 11            mov a, b
0839   0937 FD 7A         mov g, c
0840   0939 FD 2E 0A 00   mov32 cb, $0000000a
0840   093D 00 00 
0841   093F FD D8         push g ; save 'g' as the div instruction uses it
0842   0941 AE            div a, b ; %, a: quotient, b: remainder
0843   0942 11            mov a, b
0844   0943 FD F1         pop g
0845   0945 FD 38         mov c, g
0846   0947 27            mov b, a
0847   0948 FD F1         pop g
0848   094A E4            pop a
0849   094B             ; --- END FACTORS
0850   094B FD 15         add32 cb, ga
0851   094D E4            pop a
0852   094E             ; --- END TERMS
0853   094E E7            pop d
0854   094F FD 3E         mov [d], bl
0855   0951             ; num = num / 10; 
0856   0951 FA 05 00      lea d, [bp + 5] ; $num
0857   0954 DA            push d
0858   0955 FA 05 00      lea d, [bp + 5] ; $num
0859   0958 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0860   095B FD 39         mov c, b ; And place it into C
0861   095D 2A            mov b, [d] ; Lower Word in B
0862   095E             ; --- START FACTORS
0863   095E D7            push a
0864   095F FD D8         push g
0865   0961 11            mov a, b
0866   0962 FD 7A         mov g, c
0867   0964 FD 2E 0A 00   mov32 cb, $0000000a
0867   0968 00 00 
0868   096A FD D8         push g ; save 'g' as the div instruction uses it
0869   096C AE            div a, b ; /, a: quotient, b: remainder
0870   096D FD F1         pop g
0871   096F FD 38         mov c, g
0872   0971 27            mov b, a
0873   0972 FD F1         pop g
0874   0974 E4            pop a
0875   0975             ; --- END FACTORS
0876   0975 E7            pop d
0877   0976 FD 43         mov [d], b
0878   0978 28            mov b, c
0879   0979 FD 44 02 00   mov [d + 2], b
0880   097D             ; i++; 
0881   097D FA F5 FF      lea d, [bp + -11] ; $i
0882   0980 2A            mov b, [d]
0883   0981 38 00 00      mov c, 0
0884   0984 11            mov a, b
0885   0985 FD 77         inc b
0886   0987 FA F5 FF      lea d, [bp + -11] ; $i
0887   098A FD 43         mov [d], b
0888   098C 27            mov b, a
0889   098D 0A F0 08      jmp _while19_cond
0890   0990             _while19_exit:
0891   0990             ; while (i > 0) { 
0892   0990             _while26_cond:
0893   0990 FA F5 FF      lea d, [bp + -11] ; $i
0894   0993 2A            mov b, [d]
0895   0994 38 00 00      mov c, 0
0896   0997             ; --- START RELATIONAL
0897   0997 D7            push a
0898   0998 11            mov a, b
0899   0999 FD 2E 00 00   mov32 cb, $00000000
0899   099D 00 00 
0900   099F B0            cmp a, b
0901   09A0 FD 7F         sgt ; >
0902   09A2 E4            pop a
0903   09A3             ; --- END RELATIONAL
0904   09A3 C0 00 00      cmp b, 0
0905   09A6 C6 D8 09      je _while26_exit
0906   09A9             _while26_block:
0907   09A9             ; i--; 
0908   09A9 FA F5 FF      lea d, [bp + -11] ; $i
0909   09AC 2A            mov b, [d]
0910   09AD 38 00 00      mov c, 0
0911   09B0 11            mov a, b
0912   09B1 FD 7D         dec b
0913   09B3 FA F5 FF      lea d, [bp + -11] ; $i
0914   09B6 FD 43         mov [d], b
0915   09B8 27            mov b, a
0916   09B9             ; putchar(digits[i]); 
0917   09B9             ; --- START FUNCTION CALL
0918   09B9 FA F7 FF      lea d, [bp + -9] ; $digits
0919   09BC D7            push a
0920   09BD DA            push d
0921   09BE FA F5 FF      lea d, [bp + -11] ; $i
0922   09C1 2A            mov b, [d]
0923   09C2 38 00 00      mov c, 0
0924   09C5 E7            pop d
0925   09C6 5A            add d, b
0926   09C7 E4            pop a
0927   09C8 32            mov bl, [d]
0928   09C9 A7 00         mov bh, 0
0929   09CB 38 00 00      mov c, 0
0930   09CE DD            push bl
0931   09CF 07 98 08      call putchar
0932   09D2 51 01 00      add sp, 1
0933   09D5             ; --- END FUNCTION CALL
0934   09D5 0A 90 09      jmp _while26_cond
0935   09D8             _while26_exit:
0936   09D8 F9            leave
0937   09D9 09            ret
0938   09DA             
0939   09DA             printx32:
0940   09DA F8 00 00      enter 0 ; (push bp; mov bp, sp)
0941   09DD             ; --- BEGIN INLINE ASM SEGMENT
0942   09DD FA 05 00      lea d, [bp + 5] ; $hex
0943   09E0 2B 02 00      mov b, [d+2]
0944   09E3 07 EC 09      call print_u16x_printx32
0945   09E6 2A            mov b, [d]
0946   09E7 07 EC 09      call print_u16x_printx32
0947   09EA             ; --- END INLINE ASM SEGMENT
0948   09EA             ; return; 
0949   09EA F9            leave
0950   09EB 09            ret
0951   09EC             ; --- BEGIN INLINE ASM SEGMENT
0952   09EC             print_u16x_printx32:
0953   09EC D7            push a
0954   09ED D8            push b
0955   09EE DD            push bl
0956   09EF 30            mov bl, bh
0957   09F0 07 0E 0A      call _itoa_printx32        ; convert bh to char in A
0958   09F3 2F            mov bl, al        ; save al
0959   09F4 19 00         mov al, 0
0960   09F6 05 03         syscall sys_io        ; display AH
0961   09F8 24            mov ah, bl        ; retrieve al
0962   09F9 19 00         mov al, 0
0963   09FB 05 03         syscall sys_io        ; display AL
0964   09FD EA            pop bl
0965   09FE 07 0E 0A      call _itoa_printx32        ; convert bh to char in A
0966   0A01 2F            mov bl, al        ; save al
0967   0A02 19 00         mov al, 0
0968   0A04 05 03         syscall sys_io        ; display AH
0969   0A06 24            mov ah, bl        ; retrieve al
0970   0A07 19 00         mov al, 0
0971   0A09 05 03         syscall sys_io        ; display AL
0972   0A0B E5            pop b
0973   0A0C E4            pop a
0974   0A0D 09            ret
0975   0A0E             _itoa_printx32:
0976   0A0E DA            push d
0977   0A0F D8            push b
0978   0A10 A7 00         mov bh, 0
0979   0A12 FD A4 04      shr bl, 4  
0980   0A15 74            mov d, b
0981   0A16 1F 28 0A      mov al, [d + s_hex_digits_printx32]
0982   0A19 23            mov ah, al
0983   0A1A E5            pop b
0984   0A1B D8            push b
0985   0A1C A7 00         mov bh, 0
0986   0A1E FD 87 0F      and bl, $0F
0987   0A21 74            mov d, b
0988   0A22 1F 28 0A      mov al, [d + s_hex_digits_printx32]
0989   0A25 E5            pop b
0990   0A26 E7            pop d
0991   0A27 09            ret
0992   0A28 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
0992   0A2C 34 35 36 37 
0992   0A30 38 39 41 42 
0992   0A34 43 44 45 46 
0993   0A38             ; --- END INLINE ASM SEGMENT
0994   0A38 F9            leave
0995   0A39 09            ret
0996   0A3A             
0997   0A3A             err:
0998   0A3A F8 00 00      enter 0 ; (push bp; mov bp, sp)
0999   0A3D             ; print(e); 
1000   0A3D             ; --- START FUNCTION CALL
1001   0A3D FA 05 00      lea d, [bp + 5] ; $e
1002   0A40 2A            mov b, [d]
1003   0A41 38 00 00      mov c, 0
1004   0A44 FD AB         swp b
1005   0A46 D8            push b
1006   0A47 07 4F 0A      call print
1007   0A4A 51 02 00      add sp, 2
1008   0A4D             ; --- END FUNCTION CALL
1009   0A4D F9            leave
1010   0A4E 09            ret
1011   0A4F             
1012   0A4F             print:
1013   0A4F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1014   0A52             ; --- BEGIN INLINE ASM SEGMENT
1015   0A52 FA 05 00      lea d, [bp + 5] ; $s
1016   0A55 FD 2A         mov d, [d]
1017   0A57             _puts_L1_print:
1018   0A57 1E            mov al, [d]
1019   0A58 B9 00         cmp al, 0
1020   0A5A C6 66 0A      jz _puts_END_print
1021   0A5D 23            mov ah, al
1022   0A5E 19 00         mov al, 0
1023   0A60 05 03         syscall sys_io
1024   0A62 79            inc d
1025   0A63 0A 57 0A      jmp _puts_L1_print
1026   0A66             _puts_END_print:
1027   0A66             ; --- END INLINE ASM SEGMENT
1028   0A66 F9            leave
1029   0A67 09            ret
1030   0A68             
1031   0A68             print_signed:
1032   0A68 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1033   0A6B             ; char digits[5]; 
1034   0A6B 52 05 00      sub sp, 5
1035   0A6E             ; int i = 0; 
1036   0A6E 52 02 00      sub sp, 2
1037   0A71             ; --- START LOCAL VAR INITIALIZATION
1038   0A71 FA FA FF      lea d, [bp + -6] ; $i
1039   0A74 DA            push d
1040   0A75 FD 2E 00 00   mov32 cb, $00000000
1040   0A79 00 00 
1041   0A7B E7            pop d
1042   0A7C FD 43         mov [d], b
1043   0A7E             ; --- END LOCAL VAR INITIALIZATION
1044   0A7E             ; if (num < 0) { 
1045   0A7E             _if27_cond:
1046   0A7E FA 05 00      lea d, [bp + 5] ; $num
1047   0A81 2A            mov b, [d]
1048   0A82 38 00 00      mov c, 0
1049   0A85             ; --- START RELATIONAL
1050   0A85 D7            push a
1051   0A86 11            mov a, b
1052   0A87 FD 2E 00 00   mov32 cb, $00000000
1052   0A8B 00 00 
1053   0A8D B0            cmp a, b
1054   0A8E FD 73         slt ; < (signed)
1055   0A90 E4            pop a
1056   0A91             ; --- END RELATIONAL
1057   0A91 C0 00 00      cmp b, 0
1058   0A94 C6 B7 0A      je _if27_else
1059   0A97             _if27_TRUE:
1060   0A97             ; putchar('-'); 
1061   0A97             ; --- START FUNCTION CALL
1062   0A97 FD 2E 2D 00   mov32 cb, $0000002d
1062   0A9B 00 00 
1063   0A9D DD            push bl
1064   0A9E 07 98 08      call putchar
1065   0AA1 51 01 00      add sp, 1
1066   0AA4             ; --- END FUNCTION CALL
1067   0AA4             ; num = -num; 
1068   0AA4 FA 05 00      lea d, [bp + 5] ; $num
1069   0AA7 DA            push d
1070   0AA8 FA 05 00      lea d, [bp + 5] ; $num
1071   0AAB 2A            mov b, [d]
1072   0AAC 38 00 00      mov c, 0
1073   0AAF FD 97         neg b
1074   0AB1 E7            pop d
1075   0AB2 FD 43         mov [d], b
1076   0AB4 0A E2 0A      jmp _if27_exit
1077   0AB7             _if27_else:
1078   0AB7             ; if (num == 0) { 
1079   0AB7             _if28_cond:
1080   0AB7 FA 05 00      lea d, [bp + 5] ; $num
1081   0ABA 2A            mov b, [d]
1082   0ABB 38 00 00      mov c, 0
1083   0ABE             ; --- START RELATIONAL
1084   0ABE D7            push a
1085   0ABF 11            mov a, b
1086   0AC0 FD 2E 00 00   mov32 cb, $00000000
1086   0AC4 00 00 
1087   0AC6 B0            cmp a, b
1088   0AC7 FD 71         seq ; ==
1089   0AC9 E4            pop a
1090   0ACA             ; --- END RELATIONAL
1091   0ACA C0 00 00      cmp b, 0
1092   0ACD C6 E2 0A      je _if28_exit
1093   0AD0             _if28_TRUE:
1094   0AD0             ; putchar('0'); 
1095   0AD0             ; --- START FUNCTION CALL
1096   0AD0 FD 2E 30 00   mov32 cb, $00000030
1096   0AD4 00 00 
1097   0AD6 DD            push bl
1098   0AD7 07 98 08      call putchar
1099   0ADA 51 01 00      add sp, 1
1100   0ADD             ; --- END FUNCTION CALL
1101   0ADD             ; return; 
1102   0ADD F9            leave
1103   0ADE 09            ret
1104   0ADF 0A E2 0A      jmp _if28_exit
1105   0AE2             _if28_exit:
1106   0AE2             _if27_exit:
1107   0AE2             ; while (num > 0) { 
1108   0AE2             _while29_cond:
1109   0AE2 FA 05 00      lea d, [bp + 5] ; $num
1110   0AE5 2A            mov b, [d]
1111   0AE6 38 00 00      mov c, 0
1112   0AE9             ; --- START RELATIONAL
1113   0AE9 D7            push a
1114   0AEA 11            mov a, b
1115   0AEB FD 2E 00 00   mov32 cb, $00000000
1115   0AEF 00 00 
1116   0AF1 B0            cmp a, b
1117   0AF2 FD 7F         sgt ; >
1118   0AF4 E4            pop a
1119   0AF5             ; --- END RELATIONAL
1120   0AF5 C0 00 00      cmp b, 0
1121   0AF8 C6 6F 0B      je _while29_exit
1122   0AFB             _while29_block:
1123   0AFB             ; digits[i] = '0' + (num % 10); 
1124   0AFB FA FC FF      lea d, [bp + -4] ; $digits
1125   0AFE D7            push a
1126   0AFF DA            push d
1127   0B00 FA FA FF      lea d, [bp + -6] ; $i
1128   0B03 2A            mov b, [d]
1129   0B04 38 00 00      mov c, 0
1130   0B07 E7            pop d
1131   0B08 5A            add d, b
1132   0B09 E4            pop a
1133   0B0A DA            push d
1134   0B0B FD 2E 30 00   mov32 cb, $00000030
1134   0B0F 00 00 
1135   0B11             ; --- START TERMS
1136   0B11 D7            push a
1137   0B12 11            mov a, b
1138   0B13 FA 05 00      lea d, [bp + 5] ; $num
1139   0B16 2A            mov b, [d]
1140   0B17 38 00 00      mov c, 0
1141   0B1A             ; --- START FACTORS
1142   0B1A D7            push a
1143   0B1B FD D8         push g
1144   0B1D 11            mov a, b
1145   0B1E FD 7A         mov g, c
1146   0B20 FD 2E 0A 00   mov32 cb, $0000000a
1146   0B24 00 00 
1147   0B26 FD D8         push g ; save 'g' as the div instruction uses it
1148   0B28 AE            div a, b ; %, a: quotient, b: remainder
1149   0B29 11            mov a, b
1150   0B2A FD F1         pop g
1151   0B2C FD 38         mov c, g
1152   0B2E 27            mov b, a
1153   0B2F FD F1         pop g
1154   0B31 E4            pop a
1155   0B32             ; --- END FACTORS
1156   0B32 56            add b, a
1157   0B33 E4            pop a
1158   0B34             ; --- END TERMS
1159   0B34 E7            pop d
1160   0B35 FD 3E         mov [d], bl
1161   0B37             ; num = num / 10; 
1162   0B37 FA 05 00      lea d, [bp + 5] ; $num
1163   0B3A DA            push d
1164   0B3B FA 05 00      lea d, [bp + 5] ; $num
1165   0B3E 2A            mov b, [d]
1166   0B3F 38 00 00      mov c, 0
1167   0B42             ; --- START FACTORS
1168   0B42 D7            push a
1169   0B43 FD D8         push g
1170   0B45 11            mov a, b
1171   0B46 FD 7A         mov g, c
1172   0B48 FD 2E 0A 00   mov32 cb, $0000000a
1172   0B4C 00 00 
1173   0B4E FD D8         push g ; save 'g' as the div instruction uses it
1174   0B50 AE            div a, b ; /, a: quotient, b: remainder
1175   0B51 FD F1         pop g
1176   0B53 FD 38         mov c, g
1177   0B55 27            mov b, a
1178   0B56 FD F1         pop g
1179   0B58 E4            pop a
1180   0B59             ; --- END FACTORS
1181   0B59 E7            pop d
1182   0B5A FD 43         mov [d], b
1183   0B5C             ; i++; 
1184   0B5C FA FA FF      lea d, [bp + -6] ; $i
1185   0B5F 2A            mov b, [d]
1186   0B60 38 00 00      mov c, 0
1187   0B63 11            mov a, b
1188   0B64 FD 77         inc b
1189   0B66 FA FA FF      lea d, [bp + -6] ; $i
1190   0B69 FD 43         mov [d], b
1191   0B6B 27            mov b, a
1192   0B6C 0A E2 0A      jmp _while29_cond
1193   0B6F             _while29_exit:
1194   0B6F             ; while (i > 0) { 
1195   0B6F             _while36_cond:
1196   0B6F FA FA FF      lea d, [bp + -6] ; $i
1197   0B72 2A            mov b, [d]
1198   0B73 38 00 00      mov c, 0
1199   0B76             ; --- START RELATIONAL
1200   0B76 D7            push a
1201   0B77 11            mov a, b
1202   0B78 FD 2E 00 00   mov32 cb, $00000000
1202   0B7C 00 00 
1203   0B7E B0            cmp a, b
1204   0B7F FD 7F         sgt ; >
1205   0B81 E4            pop a
1206   0B82             ; --- END RELATIONAL
1207   0B82 C0 00 00      cmp b, 0
1208   0B85 C6 B7 0B      je _while36_exit
1209   0B88             _while36_block:
1210   0B88             ; i--; 
1211   0B88 FA FA FF      lea d, [bp + -6] ; $i
1212   0B8B 2A            mov b, [d]
1213   0B8C 38 00 00      mov c, 0
1214   0B8F 11            mov a, b
1215   0B90 FD 7D         dec b
1216   0B92 FA FA FF      lea d, [bp + -6] ; $i
1217   0B95 FD 43         mov [d], b
1218   0B97 27            mov b, a
1219   0B98             ; putchar(digits[i]); 
1220   0B98             ; --- START FUNCTION CALL
1221   0B98 FA FC FF      lea d, [bp + -4] ; $digits
1222   0B9B D7            push a
1223   0B9C DA            push d
1224   0B9D FA FA FF      lea d, [bp + -6] ; $i
1225   0BA0 2A            mov b, [d]
1226   0BA1 38 00 00      mov c, 0
1227   0BA4 E7            pop d
1228   0BA5 5A            add d, b
1229   0BA6 E4            pop a
1230   0BA7 32            mov bl, [d]
1231   0BA8 A7 00         mov bh, 0
1232   0BAA 38 00 00      mov c, 0
1233   0BAD DD            push bl
1234   0BAE 07 98 08      call putchar
1235   0BB1 51 01 00      add sp, 1
1236   0BB4             ; --- END FUNCTION CALL
1237   0BB4 0A 6F 0B      jmp _while36_cond
1238   0BB7             _while36_exit:
1239   0BB7 F9            leave
1240   0BB8 09            ret
1241   0BB9             
1242   0BB9             print_unsigned:
1243   0BB9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1244   0BBC             ; char digits[5]; 
1245   0BBC 52 05 00      sub sp, 5
1246   0BBF             ; int i; 
1247   0BBF 52 02 00      sub sp, 2
1248   0BC2             ; i = 0; 
1249   0BC2 FA FA FF      lea d, [bp + -6] ; $i
1250   0BC5 DA            push d
1251   0BC6 FD 2E 00 00   mov32 cb, $00000000
1251   0BCA 00 00 
1252   0BCC E7            pop d
1253   0BCD FD 43         mov [d], b
1254   0BCF             ; if(num == 0){ 
1255   0BCF             _if37_cond:
1256   0BCF FA 05 00      lea d, [bp + 5] ; $num
1257   0BD2 2A            mov b, [d]
1258   0BD3 38 00 00      mov c, 0
1259   0BD6             ; --- START RELATIONAL
1260   0BD6 D7            push a
1261   0BD7 11            mov a, b
1262   0BD8 FD 2E 00 00   mov32 cb, $00000000
1262   0BDC 00 00 
1263   0BDE B0            cmp a, b
1264   0BDF FD 71         seq ; ==
1265   0BE1 E4            pop a
1266   0BE2             ; --- END RELATIONAL
1267   0BE2 C0 00 00      cmp b, 0
1268   0BE5 C6 FA 0B      je _if37_exit
1269   0BE8             _if37_TRUE:
1270   0BE8             ; putchar('0'); 
1271   0BE8             ; --- START FUNCTION CALL
1272   0BE8 FD 2E 30 00   mov32 cb, $00000030
1272   0BEC 00 00 
1273   0BEE DD            push bl
1274   0BEF 07 98 08      call putchar
1275   0BF2 51 01 00      add sp, 1
1276   0BF5             ; --- END FUNCTION CALL
1277   0BF5             ; return; 
1278   0BF5 F9            leave
1279   0BF6 09            ret
1280   0BF7 0A FA 0B      jmp _if37_exit
1281   0BFA             _if37_exit:
1282   0BFA             ; while (num > 0) { 
1283   0BFA             _while38_cond:
1284   0BFA FA 05 00      lea d, [bp + 5] ; $num
1285   0BFD 2A            mov b, [d]
1286   0BFE 38 00 00      mov c, 0
1287   0C01             ; --- START RELATIONAL
1288   0C01 D7            push a
1289   0C02 11            mov a, b
1290   0C03 FD 2E 00 00   mov32 cb, $00000000
1290   0C07 00 00 
1291   0C09 B0            cmp a, b
1292   0C0A FD 81         sgu ; > (unsigned)
1293   0C0C E4            pop a
1294   0C0D             ; --- END RELATIONAL
1295   0C0D C0 00 00      cmp b, 0
1296   0C10 C6 87 0C      je _while38_exit
1297   0C13             _while38_block:
1298   0C13             ; digits[i] = '0' + (num % 10); 
1299   0C13 FA FC FF      lea d, [bp + -4] ; $digits
1300   0C16 D7            push a
1301   0C17 DA            push d
1302   0C18 FA FA FF      lea d, [bp + -6] ; $i
1303   0C1B 2A            mov b, [d]
1304   0C1C 38 00 00      mov c, 0
1305   0C1F E7            pop d
1306   0C20 5A            add d, b
1307   0C21 E4            pop a
1308   0C22 DA            push d
1309   0C23 FD 2E 30 00   mov32 cb, $00000030
1309   0C27 00 00 
1310   0C29             ; --- START TERMS
1311   0C29 D7            push a
1312   0C2A 11            mov a, b
1313   0C2B FA 05 00      lea d, [bp + 5] ; $num
1314   0C2E 2A            mov b, [d]
1315   0C2F 38 00 00      mov c, 0
1316   0C32             ; --- START FACTORS
1317   0C32 D7            push a
1318   0C33 FD D8         push g
1319   0C35 11            mov a, b
1320   0C36 FD 7A         mov g, c
1321   0C38 FD 2E 0A 00   mov32 cb, $0000000a
1321   0C3C 00 00 
1322   0C3E FD D8         push g ; save 'g' as the div instruction uses it
1323   0C40 AE            div a, b ; %, a: quotient, b: remainder
1324   0C41 11            mov a, b
1325   0C42 FD F1         pop g
1326   0C44 FD 38         mov c, g
1327   0C46 27            mov b, a
1328   0C47 FD F1         pop g
1329   0C49 E4            pop a
1330   0C4A             ; --- END FACTORS
1331   0C4A 56            add b, a
1332   0C4B E4            pop a
1333   0C4C             ; --- END TERMS
1334   0C4C E7            pop d
1335   0C4D FD 3E         mov [d], bl
1336   0C4F             ; num = num / 10; 
1337   0C4F FA 05 00      lea d, [bp + 5] ; $num
1338   0C52 DA            push d
1339   0C53 FA 05 00      lea d, [bp + 5] ; $num
1340   0C56 2A            mov b, [d]
1341   0C57 38 00 00      mov c, 0
1342   0C5A             ; --- START FACTORS
1343   0C5A D7            push a
1344   0C5B FD D8         push g
1345   0C5D 11            mov a, b
1346   0C5E FD 7A         mov g, c
1347   0C60 FD 2E 0A 00   mov32 cb, $0000000a
1347   0C64 00 00 
1348   0C66 FD D8         push g ; save 'g' as the div instruction uses it
1349   0C68 AE            div a, b ; /, a: quotient, b: remainder
1350   0C69 FD F1         pop g
1351   0C6B FD 38         mov c, g
1352   0C6D 27            mov b, a
1353   0C6E FD F1         pop g
1354   0C70 E4            pop a
1355   0C71             ; --- END FACTORS
1356   0C71 E7            pop d
1357   0C72 FD 43         mov [d], b
1358   0C74             ; i++; 
1359   0C74 FA FA FF      lea d, [bp + -6] ; $i
1360   0C77 2A            mov b, [d]
1361   0C78 38 00 00      mov c, 0
1362   0C7B 11            mov a, b
1363   0C7C FD 77         inc b
1364   0C7E FA FA FF      lea d, [bp + -6] ; $i
1365   0C81 FD 43         mov [d], b
1366   0C83 27            mov b, a
1367   0C84 0A FA 0B      jmp _while38_cond
1368   0C87             _while38_exit:
1369   0C87             ; while (i > 0) { 
1370   0C87             _while45_cond:
1371   0C87 FA FA FF      lea d, [bp + -6] ; $i
1372   0C8A 2A            mov b, [d]
1373   0C8B 38 00 00      mov c, 0
1374   0C8E             ; --- START RELATIONAL
1375   0C8E D7            push a
1376   0C8F 11            mov a, b
1377   0C90 FD 2E 00 00   mov32 cb, $00000000
1377   0C94 00 00 
1378   0C96 B0            cmp a, b
1379   0C97 FD 7F         sgt ; >
1380   0C99 E4            pop a
1381   0C9A             ; --- END RELATIONAL
1382   0C9A C0 00 00      cmp b, 0
1383   0C9D C6 CF 0C      je _while45_exit
1384   0CA0             _while45_block:
1385   0CA0             ; i--; 
1386   0CA0 FA FA FF      lea d, [bp + -6] ; $i
1387   0CA3 2A            mov b, [d]
1388   0CA4 38 00 00      mov c, 0
1389   0CA7 11            mov a, b
1390   0CA8 FD 7D         dec b
1391   0CAA FA FA FF      lea d, [bp + -6] ; $i
1392   0CAD FD 43         mov [d], b
1393   0CAF 27            mov b, a
1394   0CB0             ; putchar(digits[i]); 
1395   0CB0             ; --- START FUNCTION CALL
1396   0CB0 FA FC FF      lea d, [bp + -4] ; $digits
1397   0CB3 D7            push a
1398   0CB4 DA            push d
1399   0CB5 FA FA FF      lea d, [bp + -6] ; $i
1400   0CB8 2A            mov b, [d]
1401   0CB9 38 00 00      mov c, 0
1402   0CBC E7            pop d
1403   0CBD 5A            add d, b
1404   0CBE E4            pop a
1405   0CBF 32            mov bl, [d]
1406   0CC0 A7 00         mov bh, 0
1407   0CC2 38 00 00      mov c, 0
1408   0CC5 DD            push bl
1409   0CC6 07 98 08      call putchar
1410   0CC9 51 01 00      add sp, 1
1411   0CCC             ; --- END FUNCTION CALL
1412   0CCC 0A 87 0C      jmp _while45_cond
1413   0CCF             _while45_exit:
1414   0CCF F9            leave
1415   0CD0 09            ret
1416   0CD1             
1417   0CD1             printx16:
1418   0CD1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1419   0CD4             ; --- BEGIN INLINE ASM SEGMENT
1420   0CD4 FA 05 00      lea d, [bp + 5] ; $hex
1421   0CD7 2A            mov b, [d]
1422   0CD8             print_u16x_printx16:
1423   0CD8 DD            push bl
1424   0CD9 30            mov bl, bh
1425   0CDA 07 F7 0C      call _itoa_printx16        ; convert bh to char in A
1426   0CDD 2F            mov bl, al        ; save al
1427   0CDE 19 00         mov al, 0
1428   0CE0 05 03         syscall sys_io        ; display AH
1429   0CE2 24            mov ah, bl        ; retrieve al
1430   0CE3 19 00         mov al, 0
1431   0CE5 05 03         syscall sys_io        ; display AL
1432   0CE7 EA            pop bl
1433   0CE8 07 F7 0C      call _itoa_printx16        ; convert bh to char in A
1434   0CEB 2F            mov bl, al        ; save al
1435   0CEC 19 00         mov al, 0
1436   0CEE 05 03         syscall sys_io        ; display AH
1437   0CF0 24            mov ah, bl        ; retrieve al
1438   0CF1 19 00         mov al, 0
1439   0CF3 05 03         syscall sys_io        ; display AL
1440   0CF5             ; --- END INLINE ASM SEGMENT
1441   0CF5             ; return; 
1442   0CF5 F9            leave
1443   0CF6 09            ret
1444   0CF7             ; --- BEGIN INLINE ASM SEGMENT
1445   0CF7             _itoa_printx16:
1446   0CF7 DA            push d
1447   0CF8 D8            push b
1448   0CF9 A7 00         mov bh, 0
1449   0CFB FD A4 04      shr bl, 4  
1450   0CFE 74            mov d, b
1451   0CFF 1F 11 0D      mov al, [d + s_hex_digits_printx16]
1452   0D02 23            mov ah, al
1453   0D03 E5            pop b
1454   0D04 D8            push b
1455   0D05 A7 00         mov bh, 0
1456   0D07 FD 87 0F      and bl, $0F
1457   0D0A 74            mov d, b
1458   0D0B 1F 11 0D      mov al, [d + s_hex_digits_printx16]
1459   0D0E E5            pop b
1460   0D0F E7            pop d
1461   0D10 09            ret
1462   0D11 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
1462   0D15 34 35 36 37 
1462   0D19 38 39 41 42 
1462   0D1D 43 44 45 46 
1463   0D21             ; --- END INLINE ASM SEGMENT
1464   0D21 F9            leave
1465   0D22 09            ret
1466   0D23             ; --- END TEXT SEGMENT
1467   0D23             
1468   0D23             ; --- BEGIN DATA SEGMENT
1469   0D23 02 00       _a: .dw $0002
1470   0D25 48 65 6C 6C _s0: .db "Hello WorldMy name is Sol-1And this is a multi-line string", 0
1470   0D29 6F 20 57 6F 
1470   0D2D 72 6C 64 4D 
1470   0D31 79 20 6E 61 
1470   0D35 6D 65 20 69 
1470   0D39 73 20 53 6F 
1470   0D3D 6C 2D 31 41 
1470   0D41 6E 64 20 74 
1470   0D45 68 69 73 20 
1470   0D49 69 73 20 61 
1470   0D4D 20 6D 75 6C 
1470   0D51 74 69 2D 6C 
1470   0D55 69 6E 65 20 
1470   0D59 73 74 72 69 
1470   0D5D 6E 67 00 
1471   0D60 55 6E 65 78 _s1: .db "Unexpected format in printf.", 0
1471   0D64 70 65 63 74 
1471   0D68 65 64 20 66 
1471   0D6C 6F 72 6D 61 
1471   0D70 74 20 69 6E 
1471   0D74 20 70 72 69 
1471   0D78 6E 74 66 2E 
1471   0D7C 00 
1472   0D7D 45 72 72 6F _s2: .db "Error: Unknown argument type.\n", 0
1472   0D81 72 3A 20 55 
1472   0D85 6E 6B 6E 6F 
1472   0D89 77 6E 20 61 
1472   0D8D 72 67 75 6D 
1472   0D91 65 6E 74 20 
1472   0D95 74 79 70 65 
1472   0D99 2E 0A 00 
1473   0D9C             
1474   0D9C 9E 0D       _heap_top: .dw _heap
1475   0D9E 00          _heap: .db 0
1476   0D9F             ; --- END DATA SEGMENT
1477   0D9F             
1478   0D9F             .end
tasm: Number of errors = 0
