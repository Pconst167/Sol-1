0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT SEGMENT
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; 1L || 'A'; 
0011   0408 FD 2E 01 00   mov32 cb, $00000001
0011   040C 00 00 
0012   040E             ; --- START LOGICAL OR
0013   040E D7            push a
0014   040F FD D8         push g
0015   0411 11            mov a, b
0016   0412 FD 7A         mov g, c
0017   0414 FD 2E 41 00   mov32 cb, $00000041
0017   0418 00 00 
0018   041A FD B2         sor32 ga, cb
0019   041C FD F1         pop g
0020   041E E4            pop a
0021   041F             ; --- END LOGICAL OR
0022   041F 05 0B         syscall sys_terminate_proc
0023   0421             
0024   0421             strcpy:
0025   0421 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0026   0424             ; char *psrc; 
0027   0424 52 02 00      sub sp, 2
0028   0427             ; char *pdest; 
0029   0427 52 02 00      sub sp, 2
0030   042A             ; psrc = src; 
0031   042A FA FF FF      lea d, [bp + -1] ; $psrc
0032   042D DA            push d
0033   042E FA 07 00      lea d, [bp + 7] ; $src
0034   0431 2A            mov b, [d]
0035   0432 38 00 00      mov c, 0
0036   0435 E7            pop d
0037   0436 FD 43         mov [d], b
0038   0438             ; pdest = dest; 
0039   0438 FA FD FF      lea d, [bp + -3] ; $pdest
0040   043B DA            push d
0041   043C FA 05 00      lea d, [bp + 5] ; $dest
0042   043F 2A            mov b, [d]
0043   0440 38 00 00      mov c, 0
0044   0443 E7            pop d
0045   0444 FD 43         mov [d], b
0046   0446             ; while(*psrc) *pdest++ = *psrc++; 
0047   0446             _while1_cond:
0048   0446 FA FF FF      lea d, [bp + -1] ; $psrc
0049   0449 2A            mov b, [d]
0050   044A 38 00 00      mov c, 0
0051   044D 74            mov d, b
0052   044E 32            mov bl, [d]
0053   044F A7 00         mov bh, 0
0054   0451 C0 00 00      cmp b, 0
0055   0454 C6 82 04      je _while1_exit
0056   0457             _while1_block:
0057   0457             ; *pdest++ = *psrc++; 
0058   0457 FA FD FF      lea d, [bp + -3] ; $pdest
0059   045A 2A            mov b, [d]
0060   045B 38 00 00      mov c, 0
0061   045E FD 77         inc b
0062   0460 FA FD FF      lea d, [bp + -3] ; $pdest
0063   0463 FD 43         mov [d], b
0064   0465 FD 7D         dec b
0065   0467 D8            push b
0066   0468 FA FF FF      lea d, [bp + -1] ; $psrc
0067   046B 2A            mov b, [d]
0068   046C 38 00 00      mov c, 0
0069   046F FD 77         inc b
0070   0471 FA FF FF      lea d, [bp + -1] ; $psrc
0071   0474 FD 43         mov [d], b
0072   0476 FD 7D         dec b
0073   0478 74            mov d, b
0074   0479 32            mov bl, [d]
0075   047A A7 00         mov bh, 0
0076   047C E7            pop d
0077   047D FD 3E         mov [d], bl
0078   047F 0A 46 04      jmp _while1_cond
0079   0482             _while1_exit:
0080   0482             ; *pdest = '\0'; 
0081   0482 FA FD FF      lea d, [bp + -3] ; $pdest
0082   0485 2A            mov b, [d]
0083   0486 38 00 00      mov c, 0
0084   0489 D8            push b
0085   048A FD 2E 00 00   mov32 cb, $00000000
0085   048E 00 00 
0086   0490 E7            pop d
0087   0491 FD 3E         mov [d], bl
0088   0493 F9            leave
0089   0494 09            ret
0090   0495             
0091   0495             strcmp:
0092   0495 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0093   0498             ; while (*s1 && (*s1 == *s2)) { 
0094   0498             _while2_cond:
0095   0498 FA 05 00      lea d, [bp + 5] ; $s1
0096   049B 2A            mov b, [d]
0097   049C 38 00 00      mov c, 0
0098   049F 74            mov d, b
0099   04A0 32            mov bl, [d]
0100   04A1 A7 00         mov bh, 0
0101   04A3             ; --- START LOGICAL AND
0102   04A3 D7            push a
0103   04A4 11            mov a, b
0104   04A5 FA 05 00      lea d, [bp + 5] ; $s1
0105   04A8 2A            mov b, [d]
0106   04A9 38 00 00      mov c, 0
0107   04AC 74            mov d, b
0108   04AD 32            mov bl, [d]
0109   04AE A7 00         mov bh, 0
0110   04B0             ; --- START RELATIONAL
0111   04B0 D7            push a
0112   04B1 11            mov a, b
0113   04B2 FA 07 00      lea d, [bp + 7] ; $s2
0114   04B5 2A            mov b, [d]
0115   04B6 38 00 00      mov c, 0
0116   04B9 74            mov d, b
0117   04BA 32            mov bl, [d]
0118   04BB A7 00         mov bh, 0
0119   04BD B0            cmp a, b
0120   04BE FD 71         seq ; ==
0121   04C0 E4            pop a
0122   04C1             ; --- END RELATIONAL
0123   04C1 FD A7         sand a, b
0124   04C3 E4            pop a
0125   04C4             ; --- END LOGICAL AND
0126   04C4 C0 00 00      cmp b, 0
0127   04C7 C6 ED 04      je _while2_exit
0128   04CA             _while2_block:
0129   04CA             ; s1++; 
0130   04CA FA 05 00      lea d, [bp + 5] ; $s1
0131   04CD 2A            mov b, [d]
0132   04CE 38 00 00      mov c, 0
0133   04D1 FD 77         inc b
0134   04D3 FA 05 00      lea d, [bp + 5] ; $s1
0135   04D6 FD 43         mov [d], b
0136   04D8 FD 7D         dec b
0137   04DA             ; s2++; 
0138   04DA FA 07 00      lea d, [bp + 7] ; $s2
0139   04DD 2A            mov b, [d]
0140   04DE 38 00 00      mov c, 0
0141   04E1 FD 77         inc b
0142   04E3 FA 07 00      lea d, [bp + 7] ; $s2
0143   04E6 FD 43         mov [d], b
0144   04E8 FD 7D         dec b
0145   04EA 0A 98 04      jmp _while2_cond
0146   04ED             _while2_exit:
0147   04ED             ; return *s1 - *s2; 
0148   04ED FA 05 00      lea d, [bp + 5] ; $s1
0149   04F0 2A            mov b, [d]
0150   04F1 38 00 00      mov c, 0
0151   04F4 74            mov d, b
0152   04F5 32            mov bl, [d]
0153   04F6 A7 00         mov bh, 0
0154   04F8             ; --- START TERMS
0155   04F8 D7            push a
0156   04F9 11            mov a, b
0157   04FA FA 07 00      lea d, [bp + 7] ; $s2
0158   04FD 2A            mov b, [d]
0159   04FE 38 00 00      mov c, 0
0160   0501 74            mov d, b
0161   0502 32            mov bl, [d]
0162   0503 A7 00         mov bh, 0
0163   0505 60            sub a, b
0164   0506 27            mov b, a
0165   0507 E4            pop a
0166   0508             ; --- END TERMS
0167   0508 F9            leave
0168   0509 09            ret
0169   050A             
0170   050A             strncmp:
0171   050A F8 00 00      enter 0 ; (push bp; mov bp, sp)
0172   050D F9            leave
0173   050E 09            ret
0174   050F             
0175   050F             strcat:
0176   050F F8 00 00      enter 0 ; (push bp; mov bp, sp)
0177   0512             ; int dest_len; 
0178   0512 52 02 00      sub sp, 2
0179   0515             ; int i; 
0180   0515 52 02 00      sub sp, 2
0181   0518             ; dest_len = strlen(dest); 
0182   0518 FA FF FF      lea d, [bp + -1] ; $dest_len
0183   051B DA            push d
0184   051C             ; --- START FUNCTION CALL
0185   051C FA 05 00      lea d, [bp + 5] ; $dest
0186   051F 2A            mov b, [d]
0187   0520 38 00 00      mov c, 0
0188   0523 FD AB         swp b
0189   0525 D8            push b
0190   0526 07 F2 05      call strlen
0191   0529 51 02 00      add sp, 2
0192   052C             ; --- END FUNCTION CALL
0193   052C E7            pop d
0194   052D FD 43         mov [d], b
0195   052F             ; for (i = 0; src[i] != 0; i=i+1) { 
0196   052F             _for3_init:
0197   052F FA FD FF      lea d, [bp + -3] ; $i
0198   0532 DA            push d
0199   0533 FD 2E 00 00   mov32 cb, $00000000
0199   0537 00 00 
0200   0539 E7            pop d
0201   053A FD 43         mov [d], b
0202   053C             _for3_cond:
0203   053C FA 07 00      lea d, [bp + 7] ; $src
0204   053F FD 2A         mov d, [d]
0205   0541 D7            push a
0206   0542 DA            push d
0207   0543 FA FD FF      lea d, [bp + -3] ; $i
0208   0546 2A            mov b, [d]
0209   0547 38 00 00      mov c, 0
0210   054A E7            pop d
0211   054B FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0212   054F E4            pop a
0213   0550 32            mov bl, [d]
0214   0551 A7 00         mov bh, 0
0215   0553 38 00 00      mov c, 0
0216   0556             ; --- START RELATIONAL
0217   0556 D7            push a
0218   0557 11            mov a, b
0219   0558 FD 2E 00 00   mov32 cb, $00000000
0219   055C 00 00 
0220   055E B0            cmp a, b
0221   055F FD 72         sneq ; !=
0222   0561 E4            pop a
0223   0562             ; --- END RELATIONAL
0224   0562 C0 00 00      cmp b, 0
0225   0565 C6 C0 05      je _for3_exit
0226   0568             _for3_block:
0227   0568             ; dest[dest_len + i] = src[i]; 
0228   0568 FA 05 00      lea d, [bp + 5] ; $dest
0229   056B FD 2A         mov d, [d]
0230   056D D7            push a
0231   056E DA            push d
0232   056F FA FF FF      lea d, [bp + -1] ; $dest_len
0233   0572 2A            mov b, [d]
0234   0573 38 00 00      mov c, 0
0235   0576             ; --- START TERMS
0236   0576 D7            push a
0237   0577 11            mov a, b
0238   0578 FA FD FF      lea d, [bp + -3] ; $i
0239   057B 2A            mov b, [d]
0240   057C 38 00 00      mov c, 0
0241   057F 56            add b, a
0242   0580 E4            pop a
0243   0581             ; --- END TERMS
0244   0581 E7            pop d
0245   0582 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0246   0586 E4            pop a
0247   0587 DA            push d
0248   0588 FA 07 00      lea d, [bp + 7] ; $src
0249   058B FD 2A         mov d, [d]
0250   058D D7            push a
0251   058E DA            push d
0252   058F FA FD FF      lea d, [bp + -3] ; $i
0253   0592 2A            mov b, [d]
0254   0593 38 00 00      mov c, 0
0255   0596 E7            pop d
0256   0597 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0257   059B E4            pop a
0258   059C 32            mov bl, [d]
0259   059D A7 00         mov bh, 0
0260   059F 38 00 00      mov c, 0
0261   05A2 E7            pop d
0262   05A3 FD 3E         mov [d], bl
0263   05A5             _for3_update:
0264   05A5 FA FD FF      lea d, [bp + -3] ; $i
0265   05A8 DA            push d
0266   05A9 FA FD FF      lea d, [bp + -3] ; $i
0267   05AC 2A            mov b, [d]
0268   05AD 38 00 00      mov c, 0
0269   05B0             ; --- START TERMS
0270   05B0 D7            push a
0271   05B1 11            mov a, b
0272   05B2 FD 2E 01 00   mov32 cb, $00000001
0272   05B6 00 00 
0273   05B8 56            add b, a
0274   05B9 E4            pop a
0275   05BA             ; --- END TERMS
0276   05BA E7            pop d
0277   05BB FD 43         mov [d], b
0278   05BD 0A 3C 05      jmp _for3_cond
0279   05C0             _for3_exit:
0280   05C0             ; dest[dest_len + i] = 0; 
0281   05C0 FA 05 00      lea d, [bp + 5] ; $dest
0282   05C3 FD 2A         mov d, [d]
0283   05C5 D7            push a
0284   05C6 DA            push d
0285   05C7 FA FF FF      lea d, [bp + -1] ; $dest_len
0286   05CA 2A            mov b, [d]
0287   05CB 38 00 00      mov c, 0
0288   05CE             ; --- START TERMS
0289   05CE D7            push a
0290   05CF 11            mov a, b
0291   05D0 FA FD FF      lea d, [bp + -3] ; $i
0292   05D3 2A            mov b, [d]
0293   05D4 38 00 00      mov c, 0
0294   05D7 56            add b, a
0295   05D8 E4            pop a
0296   05D9             ; --- END TERMS
0297   05D9 E7            pop d
0298   05DA FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0299   05DE E4            pop a
0300   05DF DA            push d
0301   05E0 FD 2E 00 00   mov32 cb, $00000000
0301   05E4 00 00 
0302   05E6 E7            pop d
0303   05E7 FD 3E         mov [d], bl
0304   05E9             ; return dest; 
0305   05E9 FA 05 00      lea d, [bp + 5] ; $dest
0306   05EC 2A            mov b, [d]
0307   05ED 38 00 00      mov c, 0
0308   05F0 F9            leave
0309   05F1 09            ret
0310   05F2             
0311   05F2             strlen:
0312   05F2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0313   05F5             ; int length; 
0314   05F5 52 02 00      sub sp, 2
0315   05F8             ; length = 0; 
0316   05F8 FA FF FF      lea d, [bp + -1] ; $length
0317   05FB DA            push d
0318   05FC FD 2E 00 00   mov32 cb, $00000000
0318   0600 00 00 
0319   0602 E7            pop d
0320   0603 FD 43         mov [d], b
0321   0605             ; while (str[length] != 0) { 
0322   0605             _while4_cond:
0323   0605 FA 05 00      lea d, [bp + 5] ; $str
0324   0608 FD 2A         mov d, [d]
0325   060A D7            push a
0326   060B DA            push d
0327   060C FA FF FF      lea d, [bp + -1] ; $length
0328   060F 2A            mov b, [d]
0329   0610 38 00 00      mov c, 0
0330   0613 E7            pop d
0331   0614 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0332   0618 E4            pop a
0333   0619 32            mov bl, [d]
0334   061A A7 00         mov bh, 0
0335   061C 38 00 00      mov c, 0
0336   061F             ; --- START RELATIONAL
0337   061F D7            push a
0338   0620 11            mov a, b
0339   0621 FD 2E 00 00   mov32 cb, $00000000
0339   0625 00 00 
0340   0627 B0            cmp a, b
0341   0628 FD 72         sneq ; !=
0342   062A E4            pop a
0343   062B             ; --- END RELATIONAL
0344   062B C0 00 00      cmp b, 0
0345   062E C6 44 06      je _while4_exit
0346   0631             _while4_block:
0347   0631             ; length++; 
0348   0631 FA FF FF      lea d, [bp + -1] ; $length
0349   0634 2A            mov b, [d]
0350   0635 38 00 00      mov c, 0
0351   0638 FD 77         inc b
0352   063A FA FF FF      lea d, [bp + -1] ; $length
0353   063D FD 43         mov [d], b
0354   063F FD 7D         dec b
0355   0641 0A 05 06      jmp _while4_cond
0356   0644             _while4_exit:
0357   0644             ; return length; 
0358   0644 FA FF FF      lea d, [bp + -1] ; $length
0359   0647 2A            mov b, [d]
0360   0648 38 00 00      mov c, 0
0361   064B F9            leave
0362   064C 09            ret
0363   064D             
0364   064D             exit:
0365   064D F8 00 00      enter 0 ; (push bp; mov bp, sp)
0366   0650             
0367   0650             ; --- BEGIN INLINE ASM SEGMENT
0368   0650 05 0B         syscall sys_terminate_proc
0369   0652             ; --- END INLINE ASM SEGMENT
0370   0652             
0371   0652 F9            leave
0372   0653 09            ret
0373   0654             
0374   0654             memset:
0375   0654 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0376   0657             ; int i; 
0377   0657 52 02 00      sub sp, 2
0378   065A             ; for(i = 0; i < size; i++){ 
0379   065A             _for5_init:
0380   065A FA FF FF      lea d, [bp + -1] ; $i
0381   065D DA            push d
0382   065E FD 2E 00 00   mov32 cb, $00000000
0382   0662 00 00 
0383   0664 E7            pop d
0384   0665 FD 43         mov [d], b
0385   0667             _for5_cond:
0386   0667 FA FF FF      lea d, [bp + -1] ; $i
0387   066A 2A            mov b, [d]
0388   066B 38 00 00      mov c, 0
0389   066E             ; --- START RELATIONAL
0390   066E D7            push a
0391   066F 11            mov a, b
0392   0670 FA 08 00      lea d, [bp + 8] ; $size
0393   0673 2A            mov b, [d]
0394   0674 38 00 00      mov c, 0
0395   0677 B0            cmp a, b
0396   0678 FD 73         slt ; < (signed)
0397   067A E4            pop a
0398   067B             ; --- END RELATIONAL
0399   067B C0 00 00      cmp b, 0
0400   067E C6 B3 06      je _for5_exit
0401   0681             _for5_block:
0402   0681             ; *(s+i) = c; 
0403   0681 FA 05 00      lea d, [bp + 5] ; $s
0404   0684 2A            mov b, [d]
0405   0685 38 00 00      mov c, 0
0406   0688             ; --- START TERMS
0407   0688 D7            push a
0408   0689 11            mov a, b
0409   068A FA FF FF      lea d, [bp + -1] ; $i
0410   068D 2A            mov b, [d]
0411   068E 38 00 00      mov c, 0
0412   0691 56            add b, a
0413   0692 E4            pop a
0414   0693             ; --- END TERMS
0415   0693 D8            push b
0416   0694 FA 07 00      lea d, [bp + 7] ; $c
0417   0697 32            mov bl, [d]
0418   0698 A7 00         mov bh, 0
0419   069A 38 00 00      mov c, 0
0420   069D E7            pop d
0421   069E FD 3E         mov [d], bl
0422   06A0             _for5_update:
0423   06A0 FA FF FF      lea d, [bp + -1] ; $i
0424   06A3 2A            mov b, [d]
0425   06A4 38 00 00      mov c, 0
0426   06A7 FD 77         inc b
0427   06A9 FA FF FF      lea d, [bp + -1] ; $i
0428   06AC FD 43         mov [d], b
0429   06AE FD 7D         dec b
0430   06B0 0A 67 06      jmp _for5_cond
0431   06B3             _for5_exit:
0432   06B3             ; return s; 
0433   06B3 FA 05 00      lea d, [bp + 5] ; $s
0434   06B6 2A            mov b, [d]
0435   06B7 38 00 00      mov c, 0
0436   06BA F9            leave
0437   06BB 09            ret
0438   06BC             
0439   06BC             atoi:
0440   06BC F8 00 00      enter 0 ; (push bp; mov bp, sp)
0441   06BF             ; int result = 0;  // Initialize result 
0442   06BF 52 02 00      sub sp, 2
0443   06C2             ; --- START LOCAL VAR INITIALIZATION
0444   06C2 FA FF FF      lea d, [bp + -1] ; $result
0445   06C5 DA            push d
0446   06C6 FD 2E 00 00   mov32 cb, $00000000
0446   06CA 00 00 
0447   06CC E7            pop d
0448   06CD FD 43         mov [d], b
0449   06CF             ; --- END LOCAL VAR INITIALIZATION
0450   06CF             ; int sign = 1;    // Initialize sign as positive 
0451   06CF 52 02 00      sub sp, 2
0452   06D2             ; --- START LOCAL VAR INITIALIZATION
0453   06D2 FA FD FF      lea d, [bp + -3] ; $sign
0454   06D5 DA            push d
0455   06D6 FD 2E 01 00   mov32 cb, $00000001
0455   06DA 00 00 
0456   06DC E7            pop d
0457   06DD FD 43         mov [d], b
0458   06DF             ; --- END LOCAL VAR INITIALIZATION
0459   06DF             ; while (*str == ' ') str++; 
0460   06DF             _while6_cond:
0461   06DF FA 05 00      lea d, [bp + 5] ; $str
0462   06E2 2A            mov b, [d]
0463   06E3 38 00 00      mov c, 0
0464   06E6 74            mov d, b
0465   06E7 32            mov bl, [d]
0466   06E8 A7 00         mov bh, 0
0467   06EA             ; --- START RELATIONAL
0468   06EA D7            push a
0469   06EB 11            mov a, b
0470   06EC FD 2E 20 00   mov32 cb, $00000020
0470   06F0 00 00 
0471   06F2 B0            cmp a, b
0472   06F3 FD 71         seq ; ==
0473   06F5 E4            pop a
0474   06F6             ; --- END RELATIONAL
0475   06F6 C0 00 00      cmp b, 0
0476   06F9 C6 0F 07      je _while6_exit
0477   06FC             _while6_block:
0478   06FC             ; str++; 
0479   06FC FA 05 00      lea d, [bp + 5] ; $str
0480   06FF 2A            mov b, [d]
0481   0700 38 00 00      mov c, 0
0482   0703 FD 77         inc b
0483   0705 FA 05 00      lea d, [bp + 5] ; $str
0484   0708 FD 43         mov [d], b
0485   070A FD 7D         dec b
0486   070C 0A DF 06      jmp _while6_cond
0487   070F             _while6_exit:
0488   070F             ; if (*str == '-' || *str == '+') { 
0489   070F             _if7_cond:
0490   070F FA 05 00      lea d, [bp + 5] ; $str
0491   0712 2A            mov b, [d]
0492   0713 38 00 00      mov c, 0
0493   0716 74            mov d, b
0494   0717 32            mov bl, [d]
0495   0718 A7 00         mov bh, 0
0496   071A             ; --- START RELATIONAL
0497   071A D7            push a
0498   071B 11            mov a, b
0499   071C FD 2E 2D 00   mov32 cb, $0000002d
0499   0720 00 00 
0500   0722 B0            cmp a, b
0501   0723 FD 71         seq ; ==
0502   0725 E4            pop a
0503   0726             ; --- END RELATIONAL
0504   0726             ; --- START LOGICAL OR
0505   0726 D7            push a
0506   0727 11            mov a, b
0507   0728 FA 05 00      lea d, [bp + 5] ; $str
0508   072B 2A            mov b, [d]
0509   072C 38 00 00      mov c, 0
0510   072F 74            mov d, b
0511   0730 32            mov bl, [d]
0512   0731 A7 00         mov bh, 0
0513   0733             ; --- START RELATIONAL
0514   0733 D7            push a
0515   0734 11            mov a, b
0516   0735 FD 2E 2B 00   mov32 cb, $0000002b
0516   0739 00 00 
0517   073B B0            cmp a, b
0518   073C FD 71         seq ; ==
0519   073E E4            pop a
0520   073F             ; --- END RELATIONAL
0521   073F FD A8         sor a, b ; ||
0522   0741 E4            pop a
0523   0742             ; --- END LOGICAL OR
0524   0742 C0 00 00      cmp b, 0
0525   0745 C6 8A 07      je _if7_exit
0526   0748             _if7_true:
0527   0748             ; if (*str == '-') sign = -1; 
0528   0748             _if8_cond:
0529   0748 FA 05 00      lea d, [bp + 5] ; $str
0530   074B 2A            mov b, [d]
0531   074C 38 00 00      mov c, 0
0532   074F 74            mov d, b
0533   0750 32            mov bl, [d]
0534   0751 A7 00         mov bh, 0
0535   0753             ; --- START RELATIONAL
0536   0753 D7            push a
0537   0754 11            mov a, b
0538   0755 FD 2E 2D 00   mov32 cb, $0000002d
0538   0759 00 00 
0539   075B B0            cmp a, b
0540   075C FD 71         seq ; ==
0541   075E E4            pop a
0542   075F             ; --- END RELATIONAL
0543   075F C0 00 00      cmp b, 0
0544   0762 C6 77 07      je _if8_exit
0545   0765             _if8_true:
0546   0765             ; sign = -1; 
0547   0765 FA FD FF      lea d, [bp + -3] ; $sign
0548   0768 DA            push d
0549   0769 FD 2E 01 00   mov32 cb, $00000001
0549   076D 00 00 
0550   076F FD 97         neg b
0551   0771 E7            pop d
0552   0772 FD 43         mov [d], b
0553   0774 0A 77 07      jmp _if8_exit
0554   0777             _if8_exit:
0555   0777             ; str++; 
0556   0777 FA 05 00      lea d, [bp + 5] ; $str
0557   077A 2A            mov b, [d]
0558   077B 38 00 00      mov c, 0
0559   077E FD 77         inc b
0560   0780 FA 05 00      lea d, [bp + 5] ; $str
0561   0783 FD 43         mov [d], b
0562   0785 FD 7D         dec b
0563   0787 0A 8A 07      jmp _if7_exit
0564   078A             _if7_exit:
0565   078A             ; while (*str >= '0' && *str <= '9') { 
0566   078A             _while9_cond:
0567   078A FA 05 00      lea d, [bp + 5] ; $str
0568   078D 2A            mov b, [d]
0569   078E 38 00 00      mov c, 0
0570   0791 74            mov d, b
0571   0792 32            mov bl, [d]
0572   0793 A7 00         mov bh, 0
0573   0795             ; --- START RELATIONAL
0574   0795 D7            push a
0575   0796 11            mov a, b
0576   0797 FD 2E 30 00   mov32 cb, $00000030
0576   079B 00 00 
0577   079D B0            cmp a, b
0578   079E FD 82         sgeu ; >= (unsigned)
0579   07A0 E4            pop a
0580   07A1             ; --- END RELATIONAL
0581   07A1             ; --- START LOGICAL AND
0582   07A1 D7            push a
0583   07A2 11            mov a, b
0584   07A3 FA 05 00      lea d, [bp + 5] ; $str
0585   07A6 2A            mov b, [d]
0586   07A7 38 00 00      mov c, 0
0587   07AA 74            mov d, b
0588   07AB 32            mov bl, [d]
0589   07AC A7 00         mov bh, 0
0590   07AE             ; --- START RELATIONAL
0591   07AE D7            push a
0592   07AF 11            mov a, b
0593   07B0 FD 2E 39 00   mov32 cb, $00000039
0593   07B4 00 00 
0594   07B6 B0            cmp a, b
0595   07B7 FD 76         sleu ; <= (unsigned)
0596   07B9 E4            pop a
0597   07BA             ; --- END RELATIONAL
0598   07BA FD A7         sand a, b
0599   07BC E4            pop a
0600   07BD             ; --- END LOGICAL AND
0601   07BD C0 00 00      cmp b, 0
0602   07C0 C6 0A 08      je _while9_exit
0603   07C3             _while9_block:
0604   07C3             ; result = result * 10 + (*str - '0'); 
0605   07C3 FA FF FF      lea d, [bp + -1] ; $result
0606   07C6 DA            push d
0607   07C7 FA FF FF      lea d, [bp + -1] ; $result
0608   07CA 2A            mov b, [d]
0609   07CB 38 00 00      mov c, 0
0610   07CE             ; --- START FACTORS
0611   07CE D7            push a
0612   07CF 11            mov a, b
0613   07D0 FD 2E 0A 00   mov32 cb, $0000000a
0613   07D4 00 00 
0614   07D6 AC            mul a, b ; *
0615   07D7 11            mov a, b
0616   07D8 27            mov b, a
0617   07D9 E4            pop a
0618   07DA             ; --- END FACTORS
0619   07DA             ; --- START TERMS
0620   07DA D7            push a
0621   07DB 11            mov a, b
0622   07DC FA 05 00      lea d, [bp + 5] ; $str
0623   07DF 2A            mov b, [d]
0624   07E0 38 00 00      mov c, 0
0625   07E3 74            mov d, b
0626   07E4 32            mov bl, [d]
0627   07E5 A7 00         mov bh, 0
0628   07E7             ; --- START TERMS
0629   07E7 D7            push a
0630   07E8 11            mov a, b
0631   07E9 FD 2E 30 00   mov32 cb, $00000030
0631   07ED 00 00 
0632   07EF 60            sub a, b
0633   07F0 27            mov b, a
0634   07F1 E4            pop a
0635   07F2             ; --- END TERMS
0636   07F2 56            add b, a
0637   07F3 E4            pop a
0638   07F4             ; --- END TERMS
0639   07F4 E7            pop d
0640   07F5 FD 43         mov [d], b
0641   07F7             ; str++; 
0642   07F7 FA 05 00      lea d, [bp + 5] ; $str
0643   07FA 2A            mov b, [d]
0644   07FB 38 00 00      mov c, 0
0645   07FE FD 77         inc b
0646   0800 FA 05 00      lea d, [bp + 5] ; $str
0647   0803 FD 43         mov [d], b
0648   0805 FD 7D         dec b
0649   0807 0A 8A 07      jmp _while9_cond
0650   080A             _while9_exit:
0651   080A             ; return sign * result; 
0652   080A FA FD FF      lea d, [bp + -3] ; $sign
0653   080D 2A            mov b, [d]
0654   080E 38 00 00      mov c, 0
0655   0811             ; --- START FACTORS
0656   0811 D7            push a
0657   0812 11            mov a, b
0658   0813 FA FF FF      lea d, [bp + -1] ; $result
0659   0816 2A            mov b, [d]
0660   0817 38 00 00      mov c, 0
0661   081A AC            mul a, b ; *
0662   081B 11            mov a, b
0663   081C 27            mov b, a
0664   081D E4            pop a
0665   081E             ; --- END FACTORS
0666   081E F9            leave
0667   081F 09            ret
0668   0820             
0669   0820             rand:
0670   0820 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0671   0823             ; int  sec; 
0672   0823 52 02 00      sub sp, 2
0673   0826             
0674   0826             ; --- BEGIN INLINE ASM SEGMENT
0675   0826 19 00         mov al, 0
0676   0828 05 01         syscall sys_rtc					
0677   082A 1A            mov al, ah
0678   082B FA FF FF      lea d, [bp + -1] ; $sec
0679   082E 1E            mov al, [d]
0680   082F 22 00         mov ah, 0
0681   0831             ; --- END INLINE ASM SEGMENT
0682   0831             
0683   0831             ; return sec; 
0684   0831 FA FF FF      lea d, [bp + -1] ; $sec
0685   0834 2A            mov b, [d]
0686   0835 38 00 00      mov c, 0
0687   0838 F9            leave
0688   0839 09            ret
0689   083A             
0690   083A             alloc:
0691   083A F8 00 00      enter 0 ; (push bp; mov bp, sp)
0692   083D             ; heap_top = heap_top + bytes; 
0693   083D 3B 20 21      mov d, _heap_top ; $heap_top
0694   0840 DA            push d
0695   0841 3B 20 21      mov d, _heap_top ; $heap_top
0696   0844 2A            mov b, [d]
0697   0845 38 00 00      mov c, 0
0698   0848             ; --- START TERMS
0699   0848 D7            push a
0700   0849 11            mov a, b
0701   084A FA 05 00      lea d, [bp + 5] ; $bytes
0702   084D 2A            mov b, [d]
0703   084E 38 00 00      mov c, 0
0704   0851 56            add b, a
0705   0852 E4            pop a
0706   0853             ; --- END TERMS
0707   0853 E7            pop d
0708   0854 FD 43         mov [d], b
0709   0856             ; return heap_top - bytes; 
0710   0856 3B 20 21      mov d, _heap_top ; $heap_top
0711   0859 2A            mov b, [d]
0712   085A 38 00 00      mov c, 0
0713   085D             ; --- START TERMS
0714   085D D7            push a
0715   085E 11            mov a, b
0716   085F FA 05 00      lea d, [bp + 5] ; $bytes
0717   0862 2A            mov b, [d]
0718   0863 38 00 00      mov c, 0
0719   0866 60            sub a, b
0720   0867 27            mov b, a
0721   0868 E4            pop a
0722   0869             ; --- END TERMS
0723   0869 F9            leave
0724   086A 09            ret
0725   086B             
0726   086B             free:
0727   086B F8 00 00      enter 0 ; (push bp; mov bp, sp)
0728   086E             ; return heap_top = heap_top - bytes; 
0729   086E 3B 20 21      mov d, _heap_top ; $heap_top
0730   0871 DA            push d
0731   0872 3B 20 21      mov d, _heap_top ; $heap_top
0732   0875 2A            mov b, [d]
0733   0876 38 00 00      mov c, 0
0734   0879             ; --- START TERMS
0735   0879 D7            push a
0736   087A 11            mov a, b
0737   087B FA 05 00      lea d, [bp + 5] ; $bytes
0738   087E 2A            mov b, [d]
0739   087F 38 00 00      mov c, 0
0740   0882 60            sub a, b
0741   0883 27            mov b, a
0742   0884 E4            pop a
0743   0885             ; --- END TERMS
0744   0885 E7            pop d
0745   0886 FD 43         mov [d], b
0746   0888 F9            leave
0747   0889 09            ret
0748   088A             
0749   088A             fopen:
0750   088A F8 00 00      enter 0 ; (push bp; mov bp, sp)
0751   088D             ; FILE *fp; 
0752   088D 52 02 00      sub sp, 2
0753   0890             ; static int max_handle = 0; 
0754   0890 52 02 00      sub sp, 2
0755   0893             ; fp = alloc(sizeof(FILE)); 
0756   0893 FA FF FF      lea d, [bp + -1] ; $fp
0757   0896 DA            push d
0758   0897             ; --- START FUNCTION CALL
0759   0897 26 04 01      mov b, 260
0760   089A FD AB         swp b
0761   089C D8            push b
0762   089D 07 3A 08      call alloc
0763   08A0 51 02 00      add sp, 2
0764   08A3             ; --- END FUNCTION CALL
0765   08A3 E7            pop d
0766   08A4 FD 43         mov [d], b
0767   08A6             ; strcpy(fp->filename, filename); 
0768   08A6             ; --- START FUNCTION CALL
0769   08A6 FA 05 00      lea d, [bp + 5] ; $filename
0770   08A9 2A            mov b, [d]
0771   08AA 38 00 00      mov c, 0
0772   08AD FD AB         swp b
0773   08AF D8            push b
0774   08B0 FA FF FF      lea d, [bp + -1] ; $fp
0775   08B3 FD 2A         mov d, [d]
0776   08B5 58 02 00      add d, 2
0777   08B8 2D            mov b, d
0778   08B9 38 00 00      mov c, 0
0779   08BC FD AB         swp b
0780   08BE D8            push b
0781   08BF 07 21 04      call strcpy
0782   08C2 51 04 00      add sp, 4
0783   08C5             ; --- END FUNCTION CALL
0784   08C5             ; fp->handle = max_handle; 
0785   08C5 FA FF FF      lea d, [bp + -1] ; $fp
0786   08C8 FD 2A         mov d, [d]
0787   08CA 58 00 00      add d, 0
0788   08CD DA            push d
0789   08CE 3B DA 20      mov d, st_fopen_max_handle ; static max_handle
0790   08D1 2A            mov b, [d]
0791   08D2 38 00 00      mov c, 0
0792   08D5 E7            pop d
0793   08D6 FD 43         mov [d], b
0794   08D8             ; fp->mode = mode; 
0795   08D8 FA FF FF      lea d, [bp + -1] ; $fp
0796   08DB FD 2A         mov d, [d]
0797   08DD 58 02 01      add d, 258
0798   08E0 DA            push d
0799   08E1 FA 07 00      lea d, [bp + 7] ; $mode
0800   08E4 32            mov bl, [d]
0801   08E5 A7 00         mov bh, 0
0802   08E7 38 00 00      mov c, 0
0803   08EA E7            pop d
0804   08EB FD 3E         mov [d], bl
0805   08ED             ; fp->loc = 0; 
0806   08ED FA FF FF      lea d, [bp + -1] ; $fp
0807   08F0 FD 2A         mov d, [d]
0808   08F2 58 03 01      add d, 259
0809   08F5 DA            push d
0810   08F6 FD 2E 00 00   mov32 cb, $00000000
0810   08FA 00 00 
0811   08FC E7            pop d
0812   08FD FD 3E         mov [d], bl
0813   08FF             ; max_handle++; 
0814   08FF 3B DA 20      mov d, st_fopen_max_handle ; static max_handle
0815   0902 2A            mov b, [d]
0816   0903 38 00 00      mov c, 0
0817   0906 FD 77         inc b
0818   0908 3B DA 20      mov d, st_fopen_max_handle ; static max_handle
0819   090B FD 43         mov [d], b
0820   090D FD 7D         dec b
0821   090F F9            leave
0822   0910 09            ret
0823   0911             
0824   0911             fclose:
0825   0911 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0826   0914             ; free(sizeof(FILE)); 
0827   0914             ; --- START FUNCTION CALL
0828   0914 26 04 01      mov b, 260
0829   0917 FD AB         swp b
0830   0919 D8            push b
0831   091A 07 6B 08      call free
0832   091D 51 02 00      add sp, 2
0833   0920             ; --- END FUNCTION CALL
0834   0920 F9            leave
0835   0921 09            ret
0836   0922             
0837   0922             printf:
0838   0922 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0839   0925             ; char *p, *format_p; 
0840   0925 52 02 00      sub sp, 2
0841   0928 52 02 00      sub sp, 2
0842   092B             ; format_p = format; 
0843   092B FA FD FF      lea d, [bp + -3] ; $format_p
0844   092E DA            push d
0845   092F FA 05 00      lea d, [bp + 5] ; $format
0846   0932 2A            mov b, [d]
0847   0933 38 00 00      mov c, 0
0848   0936 E7            pop d
0849   0937 FD 43         mov [d], b
0850   0939             ; p = &format + 2; 
0851   0939 FA FF FF      lea d, [bp + -1] ; $p
0852   093C DA            push d
0853   093D FA 05 00      lea d, [bp + 5] ; $format
0854   0940 2D            mov b, d
0855   0941             ; --- START TERMS
0856   0941 D7            push a
0857   0942 11            mov a, b
0858   0943 FD 2E 02 00   mov32 cb, $00000002
0858   0947 00 00 
0859   0949 56            add b, a
0860   094A E4            pop a
0861   094B             ; --- END TERMS
0862   094B E7            pop d
0863   094C FD 43         mov [d], b
0864   094E             ; for(;;){ 
0865   094E             _for10_init:
0866   094E             _for10_cond:
0867   094E             _for10_block:
0868   094E             ; if(!*format_p) break; 
0869   094E             _if11_cond:
0870   094E FA FD FF      lea d, [bp + -3] ; $format_p
0871   0951 2A            mov b, [d]
0872   0952 38 00 00      mov c, 0
0873   0955 74            mov d, b
0874   0956 32            mov bl, [d]
0875   0957 A7 00         mov bh, 0
0876   0959 C0 00 00      cmp b, 0
0877   095C FD 71         seq ; !
0878   095E C0 00 00      cmp b, 0
0879   0961 C6 6A 09      je _if11_else
0880   0964             _if11_true:
0881   0964             ; break; 
0882   0964 0A E8 0B      jmp _for10_exit ; for break
0883   0967 0A E5 0B      jmp _if11_exit
0884   096A             _if11_else:
0885   096A             ; if(*format_p == '%'){ 
0886   096A             _if12_cond:
0887   096A FA FD FF      lea d, [bp + -3] ; $format_p
0888   096D 2A            mov b, [d]
0889   096E 38 00 00      mov c, 0
0890   0971 74            mov d, b
0891   0972 32            mov bl, [d]
0892   0973 A7 00         mov bh, 0
0893   0975             ; --- START RELATIONAL
0894   0975 D7            push a
0895   0976 11            mov a, b
0896   0977 FD 2E 25 00   mov32 cb, $00000025
0896   097B 00 00 
0897   097D B0            cmp a, b
0898   097E FD 71         seq ; ==
0899   0980 E4            pop a
0900   0981             ; --- END RELATIONAL
0901   0981 C0 00 00      cmp b, 0
0902   0984 C6 C3 0B      je _if12_else
0903   0987             _if12_true:
0904   0987             ; format_p++; 
0905   0987 FA FD FF      lea d, [bp + -3] ; $format_p
0906   098A 2A            mov b, [d]
0907   098B 38 00 00      mov c, 0
0908   098E FD 77         inc b
0909   0990 FA FD FF      lea d, [bp + -3] ; $format_p
0910   0993 FD 43         mov [d], b
0911   0995 FD 7D         dec b
0912   0997             ; switch(*format_p){ 
0913   0997             _switch13_expr:
0914   0997 FA FD FF      lea d, [bp + -3] ; $format_p
0915   099A 2A            mov b, [d]
0916   099B 38 00 00      mov c, 0
0917   099E 74            mov d, b
0918   099F 32            mov bl, [d]
0919   09A0 A7 00         mov bh, 0
0920   09A2             _switch13_comparisons:
0921   09A2 C1 6C         cmp bl, $6c
0922   09A4 C6 D0 09      je _switch13_case0
0923   09A7 C1 4C         cmp bl, $4c
0924   09A9 C6 D0 09      je _switch13_case1
0925   09AC C1 64         cmp bl, $64
0926   09AE C6 DC 0A      je _switch13_case2
0927   09B1 C1 69         cmp bl, $69
0928   09B3 C6 DC 0A      je _switch13_case3
0929   09B6 C1 75         cmp bl, $75
0930   09B8 C6 09 0B      je _switch13_case4
0931   09BB C1 78         cmp bl, $78
0932   09BD C6 36 0B      je _switch13_case5
0933   09C0 C1 63         cmp bl, $63
0934   09C2 C6 5A 0B      je _switch13_case6
0935   09C5 C1 73         cmp bl, $73
0936   09C7 C6 7F 0B      je _switch13_case7
0937   09CA 0A A4 0B      jmp _switch13_default
0938   09CD 0A B0 0B      jmp _switch13_exit
0939   09D0             _switch13_case0:
0940   09D0             _switch13_case1:
0941   09D0             ; format_p++; 
0942   09D0 FA FD FF      lea d, [bp + -3] ; $format_p
0943   09D3 2A            mov b, [d]
0944   09D4 38 00 00      mov c, 0
0945   09D7 FD 77         inc b
0946   09D9 FA FD FF      lea d, [bp + -3] ; $format_p
0947   09DC FD 43         mov [d], b
0948   09DE FD 7D         dec b
0949   09E0             ; if(*format_p == 'd' || *format_p == 'i') 
0950   09E0             _if14_cond:
0951   09E0 FA FD FF      lea d, [bp + -3] ; $format_p
0952   09E3 2A            mov b, [d]
0953   09E4 38 00 00      mov c, 0
0954   09E7 74            mov d, b
0955   09E8 32            mov bl, [d]
0956   09E9 A7 00         mov bh, 0
0957   09EB             ; --- START RELATIONAL
0958   09EB D7            push a
0959   09EC 11            mov a, b
0960   09ED FD 2E 64 00   mov32 cb, $00000064
0960   09F1 00 00 
0961   09F3 B0            cmp a, b
0962   09F4 FD 71         seq ; ==
0963   09F6 E4            pop a
0964   09F7             ; --- END RELATIONAL
0965   09F7             ; --- START LOGICAL OR
0966   09F7 D7            push a
0967   09F8 11            mov a, b
0968   09F9 FA FD FF      lea d, [bp + -3] ; $format_p
0969   09FC 2A            mov b, [d]
0970   09FD 38 00 00      mov c, 0
0971   0A00 74            mov d, b
0972   0A01 32            mov bl, [d]
0973   0A02 A7 00         mov bh, 0
0974   0A04             ; --- START RELATIONAL
0975   0A04 D7            push a
0976   0A05 11            mov a, b
0977   0A06 FD 2E 69 00   mov32 cb, $00000069
0977   0A0A 00 00 
0978   0A0C B0            cmp a, b
0979   0A0D FD 71         seq ; ==
0980   0A0F E4            pop a
0981   0A10             ; --- END RELATIONAL
0982   0A10 FD A8         sor a, b ; ||
0983   0A12 E4            pop a
0984   0A13             ; --- END LOGICAL OR
0985   0A13 C0 00 00      cmp b, 0
0986   0A16 C6 3A 0A      je _if14_else
0987   0A19             _if14_true:
0988   0A19             ; print_signed_long(*(long *)p); 
0989   0A19             ; --- START FUNCTION CALL
0990   0A19 FA FF FF      lea d, [bp + -1] ; $p
0991   0A1C 2A            mov b, [d]
0992   0A1D 38 00 00      mov c, 0
0993   0A20 AB            snex b
0994   0A21 FD 39         mov c, b
0995   0A23 74            mov d, b
0996   0A24 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0997   0A27 FD 39         mov c, b ; And place it into C
0998   0A29 2A            mov b, [d] ; Lower Word in B
0999   0A2A 12            mov a, c
1000   0A2B FD AA         swp a
1001   0A2D D7            push a
1002   0A2E FD AB         swp b
1003   0A30 D8            push b
1004   0A31 07 86 15      call print_signed_long
1005   0A34 51 04 00      add sp, 4
1006   0A37             ; --- END FUNCTION CALL
1007   0A37 0A C1 0A      jmp _if14_exit
1008   0A3A             _if14_else:
1009   0A3A             ; if(*format_p == 'u') 
1010   0A3A             _if15_cond:
1011   0A3A FA FD FF      lea d, [bp + -3] ; $format_p
1012   0A3D 2A            mov b, [d]
1013   0A3E 38 00 00      mov c, 0
1014   0A41 74            mov d, b
1015   0A42 32            mov bl, [d]
1016   0A43 A7 00         mov bh, 0
1017   0A45             ; --- START RELATIONAL
1018   0A45 D7            push a
1019   0A46 11            mov a, b
1020   0A47 FD 2E 75 00   mov32 cb, $00000075
1020   0A4B 00 00 
1021   0A4D B0            cmp a, b
1022   0A4E FD 71         seq ; ==
1023   0A50 E4            pop a
1024   0A51             ; --- END RELATIONAL
1025   0A51 C0 00 00      cmp b, 0
1026   0A54 C6 7A 0A      je _if15_else
1027   0A57             _if15_true:
1028   0A57             ; print_unsigned_long(*(unsigned long *)p); 
1029   0A57             ; --- START FUNCTION CALL
1030   0A57 FA FF FF      lea d, [bp + -1] ; $p
1031   0A5A 2A            mov b, [d]
1032   0A5B 38 00 00      mov c, 0
1033   0A5E A7 00         mov bh, 0
1034   0A60 38 00 00      mov c, 0
1035   0A63 74            mov d, b
1036   0A64 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1037   0A67 FD 39         mov c, b ; And place it into C
1038   0A69 2A            mov b, [d] ; Lower Word in B
1039   0A6A 12            mov a, c
1040   0A6B FD AA         swp a
1041   0A6D D7            push a
1042   0A6E FD AB         swp b
1043   0A70 D8            push b
1044   0A71 07 ED 16      call print_unsigned_long
1045   0A74 51 04 00      add sp, 4
1046   0A77             ; --- END FUNCTION CALL
1047   0A77 0A C1 0A      jmp _if15_exit
1048   0A7A             _if15_else:
1049   0A7A             ; if(*format_p == 'x') 
1050   0A7A             _if16_cond:
1051   0A7A FA FD FF      lea d, [bp + -3] ; $format_p
1052   0A7D 2A            mov b, [d]
1053   0A7E 38 00 00      mov c, 0
1054   0A81 74            mov d, b
1055   0A82 32            mov bl, [d]
1056   0A83 A7 00         mov bh, 0
1057   0A85             ; --- START RELATIONAL
1058   0A85 D7            push a
1059   0A86 11            mov a, b
1060   0A87 FD 2E 78 00   mov32 cb, $00000078
1060   0A8B 00 00 
1061   0A8D B0            cmp a, b
1062   0A8E FD 71         seq ; ==
1063   0A90 E4            pop a
1064   0A91             ; --- END RELATIONAL
1065   0A91 C0 00 00      cmp b, 0
1066   0A94 C6 B5 0A      je _if16_else
1067   0A97             _if16_true:
1068   0A97             ; printx32(*(long int *)p); 
1069   0A97             ; --- START FUNCTION CALL
1070   0A97 FA FF FF      lea d, [bp + -1] ; $p
1071   0A9A 2A            mov b, [d]
1072   0A9B 38 00 00      mov c, 0
1073   0A9E 74            mov d, b
1074   0A9F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1075   0AA2 FD 39         mov c, b ; And place it into C
1076   0AA4 2A            mov b, [d] ; Lower Word in B
1077   0AA5 12            mov a, c
1078   0AA6 FD AA         swp a
1079   0AA8 D7            push a
1080   0AA9 FD AB         swp b
1081   0AAB D8            push b
1082   0AAC 07 59 12      call printx32
1083   0AAF 51 04 00      add sp, 4
1084   0AB2             ; --- END FUNCTION CALL
1085   0AB2 0A C1 0A      jmp _if16_exit
1086   0AB5             _if16_else:
1087   0AB5             ; err("Unexpected format in printf."); 
1088   0AB5             ; --- START FUNCTION CALL
1089   0AB5 26 DC 20      mov b, _s0 ; "Unexpected format in printf."
1090   0AB8 FD AB         swp b
1091   0ABA D8            push b
1092   0ABB 07 44 12      call err
1093   0ABE 51 02 00      add sp, 2
1094   0AC1             ; --- END FUNCTION CALL
1095   0AC1             _if16_exit:
1096   0AC1             _if15_exit:
1097   0AC1             _if14_exit:
1098   0AC1             ; p = p + 4; 
1099   0AC1 FA FF FF      lea d, [bp + -1] ; $p
1100   0AC4 DA            push d
1101   0AC5 FA FF FF      lea d, [bp + -1] ; $p
1102   0AC8 2A            mov b, [d]
1103   0AC9 38 00 00      mov c, 0
1104   0ACC             ; --- START TERMS
1105   0ACC D7            push a
1106   0ACD 11            mov a, b
1107   0ACE FD 2E 04 00   mov32 cb, $00000004
1107   0AD2 00 00 
1108   0AD4 56            add b, a
1109   0AD5 E4            pop a
1110   0AD6             ; --- END TERMS
1111   0AD6 E7            pop d
1112   0AD7 FD 43         mov [d], b
1113   0AD9             ; break; 
1114   0AD9 0A B0 0B      jmp _switch13_exit ; case break
1115   0ADC             _switch13_case2:
1116   0ADC             _switch13_case3:
1117   0ADC             ; print_signed(*(int*)p); 
1118   0ADC             ; --- START FUNCTION CALL
1119   0ADC FA FF FF      lea d, [bp + -1] ; $p
1120   0ADF 2A            mov b, [d]
1121   0AE0 38 00 00      mov c, 0
1122   0AE3 74            mov d, b
1123   0AE4 2A            mov b, [d]
1124   0AE5 FD AB         swp b
1125   0AE7 D8            push b
1126   0AE8 07 4D 14      call print_signed
1127   0AEB 51 02 00      add sp, 2
1128   0AEE             ; --- END FUNCTION CALL
1129   0AEE             ; p = p + 2; 
1130   0AEE FA FF FF      lea d, [bp + -1] ; $p
1131   0AF1 DA            push d
1132   0AF2 FA FF FF      lea d, [bp + -1] ; $p
1133   0AF5 2A            mov b, [d]
1134   0AF6 38 00 00      mov c, 0
1135   0AF9             ; --- START TERMS
1136   0AF9 D7            push a
1137   0AFA 11            mov a, b
1138   0AFB FD 2E 02 00   mov32 cb, $00000002
1138   0AFF 00 00 
1139   0B01 56            add b, a
1140   0B02 E4            pop a
1141   0B03             ; --- END TERMS
1142   0B03 E7            pop d
1143   0B04 FD 43         mov [d], b
1144   0B06             ; break; 
1145   0B06 0A B0 0B      jmp _switch13_exit ; case break
1146   0B09             _switch13_case4:
1147   0B09             ; print_unsigned(*(unsigned int*)p); 
1148   0B09             ; --- START FUNCTION CALL
1149   0B09 FA FF FF      lea d, [bp + -1] ; $p
1150   0B0C 2A            mov b, [d]
1151   0B0D 38 00 00      mov c, 0
1152   0B10 74            mov d, b
1153   0B11 2A            mov b, [d]
1154   0B12 FD AB         swp b
1155   0B14 D8            push b
1156   0B15 07 61 19      call print_unsigned
1157   0B18 51 02 00      add sp, 2
1158   0B1B             ; --- END FUNCTION CALL
1159   0B1B             ; p = p + 2; 
1160   0B1B FA FF FF      lea d, [bp + -1] ; $p
1161   0B1E DA            push d
1162   0B1F FA FF FF      lea d, [bp + -1] ; $p
1163   0B22 2A            mov b, [d]
1164   0B23 38 00 00      mov c, 0
1165   0B26             ; --- START TERMS
1166   0B26 D7            push a
1167   0B27 11            mov a, b
1168   0B28 FD 2E 02 00   mov32 cb, $00000002
1168   0B2C 00 00 
1169   0B2E 56            add b, a
1170   0B2F E4            pop a
1171   0B30             ; --- END TERMS
1172   0B30 E7            pop d
1173   0B31 FD 43         mov [d], b
1174   0B33             ; break; 
1175   0B33 0A B0 0B      jmp _switch13_exit ; case break
1176   0B36             _switch13_case5:
1177   0B36             
1178   0B36             ; --- BEGIN INLINE ASM SEGMENT
1179   0B36 FA FF FF      lea d, [bp + -1] ; $p
1180   0B39 FD 2A         mov d, [d]
1181   0B3B 2A            mov b, [d]
1182   0B3C 07 DA 1F      call print_u16x
1183   0B3F             ; --- END INLINE ASM SEGMENT
1184   0B3F             
1185   0B3F             ; p = p + 2; 
1186   0B3F FA FF FF      lea d, [bp + -1] ; $p
1187   0B42 DA            push d
1188   0B43 FA FF FF      lea d, [bp + -1] ; $p
1189   0B46 2A            mov b, [d]
1190   0B47 38 00 00      mov c, 0
1191   0B4A             ; --- START TERMS
1192   0B4A D7            push a
1193   0B4B 11            mov a, b
1194   0B4C FD 2E 02 00   mov32 cb, $00000002
1194   0B50 00 00 
1195   0B52 56            add b, a
1196   0B53 E4            pop a
1197   0B54             ; --- END TERMS
1198   0B54 E7            pop d
1199   0B55 FD 43         mov [d], b
1200   0B57             ; break; 
1201   0B57 0A B0 0B      jmp _switch13_exit ; case break
1202   0B5A             _switch13_case6:
1203   0B5A             
1204   0B5A             ; --- BEGIN INLINE ASM SEGMENT
1205   0B5A FA FF FF      lea d, [bp + -1] ; $p
1206   0B5D FD 2A         mov d, [d]
1207   0B5F 1E            mov al, [d]
1208   0B60 23            mov ah, al
1209   0B61 07 38 1E      call _putchar
1210   0B64             ; --- END INLINE ASM SEGMENT
1211   0B64             
1212   0B64             ; p = p + 1; 
1213   0B64 FA FF FF      lea d, [bp + -1] ; $p
1214   0B67 DA            push d
1215   0B68 FA FF FF      lea d, [bp + -1] ; $p
1216   0B6B 2A            mov b, [d]
1217   0B6C 38 00 00      mov c, 0
1218   0B6F             ; --- START TERMS
1219   0B6F D7            push a
1220   0B70 11            mov a, b
1221   0B71 FD 2E 01 00   mov32 cb, $00000001
1221   0B75 00 00 
1222   0B77 56            add b, a
1223   0B78 E4            pop a
1224   0B79             ; --- END TERMS
1225   0B79 E7            pop d
1226   0B7A FD 43         mov [d], b
1227   0B7C             ; break; 
1228   0B7C 0A B0 0B      jmp _switch13_exit ; case break
1229   0B7F             _switch13_case7:
1230   0B7F             
1231   0B7F             ; --- BEGIN INLINE ASM SEGMENT
1232   0B7F FA FF FF      lea d, [bp + -1] ; $p
1233   0B82 FD 2A         mov d, [d]
1234   0B84 FD 2A         mov d, [d]
1235   0B86 07 82 1F      call _puts
1236   0B89             ; --- END INLINE ASM SEGMENT
1237   0B89             
1238   0B89             ; p = p + 2; 
1239   0B89 FA FF FF      lea d, [bp + -1] ; $p
1240   0B8C DA            push d
1241   0B8D FA FF FF      lea d, [bp + -1] ; $p
1242   0B90 2A            mov b, [d]
1243   0B91 38 00 00      mov c, 0
1244   0B94             ; --- START TERMS
1245   0B94 D7            push a
1246   0B95 11            mov a, b
1247   0B96 FD 2E 02 00   mov32 cb, $00000002
1247   0B9A 00 00 
1248   0B9C 56            add b, a
1249   0B9D E4            pop a
1250   0B9E             ; --- END TERMS
1251   0B9E E7            pop d
1252   0B9F FD 43         mov [d], b
1253   0BA1             ; break; 
1254   0BA1 0A B0 0B      jmp _switch13_exit ; case break
1255   0BA4             _switch13_default:
1256   0BA4             ; print("Error: Unknown argument type.\n"); 
1257   0BA4             ; --- START FUNCTION CALL
1258   0BA4 26 F9 20      mov b, _s1 ; "Error: Unknown argument type.\n"
1259   0BA7 FD AB         swp b
1260   0BA9 D8            push b
1261   0BAA 07 77 1C      call print
1262   0BAD 51 02 00      add sp, 2
1263   0BB0             ; --- END FUNCTION CALL
1264   0BB0             _switch13_exit:
1265   0BB0             ; format_p++; 
1266   0BB0 FA FD FF      lea d, [bp + -3] ; $format_p
1267   0BB3 2A            mov b, [d]
1268   0BB4 38 00 00      mov c, 0
1269   0BB7 FD 77         inc b
1270   0BB9 FA FD FF      lea d, [bp + -3] ; $format_p
1271   0BBC FD 43         mov [d], b
1272   0BBE FD 7D         dec b
1273   0BC0 0A E5 0B      jmp _if12_exit
1274   0BC3             _if12_else:
1275   0BC3             ; putchar(*format_p); 
1276   0BC3             ; --- START FUNCTION CALL
1277   0BC3 FA FD FF      lea d, [bp + -3] ; $format_p
1278   0BC6 2A            mov b, [d]
1279   0BC7 38 00 00      mov c, 0
1280   0BCA 74            mov d, b
1281   0BCB 32            mov bl, [d]
1282   0BCC A7 00         mov bh, 0
1283   0BCE DD            push bl
1284   0BCF 07 29 1C      call putchar
1285   0BD2 51 01 00      add sp, 1
1286   0BD5             ; --- END FUNCTION CALL
1287   0BD5             ; format_p++; 
1288   0BD5 FA FD FF      lea d, [bp + -3] ; $format_p
1289   0BD8 2A            mov b, [d]
1290   0BD9 38 00 00      mov c, 0
1291   0BDC FD 77         inc b
1292   0BDE FA FD FF      lea d, [bp + -3] ; $format_p
1293   0BE1 FD 43         mov [d], b
1294   0BE3 FD 7D         dec b
1295   0BE5             _if12_exit:
1296   0BE5             _if11_exit:
1297   0BE5             _for10_update:
1298   0BE5 0A 4E 09      jmp _for10_cond
1299   0BE8             _for10_exit:
1300   0BE8 F9            leave
1301   0BE9 09            ret
1302   0BEA             
1303   0BEA             scanf:
1304   0BEA F8 00 00      enter 0 ; (push bp; mov bp, sp)
1305   0BED             ; char *p, *format_p; 
1306   0BED 52 02 00      sub sp, 2
1307   0BF0 52 02 00      sub sp, 2
1308   0BF3             ; char c; 
1309   0BF3 52 01 00      sub sp, 1
1310   0BF6             ; int i; 
1311   0BF6 52 02 00      sub sp, 2
1312   0BF9             ; char input_string[  512                    ]; 
1313   0BF9 52 00 02      sub sp, 512
1314   0BFC             ; format_p = format; 
1315   0BFC FA FD FF      lea d, [bp + -3] ; $format_p
1316   0BFF DA            push d
1317   0C00 FA 05 00      lea d, [bp + 5] ; $format
1318   0C03 2A            mov b, [d]
1319   0C04 38 00 00      mov c, 0
1320   0C07 E7            pop d
1321   0C08 FD 43         mov [d], b
1322   0C0A             ; p = &format + 2; 
1323   0C0A FA FF FF      lea d, [bp + -1] ; $p
1324   0C0D DA            push d
1325   0C0E FA 05 00      lea d, [bp + 5] ; $format
1326   0C11 2D            mov b, d
1327   0C12             ; --- START TERMS
1328   0C12 D7            push a
1329   0C13 11            mov a, b
1330   0C14 FD 2E 02 00   mov32 cb, $00000002
1330   0C18 00 00 
1331   0C1A 56            add b, a
1332   0C1B E4            pop a
1333   0C1C             ; --- END TERMS
1334   0C1C E7            pop d
1335   0C1D FD 43         mov [d], b
1336   0C1F             ; for(;;){ 
1337   0C1F             _for17_init:
1338   0C1F             _for17_cond:
1339   0C1F             _for17_block:
1340   0C1F             ; if(!*format_p) break; 
1341   0C1F             _if18_cond:
1342   0C1F FA FD FF      lea d, [bp + -3] ; $format_p
1343   0C22 2A            mov b, [d]
1344   0C23 38 00 00      mov c, 0
1345   0C26 74            mov d, b
1346   0C27 32            mov bl, [d]
1347   0C28 A7 00         mov bh, 0
1348   0C2A C0 00 00      cmp b, 0
1349   0C2D FD 71         seq ; !
1350   0C2F C0 00 00      cmp b, 0
1351   0C32 C6 3B 0C      je _if18_else
1352   0C35             _if18_true:
1353   0C35             ; break; 
1354   0C35 0A AB 0E      jmp _for17_exit ; for break
1355   0C38 0A A8 0E      jmp _if18_exit
1356   0C3B             _if18_else:
1357   0C3B             ; if(*format_p == '%'){ 
1358   0C3B             _if19_cond:
1359   0C3B FA FD FF      lea d, [bp + -3] ; $format_p
1360   0C3E 2A            mov b, [d]
1361   0C3F 38 00 00      mov c, 0
1362   0C42 74            mov d, b
1363   0C43 32            mov bl, [d]
1364   0C44 A7 00         mov bh, 0
1365   0C46             ; --- START RELATIONAL
1366   0C46 D7            push a
1367   0C47 11            mov a, b
1368   0C48 FD 2E 25 00   mov32 cb, $00000025
1368   0C4C 00 00 
1369   0C4E B0            cmp a, b
1370   0C4F FD 71         seq ; ==
1371   0C51 E4            pop a
1372   0C52             ; --- END RELATIONAL
1373   0C52 C0 00 00      cmp b, 0
1374   0C55 C6 86 0E      je _if19_else
1375   0C58             _if19_true:
1376   0C58             ; format_p++; 
1377   0C58 FA FD FF      lea d, [bp + -3] ; $format_p
1378   0C5B 2A            mov b, [d]
1379   0C5C 38 00 00      mov c, 0
1380   0C5F FD 77         inc b
1381   0C61 FA FD FF      lea d, [bp + -3] ; $format_p
1382   0C64 FD 43         mov [d], b
1383   0C66 FD 7D         dec b
1384   0C68             ; switch(*format_p){ 
1385   0C68             _switch20_expr:
1386   0C68 FA FD FF      lea d, [bp + -3] ; $format_p
1387   0C6B 2A            mov b, [d]
1388   0C6C 38 00 00      mov c, 0
1389   0C6F 74            mov d, b
1390   0C70 32            mov bl, [d]
1391   0C71 A7 00         mov bh, 0
1392   0C73             _switch20_comparisons:
1393   0C73 C1 6C         cmp bl, $6c
1394   0C75 C6 A1 0C      je _switch20_case0
1395   0C78 C1 4C         cmp bl, $4c
1396   0C7A C6 A1 0C      je _switch20_case1
1397   0C7D C1 64         cmp bl, $64
1398   0C7F C6 54 0D      je _switch20_case2
1399   0C82 C1 69         cmp bl, $69
1400   0C84 C6 54 0D      je _switch20_case3
1401   0C87 C1 75         cmp bl, $75
1402   0C89 C6 8D 0D      je _switch20_case4
1403   0C8C C1 78         cmp bl, $78
1404   0C8E C6 C6 0D      je _switch20_case5
1405   0C91 C1 63         cmp bl, $63
1406   0C93 C6 E1 0D      je _switch20_case6
1407   0C96 C1 73         cmp bl, $73
1408   0C98 C6 20 0E      je _switch20_case7
1409   0C9B 0A 67 0E      jmp _switch20_default
1410   0C9E 0A 73 0E      jmp _switch20_exit
1411   0CA1             _switch20_case0:
1412   0CA1             _switch20_case1:
1413   0CA1             ; format_p++; 
1414   0CA1 FA FD FF      lea d, [bp + -3] ; $format_p
1415   0CA4 2A            mov b, [d]
1416   0CA5 38 00 00      mov c, 0
1417   0CA8 FD 77         inc b
1418   0CAA FA FD FF      lea d, [bp + -3] ; $format_p
1419   0CAD FD 43         mov [d], b
1420   0CAF FD 7D         dec b
1421   0CB1             ; if(*format_p == 'd' || *format_p == 'i'); 
1422   0CB1             _if21_cond:
1423   0CB1 FA FD FF      lea d, [bp + -3] ; $format_p
1424   0CB4 2A            mov b, [d]
1425   0CB5 38 00 00      mov c, 0
1426   0CB8 74            mov d, b
1427   0CB9 32            mov bl, [d]
1428   0CBA A7 00         mov bh, 0
1429   0CBC             ; --- START RELATIONAL
1430   0CBC D7            push a
1431   0CBD 11            mov a, b
1432   0CBE FD 2E 64 00   mov32 cb, $00000064
1432   0CC2 00 00 
1433   0CC4 B0            cmp a, b
1434   0CC5 FD 71         seq ; ==
1435   0CC7 E4            pop a
1436   0CC8             ; --- END RELATIONAL
1437   0CC8             ; --- START LOGICAL OR
1438   0CC8 D7            push a
1439   0CC9 11            mov a, b
1440   0CCA FA FD FF      lea d, [bp + -3] ; $format_p
1441   0CCD 2A            mov b, [d]
1442   0CCE 38 00 00      mov c, 0
1443   0CD1 74            mov d, b
1444   0CD2 32            mov bl, [d]
1445   0CD3 A7 00         mov bh, 0
1446   0CD5             ; --- START RELATIONAL
1447   0CD5 D7            push a
1448   0CD6 11            mov a, b
1449   0CD7 FD 2E 69 00   mov32 cb, $00000069
1449   0CDB 00 00 
1450   0CDD B0            cmp a, b
1451   0CDE FD 71         seq ; ==
1452   0CE0 E4            pop a
1453   0CE1             ; --- END RELATIONAL
1454   0CE1 FD A8         sor a, b ; ||
1455   0CE3 E4            pop a
1456   0CE4             ; --- END LOGICAL OR
1457   0CE4 C0 00 00      cmp b, 0
1458   0CE7 C6 ED 0C      je _if21_else
1459   0CEA             _if21_true:
1460   0CEA             ; ; 
1461   0CEA 0A 39 0D      jmp _if21_exit
1462   0CED             _if21_else:
1463   0CED             ; if(*format_p == 'u'); 
1464   0CED             _if22_cond:
1465   0CED FA FD FF      lea d, [bp + -3] ; $format_p
1466   0CF0 2A            mov b, [d]
1467   0CF1 38 00 00      mov c, 0
1468   0CF4 74            mov d, b
1469   0CF5 32            mov bl, [d]
1470   0CF6 A7 00         mov bh, 0
1471   0CF8             ; --- START RELATIONAL
1472   0CF8 D7            push a
1473   0CF9 11            mov a, b
1474   0CFA FD 2E 75 00   mov32 cb, $00000075
1474   0CFE 00 00 
1475   0D00 B0            cmp a, b
1476   0D01 FD 71         seq ; ==
1477   0D03 E4            pop a
1478   0D04             ; --- END RELATIONAL
1479   0D04 C0 00 00      cmp b, 0
1480   0D07 C6 0D 0D      je _if22_else
1481   0D0A             _if22_true:
1482   0D0A             ; ; 
1483   0D0A 0A 39 0D      jmp _if22_exit
1484   0D0D             _if22_else:
1485   0D0D             ; if(*format_p == 'x'); 
1486   0D0D             _if23_cond:
1487   0D0D FA FD FF      lea d, [bp + -3] ; $format_p
1488   0D10 2A            mov b, [d]
1489   0D11 38 00 00      mov c, 0
1490   0D14 74            mov d, b
1491   0D15 32            mov bl, [d]
1492   0D16 A7 00         mov bh, 0
1493   0D18             ; --- START RELATIONAL
1494   0D18 D7            push a
1495   0D19 11            mov a, b
1496   0D1A FD 2E 78 00   mov32 cb, $00000078
1496   0D1E 00 00 
1497   0D20 B0            cmp a, b
1498   0D21 FD 71         seq ; ==
1499   0D23 E4            pop a
1500   0D24             ; --- END RELATIONAL
1501   0D24 C0 00 00      cmp b, 0
1502   0D27 C6 2D 0D      je _if23_else
1503   0D2A             _if23_true:
1504   0D2A             ; ; 
1505   0D2A 0A 39 0D      jmp _if23_exit
1506   0D2D             _if23_else:
1507   0D2D             ; err("Unexpected format in printf."); 
1508   0D2D             ; --- START FUNCTION CALL
1509   0D2D 26 DC 20      mov b, _s0 ; "Unexpected format in printf."
1510   0D30 FD AB         swp b
1511   0D32 D8            push b
1512   0D33 07 44 12      call err
1513   0D36 51 02 00      add sp, 2
1514   0D39             ; --- END FUNCTION CALL
1515   0D39             _if23_exit:
1516   0D39             _if22_exit:
1517   0D39             _if21_exit:
1518   0D39             ; p = p + 4; 
1519   0D39 FA FF FF      lea d, [bp + -1] ; $p
1520   0D3C DA            push d
1521   0D3D FA FF FF      lea d, [bp + -1] ; $p
1522   0D40 2A            mov b, [d]
1523   0D41 38 00 00      mov c, 0
1524   0D44             ; --- START TERMS
1525   0D44 D7            push a
1526   0D45 11            mov a, b
1527   0D46 FD 2E 04 00   mov32 cb, $00000004
1527   0D4A 00 00 
1528   0D4C 56            add b, a
1529   0D4D E4            pop a
1530   0D4E             ; --- END TERMS
1531   0D4E E7            pop d
1532   0D4F FD 43         mov [d], b
1533   0D51             ; break; 
1534   0D51 0A 73 0E      jmp _switch20_exit ; case break
1535   0D54             _switch20_case2:
1536   0D54             _switch20_case3:
1537   0D54             ; i = scann(); 
1538   0D54 FA FA FF      lea d, [bp + -6] ; $i
1539   0D57 DA            push d
1540   0D58             ; --- START FUNCTION CALL
1541   0D58 07 4F 1C      call scann
1542   0D5B E7            pop d
1543   0D5C FD 43         mov [d], b
1544   0D5E             ; **(int **)p = i; 
1545   0D5E FA FF FF      lea d, [bp + -1] ; $p
1546   0D61 2A            mov b, [d]
1547   0D62 38 00 00      mov c, 0
1548   0D65 74            mov d, b
1549   0D66 2A            mov b, [d]
1550   0D67 D8            push b
1551   0D68 FA FA FF      lea d, [bp + -6] ; $i
1552   0D6B 2A            mov b, [d]
1553   0D6C 38 00 00      mov c, 0
1554   0D6F E7            pop d
1555   0D70 FD 43         mov [d], b
1556   0D72             ; p = p + 2; 
1557   0D72 FA FF FF      lea d, [bp + -1] ; $p
1558   0D75 DA            push d
1559   0D76 FA FF FF      lea d, [bp + -1] ; $p
1560   0D79 2A            mov b, [d]
1561   0D7A 38 00 00      mov c, 0
1562   0D7D             ; --- START TERMS
1563   0D7D D7            push a
1564   0D7E 11            mov a, b
1565   0D7F FD 2E 02 00   mov32 cb, $00000002
1565   0D83 00 00 
1566   0D85 56            add b, a
1567   0D86 E4            pop a
1568   0D87             ; --- END TERMS
1569   0D87 E7            pop d
1570   0D88 FD 43         mov [d], b
1571   0D8A             ; break; 
1572   0D8A 0A 73 0E      jmp _switch20_exit ; case break
1573   0D8D             _switch20_case4:
1574   0D8D             ; i = scann(); 
1575   0D8D FA FA FF      lea d, [bp + -6] ; $i
1576   0D90 DA            push d
1577   0D91             ; --- START FUNCTION CALL
1578   0D91 07 4F 1C      call scann
1579   0D94 E7            pop d
1580   0D95 FD 43         mov [d], b
1581   0D97             ; **(int **)p = i; 
1582   0D97 FA FF FF      lea d, [bp + -1] ; $p
1583   0D9A 2A            mov b, [d]
1584   0D9B 38 00 00      mov c, 0
1585   0D9E 74            mov d, b
1586   0D9F 2A            mov b, [d]
1587   0DA0 D8            push b
1588   0DA1 FA FA FF      lea d, [bp + -6] ; $i
1589   0DA4 2A            mov b, [d]
1590   0DA5 38 00 00      mov c, 0
1591   0DA8 E7            pop d
1592   0DA9 FD 43         mov [d], b
1593   0DAB             ; p = p + 2; 
1594   0DAB FA FF FF      lea d, [bp + -1] ; $p
1595   0DAE DA            push d
1596   0DAF FA FF FF      lea d, [bp + -1] ; $p
1597   0DB2 2A            mov b, [d]
1598   0DB3 38 00 00      mov c, 0
1599   0DB6             ; --- START TERMS
1600   0DB6 D7            push a
1601   0DB7 11            mov a, b
1602   0DB8 FD 2E 02 00   mov32 cb, $00000002
1602   0DBC 00 00 
1603   0DBE 56            add b, a
1604   0DBF E4            pop a
1605   0DC0             ; --- END TERMS
1606   0DC0 E7            pop d
1607   0DC1 FD 43         mov [d], b
1608   0DC3             ; break; 
1609   0DC3 0A 73 0E      jmp _switch20_exit ; case break
1610   0DC6             _switch20_case5:
1611   0DC6             ; p = p + 2; 
1612   0DC6 FA FF FF      lea d, [bp + -1] ; $p
1613   0DC9 DA            push d
1614   0DCA FA FF FF      lea d, [bp + -1] ; $p
1615   0DCD 2A            mov b, [d]
1616   0DCE 38 00 00      mov c, 0
1617   0DD1             ; --- START TERMS
1618   0DD1 D7            push a
1619   0DD2 11            mov a, b
1620   0DD3 FD 2E 02 00   mov32 cb, $00000002
1620   0DD7 00 00 
1621   0DD9 56            add b, a
1622   0DDA E4            pop a
1623   0DDB             ; --- END TERMS
1624   0DDB E7            pop d
1625   0DDC FD 43         mov [d], b
1626   0DDE             ; break; 
1627   0DDE 0A 73 0E      jmp _switch20_exit ; case break
1628   0DE1             _switch20_case6:
1629   0DE1             ; c = getchar(); 
1630   0DE1 FA FC FF      lea d, [bp + -4] ; $c
1631   0DE4 DA            push d
1632   0DE5             ; --- START FUNCTION CALL
1633   0DE5 07 36 1C      call getchar
1634   0DE8 E7            pop d
1635   0DE9 FD 3E         mov [d], bl
1636   0DEB             ; **(char **)p = *(char *)c; 
1637   0DEB FA FF FF      lea d, [bp + -1] ; $p
1638   0DEE 2A            mov b, [d]
1639   0DEF 38 00 00      mov c, 0
1640   0DF2 74            mov d, b
1641   0DF3 2A            mov b, [d]
1642   0DF4 D8            push b
1643   0DF5 FA FC FF      lea d, [bp + -4] ; $c
1644   0DF8 32            mov bl, [d]
1645   0DF9 A7 00         mov bh, 0
1646   0DFB 38 00 00      mov c, 0
1647   0DFE 74            mov d, b
1648   0DFF 32            mov bl, [d]
1649   0E00 A7 00         mov bh, 0
1650   0E02 E7            pop d
1651   0E03 FD 43         mov [d], b
1652   0E05             ; p = p + 1; 
1653   0E05 FA FF FF      lea d, [bp + -1] ; $p
1654   0E08 DA            push d
1655   0E09 FA FF FF      lea d, [bp + -1] ; $p
1656   0E0C 2A            mov b, [d]
1657   0E0D 38 00 00      mov c, 0
1658   0E10             ; --- START TERMS
1659   0E10 D7            push a
1660   0E11 11            mov a, b
1661   0E12 FD 2E 01 00   mov32 cb, $00000001
1661   0E16 00 00 
1662   0E18 56            add b, a
1663   0E19 E4            pop a
1664   0E1A             ; --- END TERMS
1665   0E1A E7            pop d
1666   0E1B FD 43         mov [d], b
1667   0E1D             ; break; 
1668   0E1D 0A 73 0E      jmp _switch20_exit ; case break
1669   0E20             _switch20_case7:
1670   0E20             ; gets(input_string); 
1671   0E20             ; --- START FUNCTION CALL
1672   0E20 FA FA FD      lea d, [bp + -518] ; $input_string
1673   0E23 2D            mov b, d
1674   0E24 38 00 00      mov c, 0
1675   0E27 FD AB         swp b
1676   0E29 D8            push b
1677   0E2A 07 30 14      call gets
1678   0E2D 51 02 00      add sp, 2
1679   0E30             ; --- END FUNCTION CALL
1680   0E30             ; strcpy(*(char **)p, input_string); 
1681   0E30             ; --- START FUNCTION CALL
1682   0E30 FA FA FD      lea d, [bp + -518] ; $input_string
1683   0E33 2D            mov b, d
1684   0E34 38 00 00      mov c, 0
1685   0E37 FD AB         swp b
1686   0E39 D8            push b
1687   0E3A FA FF FF      lea d, [bp + -1] ; $p
1688   0E3D 2A            mov b, [d]
1689   0E3E 38 00 00      mov c, 0
1690   0E41 74            mov d, b
1691   0E42 2A            mov b, [d]
1692   0E43 FD AB         swp b
1693   0E45 D8            push b
1694   0E46 07 21 04      call strcpy
1695   0E49 51 04 00      add sp, 4
1696   0E4C             ; --- END FUNCTION CALL
1697   0E4C             ; p = p + 2; 
1698   0E4C FA FF FF      lea d, [bp + -1] ; $p
1699   0E4F DA            push d
1700   0E50 FA FF FF      lea d, [bp + -1] ; $p
1701   0E53 2A            mov b, [d]
1702   0E54 38 00 00      mov c, 0
1703   0E57             ; --- START TERMS
1704   0E57 D7            push a
1705   0E58 11            mov a, b
1706   0E59 FD 2E 02 00   mov32 cb, $00000002
1706   0E5D 00 00 
1707   0E5F 56            add b, a
1708   0E60 E4            pop a
1709   0E61             ; --- END TERMS
1710   0E61 E7            pop d
1711   0E62 FD 43         mov [d], b
1712   0E64             ; break; 
1713   0E64 0A 73 0E      jmp _switch20_exit ; case break
1714   0E67             _switch20_default:
1715   0E67             ; print("Error: Unknown argument type.\n"); 
1716   0E67             ; --- START FUNCTION CALL
1717   0E67 26 F9 20      mov b, _s1 ; "Error: Unknown argument type.\n"
1718   0E6A FD AB         swp b
1719   0E6C D8            push b
1720   0E6D 07 77 1C      call print
1721   0E70 51 02 00      add sp, 2
1722   0E73             ; --- END FUNCTION CALL
1723   0E73             _switch20_exit:
1724   0E73             ; format_p++; 
1725   0E73 FA FD FF      lea d, [bp + -3] ; $format_p
1726   0E76 2A            mov b, [d]
1727   0E77 38 00 00      mov c, 0
1728   0E7A FD 77         inc b
1729   0E7C FA FD FF      lea d, [bp + -3] ; $format_p
1730   0E7F FD 43         mov [d], b
1731   0E81 FD 7D         dec b
1732   0E83 0A A8 0E      jmp _if19_exit
1733   0E86             _if19_else:
1734   0E86             ; putchar(*format_p); 
1735   0E86             ; --- START FUNCTION CALL
1736   0E86 FA FD FF      lea d, [bp + -3] ; $format_p
1737   0E89 2A            mov b, [d]
1738   0E8A 38 00 00      mov c, 0
1739   0E8D 74            mov d, b
1740   0E8E 32            mov bl, [d]
1741   0E8F A7 00         mov bh, 0
1742   0E91 DD            push bl
1743   0E92 07 29 1C      call putchar
1744   0E95 51 01 00      add sp, 1
1745   0E98             ; --- END FUNCTION CALL
1746   0E98             ; format_p++; 
1747   0E98 FA FD FF      lea d, [bp + -3] ; $format_p
1748   0E9B 2A            mov b, [d]
1749   0E9C 38 00 00      mov c, 0
1750   0E9F FD 77         inc b
1751   0EA1 FA FD FF      lea d, [bp + -3] ; $format_p
1752   0EA4 FD 43         mov [d], b
1753   0EA6 FD 7D         dec b
1754   0EA8             _if19_exit:
1755   0EA8             _if18_exit:
1756   0EA8             _for17_update:
1757   0EA8 0A 1F 0C      jmp _for17_cond
1758   0EAB             _for17_exit:
1759   0EAB F9            leave
1760   0EAC 09            ret
1761   0EAD             
1762   0EAD             sprintf:
1763   0EAD F8 00 00      enter 0 ; (push bp; mov bp, sp)
1764   0EB0             ; char *p, *format_p; 
1765   0EB0 52 02 00      sub sp, 2
1766   0EB3 52 02 00      sub sp, 2
1767   0EB6             ; char *sp; 
1768   0EB6 52 02 00      sub sp, 2
1769   0EB9             ; sp = dest; 
1770   0EB9 FA FB FF      lea d, [bp + -5] ; $sp
1771   0EBC DA            push d
1772   0EBD FA 05 00      lea d, [bp + 5] ; $dest
1773   0EC0 2A            mov b, [d]
1774   0EC1 38 00 00      mov c, 0
1775   0EC4 E7            pop d
1776   0EC5 FD 43         mov [d], b
1777   0EC7             ; format_p = format; 
1778   0EC7 FA FD FF      lea d, [bp + -3] ; $format_p
1779   0ECA DA            push d
1780   0ECB FA 07 00      lea d, [bp + 7] ; $format
1781   0ECE 2A            mov b, [d]
1782   0ECF 38 00 00      mov c, 0
1783   0ED2 E7            pop d
1784   0ED3 FD 43         mov [d], b
1785   0ED5             ; p = &format + 2; 
1786   0ED5 FA FF FF      lea d, [bp + -1] ; $p
1787   0ED8 DA            push d
1788   0ED9 FA 07 00      lea d, [bp + 7] ; $format
1789   0EDC 2D            mov b, d
1790   0EDD             ; --- START TERMS
1791   0EDD D7            push a
1792   0EDE 11            mov a, b
1793   0EDF FD 2E 02 00   mov32 cb, $00000002
1793   0EE3 00 00 
1794   0EE5 56            add b, a
1795   0EE6 E4            pop a
1796   0EE7             ; --- END TERMS
1797   0EE7 E7            pop d
1798   0EE8 FD 43         mov [d], b
1799   0EEA             ; for(;;){ 
1800   0EEA             _for24_init:
1801   0EEA             _for24_cond:
1802   0EEA             _for24_block:
1803   0EEA             ; if(!*format_p) break; 
1804   0EEA             _if25_cond:
1805   0EEA FA FD FF      lea d, [bp + -3] ; $format_p
1806   0EED 2A            mov b, [d]
1807   0EEE 38 00 00      mov c, 0
1808   0EF1 74            mov d, b
1809   0EF2 32            mov bl, [d]
1810   0EF3 A7 00         mov bh, 0
1811   0EF5 C0 00 00      cmp b, 0
1812   0EF8 FD 71         seq ; !
1813   0EFA C0 00 00      cmp b, 0
1814   0EFD C6 06 0F      je _if25_else
1815   0F00             _if25_true:
1816   0F00             ; break; 
1817   0F00 0A 1E 12      jmp _for24_exit ; for break
1818   0F03 0A 1B 12      jmp _if25_exit
1819   0F06             _if25_else:
1820   0F06             ; if(*format_p == '%'){ 
1821   0F06             _if26_cond:
1822   0F06 FA FD FF      lea d, [bp + -3] ; $format_p
1823   0F09 2A            mov b, [d]
1824   0F0A 38 00 00      mov c, 0
1825   0F0D 74            mov d, b
1826   0F0E 32            mov bl, [d]
1827   0F0F A7 00         mov bh, 0
1828   0F11             ; --- START RELATIONAL
1829   0F11 D7            push a
1830   0F12 11            mov a, b
1831   0F13 FD 2E 25 00   mov32 cb, $00000025
1831   0F17 00 00 
1832   0F19 B0            cmp a, b
1833   0F1A FD 71         seq ; ==
1834   0F1C E4            pop a
1835   0F1D             ; --- END RELATIONAL
1836   0F1D C0 00 00      cmp b, 0
1837   0F20 C6 F3 11      je _if26_else
1838   0F23             _if26_true:
1839   0F23             ; format_p++; 
1840   0F23 FA FD FF      lea d, [bp + -3] ; $format_p
1841   0F26 2A            mov b, [d]
1842   0F27 38 00 00      mov c, 0
1843   0F2A FD 77         inc b
1844   0F2C FA FD FF      lea d, [bp + -3] ; $format_p
1845   0F2F FD 43         mov [d], b
1846   0F31 FD 7D         dec b
1847   0F33             ; switch(*format_p){ 
1848   0F33             _switch27_expr:
1849   0F33 FA FD FF      lea d, [bp + -3] ; $format_p
1850   0F36 2A            mov b, [d]
1851   0F37 38 00 00      mov c, 0
1852   0F3A 74            mov d, b
1853   0F3B 32            mov bl, [d]
1854   0F3C A7 00         mov bh, 0
1855   0F3E             _switch27_comparisons:
1856   0F3E C1 6C         cmp bl, $6c
1857   0F40 C6 6C 0F      je _switch27_case0
1858   0F43 C1 4C         cmp bl, $4c
1859   0F45 C6 6C 0F      je _switch27_case1
1860   0F48 C1 64         cmp bl, $64
1861   0F4A C6 78 10      je _switch27_case2
1862   0F4D C1 69         cmp bl, $69
1863   0F4F C6 78 10      je _switch27_case3
1864   0F52 C1 75         cmp bl, $75
1865   0F54 C6 C1 10      je _switch27_case4
1866   0F57 C1 78         cmp bl, $78
1867   0F59 C6 0A 11      je _switch27_case5
1868   0F5C C1 63         cmp bl, $63
1869   0F5E C6 2E 11      je _switch27_case6
1870   0F61 C1 73         cmp bl, $73
1871   0F63 C6 68 11      je _switch27_case7
1872   0F66 0A D4 11      jmp _switch27_default
1873   0F69 0A E0 11      jmp _switch27_exit
1874   0F6C             _switch27_case0:
1875   0F6C             _switch27_case1:
1876   0F6C             ; format_p++; 
1877   0F6C FA FD FF      lea d, [bp + -3] ; $format_p
1878   0F6F 2A            mov b, [d]
1879   0F70 38 00 00      mov c, 0
1880   0F73 FD 77         inc b
1881   0F75 FA FD FF      lea d, [bp + -3] ; $format_p
1882   0F78 FD 43         mov [d], b
1883   0F7A FD 7D         dec b
1884   0F7C             ; if(*format_p == 'd' || *format_p == 'i') 
1885   0F7C             _if28_cond:
1886   0F7C FA FD FF      lea d, [bp + -3] ; $format_p
1887   0F7F 2A            mov b, [d]
1888   0F80 38 00 00      mov c, 0
1889   0F83 74            mov d, b
1890   0F84 32            mov bl, [d]
1891   0F85 A7 00         mov bh, 0
1892   0F87             ; --- START RELATIONAL
1893   0F87 D7            push a
1894   0F88 11            mov a, b
1895   0F89 FD 2E 64 00   mov32 cb, $00000064
1895   0F8D 00 00 
1896   0F8F B0            cmp a, b
1897   0F90 FD 71         seq ; ==
1898   0F92 E4            pop a
1899   0F93             ; --- END RELATIONAL
1900   0F93             ; --- START LOGICAL OR
1901   0F93 D7            push a
1902   0F94 11            mov a, b
1903   0F95 FA FD FF      lea d, [bp + -3] ; $format_p
1904   0F98 2A            mov b, [d]
1905   0F99 38 00 00      mov c, 0
1906   0F9C 74            mov d, b
1907   0F9D 32            mov bl, [d]
1908   0F9E A7 00         mov bh, 0
1909   0FA0             ; --- START RELATIONAL
1910   0FA0 D7            push a
1911   0FA1 11            mov a, b
1912   0FA2 FD 2E 69 00   mov32 cb, $00000069
1912   0FA6 00 00 
1913   0FA8 B0            cmp a, b
1914   0FA9 FD 71         seq ; ==
1915   0FAB E4            pop a
1916   0FAC             ; --- END RELATIONAL
1917   0FAC FD A8         sor a, b ; ||
1918   0FAE E4            pop a
1919   0FAF             ; --- END LOGICAL OR
1920   0FAF C0 00 00      cmp b, 0
1921   0FB2 C6 D6 0F      je _if28_else
1922   0FB5             _if28_true:
1923   0FB5             ; print_signed_long(*(long *)p); 
1924   0FB5             ; --- START FUNCTION CALL
1925   0FB5 FA FF FF      lea d, [bp + -1] ; $p
1926   0FB8 2A            mov b, [d]
1927   0FB9 38 00 00      mov c, 0
1928   0FBC AB            snex b
1929   0FBD FD 39         mov c, b
1930   0FBF 74            mov d, b
1931   0FC0 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1932   0FC3 FD 39         mov c, b ; And place it into C
1933   0FC5 2A            mov b, [d] ; Lower Word in B
1934   0FC6 12            mov a, c
1935   0FC7 FD AA         swp a
1936   0FC9 D7            push a
1937   0FCA FD AB         swp b
1938   0FCC D8            push b
1939   0FCD 07 86 15      call print_signed_long
1940   0FD0 51 04 00      add sp, 4
1941   0FD3             ; --- END FUNCTION CALL
1942   0FD3 0A 5D 10      jmp _if28_exit
1943   0FD6             _if28_else:
1944   0FD6             ; if(*format_p == 'u') 
1945   0FD6             _if29_cond:
1946   0FD6 FA FD FF      lea d, [bp + -3] ; $format_p
1947   0FD9 2A            mov b, [d]
1948   0FDA 38 00 00      mov c, 0
1949   0FDD 74            mov d, b
1950   0FDE 32            mov bl, [d]
1951   0FDF A7 00         mov bh, 0
1952   0FE1             ; --- START RELATIONAL
1953   0FE1 D7            push a
1954   0FE2 11            mov a, b
1955   0FE3 FD 2E 75 00   mov32 cb, $00000075
1955   0FE7 00 00 
1956   0FE9 B0            cmp a, b
1957   0FEA FD 71         seq ; ==
1958   0FEC E4            pop a
1959   0FED             ; --- END RELATIONAL
1960   0FED C0 00 00      cmp b, 0
1961   0FF0 C6 16 10      je _if29_else
1962   0FF3             _if29_true:
1963   0FF3             ; print_unsigned_long(*(unsigned long *)p); 
1964   0FF3             ; --- START FUNCTION CALL
1965   0FF3 FA FF FF      lea d, [bp + -1] ; $p
1966   0FF6 2A            mov b, [d]
1967   0FF7 38 00 00      mov c, 0
1968   0FFA A7 00         mov bh, 0
1969   0FFC 38 00 00      mov c, 0
1970   0FFF 74            mov d, b
1971   1000 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1972   1003 FD 39         mov c, b ; And place it into C
1973   1005 2A            mov b, [d] ; Lower Word in B
1974   1006 12            mov a, c
1975   1007 FD AA         swp a
1976   1009 D7            push a
1977   100A FD AB         swp b
1978   100C D8            push b
1979   100D 07 ED 16      call print_unsigned_long
1980   1010 51 04 00      add sp, 4
1981   1013             ; --- END FUNCTION CALL
1982   1013 0A 5D 10      jmp _if29_exit
1983   1016             _if29_else:
1984   1016             ; if(*format_p == 'x') 
1985   1016             _if30_cond:
1986   1016 FA FD FF      lea d, [bp + -3] ; $format_p
1987   1019 2A            mov b, [d]
1988   101A 38 00 00      mov c, 0
1989   101D 74            mov d, b
1990   101E 32            mov bl, [d]
1991   101F A7 00         mov bh, 0
1992   1021             ; --- START RELATIONAL
1993   1021 D7            push a
1994   1022 11            mov a, b
1995   1023 FD 2E 78 00   mov32 cb, $00000078
1995   1027 00 00 
1996   1029 B0            cmp a, b
1997   102A FD 71         seq ; ==
1998   102C E4            pop a
1999   102D             ; --- END RELATIONAL
2000   102D C0 00 00      cmp b, 0
2001   1030 C6 51 10      je _if30_else
2002   1033             _if30_true:
2003   1033             ; printx32(*(long int *)p); 
2004   1033             ; --- START FUNCTION CALL
2005   1033 FA FF FF      lea d, [bp + -1] ; $p
2006   1036 2A            mov b, [d]
2007   1037 38 00 00      mov c, 0
2008   103A 74            mov d, b
2009   103B 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2010   103E FD 39         mov c, b ; And place it into C
2011   1040 2A            mov b, [d] ; Lower Word in B
2012   1041 12            mov a, c
2013   1042 FD AA         swp a
2014   1044 D7            push a
2015   1045 FD AB         swp b
2016   1047 D8            push b
2017   1048 07 59 12      call printx32
2018   104B 51 04 00      add sp, 4
2019   104E             ; --- END FUNCTION CALL
2020   104E 0A 5D 10      jmp _if30_exit
2021   1051             _if30_else:
2022   1051             ; err("Unexpected format in printf."); 
2023   1051             ; --- START FUNCTION CALL
2024   1051 26 DC 20      mov b, _s0 ; "Unexpected format in printf."
2025   1054 FD AB         swp b
2026   1056 D8            push b
2027   1057 07 44 12      call err
2028   105A 51 02 00      add sp, 2
2029   105D             ; --- END FUNCTION CALL
2030   105D             _if30_exit:
2031   105D             _if29_exit:
2032   105D             _if28_exit:
2033   105D             ; p = p + 4; 
2034   105D FA FF FF      lea d, [bp + -1] ; $p
2035   1060 DA            push d
2036   1061 FA FF FF      lea d, [bp + -1] ; $p
2037   1064 2A            mov b, [d]
2038   1065 38 00 00      mov c, 0
2039   1068             ; --- START TERMS
2040   1068 D7            push a
2041   1069 11            mov a, b
2042   106A FD 2E 04 00   mov32 cb, $00000004
2042   106E 00 00 
2043   1070 56            add b, a
2044   1071 E4            pop a
2045   1072             ; --- END TERMS
2046   1072 E7            pop d
2047   1073 FD 43         mov [d], b
2048   1075             ; break; 
2049   1075 0A E0 11      jmp _switch27_exit ; case break
2050   1078             _switch27_case2:
2051   1078             _switch27_case3:
2052   1078             ; sp = sp + sprint_signed(sp, *(int*)p); 
2053   1078 FA FB FF      lea d, [bp + -5] ; $sp
2054   107B DA            push d
2055   107C FA FB FF      lea d, [bp + -5] ; $sp
2056   107F 2A            mov b, [d]
2057   1080 38 00 00      mov c, 0
2058   1083             ; --- START TERMS
2059   1083 D7            push a
2060   1084 11            mov a, b
2061   1085             ; --- START FUNCTION CALL
2062   1085 FA FF FF      lea d, [bp + -1] ; $p
2063   1088 2A            mov b, [d]
2064   1089 38 00 00      mov c, 0
2065   108C 74            mov d, b
2066   108D 2A            mov b, [d]
2067   108E FD AB         swp b
2068   1090 D8            push b
2069   1091 FA FB FF      lea d, [bp + -5] ; $sp
2070   1094 2A            mov b, [d]
2071   1095 38 00 00      mov c, 0
2072   1098 FD AB         swp b
2073   109A D8            push b
2074   109B 07 61 1A      call sprint_signed
2075   109E 51 04 00      add sp, 4
2076   10A1             ; --- END FUNCTION CALL
2077   10A1 56            add b, a
2078   10A2 E4            pop a
2079   10A3             ; --- END TERMS
2080   10A3 E7            pop d
2081   10A4 FD 43         mov [d], b
2082   10A6             ; p = p + 2; 
2083   10A6 FA FF FF      lea d, [bp + -1] ; $p
2084   10A9 DA            push d
2085   10AA FA FF FF      lea d, [bp + -1] ; $p
2086   10AD 2A            mov b, [d]
2087   10AE 38 00 00      mov c, 0
2088   10B1             ; --- START TERMS
2089   10B1 D7            push a
2090   10B2 11            mov a, b
2091   10B3 FD 2E 02 00   mov32 cb, $00000002
2091   10B7 00 00 
2092   10B9 56            add b, a
2093   10BA E4            pop a
2094   10BB             ; --- END TERMS
2095   10BB E7            pop d
2096   10BC FD 43         mov [d], b
2097   10BE             ; break; 
2098   10BE 0A E0 11      jmp _switch27_exit ; case break
2099   10C1             _switch27_case4:
2100   10C1             ; sp = sp + sprint_unsigned(sp, *(unsigned int*)p); 
2101   10C1 FA FB FF      lea d, [bp + -5] ; $sp
2102   10C4 DA            push d
2103   10C5 FA FB FF      lea d, [bp + -5] ; $sp
2104   10C8 2A            mov b, [d]
2105   10C9 38 00 00      mov c, 0
2106   10CC             ; --- START TERMS
2107   10CC D7            push a
2108   10CD 11            mov a, b
2109   10CE             ; --- START FUNCTION CALL
2110   10CE FA FF FF      lea d, [bp + -1] ; $p
2111   10D1 2A            mov b, [d]
2112   10D2 38 00 00      mov c, 0
2113   10D5 74            mov d, b
2114   10D6 2A            mov b, [d]
2115   10D7 FD AB         swp b
2116   10D9 D8            push b
2117   10DA FA FB FF      lea d, [bp + -5] ; $sp
2118   10DD 2A            mov b, [d]
2119   10DE 38 00 00      mov c, 0
2120   10E1 FD AB         swp b
2121   10E3 D8            push b
2122   10E4 07 09 18      call sprint_unsigned
2123   10E7 51 04 00      add sp, 4
2124   10EA             ; --- END FUNCTION CALL
2125   10EA 56            add b, a
2126   10EB E4            pop a
2127   10EC             ; --- END TERMS
2128   10EC E7            pop d
2129   10ED FD 43         mov [d], b
2130   10EF             ; p = p + 2; 
2131   10EF FA FF FF      lea d, [bp + -1] ; $p
2132   10F2 DA            push d
2133   10F3 FA FF FF      lea d, [bp + -1] ; $p
2134   10F6 2A            mov b, [d]
2135   10F7 38 00 00      mov c, 0
2136   10FA             ; --- START TERMS
2137   10FA D7            push a
2138   10FB 11            mov a, b
2139   10FC FD 2E 02 00   mov32 cb, $00000002
2139   1100 00 00 
2140   1102 56            add b, a
2141   1103 E4            pop a
2142   1104             ; --- END TERMS
2143   1104 E7            pop d
2144   1105 FD 43         mov [d], b
2145   1107             ; break; 
2146   1107 0A E0 11      jmp _switch27_exit ; case break
2147   110A             _switch27_case5:
2148   110A             
2149   110A             ; --- BEGIN INLINE ASM SEGMENT
2150   110A FA FF FF      lea d, [bp + -1] ; $p
2151   110D FD 2A         mov d, [d]
2152   110F 2A            mov b, [d]
2153   1110 07 DA 1F      call print_u16x
2154   1113             ; --- END INLINE ASM SEGMENT
2155   1113             
2156   1113             ; p = p + 2; 
2157   1113 FA FF FF      lea d, [bp + -1] ; $p
2158   1116 DA            push d
2159   1117 FA FF FF      lea d, [bp + -1] ; $p
2160   111A 2A            mov b, [d]
2161   111B 38 00 00      mov c, 0
2162   111E             ; --- START TERMS
2163   111E D7            push a
2164   111F 11            mov a, b
2165   1120 FD 2E 02 00   mov32 cb, $00000002
2165   1124 00 00 
2166   1126 56            add b, a
2167   1127 E4            pop a
2168   1128             ; --- END TERMS
2169   1128 E7            pop d
2170   1129 FD 43         mov [d], b
2171   112B             ; break; 
2172   112B 0A E0 11      jmp _switch27_exit ; case break
2173   112E             _switch27_case6:
2174   112E             ; *sp++ = *(char *)p; 
2175   112E FA FB FF      lea d, [bp + -5] ; $sp
2176   1131 2A            mov b, [d]
2177   1132 38 00 00      mov c, 0
2178   1135 FD 77         inc b
2179   1137 FA FB FF      lea d, [bp + -5] ; $sp
2180   113A FD 43         mov [d], b
2181   113C FD 7D         dec b
2182   113E D8            push b
2183   113F FA FF FF      lea d, [bp + -1] ; $p
2184   1142 2A            mov b, [d]
2185   1143 38 00 00      mov c, 0
2186   1146 74            mov d, b
2187   1147 32            mov bl, [d]
2188   1148 A7 00         mov bh, 0
2189   114A E7            pop d
2190   114B FD 3E         mov [d], bl
2191   114D             ; p = p + 1; 
2192   114D FA FF FF      lea d, [bp + -1] ; $p
2193   1150 DA            push d
2194   1151 FA FF FF      lea d, [bp + -1] ; $p
2195   1154 2A            mov b, [d]
2196   1155 38 00 00      mov c, 0
2197   1158             ; --- START TERMS
2198   1158 D7            push a
2199   1159 11            mov a, b
2200   115A FD 2E 01 00   mov32 cb, $00000001
2200   115E 00 00 
2201   1160 56            add b, a
2202   1161 E4            pop a
2203   1162             ; --- END TERMS
2204   1162 E7            pop d
2205   1163 FD 43         mov [d], b
2206   1165             ; break; 
2207   1165 0A E0 11      jmp _switch27_exit ; case break
2208   1168             _switch27_case7:
2209   1168             ; int len = strlen(*(char **)p); 
2210   1168 52 02 00      sub sp, 2
2211   116B             ; --- START LOCAL VAR INITIALIZATION
2212   116B FA F9 FF      lea d, [bp + -7] ; $len
2213   116E DA            push d
2214   116F             ; --- START FUNCTION CALL
2215   116F FA FF FF      lea d, [bp + -1] ; $p
2216   1172 2A            mov b, [d]
2217   1173 38 00 00      mov c, 0
2218   1176 74            mov d, b
2219   1177 2A            mov b, [d]
2220   1178 FD AB         swp b
2221   117A D8            push b
2222   117B 07 F2 05      call strlen
2223   117E 51 02 00      add sp, 2
2224   1181             ; --- END FUNCTION CALL
2225   1181 E7            pop d
2226   1182 FD 43         mov [d], b
2227   1184             ; --- END LOCAL VAR INITIALIZATION
2228   1184             ; strcpy(sp, *(char **)p); 
2229   1184             ; --- START FUNCTION CALL
2230   1184 FA FF FF      lea d, [bp + -1] ; $p
2231   1187 2A            mov b, [d]
2232   1188 38 00 00      mov c, 0
2233   118B 74            mov d, b
2234   118C 2A            mov b, [d]
2235   118D FD AB         swp b
2236   118F D8            push b
2237   1190 FA FB FF      lea d, [bp + -5] ; $sp
2238   1193 2A            mov b, [d]
2239   1194 38 00 00      mov c, 0
2240   1197 FD AB         swp b
2241   1199 D8            push b
2242   119A 07 21 04      call strcpy
2243   119D 51 04 00      add sp, 4
2244   11A0             ; --- END FUNCTION CALL
2245   11A0             ; sp = sp + len; 
2246   11A0 FA FB FF      lea d, [bp + -5] ; $sp
2247   11A3 DA            push d
2248   11A4 FA FB FF      lea d, [bp + -5] ; $sp
2249   11A7 2A            mov b, [d]
2250   11A8 38 00 00      mov c, 0
2251   11AB             ; --- START TERMS
2252   11AB D7            push a
2253   11AC 11            mov a, b
2254   11AD FA F9 FF      lea d, [bp + -7] ; $len
2255   11B0 2A            mov b, [d]
2256   11B1 38 00 00      mov c, 0
2257   11B4 56            add b, a
2258   11B5 E4            pop a
2259   11B6             ; --- END TERMS
2260   11B6 E7            pop d
2261   11B7 FD 43         mov [d], b
2262   11B9             ; p = p + 2; 
2263   11B9 FA FF FF      lea d, [bp + -1] ; $p
2264   11BC DA            push d
2265   11BD FA FF FF      lea d, [bp + -1] ; $p
2266   11C0 2A            mov b, [d]
2267   11C1 38 00 00      mov c, 0
2268   11C4             ; --- START TERMS
2269   11C4 D7            push a
2270   11C5 11            mov a, b
2271   11C6 FD 2E 02 00   mov32 cb, $00000002
2271   11CA 00 00 
2272   11CC 56            add b, a
2273   11CD E4            pop a
2274   11CE             ; --- END TERMS
2275   11CE E7            pop d
2276   11CF FD 43         mov [d], b
2277   11D1             ; break; 
2278   11D1 0A E0 11      jmp _switch27_exit ; case break
2279   11D4             _switch27_default:
2280   11D4             ; print("Error: Unknown argument type.\n"); 
2281   11D4             ; --- START FUNCTION CALL
2282   11D4 26 F9 20      mov b, _s1 ; "Error: Unknown argument type.\n"
2283   11D7 FD AB         swp b
2284   11D9 D8            push b
2285   11DA 07 77 1C      call print
2286   11DD 51 02 00      add sp, 2
2287   11E0             ; --- END FUNCTION CALL
2288   11E0             _switch27_exit:
2289   11E0             ; format_p++; 
2290   11E0 FA FD FF      lea d, [bp + -3] ; $format_p
2291   11E3 2A            mov b, [d]
2292   11E4 38 00 00      mov c, 0
2293   11E7 FD 77         inc b
2294   11E9 FA FD FF      lea d, [bp + -3] ; $format_p
2295   11EC FD 43         mov [d], b
2296   11EE FD 7D         dec b
2297   11F0 0A 1B 12      jmp _if26_exit
2298   11F3             _if26_else:
2299   11F3             ; *sp++ = *format_p++; 
2300   11F3 FA FB FF      lea d, [bp + -5] ; $sp
2301   11F6 2A            mov b, [d]
2302   11F7 38 00 00      mov c, 0
2303   11FA FD 77         inc b
2304   11FC FA FB FF      lea d, [bp + -5] ; $sp
2305   11FF FD 43         mov [d], b
2306   1201 FD 7D         dec b
2307   1203 D8            push b
2308   1204 FA FD FF      lea d, [bp + -3] ; $format_p
2309   1207 2A            mov b, [d]
2310   1208 38 00 00      mov c, 0
2311   120B FD 77         inc b
2312   120D FA FD FF      lea d, [bp + -3] ; $format_p
2313   1210 FD 43         mov [d], b
2314   1212 FD 7D         dec b
2315   1214 74            mov d, b
2316   1215 32            mov bl, [d]
2317   1216 A7 00         mov bh, 0
2318   1218 E7            pop d
2319   1219 FD 3E         mov [d], bl
2320   121B             _if26_exit:
2321   121B             _if25_exit:
2322   121B             _for24_update:
2323   121B 0A EA 0E      jmp _for24_cond
2324   121E             _for24_exit:
2325   121E             ; *sp = '\0'; 
2326   121E FA FB FF      lea d, [bp + -5] ; $sp
2327   1221 2A            mov b, [d]
2328   1222 38 00 00      mov c, 0
2329   1225 D8            push b
2330   1226 FD 2E 00 00   mov32 cb, $00000000
2330   122A 00 00 
2331   122C E7            pop d
2332   122D FD 3E         mov [d], bl
2333   122F             ; return sp - dest; // return total number of chars written 
2334   122F FA FB FF      lea d, [bp + -5] ; $sp
2335   1232 2A            mov b, [d]
2336   1233 38 00 00      mov c, 0
2337   1236             ; --- START TERMS
2338   1236 D7            push a
2339   1237 11            mov a, b
2340   1238 FA 05 00      lea d, [bp + 5] ; $dest
2341   123B 2A            mov b, [d]
2342   123C 38 00 00      mov c, 0
2343   123F 60            sub a, b
2344   1240 27            mov b, a
2345   1241 E4            pop a
2346   1242             ; --- END TERMS
2347   1242 F9            leave
2348   1243 09            ret
2349   1244             
2350   1244             err:
2351   1244 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2352   1247             ; print(e); 
2353   1247             ; --- START FUNCTION CALL
2354   1247 FA 05 00      lea d, [bp + 5] ; $e
2355   124A 2A            mov b, [d]
2356   124B 38 00 00      mov c, 0
2357   124E FD AB         swp b
2358   1250 D8            push b
2359   1251 07 77 1C      call print
2360   1254 51 02 00      add sp, 2
2361   1257             ; --- END FUNCTION CALL
2362   1257 F9            leave
2363   1258 09            ret
2364   1259             
2365   1259             printx32:
2366   1259 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2367   125C             
2368   125C             ; --- BEGIN INLINE ASM SEGMENT
2369   125C FA 05 00      lea d, [bp + 5] ; $hex
2370   125F 2B 02 00      mov b, [d+2]
2371   1262 07 DA 1F      call print_u16x
2372   1265 2A            mov b, [d]
2373   1266 07 DA 1F      call print_u16x
2374   1269             ; --- END INLINE ASM SEGMENT
2375   1269             
2376   1269 F9            leave
2377   126A 09            ret
2378   126B             
2379   126B             printx16:
2380   126B F8 00 00      enter 0 ; (push bp; mov bp, sp)
2381   126E             
2382   126E             ; --- BEGIN INLINE ASM SEGMENT
2383   126E FA 05 00      lea d, [bp + 5] ; $hex
2384   1271 2A            mov b, [d]
2385   1272 07 DA 1F      call print_u16x
2386   1275             ; --- END INLINE ASM SEGMENT
2387   1275             
2388   1275 F9            leave
2389   1276 09            ret
2390   1277             
2391   1277             printx8:
2392   1277 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2393   127A             
2394   127A             ; --- BEGIN INLINE ASM SEGMENT
2395   127A FA 05 00      lea d, [bp + 5] ; $hex
2396   127D 32            mov bl, [d]
2397   127E 07 1E 20      call print_u8x
2398   1281             ; --- END INLINE ASM SEGMENT
2399   1281             
2400   1281 F9            leave
2401   1282 09            ret
2402   1283             
2403   1283             hex_str_to_int:
2404   1283 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2405   1286             ; int value = 0; 
2406   1286 52 02 00      sub sp, 2
2407   1289             ; --- START LOCAL VAR INITIALIZATION
2408   1289 FA FF FF      lea d, [bp + -1] ; $value
2409   128C DA            push d
2410   128D FD 2E 00 00   mov32 cb, $00000000
2410   1291 00 00 
2411   1293 E7            pop d
2412   1294 FD 43         mov [d], b
2413   1296             ; --- END LOCAL VAR INITIALIZATION
2414   1296             ; int i; 
2415   1296 52 02 00      sub sp, 2
2416   1299             ; char hex_char; 
2417   1299 52 01 00      sub sp, 1
2418   129C             ; int len; 
2419   129C 52 02 00      sub sp, 2
2420   129F             ; len = strlen(hex_string); 
2421   129F FA FA FF      lea d, [bp + -6] ; $len
2422   12A2 DA            push d
2423   12A3             ; --- START FUNCTION CALL
2424   12A3 FA 05 00      lea d, [bp + 5] ; $hex_string
2425   12A6 2A            mov b, [d]
2426   12A7 38 00 00      mov c, 0
2427   12AA FD AB         swp b
2428   12AC D8            push b
2429   12AD 07 F2 05      call strlen
2430   12B0 51 02 00      add sp, 2
2431   12B3             ; --- END FUNCTION CALL
2432   12B3 E7            pop d
2433   12B4 FD 43         mov [d], b
2434   12B6             ; for (i = 0; i < len; i++) { 
2435   12B6             _for31_init:
2436   12B6 FA FD FF      lea d, [bp + -3] ; $i
2437   12B9 DA            push d
2438   12BA FD 2E 00 00   mov32 cb, $00000000
2438   12BE 00 00 
2439   12C0 E7            pop d
2440   12C1 FD 43         mov [d], b
2441   12C3             _for31_cond:
2442   12C3 FA FD FF      lea d, [bp + -3] ; $i
2443   12C6 2A            mov b, [d]
2444   12C7 38 00 00      mov c, 0
2445   12CA             ; --- START RELATIONAL
2446   12CA D7            push a
2447   12CB 11            mov a, b
2448   12CC FA FA FF      lea d, [bp + -6] ; $len
2449   12CF 2A            mov b, [d]
2450   12D0 38 00 00      mov c, 0
2451   12D3 B0            cmp a, b
2452   12D4 FD 73         slt ; < (signed)
2453   12D6 E4            pop a
2454   12D7             ; --- END RELATIONAL
2455   12D7 C0 00 00      cmp b, 0
2456   12DA C6 27 14      je _for31_exit
2457   12DD             _for31_block:
2458   12DD             ; hex_char = hex_string[i]; 
2459   12DD FA FC FF      lea d, [bp + -4] ; $hex_char
2460   12E0 DA            push d
2461   12E1 FA 05 00      lea d, [bp + 5] ; $hex_string
2462   12E4 FD 2A         mov d, [d]
2463   12E6 D7            push a
2464   12E7 DA            push d
2465   12E8 FA FD FF      lea d, [bp + -3] ; $i
2466   12EB 2A            mov b, [d]
2467   12EC 38 00 00      mov c, 0
2468   12EF E7            pop d
2469   12F0 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
2470   12F4 E4            pop a
2471   12F5 32            mov bl, [d]
2472   12F6 A7 00         mov bh, 0
2473   12F8 38 00 00      mov c, 0
2474   12FB E7            pop d
2475   12FC FD 3E         mov [d], bl
2476   12FE             ; if (hex_char >= 'a' && hex_char <= 'f')  
2477   12FE             _if32_cond:
2478   12FE FA FC FF      lea d, [bp + -4] ; $hex_char
2479   1301 32            mov bl, [d]
2480   1302 A7 00         mov bh, 0
2481   1304 38 00 00      mov c, 0
2482   1307             ; --- START RELATIONAL
2483   1307 D7            push a
2484   1308 11            mov a, b
2485   1309 FD 2E 61 00   mov32 cb, $00000061
2485   130D 00 00 
2486   130F B0            cmp a, b
2487   1310 FD 80         sge ; >=
2488   1312 E4            pop a
2489   1313             ; --- END RELATIONAL
2490   1313             ; --- START LOGICAL AND
2491   1313 D7            push a
2492   1314 11            mov a, b
2493   1315 FA FC FF      lea d, [bp + -4] ; $hex_char
2494   1318 32            mov bl, [d]
2495   1319 A7 00         mov bh, 0
2496   131B 38 00 00      mov c, 0
2497   131E             ; --- START RELATIONAL
2498   131E D7            push a
2499   131F 11            mov a, b
2500   1320 FD 2E 66 00   mov32 cb, $00000066
2500   1324 00 00 
2501   1326 B0            cmp a, b
2502   1327 FD 74         sle ; <= (signed)
2503   1329 E4            pop a
2504   132A             ; --- END RELATIONAL
2505   132A FD A7         sand a, b
2506   132C E4            pop a
2507   132D             ; --- END LOGICAL AND
2508   132D C0 00 00      cmp b, 0
2509   1330 C6 70 13      je _if32_else
2510   1333             _if32_true:
2511   1333             ; value = (value * 16) + (hex_char - 'a' + 10); 
2512   1333 FA FF FF      lea d, [bp + -1] ; $value
2513   1336 DA            push d
2514   1337 FA FF FF      lea d, [bp + -1] ; $value
2515   133A 2A            mov b, [d]
2516   133B 38 00 00      mov c, 0
2517   133E             ; --- START FACTORS
2518   133E D7            push a
2519   133F 11            mov a, b
2520   1340 FD 2E 10 00   mov32 cb, $00000010
2520   1344 00 00 
2521   1346 AC            mul a, b ; *
2522   1347 11            mov a, b
2523   1348 27            mov b, a
2524   1349 E4            pop a
2525   134A             ; --- END FACTORS
2526   134A             ; --- START TERMS
2527   134A D7            push a
2528   134B 11            mov a, b
2529   134C FA FC FF      lea d, [bp + -4] ; $hex_char
2530   134F 32            mov bl, [d]
2531   1350 A7 00         mov bh, 0
2532   1352 38 00 00      mov c, 0
2533   1355             ; --- START TERMS
2534   1355 D7            push a
2535   1356 11            mov a, b
2536   1357 FD 2E 61 00   mov32 cb, $00000061
2536   135B 00 00 
2537   135D 60            sub a, b
2538   135E 27            mov b, a
2539   135F 11            mov a, b
2540   1360 FD 2E 0A 00   mov32 cb, $0000000a
2540   1364 00 00 
2541   1366 56            add b, a
2542   1367 E4            pop a
2543   1368             ; --- END TERMS
2544   1368 56            add b, a
2545   1369 E4            pop a
2546   136A             ; --- END TERMS
2547   136A E7            pop d
2548   136B FD 43         mov [d], b
2549   136D 0A 14 14      jmp _if32_exit
2550   1370             _if32_else:
2551   1370             ; if (hex_char >= 'A' && hex_char <= 'F')  
2552   1370             _if33_cond:
2553   1370 FA FC FF      lea d, [bp + -4] ; $hex_char
2554   1373 32            mov bl, [d]
2555   1374 A7 00         mov bh, 0
2556   1376 38 00 00      mov c, 0
2557   1379             ; --- START RELATIONAL
2558   1379 D7            push a
2559   137A 11            mov a, b
2560   137B FD 2E 41 00   mov32 cb, $00000041
2560   137F 00 00 
2561   1381 B0            cmp a, b
2562   1382 FD 80         sge ; >=
2563   1384 E4            pop a
2564   1385             ; --- END RELATIONAL
2565   1385             ; --- START LOGICAL AND
2566   1385 D7            push a
2567   1386 11            mov a, b
2568   1387 FA FC FF      lea d, [bp + -4] ; $hex_char
2569   138A 32            mov bl, [d]
2570   138B A7 00         mov bh, 0
2571   138D 38 00 00      mov c, 0
2572   1390             ; --- START RELATIONAL
2573   1390 D7            push a
2574   1391 11            mov a, b
2575   1392 FD 2E 46 00   mov32 cb, $00000046
2575   1396 00 00 
2576   1398 B0            cmp a, b
2577   1399 FD 74         sle ; <= (signed)
2578   139B E4            pop a
2579   139C             ; --- END RELATIONAL
2580   139C FD A7         sand a, b
2581   139E E4            pop a
2582   139F             ; --- END LOGICAL AND
2583   139F C0 00 00      cmp b, 0
2584   13A2 C6 E2 13      je _if33_else
2585   13A5             _if33_true:
2586   13A5             ; value = (value * 16) + (hex_char - 'A' + 10); 
2587   13A5 FA FF FF      lea d, [bp + -1] ; $value
2588   13A8 DA            push d
2589   13A9 FA FF FF      lea d, [bp + -1] ; $value
2590   13AC 2A            mov b, [d]
2591   13AD 38 00 00      mov c, 0
2592   13B0             ; --- START FACTORS
2593   13B0 D7            push a
2594   13B1 11            mov a, b
2595   13B2 FD 2E 10 00   mov32 cb, $00000010
2595   13B6 00 00 
2596   13B8 AC            mul a, b ; *
2597   13B9 11            mov a, b
2598   13BA 27            mov b, a
2599   13BB E4            pop a
2600   13BC             ; --- END FACTORS
2601   13BC             ; --- START TERMS
2602   13BC D7            push a
2603   13BD 11            mov a, b
2604   13BE FA FC FF      lea d, [bp + -4] ; $hex_char
2605   13C1 32            mov bl, [d]
2606   13C2 A7 00         mov bh, 0
2607   13C4 38 00 00      mov c, 0
2608   13C7             ; --- START TERMS
2609   13C7 D7            push a
2610   13C8 11            mov a, b
2611   13C9 FD 2E 41 00   mov32 cb, $00000041
2611   13CD 00 00 
2612   13CF 60            sub a, b
2613   13D0 27            mov b, a
2614   13D1 11            mov a, b
2615   13D2 FD 2E 0A 00   mov32 cb, $0000000a
2615   13D6 00 00 
2616   13D8 56            add b, a
2617   13D9 E4            pop a
2618   13DA             ; --- END TERMS
2619   13DA 56            add b, a
2620   13DB E4            pop a
2621   13DC             ; --- END TERMS
2622   13DC E7            pop d
2623   13DD FD 43         mov [d], b
2624   13DF 0A 14 14      jmp _if33_exit
2625   13E2             _if33_else:
2626   13E2             ; value = (value * 16) + (hex_char - '0'); 
2627   13E2 FA FF FF      lea d, [bp + -1] ; $value
2628   13E5 DA            push d
2629   13E6 FA FF FF      lea d, [bp + -1] ; $value
2630   13E9 2A            mov b, [d]
2631   13EA 38 00 00      mov c, 0
2632   13ED             ; --- START FACTORS
2633   13ED D7            push a
2634   13EE 11            mov a, b
2635   13EF FD 2E 10 00   mov32 cb, $00000010
2635   13F3 00 00 
2636   13F5 AC            mul a, b ; *
2637   13F6 11            mov a, b
2638   13F7 27            mov b, a
2639   13F8 E4            pop a
2640   13F9             ; --- END FACTORS
2641   13F9             ; --- START TERMS
2642   13F9 D7            push a
2643   13FA 11            mov a, b
2644   13FB FA FC FF      lea d, [bp + -4] ; $hex_char
2645   13FE 32            mov bl, [d]
2646   13FF A7 00         mov bh, 0
2647   1401 38 00 00      mov c, 0
2648   1404             ; --- START TERMS
2649   1404 D7            push a
2650   1405 11            mov a, b
2651   1406 FD 2E 30 00   mov32 cb, $00000030
2651   140A 00 00 
2652   140C 60            sub a, b
2653   140D 27            mov b, a
2654   140E E4            pop a
2655   140F             ; --- END TERMS
2656   140F 56            add b, a
2657   1410 E4            pop a
2658   1411             ; --- END TERMS
2659   1411 E7            pop d
2660   1412 FD 43         mov [d], b
2661   1414             _if33_exit:
2662   1414             _if32_exit:
2663   1414             _for31_update:
2664   1414 FA FD FF      lea d, [bp + -3] ; $i
2665   1417 2A            mov b, [d]
2666   1418 38 00 00      mov c, 0
2667   141B FD 77         inc b
2668   141D FA FD FF      lea d, [bp + -3] ; $i
2669   1420 FD 43         mov [d], b
2670   1422 FD 7D         dec b
2671   1424 0A C3 12      jmp _for31_cond
2672   1427             _for31_exit:
2673   1427             ; return value; 
2674   1427 FA FF FF      lea d, [bp + -1] ; $value
2675   142A 2A            mov b, [d]
2676   142B 38 00 00      mov c, 0
2677   142E F9            leave
2678   142F 09            ret
2679   1430             
2680   1430             gets:
2681   1430 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2682   1433             
2683   1433             ; --- BEGIN INLINE ASM SEGMENT
2684   1433 FA 05 00      lea d, [bp + 5] ; $s
2685   1436 15            mov a, [d]
2686   1437 3C            mov d, a
2687   1438 07 3F 1E      call _gets
2688   143B             ; --- END INLINE ASM SEGMENT
2689   143B             
2690   143B             ; return strlen(s); 
2691   143B             ; --- START FUNCTION CALL
2692   143B FA 05 00      lea d, [bp + 5] ; $s
2693   143E 2A            mov b, [d]
2694   143F 38 00 00      mov c, 0
2695   1442 FD AB         swp b
2696   1444 D8            push b
2697   1445 07 F2 05      call strlen
2698   1448 51 02 00      add sp, 2
2699   144B             ; --- END FUNCTION CALL
2700   144B F9            leave
2701   144C 09            ret
2702   144D             
2703   144D             print_signed:
2704   144D F8 00 00      enter 0 ; (push bp; mov bp, sp)
2705   1450             ; char digits[5]; 
2706   1450 52 05 00      sub sp, 5
2707   1453             ; int i = 0; 
2708   1453 52 02 00      sub sp, 2
2709   1456             ; --- START LOCAL VAR INITIALIZATION
2710   1456 FA FA FF      lea d, [bp + -6] ; $i
2711   1459 DA            push d
2712   145A FD 2E 00 00   mov32 cb, $00000000
2712   145E 00 00 
2713   1460 E7            pop d
2714   1461 FD 43         mov [d], b
2715   1463             ; --- END LOCAL VAR INITIALIZATION
2716   1463             ; if (num < 0) { 
2717   1463             _if34_cond:
2718   1463 FA 05 00      lea d, [bp + 5] ; $num
2719   1466 2A            mov b, [d]
2720   1467 38 00 00      mov c, 0
2721   146A             ; --- START RELATIONAL
2722   146A D7            push a
2723   146B 11            mov a, b
2724   146C FD 2E 00 00   mov32 cb, $00000000
2724   1470 00 00 
2725   1472 B0            cmp a, b
2726   1473 FD 73         slt ; < (signed)
2727   1475 E4            pop a
2728   1476             ; --- END RELATIONAL
2729   1476 C0 00 00      cmp b, 0
2730   1479 C6 9C 14      je _if34_else
2731   147C             _if34_true:
2732   147C             ; putchar('-'); 
2733   147C             ; --- START FUNCTION CALL
2734   147C FD 2E 2D 00   mov32 cb, $0000002d
2734   1480 00 00 
2735   1482 DD            push bl
2736   1483 07 29 1C      call putchar
2737   1486 51 01 00      add sp, 1
2738   1489             ; --- END FUNCTION CALL
2739   1489             ; num = -num; 
2740   1489 FA 05 00      lea d, [bp + 5] ; $num
2741   148C DA            push d
2742   148D FA 05 00      lea d, [bp + 5] ; $num
2743   1490 2A            mov b, [d]
2744   1491 38 00 00      mov c, 0
2745   1494 FD 97         neg b
2746   1496 E7            pop d
2747   1497 FD 43         mov [d], b
2748   1499 0A C7 14      jmp _if34_exit
2749   149C             _if34_else:
2750   149C             ; if (num == 0) { 
2751   149C             _if35_cond:
2752   149C FA 05 00      lea d, [bp + 5] ; $num
2753   149F 2A            mov b, [d]
2754   14A0 38 00 00      mov c, 0
2755   14A3             ; --- START RELATIONAL
2756   14A3 D7            push a
2757   14A4 11            mov a, b
2758   14A5 FD 2E 00 00   mov32 cb, $00000000
2758   14A9 00 00 
2759   14AB B0            cmp a, b
2760   14AC FD 71         seq ; ==
2761   14AE E4            pop a
2762   14AF             ; --- END RELATIONAL
2763   14AF C0 00 00      cmp b, 0
2764   14B2 C6 C7 14      je _if35_exit
2765   14B5             _if35_true:
2766   14B5             ; putchar('0'); 
2767   14B5             ; --- START FUNCTION CALL
2768   14B5 FD 2E 30 00   mov32 cb, $00000030
2768   14B9 00 00 
2769   14BB DD            push bl
2770   14BC 07 29 1C      call putchar
2771   14BF 51 01 00      add sp, 1
2772   14C2             ; --- END FUNCTION CALL
2773   14C2             ; return; 
2774   14C2 F9            leave
2775   14C3 09            ret
2776   14C4 0A C7 14      jmp _if35_exit
2777   14C7             _if35_exit:
2778   14C7             _if34_exit:
2779   14C7             ; while (num > 0) { 
2780   14C7             _while36_cond:
2781   14C7 FA 05 00      lea d, [bp + 5] ; $num
2782   14CA 2A            mov b, [d]
2783   14CB 38 00 00      mov c, 0
2784   14CE             ; --- START RELATIONAL
2785   14CE D7            push a
2786   14CF 11            mov a, b
2787   14D0 FD 2E 00 00   mov32 cb, $00000000
2787   14D4 00 00 
2788   14D6 B0            cmp a, b
2789   14D7 FD 7F         sgt ; >
2790   14D9 E4            pop a
2791   14DA             ; --- END RELATIONAL
2792   14DA C0 00 00      cmp b, 0
2793   14DD C6 3C 15      je _while36_exit
2794   14E0             _while36_block:
2795   14E0             ; digits[i] = '0' + (num % 10); 
2796   14E0 FA FC FF      lea d, [bp + -4] ; $digits
2797   14E3 D7            push a
2798   14E4 DA            push d
2799   14E5 FA FA FF      lea d, [bp + -6] ; $i
2800   14E8 2A            mov b, [d]
2801   14E9 38 00 00      mov c, 0
2802   14EC E7            pop d
2803   14ED 5A            add d, b
2804   14EE E4            pop a
2805   14EF DA            push d
2806   14F0 FD 2E 30 00   mov32 cb, $00000030
2806   14F4 00 00 
2807   14F6             ; --- START TERMS
2808   14F6 D7            push a
2809   14F7 11            mov a, b
2810   14F8 FA 05 00      lea d, [bp + 5] ; $num
2811   14FB 2A            mov b, [d]
2812   14FC 38 00 00      mov c, 0
2813   14FF             ; --- START FACTORS
2814   14FF D7            push a
2815   1500 11            mov a, b
2816   1501 FD 2E 0A 00   mov32 cb, $0000000a
2816   1505 00 00 
2817   1507 AE            div a, b ; 
2818   1508 11            mov a, b
2819   1509 27            mov b, a
2820   150A E4            pop a
2821   150B             ; --- END FACTORS
2822   150B 56            add b, a
2823   150C E4            pop a
2824   150D             ; --- END TERMS
2825   150D E7            pop d
2826   150E FD 3E         mov [d], bl
2827   1510             ; num = num / 10; 
2828   1510 FA 05 00      lea d, [bp + 5] ; $num
2829   1513 DA            push d
2830   1514 FA 05 00      lea d, [bp + 5] ; $num
2831   1517 2A            mov b, [d]
2832   1518 38 00 00      mov c, 0
2833   151B             ; --- START FACTORS
2834   151B D7            push a
2835   151C 11            mov a, b
2836   151D FD 2E 0A 00   mov32 cb, $0000000a
2836   1521 00 00 
2837   1523 AE            div a, b
2838   1524 27            mov b, a
2839   1525 E4            pop a
2840   1526             ; --- END FACTORS
2841   1526 E7            pop d
2842   1527 FD 43         mov [d], b
2843   1529             ; i++; 
2844   1529 FA FA FF      lea d, [bp + -6] ; $i
2845   152C 2A            mov b, [d]
2846   152D 38 00 00      mov c, 0
2847   1530 FD 77         inc b
2848   1532 FA FA FF      lea d, [bp + -6] ; $i
2849   1535 FD 43         mov [d], b
2850   1537 FD 7D         dec b
2851   1539 0A C7 14      jmp _while36_cond
2852   153C             _while36_exit:
2853   153C             ; while (i > 0) { 
2854   153C             _while37_cond:
2855   153C FA FA FF      lea d, [bp + -6] ; $i
2856   153F 2A            mov b, [d]
2857   1540 38 00 00      mov c, 0
2858   1543             ; --- START RELATIONAL
2859   1543 D7            push a
2860   1544 11            mov a, b
2861   1545 FD 2E 00 00   mov32 cb, $00000000
2861   1549 00 00 
2862   154B B0            cmp a, b
2863   154C FD 7F         sgt ; >
2864   154E E4            pop a
2865   154F             ; --- END RELATIONAL
2866   154F C0 00 00      cmp b, 0
2867   1552 C6 84 15      je _while37_exit
2868   1555             _while37_block:
2869   1555             ; i--; 
2870   1555 FA FA FF      lea d, [bp + -6] ; $i
2871   1558 2A            mov b, [d]
2872   1559 38 00 00      mov c, 0
2873   155C FD 7D         dec b
2874   155E FA FA FF      lea d, [bp + -6] ; $i
2875   1561 FD 43         mov [d], b
2876   1563 FD 77         inc b
2877   1565             ; putchar(digits[i]); 
2878   1565             ; --- START FUNCTION CALL
2879   1565 FA FC FF      lea d, [bp + -4] ; $digits
2880   1568 D7            push a
2881   1569 DA            push d
2882   156A FA FA FF      lea d, [bp + -6] ; $i
2883   156D 2A            mov b, [d]
2884   156E 38 00 00      mov c, 0
2885   1571 E7            pop d
2886   1572 5A            add d, b
2887   1573 E4            pop a
2888   1574 32            mov bl, [d]
2889   1575 A7 00         mov bh, 0
2890   1577 38 00 00      mov c, 0
2891   157A DD            push bl
2892   157B 07 29 1C      call putchar
2893   157E 51 01 00      add sp, 1
2894   1581             ; --- END FUNCTION CALL
2895   1581 0A 3C 15      jmp _while37_cond
2896   1584             _while37_exit:
2897   1584 F9            leave
2898   1585 09            ret
2899   1586             
2900   1586             print_signed_long:
2901   1586 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2902   1589             ; char digits[10]; 
2903   1589 52 0A 00      sub sp, 10
2904   158C             ; int i = 0; 
2905   158C 52 02 00      sub sp, 2
2906   158F             ; --- START LOCAL VAR INITIALIZATION
2907   158F FA F5 FF      lea d, [bp + -11] ; $i
2908   1592 DA            push d
2909   1593 FD 2E 00 00   mov32 cb, $00000000
2909   1597 00 00 
2910   1599 E7            pop d
2911   159A FD 43         mov [d], b
2912   159C             ; --- END LOCAL VAR INITIALIZATION
2913   159C             ; if (num < 0) { 
2914   159C             _if38_cond:
2915   159C FA 05 00      lea d, [bp + 5] ; $num
2916   159F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2917   15A2 FD 39         mov c, b ; And place it into C
2918   15A4 2A            mov b, [d] ; Lower Word in B
2919   15A5             ; --- START RELATIONAL
2920   15A5 D7            push a
2921   15A6 FD D8         push g
2922   15A8 11            mov a, b
2923   15A9 FD 7A         mov g, c
2924   15AB FD 2E 00 00   mov32 cb, $00000000
2924   15AF 00 00 
2925   15B1 FD AF         cmp32 ga, cb
2926   15B3 FD 73         slt ; <
2927   15B5 FD F1         pop g
2928   15B7 E4            pop a
2929   15B8             ; --- END RELATIONAL
2930   15B8 C0 00 00      cmp b, 0
2931   15BB C6 E7 15      je _if38_else
2932   15BE             _if38_true:
2933   15BE             ; putchar('-'); 
2934   15BE             ; --- START FUNCTION CALL
2935   15BE FD 2E 2D 00   mov32 cb, $0000002d
2935   15C2 00 00 
2936   15C4 DD            push bl
2937   15C5 07 29 1C      call putchar
2938   15C8 51 01 00      add sp, 1
2939   15CB             ; --- END FUNCTION CALL
2940   15CB             ; num = -num; 
2941   15CB FA 05 00      lea d, [bp + 5] ; $num
2942   15CE DA            push d
2943   15CF FA 05 00      lea d, [bp + 5] ; $num
2944   15D2 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2945   15D5 FD 39         mov c, b ; And place it into C
2946   15D7 2A            mov b, [d] ; Lower Word in B
2947   15D8 FD 97         neg b
2948   15DA E7            pop d
2949   15DB FD 43         mov [d], b
2950   15DD 26 00 00      mov b, 0
2951   15E0 FD 44 02 00   mov [d + 2], b
2952   15E4 0A 1B 16      jmp _if38_exit
2953   15E7             _if38_else:
2954   15E7             ; if (num == 0) { 
2955   15E7             _if39_cond:
2956   15E7 FA 05 00      lea d, [bp + 5] ; $num
2957   15EA 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2958   15ED FD 39         mov c, b ; And place it into C
2959   15EF 2A            mov b, [d] ; Lower Word in B
2960   15F0             ; --- START RELATIONAL
2961   15F0 D7            push a
2962   15F1 FD D8         push g
2963   15F3 11            mov a, b
2964   15F4 FD 7A         mov g, c
2965   15F6 FD 2E 00 00   mov32 cb, $00000000
2965   15FA 00 00 
2966   15FC FD AF         cmp32 ga, cb
2967   15FE FD 71         seq ; ==
2968   1600 FD F1         pop g
2969   1602 E4            pop a
2970   1603             ; --- END RELATIONAL
2971   1603 C0 00 00      cmp b, 0
2972   1606 C6 1B 16      je _if39_exit
2973   1609             _if39_true:
2974   1609             ; putchar('0'); 
2975   1609             ; --- START FUNCTION CALL
2976   1609 FD 2E 30 00   mov32 cb, $00000030
2976   160D 00 00 
2977   160F DD            push bl
2978   1610 07 29 1C      call putchar
2979   1613 51 01 00      add sp, 1
2980   1616             ; --- END FUNCTION CALL
2981   1616             ; return; 
2982   1616 F9            leave
2983   1617 09            ret
2984   1618 0A 1B 16      jmp _if39_exit
2985   161B             _if39_exit:
2986   161B             _if38_exit:
2987   161B             ; while (num > 0) { 
2988   161B             _while40_cond:
2989   161B FA 05 00      lea d, [bp + 5] ; $num
2990   161E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2991   1621 FD 39         mov c, b ; And place it into C
2992   1623 2A            mov b, [d] ; Lower Word in B
2993   1624             ; --- START RELATIONAL
2994   1624 D7            push a
2995   1625 FD D8         push g
2996   1627 11            mov a, b
2997   1628 FD 7A         mov g, c
2998   162A FD 2E 00 00   mov32 cb, $00000000
2998   162E 00 00 
2999   1630 FD AF         cmp32 ga, cb
3000   1632 FD 7F         sgt
3001   1634 FD F1         pop g
3002   1636 E4            pop a
3003   1637             ; --- END RELATIONAL
3004   1637 C0 00 00      cmp b, 0
3005   163A C6 A3 16      je _while40_exit
3006   163D             _while40_block:
3007   163D             ; digits[i] = '0' + (num % 10); 
3008   163D FA F7 FF      lea d, [bp + -9] ; $digits
3009   1640 D7            push a
3010   1641 DA            push d
3011   1642 FA F5 FF      lea d, [bp + -11] ; $i
3012   1645 2A            mov b, [d]
3013   1646 38 00 00      mov c, 0
3014   1649 E7            pop d
3015   164A 5A            add d, b
3016   164B E4            pop a
3017   164C DA            push d
3018   164D FD 2E 30 00   mov32 cb, $00000030
3018   1651 00 00 
3019   1653             ; --- START TERMS
3020   1653 D7            push a
3021   1654 11            mov a, b
3022   1655 FA 05 00      lea d, [bp + 5] ; $num
3023   1658 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3024   165B FD 39         mov c, b ; And place it into C
3025   165D 2A            mov b, [d] ; Lower Word in B
3026   165E             ; --- START FACTORS
3027   165E D7            push a
3028   165F 11            mov a, b
3029   1660 FD 2E 0A 00   mov32 cb, $0000000a
3029   1664 00 00 
3030   1666 AE            div a, b ; 
3031   1667 11            mov a, b
3032   1668 27            mov b, a
3033   1669 E4            pop a
3034   166A             ; --- END FACTORS
3035   166A FD 15         add32 cb, ga
3036   166C E4            pop a
3037   166D             ; --- END TERMS
3038   166D E7            pop d
3039   166E FD 3E         mov [d], bl
3040   1670             ; num = num / 10; 
3041   1670 FA 05 00      lea d, [bp + 5] ; $num
3042   1673 DA            push d
3043   1674 FA 05 00      lea d, [bp + 5] ; $num
3044   1677 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3045   167A FD 39         mov c, b ; And place it into C
3046   167C 2A            mov b, [d] ; Lower Word in B
3047   167D             ; --- START FACTORS
3048   167D D7            push a
3049   167E 11            mov a, b
3050   167F FD 2E 0A 00   mov32 cb, $0000000a
3050   1683 00 00 
3051   1685 AE            div a, b
3052   1686 27            mov b, a
3053   1687 E4            pop a
3054   1688             ; --- END FACTORS
3055   1688 E7            pop d
3056   1689 FD 43         mov [d], b
3057   168B 28            mov b, c
3058   168C FD 44 02 00   mov [d + 2], b
3059   1690             ; i++; 
3060   1690 FA F5 FF      lea d, [bp + -11] ; $i
3061   1693 2A            mov b, [d]
3062   1694 38 00 00      mov c, 0
3063   1697 FD 77         inc b
3064   1699 FA F5 FF      lea d, [bp + -11] ; $i
3065   169C FD 43         mov [d], b
3066   169E FD 7D         dec b
3067   16A0 0A 1B 16      jmp _while40_cond
3068   16A3             _while40_exit:
3069   16A3             ; while (i > 0) { 
3070   16A3             _while41_cond:
3071   16A3 FA F5 FF      lea d, [bp + -11] ; $i
3072   16A6 2A            mov b, [d]
3073   16A7 38 00 00      mov c, 0
3074   16AA             ; --- START RELATIONAL
3075   16AA D7            push a
3076   16AB 11            mov a, b
3077   16AC FD 2E 00 00   mov32 cb, $00000000
3077   16B0 00 00 
3078   16B2 B0            cmp a, b
3079   16B3 FD 7F         sgt ; >
3080   16B5 E4            pop a
3081   16B6             ; --- END RELATIONAL
3082   16B6 C0 00 00      cmp b, 0
3083   16B9 C6 EB 16      je _while41_exit
3084   16BC             _while41_block:
3085   16BC             ; i--; 
3086   16BC FA F5 FF      lea d, [bp + -11] ; $i
3087   16BF 2A            mov b, [d]
3088   16C0 38 00 00      mov c, 0
3089   16C3 FD 7D         dec b
3090   16C5 FA F5 FF      lea d, [bp + -11] ; $i
3091   16C8 FD 43         mov [d], b
3092   16CA FD 77         inc b
3093   16CC             ; putchar(digits[i]); 
3094   16CC             ; --- START FUNCTION CALL
3095   16CC FA F7 FF      lea d, [bp + -9] ; $digits
3096   16CF D7            push a
3097   16D0 DA            push d
3098   16D1 FA F5 FF      lea d, [bp + -11] ; $i
3099   16D4 2A            mov b, [d]
3100   16D5 38 00 00      mov c, 0
3101   16D8 E7            pop d
3102   16D9 5A            add d, b
3103   16DA E4            pop a
3104   16DB 32            mov bl, [d]
3105   16DC A7 00         mov bh, 0
3106   16DE 38 00 00      mov c, 0
3107   16E1 DD            push bl
3108   16E2 07 29 1C      call putchar
3109   16E5 51 01 00      add sp, 1
3110   16E8             ; --- END FUNCTION CALL
3111   16E8 0A A3 16      jmp _while41_cond
3112   16EB             _while41_exit:
3113   16EB F9            leave
3114   16EC 09            ret
3115   16ED             
3116   16ED             print_unsigned_long:
3117   16ED F8 00 00      enter 0 ; (push bp; mov bp, sp)
3118   16F0             ; char digits[10]; 
3119   16F0 52 0A 00      sub sp, 10
3120   16F3             ; int i; 
3121   16F3 52 02 00      sub sp, 2
3122   16F6             ; i = 0; 
3123   16F6 FA F5 FF      lea d, [bp + -11] ; $i
3124   16F9 DA            push d
3125   16FA FD 2E 00 00   mov32 cb, $00000000
3125   16FE 00 00 
3126   1700 E7            pop d
3127   1701 FD 43         mov [d], b
3128   1703             ; if(num == 0){ 
3129   1703             _if42_cond:
3130   1703 FA 05 00      lea d, [bp + 5] ; $num
3131   1706 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3132   1709 FD 39         mov c, b ; And place it into C
3133   170B 2A            mov b, [d] ; Lower Word in B
3134   170C             ; --- START RELATIONAL
3135   170C D7            push a
3136   170D FD D8         push g
3137   170F 11            mov a, b
3138   1710 FD 7A         mov g, c
3139   1712 FD 2E 00 00   mov32 cb, $00000000
3139   1716 00 00 
3140   1718 FD AF         cmp32 ga, cb
3141   171A FD 71         seq ; ==
3142   171C FD F1         pop g
3143   171E E4            pop a
3144   171F             ; --- END RELATIONAL
3145   171F C0 00 00      cmp b, 0
3146   1722 C6 37 17      je _if42_exit
3147   1725             _if42_true:
3148   1725             ; putchar('0'); 
3149   1725             ; --- START FUNCTION CALL
3150   1725 FD 2E 30 00   mov32 cb, $00000030
3150   1729 00 00 
3151   172B DD            push bl
3152   172C 07 29 1C      call putchar
3153   172F 51 01 00      add sp, 1
3154   1732             ; --- END FUNCTION CALL
3155   1732             ; return; 
3156   1732 F9            leave
3157   1733 09            ret
3158   1734 0A 37 17      jmp _if42_exit
3159   1737             _if42_exit:
3160   1737             ; while (num > 0) { 
3161   1737             _while43_cond:
3162   1737 FA 05 00      lea d, [bp + 5] ; $num
3163   173A 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3164   173D FD 39         mov c, b ; And place it into C
3165   173F 2A            mov b, [d] ; Lower Word in B
3166   1740             ; --- START RELATIONAL
3167   1740 D7            push a
3168   1741 FD D8         push g
3169   1743 11            mov a, b
3170   1744 FD 7A         mov g, c
3171   1746 FD 2E 00 00   mov32 cb, $00000000
3171   174A 00 00 
3172   174C FD AF         cmp32 ga, cb
3173   174E FD 81         sgu
3174   1750 FD F1         pop g
3175   1752 E4            pop a
3176   1753             ; --- END RELATIONAL
3177   1753 C0 00 00      cmp b, 0
3178   1756 C6 BF 17      je _while43_exit
3179   1759             _while43_block:
3180   1759             ; digits[i] = '0' + (num % 10); 
3181   1759 FA F7 FF      lea d, [bp + -9] ; $digits
3182   175C D7            push a
3183   175D DA            push d
3184   175E FA F5 FF      lea d, [bp + -11] ; $i
3185   1761 2A            mov b, [d]
3186   1762 38 00 00      mov c, 0
3187   1765 E7            pop d
3188   1766 5A            add d, b
3189   1767 E4            pop a
3190   1768 DA            push d
3191   1769 FD 2E 30 00   mov32 cb, $00000030
3191   176D 00 00 
3192   176F             ; --- START TERMS
3193   176F D7            push a
3194   1770 11            mov a, b
3195   1771 FA 05 00      lea d, [bp + 5] ; $num
3196   1774 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3197   1777 FD 39         mov c, b ; And place it into C
3198   1779 2A            mov b, [d] ; Lower Word in B
3199   177A             ; --- START FACTORS
3200   177A D7            push a
3201   177B 11            mov a, b
3202   177C FD 2E 0A 00   mov32 cb, $0000000a
3202   1780 00 00 
3203   1782 AE            div a, b ; 
3204   1783 11            mov a, b
3205   1784 27            mov b, a
3206   1785 E4            pop a
3207   1786             ; --- END FACTORS
3208   1786 FD 15         add32 cb, ga
3209   1788 E4            pop a
3210   1789             ; --- END TERMS
3211   1789 E7            pop d
3212   178A FD 3E         mov [d], bl
3213   178C             ; num = num / 10; 
3214   178C FA 05 00      lea d, [bp + 5] ; $num
3215   178F DA            push d
3216   1790 FA 05 00      lea d, [bp + 5] ; $num
3217   1793 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3218   1796 FD 39         mov c, b ; And place it into C
3219   1798 2A            mov b, [d] ; Lower Word in B
3220   1799             ; --- START FACTORS
3221   1799 D7            push a
3222   179A 11            mov a, b
3223   179B FD 2E 0A 00   mov32 cb, $0000000a
3223   179F 00 00 
3224   17A1 AE            div a, b
3225   17A2 27            mov b, a
3226   17A3 E4            pop a
3227   17A4             ; --- END FACTORS
3228   17A4 E7            pop d
3229   17A5 FD 43         mov [d], b
3230   17A7 28            mov b, c
3231   17A8 FD 44 02 00   mov [d + 2], b
3232   17AC             ; i++; 
3233   17AC FA F5 FF      lea d, [bp + -11] ; $i
3234   17AF 2A            mov b, [d]
3235   17B0 38 00 00      mov c, 0
3236   17B3 FD 77         inc b
3237   17B5 FA F5 FF      lea d, [bp + -11] ; $i
3238   17B8 FD 43         mov [d], b
3239   17BA FD 7D         dec b
3240   17BC 0A 37 17      jmp _while43_cond
3241   17BF             _while43_exit:
3242   17BF             ; while (i > 0) { 
3243   17BF             _while44_cond:
3244   17BF FA F5 FF      lea d, [bp + -11] ; $i
3245   17C2 2A            mov b, [d]
3246   17C3 38 00 00      mov c, 0
3247   17C6             ; --- START RELATIONAL
3248   17C6 D7            push a
3249   17C7 11            mov a, b
3250   17C8 FD 2E 00 00   mov32 cb, $00000000
3250   17CC 00 00 
3251   17CE B0            cmp a, b
3252   17CF FD 7F         sgt ; >
3253   17D1 E4            pop a
3254   17D2             ; --- END RELATIONAL
3255   17D2 C0 00 00      cmp b, 0
3256   17D5 C6 07 18      je _while44_exit
3257   17D8             _while44_block:
3258   17D8             ; i--; 
3259   17D8 FA F5 FF      lea d, [bp + -11] ; $i
3260   17DB 2A            mov b, [d]
3261   17DC 38 00 00      mov c, 0
3262   17DF FD 7D         dec b
3263   17E1 FA F5 FF      lea d, [bp + -11] ; $i
3264   17E4 FD 43         mov [d], b
3265   17E6 FD 77         inc b
3266   17E8             ; putchar(digits[i]); 
3267   17E8             ; --- START FUNCTION CALL
3268   17E8 FA F7 FF      lea d, [bp + -9] ; $digits
3269   17EB D7            push a
3270   17EC DA            push d
3271   17ED FA F5 FF      lea d, [bp + -11] ; $i
3272   17F0 2A            mov b, [d]
3273   17F1 38 00 00      mov c, 0
3274   17F4 E7            pop d
3275   17F5 5A            add d, b
3276   17F6 E4            pop a
3277   17F7 32            mov bl, [d]
3278   17F8 A7 00         mov bh, 0
3279   17FA 38 00 00      mov c, 0
3280   17FD DD            push bl
3281   17FE 07 29 1C      call putchar
3282   1801 51 01 00      add sp, 1
3283   1804             ; --- END FUNCTION CALL
3284   1804 0A BF 17      jmp _while44_cond
3285   1807             _while44_exit:
3286   1807 F9            leave
3287   1808 09            ret
3288   1809             
3289   1809             sprint_unsigned:
3290   1809 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3291   180C             ; char digits[5]; 
3292   180C 52 05 00      sub sp, 5
3293   180F             ; int i; 
3294   180F 52 02 00      sub sp, 2
3295   1812             ; int len = 0; 
3296   1812 52 02 00      sub sp, 2
3297   1815             ; --- START LOCAL VAR INITIALIZATION
3298   1815 FA F8 FF      lea d, [bp + -8] ; $len
3299   1818 DA            push d
3300   1819 FD 2E 00 00   mov32 cb, $00000000
3300   181D 00 00 
3301   181F E7            pop d
3302   1820 FD 43         mov [d], b
3303   1822             ; --- END LOCAL VAR INITIALIZATION
3304   1822             ; i = 0; 
3305   1822 FA FA FF      lea d, [bp + -6] ; $i
3306   1825 DA            push d
3307   1826 FD 2E 00 00   mov32 cb, $00000000
3307   182A 00 00 
3308   182C E7            pop d
3309   182D FD 43         mov [d], b
3310   182F             ; if(num == 0){ 
3311   182F             _if45_cond:
3312   182F FA 07 00      lea d, [bp + 7] ; $num
3313   1832 2A            mov b, [d]
3314   1833 38 00 00      mov c, 0
3315   1836             ; --- START RELATIONAL
3316   1836 D7            push a
3317   1837 11            mov a, b
3318   1838 FD 2E 00 00   mov32 cb, $00000000
3318   183C 00 00 
3319   183E B0            cmp a, b
3320   183F FD 71         seq ; ==
3321   1841 E4            pop a
3322   1842             ; --- END RELATIONAL
3323   1842 C0 00 00      cmp b, 0
3324   1845 C6 6D 18      je _if45_exit
3325   1848             _if45_true:
3326   1848             ; *dest++ = '0'; 
3327   1848 FA 05 00      lea d, [bp + 5] ; $dest
3328   184B 2A            mov b, [d]
3329   184C 38 00 00      mov c, 0
3330   184F FD 77         inc b
3331   1851 FA 05 00      lea d, [bp + 5] ; $dest
3332   1854 FD 43         mov [d], b
3333   1856 FD 7D         dec b
3334   1858 D8            push b
3335   1859 FD 2E 30 00   mov32 cb, $00000030
3335   185D 00 00 
3336   185F E7            pop d
3337   1860 FD 3E         mov [d], bl
3338   1862             ; return 1; 
3339   1862 FD 2E 01 00   mov32 cb, $00000001
3339   1866 00 00 
3340   1868 F9            leave
3341   1869 09            ret
3342   186A 0A 6D 18      jmp _if45_exit
3343   186D             _if45_exit:
3344   186D             ; while (num > 0) { 
3345   186D             _while46_cond:
3346   186D FA 07 00      lea d, [bp + 7] ; $num
3347   1870 2A            mov b, [d]
3348   1871 38 00 00      mov c, 0
3349   1874             ; --- START RELATIONAL
3350   1874 D7            push a
3351   1875 11            mov a, b
3352   1876 FD 2E 00 00   mov32 cb, $00000000
3352   187A 00 00 
3353   187C B0            cmp a, b
3354   187D FD 81         sgu ; > (unsigned)
3355   187F E4            pop a
3356   1880             ; --- END RELATIONAL
3357   1880 C0 00 00      cmp b, 0
3358   1883 C6 E2 18      je _while46_exit
3359   1886             _while46_block:
3360   1886             ; digits[i] = '0' + (num % 10); 
3361   1886 FA FC FF      lea d, [bp + -4] ; $digits
3362   1889 D7            push a
3363   188A DA            push d
3364   188B FA FA FF      lea d, [bp + -6] ; $i
3365   188E 2A            mov b, [d]
3366   188F 38 00 00      mov c, 0
3367   1892 E7            pop d
3368   1893 5A            add d, b
3369   1894 E4            pop a
3370   1895 DA            push d
3371   1896 FD 2E 30 00   mov32 cb, $00000030
3371   189A 00 00 
3372   189C             ; --- START TERMS
3373   189C D7            push a
3374   189D 11            mov a, b
3375   189E FA 07 00      lea d, [bp + 7] ; $num
3376   18A1 2A            mov b, [d]
3377   18A2 38 00 00      mov c, 0
3378   18A5             ; --- START FACTORS
3379   18A5 D7            push a
3380   18A6 11            mov a, b
3381   18A7 FD 2E 0A 00   mov32 cb, $0000000a
3381   18AB 00 00 
3382   18AD AE            div a, b ; 
3383   18AE 11            mov a, b
3384   18AF 27            mov b, a
3385   18B0 E4            pop a
3386   18B1             ; --- END FACTORS
3387   18B1 56            add b, a
3388   18B2 E4            pop a
3389   18B3             ; --- END TERMS
3390   18B3 E7            pop d
3391   18B4 FD 3E         mov [d], bl
3392   18B6             ; num = num / 10; 
3393   18B6 FA 07 00      lea d, [bp + 7] ; $num
3394   18B9 DA            push d
3395   18BA FA 07 00      lea d, [bp + 7] ; $num
3396   18BD 2A            mov b, [d]
3397   18BE 38 00 00      mov c, 0
3398   18C1             ; --- START FACTORS
3399   18C1 D7            push a
3400   18C2 11            mov a, b
3401   18C3 FD 2E 0A 00   mov32 cb, $0000000a
3401   18C7 00 00 
3402   18C9 AE            div a, b
3403   18CA 27            mov b, a
3404   18CB E4            pop a
3405   18CC             ; --- END FACTORS
3406   18CC E7            pop d
3407   18CD FD 43         mov [d], b
3408   18CF             ; i++; 
3409   18CF FA FA FF      lea d, [bp + -6] ; $i
3410   18D2 2A            mov b, [d]
3411   18D3 38 00 00      mov c, 0
3412   18D6 FD 77         inc b
3413   18D8 FA FA FF      lea d, [bp + -6] ; $i
3414   18DB FD 43         mov [d], b
3415   18DD FD 7D         dec b
3416   18DF 0A 6D 18      jmp _while46_cond
3417   18E2             _while46_exit:
3418   18E2             ; while (i > 0) { 
3419   18E2             _while47_cond:
3420   18E2 FA FA FF      lea d, [bp + -6] ; $i
3421   18E5 2A            mov b, [d]
3422   18E6 38 00 00      mov c, 0
3423   18E9             ; --- START RELATIONAL
3424   18E9 D7            push a
3425   18EA 11            mov a, b
3426   18EB FD 2E 00 00   mov32 cb, $00000000
3426   18EF 00 00 
3427   18F1 B0            cmp a, b
3428   18F2 FD 7F         sgt ; >
3429   18F4 E4            pop a
3430   18F5             ; --- END RELATIONAL
3431   18F5 C0 00 00      cmp b, 0
3432   18F8 C6 47 19      je _while47_exit
3433   18FB             _while47_block:
3434   18FB             ; i--; 
3435   18FB FA FA FF      lea d, [bp + -6] ; $i
3436   18FE 2A            mov b, [d]
3437   18FF 38 00 00      mov c, 0
3438   1902 FD 7D         dec b
3439   1904 FA FA FF      lea d, [bp + -6] ; $i
3440   1907 FD 43         mov [d], b
3441   1909 FD 77         inc b
3442   190B             ; *dest++ = digits[i]; 
3443   190B FA 05 00      lea d, [bp + 5] ; $dest
3444   190E 2A            mov b, [d]
3445   190F 38 00 00      mov c, 0
3446   1912 FD 77         inc b
3447   1914 FA 05 00      lea d, [bp + 5] ; $dest
3448   1917 FD 43         mov [d], b
3449   1919 FD 7D         dec b
3450   191B D8            push b
3451   191C FA FC FF      lea d, [bp + -4] ; $digits
3452   191F D7            push a
3453   1920 DA            push d
3454   1921 FA FA FF      lea d, [bp + -6] ; $i
3455   1924 2A            mov b, [d]
3456   1925 38 00 00      mov c, 0
3457   1928 E7            pop d
3458   1929 5A            add d, b
3459   192A E4            pop a
3460   192B 32            mov bl, [d]
3461   192C A7 00         mov bh, 0
3462   192E 38 00 00      mov c, 0
3463   1931 E7            pop d
3464   1932 FD 3E         mov [d], bl
3465   1934             ; len++; 
3466   1934 FA F8 FF      lea d, [bp + -8] ; $len
3467   1937 2A            mov b, [d]
3468   1938 38 00 00      mov c, 0
3469   193B FD 77         inc b
3470   193D FA F8 FF      lea d, [bp + -8] ; $len
3471   1940 FD 43         mov [d], b
3472   1942 FD 7D         dec b
3473   1944 0A E2 18      jmp _while47_cond
3474   1947             _while47_exit:
3475   1947             ; *dest = '\0'; 
3476   1947 FA 05 00      lea d, [bp + 5] ; $dest
3477   194A 2A            mov b, [d]
3478   194B 38 00 00      mov c, 0
3479   194E D8            push b
3480   194F FD 2E 00 00   mov32 cb, $00000000
3480   1953 00 00 
3481   1955 E7            pop d
3482   1956 FD 3E         mov [d], bl
3483   1958             ; return len; 
3484   1958 FA F8 FF      lea d, [bp + -8] ; $len
3485   195B 2A            mov b, [d]
3486   195C 38 00 00      mov c, 0
3487   195F F9            leave
3488   1960 09            ret
3489   1961             
3490   1961             print_unsigned:
3491   1961 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3492   1964             ; char digits[5]; 
3493   1964 52 05 00      sub sp, 5
3494   1967             ; int i; 
3495   1967 52 02 00      sub sp, 2
3496   196A             ; i = 0; 
3497   196A FA FA FF      lea d, [bp + -6] ; $i
3498   196D DA            push d
3499   196E FD 2E 00 00   mov32 cb, $00000000
3499   1972 00 00 
3500   1974 E7            pop d
3501   1975 FD 43         mov [d], b
3502   1977             ; if(num == 0){ 
3503   1977             _if48_cond:
3504   1977 FA 05 00      lea d, [bp + 5] ; $num
3505   197A 2A            mov b, [d]
3506   197B 38 00 00      mov c, 0
3507   197E             ; --- START RELATIONAL
3508   197E D7            push a
3509   197F 11            mov a, b
3510   1980 FD 2E 00 00   mov32 cb, $00000000
3510   1984 00 00 
3511   1986 B0            cmp a, b
3512   1987 FD 71         seq ; ==
3513   1989 E4            pop a
3514   198A             ; --- END RELATIONAL
3515   198A C0 00 00      cmp b, 0
3516   198D C6 A2 19      je _if48_exit
3517   1990             _if48_true:
3518   1990             ; putchar('0'); 
3519   1990             ; --- START FUNCTION CALL
3520   1990 FD 2E 30 00   mov32 cb, $00000030
3520   1994 00 00 
3521   1996 DD            push bl
3522   1997 07 29 1C      call putchar
3523   199A 51 01 00      add sp, 1
3524   199D             ; --- END FUNCTION CALL
3525   199D             ; return; 
3526   199D F9            leave
3527   199E 09            ret
3528   199F 0A A2 19      jmp _if48_exit
3529   19A2             _if48_exit:
3530   19A2             ; while (num > 0) { 
3531   19A2             _while49_cond:
3532   19A2 FA 05 00      lea d, [bp + 5] ; $num
3533   19A5 2A            mov b, [d]
3534   19A6 38 00 00      mov c, 0
3535   19A9             ; --- START RELATIONAL
3536   19A9 D7            push a
3537   19AA 11            mov a, b
3538   19AB FD 2E 00 00   mov32 cb, $00000000
3538   19AF 00 00 
3539   19B1 B0            cmp a, b
3540   19B2 FD 81         sgu ; > (unsigned)
3541   19B4 E4            pop a
3542   19B5             ; --- END RELATIONAL
3543   19B5 C0 00 00      cmp b, 0
3544   19B8 C6 17 1A      je _while49_exit
3545   19BB             _while49_block:
3546   19BB             ; digits[i] = '0' + (num % 10); 
3547   19BB FA FC FF      lea d, [bp + -4] ; $digits
3548   19BE D7            push a
3549   19BF DA            push d
3550   19C0 FA FA FF      lea d, [bp + -6] ; $i
3551   19C3 2A            mov b, [d]
3552   19C4 38 00 00      mov c, 0
3553   19C7 E7            pop d
3554   19C8 5A            add d, b
3555   19C9 E4            pop a
3556   19CA DA            push d
3557   19CB FD 2E 30 00   mov32 cb, $00000030
3557   19CF 00 00 
3558   19D1             ; --- START TERMS
3559   19D1 D7            push a
3560   19D2 11            mov a, b
3561   19D3 FA 05 00      lea d, [bp + 5] ; $num
3562   19D6 2A            mov b, [d]
3563   19D7 38 00 00      mov c, 0
3564   19DA             ; --- START FACTORS
3565   19DA D7            push a
3566   19DB 11            mov a, b
3567   19DC FD 2E 0A 00   mov32 cb, $0000000a
3567   19E0 00 00 
3568   19E2 AE            div a, b ; 
3569   19E3 11            mov a, b
3570   19E4 27            mov b, a
3571   19E5 E4            pop a
3572   19E6             ; --- END FACTORS
3573   19E6 56            add b, a
3574   19E7 E4            pop a
3575   19E8             ; --- END TERMS
3576   19E8 E7            pop d
3577   19E9 FD 3E         mov [d], bl
3578   19EB             ; num = num / 10; 
3579   19EB FA 05 00      lea d, [bp + 5] ; $num
3580   19EE DA            push d
3581   19EF FA 05 00      lea d, [bp + 5] ; $num
3582   19F2 2A            mov b, [d]
3583   19F3 38 00 00      mov c, 0
3584   19F6             ; --- START FACTORS
3585   19F6 D7            push a
3586   19F7 11            mov a, b
3587   19F8 FD 2E 0A 00   mov32 cb, $0000000a
3587   19FC 00 00 
3588   19FE AE            div a, b
3589   19FF 27            mov b, a
3590   1A00 E4            pop a
3591   1A01             ; --- END FACTORS
3592   1A01 E7            pop d
3593   1A02 FD 43         mov [d], b
3594   1A04             ; i++; 
3595   1A04 FA FA FF      lea d, [bp + -6] ; $i
3596   1A07 2A            mov b, [d]
3597   1A08 38 00 00      mov c, 0
3598   1A0B FD 77         inc b
3599   1A0D FA FA FF      lea d, [bp + -6] ; $i
3600   1A10 FD 43         mov [d], b
3601   1A12 FD 7D         dec b
3602   1A14 0A A2 19      jmp _while49_cond
3603   1A17             _while49_exit:
3604   1A17             ; while (i > 0) { 
3605   1A17             _while50_cond:
3606   1A17 FA FA FF      lea d, [bp + -6] ; $i
3607   1A1A 2A            mov b, [d]
3608   1A1B 38 00 00      mov c, 0
3609   1A1E             ; --- START RELATIONAL
3610   1A1E D7            push a
3611   1A1F 11            mov a, b
3612   1A20 FD 2E 00 00   mov32 cb, $00000000
3612   1A24 00 00 
3613   1A26 B0            cmp a, b
3614   1A27 FD 7F         sgt ; >
3615   1A29 E4            pop a
3616   1A2A             ; --- END RELATIONAL
3617   1A2A C0 00 00      cmp b, 0
3618   1A2D C6 5F 1A      je _while50_exit
3619   1A30             _while50_block:
3620   1A30             ; i--; 
3621   1A30 FA FA FF      lea d, [bp + -6] ; $i
3622   1A33 2A            mov b, [d]
3623   1A34 38 00 00      mov c, 0
3624   1A37 FD 7D         dec b
3625   1A39 FA FA FF      lea d, [bp + -6] ; $i
3626   1A3C FD 43         mov [d], b
3627   1A3E FD 77         inc b
3628   1A40             ; putchar(digits[i]); 
3629   1A40             ; --- START FUNCTION CALL
3630   1A40 FA FC FF      lea d, [bp + -4] ; $digits
3631   1A43 D7            push a
3632   1A44 DA            push d
3633   1A45 FA FA FF      lea d, [bp + -6] ; $i
3634   1A48 2A            mov b, [d]
3635   1A49 38 00 00      mov c, 0
3636   1A4C E7            pop d
3637   1A4D 5A            add d, b
3638   1A4E E4            pop a
3639   1A4F 32            mov bl, [d]
3640   1A50 A7 00         mov bh, 0
3641   1A52 38 00 00      mov c, 0
3642   1A55 DD            push bl
3643   1A56 07 29 1C      call putchar
3644   1A59 51 01 00      add sp, 1
3645   1A5C             ; --- END FUNCTION CALL
3646   1A5C 0A 17 1A      jmp _while50_cond
3647   1A5F             _while50_exit:
3648   1A5F F9            leave
3649   1A60 09            ret
3650   1A61             
3651   1A61             sprint_signed:
3652   1A61 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3653   1A64             ; char digits[5]; 
3654   1A64 52 05 00      sub sp, 5
3655   1A67             ; int i = 0; 
3656   1A67 52 02 00      sub sp, 2
3657   1A6A             ; --- START LOCAL VAR INITIALIZATION
3658   1A6A FA FA FF      lea d, [bp + -6] ; $i
3659   1A6D DA            push d
3660   1A6E FD 2E 00 00   mov32 cb, $00000000
3660   1A72 00 00 
3661   1A74 E7            pop d
3662   1A75 FD 43         mov [d], b
3663   1A77             ; --- END LOCAL VAR INITIALIZATION
3664   1A77             ; int len = 0; 
3665   1A77 52 02 00      sub sp, 2
3666   1A7A             ; --- START LOCAL VAR INITIALIZATION
3667   1A7A FA F8 FF      lea d, [bp + -8] ; $len
3668   1A7D DA            push d
3669   1A7E FD 2E 00 00   mov32 cb, $00000000
3669   1A82 00 00 
3670   1A84 E7            pop d
3671   1A85 FD 43         mov [d], b
3672   1A87             ; --- END LOCAL VAR INITIALIZATION
3673   1A87             ; if (num < 0) { 
3674   1A87             _if51_cond:
3675   1A87 FA 07 00      lea d, [bp + 7] ; $num
3676   1A8A 2A            mov b, [d]
3677   1A8B 38 00 00      mov c, 0
3678   1A8E             ; --- START RELATIONAL
3679   1A8E D7            push a
3680   1A8F 11            mov a, b
3681   1A90 FD 2E 00 00   mov32 cb, $00000000
3681   1A94 00 00 
3682   1A96 B0            cmp a, b
3683   1A97 FD 73         slt ; < (signed)
3684   1A99 E4            pop a
3685   1A9A             ; --- END RELATIONAL
3686   1A9A C0 00 00      cmp b, 0
3687   1A9D C6 DD 1A      je _if51_else
3688   1AA0             _if51_true:
3689   1AA0             ; *dest++ = '-'; 
3690   1AA0 FA 05 00      lea d, [bp + 5] ; $dest
3691   1AA3 2A            mov b, [d]
3692   1AA4 38 00 00      mov c, 0
3693   1AA7 FD 77         inc b
3694   1AA9 FA 05 00      lea d, [bp + 5] ; $dest
3695   1AAC FD 43         mov [d], b
3696   1AAE FD 7D         dec b
3697   1AB0 D8            push b
3698   1AB1 FD 2E 2D 00   mov32 cb, $0000002d
3698   1AB5 00 00 
3699   1AB7 E7            pop d
3700   1AB8 FD 3E         mov [d], bl
3701   1ABA             ; num = -num; 
3702   1ABA FA 07 00      lea d, [bp + 7] ; $num
3703   1ABD DA            push d
3704   1ABE FA 07 00      lea d, [bp + 7] ; $num
3705   1AC1 2A            mov b, [d]
3706   1AC2 38 00 00      mov c, 0
3707   1AC5 FD 97         neg b
3708   1AC7 E7            pop d
3709   1AC8 FD 43         mov [d], b
3710   1ACA             ; len++; 
3711   1ACA FA F8 FF      lea d, [bp + -8] ; $len
3712   1ACD 2A            mov b, [d]
3713   1ACE 38 00 00      mov c, 0
3714   1AD1 FD 77         inc b
3715   1AD3 FA F8 FF      lea d, [bp + -8] ; $len
3716   1AD6 FD 43         mov [d], b
3717   1AD8 FD 7D         dec b
3718   1ADA 0A 2C 1B      jmp _if51_exit
3719   1ADD             _if51_else:
3720   1ADD             ; if (num == 0) { 
3721   1ADD             _if52_cond:
3722   1ADD FA 07 00      lea d, [bp + 7] ; $num
3723   1AE0 2A            mov b, [d]
3724   1AE1 38 00 00      mov c, 0
3725   1AE4             ; --- START RELATIONAL
3726   1AE4 D7            push a
3727   1AE5 11            mov a, b
3728   1AE6 FD 2E 00 00   mov32 cb, $00000000
3728   1AEA 00 00 
3729   1AEC B0            cmp a, b
3730   1AED FD 71         seq ; ==
3731   1AEF E4            pop a
3732   1AF0             ; --- END RELATIONAL
3733   1AF0 C0 00 00      cmp b, 0
3734   1AF3 C6 2C 1B      je _if52_exit
3735   1AF6             _if52_true:
3736   1AF6             ; *dest++ = '0'; 
3737   1AF6 FA 05 00      lea d, [bp + 5] ; $dest
3738   1AF9 2A            mov b, [d]
3739   1AFA 38 00 00      mov c, 0
3740   1AFD FD 77         inc b
3741   1AFF FA 05 00      lea d, [bp + 5] ; $dest
3742   1B02 FD 43         mov [d], b
3743   1B04 FD 7D         dec b
3744   1B06 D8            push b
3745   1B07 FD 2E 30 00   mov32 cb, $00000030
3745   1B0B 00 00 
3746   1B0D E7            pop d
3747   1B0E FD 3E         mov [d], bl
3748   1B10             ; *dest = '\0'; 
3749   1B10 FA 05 00      lea d, [bp + 5] ; $dest
3750   1B13 2A            mov b, [d]
3751   1B14 38 00 00      mov c, 0
3752   1B17 D8            push b
3753   1B18 FD 2E 00 00   mov32 cb, $00000000
3753   1B1C 00 00 
3754   1B1E E7            pop d
3755   1B1F FD 3E         mov [d], bl
3756   1B21             ; return 1; 
3757   1B21 FD 2E 01 00   mov32 cb, $00000001
3757   1B25 00 00 
3758   1B27 F9            leave
3759   1B28 09            ret
3760   1B29 0A 2C 1B      jmp _if52_exit
3761   1B2C             _if52_exit:
3762   1B2C             _if51_exit:
3763   1B2C             ; while (num > 0) { 
3764   1B2C             _while53_cond:
3765   1B2C FA 07 00      lea d, [bp + 7] ; $num
3766   1B2F 2A            mov b, [d]
3767   1B30 38 00 00      mov c, 0
3768   1B33             ; --- START RELATIONAL
3769   1B33 D7            push a
3770   1B34 11            mov a, b
3771   1B35 FD 2E 00 00   mov32 cb, $00000000
3771   1B39 00 00 
3772   1B3B B0            cmp a, b
3773   1B3C FD 7F         sgt ; >
3774   1B3E E4            pop a
3775   1B3F             ; --- END RELATIONAL
3776   1B3F C0 00 00      cmp b, 0
3777   1B42 C6 A1 1B      je _while53_exit
3778   1B45             _while53_block:
3779   1B45             ; digits[i] = '0' + (num % 10); 
3780   1B45 FA FC FF      lea d, [bp + -4] ; $digits
3781   1B48 D7            push a
3782   1B49 DA            push d
3783   1B4A FA FA FF      lea d, [bp + -6] ; $i
3784   1B4D 2A            mov b, [d]
3785   1B4E 38 00 00      mov c, 0
3786   1B51 E7            pop d
3787   1B52 5A            add d, b
3788   1B53 E4            pop a
3789   1B54 DA            push d
3790   1B55 FD 2E 30 00   mov32 cb, $00000030
3790   1B59 00 00 
3791   1B5B             ; --- START TERMS
3792   1B5B D7            push a
3793   1B5C 11            mov a, b
3794   1B5D FA 07 00      lea d, [bp + 7] ; $num
3795   1B60 2A            mov b, [d]
3796   1B61 38 00 00      mov c, 0
3797   1B64             ; --- START FACTORS
3798   1B64 D7            push a
3799   1B65 11            mov a, b
3800   1B66 FD 2E 0A 00   mov32 cb, $0000000a
3800   1B6A 00 00 
3801   1B6C AE            div a, b ; 
3802   1B6D 11            mov a, b
3803   1B6E 27            mov b, a
3804   1B6F E4            pop a
3805   1B70             ; --- END FACTORS
3806   1B70 56            add b, a
3807   1B71 E4            pop a
3808   1B72             ; --- END TERMS
3809   1B72 E7            pop d
3810   1B73 FD 3E         mov [d], bl
3811   1B75             ; num = num / 10; 
3812   1B75 FA 07 00      lea d, [bp + 7] ; $num
3813   1B78 DA            push d
3814   1B79 FA 07 00      lea d, [bp + 7] ; $num
3815   1B7C 2A            mov b, [d]
3816   1B7D 38 00 00      mov c, 0
3817   1B80             ; --- START FACTORS
3818   1B80 D7            push a
3819   1B81 11            mov a, b
3820   1B82 FD 2E 0A 00   mov32 cb, $0000000a
3820   1B86 00 00 
3821   1B88 AE            div a, b
3822   1B89 27            mov b, a
3823   1B8A E4            pop a
3824   1B8B             ; --- END FACTORS
3825   1B8B E7            pop d
3826   1B8C FD 43         mov [d], b
3827   1B8E             ; i++; 
3828   1B8E FA FA FF      lea d, [bp + -6] ; $i
3829   1B91 2A            mov b, [d]
3830   1B92 38 00 00      mov c, 0
3831   1B95 FD 77         inc b
3832   1B97 FA FA FF      lea d, [bp + -6] ; $i
3833   1B9A FD 43         mov [d], b
3834   1B9C FD 7D         dec b
3835   1B9E 0A 2C 1B      jmp _while53_cond
3836   1BA1             _while53_exit:
3837   1BA1             ; while (i > 0) { 
3838   1BA1             _while54_cond:
3839   1BA1 FA FA FF      lea d, [bp + -6] ; $i
3840   1BA4 2A            mov b, [d]
3841   1BA5 38 00 00      mov c, 0
3842   1BA8             ; --- START RELATIONAL
3843   1BA8 D7            push a
3844   1BA9 11            mov a, b
3845   1BAA FD 2E 00 00   mov32 cb, $00000000
3845   1BAE 00 00 
3846   1BB0 B0            cmp a, b
3847   1BB1 FD 7F         sgt ; >
3848   1BB3 E4            pop a
3849   1BB4             ; --- END RELATIONAL
3850   1BB4 C0 00 00      cmp b, 0
3851   1BB7 C6 06 1C      je _while54_exit
3852   1BBA             _while54_block:
3853   1BBA             ; i--; 
3854   1BBA FA FA FF      lea d, [bp + -6] ; $i
3855   1BBD 2A            mov b, [d]
3856   1BBE 38 00 00      mov c, 0
3857   1BC1 FD 7D         dec b
3858   1BC3 FA FA FF      lea d, [bp + -6] ; $i
3859   1BC6 FD 43         mov [d], b
3860   1BC8 FD 77         inc b
3861   1BCA             ; *dest++ = digits[i]; 
3862   1BCA FA 05 00      lea d, [bp + 5] ; $dest
3863   1BCD 2A            mov b, [d]
3864   1BCE 38 00 00      mov c, 0
3865   1BD1 FD 77         inc b
3866   1BD3 FA 05 00      lea d, [bp + 5] ; $dest
3867   1BD6 FD 43         mov [d], b
3868   1BD8 FD 7D         dec b
3869   1BDA D8            push b
3870   1BDB FA FC FF      lea d, [bp + -4] ; $digits
3871   1BDE D7            push a
3872   1BDF DA            push d
3873   1BE0 FA FA FF      lea d, [bp + -6] ; $i
3874   1BE3 2A            mov b, [d]
3875   1BE4 38 00 00      mov c, 0
3876   1BE7 E7            pop d
3877   1BE8 5A            add d, b
3878   1BE9 E4            pop a
3879   1BEA 32            mov bl, [d]
3880   1BEB A7 00         mov bh, 0
3881   1BED 38 00 00      mov c, 0
3882   1BF0 E7            pop d
3883   1BF1 FD 3E         mov [d], bl
3884   1BF3             ; len++; 
3885   1BF3 FA F8 FF      lea d, [bp + -8] ; $len
3886   1BF6 2A            mov b, [d]
3887   1BF7 38 00 00      mov c, 0
3888   1BFA FD 77         inc b
3889   1BFC FA F8 FF      lea d, [bp + -8] ; $len
3890   1BFF FD 43         mov [d], b
3891   1C01 FD 7D         dec b
3892   1C03 0A A1 1B      jmp _while54_cond
3893   1C06             _while54_exit:
3894   1C06             ; *dest = '\0'; 
3895   1C06 FA 05 00      lea d, [bp + 5] ; $dest
3896   1C09 2A            mov b, [d]
3897   1C0A 38 00 00      mov c, 0
3898   1C0D D8            push b
3899   1C0E FD 2E 00 00   mov32 cb, $00000000
3899   1C12 00 00 
3900   1C14 E7            pop d
3901   1C15 FD 3E         mov [d], bl
3902   1C17             ; return len; 
3903   1C17 FA F8 FF      lea d, [bp + -8] ; $len
3904   1C1A 2A            mov b, [d]
3905   1C1B 38 00 00      mov c, 0
3906   1C1E F9            leave
3907   1C1F 09            ret
3908   1C20             
3909   1C20             date:
3910   1C20 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3911   1C23             
3912   1C23             ; --- BEGIN INLINE ASM SEGMENT
3913   1C23 19 00         mov al, 0 
3914   1C25 05 07         syscall sys_datetime
3915   1C27             ; --- END INLINE ASM SEGMENT
3916   1C27             
3917   1C27 F9            leave
3918   1C28 09            ret
3919   1C29             
3920   1C29             putchar:
3921   1C29 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3922   1C2C             
3923   1C2C             ; --- BEGIN INLINE ASM SEGMENT
3924   1C2C FA 05 00      lea d, [bp + 5] ; $c
3925   1C2F 1E            mov al, [d]
3926   1C30 23            mov ah, al
3927   1C31 07 38 1E      call _putchar
3928   1C34             ; --- END INLINE ASM SEGMENT
3929   1C34             
3930   1C34 F9            leave
3931   1C35 09            ret
3932   1C36             
3933   1C36             getchar:
3934   1C36 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3935   1C39             ; char c; 
3936   1C39 52 01 00      sub sp, 1
3937   1C3C             
3938   1C3C             ; --- BEGIN INLINE ASM SEGMENT
3939   1C3C 07 31 1E      call getch
3940   1C3F 1A            mov al, ah
3941   1C40 FA 00 00      lea d, [bp + 0] ; $c
3942   1C43 3E            mov [d], al
3943   1C44             ; --- END INLINE ASM SEGMENT
3944   1C44             
3945   1C44             ; return c; 
3946   1C44 FA 00 00      lea d, [bp + 0] ; $c
3947   1C47 32            mov bl, [d]
3948   1C48 A7 00         mov bh, 0
3949   1C4A 38 00 00      mov c, 0
3950   1C4D F9            leave
3951   1C4E 09            ret
3952   1C4F             
3953   1C4F             scann:
3954   1C4F F8 00 00      enter 0 ; (push bp; mov bp, sp)
3955   1C52             ; int m; 
3956   1C52 52 02 00      sub sp, 2
3957   1C55             
3958   1C55             ; --- BEGIN INLINE ASM SEGMENT
3959   1C55 07 7C 20      call scan_u16d
3960   1C58 FA FF FF      lea d, [bp + -1] ; $m
3961   1C5B 43            mov [d], a
3962   1C5C             ; --- END INLINE ASM SEGMENT
3963   1C5C             
3964   1C5C             ; return m; 
3965   1C5C FA FF FF      lea d, [bp + -1] ; $m
3966   1C5F 2A            mov b, [d]
3967   1C60 38 00 00      mov c, 0
3968   1C63 F9            leave
3969   1C64 09            ret
3970   1C65             
3971   1C65             puts:
3972   1C65 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3973   1C68             
3974   1C68             ; --- BEGIN INLINE ASM SEGMENT
3975   1C68 FA 05 00      lea d, [bp + 5] ; $s
3976   1C6B 15            mov a, [d]
3977   1C6C 3C            mov d, a
3978   1C6D 07 82 1F      call _puts
3979   1C70 10 00 0A      mov a, $0A00
3980   1C73 05 03         syscall sys_io
3981   1C75             ; --- END INLINE ASM SEGMENT
3982   1C75             
3983   1C75 F9            leave
3984   1C76 09            ret
3985   1C77             
3986   1C77             print:
3987   1C77 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3988   1C7A             
3989   1C7A             ; --- BEGIN INLINE ASM SEGMENT
3990   1C7A FA 05 00      lea d, [bp + 5] ; $s
3991   1C7D FD 2A         mov d, [d]
3992   1C7F 07 82 1F      call _puts
3993   1C82             ; --- END INLINE ASM SEGMENT
3994   1C82             
3995   1C82 F9            leave
3996   1C83 09            ret
3997   1C84             
3998   1C84             getparam:
3999   1C84 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4000   1C87             ; char data; 
4001   1C87 52 01 00      sub sp, 1
4002   1C8A             
4003   1C8A             ; --- BEGIN INLINE ASM SEGMENT
4004   1C8A 19 04         mov al, 4
4005   1C8C FA 05 00      lea d, [bp + 5] ; $address
4006   1C8F FD 2A         mov d, [d]
4007   1C91 05 0C         syscall sys_system
4008   1C93 FA 00 00      lea d, [bp + 0] ; $data
4009   1C96 FD 3E         mov [d], bl
4010   1C98             ; --- END INLINE ASM SEGMENT
4011   1C98             
4012   1C98             ; return data; 
4013   1C98 FA 00 00      lea d, [bp + 0] ; $data
4014   1C9B 32            mov bl, [d]
4015   1C9C A7 00         mov bh, 0
4016   1C9E 38 00 00      mov c, 0
4017   1CA1 F9            leave
4018   1CA2 09            ret
4019   1CA3             
4020   1CA3             clear:
4021   1CA3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4022   1CA6             ; print("\033[2J\033[H"); 
4023   1CA6             ; --- START FUNCTION CALL
4024   1CA6 26 18 21      mov b, _s2 ; "\033[2J\033[H"
4025   1CA9 FD AB         swp b
4026   1CAB D8            push b
4027   1CAC 07 77 1C      call print
4028   1CAF 51 02 00      add sp, 2
4029   1CB2             ; --- END FUNCTION CALL
4030   1CB2 F9            leave
4031   1CB3 09            ret
4032   1CB4             
4033   1CB4             abs:
4034   1CB4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4035   1CB7             ; return i < 0 ? -i : i; 
4036   1CB7             _ternary55_cond:
4037   1CB7 FA 05 00      lea d, [bp + 5] ; $i
4038   1CBA 2A            mov b, [d]
4039   1CBB 38 00 00      mov c, 0
4040   1CBE             ; --- START RELATIONAL
4041   1CBE D7            push a
4042   1CBF 11            mov a, b
4043   1CC0 FD 2E 00 00   mov32 cb, $00000000
4043   1CC4 00 00 
4044   1CC6 B0            cmp a, b
4045   1CC7 FD 73         slt ; < (signed)
4046   1CC9 E4            pop a
4047   1CCA             ; --- END RELATIONAL
4048   1CCA C0 00 00      cmp b, 0
4049   1CCD C6 DC 1C      je _ternary55_false
4050   1CD0             _ternary55_true:
4051   1CD0 FA 05 00      lea d, [bp + 5] ; $i
4052   1CD3 2A            mov b, [d]
4053   1CD4 38 00 00      mov c, 0
4054   1CD7 FD 97         neg b
4055   1CD9 0A E3 1C      jmp _ternary55_exit
4056   1CDC             _ternary55_false:
4057   1CDC FA 05 00      lea d, [bp + 5] ; $i
4058   1CDF 2A            mov b, [d]
4059   1CE0 38 00 00      mov c, 0
4060   1CE3             _ternary55_exit:
4061   1CE3 F9            leave
4062   1CE4 09            ret
4063   1CE5             
4064   1CE5             loadfile:
4065   1CE5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4066   1CE8             
4067   1CE8             ; --- BEGIN INLINE ASM SEGMENT
4068   1CE8 FA 07 00      lea d, [bp + 7] ; $destination
4069   1CEB 15            mov a, [d]
4070   1CEC 4F            mov di, a
4071   1CED FA 05 00      lea d, [bp + 5] ; $filename
4072   1CF0 FD 2A         mov d, [d]
4073   1CF2 19 14         mov al, 20
4074   1CF4 05 04         syscall sys_filesystem
4075   1CF6             ; --- END INLINE ASM SEGMENT
4076   1CF6             
4077   1CF6 F9            leave
4078   1CF7 09            ret
4079   1CF8             
4080   1CF8             create_file:
4081   1CF8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4082   1CFB F9            leave
4083   1CFC 09            ret
4084   1CFD             
4085   1CFD             delete_file:
4086   1CFD F8 00 00      enter 0 ; (push bp; mov bp, sp)
4087   1D00             
4088   1D00             ; --- BEGIN INLINE ASM SEGMENT
4089   1D00 FA 05 00      lea d, [bp + 5] ; $filename
4090   1D03 19 0A         mov al, 10
4091   1D05 05 04         syscall sys_filesystem
4092   1D07             ; --- END INLINE ASM SEGMENT
4093   1D07             
4094   1D07 F9            leave
4095   1D08 09            ret
4096   1D09             
4097   1D09             load_hex:
4098   1D09 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4099   1D0C             ; char *temp; 
4100   1D0C 52 02 00      sub sp, 2
4101   1D0F             ; temp = alloc(32768); 
4102   1D0F FA FF FF      lea d, [bp + -1] ; $temp
4103   1D12 DA            push d
4104   1D13             ; --- START FUNCTION CALL
4105   1D13 FD 2E 00 80   mov32 cb, $00008000
4105   1D17 00 00 
4106   1D19 FD AB         swp b
4107   1D1B D8            push b
4108   1D1C 07 3A 08      call alloc
4109   1D1F 51 02 00      add sp, 2
4110   1D22             ; --- END FUNCTION CALL
4111   1D22 E7            pop d
4112   1D23 FD 43         mov [d], b
4113   1D25             
4114   1D25             ; --- BEGIN INLINE ASM SEGMENT
4115   1D25               
4116   1D25               
4117   1D25               
4118   1D25             _load_hex:
4119   1D25 FA 05 00      lea d, [bp + 5] ; $destination
4120   1D28 FD 2A         mov d, [d]
4121   1D2A FD 50         mov di, d
4122   1D2C FA FF FF      lea d, [bp + -1] ; $temp
4123   1D2F FD 2A         mov d, [d]
4124   1D31 38 00 00      mov c, 0
4125   1D34 48            mov a, sp
4126   1D35 77            inc a
4127   1D36 3C            mov d, a          
4128   1D37 07 3F 1E      call _gets        
4129   1D3A 4D            mov si, a
4130   1D3B             __load_hex_loop:
4131   1D3B F6            lodsb             
4132   1D3C B9 00         cmp al, 0         
4133   1D3E C6 4C 1D      jz __load_hex_ret
4134   1D41 36            mov bh, al
4135   1D42 F6            lodsb
4136   1D43 2F            mov bl, al
4137   1D44 07 F6 1D      call _atoi        
4138   1D47 F7            stosb             
4139   1D48 78            inc c
4140   1D49 0A 3B 1D      jmp __load_hex_loop
4141   1D4C             __load_hex_ret:
4142   1D4C             ; --- END INLINE ASM SEGMENT
4143   1D4C             
4144   1D4C F9            leave
4145   1D4D 09            ret
4146   1D4E             
4147   1D4E             include_stdio_asm:
4148   1D4E F8 00 00      enter 0 ; (push bp; mov bp, sp)
4149   1D51             
4150   1D51             ; --- BEGIN INLINE ASM SEGMENT
4151   1D51             .include "lib/asm/stdio.asm"
0001+  1D51             ;-----------------------------------------------------------------------------
0002+  1D51             ; stdio.s
0003+  1D51             ;-----------------------------------------------------------------------------
0004+  1D51             .include "lib/asm/string.asm"
0001++ 1D51             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 1D51             ; string.s
0003++ 1D51             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 1D51             
0005++ 1D51             
0006++ 1D51             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 1D51             ; _strrev
0008++ 1D51             ; reverse a string
0009++ 1D51             ; D = string address
0010++ 1D51             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 1D51             ; 01234
0012++ 1D51             _strrev:
0013++ 1D51 4B          	pusha
0014++ 1D52 07 98 1D    	call _strlen	; length in C
0015++ 1D55 12          	mov a, c
0016++ 1D56 AF 01 00    	cmp a, 1
0017++ 1D59 D0 73 1D    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 1D5C 7D          	dec a
0019++ 1D5D FD 4E       	mov si, d	; beginning of string
0020++ 1D5F FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 1D61 59          	add d, a	; end of string
0022++ 1D62 12          	mov a, c
0023++ 1D63 FD 9B       	shr a		; divide by 2
0024++ 1D65 39          	mov c, a	; C now counts the steps
0025++ 1D66             _strrev_L0:
0026++ 1D66 32          	mov bl, [d]	; save load right-side char into BL
0027++ 1D67 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 1D68 3E          	mov [d], al	; store left char into right side
0029++ 1D69 1B          	mov al, bl
0030++ 1D6A F7          	stosb		; store right-side char into left-side; increase DI
0031++ 1D6B 7E          	dec c
0032++ 1D6C 7F          	dec d
0033++ 1D6D C2 00 00    	cmp c, 0
0034++ 1D70 C7 66 1D    	jne _strrev_L0
0035++ 1D73             _strrev_end:
0036++ 1D73 4C          	popa
0037++ 1D74 09          	ret
0038++ 1D75             	
0039++ 1D75             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 1D75             ; _strchr
0041++ 1D75             ; search string in D for char in AL
0042++ 1D75             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 1D75             _strchr:
0044++ 1D75             _strchr_L0:
0045++ 1D75 32          	mov bl, [d]
0046++ 1D76 C1 00       	cmp bl, 0
0047++ 1D78 C6 83 1D    	je _strchr_end
0048++ 1D7B BA          	cmp al, bl
0049++ 1D7C C6 83 1D    	je _strchr_end
0050++ 1D7F 79          	inc d
0051++ 1D80 0A 75 1D    	jmp _strchr_L0
0052++ 1D83             _strchr_end:
0053++ 1D83 1B          	mov al, bl
0054++ 1D84 09          	ret
0055++ 1D85             
0056++ 1D85             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 1D85             ; _strstr
0058++ 1D85             ; find sub-string
0059++ 1D85             ; str1 in SI
0060++ 1D85             ; str2 in DI
0061++ 1D85             ; SI points to end of source string
0062++ 1D85             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 1D85             _strstr:
0064++ 1D85 DB          	push al
0065++ 1D86 DA          	push d
0066++ 1D87 E3          	push di
0067++ 1D88             _strstr_loop:
0068++ 1D88 F3          	cmpsb					; compare a byte of the strings
0069++ 1D89 C7 94 1D    	jne _strstr_ret
0070++ 1D8C FC 00 00    	lea d, [di + 0]
0071++ 1D8F BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1D91 C7 88 1D    	jne _strstr_loop				; equal chars but not at end
0073++ 1D94             _strstr_ret:
0074++ 1D94 F0          	pop di
0075++ 1D95 E7          	pop d
0076++ 1D96 E8          	pop al
0077++ 1D97 09          	ret
0078++ 1D98             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1D98             ; length of null terminated string
0080++ 1D98             ; result in C
0081++ 1D98             ; pointer in D
0082++ 1D98             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1D98             _strlen:
0084++ 1D98 DA          	push d
0085++ 1D99 38 00 00    	mov c, 0
0086++ 1D9C             _strlen_L1:
0087++ 1D9C BD 00       	cmp byte [d], 0
0088++ 1D9E C6 A6 1D    	je _strlen_ret
0089++ 1DA1 79          	inc d
0090++ 1DA2 78          	inc c
0091++ 1DA3 0A 9C 1D    	jmp _strlen_L1
0092++ 1DA6             _strlen_ret:
0093++ 1DA6 E7          	pop d
0094++ 1DA7 09          	ret
0095++ 1DA8             
0096++ 1DA8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1DA8             ; STRCMP
0098++ 1DA8             ; compare two strings
0099++ 1DA8             ; str1 in SI
0100++ 1DA8             ; str2 in DI
0101++ 1DA8             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 1DA8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1DA8             _strcmp:
0104++ 1DA8 DB          	push al
0105++ 1DA9 DA          	push d
0106++ 1DAA E3          	push di
0107++ 1DAB E2          	push si
0108++ 1DAC             _strcmp_loop:
0109++ 1DAC F3          	cmpsb					; compare a byte of the strings
0110++ 1DAD C7 B8 1D    	jne _strcmp_ret
0111++ 1DB0 FB FF FF    	lea d, [si +- 1]
0112++ 1DB3 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1DB5 C7 AC 1D    	jne _strcmp_loop				; equal chars but not at end
0114++ 1DB8             _strcmp_ret:
0115++ 1DB8 EF          	pop si
0116++ 1DB9 F0          	pop di
0117++ 1DBA E7          	pop d
0118++ 1DBB E8          	pop al
0119++ 1DBC 09          	ret
0120++ 1DBD             
0121++ 1DBD             
0122++ 1DBD             ; STRCPY
0123++ 1DBD             ; copy null terminated string from SI to DI
0124++ 1DBD             ; source in SI
0125++ 1DBD             ; destination in DI
0126++ 1DBD             _strcpy:
0127++ 1DBD E2          	push si
0128++ 1DBE E3          	push di
0129++ 1DBF DB          	push al
0130++ 1DC0             _strcpy_L1:
0131++ 1DC0 F6          	lodsb
0132++ 1DC1 F7          	stosb
0133++ 1DC2 B9 00       	cmp al, 0
0134++ 1DC4 C7 C0 1D    	jne _strcpy_L1
0135++ 1DC7             _strcpy_end:
0136++ 1DC7 E8          	pop al
0137++ 1DC8 F0          	pop di
0138++ 1DC9 EF          	pop si
0139++ 1DCA 09          	ret
0140++ 1DCB             
0141++ 1DCB             ; STRCAT
0142++ 1DCB             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 1DCB             ; source in SI
0144++ 1DCB             ; destination in DI
0145++ 1DCB             _strcat:
0146++ 1DCB E2          	push si
0147++ 1DCC E3          	push di
0148++ 1DCD D7          	push a
0149++ 1DCE DA          	push d
0150++ 1DCF 50          	mov a, di
0151++ 1DD0 3C          	mov d, a
0152++ 1DD1             _strcat_goto_end_L1:
0153++ 1DD1 BD 00       	cmp byte[d], 0
0154++ 1DD3 C6 DA 1D    	je _strcat_start
0155++ 1DD6 79          	inc d
0156++ 1DD7 0A D1 1D    	jmp _strcat_goto_end_L1
0157++ 1DDA             _strcat_start:
0158++ 1DDA FD 50       	mov di, d
0159++ 1DDC             _strcat_L1:
0160++ 1DDC F6          	lodsb
0161++ 1DDD F7          	stosb
0162++ 1DDE B9 00       	cmp al, 0
0163++ 1DE0 C7 DC 1D    	jne _strcat_L1
0164++ 1DE3             _strcat_end:
0165++ 1DE3 E7          	pop d
0166++ 1DE4 E4          	pop a
0167++ 1DE5 F0          	pop di
0168++ 1DE6 EF          	pop si
0169++ 1DE7 09          	ret
0170++ 1DE8             
0171++ 1DE8             
0005+  1DE8             
0006+  1DE8             ;-----------------------------------------------------------------------------
0007+  1DE8             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0008+  1DE8             ; ASCII in BL
0009+  1DE8             ; result in AL
0010+  1DE8             ; ascii for F = 0100 0110
0011+  1DE8             ; ascii for 9 = 0011 1001
0012+  1DE8             ;-----------------------------------------------------------------------------
0013+  1DE8             hex_ascii_encode:
0014+  1DE8 1B            mov al, bl
0015+  1DE9 93 40         test al, $40        ; test if letter or number
0016+  1DEB C7 F1 1D      jnz hex_letter
0017+  1DEE 87 0F         and al, $0F        ; get number
0018+  1DF0 09            ret
0019+  1DF1             hex_letter:
0020+  1DF1 87 0F         and al, $0F        ; get letter
0021+  1DF3 6A 09         add al, 9
0022+  1DF5 09            ret
0023+  1DF6             
0024+  1DF6             ;-----------------------------------------------------------------------------
0025+  1DF6             ; ATOI
0026+  1DF6             ; 2 letter hex string in B
0027+  1DF6             ; 8bit integer returned in AL
0028+  1DF6             ;-----------------------------------------------------------------------------
0029+  1DF6             _atoi:
0030+  1DF6 D8            push b
0031+  1DF7 07 E8 1D      call hex_ascii_encode      ; convert BL to 4bit code in AL
0032+  1DFA 30            mov bl, bh
0033+  1DFB DB            push al          ; save a
0034+  1DFC 07 E8 1D      call hex_ascii_encode
0035+  1DFF EA            pop bl  
0036+  1E00 FD 9E 04      shl al, 4
0037+  1E03 8C            or al, bl
0038+  1E04 E5            pop b
0039+  1E05 09            ret  
0040+  1E06             
0041+  1E06             
0042+  1E06             ;-----------------------------------------------------------------------------
0043+  1E06             ; ITOA
0044+  1E06             ; 8bit value in BL
0045+  1E06             ; 2 byte ASCII result in A
0046+  1E06             ;-----------------------------------------------------------------------------
0047+  1E06             _itoa:
0048+  1E06 DA            push d
0049+  1E07 D8            push b
0050+  1E08 A7 00         mov bh, 0
0051+  1E0A FD A4 04      shr bl, 4  
0052+  1E0D 74            mov d, b
0053+  1E0E 1F B6 20      mov al, [d + s_hex_digits]
0054+  1E11 23            mov ah, al
0055+  1E12               
0056+  1E12 E5            pop b
0057+  1E13 D8            push b
0058+  1E14 A7 00         mov bh, 0
0059+  1E16 FD 87 0F      and bl, $0F
0060+  1E19 74            mov d, b
0061+  1E1A 1F B6 20      mov al, [d + s_hex_digits]
0062+  1E1D E5            pop b
0063+  1E1E E7            pop d
0064+  1E1F 09            ret
0065+  1E20             
0066+  1E20             ;-----------------------------------------------------------------------------
0067+  1E20             ; HEX STRING TO BINARY
0068+  1E20             ; di = destination address
0069+  1E20             ; si = source
0070+  1E20             ;-----------------------------------------------------------------------------
0071+  1E20             _hex_to_int:
0072+  1E20             _hex_to_int_L1:
0073+  1E20 F6            lodsb          ; load from [SI] to AL
0074+  1E21 B9 00         cmp al, 0        ; check if ASCII 0
0075+  1E23 C6 30 1E      jz _hex_to_int_ret
0076+  1E26 36            mov bh, al
0077+  1E27 F6            lodsb
0078+  1E28 2F            mov bl, al
0079+  1E29 07 F6 1D      call _atoi        ; convert ASCII byte in B to int (to AL)
0080+  1E2C F7            stosb          ; store AL to [DI]
0081+  1E2D 0A 20 1E      jmp _hex_to_int_L1
0082+  1E30             _hex_to_int_ret:
0083+  1E30 09            ret    
0084+  1E31             
0085+  1E31             ;-----------------------------------------------------------------------------
0086+  1E31             ; GETCHAR
0087+  1E31             ; char in ah
0088+  1E31             ;-----------------------------------------------------------------------------
0089+  1E31             getch:
0090+  1E31 DB            push al
0091+  1E32             getch_retry:
0092+  1E32 19 01         mov al, 1
0093+  1E34 05 03         syscall sys_io      ; receive in AH
0094+  1E36 E8            pop al
0095+  1E37 09            ret
0096+  1E38             
0097+  1E38             ;-----------------------------------------------------------------------------
0098+  1E38             ; PUTCHAR
0099+  1E38             ; char in ah
0100+  1E38             ;-----------------------------------------------------------------------------
0101+  1E38             _putchar:
0102+  1E38 D7            push a
0103+  1E39 19 00         mov al, 0
0104+  1E3B 05 03         syscall sys_io      ; char in AH
0105+  1E3D E4            pop a
0106+  1E3E 09            ret
0107+  1E3F             
0108+  1E3F             ;-----------------------------------------------------------------------------
0109+  1E3F             ;; INPUT A STRING
0110+  1E3F             ;; terminates with null
0111+  1E3F             ;; pointer in D
0112+  1E3F             ;-----------------------------------------------------------------------------
0113+  1E3F             _gets:
0114+  1E3F D7            push a
0115+  1E40 DA            push d
0116+  1E41             _gets_loop:
0117+  1E41 19 01         mov al, 1
0118+  1E43 05 03         syscall sys_io      ; receive in AH
0119+  1E45 B9 00         cmp al, 0        ; check error code (AL)
0120+  1E47 C6 41 1E      je _gets_loop      ; if no char received, retry
0121+  1E4A             
0122+  1E4A 76 1B         cmp ah, 27
0123+  1E4C C6 6D 1E      je _gets_ansi_esc
0124+  1E4F 76 0A         cmp ah, $0A        ; LF
0125+  1E51 C6 D8 1E      je _gets_end
0126+  1E54 76 0D         cmp ah, $0D        ; CR
0127+  1E56 C6 D8 1E      je _gets_end
0128+  1E59 76 5C         cmp ah, $5C        ; '\\'
0129+  1E5B C6 99 1E      je _gets_escape
0130+  1E5E               
0131+  1E5E 76 08         cmp ah, $08      ; check for backspace
0132+  1E60 C6 69 1E      je _gets_backspace
0133+  1E63             
0134+  1E63 1A            mov al, ah
0135+  1E64 3E            mov [d], al
0136+  1E65 79            inc d
0137+  1E66 0A 41 1E      jmp _gets_loop
0138+  1E69             _gets_backspace:
0139+  1E69 7F            dec d
0140+  1E6A 0A 41 1E      jmp _gets_loop
0141+  1E6D             _gets_ansi_esc:
0142+  1E6D 19 01         mov al, 1
0143+  1E6F 05 03         syscall sys_io        ; receive in AH without echo
0144+  1E71 B9 00         cmp al, 0          ; check error code (AL)
0145+  1E73 C6 6D 1E      je _gets_ansi_esc    ; if no char received, retry
0146+  1E76 76 5B         cmp ah, '['
0147+  1E78 C7 41 1E      jne _gets_loop
0148+  1E7B             _gets_ansi_esc_2:
0149+  1E7B 19 01         mov al, 1
0150+  1E7D 05 03         syscall sys_io          ; receive in AH without echo
0151+  1E7F B9 00         cmp al, 0            ; check error code (AL)
0152+  1E81 C6 7B 1E      je _gets_ansi_esc_2  ; if no char received, retry
0153+  1E84 76 44         cmp ah, 'D'
0154+  1E86 C6 91 1E      je _gets_left_arrow
0155+  1E89 76 43         cmp ah, 'C'
0156+  1E8B C6 95 1E      je _gets_right_arrow
0157+  1E8E 0A 41 1E      jmp _gets_loop
0158+  1E91             _gets_left_arrow:
0159+  1E91 7F            dec d
0160+  1E92 0A 41 1E      jmp _gets_loop
0161+  1E95             _gets_right_arrow:
0162+  1E95 79            inc d
0163+  1E96 0A 41 1E      jmp _gets_loop
0164+  1E99             _gets_escape:
0165+  1E99 19 01         mov al, 1
0166+  1E9B 05 03         syscall sys_io      ; receive in AH
0167+  1E9D B9 00         cmp al, 0        ; check error code (AL)
0168+  1E9F C6 99 1E      je _gets_escape      ; if no char received, retry
0169+  1EA2 76 6E         cmp ah, 'n'
0170+  1EA4 C6 C3 1E      je _gets_LF
0171+  1EA7 76 72         cmp ah, 'r'
0172+  1EA9 C6 CA 1E      je _gets_CR
0173+  1EAC 76 30         cmp ah, '0'
0174+  1EAE C6 D1 1E      je _gets_NULL
0175+  1EB1 76 5C         cmp ah, $5C  ; '\'
0176+  1EB3 C6 BC 1E      je _gets_slash
0177+  1EB6 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0178+  1EB7 3E            mov [d], al
0179+  1EB8 79            inc d
0180+  1EB9 0A 41 1E      jmp _gets_loop
0181+  1EBC             _gets_slash:
0182+  1EBC 19 5C         mov al, $5C
0183+  1EBE 3E            mov [d], al
0184+  1EBF 79            inc d
0185+  1EC0 0A 41 1E      jmp _gets_loop
0186+  1EC3             _gets_LF:
0187+  1EC3 19 0A         mov al, $0A
0188+  1EC5 3E            mov [d], al
0189+  1EC6 79            inc d
0190+  1EC7 0A 41 1E      jmp _gets_loop
0191+  1ECA             _gets_CR:
0192+  1ECA 19 0D         mov al, $0D
0193+  1ECC 3E            mov [d], al
0194+  1ECD 79            inc d
0195+  1ECE 0A 41 1E      jmp _gets_loop
0196+  1ED1             _gets_NULL:
0197+  1ED1 19 00         mov al, $00
0198+  1ED3 3E            mov [d], al
0199+  1ED4 79            inc d
0200+  1ED5 0A 41 1E      jmp _gets_loop
0201+  1ED8             _gets_end:
0202+  1ED8 19 00         mov al, 0
0203+  1EDA 3E            mov [d], al        ; terminate string
0204+  1EDB E7            pop d
0205+  1EDC E4            pop a
0206+  1EDD 09            ret
0207+  1EDE             
0208+  1EDE             ;-----------------------------------------------------------------------------
0209+  1EDE             ;; INPUT TEXT
0210+  1EDE             ;; terminated with CTRL+D
0211+  1EDE             ;; pointer in D
0212+  1EDE             ;-----------------------------------------------------------------------------
0213+  1EDE             _gettxt:
0214+  1EDE D7            push a
0215+  1EDF DA            push d
0216+  1EE0             _gettxt_loop:
0217+  1EE0 19 01         mov al, 1
0218+  1EE2 05 03         syscall sys_io      ; receive in AH
0219+  1EE4 B9 00         cmp al, 0        ; check error code (AL)
0220+  1EE6 C6 E0 1E      je _gettxt_loop    ; if no char received, retry
0221+  1EE9 76 04         cmp ah, 4      ; EOT
0222+  1EEB C6 29 1F      je _gettxt_end
0223+  1EEE 76 08         cmp ah, $08      ; check for backspace
0224+  1EF0 C6 25 1F      je _gettxt_backspace
0225+  1EF3 76 5C         cmp ah, $5C        ; '\'
0226+  1EF5 C6 FE 1E      je _gettxt_escape
0227+  1EF8 1A            mov al, ah
0228+  1EF9 3E            mov [d], al
0229+  1EFA 79            inc d
0230+  1EFB 0A E0 1E      jmp _gettxt_loop
0231+  1EFE             _gettxt_escape:
0232+  1EFE 19 01         mov al, 1
0233+  1F00 05 03         syscall sys_io      ; receive in AH
0234+  1F02 B9 00         cmp al, 0        ; check error code (AL)
0235+  1F04 C6 FE 1E      je _gettxt_escape    ; if no char received, retry
0236+  1F07 76 6E         cmp ah, 'n'
0237+  1F09 C6 17 1F      je _gettxt_LF
0238+  1F0C 76 72         cmp ah, 'r'
0239+  1F0E C6 1E 1F      je _gettxt_CR
0240+  1F11 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0241+  1F12 3E            mov [d], al
0242+  1F13 79            inc d
0243+  1F14 0A E0 1E      jmp _gettxt_loop
0244+  1F17             _gettxt_LF:
0245+  1F17 19 0A         mov al, $0A
0246+  1F19 3E            mov [d], al
0247+  1F1A 79            inc d
0248+  1F1B 0A E0 1E      jmp _gettxt_loop
0249+  1F1E             _gettxt_CR:
0250+  1F1E 19 0D         mov al, $0D
0251+  1F20 3E            mov [d], al
0252+  1F21 79            inc d
0253+  1F22 0A E0 1E      jmp _gettxt_loop
0254+  1F25             _gettxt_backspace:
0255+  1F25 7F            dec d
0256+  1F26 0A E0 1E      jmp _gettxt_loop
0257+  1F29             _gettxt_end:
0258+  1F29 19 00         mov al, 0
0259+  1F2B 3E            mov [d], al        ; terminate string
0260+  1F2C E7            pop d
0261+  1F2D E4            pop a
0262+  1F2E 09            ret
0263+  1F2F             
0264+  1F2F             ;-----------------------------------------------------------------------------
0265+  1F2F             ; PRINT NEW LINE
0266+  1F2F             ;-----------------------------------------------------------------------------
0267+  1F2F             printnl:
0268+  1F2F D7            push a
0269+  1F30 10 00 0A      mov a, $0A00
0270+  1F33 05 03         syscall sys_io
0271+  1F35 10 00 0D      mov a, $0D00
0272+  1F38 05 03         syscall sys_io
0273+  1F3A E4            pop a
0274+  1F3B 09            ret
0275+  1F3C             
0276+  1F3C             ;-----------------------------------------------------------------------------
0277+  1F3C             ; _strtoint
0278+  1F3C             ; 4 digit hex string number in d
0279+  1F3C             ; integer returned in A
0280+  1F3C             ;-----------------------------------------------------------------------------
0281+  1F3C             _strtointx:
0282+  1F3C D8            push b
0283+  1F3D 32            mov bl, [d]
0284+  1F3E 37            mov bh, bl
0285+  1F3F 33 01 00      mov bl, [d + 1]
0286+  1F42 07 F6 1D      call _atoi        ; convert to int in AL
0287+  1F45 23            mov ah, al        ; move to AH
0288+  1F46 33 02 00      mov bl, [d + 2]
0289+  1F49 37            mov bh, bl
0290+  1F4A 33 03 00      mov bl, [d + 3]
0291+  1F4D 07 F6 1D      call _atoi        ; convert to int in AL
0292+  1F50 E5            pop b
0293+  1F51 09            ret
0294+  1F52             
0295+  1F52             ;-----------------------------------------------------------------------------
0296+  1F52             ; _strtoint
0297+  1F52             ; 5 digit base10 string number in d
0298+  1F52             ; integer returned in A
0299+  1F52             ;-----------------------------------------------------------------------------
0300+  1F52             _strtoint:
0301+  1F52 E2            push si
0302+  1F53 D8            push b
0303+  1F54 D9            push c
0304+  1F55 DA            push d
0305+  1F56 07 98 1D      call _strlen      ; get string length in C
0306+  1F59 7E            dec c
0307+  1F5A FD 4E         mov si, d
0308+  1F5C 12            mov a, c
0309+  1F5D FD 99         shl a
0310+  1F5F 3B CE 20      mov d, table_power
0311+  1F62 59            add d, a
0312+  1F63 38 00 00      mov c, 0
0313+  1F66             _strtoint_L0:
0314+  1F66 F6            lodsb      ; load ASCII to al
0315+  1F67 B9 00         cmp al, 0
0316+  1F69 C6 7C 1F      je _strtoint_end
0317+  1F6C 6F 30         sub al, $30    ; make into integer
0318+  1F6E 22 00         mov ah, 0
0319+  1F70 2A            mov b, [d]
0320+  1F71 AC            mul a, b      ; result in B since it fits in 16bits
0321+  1F72 11            mov a, b
0322+  1F73 28            mov b, c
0323+  1F74 54            add a, b
0324+  1F75 39            mov c, a
0325+  1F76 63 02 00      sub d, 2
0326+  1F79 0A 66 1F      jmp _strtoint_L0
0327+  1F7C             _strtoint_end:
0328+  1F7C 12            mov a, c
0329+  1F7D E7            pop d
0330+  1F7E E6            pop c
0331+  1F7F E5            pop b
0332+  1F80 EF            pop si
0333+  1F81 09            ret
0334+  1F82             
0335+  1F82             ;-----------------------------------------------------------------------------
0336+  1F82             ; PRINT NULL TERMINATED STRING
0337+  1F82             ; pointer in D
0338+  1F82             ;-----------------------------------------------------------------------------
0339+  1F82             _puts:
0340+  1F82 D7            push a
0341+  1F83 DA            push d
0342+  1F84             _puts_L1:
0343+  1F84 1E            mov al, [d]
0344+  1F85 B9 00         cmp al, 0
0345+  1F87 C6 93 1F      jz _puts_END
0346+  1F8A 23            mov ah, al
0347+  1F8B 19 00         mov al, 0
0348+  1F8D 05 03         syscall sys_io
0349+  1F8F 79            inc d
0350+  1F90 0A 84 1F      jmp _puts_L1
0351+  1F93             _puts_END:
0352+  1F93 E7            pop d
0353+  1F94 E4            pop a
0354+  1F95 09            ret
0355+  1F96             
0356+  1F96             ;-----------------------------------------------------------------------------
0357+  1F96             ; PRINT N SIZE STRING
0358+  1F96             ; pointer in D
0359+  1F96             ; size in C
0360+  1F96             ;-----------------------------------------------------------------------------
0361+  1F96             _putsn:
0362+  1F96 DB            push al
0363+  1F97 DA            push d
0364+  1F98 D9            push c
0365+  1F99             _putsn_L0:
0366+  1F99 1E            mov al, [d]
0367+  1F9A 23            mov ah, al
0368+  1F9B 19 00         mov al, 0
0369+  1F9D 05 03         syscall sys_io
0370+  1F9F 79            inc d
0371+  1FA0 7E            dec c  
0372+  1FA1 C2 00 00      cmp c, 0
0373+  1FA4 C7 99 1F      jne _putsn_L0
0374+  1FA7             _putsn_end:
0375+  1FA7 E6            pop c
0376+  1FA8 E7            pop d
0377+  1FA9 E8            pop al
0378+  1FAA 09            ret
0379+  1FAB             
0380+  1FAB             ;-----------------------------------------------------------------------------
0381+  1FAB             ; print 16bit decimal number
0382+  1FAB             ; input number in A
0383+  1FAB             ;-----------------------------------------------------------------------------
0384+  1FAB             print_u16d:
0385+  1FAB D7            push a
0386+  1FAC D8            push b
0387+  1FAD 26 10 27      mov b, 10000
0388+  1FB0 AE            div a, b      ; get 10000's coeff.
0389+  1FB1 07 D3 1F      call print_number
0390+  1FB4 11            mov a, b
0391+  1FB5 26 E8 03      mov b, 1000
0392+  1FB8 AE            div a, b      ; get 1000's coeff.
0393+  1FB9 07 D3 1F      call print_number
0394+  1FBC 11            mov a, b
0395+  1FBD 26 64 00      mov b, 100
0396+  1FC0 AE            div a, b
0397+  1FC1 07 D3 1F      call print_number
0398+  1FC4 11            mov a, b
0399+  1FC5 26 0A 00      mov b, 10
0400+  1FC8 AE            div a, b
0401+  1FC9 07 D3 1F      call print_number
0402+  1FCC 1B            mov al, bl      ; 1's coeff in bl
0403+  1FCD 07 D3 1F      call print_number
0404+  1FD0 E5            pop b
0405+  1FD1 E4            pop a
0406+  1FD2 09            ret
0407+  1FD3             
0408+  1FD3             ;-----------------------------------------------------------------------------
0409+  1FD3             ; print AL
0410+  1FD3             ;-----------------------------------------------------------------------------
0411+  1FD3             print_number:
0412+  1FD3 6A 30         add al, $30
0413+  1FD5 23            mov ah, al
0414+  1FD6 07 38 1E      call _putchar
0415+  1FD9 09            ret
0416+  1FDA             
0417+  1FDA             ;-----------------------------------------------------------------------------
0418+  1FDA             ; PRINT 16BIT HEX INTEGER
0419+  1FDA             ; integer value in reg B
0420+  1FDA             ;-----------------------------------------------------------------------------
0421+  1FDA             print_u16x:
0422+  1FDA D7            push a
0423+  1FDB D8            push b
0424+  1FDC DD            push bl
0425+  1FDD 30            mov bl, bh
0426+  1FDE 07 06 1E      call _itoa        ; convert bh to char in A
0427+  1FE1 2F            mov bl, al        ; save al
0428+  1FE2 19 00         mov al, 0
0429+  1FE4 05 03         syscall sys_io        ; display AH
0430+  1FE6 24            mov ah, bl        ; retrieve al
0431+  1FE7 19 00         mov al, 0
0432+  1FE9 05 03         syscall sys_io        ; display AL
0433+  1FEB             
0434+  1FEB EA            pop bl
0435+  1FEC 07 06 1E      call _itoa        ; convert bh to char in A
0436+  1FEF 2F            mov bl, al        ; save al
0437+  1FF0 19 00         mov al, 0
0438+  1FF2 05 03         syscall sys_io        ; display AH
0439+  1FF4 24            mov ah, bl        ; retrieve al
0440+  1FF5 19 00         mov al, 0
0441+  1FF7 05 03         syscall sys_io        ; display AL
0442+  1FF9             
0443+  1FF9 E5            pop b
0444+  1FFA E4            pop a
0445+  1FFB 09            ret
0446+  1FFC             
0447+  1FFC             ;-----------------------------------------------------------------------------
0448+  1FFC             ; INPUT 16BIT HEX INTEGER
0449+  1FFC             ; read 16bit integer into A
0450+  1FFC             ;-----------------------------------------------------------------------------
0451+  1FFC             scan_u16x:
0452+  1FFC F8 10 00      enter 16
0453+  1FFF D8            push b
0454+  2000 DA            push d
0455+  2001             
0456+  2001 FA F1 FF      lea d, [bp + -15]
0457+  2004 07 3F 1E      call _gets        ; get number
0458+  2007             
0459+  2007 32            mov bl, [d]
0460+  2008 37            mov bh, bl
0461+  2009 33 01 00      mov bl, [d + 1]
0462+  200C 07 F6 1D      call _atoi        ; convert to int in AL
0463+  200F 23            mov ah, al        ; move to AH
0464+  2010             
0465+  2010 33 02 00      mov bl, [d + 2]
0466+  2013 37            mov bh, bl
0467+  2014 33 03 00      mov bl, [d + 3]
0468+  2017 07 F6 1D      call _atoi        ; convert to int in AL
0469+  201A             
0470+  201A E7            pop d
0471+  201B E5            pop b
0472+  201C F9            leave
0473+  201D 09            ret
0474+  201E             
0475+  201E             ;-----------------------------------------------------------------------------
0476+  201E             ; PRINT 8bit HEX INTEGER
0477+  201E             ; integer value in reg bl
0478+  201E             ;-----------------------------------------------------------------------------
0479+  201E             print_u8x:
0480+  201E D7            push a
0481+  201F DD            push bl
0482+  2020             
0483+  2020 07 06 1E      call _itoa        ; convert bl to char in A
0484+  2023 2F            mov bl, al        ; save al
0485+  2024 19 00         mov al, 0
0486+  2026 05 03         syscall sys_io        ; display AH
0487+  2028 24            mov ah, bl        ; retrieve al
0488+  2029 19 00         mov al, 0
0489+  202B 05 03         syscall sys_io        ; display AL
0490+  202D             
0491+  202D EA            pop bl
0492+  202E E4            pop a
0493+  202F 09            ret
0494+  2030             
0495+  2030             ;-----------------------------------------------------------------------------
0496+  2030             ; print 8bit decimal unsigned number
0497+  2030             ; input number in AL
0498+  2030             ;-----------------------------------------------------------------------------
0499+  2030             print_u8d:
0500+  2030 D7            push a
0501+  2031 D8            push b
0502+  2032             
0503+  2032 22 00         mov ah, 0
0504+  2034 26 64 00      mov b, 100
0505+  2037 AE            div a, b
0506+  2038 D8            push b      ; save remainder
0507+  2039 B9 00         cmp al, 0
0508+  203B C6 45 20      je skip100
0509+  203E 6A 30         add al, $30
0510+  2040 23            mov ah, al
0511+  2041 19 00         mov al, 0
0512+  2043 05 03         syscall sys_io  ; print coeff
0513+  2045             skip100:
0514+  2045 E4            pop a
0515+  2046 22 00         mov ah, 0
0516+  2048 26 0A 00      mov b, 10
0517+  204B AE            div a, b
0518+  204C D8            push b      ; save remainder
0519+  204D B9 00         cmp al, 0
0520+  204F C6 59 20      je skip10
0521+  2052 6A 30         add al, $30
0522+  2054 23            mov ah, al
0523+  2055 19 00         mov al, 0
0524+  2057 05 03         syscall sys_io  ; print coeff
0525+  2059             skip10:
0526+  2059 E4            pop a
0527+  205A 1B            mov al, bl
0528+  205B 6A 30         add al, $30
0529+  205D 23            mov ah, al
0530+  205E 19 00         mov al, 0
0531+  2060 05 03         syscall sys_io  ; print coeff
0532+  2062 E5            pop b
0533+  2063 E4            pop a
0534+  2064 09            ret
0535+  2065             
0536+  2065             ;-----------------------------------------------------------------------------
0537+  2065             ; INPUT 8BIT HEX INTEGER
0538+  2065             ; read 8bit integer into AL
0539+  2065             ;-----------------------------------------------------------------------------
0540+  2065             scan_u8x:
0541+  2065 F8 04 00      enter 4
0542+  2068 D8            push b
0543+  2069 DA            push d
0544+  206A             
0545+  206A FA FD FF      lea d, [bp + -3]
0546+  206D 07 3F 1E      call _gets        ; get number
0547+  2070             
0548+  2070 32            mov bl, [d]
0549+  2071 37            mov bh, bl
0550+  2072 33 01 00      mov bl, [d + 1]
0551+  2075 07 F6 1D      call _atoi        ; convert to int in AL
0552+  2078             
0553+  2078 E7            pop d
0554+  2079 E5            pop b
0555+  207A F9            leave
0556+  207B 09            ret
0557+  207C             
0558+  207C             ;-----------------------------------------------------------------------------
0559+  207C             ; input decimal number
0560+  207C             ; result in A
0561+  207C             ; 655'\0'
0562+  207C             ; low--------high
0563+  207C             ;-----------------------------------------------------------------------------
0564+  207C             scan_u16d:
0565+  207C F8 08 00      enter 8
0566+  207F E2            push si
0567+  2080 D8            push b
0568+  2081 D9            push c
0569+  2082 DA            push d
0570+  2083 FA F9 FF      lea d, [bp +- 7]
0571+  2086 07 3F 1E      call _gets
0572+  2089 07 98 1D      call _strlen      ; get string length in C
0573+  208C 7E            dec c
0574+  208D FD 4E         mov si, d
0575+  208F 12            mov a, c
0576+  2090 FD 99         shl a
0577+  2092 3B CE 20      mov d, table_power
0578+  2095 59            add d, a
0579+  2096 38 00 00      mov c, 0
0580+  2099             mul_loop:
0581+  2099 F6            lodsb      ; load ASCII to al
0582+  209A B9 00         cmp al, 0
0583+  209C C6 AF 20      je mul_exit
0584+  209F 6F 30         sub al, $30    ; make into integer
0585+  20A1 22 00         mov ah, 0
0586+  20A3 2A            mov b, [d]
0587+  20A4 AC            mul a, b      ; result in B since it fits in 16bits
0588+  20A5 11            mov a, b
0589+  20A6 28            mov b, c
0590+  20A7 54            add a, b
0591+  20A8 39            mov c, a
0592+  20A9 63 02 00      sub d, 2
0593+  20AC 0A 99 20      jmp mul_loop
0594+  20AF             mul_exit:
0595+  20AF 12            mov a, c
0596+  20B0 E7            pop d
0597+  20B1 E6            pop c
0598+  20B2 E5            pop b
0599+  20B3 EF            pop si
0600+  20B4 F9            leave
0601+  20B5 09            ret
0602+  20B6             
0603+  20B6 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0603+  20BA 34 35 36 37 
0603+  20BE 38 39 41 42 
0603+  20C2 43 44 45 46 
0604+  20C6 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0604+  20CA 1B 5B 48 00 
0605+  20CE             
0606+  20CE             table_power:
0607+  20CE 01 00         .dw 1
0608+  20D0 0A 00         .dw 10
0609+  20D2 64 00         .dw 100
0610+  20D4 E8 03         .dw 1000
0611+  20D6 10 27         .dw 100004152   20D8             ; --- END INLINE ASM SEGMENT
4153   20D8             
4154   20D8 F9            leave
4155   20D9 09            ret
4156   20DA             ; --- END TEXT SEGMENT
4157   20DA             
4158   20DA             ; --- BEGIN DATA SEGMENT
4159   20DA 00 00       st_fopen_max_handle: .dw 0
4160   20DC 55 6E 65 78 _s0: .db "Unexpected format in printf.", 0
4160   20E0 70 65 63 74 
4160   20E4 65 64 20 66 
4160   20E8 6F 72 6D 61 
4160   20EC 74 20 69 6E 
4160   20F0 20 70 72 69 
4160   20F4 6E 74 66 2E 
4160   20F8 00 
4161   20F9 45 72 72 6F _s1: .db "Error: Unknown argument type.\n", 0
4161   20FD 72 3A 20 55 
4161   2101 6E 6B 6E 6F 
4161   2105 77 6E 20 61 
4161   2109 72 67 75 6D 
4161   210D 65 6E 74 20 
4161   2111 74 79 70 65 
4161   2115 2E 0A 00 
4162   2118 1B 5B 32 4A _s2: .db "\033[2J\033[H", 0
4162   211C 1B 5B 48 00 
4163   2120             
4164   2120 22 21       _heap_top: .dw _heap
4165   2122 00          _heap: .db 0
4166   2123             ; --- END DATA SEGMENT
4167   2123             
4168   2123             .end
tasm: Number of errors = 0
