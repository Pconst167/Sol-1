0001   0000             ; --- FILENAME: test
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ;; il0 = 0x80000000L; 
0011   0408 3B 21 14      mov d, _il0 ; $il0
0012   040B DA            push d
0013   040C 26 00 00      mov b, 0
0014   040F 38 00 80      mov c, 32768
0015   0412 E7            pop d
0016   0413 FD 43         mov [d], b
0017   0415 28            mov b, c
0018   0416 FD 44 02 00   mov [d + 2], b
0019   041A             ;; il1 = 0x00000001L; 
0020   041A 3B 25 14      mov d, _il1 ; $il1
0021   041D DA            push d
0022   041E 26 01 00      mov b, 1
0023   0421 38 00 00      mov c, 0
0024   0424 E7            pop d
0025   0425 FD 43         mov [d], b
0026   0427 28            mov b, c
0027   0428 FD 44 02 00   mov [d + 2], b
0028   042C             ;; i0 = 0x8000; 
0029   042C 3B 29 14      mov d, _i0 ; $i0
0030   042F DA            push d
0031   0430 26 00 80      mov b, $8000
0032   0433 E7            pop d
0033   0434 FD 43         mov [d], b
0034   0436             ;; i1 = 0x0001; 
0035   0436 3B 2B 14      mov d, _i1 ; $i1
0036   0439 DA            push d
0037   043A 26 01 00      mov b, $1
0038   043D E7            pop d
0039   043E FD 43         mov [d], b
0040   0440             ;; c0 = 'A'; 
0041   0440 3B 2D 14      mov d, _c0 ; $c0
0042   0443 DA            push d
0043   0444 26 41 00      mov b, $41
0044   0447 E7            pop d
0045   0448 FD 3E         mov [d], bl
0046   044A             ;; c1 = 'Z'; 
0047   044A 3B 2E 14      mov d, _c1 ; $c1
0048   044D DA            push d
0049   044E 26 5A 00      mov b, $5a
0050   0451 E7            pop d
0051   0452 FD 3E         mov [d], bl
0052   0454 05 0B         syscall sys_terminate_proc
0053   0456             
0054   0456             strcpy:
0055   0456 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0056   0459             ; $psrc 
0057   0459             ; $pdest 
0058   0459 52 04 00      sub sp, 4
0059   045C             ;; psrc = src; 
0060   045C FA FF FF      lea d, [bp + -1] ; $psrc
0061   045F DA            push d
0062   0460 FA 07 00      lea d, [bp + 7] ; $src
0063   0463 2A            mov b, [d]
0064   0464 E7            pop d
0065   0465 FD 43         mov [d], b
0066   0467             ;; pdest = dest; 
0067   0467 FA FD FF      lea d, [bp + -3] ; $pdest
0068   046A DA            push d
0069   046B FA 05 00      lea d, [bp + 5] ; $dest
0070   046E 2A            mov b, [d]
0071   046F E7            pop d
0072   0470 FD 43         mov [d], b
0073   0472             ;; while(*psrc) *pdest++ = *psrc++; 
0074   0472             _while1_cond:
0075   0472 FA FF FF      lea d, [bp + -1] ; $psrc
0076   0475 2A            mov b, [d]
0077   0476 74            mov d, b
0078   0477 32            mov bl, [d]
0079   0478 A7 00         mov bh, 0
0080   047A C0 00 00      cmp b, 0
0081   047D C6 A5 04      je _while1_exit
0082   0480             _while1_block:
0083   0480             ;; *pdest++ = *psrc++; 
0084   0480 FA FD FF      lea d, [bp + -3] ; $pdest
0085   0483 2A            mov b, [d]
0086   0484 D8            push b
0087   0485 FD 77         inc b
0088   0487 FA FD FF      lea d, [bp + -3] ; $pdest
0089   048A FD 43         mov [d], b
0090   048C E5            pop b
0091   048D D8            push b
0092   048E FA FF FF      lea d, [bp + -1] ; $psrc
0093   0491 2A            mov b, [d]
0094   0492 D8            push b
0095   0493 FD 77         inc b
0096   0495 FA FF FF      lea d, [bp + -1] ; $psrc
0097   0498 FD 43         mov [d], b
0098   049A E5            pop b
0099   049B 74            mov d, b
0100   049C 32            mov bl, [d]
0101   049D A7 00         mov bh, 0
0102   049F E7            pop d
0103   04A0 FD 3E         mov [d], bl
0104   04A2 0A 72 04      jmp _while1_cond
0105   04A5             _while1_exit:
0106   04A5             ;; *pdest = '\0'; 
0107   04A5 FA FD FF      lea d, [bp + -3] ; $pdest
0108   04A8 2A            mov b, [d]
0109   04A9 D8            push b
0110   04AA 26 00 00      mov b, $0
0111   04AD E7            pop d
0112   04AE FD 3E         mov [d], bl
0113   04B0 F9            leave
0114   04B1 09            ret
0115   04B2             
0116   04B2             strcmp:
0117   04B2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0118   04B5             ;; while (*s1 && (*s1 == *s2)) { 
0119   04B5             _while2_cond:
0120   04B5 FA 05 00      lea d, [bp + 5] ; $s1
0121   04B8 2A            mov b, [d]
0122   04B9 74            mov d, b
0123   04BA 32            mov bl, [d]
0124   04BB A7 00         mov bh, 0
0125   04BD D7            push a
0126   04BE 11            mov a, b
0127   04BF FA 05 00      lea d, [bp + 5] ; $s1
0128   04C2 2A            mov b, [d]
0129   04C3 74            mov d, b
0130   04C4 32            mov bl, [d]
0131   04C5 A7 00         mov bh, 0
0132   04C7             ; START RELATIONAL
0133   04C7 D7            push a
0134   04C8 11            mov a, b
0135   04C9 FA 07 00      lea d, [bp + 7] ; $s2
0136   04CC 2A            mov b, [d]
0137   04CD 74            mov d, b
0138   04CE 32            mov bl, [d]
0139   04CF A7 00         mov bh, 0
0140   04D1 B0            cmp a, b
0141   04D2 FD 71         seq ; ==
0142   04D4 E4            pop a
0143   04D5             ; END RELATIONAL
0144   04D5 FD A7         sand a, b
0145   04D7 E4            pop a
0146   04D8 C0 00 00      cmp b, 0
0147   04DB C6 FB 04      je _while2_exit
0148   04DE             _while2_block:
0149   04DE             ;; s1++; 
0150   04DE FA 05 00      lea d, [bp + 5] ; $s1
0151   04E1 2A            mov b, [d]
0152   04E2 D8            push b
0153   04E3 FD 77         inc b
0154   04E5 FA 05 00      lea d, [bp + 5] ; $s1
0155   04E8 FD 43         mov [d], b
0156   04EA E5            pop b
0157   04EB             ;; s2++; 
0158   04EB FA 07 00      lea d, [bp + 7] ; $s2
0159   04EE 2A            mov b, [d]
0160   04EF D8            push b
0161   04F0 FD 77         inc b
0162   04F2 FA 07 00      lea d, [bp + 7] ; $s2
0163   04F5 FD 43         mov [d], b
0164   04F7 E5            pop b
0165   04F8 0A B5 04      jmp _while2_cond
0166   04FB             _while2_exit:
0167   04FB             ;; return *s1 - *s2; 
0168   04FB FA 05 00      lea d, [bp + 5] ; $s1
0169   04FE 2A            mov b, [d]
0170   04FF 74            mov d, b
0171   0500 32            mov bl, [d]
0172   0501 A7 00         mov bh, 0
0173   0503             ; START TERMS
0174   0503 D7            push a
0175   0504 11            mov a, b
0176   0505 FA 07 00      lea d, [bp + 7] ; $s2
0177   0508 2A            mov b, [d]
0178   0509 74            mov d, b
0179   050A 32            mov bl, [d]
0180   050B A7 00         mov bh, 0
0181   050D 60            sub a, b
0182   050E 27            mov b, a
0183   050F E4            pop a
0184   0510             ; END TERMS
0185   0510 F9            leave
0186   0511 09            ret
0187   0512             
0188   0512             strcat:
0189   0512 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0190   0515             ; $dest_len 
0191   0515             ; $i 
0192   0515 52 04 00      sub sp, 4
0193   0518             ;; dest_len = strlen(dest); 
0194   0518 FA FF FF      lea d, [bp + -1] ; $dest_len
0195   051B DA            push d
0196   051C FA 05 00      lea d, [bp + 5] ; $dest
0197   051F 2A            mov b, [d]
0198   0520 FD AB         swp b
0199   0522 D8            push b
0200   0523 07 C5 05      call strlen
0201   0526 51 02 00      add sp, 2
0202   0529 E7            pop d
0203   052A FD 43         mov [d], b
0204   052C             ;; for (i = 0; src[i] != 0; i=i+1) { 
0205   052C             _for3_init:
0206   052C FA FD FF      lea d, [bp + -3] ; $i
0207   052F DA            push d
0208   0530 26 00 00      mov b, $0
0209   0533 E7            pop d
0210   0534 FD 43         mov [d], b
0211   0536             _for3_cond:
0212   0536 FA 07 00      lea d, [bp + 7] ; $src
0213   0539 FD 2A         mov d, [d]
0214   053B D7            push a
0215   053C DA            push d
0216   053D FA FD FF      lea d, [bp + -3] ; $i
0217   0540 2A            mov b, [d]
0218   0541 E7            pop d
0219   0542 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0220   0546 E4            pop a
0221   0547 32            mov bl, [d]
0222   0548 A7 00         mov bh, 0
0223   054A             ; START RELATIONAL
0224   054A D7            push a
0225   054B 11            mov a, b
0226   054C 26 00 00      mov b, $0
0227   054F B0            cmp a, b
0228   0550 FD 72         sneq ; !=
0229   0552 E4            pop a
0230   0553             ; END RELATIONAL
0231   0553 C0 00 00      cmp b, 0
0232   0556 C6 9F 05      je _for3_exit
0233   0559             _for3_block:
0234   0559             ;; dest[dest_len + i] = src[i]; 
0235   0559 FA 05 00      lea d, [bp + 5] ; $dest
0236   055C FD 2A         mov d, [d]
0237   055E D7            push a
0238   055F DA            push d
0239   0560 FA FF FF      lea d, [bp + -1] ; $dest_len
0240   0563 2A            mov b, [d]
0241   0564             ; START TERMS
0242   0564 D7            push a
0243   0565 11            mov a, b
0244   0566 FA FD FF      lea d, [bp + -3] ; $i
0245   0569 2A            mov b, [d]
0246   056A 56            add b, a
0247   056B E4            pop a
0248   056C             ; END TERMS
0249   056C E7            pop d
0250   056D FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0251   0571 E4            pop a
0252   0572 DA            push d
0253   0573 FA 07 00      lea d, [bp + 7] ; $src
0254   0576 FD 2A         mov d, [d]
0255   0578 D7            push a
0256   0579 DA            push d
0257   057A FA FD FF      lea d, [bp + -3] ; $i
0258   057D 2A            mov b, [d]
0259   057E E7            pop d
0260   057F FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0261   0583 E4            pop a
0262   0584 32            mov bl, [d]
0263   0585 A7 00         mov bh, 0
0264   0587 E7            pop d
0265   0588 FD 3E         mov [d], bl
0266   058A             _for3_update:
0267   058A FA FD FF      lea d, [bp + -3] ; $i
0268   058D DA            push d
0269   058E FA FD FF      lea d, [bp + -3] ; $i
0270   0591 2A            mov b, [d]
0271   0592             ; START TERMS
0272   0592 D7            push a
0273   0593 11            mov a, b
0274   0594 26 01 00      mov b, $1
0275   0597 56            add b, a
0276   0598 E4            pop a
0277   0599             ; END TERMS
0278   0599 E7            pop d
0279   059A FD 43         mov [d], b
0280   059C 0A 36 05      jmp _for3_cond
0281   059F             _for3_exit:
0282   059F             ;; dest[dest_len + i] = 0; 
0283   059F FA 05 00      lea d, [bp + 5] ; $dest
0284   05A2 FD 2A         mov d, [d]
0285   05A4 D7            push a
0286   05A5 DA            push d
0287   05A6 FA FF FF      lea d, [bp + -1] ; $dest_len
0288   05A9 2A            mov b, [d]
0289   05AA             ; START TERMS
0290   05AA D7            push a
0291   05AB 11            mov a, b
0292   05AC FA FD FF      lea d, [bp + -3] ; $i
0293   05AF 2A            mov b, [d]
0294   05B0 56            add b, a
0295   05B1 E4            pop a
0296   05B2             ; END TERMS
0297   05B2 E7            pop d
0298   05B3 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0299   05B7 E4            pop a
0300   05B8 DA            push d
0301   05B9 26 00 00      mov b, $0
0302   05BC E7            pop d
0303   05BD FD 3E         mov [d], bl
0304   05BF             ;; return dest; 
0305   05BF FA 05 00      lea d, [bp + 5] ; $dest
0306   05C2 2A            mov b, [d]
0307   05C3 F9            leave
0308   05C4 09            ret
0309   05C5             
0310   05C5             strlen:
0311   05C5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0312   05C8             ; $length 
0313   05C8 52 02 00      sub sp, 2
0314   05CB             ;; length = 0; 
0315   05CB FA FF FF      lea d, [bp + -1] ; $length
0316   05CE DA            push d
0317   05CF 26 00 00      mov b, $0
0318   05D2 E7            pop d
0319   05D3 FD 43         mov [d], b
0320   05D5             ;; while (str[length] != 0) { 
0321   05D5             _while4_cond:
0322   05D5 FA 05 00      lea d, [bp + 5] ; $str
0323   05D8 FD 2A         mov d, [d]
0324   05DA D7            push a
0325   05DB DA            push d
0326   05DC FA FF FF      lea d, [bp + -1] ; $length
0327   05DF 2A            mov b, [d]
0328   05E0 E7            pop d
0329   05E1 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0330   05E5 E4            pop a
0331   05E6 32            mov bl, [d]
0332   05E7 A7 00         mov bh, 0
0333   05E9             ; START RELATIONAL
0334   05E9 D7            push a
0335   05EA 11            mov a, b
0336   05EB 26 00 00      mov b, $0
0337   05EE B0            cmp a, b
0338   05EF FD 72         sneq ; !=
0339   05F1 E4            pop a
0340   05F2             ; END RELATIONAL
0341   05F2 C0 00 00      cmp b, 0
0342   05F5 C6 08 06      je _while4_exit
0343   05F8             _while4_block:
0344   05F8             ;; length++; 
0345   05F8 FA FF FF      lea d, [bp + -1] ; $length
0346   05FB 2A            mov b, [d]
0347   05FC D8            push b
0348   05FD FD 77         inc b
0349   05FF FA FF FF      lea d, [bp + -1] ; $length
0350   0602 FD 43         mov [d], b
0351   0604 E5            pop b
0352   0605 0A D5 05      jmp _while4_cond
0353   0608             _while4_exit:
0354   0608             ;; return length; 
0355   0608 FA FF FF      lea d, [bp + -1] ; $length
0356   060B 2A            mov b, [d]
0357   060C F9            leave
0358   060D 09            ret
0359   060E             
0360   060E             scanf:
0361   060E F8 00 00      enter 0 ; (push bp; mov bp, sp)
0362   0611             ; $p 
0363   0611             ; $format_p 
0364   0611             ; $c 
0365   0611             ; $i 
0366   0611             ; $input_string 
0367   0611 52 07 02      sub sp, 519
0368   0614             ;; format_p = format; 
0369   0614 FA FD FF      lea d, [bp + -3] ; $format_p
0370   0617 DA            push d
0371   0618 FA 05 00      lea d, [bp + 5] ; $format
0372   061B 2A            mov b, [d]
0373   061C E7            pop d
0374   061D FD 43         mov [d], b
0375   061F             ;; p = &format + 2; 
0376   061F FA FF FF      lea d, [bp + -1] ; $p
0377   0622 DA            push d
0378   0623 FA 05 00      lea d, [bp + 5] ; $format
0379   0626 2D            mov b, d
0380   0627             ; START TERMS
0381   0627 D7            push a
0382   0628 11            mov a, b
0383   0629 26 02 00      mov b, $2
0384   062C 56            add b, a
0385   062D E4            pop a
0386   062E             ; END TERMS
0387   062E E7            pop d
0388   062F FD 43         mov [d], b
0389   0631             ;; for(;;){ 
0390   0631             _for5_init:
0391   0631             _for5_cond:
0392   0631             _for5_block:
0393   0631             ;; if(!*format_p) break; 
0394   0631             _if6_cond:
0395   0631 FA FD FF      lea d, [bp + -3] ; $format_p
0396   0634 2A            mov b, [d]
0397   0635 74            mov d, b
0398   0636 32            mov bl, [d]
0399   0637 A7 00         mov bh, 0
0400   0639 C0 00 00      cmp b, 0
0401   063C FD 71         seq ; !
0402   063E C0 00 00      cmp b, 0
0403   0641 C6 4A 06      je _if6_else
0404   0644             _if6_true:
0405   0644             ;; break; 
0406   0644 0A 47 08      jmp _for5_exit ; for break
0407   0647 0A 44 08      jmp _if6_exit
0408   064A             _if6_else:
0409   064A             ;; if(*format_p == '%'){ 
0410   064A             _if7_cond:
0411   064A FA FD FF      lea d, [bp + -3] ; $format_p
0412   064D 2A            mov b, [d]
0413   064E 74            mov d, b
0414   064F 32            mov bl, [d]
0415   0650 A7 00         mov bh, 0
0416   0652             ; START RELATIONAL
0417   0652 D7            push a
0418   0653 11            mov a, b
0419   0654 26 25 00      mov b, $25
0420   0657 B0            cmp a, b
0421   0658 FD 71         seq ; ==
0422   065A E4            pop a
0423   065B             ; END RELATIONAL
0424   065B C0 00 00      cmp b, 0
0425   065E C6 28 08      je _if7_else
0426   0661             _if7_true:
0427   0661             ;; format_p++; 
0428   0661 FA FD FF      lea d, [bp + -3] ; $format_p
0429   0664 2A            mov b, [d]
0430   0665 D8            push b
0431   0666 FD 77         inc b
0432   0668 FA FD FF      lea d, [bp + -3] ; $format_p
0433   066B FD 43         mov [d], b
0434   066D E5            pop b
0435   066E             ;; switch(*format_p){ 
0436   066E             _switch8_expr:
0437   066E FA FD FF      lea d, [bp + -3] ; $format_p
0438   0671 2A            mov b, [d]
0439   0672 74            mov d, b
0440   0673 32            mov bl, [d]
0441   0674 A7 00         mov bh, 0
0442   0676             _switch8_comparisons:
0443   0676 C1 6C         cmp bl, $6c
0444   0678 C6 A4 06      je _switch8_case0
0445   067B C1 4C         cmp bl, $4c
0446   067D C6 A4 06      je _switch8_case1
0447   0680 C1 64         cmp bl, $64
0448   0682 C6 36 07      je _switch8_case2
0449   0685 C1 69         cmp bl, $69
0450   0687 C6 36 07      je _switch8_case3
0451   068A C1 75         cmp bl, $75
0452   068C C6 63 07      je _switch8_case4
0453   068F C1 78         cmp bl, $78
0454   0691 C6 90 07      je _switch8_case5
0455   0694 C1 63         cmp bl, $63
0456   0696 C6 A5 07      je _switch8_case6
0457   0699 C1 73         cmp bl, $73
0458   069B C6 D4 07      je _switch8_case7
0459   069E 0A 0C 08      jmp _switch8_default
0460   06A1 0A 18 08      jmp _switch8_exit
0461   06A4             _switch8_case0:
0462   06A4             _switch8_case1:
0463   06A4             ;; format_p++; 
0464   06A4 FA FD FF      lea d, [bp + -3] ; $format_p
0465   06A7 2A            mov b, [d]
0466   06A8 D8            push b
0467   06A9 FD 77         inc b
0468   06AB FA FD FF      lea d, [bp + -3] ; $format_p
0469   06AE FD 43         mov [d], b
0470   06B0 E5            pop b
0471   06B1             ;; if(*format_p == 'd' || *format_p == 'i'); 
0472   06B1             _if9_cond:
0473   06B1 FA FD FF      lea d, [bp + -3] ; $format_p
0474   06B4 2A            mov b, [d]
0475   06B5 74            mov d, b
0476   06B6 32            mov bl, [d]
0477   06B7 A7 00         mov bh, 0
0478   06B9             ; START RELATIONAL
0479   06B9 D7            push a
0480   06BA 11            mov a, b
0481   06BB 26 64 00      mov b, $64
0482   06BE B0            cmp a, b
0483   06BF FD 71         seq ; ==
0484   06C1 E4            pop a
0485   06C2             ; END RELATIONAL
0486   06C2 D7            push a
0487   06C3 11            mov a, b
0488   06C4 FA FD FF      lea d, [bp + -3] ; $format_p
0489   06C7 2A            mov b, [d]
0490   06C8 74            mov d, b
0491   06C9 32            mov bl, [d]
0492   06CA A7 00         mov bh, 0
0493   06CC             ; START RELATIONAL
0494   06CC D7            push a
0495   06CD 11            mov a, b
0496   06CE 26 69 00      mov b, $69
0497   06D1 B0            cmp a, b
0498   06D2 FD 71         seq ; ==
0499   06D4 E4            pop a
0500   06D5             ; END RELATIONAL
0501   06D5 FD A8         sor a, b ; ||
0502   06D7 E4            pop a
0503   06D8 C0 00 00      cmp b, 0
0504   06DB C6 E1 06      je _if9_else
0505   06DE             _if9_true:
0506   06DE             ;; ; 
0507   06DE 0A 21 07      jmp _if9_exit
0508   06E1             _if9_else:
0509   06E1             ;; if(*format_p == 'u'); 
0510   06E1             _if10_cond:
0511   06E1 FA FD FF      lea d, [bp + -3] ; $format_p
0512   06E4 2A            mov b, [d]
0513   06E5 74            mov d, b
0514   06E6 32            mov bl, [d]
0515   06E7 A7 00         mov bh, 0
0516   06E9             ; START RELATIONAL
0517   06E9 D7            push a
0518   06EA 11            mov a, b
0519   06EB 26 75 00      mov b, $75
0520   06EE B0            cmp a, b
0521   06EF FD 71         seq ; ==
0522   06F1 E4            pop a
0523   06F2             ; END RELATIONAL
0524   06F2 C0 00 00      cmp b, 0
0525   06F5 C6 FB 06      je _if10_else
0526   06F8             _if10_true:
0527   06F8             ;; ; 
0528   06F8 0A 21 07      jmp _if10_exit
0529   06FB             _if10_else:
0530   06FB             ;; if(*format_p == 'x'); 
0531   06FB             _if11_cond:
0532   06FB FA FD FF      lea d, [bp + -3] ; $format_p
0533   06FE 2A            mov b, [d]
0534   06FF 74            mov d, b
0535   0700 32            mov bl, [d]
0536   0701 A7 00         mov bh, 0
0537   0703             ; START RELATIONAL
0538   0703 D7            push a
0539   0704 11            mov a, b
0540   0705 26 78 00      mov b, $78
0541   0708 B0            cmp a, b
0542   0709 FD 71         seq ; ==
0543   070B E4            pop a
0544   070C             ; END RELATIONAL
0545   070C C0 00 00      cmp b, 0
0546   070F C6 15 07      je _if11_else
0547   0712             _if11_true:
0548   0712             ;; ; 
0549   0712 0A 21 07      jmp _if11_exit
0550   0715             _if11_else:
0551   0715             ;; err("Unexpected format in printf."); 
0552   0715 26 2F 14      mov b, __s0 ; "Unexpected format in printf."
0553   0718 FD AB         swp b
0554   071A D8            push b
0555   071B 07 90 0A      call err
0556   071E 51 02 00      add sp, 2
0557   0721             _if11_exit:
0558   0721             _if10_exit:
0559   0721             _if9_exit:
0560   0721             ;; p = p + 4; 
0561   0721 FA FF FF      lea d, [bp + -1] ; $p
0562   0724 DA            push d
0563   0725 FA FF FF      lea d, [bp + -1] ; $p
0564   0728 2A            mov b, [d]
0565   0729             ; START TERMS
0566   0729 D7            push a
0567   072A 11            mov a, b
0568   072B 26 04 00      mov b, $4
0569   072E 56            add b, a
0570   072F E4            pop a
0571   0730             ; END TERMS
0572   0730 E7            pop d
0573   0731 FD 43         mov [d], b
0574   0733             ;; break; 
0575   0733 0A 18 08      jmp _switch8_exit ; case break
0576   0736             _switch8_case2:
0577   0736             _switch8_case3:
0578   0736             ;; i = scann(); 
0579   0736 FA FA FF      lea d, [bp + -6] ; $i
0580   0739 DA            push d
0581   073A 07 36 10      call scann
0582   073D E7            pop d
0583   073E FD 43         mov [d], b
0584   0740             ;; **(int **)p = i; 
0585   0740 FA FF FF      lea d, [bp + -1] ; $p
0586   0743 2A            mov b, [d]
0587   0744 74            mov d, b
0588   0745 2A            mov b, [d]
0589   0746 D8            push b
0590   0747 FA FA FF      lea d, [bp + -6] ; $i
0591   074A 2A            mov b, [d]
0592   074B E7            pop d
0593   074C FD 43         mov [d], b
0594   074E             ;; p = p + 2; 
0595   074E FA FF FF      lea d, [bp + -1] ; $p
0596   0751 DA            push d
0597   0752 FA FF FF      lea d, [bp + -1] ; $p
0598   0755 2A            mov b, [d]
0599   0756             ; START TERMS
0600   0756 D7            push a
0601   0757 11            mov a, b
0602   0758 26 02 00      mov b, $2
0603   075B 56            add b, a
0604   075C E4            pop a
0605   075D             ; END TERMS
0606   075D E7            pop d
0607   075E FD 43         mov [d], b
0608   0760             ;; break; 
0609   0760 0A 18 08      jmp _switch8_exit ; case break
0610   0763             _switch8_case4:
0611   0763             ;; i = scann(); 
0612   0763 FA FA FF      lea d, [bp + -6] ; $i
0613   0766 DA            push d
0614   0767 07 36 10      call scann
0615   076A E7            pop d
0616   076B FD 43         mov [d], b
0617   076D             ;; **(int **)p = i; 
0618   076D FA FF FF      lea d, [bp + -1] ; $p
0619   0770 2A            mov b, [d]
0620   0771 74            mov d, b
0621   0772 2A            mov b, [d]
0622   0773 D8            push b
0623   0774 FA FA FF      lea d, [bp + -6] ; $i
0624   0777 2A            mov b, [d]
0625   0778 E7            pop d
0626   0779 FD 43         mov [d], b
0627   077B             ;; p = p + 2; 
0628   077B FA FF FF      lea d, [bp + -1] ; $p
0629   077E DA            push d
0630   077F FA FF FF      lea d, [bp + -1] ; $p
0631   0782 2A            mov b, [d]
0632   0783             ; START TERMS
0633   0783 D7            push a
0634   0784 11            mov a, b
0635   0785 26 02 00      mov b, $2
0636   0788 56            add b, a
0637   0789 E4            pop a
0638   078A             ; END TERMS
0639   078A E7            pop d
0640   078B FD 43         mov [d], b
0641   078D             ;; break; 
0642   078D 0A 18 08      jmp _switch8_exit ; case break
0643   0790             _switch8_case5:
0644   0790             ;; p = p + 2; 
0645   0790 FA FF FF      lea d, [bp + -1] ; $p
0646   0793 DA            push d
0647   0794 FA FF FF      lea d, [bp + -1] ; $p
0648   0797 2A            mov b, [d]
0649   0798             ; START TERMS
0650   0798 D7            push a
0651   0799 11            mov a, b
0652   079A 26 02 00      mov b, $2
0653   079D 56            add b, a
0654   079E E4            pop a
0655   079F             ; END TERMS
0656   079F E7            pop d
0657   07A0 FD 43         mov [d], b
0658   07A2             ;; break; 
0659   07A2 0A 18 08      jmp _switch8_exit ; case break
0660   07A5             _switch8_case6:
0661   07A5             ;; c = getchar(); 
0662   07A5 FA FC FF      lea d, [bp + -4] ; $c
0663   07A8 DA            push d
0664   07A9 07 20 10      call getchar
0665   07AC E7            pop d
0666   07AD FD 3E         mov [d], bl
0667   07AF             ;; **(char **)p = c; 
0668   07AF FA FF FF      lea d, [bp + -1] ; $p
0669   07B2 2A            mov b, [d]
0670   07B3 74            mov d, b
0671   07B4 2A            mov b, [d]
0672   07B5 D8            push b
0673   07B6 FA FC FF      lea d, [bp + -4] ; $c
0674   07B9 32            mov bl, [d]
0675   07BA A7 00         mov bh, 0
0676   07BC E7            pop d
0677   07BD FD 43         mov [d], b
0678   07BF             ;; p = p + 2; 
0679   07BF FA FF FF      lea d, [bp + -1] ; $p
0680   07C2 DA            push d
0681   07C3 FA FF FF      lea d, [bp + -1] ; $p
0682   07C6 2A            mov b, [d]
0683   07C7             ; START TERMS
0684   07C7 D7            push a
0685   07C8 11            mov a, b
0686   07C9 26 02 00      mov b, $2
0687   07CC 56            add b, a
0688   07CD E4            pop a
0689   07CE             ; END TERMS
0690   07CE E7            pop d
0691   07CF FD 43         mov [d], b
0692   07D1             ;; break; 
0693   07D1 0A 18 08      jmp _switch8_exit ; case break
0694   07D4             _switch8_case7:
0695   07D4             ;; gets(input_string); 
0696   07D4 FA FA FD      lea d, [bp + -518] ; $input_string
0697   07D7 2D            mov b, d
0698   07D8 FD AB         swp b
0699   07DA D8            push b
0700   07DB 07 0F 0C      call gets
0701   07DE 51 02 00      add sp, 2
0702   07E1             ;; strcpy(*(char **)p, input_string); 
0703   07E1 FA FA FD      lea d, [bp + -518] ; $input_string
0704   07E4 2D            mov b, d
0705   07E5 FD AB         swp b
0706   07E7 D8            push b
0707   07E8 FA FF FF      lea d, [bp + -1] ; $p
0708   07EB 2A            mov b, [d]
0709   07EC 74            mov d, b
0710   07ED 2A            mov b, [d]
0711   07EE FD AB         swp b
0712   07F0 D8            push b
0713   07F1 07 56 04      call strcpy
0714   07F4 51 04 00      add sp, 4
0715   07F7             ;; p = p + 2; 
0716   07F7 FA FF FF      lea d, [bp + -1] ; $p
0717   07FA DA            push d
0718   07FB FA FF FF      lea d, [bp + -1] ; $p
0719   07FE 2A            mov b, [d]
0720   07FF             ; START TERMS
0721   07FF D7            push a
0722   0800 11            mov a, b
0723   0801 26 02 00      mov b, $2
0724   0804 56            add b, a
0725   0805 E4            pop a
0726   0806             ; END TERMS
0727   0806 E7            pop d
0728   0807 FD 43         mov [d], b
0729   0809             ;; break; 
0730   0809 0A 18 08      jmp _switch8_exit ; case break
0731   080C             _switch8_default:
0732   080C             ;; print("Error: Unknown argument type.\n"); 
0733   080C 26 4C 14      mov b, __s1 ; "Error: Unknown argument type.\n"
0734   080F FD AB         swp b
0735   0811 D8            push b
0736   0812 07 5B 10      call print
0737   0815 51 02 00      add sp, 2
0738   0818             _switch8_exit:
0739   0818             ;; format_p++; 
0740   0818 FA FD FF      lea d, [bp + -3] ; $format_p
0741   081B 2A            mov b, [d]
0742   081C D8            push b
0743   081D FD 77         inc b
0744   081F FA FD FF      lea d, [bp + -3] ; $format_p
0745   0822 FD 43         mov [d], b
0746   0824 E5            pop b
0747   0825 0A 44 08      jmp _if7_exit
0748   0828             _if7_else:
0749   0828             ;; putchar(*format_p); 
0750   0828 FA FD FF      lea d, [bp + -3] ; $format_p
0751   082B 2A            mov b, [d]
0752   082C 74            mov d, b
0753   082D 32            mov bl, [d]
0754   082E A7 00         mov bh, 0
0755   0830 DD            push bl
0756   0831 07 13 10      call putchar
0757   0834 51 01 00      add sp, 1
0758   0837             ;; format_p++; 
0759   0837 FA FD FF      lea d, [bp + -3] ; $format_p
0760   083A 2A            mov b, [d]
0761   083B D8            push b
0762   083C FD 77         inc b
0763   083E FA FD FF      lea d, [bp + -3] ; $format_p
0764   0841 FD 43         mov [d], b
0765   0843 E5            pop b
0766   0844             _if7_exit:
0767   0844             _if6_exit:
0768   0844             _for5_update:
0769   0844 0A 31 06      jmp _for5_cond
0770   0847             _for5_exit:
0771   0847 F9            leave
0772   0848 09            ret
0773   0849             
0774   0849             printf:
0775   0849 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0776   084C             ; $p 
0777   084C             ; $format_p 
0778   084C 52 04 00      sub sp, 4
0779   084F             ;; format_p = format; 
0780   084F FA FD FF      lea d, [bp + -3] ; $format_p
0781   0852 DA            push d
0782   0853 FA 05 00      lea d, [bp + 5] ; $format
0783   0856 2A            mov b, [d]
0784   0857 E7            pop d
0785   0858 FD 43         mov [d], b
0786   085A             ;; p = &format + 2; 
0787   085A FA FF FF      lea d, [bp + -1] ; $p
0788   085D DA            push d
0789   085E FA 05 00      lea d, [bp + 5] ; $format
0790   0861 2D            mov b, d
0791   0862             ; START TERMS
0792   0862 D7            push a
0793   0863 11            mov a, b
0794   0864 26 02 00      mov b, $2
0795   0867 56            add b, a
0796   0868 E4            pop a
0797   0869             ; END TERMS
0798   0869 E7            pop d
0799   086A FD 43         mov [d], b
0800   086C             ;; for(;;){ 
0801   086C             _for12_init:
0802   086C             _for12_cond:
0803   086C             _for12_block:
0804   086C             ;; if(!*format_p) break; 
0805   086C             _if13_cond:
0806   086C FA FD FF      lea d, [bp + -3] ; $format_p
0807   086F 2A            mov b, [d]
0808   0870 74            mov d, b
0809   0871 32            mov bl, [d]
0810   0872 A7 00         mov bh, 0
0811   0874 C0 00 00      cmp b, 0
0812   0877 FD 71         seq ; !
0813   0879 C0 00 00      cmp b, 0
0814   087C C6 85 08      je _if13_else
0815   087F             _if13_true:
0816   087F             ;; break; 
0817   087F 0A 8E 0A      jmp _for12_exit ; for break
0818   0882 0A 8B 0A      jmp _if13_exit
0819   0885             _if13_else:
0820   0885             ;; if(*format_p == '%'){ 
0821   0885             _if14_cond:
0822   0885 FA FD FF      lea d, [bp + -3] ; $format_p
0823   0888 2A            mov b, [d]
0824   0889 74            mov d, b
0825   088A 32            mov bl, [d]
0826   088B A7 00         mov bh, 0
0827   088D             ; START RELATIONAL
0828   088D D7            push a
0829   088E 11            mov a, b
0830   088F 26 25 00      mov b, $25
0831   0892 B0            cmp a, b
0832   0893 FD 71         seq ; ==
0833   0895 E4            pop a
0834   0896             ; END RELATIONAL
0835   0896 C0 00 00      cmp b, 0
0836   0899 C6 6F 0A      je _if14_else
0837   089C             _if14_true:
0838   089C             ;; format_p++; 
0839   089C FA FD FF      lea d, [bp + -3] ; $format_p
0840   089F 2A            mov b, [d]
0841   08A0 D8            push b
0842   08A1 FD 77         inc b
0843   08A3 FA FD FF      lea d, [bp + -3] ; $format_p
0844   08A6 FD 43         mov [d], b
0845   08A8 E5            pop b
0846   08A9             ;; switch(*format_p){ 
0847   08A9             _switch15_expr:
0848   08A9 FA FD FF      lea d, [bp + -3] ; $format_p
0849   08AC 2A            mov b, [d]
0850   08AD 74            mov d, b
0851   08AE 32            mov bl, [d]
0852   08AF A7 00         mov bh, 0
0853   08B1             _switch15_comparisons:
0854   08B1 C1 6C         cmp bl, $6c
0855   08B3 C6 DF 08      je _switch15_case0
0856   08B6 C1 4C         cmp bl, $4c
0857   08B8 C6 DF 08      je _switch15_case1
0858   08BB C1 64         cmp bl, $64
0859   08BD C6 AF 09      je _switch15_case2
0860   08C0 C1 69         cmp bl, $69
0861   08C2 C6 AF 09      je _switch15_case3
0862   08C5 C1 75         cmp bl, $75
0863   08C7 C6 D3 09      je _switch15_case4
0864   08CA C1 78         cmp bl, $78
0865   08CC C6 F7 09      je _switch15_case5
0866   08CF C1 63         cmp bl, $63
0867   08D1 C6 15 0A      je _switch15_case6
0868   08D4 C1 73         cmp bl, $73
0869   08D6 C6 34 0A      je _switch15_case7
0870   08D9 0A 53 0A      jmp _switch15_default
0871   08DC 0A 5F 0A      jmp _switch15_exit
0872   08DF             _switch15_case0:
0873   08DF             _switch15_case1:
0874   08DF             ;; format_p++; 
0875   08DF FA FD FF      lea d, [bp + -3] ; $format_p
0876   08E2 2A            mov b, [d]
0877   08E3 D8            push b
0878   08E4 FD 77         inc b
0879   08E6 FA FD FF      lea d, [bp + -3] ; $format_p
0880   08E9 FD 43         mov [d], b
0881   08EB E5            pop b
0882   08EC             ;; if(*format_p == 'd' || *format_p == 'i') 
0883   08EC             _if16_cond:
0884   08EC FA FD FF      lea d, [bp + -3] ; $format_p
0885   08EF 2A            mov b, [d]
0886   08F0 74            mov d, b
0887   08F1 32            mov bl, [d]
0888   08F2 A7 00         mov bh, 0
0889   08F4             ; START RELATIONAL
0890   08F4 D7            push a
0891   08F5 11            mov a, b
0892   08F6 26 64 00      mov b, $64
0893   08F9 B0            cmp a, b
0894   08FA FD 71         seq ; ==
0895   08FC E4            pop a
0896   08FD             ; END RELATIONAL
0897   08FD D7            push a
0898   08FE 11            mov a, b
0899   08FF FA FD FF      lea d, [bp + -3] ; $format_p
0900   0902 2A            mov b, [d]
0901   0903 74            mov d, b
0902   0904 32            mov bl, [d]
0903   0905 A7 00         mov bh, 0
0904   0907             ; START RELATIONAL
0905   0907 D7            push a
0906   0908 11            mov a, b
0907   0909 26 69 00      mov b, $69
0908   090C B0            cmp a, b
0909   090D FD 71         seq ; ==
0910   090F E4            pop a
0911   0910             ; END RELATIONAL
0912   0910 FD A8         sor a, b ; ||
0913   0912 E4            pop a
0914   0913 C0 00 00      cmp b, 0
0915   0916 C6 2D 09      je _if16_else
0916   0919             _if16_true:
0917   0919             ;; print_signed_long(*(long *)p); 
0918   0919 FD 79         mov g, b
0919   091B 28            mov b, c
0920   091C FD AB         swp b
0921   091E D8            push b
0922   091F FD 27         mov b, g
0923   0921 FD AB         swp b
0924   0923 D8            push b
0925   0924 07 19 0D      call print_signed_long
0926   0927 51 04 00      add sp, 4
0927   092A 0A 9A 09      jmp _if16_exit
0928   092D             _if16_else:
0929   092D             ;; if(*format_p == 'u') 
0930   092D             _if17_cond:
0931   092D FA FD FF      lea d, [bp + -3] ; $format_p
0932   0930 2A            mov b, [d]
0933   0931 74            mov d, b
0934   0932 32            mov bl, [d]
0935   0933 A7 00         mov bh, 0
0936   0935             ; START RELATIONAL
0937   0935 D7            push a
0938   0936 11            mov a, b
0939   0937 26 75 00      mov b, $75
0940   093A B0            cmp a, b
0941   093B FD 71         seq ; ==
0942   093D E4            pop a
0943   093E             ; END RELATIONAL
0944   093E C0 00 00      cmp b, 0
0945   0941 C6 58 09      je _if17_else
0946   0944             _if17_true:
0947   0944             ;; print_unsigned_long(*(unsigned long *)p); 
0948   0944 FD 79         mov g, b
0949   0946 28            mov b, c
0950   0947 FD AB         swp b
0951   0949 D8            push b
0952   094A FD 27         mov b, g
0953   094C FD AB         swp b
0954   094E D8            push b
0955   094F 07 4E 0E      call print_unsigned_long
0956   0952 51 04 00      add sp, 4
0957   0955 0A 9A 09      jmp _if17_exit
0958   0958             _if17_else:
0959   0958             ;; if(*format_p == 'x') 
0960   0958             _if18_cond:
0961   0958 FA FD FF      lea d, [bp + -3] ; $format_p
0962   095B 2A            mov b, [d]
0963   095C 74            mov d, b
0964   095D 32            mov bl, [d]
0965   095E A7 00         mov bh, 0
0966   0960             ; START RELATIONAL
0967   0960 D7            push a
0968   0961 11            mov a, b
0969   0962 26 78 00      mov b, $78
0970   0965 B0            cmp a, b
0971   0966 FD 71         seq ; ==
0972   0968 E4            pop a
0973   0969             ; END RELATIONAL
0974   0969 C0 00 00      cmp b, 0
0975   096C C6 8E 09      je _if18_else
0976   096F             _if18_true:
0977   096F             ;; printx32(*(long int *)p); 
0978   096F FA FF FF      lea d, [bp + -1] ; $p
0979   0972 2A            mov b, [d]
0980   0973 74            mov d, b
0981   0974 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0982   0977 FD 39         mov c, b ; And place it into C
0983   0979 2A            mov b, [d] ; Lower Word in B
0984   097A FD 79         mov g, b
0985   097C 28            mov b, c
0986   097D FD AB         swp b
0987   097F D8            push b
0988   0980 FD 27         mov b, g
0989   0982 FD AB         swp b
0990   0984 D8            push b
0991   0985 07 A2 0A      call printx32
0992   0988 51 04 00      add sp, 4
0993   098B 0A 9A 09      jmp _if18_exit
0994   098E             _if18_else:
0995   098E             ;; err("Unexpected format in printf."); 
0996   098E 26 2F 14      mov b, __s0 ; "Unexpected format in printf."
0997   0991 FD AB         swp b
0998   0993 D8            push b
0999   0994 07 90 0A      call err
1000   0997 51 02 00      add sp, 2
1001   099A             _if18_exit:
1002   099A             _if17_exit:
1003   099A             _if16_exit:
1004   099A             ;; p = p + 4; 
1005   099A FA FF FF      lea d, [bp + -1] ; $p
1006   099D DA            push d
1007   099E FA FF FF      lea d, [bp + -1] ; $p
1008   09A1 2A            mov b, [d]
1009   09A2             ; START TERMS
1010   09A2 D7            push a
1011   09A3 11            mov a, b
1012   09A4 26 04 00      mov b, $4
1013   09A7 56            add b, a
1014   09A8 E4            pop a
1015   09A9             ; END TERMS
1016   09A9 E7            pop d
1017   09AA FD 43         mov [d], b
1018   09AC             ;; break; 
1019   09AC 0A 5F 0A      jmp _switch15_exit ; case break
1020   09AF             _switch15_case2:
1021   09AF             _switch15_case3:
1022   09AF             ;; print_signed(*(int*)p); 
1023   09AF FA FF FF      lea d, [bp + -1] ; $p
1024   09B2 2A            mov b, [d]
1025   09B3 74            mov d, b
1026   09B4 2A            mov b, [d]
1027   09B5 FD AB         swp b
1028   09B7 D8            push b
1029   09B8 07 29 0C      call print_signed
1030   09BB 51 02 00      add sp, 2
1031   09BE             ;; p = p + 2; 
1032   09BE FA FF FF      lea d, [bp + -1] ; $p
1033   09C1 DA            push d
1034   09C2 FA FF FF      lea d, [bp + -1] ; $p
1035   09C5 2A            mov b, [d]
1036   09C6             ; START TERMS
1037   09C6 D7            push a
1038   09C7 11            mov a, b
1039   09C8 26 02 00      mov b, $2
1040   09CB 56            add b, a
1041   09CC E4            pop a
1042   09CD             ; END TERMS
1043   09CD E7            pop d
1044   09CE FD 43         mov [d], b
1045   09D0             ;; break; 
1046   09D0 0A 5F 0A      jmp _switch15_exit ; case break
1047   09D3             _switch15_case4:
1048   09D3             ;; print_unsigned(*(unsigned int*)p); 
1049   09D3 FA FF FF      lea d, [bp + -1] ; $p
1050   09D6 2A            mov b, [d]
1051   09D7 74            mov d, b
1052   09D8 2A            mov b, [d]
1053   09D9 FD AB         swp b
1054   09DB D8            push b
1055   09DC 07 43 0F      call print_unsigned
1056   09DF 51 02 00      add sp, 2
1057   09E2             ;; p = p + 2; 
1058   09E2 FA FF FF      lea d, [bp + -1] ; $p
1059   09E5 DA            push d
1060   09E6 FA FF FF      lea d, [bp + -1] ; $p
1061   09E9 2A            mov b, [d]
1062   09EA             ; START TERMS
1063   09EA D7            push a
1064   09EB 11            mov a, b
1065   09EC 26 02 00      mov b, $2
1066   09EF 56            add b, a
1067   09F0 E4            pop a
1068   09F1             ; END TERMS
1069   09F1 E7            pop d
1070   09F2 FD 43         mov [d], b
1071   09F4             ;; break; 
1072   09F4 0A 5F 0A      jmp _switch15_exit ; case break
1073   09F7             _switch15_case5:
1074   09F7             
1075   09F7             ; --- BEGIN INLINE ASM BLOCK
1076   09F7 FA FF FF      lea d, [bp + -1] ; $p
1077   09FA FD 2A         mov d, [d]
1078   09FC 2A            mov b, [d]
1079   09FD 07 21 13      call print_u16x
1080   0A00             ; --- END INLINE ASM BLOCK
1081   0A00             
1082   0A00             ;; p = p + 2; 
1083   0A00 FA FF FF      lea d, [bp + -1] ; $p
1084   0A03 DA            push d
1085   0A04 FA FF FF      lea d, [bp + -1] ; $p
1086   0A07 2A            mov b, [d]
1087   0A08             ; START TERMS
1088   0A08 D7            push a
1089   0A09 11            mov a, b
1090   0A0A 26 02 00      mov b, $2
1091   0A0D 56            add b, a
1092   0A0E E4            pop a
1093   0A0F             ; END TERMS
1094   0A0F E7            pop d
1095   0A10 FD 43         mov [d], b
1096   0A12             ;; break; 
1097   0A12 0A 5F 0A      jmp _switch15_exit ; case break
1098   0A15             _switch15_case6:
1099   0A15             
1100   0A15             ; --- BEGIN INLINE ASM BLOCK
1101   0A15 FA FF FF      lea d, [bp + -1] ; $p
1102   0A18 FD 2A         mov d, [d]
1103   0A1A 1E            mov al, [d]
1104   0A1B 23            mov ah, al
1105   0A1C 07 7F 11      call _putchar
1106   0A1F             ; --- END INLINE ASM BLOCK
1107   0A1F             
1108   0A1F             ;; p = p + 2; 
1109   0A1F FA FF FF      lea d, [bp + -1] ; $p
1110   0A22 DA            push d
1111   0A23 FA FF FF      lea d, [bp + -1] ; $p
1112   0A26 2A            mov b, [d]
1113   0A27             ; START TERMS
1114   0A27 D7            push a
1115   0A28 11            mov a, b
1116   0A29 26 02 00      mov b, $2
1117   0A2C 56            add b, a
1118   0A2D E4            pop a
1119   0A2E             ; END TERMS
1120   0A2E E7            pop d
1121   0A2F FD 43         mov [d], b
1122   0A31             ;; break; 
1123   0A31 0A 5F 0A      jmp _switch15_exit ; case break
1124   0A34             _switch15_case7:
1125   0A34             
1126   0A34             ; --- BEGIN INLINE ASM BLOCK
1127   0A34 FA FF FF      lea d, [bp + -1] ; $p
1128   0A37 FD 2A         mov d, [d]
1129   0A39 FD 2A         mov d, [d]
1130   0A3B 07 C9 12      call _puts
1131   0A3E             ; --- END INLINE ASM BLOCK
1132   0A3E             
1133   0A3E             ;; p = p + 2; 
1134   0A3E FA FF FF      lea d, [bp + -1] ; $p
1135   0A41 DA            push d
1136   0A42 FA FF FF      lea d, [bp + -1] ; $p
1137   0A45 2A            mov b, [d]
1138   0A46             ; START TERMS
1139   0A46 D7            push a
1140   0A47 11            mov a, b
1141   0A48 26 02 00      mov b, $2
1142   0A4B 56            add b, a
1143   0A4C E4            pop a
1144   0A4D             ; END TERMS
1145   0A4D E7            pop d
1146   0A4E FD 43         mov [d], b
1147   0A50             ;; break; 
1148   0A50 0A 5F 0A      jmp _switch15_exit ; case break
1149   0A53             _switch15_default:
1150   0A53             ;; print("Error: Unknown argument type.\n"); 
1151   0A53 26 4C 14      mov b, __s1 ; "Error: Unknown argument type.\n"
1152   0A56 FD AB         swp b
1153   0A58 D8            push b
1154   0A59 07 5B 10      call print
1155   0A5C 51 02 00      add sp, 2
1156   0A5F             _switch15_exit:
1157   0A5F             ;; format_p++; 
1158   0A5F FA FD FF      lea d, [bp + -3] ; $format_p
1159   0A62 2A            mov b, [d]
1160   0A63 D8            push b
1161   0A64 FD 77         inc b
1162   0A66 FA FD FF      lea d, [bp + -3] ; $format_p
1163   0A69 FD 43         mov [d], b
1164   0A6B E5            pop b
1165   0A6C 0A 8B 0A      jmp _if14_exit
1166   0A6F             _if14_else:
1167   0A6F             ;; putchar(*format_p); 
1168   0A6F FA FD FF      lea d, [bp + -3] ; $format_p
1169   0A72 2A            mov b, [d]
1170   0A73 74            mov d, b
1171   0A74 32            mov bl, [d]
1172   0A75 A7 00         mov bh, 0
1173   0A77 DD            push bl
1174   0A78 07 13 10      call putchar
1175   0A7B 51 01 00      add sp, 1
1176   0A7E             ;; format_p++; 
1177   0A7E FA FD FF      lea d, [bp + -3] ; $format_p
1178   0A81 2A            mov b, [d]
1179   0A82 D8            push b
1180   0A83 FD 77         inc b
1181   0A85 FA FD FF      lea d, [bp + -3] ; $format_p
1182   0A88 FD 43         mov [d], b
1183   0A8A E5            pop b
1184   0A8B             _if14_exit:
1185   0A8B             _if13_exit:
1186   0A8B             _for12_update:
1187   0A8B 0A 6C 08      jmp _for12_cond
1188   0A8E             _for12_exit:
1189   0A8E F9            leave
1190   0A8F 09            ret
1191   0A90             
1192   0A90             err:
1193   0A90 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1194   0A93             ;; print(e); 
1195   0A93 FA 05 00      lea d, [bp + 5] ; $e
1196   0A96 2A            mov b, [d]
1197   0A97 FD AB         swp b
1198   0A99 D8            push b
1199   0A9A 07 5B 10      call print
1200   0A9D 51 02 00      add sp, 2
1201   0AA0 F9            leave
1202   0AA1 09            ret
1203   0AA2             
1204   0AA2             printx32:
1205   0AA2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1206   0AA5             
1207   0AA5             ; --- BEGIN INLINE ASM BLOCK
1208   0AA5 FA 05 00      lea d, [bp + 5] ; $hex
1209   0AA8 2B 02 00      mov b, [d+2]
1210   0AAB 07 21 13      call print_u16x
1211   0AAE 2A            mov b, [d]
1212   0AAF 07 21 13      call print_u16x
1213   0AB2             ; --- END INLINE ASM BLOCK
1214   0AB2             
1215   0AB2 F9            leave
1216   0AB3 09            ret
1217   0AB4             
1218   0AB4             printx16:
1219   0AB4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1220   0AB7             
1221   0AB7             ; --- BEGIN INLINE ASM BLOCK
1222   0AB7 FA 05 00      lea d, [bp + 5] ; $hex
1223   0ABA 2A            mov b, [d]
1224   0ABB 07 21 13      call print_u16x
1225   0ABE             ; --- END INLINE ASM BLOCK
1226   0ABE             
1227   0ABE F9            leave
1228   0ABF 09            ret
1229   0AC0             
1230   0AC0             printx8:
1231   0AC0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1232   0AC3             
1233   0AC3             ; --- BEGIN INLINE ASM BLOCK
1234   0AC3 FA 05 00      lea d, [bp + 5] ; $hex
1235   0AC6 32            mov bl, [d]
1236   0AC7 07 65 13      call print_u8x
1237   0ACA             ; --- END INLINE ASM BLOCK
1238   0ACA             
1239   0ACA F9            leave
1240   0ACB 09            ret
1241   0ACC             
1242   0ACC             hex_str_to_int:
1243   0ACC F8 00 00      enter 0 ; (push bp; mov bp, sp)
1244   0ACF             ; $value 
1245   0ACF 10 00 00      mov a, $0
1246   0AD2 45 FF FF      mov [bp + -1], a
1247   0AD5             ; $i 
1248   0AD5             ; $hex_char 
1249   0AD5             ; $len 
1250   0AD5 52 07 00      sub sp, 7
1251   0AD8             ;; len = strlen(hex_string); 
1252   0AD8 FA FA FF      lea d, [bp + -6] ; $len
1253   0ADB DA            push d
1254   0ADC FA 05 00      lea d, [bp + 5] ; $hex_string
1255   0ADF 2A            mov b, [d]
1256   0AE0 FD AB         swp b
1257   0AE2 D8            push b
1258   0AE3 07 C5 05      call strlen
1259   0AE6 51 02 00      add sp, 2
1260   0AE9 E7            pop d
1261   0AEA FD 43         mov [d], b
1262   0AEC             ;; for (i = 0; i < len; i++) { 
1263   0AEC             _for19_init:
1264   0AEC FA FD FF      lea d, [bp + -3] ; $i
1265   0AEF DA            push d
1266   0AF0 26 00 00      mov b, $0
1267   0AF3 E7            pop d
1268   0AF4 FD 43         mov [d], b
1269   0AF6             _for19_cond:
1270   0AF6 FA FD FF      lea d, [bp + -3] ; $i
1271   0AF9 2A            mov b, [d]
1272   0AFA             ; START RELATIONAL
1273   0AFA D7            push a
1274   0AFB 11            mov a, b
1275   0AFC FA FA FF      lea d, [bp + -6] ; $len
1276   0AFF 2A            mov b, [d]
1277   0B00 B0            cmp a, b
1278   0B01 FD 73         slt ; < (signed)
1279   0B03 E4            pop a
1280   0B04             ; END RELATIONAL
1281   0B04 C0 00 00      cmp b, 0
1282   0B07 C6 09 0C      je _for19_exit
1283   0B0A             _for19_block:
1284   0B0A             ;; hex_char = hex_string[i]; 
1285   0B0A FA FC FF      lea d, [bp + -4] ; $hex_char
1286   0B0D DA            push d
1287   0B0E FA 05 00      lea d, [bp + 5] ; $hex_string
1288   0B11 FD 2A         mov d, [d]
1289   0B13 D7            push a
1290   0B14 DA            push d
1291   0B15 FA FD FF      lea d, [bp + -3] ; $i
1292   0B18 2A            mov b, [d]
1293   0B19 E7            pop d
1294   0B1A FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
1295   0B1E E4            pop a
1296   0B1F 32            mov bl, [d]
1297   0B20 A7 00         mov bh, 0
1298   0B22 E7            pop d
1299   0B23 FD 3E         mov [d], bl
1300   0B25             ;; if (hex_char >= 'a' && hex_char <= 'f')  
1301   0B25             _if20_cond:
1302   0B25 FA FC FF      lea d, [bp + -4] ; $hex_char
1303   0B28 32            mov bl, [d]
1304   0B29 A7 00         mov bh, 0
1305   0B2B             ; START RELATIONAL
1306   0B2B D7            push a
1307   0B2C 11            mov a, b
1308   0B2D 26 61 00      mov b, $61
1309   0B30 B0            cmp a, b
1310   0B31 FD 80         sge ; >=
1311   0B33 E4            pop a
1312   0B34             ; END RELATIONAL
1313   0B34 D7            push a
1314   0B35 11            mov a, b
1315   0B36 FA FC FF      lea d, [bp + -4] ; $hex_char
1316   0B39 32            mov bl, [d]
1317   0B3A A7 00         mov bh, 0
1318   0B3C             ; START RELATIONAL
1319   0B3C D7            push a
1320   0B3D 11            mov a, b
1321   0B3E 26 66 00      mov b, $66
1322   0B41 B0            cmp a, b
1323   0B42 FD 73         slt ; <= (signed)
1324   0B44 E4            pop a
1325   0B45             ; END RELATIONAL
1326   0B45 FD A7         sand a, b
1327   0B47 E4            pop a
1328   0B48 C0 00 00      cmp b, 0
1329   0B4B C6 7C 0B      je _if20_else
1330   0B4E             _if20_true:
1331   0B4E             ;; value = (value * 16) + (hex_char - 'a' + 10); 
1332   0B4E FA FF FF      lea d, [bp + -1] ; $value
1333   0B51 DA            push d
1334   0B52 FA FF FF      lea d, [bp + -1] ; $value
1335   0B55 2A            mov b, [d]
1336   0B56             ; START FACTORS
1337   0B56 D7            push a
1338   0B57 11            mov a, b
1339   0B58 26 10 00      mov b, $10
1340   0B5B AC            mul a, b ; *
1341   0B5C 11            mov a, b
1342   0B5D 27            mov b, a
1343   0B5E E4            pop a
1344   0B5F             ; END FACTORS
1345   0B5F             ; START TERMS
1346   0B5F D7            push a
1347   0B60 11            mov a, b
1348   0B61 FA FC FF      lea d, [bp + -4] ; $hex_char
1349   0B64 32            mov bl, [d]
1350   0B65 A7 00         mov bh, 0
1351   0B67             ; START TERMS
1352   0B67 D7            push a
1353   0B68 11            mov a, b
1354   0B69 26 61 00      mov b, $61
1355   0B6C 60            sub a, b
1356   0B6D 27            mov b, a
1357   0B6E 11            mov a, b
1358   0B6F 26 0A 00      mov b, $a
1359   0B72 56            add b, a
1360   0B73 E4            pop a
1361   0B74             ; END TERMS
1362   0B74 56            add b, a
1363   0B75 E4            pop a
1364   0B76             ; END TERMS
1365   0B76 E7            pop d
1366   0B77 FD 43         mov [d], b
1367   0B79 0A F9 0B      jmp _if20_exit
1368   0B7C             _if20_else:
1369   0B7C             ;; if (hex_char >= 'A' && hex_char <= 'F')  
1370   0B7C             _if21_cond:
1371   0B7C FA FC FF      lea d, [bp + -4] ; $hex_char
1372   0B7F 32            mov bl, [d]
1373   0B80 A7 00         mov bh, 0
1374   0B82             ; START RELATIONAL
1375   0B82 D7            push a
1376   0B83 11            mov a, b
1377   0B84 26 41 00      mov b, $41
1378   0B87 B0            cmp a, b
1379   0B88 FD 80         sge ; >=
1380   0B8A E4            pop a
1381   0B8B             ; END RELATIONAL
1382   0B8B D7            push a
1383   0B8C 11            mov a, b
1384   0B8D FA FC FF      lea d, [bp + -4] ; $hex_char
1385   0B90 32            mov bl, [d]
1386   0B91 A7 00         mov bh, 0
1387   0B93             ; START RELATIONAL
1388   0B93 D7            push a
1389   0B94 11            mov a, b
1390   0B95 26 46 00      mov b, $46
1391   0B98 B0            cmp a, b
1392   0B99 FD 73         slt ; <= (signed)
1393   0B9B E4            pop a
1394   0B9C             ; END RELATIONAL
1395   0B9C FD A7         sand a, b
1396   0B9E E4            pop a
1397   0B9F C0 00 00      cmp b, 0
1398   0BA2 C6 D3 0B      je _if21_else
1399   0BA5             _if21_true:
1400   0BA5             ;; value = (value * 16) + (hex_char - 'A' + 10); 
1401   0BA5 FA FF FF      lea d, [bp + -1] ; $value
1402   0BA8 DA            push d
1403   0BA9 FA FF FF      lea d, [bp + -1] ; $value
1404   0BAC 2A            mov b, [d]
1405   0BAD             ; START FACTORS
1406   0BAD D7            push a
1407   0BAE 11            mov a, b
1408   0BAF 26 10 00      mov b, $10
1409   0BB2 AC            mul a, b ; *
1410   0BB3 11            mov a, b
1411   0BB4 27            mov b, a
1412   0BB5 E4            pop a
1413   0BB6             ; END FACTORS
1414   0BB6             ; START TERMS
1415   0BB6 D7            push a
1416   0BB7 11            mov a, b
1417   0BB8 FA FC FF      lea d, [bp + -4] ; $hex_char
1418   0BBB 32            mov bl, [d]
1419   0BBC A7 00         mov bh, 0
1420   0BBE             ; START TERMS
1421   0BBE D7            push a
1422   0BBF 11            mov a, b
1423   0BC0 26 41 00      mov b, $41
1424   0BC3 60            sub a, b
1425   0BC4 27            mov b, a
1426   0BC5 11            mov a, b
1427   0BC6 26 0A 00      mov b, $a
1428   0BC9 56            add b, a
1429   0BCA E4            pop a
1430   0BCB             ; END TERMS
1431   0BCB 56            add b, a
1432   0BCC E4            pop a
1433   0BCD             ; END TERMS
1434   0BCD E7            pop d
1435   0BCE FD 43         mov [d], b
1436   0BD0 0A F9 0B      jmp _if21_exit
1437   0BD3             _if21_else:
1438   0BD3             ;; value = (value * 16) + (hex_char - '0'); 
1439   0BD3 FA FF FF      lea d, [bp + -1] ; $value
1440   0BD6 DA            push d
1441   0BD7 FA FF FF      lea d, [bp + -1] ; $value
1442   0BDA 2A            mov b, [d]
1443   0BDB             ; START FACTORS
1444   0BDB D7            push a
1445   0BDC 11            mov a, b
1446   0BDD 26 10 00      mov b, $10
1447   0BE0 AC            mul a, b ; *
1448   0BE1 11            mov a, b
1449   0BE2 27            mov b, a
1450   0BE3 E4            pop a
1451   0BE4             ; END FACTORS
1452   0BE4             ; START TERMS
1453   0BE4 D7            push a
1454   0BE5 11            mov a, b
1455   0BE6 FA FC FF      lea d, [bp + -4] ; $hex_char
1456   0BE9 32            mov bl, [d]
1457   0BEA A7 00         mov bh, 0
1458   0BEC             ; START TERMS
1459   0BEC D7            push a
1460   0BED 11            mov a, b
1461   0BEE 26 30 00      mov b, $30
1462   0BF1 60            sub a, b
1463   0BF2 27            mov b, a
1464   0BF3 E4            pop a
1465   0BF4             ; END TERMS
1466   0BF4 56            add b, a
1467   0BF5 E4            pop a
1468   0BF6             ; END TERMS
1469   0BF6 E7            pop d
1470   0BF7 FD 43         mov [d], b
1471   0BF9             _if21_exit:
1472   0BF9             _if20_exit:
1473   0BF9             _for19_update:
1474   0BF9 FA FD FF      lea d, [bp + -3] ; $i
1475   0BFC 2A            mov b, [d]
1476   0BFD D8            push b
1477   0BFE FD 77         inc b
1478   0C00 FA FD FF      lea d, [bp + -3] ; $i
1479   0C03 FD 43         mov [d], b
1480   0C05 E5            pop b
1481   0C06 0A F6 0A      jmp _for19_cond
1482   0C09             _for19_exit:
1483   0C09             ;; return value; 
1484   0C09 FA FF FF      lea d, [bp + -1] ; $value
1485   0C0C 2A            mov b, [d]
1486   0C0D F9            leave
1487   0C0E 09            ret
1488   0C0F             
1489   0C0F             gets:
1490   0C0F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1491   0C12             
1492   0C12             ; --- BEGIN INLINE ASM BLOCK
1493   0C12 FA 05 00      lea d, [bp + 5] ; $s
1494   0C15 15            mov a, [d]
1495   0C16 3C            mov d, a
1496   0C17 07 86 11      call _gets
1497   0C1A             ; --- END INLINE ASM BLOCK
1498   0C1A             
1499   0C1A             ;; return strlen(s); 
1500   0C1A FA 05 00      lea d, [bp + 5] ; $s
1501   0C1D 2A            mov b, [d]
1502   0C1E FD AB         swp b
1503   0C20 D8            push b
1504   0C21 07 C5 05      call strlen
1505   0C24 51 02 00      add sp, 2
1506   0C27 F9            leave
1507   0C28 09            ret
1508   0C29             
1509   0C29             print_signed:
1510   0C29 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1511   0C2C             ; $digits 
1512   0C2C             ; $i 
1513   0C2C 10 00 00      mov a, $0
1514   0C2F 45 FA FF      mov [bp + -6], a
1515   0C32 52 07 00      sub sp, 7
1516   0C35             ;; if (num < 0) { 
1517   0C35             _if22_cond:
1518   0C35 FA 05 00      lea d, [bp + 5] ; $num
1519   0C38 2A            mov b, [d]
1520   0C39             ; START RELATIONAL
1521   0C39 D7            push a
1522   0C3A 11            mov a, b
1523   0C3B 26 00 00      mov b, $0
1524   0C3E B0            cmp a, b
1525   0C3F FD 73         slt ; < (signed)
1526   0C41 E4            pop a
1527   0C42             ; END RELATIONAL
1528   0C42 C0 00 00      cmp b, 0
1529   0C45 C6 62 0C      je _if22_else
1530   0C48             _if22_true:
1531   0C48             ;; putchar('-'); 
1532   0C48 26 2D 00      mov b, $2d
1533   0C4B DD            push bl
1534   0C4C 07 13 10      call putchar
1535   0C4F 51 01 00      add sp, 1
1536   0C52             ;; num = -num; 
1537   0C52 FA 05 00      lea d, [bp + 5] ; $num
1538   0C55 DA            push d
1539   0C56 FA 05 00      lea d, [bp + 5] ; $num
1540   0C59 2A            mov b, [d]
1541   0C5A FD 97         neg b
1542   0C5C E7            pop d
1543   0C5D FD 43         mov [d], b
1544   0C5F 0A 84 0C      jmp _if22_exit
1545   0C62             _if22_else:
1546   0C62             ;; if (num == 0) { 
1547   0C62             _if23_cond:
1548   0C62 FA 05 00      lea d, [bp + 5] ; $num
1549   0C65 2A            mov b, [d]
1550   0C66             ; START RELATIONAL
1551   0C66 D7            push a
1552   0C67 11            mov a, b
1553   0C68 26 00 00      mov b, $0
1554   0C6B B0            cmp a, b
1555   0C6C FD 71         seq ; ==
1556   0C6E E4            pop a
1557   0C6F             ; END RELATIONAL
1558   0C6F C0 00 00      cmp b, 0
1559   0C72 C6 84 0C      je _if23_exit
1560   0C75             _if23_true:
1561   0C75             ;; putchar('0'); 
1562   0C75 26 30 00      mov b, $30
1563   0C78 DD            push bl
1564   0C79 07 13 10      call putchar
1565   0C7C 51 01 00      add sp, 1
1566   0C7F             ;; return; 
1567   0C7F F9            leave
1568   0C80 09            ret
1569   0C81 0A 84 0C      jmp _if23_exit
1570   0C84             _if23_exit:
1571   0C84             _if22_exit:
1572   0C84             ;; while (num > 0) { 
1573   0C84             _while24_cond:
1574   0C84 FA 05 00      lea d, [bp + 5] ; $num
1575   0C87 2A            mov b, [d]
1576   0C88             ; START RELATIONAL
1577   0C88 D7            push a
1578   0C89 11            mov a, b
1579   0C8A 26 00 00      mov b, $0
1580   0C8D B0            cmp a, b
1581   0C8E FD 7F         sgt ; >
1582   0C90 E4            pop a
1583   0C91             ; END RELATIONAL
1584   0C91 C0 00 00      cmp b, 0
1585   0C94 C6 DE 0C      je _while24_exit
1586   0C97             _while24_block:
1587   0C97             ;; digits[i] = '0' + (num % 10); 
1588   0C97 FA FC FF      lea d, [bp + -4] ; $digits
1589   0C9A D7            push a
1590   0C9B DA            push d
1591   0C9C FA FA FF      lea d, [bp + -6] ; $i
1592   0C9F 2A            mov b, [d]
1593   0CA0 E7            pop d
1594   0CA1 5A            add d, b
1595   0CA2 E4            pop a
1596   0CA3 DA            push d
1597   0CA4 26 30 00      mov b, $30
1598   0CA7             ; START TERMS
1599   0CA7 D7            push a
1600   0CA8 11            mov a, b
1601   0CA9 FA 05 00      lea d, [bp + 5] ; $num
1602   0CAC 2A            mov b, [d]
1603   0CAD             ; START FACTORS
1604   0CAD D7            push a
1605   0CAE 11            mov a, b
1606   0CAF 26 0A 00      mov b, $a
1607   0CB2 AE            div a, b ; 
1608   0CB3 11            mov a, b
1609   0CB4 27            mov b, a
1610   0CB5 E4            pop a
1611   0CB6             ; END FACTORS
1612   0CB6 56            add b, a
1613   0CB7 E4            pop a
1614   0CB8             ; END TERMS
1615   0CB8 E7            pop d
1616   0CB9 FD 3E         mov [d], bl
1617   0CBB             ;; num = num / 10; 
1618   0CBB FA 05 00      lea d, [bp + 5] ; $num
1619   0CBE DA            push d
1620   0CBF FA 05 00      lea d, [bp + 5] ; $num
1621   0CC2 2A            mov b, [d]
1622   0CC3             ; START FACTORS
1623   0CC3 D7            push a
1624   0CC4 11            mov a, b
1625   0CC5 26 0A 00      mov b, $a
1626   0CC8 AE            div a, b
1627   0CC9 27            mov b, a
1628   0CCA E4            pop a
1629   0CCB             ; END FACTORS
1630   0CCB E7            pop d
1631   0CCC FD 43         mov [d], b
1632   0CCE             ;; i++; 
1633   0CCE FA FA FF      lea d, [bp + -6] ; $i
1634   0CD1 2A            mov b, [d]
1635   0CD2 D8            push b
1636   0CD3 FD 77         inc b
1637   0CD5 FA FA FF      lea d, [bp + -6] ; $i
1638   0CD8 FD 43         mov [d], b
1639   0CDA E5            pop b
1640   0CDB 0A 84 0C      jmp _while24_cond
1641   0CDE             _while24_exit:
1642   0CDE             ;; while (i > 0) { 
1643   0CDE             _while25_cond:
1644   0CDE FA FA FF      lea d, [bp + -6] ; $i
1645   0CE1 2A            mov b, [d]
1646   0CE2             ; START RELATIONAL
1647   0CE2 D7            push a
1648   0CE3 11            mov a, b
1649   0CE4 26 00 00      mov b, $0
1650   0CE7 B0            cmp a, b
1651   0CE8 FD 7F         sgt ; >
1652   0CEA E4            pop a
1653   0CEB             ; END RELATIONAL
1654   0CEB C0 00 00      cmp b, 0
1655   0CEE C6 17 0D      je _while25_exit
1656   0CF1             _while25_block:
1657   0CF1             ;; i--; 
1658   0CF1 FA FA FF      lea d, [bp + -6] ; $i
1659   0CF4 2A            mov b, [d]
1660   0CF5 D8            push b
1661   0CF6 FD 7D         dec b
1662   0CF8 FA FA FF      lea d, [bp + -6] ; $i
1663   0CFB FD 43         mov [d], b
1664   0CFD E5            pop b
1665   0CFE             ;; putchar(digits[i]); 
1666   0CFE FA FC FF      lea d, [bp + -4] ; $digits
1667   0D01 D7            push a
1668   0D02 DA            push d
1669   0D03 FA FA FF      lea d, [bp + -6] ; $i
1670   0D06 2A            mov b, [d]
1671   0D07 E7            pop d
1672   0D08 5A            add d, b
1673   0D09 E4            pop a
1674   0D0A 32            mov bl, [d]
1675   0D0B A7 00         mov bh, 0
1676   0D0D DD            push bl
1677   0D0E 07 13 10      call putchar
1678   0D11 51 01 00      add sp, 1
1679   0D14 0A DE 0C      jmp _while25_cond
1680   0D17             _while25_exit:
1681   0D17 F9            leave
1682   0D18 09            ret
1683   0D19             
1684   0D19             print_signed_long:
1685   0D19 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1686   0D1C             ; $digits 
1687   0D1C             ; $i 
1688   0D1C 10 00 00      mov a, $0
1689   0D1F 45 F5 FF      mov [bp + -11], a
1690   0D22 52 0C 00      sub sp, 12
1691   0D25             ;; if (num < 0) { 
1692   0D25             _if26_cond:
1693   0D25 FA 05 00      lea d, [bp + 5] ; $num
1694   0D28 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1695   0D2B FD 39         mov c, b ; And place it into C
1696   0D2D 2A            mov b, [d] ; Lower Word in B
1697   0D2E             ; START RELATIONAL
1698   0D2E D7            push a
1699   0D2F FD D8         push g
1700   0D31 11            mov a, b
1701   0D32 FD 7A         mov g, c
1702   0D34 26 00 00      mov b, $0
1703   0D37 38 00 00      mov c, 0
1704   0D3A               cmp32 ga, cb
out/test.asm line 1704: unrecognized instruction.          (CMP32)
1705   0D3A FD 73         slt ; <
1706   0D3C FD F1         pop g
1707   0D3E E4            pop a
1708   0D3F             ; END RELATIONAL
1709   0D3F C0 00 00      cmp b, 0
1710   0D42 C6 69 0D      je _if26_else
1711   0D45             _if26_true:
1712   0D45             ;; putchar('-'); 
1713   0D45 26 2D 00      mov b, $2d
1714   0D48 DD            push bl
1715   0D49 07 13 10      call putchar
1716   0D4C 51 01 00      add sp, 1
1717   0D4F             ;; num = -num; 
1718   0D4F FA 05 00      lea d, [bp + 5] ; $num
1719   0D52 DA            push d
1720   0D53 FA 05 00      lea d, [bp + 5] ; $num
1721   0D56 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1722   0D59 FD 39         mov c, b ; And place it into C
1723   0D5B 2A            mov b, [d] ; Lower Word in B
1724   0D5C FD 97         neg b
1725   0D5E E7            pop d
1726   0D5F FD 43         mov [d], b
1727   0D61 28            mov b, c
1728   0D62 FD 44 02 00   mov [d + 2], b
1729   0D66 0A 98 0D      jmp _if26_exit
1730   0D69             _if26_else:
1731   0D69             ;; if (num == 0) { 
1732   0D69             _if27_cond:
1733   0D69 FA 05 00      lea d, [bp + 5] ; $num
1734   0D6C 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1735   0D6F FD 39         mov c, b ; And place it into C
1736   0D71 2A            mov b, [d] ; Lower Word in B
1737   0D72             ; START RELATIONAL
1738   0D72 D7            push a
1739   0D73 FD D8         push g
1740   0D75 11            mov a, b
1741   0D76 FD 7A         mov g, c
1742   0D78 26 00 00      mov b, $0
1743   0D7B 38 00 00      mov c, 0
1744   0D7E               cmp32 ga, cb
out/test.asm line 1744: unrecognized instruction.          (CMP32)
1745   0D7E FD 71         seq ; ==
1746   0D80 FD F1         pop g
1747   0D82 E4            pop a
1748   0D83             ; END RELATIONAL
1749   0D83 C0 00 00      cmp b, 0
1750   0D86 C6 98 0D      je _if27_exit
1751   0D89             _if27_true:
1752   0D89             ;; putchar('0'); 
1753   0D89 26 30 00      mov b, $30
1754   0D8C DD            push bl
1755   0D8D 07 13 10      call putchar
1756   0D90 51 01 00      add sp, 1
1757   0D93             ;; return; 
1758   0D93 F9            leave
1759   0D94 09            ret
1760   0D95 0A 98 0D      jmp _if27_exit
1761   0D98             _if27_exit:
1762   0D98             _if26_exit:
1763   0D98             ;; while (num > 0) { 
1764   0D98             _while28_cond:
1765   0D98 FA 05 00      lea d, [bp + 5] ; $num
1766   0D9B 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1767   0D9E FD 39         mov c, b ; And place it into C
1768   0DA0 2A            mov b, [d] ; Lower Word in B
1769   0DA1             ; START RELATIONAL
1770   0DA1 D7            push a
1771   0DA2 FD D8         push g
1772   0DA4 11            mov a, b
1773   0DA5 FD 7A         mov g, c
1774   0DA7 26 00 00      mov b, $0
1775   0DAA 38 00 00      mov c, 0
1776   0DAD               sgt32 ga, cb
out/test.asm line 1776: unrecognized instruction.          (SGT32)
1777   0DAD FD F1         pop g
1778   0DAF E4            pop a
1779   0DB0             ; END RELATIONAL
1780   0DB0 C0 00 00      cmp b, 0
1781   0DB3 C6 13 0E      je _while28_exit
1782   0DB6             _while28_block:
1783   0DB6             ;; digits[i] = '0' + (num % 10); 
1784   0DB6 FA F7 FF      lea d, [bp + -9] ; $digits
1785   0DB9 D7            push a
1786   0DBA DA            push d
1787   0DBB FA F5 FF      lea d, [bp + -11] ; $i
1788   0DBE 2A            mov b, [d]
1789   0DBF E7            pop d
1790   0DC0 5A            add d, b
1791   0DC1 E4            pop a
1792   0DC2 DA            push d
1793   0DC3 26 30 00      mov b, $30
1794   0DC6             ; START TERMS
1795   0DC6 D7            push a
1796   0DC7 11            mov a, b
1797   0DC8 FA 05 00      lea d, [bp + 5] ; $num
1798   0DCB 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1799   0DCE FD 39         mov c, b ; And place it into C
1800   0DD0 2A            mov b, [d] ; Lower Word in B
1801   0DD1             ; START FACTORS
1802   0DD1 D7            push a
1803   0DD2 11            mov a, b
1804   0DD3 26 0A 00      mov b, $a
1805   0DD6 AE            div a, b ; 
1806   0DD7 11            mov a, b
1807   0DD8 27            mov b, a
1808   0DD9 E4            pop a
1809   0DDA             ; END FACTORS
1810   0DDA 54            add a, b
1811   0DDB D7            push a
1812   0DDC FD 12         mov a, g
1813   0DDE 28            mov b, c
1814   0DDF 5C            adc a, b
1815   0DE0 39            mov c, a
1816   0DE1 E5            pop b
1817   0DE2 E4            pop a
1818   0DE3             ; END TERMS
1819   0DE3 E7            pop d
1820   0DE4 FD 3E         mov [d], bl
1821   0DE6             ;; num = num / 10; 
1822   0DE6 FA 05 00      lea d, [bp + 5] ; $num
1823   0DE9 DA            push d
1824   0DEA FA 05 00      lea d, [bp + 5] ; $num
1825   0DED 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1826   0DF0 FD 39         mov c, b ; And place it into C
1827   0DF2 2A            mov b, [d] ; Lower Word in B
1828   0DF3             ; START FACTORS
1829   0DF3 D7            push a
1830   0DF4 11            mov a, b
1831   0DF5 26 0A 00      mov b, $a
1832   0DF8 AE            div a, b
1833   0DF9 27            mov b, a
1834   0DFA E4            pop a
1835   0DFB             ; END FACTORS
1836   0DFB E7            pop d
1837   0DFC FD 43         mov [d], b
1838   0DFE 28            mov b, c
1839   0DFF FD 44 02 00   mov [d + 2], b
1840   0E03             ;; i++; 
1841   0E03 FA F5 FF      lea d, [bp + -11] ; $i
1842   0E06 2A            mov b, [d]
1843   0E07 D8            push b
1844   0E08 FD 77         inc b
1845   0E0A FA F5 FF      lea d, [bp + -11] ; $i
1846   0E0D FD 43         mov [d], b
1847   0E0F E5            pop b
1848   0E10 0A 98 0D      jmp _while28_cond
1849   0E13             _while28_exit:
1850   0E13             ;; while (i > 0) { 
1851   0E13             _while29_cond:
1852   0E13 FA F5 FF      lea d, [bp + -11] ; $i
1853   0E16 2A            mov b, [d]
1854   0E17             ; START RELATIONAL
1855   0E17 D7            push a
1856   0E18 11            mov a, b
1857   0E19 26 00 00      mov b, $0
1858   0E1C B0            cmp a, b
1859   0E1D FD 7F         sgt ; >
1860   0E1F E4            pop a
1861   0E20             ; END RELATIONAL
1862   0E20 C0 00 00      cmp b, 0
1863   0E23 C6 4C 0E      je _while29_exit
1864   0E26             _while29_block:
1865   0E26             ;; i--; 
1866   0E26 FA F5 FF      lea d, [bp + -11] ; $i
1867   0E29 2A            mov b, [d]
1868   0E2A D8            push b
1869   0E2B FD 7D         dec b
1870   0E2D FA F5 FF      lea d, [bp + -11] ; $i
1871   0E30 FD 43         mov [d], b
1872   0E32 E5            pop b
1873   0E33             ;; putchar(digits[i]); 
1874   0E33 FA F7 FF      lea d, [bp + -9] ; $digits
1875   0E36 D7            push a
1876   0E37 DA            push d
1877   0E38 FA F5 FF      lea d, [bp + -11] ; $i
1878   0E3B 2A            mov b, [d]
1879   0E3C E7            pop d
1880   0E3D 5A            add d, b
1881   0E3E E4            pop a
1882   0E3F 32            mov bl, [d]
1883   0E40 A7 00         mov bh, 0
1884   0E42 DD            push bl
1885   0E43 07 13 10      call putchar
1886   0E46 51 01 00      add sp, 1
1887   0E49 0A 13 0E      jmp _while29_cond
1888   0E4C             _while29_exit:
1889   0E4C F9            leave
1890   0E4D 09            ret
1891   0E4E             
1892   0E4E             print_unsigned_long:
1893   0E4E F8 00 00      enter 0 ; (push bp; mov bp, sp)
1894   0E51             ; $digits 
1895   0E51             ; $i 
1896   0E51 52 0C 00      sub sp, 12
1897   0E54             ;; i = 0; 
1898   0E54 FA F5 FF      lea d, [bp + -11] ; $i
1899   0E57 DA            push d
1900   0E58 26 00 00      mov b, $0
1901   0E5B E7            pop d
1902   0E5C FD 43         mov [d], b
1903   0E5E             ;; if(num == 0){ 
1904   0E5E             _if30_cond:
1905   0E5E FA 05 00      lea d, [bp + 5] ; $num
1906   0E61 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1907   0E64 FD 39         mov c, b ; And place it into C
1908   0E66 2A            mov b, [d] ; Lower Word in B
1909   0E67             ; START RELATIONAL
1910   0E67 D7            push a
1911   0E68 FD D8         push g
1912   0E6A 11            mov a, b
1913   0E6B FD 7A         mov g, c
1914   0E6D 26 00 00      mov b, $0
1915   0E70 38 00 00      mov c, 0
1916   0E73               cmp32 ga, cb
out/test.asm line 1916: unrecognized instruction.          (CMP32)
1917   0E73 FD 71         seq ; ==
1918   0E75 FD F1         pop g
1919   0E77 E4            pop a
1920   0E78             ; END RELATIONAL
1921   0E78 C0 00 00      cmp b, 0
1922   0E7B C6 8D 0E      je _if30_exit
1923   0E7E             _if30_true:
1924   0E7E             ;; putchar('0'); 
1925   0E7E 26 30 00      mov b, $30
1926   0E81 DD            push bl
1927   0E82 07 13 10      call putchar
1928   0E85 51 01 00      add sp, 1
1929   0E88             ;; return; 
1930   0E88 F9            leave
1931   0E89 09            ret
1932   0E8A 0A 8D 0E      jmp _if30_exit
1933   0E8D             _if30_exit:
1934   0E8D             ;; while (num > 0) { 
1935   0E8D             _while31_cond:
1936   0E8D FA 05 00      lea d, [bp + 5] ; $num
1937   0E90 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1938   0E93 FD 39         mov c, b ; And place it into C
1939   0E95 2A            mov b, [d] ; Lower Word in B
1940   0E96             ; START RELATIONAL
1941   0E96 D7            push a
1942   0E97 FD D8         push g
1943   0E99 11            mov a, b
1944   0E9A FD 7A         mov g, c
1945   0E9C 26 00 00      mov b, $0
1946   0E9F 38 00 00      mov c, 0
1947   0EA2               sgu32 ga, cb
out/test.asm line 1947: unrecognized instruction.          (SGU32)
1948   0EA2 FD F1         pop g
1949   0EA4 E4            pop a
1950   0EA5             ; END RELATIONAL
1951   0EA5 C0 00 00      cmp b, 0
1952   0EA8 C6 08 0F      je _while31_exit
1953   0EAB             _while31_block:
1954   0EAB             ;; digits[i] = '0' + (num % 10); 
1955   0EAB FA F7 FF      lea d, [bp + -9] ; $digits
1956   0EAE D7            push a
1957   0EAF DA            push d
1958   0EB0 FA F5 FF      lea d, [bp + -11] ; $i
1959   0EB3 2A            mov b, [d]
1960   0EB4 E7            pop d
1961   0EB5 5A            add d, b
1962   0EB6 E4            pop a
1963   0EB7 DA            push d
1964   0EB8 26 30 00      mov b, $30
1965   0EBB             ; START TERMS
1966   0EBB D7            push a
1967   0EBC 11            mov a, b
1968   0EBD FA 05 00      lea d, [bp + 5] ; $num
1969   0EC0 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1970   0EC3 FD 39         mov c, b ; And place it into C
1971   0EC5 2A            mov b, [d] ; Lower Word in B
1972   0EC6             ; START FACTORS
1973   0EC6 D7            push a
1974   0EC7 11            mov a, b
1975   0EC8 26 0A 00      mov b, $a
1976   0ECB AE            div a, b ; 
1977   0ECC 11            mov a, b
1978   0ECD 27            mov b, a
1979   0ECE E4            pop a
1980   0ECF             ; END FACTORS
1981   0ECF 54            add a, b
1982   0ED0 D7            push a
1983   0ED1 FD 12         mov a, g
1984   0ED3 28            mov b, c
1985   0ED4 5C            adc a, b
1986   0ED5 39            mov c, a
1987   0ED6 E5            pop b
1988   0ED7 E4            pop a
1989   0ED8             ; END TERMS
1990   0ED8 E7            pop d
1991   0ED9 FD 3E         mov [d], bl
1992   0EDB             ;; num = num / 10; 
1993   0EDB FA 05 00      lea d, [bp + 5] ; $num
1994   0EDE DA            push d
1995   0EDF FA 05 00      lea d, [bp + 5] ; $num
1996   0EE2 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1997   0EE5 FD 39         mov c, b ; And place it into C
1998   0EE7 2A            mov b, [d] ; Lower Word in B
1999   0EE8             ; START FACTORS
2000   0EE8 D7            push a
2001   0EE9 11            mov a, b
2002   0EEA 26 0A 00      mov b, $a
2003   0EED AE            div a, b
2004   0EEE 27            mov b, a
2005   0EEF E4            pop a
2006   0EF0             ; END FACTORS
2007   0EF0 E7            pop d
2008   0EF1 FD 43         mov [d], b
2009   0EF3 28            mov b, c
2010   0EF4 FD 44 02 00   mov [d + 2], b
2011   0EF8             ;; i++; 
2012   0EF8 FA F5 FF      lea d, [bp + -11] ; $i
2013   0EFB 2A            mov b, [d]
2014   0EFC D8            push b
2015   0EFD FD 77         inc b
2016   0EFF FA F5 FF      lea d, [bp + -11] ; $i
2017   0F02 FD 43         mov [d], b
2018   0F04 E5            pop b
2019   0F05 0A 8D 0E      jmp _while31_cond
2020   0F08             _while31_exit:
2021   0F08             ;; while (i > 0) { 
2022   0F08             _while32_cond:
2023   0F08 FA F5 FF      lea d, [bp + -11] ; $i
2024   0F0B 2A            mov b, [d]
2025   0F0C             ; START RELATIONAL
2026   0F0C D7            push a
2027   0F0D 11            mov a, b
2028   0F0E 26 00 00      mov b, $0
2029   0F11 B0            cmp a, b
2030   0F12 FD 7F         sgt ; >
2031   0F14 E4            pop a
2032   0F15             ; END RELATIONAL
2033   0F15 C0 00 00      cmp b, 0
2034   0F18 C6 41 0F      je _while32_exit
2035   0F1B             _while32_block:
2036   0F1B             ;; i--; 
2037   0F1B FA F5 FF      lea d, [bp + -11] ; $i
2038   0F1E 2A            mov b, [d]
2039   0F1F D8            push b
2040   0F20 FD 7D         dec b
2041   0F22 FA F5 FF      lea d, [bp + -11] ; $i
2042   0F25 FD 43         mov [d], b
2043   0F27 E5            pop b
2044   0F28             ;; putchar(digits[i]); 
2045   0F28 FA F7 FF      lea d, [bp + -9] ; $digits
2046   0F2B D7            push a
2047   0F2C DA            push d
2048   0F2D FA F5 FF      lea d, [bp + -11] ; $i
2049   0F30 2A            mov b, [d]
2050   0F31 E7            pop d
2051   0F32 5A            add d, b
2052   0F33 E4            pop a
2053   0F34 32            mov bl, [d]
2054   0F35 A7 00         mov bh, 0
2055   0F37 DD            push bl
2056   0F38 07 13 10      call putchar
2057   0F3B 51 01 00      add sp, 1
2058   0F3E 0A 08 0F      jmp _while32_cond
2059   0F41             _while32_exit:
2060   0F41 F9            leave
2061   0F42 09            ret
2062   0F43             
2063   0F43             print_unsigned:
2064   0F43 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2065   0F46             ; $digits 
2066   0F46             ; $i 
2067   0F46 52 07 00      sub sp, 7
2068   0F49             ;; i = 0; 
2069   0F49 FA FA FF      lea d, [bp + -6] ; $i
2070   0F4C DA            push d
2071   0F4D 26 00 00      mov b, $0
2072   0F50 E7            pop d
2073   0F51 FD 43         mov [d], b
2074   0F53             ;; if(num == 0){ 
2075   0F53             _if33_cond:
2076   0F53 FA 05 00      lea d, [bp + 5] ; $num
2077   0F56 2A            mov b, [d]
2078   0F57             ; START RELATIONAL
2079   0F57 D7            push a
2080   0F58 11            mov a, b
2081   0F59 26 00 00      mov b, $0
2082   0F5C B0            cmp a, b
2083   0F5D FD 71         seq ; ==
2084   0F5F E4            pop a
2085   0F60             ; END RELATIONAL
2086   0F60 C0 00 00      cmp b, 0
2087   0F63 C6 75 0F      je _if33_exit
2088   0F66             _if33_true:
2089   0F66             ;; putchar('0'); 
2090   0F66 26 30 00      mov b, $30
2091   0F69 DD            push bl
2092   0F6A 07 13 10      call putchar
2093   0F6D 51 01 00      add sp, 1
2094   0F70             ;; return; 
2095   0F70 F9            leave
2096   0F71 09            ret
2097   0F72 0A 75 0F      jmp _if33_exit
2098   0F75             _if33_exit:
2099   0F75             ;; while (num > 0) { 
2100   0F75             _while34_cond:
2101   0F75 FA 05 00      lea d, [bp + 5] ; $num
2102   0F78 2A            mov b, [d]
2103   0F79             ; START RELATIONAL
2104   0F79 D7            push a
2105   0F7A 11            mov a, b
2106   0F7B 26 00 00      mov b, $0
2107   0F7E B0            cmp a, b
2108   0F7F FD 81         sgu ; > (unsigned)
2109   0F81 E4            pop a
2110   0F82             ; END RELATIONAL
2111   0F82 C0 00 00      cmp b, 0
2112   0F85 C6 CF 0F      je _while34_exit
2113   0F88             _while34_block:
2114   0F88             ;; digits[i] = '0' + (num % 10); 
2115   0F88 FA FC FF      lea d, [bp + -4] ; $digits
2116   0F8B D7            push a
2117   0F8C DA            push d
2118   0F8D FA FA FF      lea d, [bp + -6] ; $i
2119   0F90 2A            mov b, [d]
2120   0F91 E7            pop d
2121   0F92 5A            add d, b
2122   0F93 E4            pop a
2123   0F94 DA            push d
2124   0F95 26 30 00      mov b, $30
2125   0F98             ; START TERMS
2126   0F98 D7            push a
2127   0F99 11            mov a, b
2128   0F9A FA 05 00      lea d, [bp + 5] ; $num
2129   0F9D 2A            mov b, [d]
2130   0F9E             ; START FACTORS
2131   0F9E D7            push a
2132   0F9F 11            mov a, b
2133   0FA0 26 0A 00      mov b, $a
2134   0FA3 AE            div a, b ; 
2135   0FA4 11            mov a, b
2136   0FA5 27            mov b, a
2137   0FA6 E4            pop a
2138   0FA7             ; END FACTORS
2139   0FA7 56            add b, a
2140   0FA8 E4            pop a
2141   0FA9             ; END TERMS
2142   0FA9 E7            pop d
2143   0FAA FD 3E         mov [d], bl
2144   0FAC             ;; num = num / 10; 
2145   0FAC FA 05 00      lea d, [bp + 5] ; $num
2146   0FAF DA            push d
2147   0FB0 FA 05 00      lea d, [bp + 5] ; $num
2148   0FB3 2A            mov b, [d]
2149   0FB4             ; START FACTORS
2150   0FB4 D7            push a
2151   0FB5 11            mov a, b
2152   0FB6 26 0A 00      mov b, $a
2153   0FB9 AE            div a, b
2154   0FBA 27            mov b, a
2155   0FBB E4            pop a
2156   0FBC             ; END FACTORS
2157   0FBC E7            pop d
2158   0FBD FD 43         mov [d], b
2159   0FBF             ;; i++; 
2160   0FBF FA FA FF      lea d, [bp + -6] ; $i
2161   0FC2 2A            mov b, [d]
2162   0FC3 D8            push b
2163   0FC4 FD 77         inc b
2164   0FC6 FA FA FF      lea d, [bp + -6] ; $i
2165   0FC9 FD 43         mov [d], b
2166   0FCB E5            pop b
2167   0FCC 0A 75 0F      jmp _while34_cond
2168   0FCF             _while34_exit:
2169   0FCF             ;; while (i > 0) { 
2170   0FCF             _while35_cond:
2171   0FCF FA FA FF      lea d, [bp + -6] ; $i
2172   0FD2 2A            mov b, [d]
2173   0FD3             ; START RELATIONAL
2174   0FD3 D7            push a
2175   0FD4 11            mov a, b
2176   0FD5 26 00 00      mov b, $0
2177   0FD8 B0            cmp a, b
2178   0FD9 FD 7F         sgt ; >
2179   0FDB E4            pop a
2180   0FDC             ; END RELATIONAL
2181   0FDC C0 00 00      cmp b, 0
2182   0FDF C6 08 10      je _while35_exit
2183   0FE2             _while35_block:
2184   0FE2             ;; i--; 
2185   0FE2 FA FA FF      lea d, [bp + -6] ; $i
2186   0FE5 2A            mov b, [d]
2187   0FE6 D8            push b
2188   0FE7 FD 7D         dec b
2189   0FE9 FA FA FF      lea d, [bp + -6] ; $i
2190   0FEC FD 43         mov [d], b
2191   0FEE E5            pop b
2192   0FEF             ;; putchar(digits[i]); 
2193   0FEF FA FC FF      lea d, [bp + -4] ; $digits
2194   0FF2 D7            push a
2195   0FF3 DA            push d
2196   0FF4 FA FA FF      lea d, [bp + -6] ; $i
2197   0FF7 2A            mov b, [d]
2198   0FF8 E7            pop d
2199   0FF9 5A            add d, b
2200   0FFA E4            pop a
2201   0FFB 32            mov bl, [d]
2202   0FFC A7 00         mov bh, 0
2203   0FFE DD            push bl
2204   0FFF 07 13 10      call putchar
2205   1002 51 01 00      add sp, 1
2206   1005 0A CF 0F      jmp _while35_cond
2207   1008             _while35_exit:
2208   1008 F9            leave
2209   1009 09            ret
2210   100A             
2211   100A             date:
2212   100A F8 00 00      enter 0 ; (push bp; mov bp, sp)
2213   100D             
2214   100D             ; --- BEGIN INLINE ASM BLOCK
2215   100D 19 00         mov al, 0 
2216   100F 05 07         syscall sys_datetime
2217   1011             ; --- END INLINE ASM BLOCK
2218   1011             
2219   1011 F9            leave
2220   1012 09            ret
2221   1013             
2222   1013             putchar:
2223   1013 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2224   1016             
2225   1016             ; --- BEGIN INLINE ASM BLOCK
2226   1016 FA 05 00      lea d, [bp + 5] ; $c
2227   1019 1E            mov al, [d]
2228   101A 23            mov ah, al
2229   101B 07 7F 11      call _putchar
2230   101E             ; --- END INLINE ASM BLOCK
2231   101E             
2232   101E F9            leave
2233   101F 09            ret
2234   1020             
2235   1020             getchar:
2236   1020 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2237   1023             ; $c 
2238   1023 52 01 00      sub sp, 1
2239   1026             
2240   1026             ; --- BEGIN INLINE ASM BLOCK
2241   1026 07 78 11      call getch
2242   1029 1A            mov al, ah
2243   102A FA 00 00      lea d, [bp + 0] ; $c
2244   102D 3E            mov [d], al
2245   102E             ; --- END INLINE ASM BLOCK
2246   102E             
2247   102E             ;; return c; 
2248   102E FA 00 00      lea d, [bp + 0] ; $c
2249   1031 32            mov bl, [d]
2250   1032 A7 00         mov bh, 0
2251   1034 F9            leave
2252   1035 09            ret
2253   1036             
2254   1036             scann:
2255   1036 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2256   1039             ; $m 
2257   1039 52 02 00      sub sp, 2
2258   103C             
2259   103C             ; --- BEGIN INLINE ASM BLOCK
2260   103C 07 C3 13      call scan_u16d
2261   103F FA FF FF      lea d, [bp + -1] ; $m
2262   1042 43            mov [d], a
2263   1043             ; --- END INLINE ASM BLOCK
2264   1043             
2265   1043             ;; return m; 
2266   1043 FA FF FF      lea d, [bp + -1] ; $m
2267   1046 2A            mov b, [d]
2268   1047 F9            leave
2269   1048 09            ret
2270   1049             
2271   1049             puts:
2272   1049 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2273   104C             
2274   104C             ; --- BEGIN INLINE ASM BLOCK
2275   104C FA 05 00      lea d, [bp + 5] ; $s
2276   104F 15            mov a, [d]
2277   1050 3C            mov d, a
2278   1051 07 C9 12      call _puts
2279   1054 10 00 0A      mov a, $0A00
2280   1057 05 03         syscall sys_io
2281   1059             ; --- END INLINE ASM BLOCK
2282   1059             
2283   1059 F9            leave
2284   105A 09            ret
2285   105B             
2286   105B             print:
2287   105B F8 00 00      enter 0 ; (push bp; mov bp, sp)
2288   105E             
2289   105E             ; --- BEGIN INLINE ASM BLOCK
2290   105E FA 05 00      lea d, [bp + 5] ; $s
2291   1061 FD 2A         mov d, [d]
2292   1063 07 C9 12      call _puts
2293   1066             ; --- END INLINE ASM BLOCK
2294   1066             
2295   1066 F9            leave
2296   1067 09            ret
2297   1068             
2298   1068             getparam:
2299   1068 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2300   106B             ; $data 
2301   106B 52 01 00      sub sp, 1
2302   106E             
2303   106E             ; --- BEGIN INLINE ASM BLOCK
2304   106E 19 04         mov al, 4
2305   1070 FA 05 00      lea d, [bp + 5] ; $address
2306   1073 FD 2A         mov d, [d]
2307   1075 05 0C         syscall sys_system
2308   1077 FA 00 00      lea d, [bp + 0] ; $data
2309   107A FD 3E         mov [d], bl
2310   107C             ; --- END INLINE ASM BLOCK
2311   107C             
2312   107C             ;; return data; 
2313   107C FA 00 00      lea d, [bp + 0] ; $data
2314   107F 32            mov bl, [d]
2315   1080 A7 00         mov bh, 0
2316   1082 F9            leave
2317   1083 09            ret
2318   1084             
2319   1084             clear:
2320   1084 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2321   1087             ;; print("\033[2J\033[H"); 
2322   1087 26 6B 14      mov b, __s2 ; "\033[2J\033[H"
2323   108A FD AB         swp b
2324   108C D8            push b
2325   108D 07 5B 10      call print
2326   1090 51 02 00      add sp, 2
2327   1093 F9            leave
2328   1094 09            ret
2329   1095             
2330   1095             include_stdio_asm:
2331   1095 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2332   1098             
2333   1098             ; --- BEGIN INLINE ASM BLOCK
2334   1098             .include "lib/asm/stdio.asm"
0001+  1098             ;-----------------------------------------------------------------------------
0002+  1098             ; stdio.s
0003+  1098             ;-----------------------------------------------------------------------------
0004+  1098             .include "lib/asm/string.asm"
0001++ 1098             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 1098             ; string.s
0003++ 1098             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 1098             
0005++ 1098             
0006++ 1098             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 1098             ; _strrev
0008++ 1098             ; reverse a string
0009++ 1098             ; D = string address
0010++ 1098             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 1098             ; 01234
0012++ 1098             _strrev:
0013++ 1098 4B          	pusha
0014++ 1099 07 DF 10    	call _strlen	; length in C
0015++ 109C 12          	mov a, c
0016++ 109D AF 01 00    	cmp a, 1
0017++ 10A0 D0 BA 10    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 10A3 7D          	dec a
0019++ 10A4 FD 4E       	mov si, d	; beginning of string
0020++ 10A6 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 10A8 59          	add d, a	; end of string
0022++ 10A9 12          	mov a, c
0023++ 10AA FD 9B       	shr a		; divide by 2
0024++ 10AC 39          	mov c, a	; C now counts the steps
0025++ 10AD             _strrev_L0:
0026++ 10AD 32          	mov bl, [d]	; save load right-side char into BL
0027++ 10AE F6          	lodsb		; load left-side char into AL; increase SI
0028++ 10AF 3E          	mov [d], al	; store left char into right side
0029++ 10B0 1B          	mov al, bl
0030++ 10B1 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 10B2 7E          	dec c
0032++ 10B3 7F          	dec d
0033++ 10B4 C2 00 00    	cmp c, 0
0034++ 10B7 C7 AD 10    	jne _strrev_L0
0035++ 10BA             _strrev_end:
0036++ 10BA 4C          	popa
0037++ 10BB 09          	ret
0038++ 10BC             	
0039++ 10BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 10BC             ; _strchr
0041++ 10BC             ; search string in D for char in AL
0042++ 10BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 10BC             _strchr:
0044++ 10BC             _strchr_L0:
0045++ 10BC 32          	mov bl, [d]
0046++ 10BD C1 00       	cmp bl, 0
0047++ 10BF C6 CA 10    	je _strchr_end
0048++ 10C2 BA          	cmp al, bl
0049++ 10C3 C6 CA 10    	je _strchr_end
0050++ 10C6 79          	inc d
0051++ 10C7 0A BC 10    	jmp _strchr_L0
0052++ 10CA             _strchr_end:
0053++ 10CA 1B          	mov al, bl
0054++ 10CB 09          	ret
0055++ 10CC             
0056++ 10CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 10CC             ; _strstr
0058++ 10CC             ; find sub-string
0059++ 10CC             ; str1 in SI
0060++ 10CC             ; str2 in DI
0061++ 10CC             ; SI points to end of source string
0062++ 10CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 10CC             _strstr:
0064++ 10CC DB          	push al
0065++ 10CD DA          	push d
0066++ 10CE E3          	push di
0067++ 10CF             _strstr_loop:
0068++ 10CF F3          	cmpsb					; compare a byte of the strings
0069++ 10D0 C7 DB 10    	jne _strstr_ret
0070++ 10D3 FC 00 00    	lea d, [di + 0]
0071++ 10D6 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 10D8 C7 CF 10    	jne _strstr_loop				; equal chars but not at end
0073++ 10DB             _strstr_ret:
0074++ 10DB F0          	pop di
0075++ 10DC E7          	pop d
0076++ 10DD E8          	pop al
0077++ 10DE 09          	ret
0078++ 10DF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 10DF             ; length of null terminated string
0080++ 10DF             ; result in C
0081++ 10DF             ; pointer in D
0082++ 10DF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 10DF             _strlen:
0084++ 10DF DA          	push d
0085++ 10E0 38 00 00    	mov c, 0
0086++ 10E3             _strlen_L1:
0087++ 10E3 BD 00       	cmp byte [d], 0
0088++ 10E5 C6 ED 10    	je _strlen_ret
0089++ 10E8 79          	inc d
0090++ 10E9 78          	inc c
0091++ 10EA 0A E3 10    	jmp _strlen_L1
0092++ 10ED             _strlen_ret:
0093++ 10ED E7          	pop d
0094++ 10EE 09          	ret
0095++ 10EF             
0096++ 10EF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 10EF             ; STRCMP
0098++ 10EF             ; compare two strings
0099++ 10EF             ; str1 in SI
0100++ 10EF             ; str2 in DI
0101++ 10EF             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 10EF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 10EF             _strcmp:
0104++ 10EF DB          	push al
0105++ 10F0 DA          	push d
0106++ 10F1 E3          	push di
0107++ 10F2 E2          	push si
0108++ 10F3             _strcmp_loop:
0109++ 10F3 F3          	cmpsb					; compare a byte of the strings
0110++ 10F4 C7 FF 10    	jne _strcmp_ret
0111++ 10F7 FB FF FF    	lea d, [si +- 1]
0112++ 10FA BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 10FC C7 F3 10    	jne _strcmp_loop				; equal chars but not at end
0114++ 10FF             _strcmp_ret:
0115++ 10FF EF          	pop si
0116++ 1100 F0          	pop di
0117++ 1101 E7          	pop d
0118++ 1102 E8          	pop al
0119++ 1103 09          	ret
0120++ 1104             
0121++ 1104             
0122++ 1104             ; STRCPY
0123++ 1104             ; copy null terminated string from SI to DI
0124++ 1104             ; source in SI
0125++ 1104             ; destination in DI
0126++ 1104             _strcpy:
0127++ 1104 E2          	push si
0128++ 1105 E3          	push di
0129++ 1106 DB          	push al
0130++ 1107             _strcpy_L1:
0131++ 1107 F6          	lodsb
0132++ 1108 F7          	stosb
0133++ 1109 B9 00       	cmp al, 0
0134++ 110B C7 07 11    	jne _strcpy_L1
0135++ 110E             _strcpy_end:
0136++ 110E E8          	pop al
0137++ 110F F0          	pop di
0138++ 1110 EF          	pop si
0139++ 1111 09          	ret
0140++ 1112             
0141++ 1112             ; STRCAT
0142++ 1112             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 1112             ; source in SI
0144++ 1112             ; destination in DI
0145++ 1112             _strcat:
0146++ 1112 E2          	push si
0147++ 1113 E3          	push di
0148++ 1114 D7          	push a
0149++ 1115 DA          	push d
0150++ 1116 50          	mov a, di
0151++ 1117 3C          	mov d, a
0152++ 1118             _strcat_goto_end_L1:
0153++ 1118 BD 00       	cmp byte[d], 0
0154++ 111A C6 21 11    	je _strcat_start
0155++ 111D 79          	inc d
0156++ 111E 0A 18 11    	jmp _strcat_goto_end_L1
0157++ 1121             _strcat_start:
0158++ 1121 FD 50       	mov di, d
0159++ 1123             _strcat_L1:
0160++ 1123 F6          	lodsb
0161++ 1124 F7          	stosb
0162++ 1125 B9 00       	cmp al, 0
0163++ 1127 C7 23 11    	jne _strcat_L1
0164++ 112A             _strcat_end:
0165++ 112A E7          	pop d
0166++ 112B E4          	pop a
0167++ 112C F0          	pop di
0168++ 112D EF          	pop si
0169++ 112E 09          	ret
0170++ 112F             
0171++ 112F             
0005+  112F             
0006+  112F             ;-----------------------------------------------------------------------------
0007+  112F             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0008+  112F             ; ASCII in BL
0009+  112F             ; result in AL
0010+  112F             ; ascii for F = 0100 0110
0011+  112F             ; ascii for 9 = 0011 1001
0012+  112F             ;-----------------------------------------------------------------------------
0013+  112F             hex_ascii_encode:
0014+  112F 1B            mov al, bl
0015+  1130 93 40         test al, $40        ; test if letter or number
0016+  1132 C7 38 11      jnz hex_letter
0017+  1135 87 0F         and al, $0F        ; get number
0018+  1137 09            ret
0019+  1138             hex_letter:
0020+  1138 87 0F         and al, $0F        ; get letter
0021+  113A 6A 09         add al, 9
0022+  113C 09            ret
0023+  113D             
0024+  113D             ;-----------------------------------------------------------------------------
0025+  113D             ; ATOI
0026+  113D             ; 2 letter hex string in B
0027+  113D             ; 8bit integer returned in AL
0028+  113D             ;-----------------------------------------------------------------------------
0029+  113D             _atoi:
0030+  113D D8            push b
0031+  113E 07 2F 11      call hex_ascii_encode      ; convert BL to 4bit code in AL
0032+  1141 30            mov bl, bh
0033+  1142 DB            push al          ; save a
0034+  1143 07 2F 11      call hex_ascii_encode
0035+  1146 EA            pop bl  
0036+  1147 FD 9E 04      shl al, 4
0037+  114A 8C            or al, bl
0038+  114B E5            pop b
0039+  114C 09            ret  
0040+  114D             
0041+  114D             
0042+  114D             ;-----------------------------------------------------------------------------
0043+  114D             ; ITOA
0044+  114D             ; 8bit value in BL
0045+  114D             ; 2 byte ASCII result in A
0046+  114D             ;-----------------------------------------------------------------------------
0047+  114D             _itoa:
0048+  114D DA            push d
0049+  114E D8            push b
0050+  114F A7 00         mov bh, 0
0051+  1151 FD A4 04      shr bl, 4  
0052+  1154 74            mov d, b
0053+  1155 1F FD 13      mov al, [d + s_hex_digits]
0054+  1158 23            mov ah, al
0055+  1159               
0056+  1159 E5            pop b
0057+  115A D8            push b
0058+  115B A7 00         mov bh, 0
0059+  115D FD 87 0F      and bl, $0F
0060+  1160 74            mov d, b
0061+  1161 1F FD 13      mov al, [d + s_hex_digits]
0062+  1164 E5            pop b
0063+  1165 E7            pop d
0064+  1166 09            ret
0065+  1167             
0066+  1167             ;-----------------------------------------------------------------------------
0067+  1167             ; HEX STRING TO BINARY
0068+  1167             ; di = destination address
0069+  1167             ; si = source
0070+  1167             ;-----------------------------------------------------------------------------
0071+  1167             _hex_to_int:
0072+  1167             _hex_to_int_L1:
0073+  1167 F6            lodsb          ; load from [SI] to AL
0074+  1168 B9 00         cmp al, 0        ; check if ASCII 0
0075+  116A C6 77 11      jz _hex_to_int_ret
0076+  116D 36            mov bh, al
0077+  116E F6            lodsb
0078+  116F 2F            mov bl, al
0079+  1170 07 3D 11      call _atoi        ; convert ASCII byte in B to int (to AL)
0080+  1173 F7            stosb          ; store AL to [DI]
0081+  1174 0A 67 11      jmp _hex_to_int_L1
0082+  1177             _hex_to_int_ret:
0083+  1177 09            ret    
0084+  1178             
0085+  1178             ;-----------------------------------------------------------------------------
0086+  1178             ; GETCHAR
0087+  1178             ; char in ah
0088+  1178             ;-----------------------------------------------------------------------------
0089+  1178             getch:
0090+  1178 DB            push al
0091+  1179             getch_retry:
0092+  1179 19 01         mov al, 1
0093+  117B 05 03         syscall sys_io      ; receive in AH
0094+  117D E8            pop al
0095+  117E 09            ret
0096+  117F             
0097+  117F             ;-----------------------------------------------------------------------------
0098+  117F             ; PUTCHAR
0099+  117F             ; char in ah
0100+  117F             ;-----------------------------------------------------------------------------
0101+  117F             _putchar:
0102+  117F D7            push a
0103+  1180 19 00         mov al, 0
0104+  1182 05 03         syscall sys_io      ; char in AH
0105+  1184 E4            pop a
0106+  1185 09            ret
0107+  1186             
0108+  1186             ;-----------------------------------------------------------------------------
0109+  1186             ;; INPUT A STRING
0110+  1186             ;; terminates with null
0111+  1186             ;; pointer in D
0112+  1186             ;-----------------------------------------------------------------------------
0113+  1186             _gets:
0114+  1186 D7            push a
0115+  1187 DA            push d
0116+  1188             _gets_loop:
0117+  1188 19 01         mov al, 1
0118+  118A 05 03         syscall sys_io      ; receive in AH
0119+  118C B9 00         cmp al, 0        ; check error code (AL)
0120+  118E C6 88 11      je _gets_loop      ; if no char received, retry
0121+  1191             
0122+  1191 76 1B         cmp ah, 27
0123+  1193 C6 B4 11      je _gets_ansi_esc
0124+  1196 76 0A         cmp ah, $0A        ; LF
0125+  1198 C6 1F 12      je _gets_end
0126+  119B 76 0D         cmp ah, $0D        ; CR
0127+  119D C6 1F 12      je _gets_end
0128+  11A0 76 5C         cmp ah, $5C        ; '\\'
0129+  11A2 C6 E0 11      je _gets_escape
0130+  11A5               
0131+  11A5 76 08         cmp ah, $08      ; check for backspace
0132+  11A7 C6 B0 11      je _gets_backspace
0133+  11AA             
0134+  11AA 1A            mov al, ah
0135+  11AB 3E            mov [d], al
0136+  11AC 79            inc d
0137+  11AD 0A 88 11      jmp _gets_loop
0138+  11B0             _gets_backspace:
0139+  11B0 7F            dec d
0140+  11B1 0A 88 11      jmp _gets_loop
0141+  11B4             _gets_ansi_esc:
0142+  11B4 19 01         mov al, 1
0143+  11B6 05 03         syscall sys_io        ; receive in AH without echo
0144+  11B8 B9 00         cmp al, 0          ; check error code (AL)
0145+  11BA C6 B4 11      je _gets_ansi_esc    ; if no char received, retry
0146+  11BD 76 5B         cmp ah, '['
0147+  11BF C7 88 11      jne _gets_loop
0148+  11C2             _gets_ansi_esc_2:
0149+  11C2 19 01         mov al, 1
0150+  11C4 05 03         syscall sys_io          ; receive in AH without echo
0151+  11C6 B9 00         cmp al, 0            ; check error code (AL)
0152+  11C8 C6 C2 11      je _gets_ansi_esc_2  ; if no char received, retry
0153+  11CB 76 44         cmp ah, 'D'
0154+  11CD C6 D8 11      je _gets_left_arrow
0155+  11D0 76 43         cmp ah, 'C'
0156+  11D2 C6 DC 11      je _gets_right_arrow
0157+  11D5 0A 88 11      jmp _gets_loop
0158+  11D8             _gets_left_arrow:
0159+  11D8 7F            dec d
0160+  11D9 0A 88 11      jmp _gets_loop
0161+  11DC             _gets_right_arrow:
0162+  11DC 79            inc d
0163+  11DD 0A 88 11      jmp _gets_loop
0164+  11E0             _gets_escape:
0165+  11E0 19 01         mov al, 1
0166+  11E2 05 03         syscall sys_io      ; receive in AH
0167+  11E4 B9 00         cmp al, 0        ; check error code (AL)
0168+  11E6 C6 E0 11      je _gets_escape      ; if no char received, retry
0169+  11E9 76 6E         cmp ah, 'n'
0170+  11EB C6 0A 12      je _gets_LF
0171+  11EE 76 72         cmp ah, 'r'
0172+  11F0 C6 11 12      je _gets_CR
0173+  11F3 76 30         cmp ah, '0'
0174+  11F5 C6 18 12      je _gets_NULL
0175+  11F8 76 5C         cmp ah, $5C  ; '\'
0176+  11FA C6 03 12      je _gets_slash
0177+  11FD 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0178+  11FE 3E            mov [d], al
0179+  11FF 79            inc d
0180+  1200 0A 88 11      jmp _gets_loop
0181+  1203             _gets_slash:
0182+  1203 19 5C         mov al, $5C
0183+  1205 3E            mov [d], al
0184+  1206 79            inc d
0185+  1207 0A 88 11      jmp _gets_loop
0186+  120A             _gets_LF:
0187+  120A 19 0A         mov al, $0A
0188+  120C 3E            mov [d], al
0189+  120D 79            inc d
0190+  120E 0A 88 11      jmp _gets_loop
0191+  1211             _gets_CR:
0192+  1211 19 0D         mov al, $0D
0193+  1213 3E            mov [d], al
0194+  1214 79            inc d
0195+  1215 0A 88 11      jmp _gets_loop
0196+  1218             _gets_NULL:
0197+  1218 19 00         mov al, $00
0198+  121A 3E            mov [d], al
0199+  121B 79            inc d
0200+  121C 0A 88 11      jmp _gets_loop
0201+  121F             _gets_end:
0202+  121F 19 00         mov al, 0
0203+  1221 3E            mov [d], al        ; terminate string
0204+  1222 E7            pop d
0205+  1223 E4            pop a
0206+  1224 09            ret
0207+  1225             
0208+  1225             ;-----------------------------------------------------------------------------
0209+  1225             ;; INPUT TEXT
0210+  1225             ;; terminated with CTRL+D
0211+  1225             ;; pointer in D
0212+  1225             ;-----------------------------------------------------------------------------
0213+  1225             _gettxt:
0214+  1225 D7            push a
0215+  1226 DA            push d
0216+  1227             _gettxt_loop:
0217+  1227 19 01         mov al, 1
0218+  1229 05 03         syscall sys_io      ; receive in AH
0219+  122B B9 00         cmp al, 0        ; check error code (AL)
0220+  122D C6 27 12      je _gettxt_loop    ; if no char received, retry
0221+  1230 76 04         cmp ah, 4      ; EOT
0222+  1232 C6 70 12      je _gettxt_end
0223+  1235 76 08         cmp ah, $08      ; check for backspace
0224+  1237 C6 6C 12      je _gettxt_backspace
0225+  123A 76 5C         cmp ah, $5C        ; '\'
0226+  123C C6 45 12      je _gettxt_escape
0227+  123F 1A            mov al, ah
0228+  1240 3E            mov [d], al
0229+  1241 79            inc d
0230+  1242 0A 27 12      jmp _gettxt_loop
0231+  1245             _gettxt_escape:
0232+  1245 19 01         mov al, 1
0233+  1247 05 03         syscall sys_io      ; receive in AH
0234+  1249 B9 00         cmp al, 0        ; check error code (AL)
0235+  124B C6 45 12      je _gettxt_escape    ; if no char received, retry
0236+  124E 76 6E         cmp ah, 'n'
0237+  1250 C6 5E 12      je _gettxt_LF
0238+  1253 76 72         cmp ah, 'r'
0239+  1255 C6 65 12      je _gettxt_CR
0240+  1258 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0241+  1259 3E            mov [d], al
0242+  125A 79            inc d
0243+  125B 0A 27 12      jmp _gettxt_loop
0244+  125E             _gettxt_LF:
0245+  125E 19 0A         mov al, $0A
0246+  1260 3E            mov [d], al
0247+  1261 79            inc d
0248+  1262 0A 27 12      jmp _gettxt_loop
0249+  1265             _gettxt_CR:
0250+  1265 19 0D         mov al, $0D
0251+  1267 3E            mov [d], al
0252+  1268 79            inc d
0253+  1269 0A 27 12      jmp _gettxt_loop
0254+  126C             _gettxt_backspace:
0255+  126C 7F            dec d
0256+  126D 0A 27 12      jmp _gettxt_loop
0257+  1270             _gettxt_end:
0258+  1270 19 00         mov al, 0
0259+  1272 3E            mov [d], al        ; terminate string
0260+  1273 E7            pop d
0261+  1274 E4            pop a
0262+  1275 09            ret
0263+  1276             
0264+  1276             ;-----------------------------------------------------------------------------
0265+  1276             ; PRINT NEW LINE
0266+  1276             ;-----------------------------------------------------------------------------
0267+  1276             printnl:
0268+  1276 D7            push a
0269+  1277 10 00 0A      mov a, $0A00
0270+  127A 05 03         syscall sys_io
0271+  127C 10 00 0D      mov a, $0D00
0272+  127F 05 03         syscall sys_io
0273+  1281 E4            pop a
0274+  1282 09            ret
0275+  1283             
0276+  1283             ;-----------------------------------------------------------------------------
0277+  1283             ; _strtoint
0278+  1283             ; 4 digit hex string number in d
0279+  1283             ; integer returned in A
0280+  1283             ;-----------------------------------------------------------------------------
0281+  1283             _strtointx:
0282+  1283 D8            push b
0283+  1284 32            mov bl, [d]
0284+  1285 37            mov bh, bl
0285+  1286 33 01 00      mov bl, [d + 1]
0286+  1289 07 3D 11      call _atoi        ; convert to int in AL
0287+  128C 23            mov ah, al        ; move to AH
0288+  128D 33 02 00      mov bl, [d + 2]
0289+  1290 37            mov bh, bl
0290+  1291 33 03 00      mov bl, [d + 3]
0291+  1294 07 3D 11      call _atoi        ; convert to int in AL
0292+  1297 E5            pop b
0293+  1298 09            ret
0294+  1299             
0295+  1299             ;-----------------------------------------------------------------------------
0296+  1299             ; _strtoint
0297+  1299             ; 5 digit base10 string number in d
0298+  1299             ; integer returned in A
0299+  1299             ;-----------------------------------------------------------------------------
0300+  1299             _strtoint:
0301+  1299 E2            push si
0302+  129A D8            push b
0303+  129B D9            push c
0304+  129C DA            push d
0305+  129D 07 DF 10      call _strlen      ; get string length in C
0306+  12A0 7E            dec c
0307+  12A1 FD 4E         mov si, d
0308+  12A3 12            mov a, c
0309+  12A4 FD 99         shl a
0310+  12A6 3B 15 14      mov d, table_power
0311+  12A9 59            add d, a
0312+  12AA 38 00 00      mov c, 0
0313+  12AD             _strtoint_L0:
0314+  12AD F6            lodsb      ; load ASCII to al
0315+  12AE B9 00         cmp al, 0
0316+  12B0 C6 C3 12      je _strtoint_end
0317+  12B3 6F 30         sub al, $30    ; make into integer
0318+  12B5 22 00         mov ah, 0
0319+  12B7 2A            mov b, [d]
0320+  12B8 AC            mul a, b      ; result in B since it fits in 16bits
0321+  12B9 11            mov a, b
0322+  12BA 28            mov b, c
0323+  12BB 54            add a, b
0324+  12BC 39            mov c, a
0325+  12BD 63 02 00      sub d, 2
0326+  12C0 0A AD 12      jmp _strtoint_L0
0327+  12C3             _strtoint_end:
0328+  12C3 12            mov a, c
0329+  12C4 E7            pop d
0330+  12C5 E6            pop c
0331+  12C6 E5            pop b
0332+  12C7 EF            pop si
0333+  12C8 09            ret
0334+  12C9             
0335+  12C9             ;-----------------------------------------------------------------------------
0336+  12C9             ; PRINT NULL TERMINATED STRING
0337+  12C9             ; pointer in D
0338+  12C9             ;-----------------------------------------------------------------------------
0339+  12C9             _puts:
0340+  12C9 D7            push a
0341+  12CA DA            push d
0342+  12CB             _puts_L1:
0343+  12CB 1E            mov al, [d]
0344+  12CC B9 00         cmp al, 0
0345+  12CE C6 DA 12      jz _puts_END
0346+  12D1 23            mov ah, al
0347+  12D2 19 00         mov al, 0
0348+  12D4 05 03         syscall sys_io
0349+  12D6 79            inc d
0350+  12D7 0A CB 12      jmp _puts_L1
0351+  12DA             _puts_END:
0352+  12DA E7            pop d
0353+  12DB E4            pop a
0354+  12DC 09            ret
0355+  12DD             
0356+  12DD             ;-----------------------------------------------------------------------------
0357+  12DD             ; PRINT N SIZE STRING
0358+  12DD             ; pointer in D
0359+  12DD             ; size in C
0360+  12DD             ;-----------------------------------------------------------------------------
0361+  12DD             _putsn:
0362+  12DD DB            push al
0363+  12DE DA            push d
0364+  12DF D9            push c
0365+  12E0             _putsn_L0:
0366+  12E0 1E            mov al, [d]
0367+  12E1 23            mov ah, al
0368+  12E2 19 00         mov al, 0
0369+  12E4 05 03         syscall sys_io
0370+  12E6 79            inc d
0371+  12E7 7E            dec c  
0372+  12E8 C2 00 00      cmp c, 0
0373+  12EB C7 E0 12      jne _putsn_L0
0374+  12EE             _putsn_end:
0375+  12EE E6            pop c
0376+  12EF E7            pop d
0377+  12F0 E8            pop al
0378+  12F1 09            ret
0379+  12F2             
0380+  12F2             ;-----------------------------------------------------------------------------
0381+  12F2             ; print 16bit decimal number
0382+  12F2             ; input number in A
0383+  12F2             ;-----------------------------------------------------------------------------
0384+  12F2             print_u16d:
0385+  12F2 D7            push a
0386+  12F3 D8            push b
0387+  12F4 26 10 27      mov b, 10000
0388+  12F7 AE            div a, b      ; get 10000's coeff.
0389+  12F8 07 1A 13      call print_number
0390+  12FB 11            mov a, b
0391+  12FC 26 E8 03      mov b, 1000
0392+  12FF AE            div a, b      ; get 1000's coeff.
0393+  1300 07 1A 13      call print_number
0394+  1303 11            mov a, b
0395+  1304 26 64 00      mov b, 100
0396+  1307 AE            div a, b
0397+  1308 07 1A 13      call print_number
0398+  130B 11            mov a, b
0399+  130C 26 0A 00      mov b, 10
0400+  130F AE            div a, b
0401+  1310 07 1A 13      call print_number
0402+  1313 1B            mov al, bl      ; 1's coeff in bl
0403+  1314 07 1A 13      call print_number
0404+  1317 E5            pop b
0405+  1318 E4            pop a
0406+  1319 09            ret
0407+  131A             
0408+  131A             ;-----------------------------------------------------------------------------
0409+  131A             ; print AL
0410+  131A             ;-----------------------------------------------------------------------------
0411+  131A             print_number:
0412+  131A 6A 30         add al, $30
0413+  131C 23            mov ah, al
0414+  131D 07 7F 11      call _putchar
0415+  1320 09            ret
0416+  1321             
0417+  1321             ;-----------------------------------------------------------------------------
0418+  1321             ; PRINT 16BIT HEX INTEGER
0419+  1321             ; integer value in reg B
0420+  1321             ;-----------------------------------------------------------------------------
0421+  1321             print_u16x:
0422+  1321 D7            push a
0423+  1322 D8            push b
0424+  1323 DD            push bl
0425+  1324 30            mov bl, bh
0426+  1325 07 4D 11      call _itoa        ; convert bh to char in A
0427+  1328 2F            mov bl, al        ; save al
0428+  1329 19 00         mov al, 0
0429+  132B 05 03         syscall sys_io        ; display AH
0430+  132D 24            mov ah, bl        ; retrieve al
0431+  132E 19 00         mov al, 0
0432+  1330 05 03         syscall sys_io        ; display AL
0433+  1332             
0434+  1332 EA            pop bl
0435+  1333 07 4D 11      call _itoa        ; convert bh to char in A
0436+  1336 2F            mov bl, al        ; save al
0437+  1337 19 00         mov al, 0
0438+  1339 05 03         syscall sys_io        ; display AH
0439+  133B 24            mov ah, bl        ; retrieve al
0440+  133C 19 00         mov al, 0
0441+  133E 05 03         syscall sys_io        ; display AL
0442+  1340             
0443+  1340 E5            pop b
0444+  1341 E4            pop a
0445+  1342 09            ret
0446+  1343             
0447+  1343             ;-----------------------------------------------------------------------------
0448+  1343             ; INPUT 16BIT HEX INTEGER
0449+  1343             ; read 16bit integer into A
0450+  1343             ;-----------------------------------------------------------------------------
0451+  1343             scan_u16x:
0452+  1343 F8 10 00      enter 16
0453+  1346 D8            push b
0454+  1347 DA            push d
0455+  1348             
0456+  1348 FA F1 FF      lea d, [bp + -15]
0457+  134B 07 86 11      call _gets        ; get number
0458+  134E             
0459+  134E 32            mov bl, [d]
0460+  134F 37            mov bh, bl
0461+  1350 33 01 00      mov bl, [d + 1]
0462+  1353 07 3D 11      call _atoi        ; convert to int in AL
0463+  1356 23            mov ah, al        ; move to AH
0464+  1357             
0465+  1357 33 02 00      mov bl, [d + 2]
0466+  135A 37            mov bh, bl
0467+  135B 33 03 00      mov bl, [d + 3]
0468+  135E 07 3D 11      call _atoi        ; convert to int in AL
0469+  1361             
0470+  1361 E7            pop d
0471+  1362 E5            pop b
0472+  1363 F9            leave
0473+  1364 09            ret
0474+  1365             
0475+  1365             ;-----------------------------------------------------------------------------
0476+  1365             ; PRINT 8bit HEX INTEGER
0477+  1365             ; integer value in reg bl
0478+  1365             ;-----------------------------------------------------------------------------
0479+  1365             print_u8x:
0480+  1365 D7            push a
0481+  1366 DD            push bl
0482+  1367             
0483+  1367 07 4D 11      call _itoa        ; convert bl to char in A
0484+  136A 2F            mov bl, al        ; save al
0485+  136B 19 00         mov al, 0
0486+  136D 05 03         syscall sys_io        ; display AH
0487+  136F 24            mov ah, bl        ; retrieve al
0488+  1370 19 00         mov al, 0
0489+  1372 05 03         syscall sys_io        ; display AL
0490+  1374             
0491+  1374 EA            pop bl
0492+  1375 E4            pop a
0493+  1376 09            ret
0494+  1377             
0495+  1377             ;-----------------------------------------------------------------------------
0496+  1377             ; print 8bit decimal unsigned number
0497+  1377             ; input number in AL
0498+  1377             ;-----------------------------------------------------------------------------
0499+  1377             print_u8d:
0500+  1377 D7            push a
0501+  1378 D8            push b
0502+  1379             
0503+  1379 22 00         mov ah, 0
0504+  137B 26 64 00      mov b, 100
0505+  137E AE            div a, b
0506+  137F D8            push b      ; save remainder
0507+  1380 B9 00         cmp al, 0
0508+  1382 C6 8C 13      je skip100
0509+  1385 6A 30         add al, $30
0510+  1387 23            mov ah, al
0511+  1388 19 00         mov al, 0
0512+  138A 05 03         syscall sys_io  ; print coeff
0513+  138C             skip100:
0514+  138C E4            pop a
0515+  138D 22 00         mov ah, 0
0516+  138F 26 0A 00      mov b, 10
0517+  1392 AE            div a, b
0518+  1393 D8            push b      ; save remainder
0519+  1394 B9 00         cmp al, 0
0520+  1396 C6 A0 13      je skip10
0521+  1399 6A 30         add al, $30
0522+  139B 23            mov ah, al
0523+  139C 19 00         mov al, 0
0524+  139E 05 03         syscall sys_io  ; print coeff
0525+  13A0             skip10:
0526+  13A0 E4            pop a
0527+  13A1 1B            mov al, bl
0528+  13A2 6A 30         add al, $30
0529+  13A4 23            mov ah, al
0530+  13A5 19 00         mov al, 0
0531+  13A7 05 03         syscall sys_io  ; print coeff
0532+  13A9 E5            pop b
0533+  13AA E4            pop a
0534+  13AB 09            ret
0535+  13AC             
0536+  13AC             ;-----------------------------------------------------------------------------
0537+  13AC             ; INPUT 8BIT HEX INTEGER
0538+  13AC             ; read 8bit integer into AL
0539+  13AC             ;-----------------------------------------------------------------------------
0540+  13AC             scan_u8x:
0541+  13AC F8 04 00      enter 4
0542+  13AF D8            push b
0543+  13B0 DA            push d
0544+  13B1             
0545+  13B1 FA FD FF      lea d, [bp + -3]
0546+  13B4 07 86 11      call _gets        ; get number
0547+  13B7             
0548+  13B7 32            mov bl, [d]
0549+  13B8 37            mov bh, bl
0550+  13B9 33 01 00      mov bl, [d + 1]
0551+  13BC 07 3D 11      call _atoi        ; convert to int in AL
0552+  13BF             
0553+  13BF E7            pop d
0554+  13C0 E5            pop b
0555+  13C1 F9            leave
0556+  13C2 09            ret
0557+  13C3             
0558+  13C3             ;-----------------------------------------------------------------------------
0559+  13C3             ; input decimal number
0560+  13C3             ; result in A
0561+  13C3             ; 655'\0'
0562+  13C3             ; low--------high
0563+  13C3             ;-----------------------------------------------------------------------------
0564+  13C3             scan_u16d:
0565+  13C3 F8 08 00      enter 8
0566+  13C6 E2            push si
0567+  13C7 D8            push b
0568+  13C8 D9            push c
0569+  13C9 DA            push d
0570+  13CA FA F9 FF      lea d, [bp +- 7]
0571+  13CD 07 86 11      call _gets
0572+  13D0 07 DF 10      call _strlen      ; get string length in C
0573+  13D3 7E            dec c
0574+  13D4 FD 4E         mov si, d
0575+  13D6 12            mov a, c
0576+  13D7 FD 99         shl a
0577+  13D9 3B 15 14      mov d, table_power
0578+  13DC 59            add d, a
0579+  13DD 38 00 00      mov c, 0
0580+  13E0             mul_loop:
0581+  13E0 F6            lodsb      ; load ASCII to al
0582+  13E1 B9 00         cmp al, 0
0583+  13E3 C6 F6 13      je mul_exit
0584+  13E6 6F 30         sub al, $30    ; make into integer
0585+  13E8 22 00         mov ah, 0
0586+  13EA 2A            mov b, [d]
0587+  13EB AC            mul a, b      ; result in B since it fits in 16bits
0588+  13EC 11            mov a, b
0589+  13ED 28            mov b, c
0590+  13EE 54            add a, b
0591+  13EF 39            mov c, a
0592+  13F0 63 02 00      sub d, 2
0593+  13F3 0A E0 13      jmp mul_loop
0594+  13F6             mul_exit:
0595+  13F6 12            mov a, c
0596+  13F7 E7            pop d
0597+  13F8 E6            pop c
0598+  13F9 E5            pop b
0599+  13FA EF            pop si
0600+  13FB F9            leave
0601+  13FC 09            ret
0602+  13FD             
0603+  13FD 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0603+  1401 34 35 36 37 
0603+  1405 38 39 41 42 
0603+  1409 43 44 45 46 
0604+  140D 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0604+  1411 1B 5B 48 00 
0605+  1415             
0606+  1415             table_power:
0607+  1415 01 00         .dw 1
0608+  1417 0A 00         .dw 10
0609+  1419 64 00         .dw 100
0610+  141B E8 03         .dw 1000
0611+  141D 10 27         .dw 100002335   141F             ; --- END INLINE ASM BLOCK
2336   141F             
2337   141F F9            leave
2338   1420 09            ret
2339   1421             ; --- END TEXT BLOCK
2340   1421             
2341   1421             ; --- BEGIN DATA BLOCK
2342   1421 00 00 00 00 _il0: .fill 4, 0
2343   1425 00 00 00 00 _il1: .fill 4, 0
2344   1429 00 00       _i0: .fill 2, 0
2345   142B 00 00       _i1: .fill 2, 0
2346   142D 00          _c0: .fill 1, 0
2347   142E 00          _c1: .fill 1, 0
2348   142F 55 6E 65 78 __s0: .db "Unexpected format in printf.", 0
2348   1433 70 65 63 74 
2348   1437 65 64 20 66 
2348   143B 6F 72 6D 61 
2348   143F 74 20 69 6E 
2348   1443 20 70 72 69 
2348   1447 6E 74 66 2E 
2348   144B 00 
2349   144C 45 72 72 6F __s1: .db "Error: Unknown argument type.\n", 0
2349   1450 72 3A 20 55 
2349   1454 6E 6B 6E 6F 
2349   1458 77 6E 20 61 
2349   145C 72 67 75 6D 
2349   1460 65 6E 74 20 
2349   1464 74 79 70 65 
2349   1468 2E 0A 00 
2350   146B 1B 5B 32 4A __s2: .db "\033[2J\033[H", 0
2350   146F 1B 5B 48 00 
2351   1473             
2352   1473 75 14       _heap_top: .dw _heap
2353   1475 00          _heap: .db 0
2354   1476             ; --- END DATA BLOCK
2355   1476             
2356   1476             .end
tasm: Number of errors = 5
