0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0000             
0005   0000             ; --- BEGIN TEXT SEGMENT
0006   0400             .org text_org
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; char option; 
0011   0408 52 01 00      sub sp, 1
0012   040B             ; char byte; 
0013   040B 52 01 00      sub sp, 1
0014   040E             ; printf("Test of 5.25 inch Floppy Drive Interface.\n"); 
0015   040E             ; --- START FUNCTION CALL
0016   040E 26 0D 0E      mov b, _s0 ; "Test of 5.25 inch Floppy Drive Interface.\n"
0017   0411 FD AB         swp b
0018   0413 D8            push b
0019   0414 07 F6 04      call printf
0020   0417 51 02 00      add sp, 2
0021   041A             ; --- END FUNCTION CALL
0022   041A             ; for(;;){ 
0023   041A             _for1_init:
0024   041A             _for1_cond:
0025   041A             _for1_block:
0026   041A             ; printf("\nOption: "); 
0027   041A             ; --- START FUNCTION CALL
0028   041A 26 38 0E      mov b, _s1 ; "\nOption: "
0029   041D FD AB         swp b
0030   041F D8            push b
0031   0420 07 F6 04      call printf
0032   0423 51 02 00      add sp, 2
0033   0426             ; --- END FUNCTION CALL
0034   0426             ; option = getchar(); 
0035   0426 FA 00 00      lea d, [bp + 0] ; $option
0036   0429 DA            push d
0037   042A             ; --- START FUNCTION CALL
0038   042A 07 F3 0D      call getchar
0039   042D E7            pop d
0040   042E FD 3E         mov [d], bl
0041   0430             ; switch(option){ 
0042   0430             _switch2_expr:
0043   0430 FA 00 00      lea d, [bp + 0] ; $option
0044   0433 32            mov bl, [d]
0045   0434 A7 00         mov bh, 0
0046   0436 38 00 00      mov c, 0
0047   0439             _switch2_comparisons:
0048   0439 C1 77         cmp bl, $77
0049   043B C6 64 04      je _switch2_case0
0050   043E C1 64         cmp bl, $64
0051   0440 C6 70 04      je _switch2_case1
0052   0443 C1 74         cmp bl, $74
0053   0445 C6 97 04      je _switch2_case2
0054   0448 C1 73         cmp bl, $73
0055   044A C6 BE 04      je _switch2_case3
0056   044D C1 72         cmp bl, $72
0057   044F C6 CA 04      je _switch2_case4
0058   0452 C1 69         cmp bl, $69
0059   0454 C6 D6 04      je _switch2_case5
0060   0457 C1 6F         cmp bl, $6f
0061   0459 C6 E2 04      je _switch2_case6
0062   045C C1 65         cmp bl, $65
0063   045E C6 EE 04      je _switch2_case7
0064   0461 0A F1 04      jmp _switch2_exit
0065   0464             _switch2_case0:
0066   0464             ; --- BEGIN INLINE ASM SEGMENT
0067   0464 3B CB FF      mov d, $FFCB    ; wd1770 data register
0068   0467 19 02         mov al, 2       ; setparam call
0069   0469 2E 10         mov bl, $10     ; track 16
0070   046B 05 0C         syscall sys_system
0071   046D             ; --- END INLINE ASM SEGMENT
0072   046D             ; break; 
0073   046D 0A F1 04      jmp _switch2_exit ; case break
0074   0470             _switch2_case1:
0075   0470             ; --- BEGIN INLINE ASM SEGMENT
0076   0470 3B CB FF      mov d, $FFCB    ; wd1770 data register
0077   0473 19 04         mov al, 4       ; getparam call
0078   0475 05 0C         syscall sys_system
0079   0477 FA FF FF      lea d, [bp + -1] ; $byte
0080   047A FD 3E         mov [d], bl
0081   047C             ; --- END INLINE ASM SEGMENT
0082   047C             ; printf("\nData register value: %d\n", byte); 
0083   047C             ; --- START FUNCTION CALL
0084   047C FA FF FF      lea d, [bp + -1] ; $byte
0085   047F 32            mov bl, [d]
0086   0480 A7 00         mov bh, 0
0087   0482 38 00 00      mov c, 0
0088   0485 FD AB         swp b
0089   0487 D8            push b
0090   0488 26 42 0E      mov b, _s2 ; "\nData register value: %d\n"
0091   048B FD AB         swp b
0092   048D D8            push b
0093   048E 07 F6 04      call printf
0094   0491 51 03 00      add sp, 3
0095   0494             ; --- END FUNCTION CALL
0096   0494             ; break; 
0097   0494 0A F1 04      jmp _switch2_exit ; case break
0098   0497             _switch2_case2:
0099   0497             ; --- BEGIN INLINE ASM SEGMENT
0100   0497 3B C9 FF      mov d, $FFC9    ; wd1770 track register
0101   049A 19 04         mov al, 4       ; getparam call
0102   049C 05 0C         syscall sys_system
0103   049E FA FF FF      lea d, [bp + -1] ; $byte
0104   04A1 FD 3E         mov [d], bl
0105   04A3             ; --- END INLINE ASM SEGMENT
0106   04A3             ; printf("\nTrack register value: %d\n", byte); 
0107   04A3             ; --- START FUNCTION CALL
0108   04A3 FA FF FF      lea d, [bp + -1] ; $byte
0109   04A6 32            mov bl, [d]
0110   04A7 A7 00         mov bh, 0
0111   04A9 38 00 00      mov c, 0
0112   04AC FD AB         swp b
0113   04AE D8            push b
0114   04AF 26 5C 0E      mov b, _s3 ; "\nTrack register value: %d\n"
0115   04B2 FD AB         swp b
0116   04B4 D8            push b
0117   04B5 07 F6 04      call printf
0118   04B8 51 03 00      add sp, 3
0119   04BB             ; --- END FUNCTION CALL
0120   04BB             ; break; 
0121   04BB 0A F1 04      jmp _switch2_exit ; case break
0122   04BE             _switch2_case3:
0123   04BE             ; --- BEGIN INLINE ASM SEGMENT
0124   04BE 3B C8 FF      mov d, $FFC8    ; wd1770 command register
0125   04C1 19 02         mov al, 2       ; setparam call
0126   04C3 2E 23         mov bl, $23     ; STEP command, 30ms rate
0127   04C5 05 0C         syscall sys_system
0128   04C7             ; --- END INLINE ASM SEGMENT
0129   04C7             ; break; 
0130   04C7 0A F1 04      jmp _switch2_exit ; case break
0131   04CA             _switch2_case4:
0132   04CA             ; --- BEGIN INLINE ASM SEGMENT
0133   04CA               ; send restore command
0134   04CA 3B C8 FF      mov d, $FFC8    ; wd1770
0135   04CD 19 02         mov al, 2       ; setparam call
0136   04CF 2E 03         mov bl, $03     ; restore command, 30ms rate
0137   04D1 05 0C         syscall sys_system
0138   04D3             ; --- END INLINE ASM SEGMENT
0139   04D3             ; break; 
0140   04D3 0A F1 04      jmp _switch2_exit ; case break
0141   04D6             _switch2_case5:
0142   04D6             ; --- BEGIN INLINE ASM SEGMENT
0143   04D6               ; send step in command
0144   04D6 3B C8 FF      mov d, $FFC8    ; wd1770
0145   04D9 19 02         mov al, 2       ; setparam call
0146   04DB 2E 43         mov bl, $43     ; step in command, 30ms rate
0147   04DD 05 0C         syscall sys_system
0148   04DF             ; --- END INLINE ASM SEGMENT
0149   04DF             ; break; 
0150   04DF 0A F1 04      jmp _switch2_exit ; case break
0151   04E2             _switch2_case6:
0152   04E2             ; --- BEGIN INLINE ASM SEGMENT
0153   04E2               ; send step out command
0154   04E2 3B C8 FF      mov d, $FFC8    ; wd1770
0155   04E5 19 02         mov al, 2       ; setparam call
0156   04E7 2E 63         mov bl, $63     ; step out command, 30ms rate
0157   04E9 05 0C         syscall sys_system
0158   04EB             ; --- END INLINE ASM SEGMENT
0159   04EB             ; break; 
0160   04EB 0A F1 04      jmp _switch2_exit ; case break
0161   04EE             _switch2_case7:
0162   04EE             ; return; 
0163   04EE F9            leave
0164   04EF 05 0B         syscall sys_terminate_proc
0165   04F1             _switch2_exit:
0166   04F1             _for1_update:
0167   04F1 0A 1A 04      jmp _for1_cond
0168   04F4             _for1_exit:
0169   04F4 05 0B         syscall sys_terminate_proc
0170   04F6             
0171   04F6             printf:
0172   04F6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0173   04F9             ; char *p, *format_p; 
0174   04F9 52 02 00      sub sp, 2
0175   04FC 52 02 00      sub sp, 2
0176   04FF             ; format_p = format; 
0177   04FF FA FD FF      lea d, [bp + -3] ; $format_p
0178   0502 DA            push d
0179   0503 FA 05 00      lea d, [bp + 5] ; $format
0180   0506 2A            mov b, [d]
0181   0507 38 00 00      mov c, 0
0182   050A E7            pop d
0183   050B FD 43         mov [d], b
0184   050D             ; p = &format + 2; 
0185   050D FA FF FF      lea d, [bp + -1] ; $p
0186   0510 DA            push d
0187   0511 FA 05 00      lea d, [bp + 5] ; $format
0188   0514 2D            mov b, d
0189   0515             ; --- START TERMS
0190   0515 D7            push a
0191   0516 11            mov a, b
0192   0517 FD 2E 02 00   mov32 cb, $00000002
0192   051B 00 00 
0193   051D 56            add b, a
0194   051E E4            pop a
0195   051F             ; --- END TERMS
0196   051F E7            pop d
0197   0520 FD 43         mov [d], b
0198   0522             ; for(;;){ 
0199   0522             _for3_init:
0200   0522             _for3_cond:
0201   0522             _for3_block:
0202   0522             ; if(!*format_p) break; 
0203   0522             _if4_cond:
0204   0522 FA FD FF      lea d, [bp + -3] ; $format_p
0205   0525 2A            mov b, [d]
0206   0526 38 00 00      mov c, 0
0207   0529 74            mov d, b
0208   052A 32            mov bl, [d]
0209   052B A7 00         mov bh, 0
0210   052D 38 00 00      mov c, 0
0211   0530 C0 00 00      cmp b, 0
0212   0533 FD 71         seq ; !
0213   0535 C0 00 00      cmp b, 0
0214   0538 C6 41 05      je _if4_else
0215   053B             _if4_TRUE:
0216   053B             ; break; 
0217   053B 0A E1 07      jmp _for3_exit ; for break
0218   053E 0A CE 07      jmp _if4_exit
0219   0541             _if4_else:
0220   0541             ; if(*format_p == '%'){ 
0221   0541             _if5_cond:
0222   0541 FA FD FF      lea d, [bp + -3] ; $format_p
0223   0544 2A            mov b, [d]
0224   0545 38 00 00      mov c, 0
0225   0548 74            mov d, b
0226   0549 32            mov bl, [d]
0227   054A A7 00         mov bh, 0
0228   054C 38 00 00      mov c, 0
0229   054F             ; --- START RELATIONAL
0230   054F D7            push a
0231   0550 11            mov a, b
0232   0551 FD 2E 25 00   mov32 cb, $00000025
0232   0555 00 00 
0233   0557 B0            cmp a, b
0234   0558 FD 71         seq ; ==
0235   055A E4            pop a
0236   055B             ; --- END RELATIONAL
0237   055B C0 00 00      cmp b, 0
0238   055E C6 B9 07      je _if5_else
0239   0561             _if5_TRUE:
0240   0561             ; format_p++; 
0241   0561 FA FD FF      lea d, [bp + -3] ; $format_p
0242   0564 2A            mov b, [d]
0243   0565 38 00 00      mov c, 0
0244   0568 FD 77         inc b
0245   056A FA FD FF      lea d, [bp + -3] ; $format_p
0246   056D FD 43         mov [d], b
0247   056F FD 7D         dec b
0248   0571             ; switch(*format_p){ 
0249   0571             _switch6_expr:
0250   0571 FA FD FF      lea d, [bp + -3] ; $format_p
0251   0574 2A            mov b, [d]
0252   0575 38 00 00      mov c, 0
0253   0578 74            mov d, b
0254   0579 32            mov bl, [d]
0255   057A A7 00         mov bh, 0
0256   057C 38 00 00      mov c, 0
0257   057F             _switch6_comparisons:
0258   057F C1 6C         cmp bl, $6c
0259   0581 C6 AD 05      je _switch6_case0
0260   0584 C1 4C         cmp bl, $4c
0261   0586 C6 AD 05      je _switch6_case1
0262   0589 C1 64         cmp bl, $64
0263   058B C6 BD 06      je _switch6_case2
0264   058E C1 69         cmp bl, $69
0265   0590 C6 BD 06      je _switch6_case3
0266   0593 C1 75         cmp bl, $75
0267   0595 C6 ED 06      je _switch6_case4
0268   0598 C1 78         cmp bl, $78
0269   059A C6 1D 07      je _switch6_case5
0270   059D C1 63         cmp bl, $63
0271   059F C6 4D 07      je _switch6_case6
0272   05A2 C1 73         cmp bl, $73
0273   05A4 C6 7D 07      je _switch6_case7
0274   05A7 0A AA 07      jmp _switch6_default
0275   05AA 0A B6 07      jmp _switch6_exit
0276   05AD             _switch6_case0:
0277   05AD             _switch6_case1:
0278   05AD             ; format_p++; 
0279   05AD FA FD FF      lea d, [bp + -3] ; $format_p
0280   05B0 2A            mov b, [d]
0281   05B1 38 00 00      mov c, 0
0282   05B4 FD 77         inc b
0283   05B6 FA FD FF      lea d, [bp + -3] ; $format_p
0284   05B9 FD 43         mov [d], b
0285   05BB FD 7D         dec b
0286   05BD             ; if(*format_p == 'd' || *format_p == 'i') 
0287   05BD             _if7_cond:
0288   05BD FA FD FF      lea d, [bp + -3] ; $format_p
0289   05C0 2A            mov b, [d]
0290   05C1 38 00 00      mov c, 0
0291   05C4 74            mov d, b
0292   05C5 32            mov bl, [d]
0293   05C6 A7 00         mov bh, 0
0294   05C8 38 00 00      mov c, 0
0295   05CB             ; --- START RELATIONAL
0296   05CB D7            push a
0297   05CC 11            mov a, b
0298   05CD FD 2E 64 00   mov32 cb, $00000064
0298   05D1 00 00 
0299   05D3 B0            cmp a, b
0300   05D4 FD 71         seq ; ==
0301   05D6 E4            pop a
0302   05D7             ; --- END RELATIONAL
0303   05D7             ; --- START LOGICAL OR
0304   05D7 D7            push a
0305   05D8 11            mov a, b
0306   05D9 FA FD FF      lea d, [bp + -3] ; $format_p
0307   05DC 2A            mov b, [d]
0308   05DD 38 00 00      mov c, 0
0309   05E0 74            mov d, b
0310   05E1 32            mov bl, [d]
0311   05E2 A7 00         mov bh, 0
0312   05E4 38 00 00      mov c, 0
0313   05E7             ; --- START RELATIONAL
0314   05E7 D7            push a
0315   05E8 11            mov a, b
0316   05E9 FD 2E 69 00   mov32 cb, $00000069
0316   05ED 00 00 
0317   05EF B0            cmp a, b
0318   05F0 FD 71         seq ; ==
0319   05F2 E4            pop a
0320   05F3             ; --- END RELATIONAL
0321   05F3 FD A8         sor a, b ; ||
0322   05F5 E4            pop a
0323   05F6             ; --- END LOGICAL OR
0324   05F6 C0 00 00      cmp b, 0
0325   05F9 C6 1A 06      je _if7_else
0326   05FC             _if7_TRUE:
0327   05FC             ; print_signed_long(*(long *)p); 
0328   05FC             ; --- START FUNCTION CALL
0329   05FC FA FF FF      lea d, [bp + -1] ; $p
0330   05FF 2A            mov b, [d]
0331   0600 38 00 00      mov c, 0
0332   0603 74            mov d, b
0333   0604 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0334   0607 FD 39         mov c, b ; And place it into C
0335   0609 2A            mov b, [d] ; Lower Word in B
0336   060A 12            mov a, c
0337   060B FD AA         swp a
0338   060D D7            push a
0339   060E FD AB         swp b
0340   0610 D8            push b
0341   0611 07 E3 07      call print_signed_long
0342   0614 51 04 00      add sp, 4
0343   0617             ; --- END FUNCTION CALL
0344   0617 0A A2 06      jmp _if7_exit
0345   061A             _if7_else:
0346   061A             ; if(*format_p == 'u') 
0347   061A             _if8_cond:
0348   061A FA FD FF      lea d, [bp + -3] ; $format_p
0349   061D 2A            mov b, [d]
0350   061E 38 00 00      mov c, 0
0351   0621 74            mov d, b
0352   0622 32            mov bl, [d]
0353   0623 A7 00         mov bh, 0
0354   0625 38 00 00      mov c, 0
0355   0628             ; --- START RELATIONAL
0356   0628 D7            push a
0357   0629 11            mov a, b
0358   062A FD 2E 75 00   mov32 cb, $00000075
0358   062E 00 00 
0359   0630 B0            cmp a, b
0360   0631 FD 71         seq ; ==
0361   0633 E4            pop a
0362   0634             ; --- END RELATIONAL
0363   0634 C0 00 00      cmp b, 0
0364   0637 C6 58 06      je _if8_else
0365   063A             _if8_TRUE:
0366   063A             ; print_unsigned_long(*(unsigned long *)p); 
0367   063A             ; --- START FUNCTION CALL
0368   063A FA FF FF      lea d, [bp + -1] ; $p
0369   063D 2A            mov b, [d]
0370   063E 38 00 00      mov c, 0
0371   0641 74            mov d, b
0372   0642 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0373   0645 FD 39         mov c, b ; And place it into C
0374   0647 2A            mov b, [d] ; Lower Word in B
0375   0648 12            mov a, c
0376   0649 FD AA         swp a
0377   064B D7            push a
0378   064C FD AB         swp b
0379   064E D8            push b
0380   064F 07 76 09      call print_unsigned_long
0381   0652 51 04 00      add sp, 4
0382   0655             ; --- END FUNCTION CALL
0383   0655 0A A2 06      jmp _if8_exit
0384   0658             _if8_else:
0385   0658             ; if(*format_p == 'x') 
0386   0658             _if9_cond:
0387   0658 FA FD FF      lea d, [bp + -3] ; $format_p
0388   065B 2A            mov b, [d]
0389   065C 38 00 00      mov c, 0
0390   065F 74            mov d, b
0391   0660 32            mov bl, [d]
0392   0661 A7 00         mov bh, 0
0393   0663 38 00 00      mov c, 0
0394   0666             ; --- START RELATIONAL
0395   0666 D7            push a
0396   0667 11            mov a, b
0397   0668 FD 2E 78 00   mov32 cb, $00000078
0397   066C 00 00 
0398   066E B0            cmp a, b
0399   066F FD 71         seq ; ==
0400   0671 E4            pop a
0401   0672             ; --- END RELATIONAL
0402   0672 C0 00 00      cmp b, 0
0403   0675 C6 96 06      je _if9_else
0404   0678             _if9_TRUE:
0405   0678             ; printx32(*(long int *)p); 
0406   0678             ; --- START FUNCTION CALL
0407   0678 FA FF FF      lea d, [bp + -1] ; $p
0408   067B 2A            mov b, [d]
0409   067C 38 00 00      mov c, 0
0410   067F 74            mov d, b
0411   0680 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0412   0683 FD 39         mov c, b ; And place it into C
0413   0685 2A            mov b, [d] ; Lower Word in B
0414   0686 12            mov a, c
0415   0687 FD AA         swp a
0416   0689 D7            push a
0417   068A FD AB         swp b
0418   068C D8            push b
0419   068D 07 AA 0A      call printx32
0420   0690 51 04 00      add sp, 4
0421   0693             ; --- END FUNCTION CALL
0422   0693 0A A2 06      jmp _if9_exit
0423   0696             _if9_else:
0424   0696             ; err("Unexpected format in printf."); 
0425   0696             ; --- START FUNCTION CALL
0426   0696 26 77 0E      mov b, _s4 ; "Unexpected format in printf."
0427   0699 FD AB         swp b
0428   069B D8            push b
0429   069C 07 0A 0B      call err
0430   069F 51 02 00      add sp, 2
0431   06A2             ; --- END FUNCTION CALL
0432   06A2             _if9_exit:
0433   06A2             _if8_exit:
0434   06A2             _if7_exit:
0435   06A2             ; p = p + 4; 
0436   06A2 FA FF FF      lea d, [bp + -1] ; $p
0437   06A5 DA            push d
0438   06A6 FA FF FF      lea d, [bp + -1] ; $p
0439   06A9 2A            mov b, [d]
0440   06AA 38 00 00      mov c, 0
0441   06AD             ; --- START TERMS
0442   06AD D7            push a
0443   06AE 11            mov a, b
0444   06AF FD 2E 04 00   mov32 cb, $00000004
0444   06B3 00 00 
0445   06B5 56            add b, a
0446   06B6 E4            pop a
0447   06B7             ; --- END TERMS
0448   06B7 E7            pop d
0449   06B8 FD 43         mov [d], b
0450   06BA             ; break; 
0451   06BA 0A B6 07      jmp _switch6_exit ; case break
0452   06BD             _switch6_case2:
0453   06BD             _switch6_case3:
0454   06BD             ; print_signed(*(int*)p); 
0455   06BD             ; --- START FUNCTION CALL
0456   06BD FA FF FF      lea d, [bp + -1] ; $p
0457   06C0 2A            mov b, [d]
0458   06C1 38 00 00      mov c, 0
0459   06C4 74            mov d, b
0460   06C5 2A            mov b, [d]
0461   06C6 38 00 00      mov c, 0
0462   06C9 FD AB         swp b
0463   06CB D8            push b
0464   06CC 07 38 0B      call print_signed
0465   06CF 51 02 00      add sp, 2
0466   06D2             ; --- END FUNCTION CALL
0467   06D2             ; p = p + 2; 
0468   06D2 FA FF FF      lea d, [bp + -1] ; $p
0469   06D5 DA            push d
0470   06D6 FA FF FF      lea d, [bp + -1] ; $p
0471   06D9 2A            mov b, [d]
0472   06DA 38 00 00      mov c, 0
0473   06DD             ; --- START TERMS
0474   06DD D7            push a
0475   06DE 11            mov a, b
0476   06DF FD 2E 02 00   mov32 cb, $00000002
0476   06E3 00 00 
0477   06E5 56            add b, a
0478   06E6 E4            pop a
0479   06E7             ; --- END TERMS
0480   06E7 E7            pop d
0481   06E8 FD 43         mov [d], b
0482   06EA             ; break; 
0483   06EA 0A B6 07      jmp _switch6_exit ; case break
0484   06ED             _switch6_case4:
0485   06ED             ; print_unsigned(*(unsigned int*)p); 
0486   06ED             ; --- START FUNCTION CALL
0487   06ED FA FF FF      lea d, [bp + -1] ; $p
0488   06F0 2A            mov b, [d]
0489   06F1 38 00 00      mov c, 0
0490   06F4 74            mov d, b
0491   06F5 2A            mov b, [d]
0492   06F6 38 00 00      mov c, 0
0493   06F9 FD AB         swp b
0494   06FB D8            push b
0495   06FC 07 89 0C      call print_unsigned
0496   06FF 51 02 00      add sp, 2
0497   0702             ; --- END FUNCTION CALL
0498   0702             ; p = p + 2; 
0499   0702 FA FF FF      lea d, [bp + -1] ; $p
0500   0705 DA            push d
0501   0706 FA FF FF      lea d, [bp + -1] ; $p
0502   0709 2A            mov b, [d]
0503   070A 38 00 00      mov c, 0
0504   070D             ; --- START TERMS
0505   070D D7            push a
0506   070E 11            mov a, b
0507   070F FD 2E 02 00   mov32 cb, $00000002
0507   0713 00 00 
0508   0715 56            add b, a
0509   0716 E4            pop a
0510   0717             ; --- END TERMS
0511   0717 E7            pop d
0512   0718 FD 43         mov [d], b
0513   071A             ; break; 
0514   071A 0A B6 07      jmp _switch6_exit ; case break
0515   071D             _switch6_case5:
0516   071D             ; printx16(*(int*)p); 
0517   071D             ; --- START FUNCTION CALL
0518   071D FA FF FF      lea d, [bp + -1] ; $p
0519   0720 2A            mov b, [d]
0520   0721 38 00 00      mov c, 0
0521   0724 74            mov d, b
0522   0725 2A            mov b, [d]
0523   0726 38 00 00      mov c, 0
0524   0729 FD AB         swp b
0525   072B D8            push b
0526   072C 07 A1 0D      call printx16
0527   072F 51 02 00      add sp, 2
0528   0732             ; --- END FUNCTION CALL
0529   0732             ; p = p + 2; 
0530   0732 FA FF FF      lea d, [bp + -1] ; $p
0531   0735 DA            push d
0532   0736 FA FF FF      lea d, [bp + -1] ; $p
0533   0739 2A            mov b, [d]
0534   073A 38 00 00      mov c, 0
0535   073D             ; --- START TERMS
0536   073D D7            push a
0537   073E 11            mov a, b
0538   073F FD 2E 02 00   mov32 cb, $00000002
0538   0743 00 00 
0539   0745 56            add b, a
0540   0746 E4            pop a
0541   0747             ; --- END TERMS
0542   0747 E7            pop d
0543   0748 FD 43         mov [d], b
0544   074A             ; break; 
0545   074A 0A B6 07      jmp _switch6_exit ; case break
0546   074D             _switch6_case6:
0547   074D             ; putchar(*(char*)p); 
0548   074D             ; --- START FUNCTION CALL
0549   074D FA FF FF      lea d, [bp + -1] ; $p
0550   0750 2A            mov b, [d]
0551   0751 38 00 00      mov c, 0
0552   0754 74            mov d, b
0553   0755 32            mov bl, [d]
0554   0756 A7 00         mov bh, 0
0555   0758 38 00 00      mov c, 0
0556   075B DD            push bl
0557   075C 07 68 09      call putchar
0558   075F 51 01 00      add sp, 1
0559   0762             ; --- END FUNCTION CALL
0560   0762             ; p = p + 2; 
0561   0762 FA FF FF      lea d, [bp + -1] ; $p
0562   0765 DA            push d
0563   0766 FA FF FF      lea d, [bp + -1] ; $p
0564   0769 2A            mov b, [d]
0565   076A 38 00 00      mov c, 0
0566   076D             ; --- START TERMS
0567   076D D7            push a
0568   076E 11            mov a, b
0569   076F FD 2E 02 00   mov32 cb, $00000002
0569   0773 00 00 
0570   0775 56            add b, a
0571   0776 E4            pop a
0572   0777             ; --- END TERMS
0573   0777 E7            pop d
0574   0778 FD 43         mov [d], b
0575   077A             ; break; 
0576   077A 0A B6 07      jmp _switch6_exit ; case break
0577   077D             _switch6_case7:
0578   077D             ; print(*(char**)p); 
0579   077D             ; --- START FUNCTION CALL
0580   077D FA FF FF      lea d, [bp + -1] ; $p
0581   0780 2A            mov b, [d]
0582   0781 38 00 00      mov c, 0
0583   0784 74            mov d, b
0584   0785 2A            mov b, [d]
0585   0786 FD AB         swp b
0586   0788 D8            push b
0587   0789 07 1F 0B      call print
0588   078C 51 02 00      add sp, 2
0589   078F             ; --- END FUNCTION CALL
0590   078F             ; p = p + 2; 
0591   078F FA FF FF      lea d, [bp + -1] ; $p
0592   0792 DA            push d
0593   0793 FA FF FF      lea d, [bp + -1] ; $p
0594   0796 2A            mov b, [d]
0595   0797 38 00 00      mov c, 0
0596   079A             ; --- START TERMS
0597   079A D7            push a
0598   079B 11            mov a, b
0599   079C FD 2E 02 00   mov32 cb, $00000002
0599   07A0 00 00 
0600   07A2 56            add b, a
0601   07A3 E4            pop a
0602   07A4             ; --- END TERMS
0603   07A4 E7            pop d
0604   07A5 FD 43         mov [d], b
0605   07A7             ; break; 
0606   07A7 0A B6 07      jmp _switch6_exit ; case break
0607   07AA             _switch6_default:
0608   07AA             ; print("Error: Unknown argument type.\n"); 
0609   07AA             ; --- START FUNCTION CALL
0610   07AA 26 94 0E      mov b, _s5 ; "Error: Unknown argument type.\n"
0611   07AD FD AB         swp b
0612   07AF D8            push b
0613   07B0 07 1F 0B      call print
0614   07B3 51 02 00      add sp, 2
0615   07B6             ; --- END FUNCTION CALL
0616   07B6             _switch6_exit:
0617   07B6 0A CE 07      jmp _if5_exit
0618   07B9             _if5_else:
0619   07B9             ; putchar(*format_p); 
0620   07B9             ; --- START FUNCTION CALL
0621   07B9 FA FD FF      lea d, [bp + -3] ; $format_p
0622   07BC 2A            mov b, [d]
0623   07BD 38 00 00      mov c, 0
0624   07C0 74            mov d, b
0625   07C1 32            mov bl, [d]
0626   07C2 A7 00         mov bh, 0
0627   07C4 38 00 00      mov c, 0
0628   07C7 DD            push bl
0629   07C8 07 68 09      call putchar
0630   07CB 51 01 00      add sp, 1
0631   07CE             ; --- END FUNCTION CALL
0632   07CE             _if5_exit:
0633   07CE             _if4_exit:
0634   07CE             ; format_p++; 
0635   07CE FA FD FF      lea d, [bp + -3] ; $format_p
0636   07D1 2A            mov b, [d]
0637   07D2 38 00 00      mov c, 0
0638   07D5 FD 77         inc b
0639   07D7 FA FD FF      lea d, [bp + -3] ; $format_p
0640   07DA FD 43         mov [d], b
0641   07DC FD 7D         dec b
0642   07DE             _for3_update:
0643   07DE 0A 22 05      jmp _for3_cond
0644   07E1             _for3_exit:
0645   07E1 F9            leave
0646   07E2 09            ret
0647   07E3             
0648   07E3             print_signed_long:
0649   07E3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0650   07E6             ; char digits[10]; 
0651   07E6 52 0A 00      sub sp, 10
0652   07E9             ; int i = 0; 
0653   07E9 52 02 00      sub sp, 2
0654   07EC             ; --- START LOCAL VAR INITIALIZATION
0655   07EC FA F5 FF      lea d, [bp + -11] ; $i
0656   07EF DA            push d
0657   07F0 FD 2E 00 00   mov32 cb, $00000000
0657   07F4 00 00 
0658   07F6 E7            pop d
0659   07F7 FD 43         mov [d], b
0660   07F9             ; --- END LOCAL VAR INITIALIZATION
0661   07F9             ; if (num < 0) { 
0662   07F9             _if10_cond:
0663   07F9 FA 05 00      lea d, [bp + 5] ; $num
0664   07FC 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0665   07FF FD 39         mov c, b ; And place it into C
0666   0801 2A            mov b, [d] ; Lower Word in B
0667   0802             ; --- START RELATIONAL
0668   0802 D7            push a
0669   0803 FD D8         push g
0670   0805 11            mov a, b
0671   0806 FD 7A         mov g, c
0672   0808 FD 2E 00 00   mov32 cb, $00000000
0672   080C 00 00 
0673   080E FD AF         cmp32 ga, cb
0674   0810 FD 73         slt ; <
0675   0812 FD F1         pop g
0676   0814 E4            pop a
0677   0815             ; --- END RELATIONAL
0678   0815 C0 00 00      cmp b, 0
0679   0818 C6 4A 08      je _if10_else
0680   081B             _if10_TRUE:
0681   081B             ; putchar('-'); 
0682   081B             ; --- START FUNCTION CALL
0683   081B FD 2E 2D 00   mov32 cb, $0000002d
0683   081F 00 00 
0684   0821 DD            push bl
0685   0822 07 68 09      call putchar
0686   0825 51 01 00      add sp, 1
0687   0828             ; --- END FUNCTION CALL
0688   0828             ; num = -num; 
0689   0828 FA 05 00      lea d, [bp + 5] ; $num
0690   082B DA            push d
0691   082C FA 05 00      lea d, [bp + 5] ; $num
0692   082F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0693   0832 FD 39         mov c, b ; And place it into C
0694   0834 2A            mov b, [d] ; Lower Word in B
0695   0835 12            mov a, c
0696   0836 95            not a
0697   0837 97            not b
0698   0838 55 01 00      add b, 1
0699   083B 5B 00 00      adc a, 0
0700   083E 39            mov c, a
0701   083F E7            pop d
0702   0840 FD 43         mov [d], b
0703   0842 28            mov b, c
0704   0843 FD 44 02 00   mov [d + 2], b
0705   0847 0A 7E 08      jmp _if10_exit
0706   084A             _if10_else:
0707   084A             ; if (num == 0) { 
0708   084A             _if11_cond:
0709   084A FA 05 00      lea d, [bp + 5] ; $num
0710   084D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0711   0850 FD 39         mov c, b ; And place it into C
0712   0852 2A            mov b, [d] ; Lower Word in B
0713   0853             ; --- START RELATIONAL
0714   0853 D7            push a
0715   0854 FD D8         push g
0716   0856 11            mov a, b
0717   0857 FD 7A         mov g, c
0718   0859 FD 2E 00 00   mov32 cb, $00000000
0718   085D 00 00 
0719   085F FD AF         cmp32 ga, cb
0720   0861 FD 71         seq ; ==
0721   0863 FD F1         pop g
0722   0865 E4            pop a
0723   0866             ; --- END RELATIONAL
0724   0866 C0 00 00      cmp b, 0
0725   0869 C6 7E 08      je _if11_exit
0726   086C             _if11_TRUE:
0727   086C             ; putchar('0'); 
0728   086C             ; --- START FUNCTION CALL
0729   086C FD 2E 30 00   mov32 cb, $00000030
0729   0870 00 00 
0730   0872 DD            push bl
0731   0873 07 68 09      call putchar
0732   0876 51 01 00      add sp, 1
0733   0879             ; --- END FUNCTION CALL
0734   0879             ; return; 
0735   0879 F9            leave
0736   087A 09            ret
0737   087B 0A 7E 08      jmp _if11_exit
0738   087E             _if11_exit:
0739   087E             _if10_exit:
0740   087E             ; while (num > 0) { 
0741   087E             _while12_cond:
0742   087E FA 05 00      lea d, [bp + 5] ; $num
0743   0881 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0744   0884 FD 39         mov c, b ; And place it into C
0745   0886 2A            mov b, [d] ; Lower Word in B
0746   0887             ; --- START RELATIONAL
0747   0887 D7            push a
0748   0888 FD D8         push g
0749   088A 11            mov a, b
0750   088B FD 7A         mov g, c
0751   088D FD 2E 00 00   mov32 cb, $00000000
0751   0891 00 00 
0752   0893 FD AF         cmp32 ga, cb
0753   0895 FD 7F         sgt
0754   0897 FD F1         pop g
0755   0899 E4            pop a
0756   089A             ; --- END RELATIONAL
0757   089A C0 00 00      cmp b, 0
0758   089D C6 1E 09      je _while12_exit
0759   08A0             _while12_block:
0760   08A0             ; digits[i] = '0' + (num % 10); 
0761   08A0 FA F7 FF      lea d, [bp + -9] ; $digits
0762   08A3 D7            push a
0763   08A4 DA            push d
0764   08A5 FA F5 FF      lea d, [bp + -11] ; $i
0765   08A8 2A            mov b, [d]
0766   08A9 38 00 00      mov c, 0
0767   08AC E7            pop d
0768   08AD 5A            add d, b
0769   08AE E4            pop a
0770   08AF DA            push d
0771   08B0 FD 2E 30 00   mov32 cb, $00000030
0771   08B4 00 00 
0772   08B6             ; --- START TERMS
0773   08B6 D7            push a
0774   08B7 11            mov a, b
0775   08B8 FA 05 00      lea d, [bp + 5] ; $num
0776   08BB 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0777   08BE FD 39         mov c, b ; And place it into C
0778   08C0 2A            mov b, [d] ; Lower Word in B
0779   08C1             ; --- START FACTORS
0780   08C1 D7            push a
0781   08C2 FD D8         push g
0782   08C4 11            mov a, b
0783   08C5 FD 7A         mov g, c
0784   08C7 FD 2E 0A 00   mov32 cb, $0000000a
0784   08CB 00 00 
0785   08CD FD D8         push g ; save 'g' as the div instruction uses it
0786   08CF AE            div a, b ; %, a: quotient, b: remainder
0787   08D0 11            mov a, b
0788   08D1 FD F1         pop g
0789   08D3 FD 38         mov c, g
0790   08D5 27            mov b, a
0791   08D6 FD F1         pop g
0792   08D8 E4            pop a
0793   08D9             ; --- END FACTORS
0794   08D9 FD 15         add32 cb, ga
0795   08DB E4            pop a
0796   08DC             ; --- END TERMS
0797   08DC E7            pop d
0798   08DD FD 3E         mov [d], bl
0799   08DF             ; num = num / 10; 
0800   08DF FA 05 00      lea d, [bp + 5] ; $num
0801   08E2 DA            push d
0802   08E3 FA 05 00      lea d, [bp + 5] ; $num
0803   08E6 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0804   08E9 FD 39         mov c, b ; And place it into C
0805   08EB 2A            mov b, [d] ; Lower Word in B
0806   08EC             ; --- START FACTORS
0807   08EC D7            push a
0808   08ED FD D8         push g
0809   08EF 11            mov a, b
0810   08F0 FD 7A         mov g, c
0811   08F2 FD 2E 0A 00   mov32 cb, $0000000a
0811   08F6 00 00 
0812   08F8 FD D8         push g ; save 'g' as the div instruction uses it
0813   08FA AE            div a, b ; /, a: quotient, b: remainder
0814   08FB FD F1         pop g
0815   08FD FD 38         mov c, g
0816   08FF 27            mov b, a
0817   0900 FD F1         pop g
0818   0902 E4            pop a
0819   0903             ; --- END FACTORS
0820   0903 E7            pop d
0821   0904 FD 43         mov [d], b
0822   0906 28            mov b, c
0823   0907 FD 44 02 00   mov [d + 2], b
0824   090B             ; i++; 
0825   090B FA F5 FF      lea d, [bp + -11] ; $i
0826   090E 2A            mov b, [d]
0827   090F 38 00 00      mov c, 0
0828   0912 11            mov a, b
0829   0913 FD 77         inc b
0830   0915 FA F5 FF      lea d, [bp + -11] ; $i
0831   0918 FD 43         mov [d], b
0832   091A 27            mov b, a
0833   091B 0A 7E 08      jmp _while12_cond
0834   091E             _while12_exit:
0835   091E             ; while (i > 0) { 
0836   091E             _while19_cond:
0837   091E FA F5 FF      lea d, [bp + -11] ; $i
0838   0921 2A            mov b, [d]
0839   0922 38 00 00      mov c, 0
0840   0925             ; --- START RELATIONAL
0841   0925 D7            push a
0842   0926 11            mov a, b
0843   0927 FD 2E 00 00   mov32 cb, $00000000
0843   092B 00 00 
0844   092D B0            cmp a, b
0845   092E FD 7F         sgt ; >
0846   0930 E4            pop a
0847   0931             ; --- END RELATIONAL
0848   0931 C0 00 00      cmp b, 0
0849   0934 C6 66 09      je _while19_exit
0850   0937             _while19_block:
0851   0937             ; i--; 
0852   0937 FA F5 FF      lea d, [bp + -11] ; $i
0853   093A 2A            mov b, [d]
0854   093B 38 00 00      mov c, 0
0855   093E 11            mov a, b
0856   093F FD 7D         dec b
0857   0941 FA F5 FF      lea d, [bp + -11] ; $i
0858   0944 FD 43         mov [d], b
0859   0946 27            mov b, a
0860   0947             ; putchar(digits[i]); 
0861   0947             ; --- START FUNCTION CALL
0862   0947 FA F7 FF      lea d, [bp + -9] ; $digits
0863   094A D7            push a
0864   094B DA            push d
0865   094C FA F5 FF      lea d, [bp + -11] ; $i
0866   094F 2A            mov b, [d]
0867   0950 38 00 00      mov c, 0
0868   0953 E7            pop d
0869   0954 5A            add d, b
0870   0955 E4            pop a
0871   0956 32            mov bl, [d]
0872   0957 A7 00         mov bh, 0
0873   0959 38 00 00      mov c, 0
0874   095C DD            push bl
0875   095D 07 68 09      call putchar
0876   0960 51 01 00      add sp, 1
0877   0963             ; --- END FUNCTION CALL
0878   0963 0A 1E 09      jmp _while19_cond
0879   0966             _while19_exit:
0880   0966 F9            leave
0881   0967 09            ret
0882   0968             
0883   0968             putchar:
0884   0968 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0885   096B             ; --- BEGIN INLINE ASM SEGMENT
0886   096B FA 05 00      lea d, [bp + 5] ; $c
0887   096E 1E            mov al, [d]
0888   096F 23            mov ah, al
0889   0970 19 00         mov al, 0
0890   0972 05 03         syscall sys_io      ; char in AH
0891   0974             ; --- END INLINE ASM SEGMENT
0892   0974 F9            leave
0893   0975 09            ret
0894   0976             
0895   0976             print_unsigned_long:
0896   0976 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0897   0979             ; char digits[10]; 
0898   0979 52 0A 00      sub sp, 10
0899   097C             ; int i; 
0900   097C 52 02 00      sub sp, 2
0901   097F             ; i = 0; 
0902   097F FA F5 FF      lea d, [bp + -11] ; $i
0903   0982 DA            push d
0904   0983 FD 2E 00 00   mov32 cb, $00000000
0904   0987 00 00 
0905   0989 E7            pop d
0906   098A FD 43         mov [d], b
0907   098C             ; if(num == 0){ 
0908   098C             _if20_cond:
0909   098C FA 05 00      lea d, [bp + 5] ; $num
0910   098F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0911   0992 FD 39         mov c, b ; And place it into C
0912   0994 2A            mov b, [d] ; Lower Word in B
0913   0995             ; --- START RELATIONAL
0914   0995 D7            push a
0915   0996 FD D8         push g
0916   0998 11            mov a, b
0917   0999 FD 7A         mov g, c
0918   099B FD 2E 00 00   mov32 cb, $00000000
0918   099F 00 00 
0919   09A1 FD AF         cmp32 ga, cb
0920   09A3 FD 71         seq ; ==
0921   09A5 FD F1         pop g
0922   09A7 E4            pop a
0923   09A8             ; --- END RELATIONAL
0924   09A8 C0 00 00      cmp b, 0
0925   09AB C6 C0 09      je _if20_exit
0926   09AE             _if20_TRUE:
0927   09AE             ; putchar('0'); 
0928   09AE             ; --- START FUNCTION CALL
0929   09AE FD 2E 30 00   mov32 cb, $00000030
0929   09B2 00 00 
0930   09B4 DD            push bl
0931   09B5 07 68 09      call putchar
0932   09B8 51 01 00      add sp, 1
0933   09BB             ; --- END FUNCTION CALL
0934   09BB             ; return; 
0935   09BB F9            leave
0936   09BC 09            ret
0937   09BD 0A C0 09      jmp _if20_exit
0938   09C0             _if20_exit:
0939   09C0             ; while (num > 0) { 
0940   09C0             _while21_cond:
0941   09C0 FA 05 00      lea d, [bp + 5] ; $num
0942   09C3 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0943   09C6 FD 39         mov c, b ; And place it into C
0944   09C8 2A            mov b, [d] ; Lower Word in B
0945   09C9             ; --- START RELATIONAL
0946   09C9 D7            push a
0947   09CA FD D8         push g
0948   09CC 11            mov a, b
0949   09CD FD 7A         mov g, c
0950   09CF FD 2E 00 00   mov32 cb, $00000000
0950   09D3 00 00 
0951   09D5 FD AF         cmp32 ga, cb
0952   09D7 FD 81         sgu
0953   09D9 FD F1         pop g
0954   09DB E4            pop a
0955   09DC             ; --- END RELATIONAL
0956   09DC C0 00 00      cmp b, 0
0957   09DF C6 60 0A      je _while21_exit
0958   09E2             _while21_block:
0959   09E2             ; digits[i] = '0' + (num % 10); 
0960   09E2 FA F7 FF      lea d, [bp + -9] ; $digits
0961   09E5 D7            push a
0962   09E6 DA            push d
0963   09E7 FA F5 FF      lea d, [bp + -11] ; $i
0964   09EA 2A            mov b, [d]
0965   09EB 38 00 00      mov c, 0
0966   09EE E7            pop d
0967   09EF 5A            add d, b
0968   09F0 E4            pop a
0969   09F1 DA            push d
0970   09F2 FD 2E 30 00   mov32 cb, $00000030
0970   09F6 00 00 
0971   09F8             ; --- START TERMS
0972   09F8 D7            push a
0973   09F9 11            mov a, b
0974   09FA FA 05 00      lea d, [bp + 5] ; $num
0975   09FD 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0976   0A00 FD 39         mov c, b ; And place it into C
0977   0A02 2A            mov b, [d] ; Lower Word in B
0978   0A03             ; --- START FACTORS
0979   0A03 D7            push a
0980   0A04 FD D8         push g
0981   0A06 11            mov a, b
0982   0A07 FD 7A         mov g, c
0983   0A09 FD 2E 0A 00   mov32 cb, $0000000a
0983   0A0D 00 00 
0984   0A0F FD D8         push g ; save 'g' as the div instruction uses it
0985   0A11 AE            div a, b ; %, a: quotient, b: remainder
0986   0A12 11            mov a, b
0987   0A13 FD F1         pop g
0988   0A15 FD 38         mov c, g
0989   0A17 27            mov b, a
0990   0A18 FD F1         pop g
0991   0A1A E4            pop a
0992   0A1B             ; --- END FACTORS
0993   0A1B FD 15         add32 cb, ga
0994   0A1D E4            pop a
0995   0A1E             ; --- END TERMS
0996   0A1E E7            pop d
0997   0A1F FD 3E         mov [d], bl
0998   0A21             ; num = num / 10; 
0999   0A21 FA 05 00      lea d, [bp + 5] ; $num
1000   0A24 DA            push d
1001   0A25 FA 05 00      lea d, [bp + 5] ; $num
1002   0A28 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1003   0A2B FD 39         mov c, b ; And place it into C
1004   0A2D 2A            mov b, [d] ; Lower Word in B
1005   0A2E             ; --- START FACTORS
1006   0A2E D7            push a
1007   0A2F FD D8         push g
1008   0A31 11            mov a, b
1009   0A32 FD 7A         mov g, c
1010   0A34 FD 2E 0A 00   mov32 cb, $0000000a
1010   0A38 00 00 
1011   0A3A FD D8         push g ; save 'g' as the div instruction uses it
1012   0A3C AE            div a, b ; /, a: quotient, b: remainder
1013   0A3D FD F1         pop g
1014   0A3F FD 38         mov c, g
1015   0A41 27            mov b, a
1016   0A42 FD F1         pop g
1017   0A44 E4            pop a
1018   0A45             ; --- END FACTORS
1019   0A45 E7            pop d
1020   0A46 FD 43         mov [d], b
1021   0A48 28            mov b, c
1022   0A49 FD 44 02 00   mov [d + 2], b
1023   0A4D             ; i++; 
1024   0A4D FA F5 FF      lea d, [bp + -11] ; $i
1025   0A50 2A            mov b, [d]
1026   0A51 38 00 00      mov c, 0
1027   0A54 11            mov a, b
1028   0A55 FD 77         inc b
1029   0A57 FA F5 FF      lea d, [bp + -11] ; $i
1030   0A5A FD 43         mov [d], b
1031   0A5C 27            mov b, a
1032   0A5D 0A C0 09      jmp _while21_cond
1033   0A60             _while21_exit:
1034   0A60             ; while (i > 0) { 
1035   0A60             _while28_cond:
1036   0A60 FA F5 FF      lea d, [bp + -11] ; $i
1037   0A63 2A            mov b, [d]
1038   0A64 38 00 00      mov c, 0
1039   0A67             ; --- START RELATIONAL
1040   0A67 D7            push a
1041   0A68 11            mov a, b
1042   0A69 FD 2E 00 00   mov32 cb, $00000000
1042   0A6D 00 00 
1043   0A6F B0            cmp a, b
1044   0A70 FD 7F         sgt ; >
1045   0A72 E4            pop a
1046   0A73             ; --- END RELATIONAL
1047   0A73 C0 00 00      cmp b, 0
1048   0A76 C6 A8 0A      je _while28_exit
1049   0A79             _while28_block:
1050   0A79             ; i--; 
1051   0A79 FA F5 FF      lea d, [bp + -11] ; $i
1052   0A7C 2A            mov b, [d]
1053   0A7D 38 00 00      mov c, 0
1054   0A80 11            mov a, b
1055   0A81 FD 7D         dec b
1056   0A83 FA F5 FF      lea d, [bp + -11] ; $i
1057   0A86 FD 43         mov [d], b
1058   0A88 27            mov b, a
1059   0A89             ; putchar(digits[i]); 
1060   0A89             ; --- START FUNCTION CALL
1061   0A89 FA F7 FF      lea d, [bp + -9] ; $digits
1062   0A8C D7            push a
1063   0A8D DA            push d
1064   0A8E FA F5 FF      lea d, [bp + -11] ; $i
1065   0A91 2A            mov b, [d]
1066   0A92 38 00 00      mov c, 0
1067   0A95 E7            pop d
1068   0A96 5A            add d, b
1069   0A97 E4            pop a
1070   0A98 32            mov bl, [d]
1071   0A99 A7 00         mov bh, 0
1072   0A9B 38 00 00      mov c, 0
1073   0A9E DD            push bl
1074   0A9F 07 68 09      call putchar
1075   0AA2 51 01 00      add sp, 1
1076   0AA5             ; --- END FUNCTION CALL
1077   0AA5 0A 60 0A      jmp _while28_cond
1078   0AA8             _while28_exit:
1079   0AA8 F9            leave
1080   0AA9 09            ret
1081   0AAA             
1082   0AAA             printx32:
1083   0AAA F8 00 00      enter 0 ; (push bp; mov bp, sp)
1084   0AAD             ; --- BEGIN INLINE ASM SEGMENT
1085   0AAD FA 05 00      lea d, [bp + 5] ; $hex
1086   0AB0 2B 02 00      mov b, [d+2]
1087   0AB3 07 BC 0A      call print_u16x_printx32
1088   0AB6 2A            mov b, [d]
1089   0AB7 07 BC 0A      call print_u16x_printx32
1090   0ABA             ; --- END INLINE ASM SEGMENT
1091   0ABA             ; return; 
1092   0ABA F9            leave
1093   0ABB 09            ret
1094   0ABC             ; --- BEGIN INLINE ASM SEGMENT
1095   0ABC             print_u16x_printx32:
1096   0ABC D7            push a
1097   0ABD D8            push b
1098   0ABE DD            push bl
1099   0ABF 30            mov bl, bh
1100   0AC0 07 DE 0A      call _itoa_printx32        ; convert bh to char in A
1101   0AC3 2F            mov bl, al        ; save al
1102   0AC4 19 00         mov al, 0
1103   0AC6 05 03         syscall sys_io        ; display AH
1104   0AC8 24            mov ah, bl        ; retrieve al
1105   0AC9 19 00         mov al, 0
1106   0ACB 05 03         syscall sys_io        ; display AL
1107   0ACD EA            pop bl
1108   0ACE 07 DE 0A      call _itoa_printx32        ; convert bh to char in A
1109   0AD1 2F            mov bl, al        ; save al
1110   0AD2 19 00         mov al, 0
1111   0AD4 05 03         syscall sys_io        ; display AH
1112   0AD6 24            mov ah, bl        ; retrieve al
1113   0AD7 19 00         mov al, 0
1114   0AD9 05 03         syscall sys_io        ; display AL
1115   0ADB E5            pop b
1116   0ADC E4            pop a
1117   0ADD 09            ret
1118   0ADE             _itoa_printx32:
1119   0ADE DA            push d
1120   0ADF D8            push b
1121   0AE0 A7 00         mov bh, 0
1122   0AE2 FD A4 04      shr bl, 4  
1123   0AE5 74            mov d, b
1124   0AE6 1F F8 0A      mov al, [d + s_hex_digits_printx32]
1125   0AE9 23            mov ah, al
1126   0AEA E5            pop b
1127   0AEB D8            push b
1128   0AEC A7 00         mov bh, 0
1129   0AEE FD 87 0F      and bl, $0F
1130   0AF1 74            mov d, b
1131   0AF2 1F F8 0A      mov al, [d + s_hex_digits_printx32]
1132   0AF5 E5            pop b
1133   0AF6 E7            pop d
1134   0AF7 09            ret
1135   0AF8 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
1135   0AFC 34 35 36 37 
1135   0B00 38 39 41 42 
1135   0B04 43 44 45 46 
1136   0B08             ; --- END INLINE ASM SEGMENT
1137   0B08 F9            leave
1138   0B09 09            ret
1139   0B0A             
1140   0B0A             err:
1141   0B0A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1142   0B0D             ; print(e); 
1143   0B0D             ; --- START FUNCTION CALL
1144   0B0D FA 05 00      lea d, [bp + 5] ; $e
1145   0B10 2A            mov b, [d]
1146   0B11 38 00 00      mov c, 0
1147   0B14 FD AB         swp b
1148   0B16 D8            push b
1149   0B17 07 1F 0B      call print
1150   0B1A 51 02 00      add sp, 2
1151   0B1D             ; --- END FUNCTION CALL
1152   0B1D F9            leave
1153   0B1E 09            ret
1154   0B1F             
1155   0B1F             print:
1156   0B1F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1157   0B22             ; --- BEGIN INLINE ASM SEGMENT
1158   0B22 FA 05 00      lea d, [bp + 5] ; $s
1159   0B25 FD 2A         mov d, [d]
1160   0B27             _puts_L1_print:
1161   0B27 1E            mov al, [d]
1162   0B28 B9 00         cmp al, 0
1163   0B2A C6 36 0B      jz _puts_END_print
1164   0B2D 23            mov ah, al
1165   0B2E 19 00         mov al, 0
1166   0B30 05 03         syscall sys_io
1167   0B32 79            inc d
1168   0B33 0A 27 0B      jmp _puts_L1_print
1169   0B36             _puts_END_print:
1170   0B36             ; --- END INLINE ASM SEGMENT
1171   0B36 F9            leave
1172   0B37 09            ret
1173   0B38             
1174   0B38             print_signed:
1175   0B38 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1176   0B3B             ; char digits[5]; 
1177   0B3B 52 05 00      sub sp, 5
1178   0B3E             ; int i = 0; 
1179   0B3E 52 02 00      sub sp, 2
1180   0B41             ; --- START LOCAL VAR INITIALIZATION
1181   0B41 FA FA FF      lea d, [bp + -6] ; $i
1182   0B44 DA            push d
1183   0B45 FD 2E 00 00   mov32 cb, $00000000
1183   0B49 00 00 
1184   0B4B E7            pop d
1185   0B4C FD 43         mov [d], b
1186   0B4E             ; --- END LOCAL VAR INITIALIZATION
1187   0B4E             ; if (num < 0) { 
1188   0B4E             _if29_cond:
1189   0B4E FA 05 00      lea d, [bp + 5] ; $num
1190   0B51 2A            mov b, [d]
1191   0B52 38 00 00      mov c, 0
1192   0B55             ; --- START RELATIONAL
1193   0B55 D7            push a
1194   0B56 11            mov a, b
1195   0B57 FD 2E 00 00   mov32 cb, $00000000
1195   0B5B 00 00 
1196   0B5D B0            cmp a, b
1197   0B5E FD 73         slt ; < (signed)
1198   0B60 E4            pop a
1199   0B61             ; --- END RELATIONAL
1200   0B61 C0 00 00      cmp b, 0
1201   0B64 C6 87 0B      je _if29_else
1202   0B67             _if29_TRUE:
1203   0B67             ; putchar('-'); 
1204   0B67             ; --- START FUNCTION CALL
1205   0B67 FD 2E 2D 00   mov32 cb, $0000002d
1205   0B6B 00 00 
1206   0B6D DD            push bl
1207   0B6E 07 68 09      call putchar
1208   0B71 51 01 00      add sp, 1
1209   0B74             ; --- END FUNCTION CALL
1210   0B74             ; num = -num; 
1211   0B74 FA 05 00      lea d, [bp + 5] ; $num
1212   0B77 DA            push d
1213   0B78 FA 05 00      lea d, [bp + 5] ; $num
1214   0B7B 2A            mov b, [d]
1215   0B7C 38 00 00      mov c, 0
1216   0B7F FD 97         neg b
1217   0B81 E7            pop d
1218   0B82 FD 43         mov [d], b
1219   0B84 0A B2 0B      jmp _if29_exit
1220   0B87             _if29_else:
1221   0B87             ; if (num == 0) { 
1222   0B87             _if30_cond:
1223   0B87 FA 05 00      lea d, [bp + 5] ; $num
1224   0B8A 2A            mov b, [d]
1225   0B8B 38 00 00      mov c, 0
1226   0B8E             ; --- START RELATIONAL
1227   0B8E D7            push a
1228   0B8F 11            mov a, b
1229   0B90 FD 2E 00 00   mov32 cb, $00000000
1229   0B94 00 00 
1230   0B96 B0            cmp a, b
1231   0B97 FD 71         seq ; ==
1232   0B99 E4            pop a
1233   0B9A             ; --- END RELATIONAL
1234   0B9A C0 00 00      cmp b, 0
1235   0B9D C6 B2 0B      je _if30_exit
1236   0BA0             _if30_TRUE:
1237   0BA0             ; putchar('0'); 
1238   0BA0             ; --- START FUNCTION CALL
1239   0BA0 FD 2E 30 00   mov32 cb, $00000030
1239   0BA4 00 00 
1240   0BA6 DD            push bl
1241   0BA7 07 68 09      call putchar
1242   0BAA 51 01 00      add sp, 1
1243   0BAD             ; --- END FUNCTION CALL
1244   0BAD             ; return; 
1245   0BAD F9            leave
1246   0BAE 09            ret
1247   0BAF 0A B2 0B      jmp _if30_exit
1248   0BB2             _if30_exit:
1249   0BB2             _if29_exit:
1250   0BB2             ; while (num > 0) { 
1251   0BB2             _while31_cond:
1252   0BB2 FA 05 00      lea d, [bp + 5] ; $num
1253   0BB5 2A            mov b, [d]
1254   0BB6 38 00 00      mov c, 0
1255   0BB9             ; --- START RELATIONAL
1256   0BB9 D7            push a
1257   0BBA 11            mov a, b
1258   0BBB FD 2E 00 00   mov32 cb, $00000000
1258   0BBF 00 00 
1259   0BC1 B0            cmp a, b
1260   0BC2 FD 7F         sgt ; >
1261   0BC4 E4            pop a
1262   0BC5             ; --- END RELATIONAL
1263   0BC5 C0 00 00      cmp b, 0
1264   0BC8 C6 3F 0C      je _while31_exit
1265   0BCB             _while31_block:
1266   0BCB             ; digits[i] = '0' + (num % 10); 
1267   0BCB FA FC FF      lea d, [bp + -4] ; $digits
1268   0BCE D7            push a
1269   0BCF DA            push d
1270   0BD0 FA FA FF      lea d, [bp + -6] ; $i
1271   0BD3 2A            mov b, [d]
1272   0BD4 38 00 00      mov c, 0
1273   0BD7 E7            pop d
1274   0BD8 5A            add d, b
1275   0BD9 E4            pop a
1276   0BDA DA            push d
1277   0BDB FD 2E 30 00   mov32 cb, $00000030
1277   0BDF 00 00 
1278   0BE1             ; --- START TERMS
1279   0BE1 D7            push a
1280   0BE2 11            mov a, b
1281   0BE3 FA 05 00      lea d, [bp + 5] ; $num
1282   0BE6 2A            mov b, [d]
1283   0BE7 38 00 00      mov c, 0
1284   0BEA             ; --- START FACTORS
1285   0BEA D7            push a
1286   0BEB FD D8         push g
1287   0BED 11            mov a, b
1288   0BEE FD 7A         mov g, c
1289   0BF0 FD 2E 0A 00   mov32 cb, $0000000a
1289   0BF4 00 00 
1290   0BF6 FD D8         push g ; save 'g' as the div instruction uses it
1291   0BF8 AE            div a, b ; %, a: quotient, b: remainder
1292   0BF9 11            mov a, b
1293   0BFA FD F1         pop g
1294   0BFC FD 38         mov c, g
1295   0BFE 27            mov b, a
1296   0BFF FD F1         pop g
1297   0C01 E4            pop a
1298   0C02             ; --- END FACTORS
1299   0C02 56            add b, a
1300   0C03 E4            pop a
1301   0C04             ; --- END TERMS
1302   0C04 E7            pop d
1303   0C05 FD 3E         mov [d], bl
1304   0C07             ; num = num / 10; 
1305   0C07 FA 05 00      lea d, [bp + 5] ; $num
1306   0C0A DA            push d
1307   0C0B FA 05 00      lea d, [bp + 5] ; $num
1308   0C0E 2A            mov b, [d]
1309   0C0F 38 00 00      mov c, 0
1310   0C12             ; --- START FACTORS
1311   0C12 D7            push a
1312   0C13 FD D8         push g
1313   0C15 11            mov a, b
1314   0C16 FD 7A         mov g, c
1315   0C18 FD 2E 0A 00   mov32 cb, $0000000a
1315   0C1C 00 00 
1316   0C1E FD D8         push g ; save 'g' as the div instruction uses it
1317   0C20 AE            div a, b ; /, a: quotient, b: remainder
1318   0C21 FD F1         pop g
1319   0C23 FD 38         mov c, g
1320   0C25 27            mov b, a
1321   0C26 FD F1         pop g
1322   0C28 E4            pop a
1323   0C29             ; --- END FACTORS
1324   0C29 E7            pop d
1325   0C2A FD 43         mov [d], b
1326   0C2C             ; i++; 
1327   0C2C FA FA FF      lea d, [bp + -6] ; $i
1328   0C2F 2A            mov b, [d]
1329   0C30 38 00 00      mov c, 0
1330   0C33 11            mov a, b
1331   0C34 FD 77         inc b
1332   0C36 FA FA FF      lea d, [bp + -6] ; $i
1333   0C39 FD 43         mov [d], b
1334   0C3B 27            mov b, a
1335   0C3C 0A B2 0B      jmp _while31_cond
1336   0C3F             _while31_exit:
1337   0C3F             ; while (i > 0) { 
1338   0C3F             _while38_cond:
1339   0C3F FA FA FF      lea d, [bp + -6] ; $i
1340   0C42 2A            mov b, [d]
1341   0C43 38 00 00      mov c, 0
1342   0C46             ; --- START RELATIONAL
1343   0C46 D7            push a
1344   0C47 11            mov a, b
1345   0C48 FD 2E 00 00   mov32 cb, $00000000
1345   0C4C 00 00 
1346   0C4E B0            cmp a, b
1347   0C4F FD 7F         sgt ; >
1348   0C51 E4            pop a
1349   0C52             ; --- END RELATIONAL
1350   0C52 C0 00 00      cmp b, 0
1351   0C55 C6 87 0C      je _while38_exit
1352   0C58             _while38_block:
1353   0C58             ; i--; 
1354   0C58 FA FA FF      lea d, [bp + -6] ; $i
1355   0C5B 2A            mov b, [d]
1356   0C5C 38 00 00      mov c, 0
1357   0C5F 11            mov a, b
1358   0C60 FD 7D         dec b
1359   0C62 FA FA FF      lea d, [bp + -6] ; $i
1360   0C65 FD 43         mov [d], b
1361   0C67 27            mov b, a
1362   0C68             ; putchar(digits[i]); 
1363   0C68             ; --- START FUNCTION CALL
1364   0C68 FA FC FF      lea d, [bp + -4] ; $digits
1365   0C6B D7            push a
1366   0C6C DA            push d
1367   0C6D FA FA FF      lea d, [bp + -6] ; $i
1368   0C70 2A            mov b, [d]
1369   0C71 38 00 00      mov c, 0
1370   0C74 E7            pop d
1371   0C75 5A            add d, b
1372   0C76 E4            pop a
1373   0C77 32            mov bl, [d]
1374   0C78 A7 00         mov bh, 0
1375   0C7A 38 00 00      mov c, 0
1376   0C7D DD            push bl
1377   0C7E 07 68 09      call putchar
1378   0C81 51 01 00      add sp, 1
1379   0C84             ; --- END FUNCTION CALL
1380   0C84 0A 3F 0C      jmp _while38_cond
1381   0C87             _while38_exit:
1382   0C87 F9            leave
1383   0C88 09            ret
1384   0C89             
1385   0C89             print_unsigned:
1386   0C89 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1387   0C8C             ; char digits[5]; 
1388   0C8C 52 05 00      sub sp, 5
1389   0C8F             ; int i; 
1390   0C8F 52 02 00      sub sp, 2
1391   0C92             ; i = 0; 
1392   0C92 FA FA FF      lea d, [bp + -6] ; $i
1393   0C95 DA            push d
1394   0C96 FD 2E 00 00   mov32 cb, $00000000
1394   0C9A 00 00 
1395   0C9C E7            pop d
1396   0C9D FD 43         mov [d], b
1397   0C9F             ; if(num == 0){ 
1398   0C9F             _if39_cond:
1399   0C9F FA 05 00      lea d, [bp + 5] ; $num
1400   0CA2 2A            mov b, [d]
1401   0CA3 38 00 00      mov c, 0
1402   0CA6             ; --- START RELATIONAL
1403   0CA6 D7            push a
1404   0CA7 11            mov a, b
1405   0CA8 FD 2E 00 00   mov32 cb, $00000000
1405   0CAC 00 00 
1406   0CAE B0            cmp a, b
1407   0CAF FD 71         seq ; ==
1408   0CB1 E4            pop a
1409   0CB2             ; --- END RELATIONAL
1410   0CB2 C0 00 00      cmp b, 0
1411   0CB5 C6 CA 0C      je _if39_exit
1412   0CB8             _if39_TRUE:
1413   0CB8             ; putchar('0'); 
1414   0CB8             ; --- START FUNCTION CALL
1415   0CB8 FD 2E 30 00   mov32 cb, $00000030
1415   0CBC 00 00 
1416   0CBE DD            push bl
1417   0CBF 07 68 09      call putchar
1418   0CC2 51 01 00      add sp, 1
1419   0CC5             ; --- END FUNCTION CALL
1420   0CC5             ; return; 
1421   0CC5 F9            leave
1422   0CC6 09            ret
1423   0CC7 0A CA 0C      jmp _if39_exit
1424   0CCA             _if39_exit:
1425   0CCA             ; while (num > 0) { 
1426   0CCA             _while40_cond:
1427   0CCA FA 05 00      lea d, [bp + 5] ; $num
1428   0CCD 2A            mov b, [d]
1429   0CCE 38 00 00      mov c, 0
1430   0CD1             ; --- START RELATIONAL
1431   0CD1 D7            push a
1432   0CD2 11            mov a, b
1433   0CD3 FD 2E 00 00   mov32 cb, $00000000
1433   0CD7 00 00 
1434   0CD9 B0            cmp a, b
1435   0CDA FD 81         sgu ; > (unsigned)
1436   0CDC E4            pop a
1437   0CDD             ; --- END RELATIONAL
1438   0CDD C0 00 00      cmp b, 0
1439   0CE0 C6 57 0D      je _while40_exit
1440   0CE3             _while40_block:
1441   0CE3             ; digits[i] = '0' + (num % 10); 
1442   0CE3 FA FC FF      lea d, [bp + -4] ; $digits
1443   0CE6 D7            push a
1444   0CE7 DA            push d
1445   0CE8 FA FA FF      lea d, [bp + -6] ; $i
1446   0CEB 2A            mov b, [d]
1447   0CEC 38 00 00      mov c, 0
1448   0CEF E7            pop d
1449   0CF0 5A            add d, b
1450   0CF1 E4            pop a
1451   0CF2 DA            push d
1452   0CF3 FD 2E 30 00   mov32 cb, $00000030
1452   0CF7 00 00 
1453   0CF9             ; --- START TERMS
1454   0CF9 D7            push a
1455   0CFA 11            mov a, b
1456   0CFB FA 05 00      lea d, [bp + 5] ; $num
1457   0CFE 2A            mov b, [d]
1458   0CFF 38 00 00      mov c, 0
1459   0D02             ; --- START FACTORS
1460   0D02 D7            push a
1461   0D03 FD D8         push g
1462   0D05 11            mov a, b
1463   0D06 FD 7A         mov g, c
1464   0D08 FD 2E 0A 00   mov32 cb, $0000000a
1464   0D0C 00 00 
1465   0D0E FD D8         push g ; save 'g' as the div instruction uses it
1466   0D10 AE            div a, b ; %, a: quotient, b: remainder
1467   0D11 11            mov a, b
1468   0D12 FD F1         pop g
1469   0D14 FD 38         mov c, g
1470   0D16 27            mov b, a
1471   0D17 FD F1         pop g
1472   0D19 E4            pop a
1473   0D1A             ; --- END FACTORS
1474   0D1A 56            add b, a
1475   0D1B E4            pop a
1476   0D1C             ; --- END TERMS
1477   0D1C E7            pop d
1478   0D1D FD 3E         mov [d], bl
1479   0D1F             ; num = num / 10; 
1480   0D1F FA 05 00      lea d, [bp + 5] ; $num
1481   0D22 DA            push d
1482   0D23 FA 05 00      lea d, [bp + 5] ; $num
1483   0D26 2A            mov b, [d]
1484   0D27 38 00 00      mov c, 0
1485   0D2A             ; --- START FACTORS
1486   0D2A D7            push a
1487   0D2B FD D8         push g
1488   0D2D 11            mov a, b
1489   0D2E FD 7A         mov g, c
1490   0D30 FD 2E 0A 00   mov32 cb, $0000000a
1490   0D34 00 00 
1491   0D36 FD D8         push g ; save 'g' as the div instruction uses it
1492   0D38 AE            div a, b ; /, a: quotient, b: remainder
1493   0D39 FD F1         pop g
1494   0D3B FD 38         mov c, g
1495   0D3D 27            mov b, a
1496   0D3E FD F1         pop g
1497   0D40 E4            pop a
1498   0D41             ; --- END FACTORS
1499   0D41 E7            pop d
1500   0D42 FD 43         mov [d], b
1501   0D44             ; i++; 
1502   0D44 FA FA FF      lea d, [bp + -6] ; $i
1503   0D47 2A            mov b, [d]
1504   0D48 38 00 00      mov c, 0
1505   0D4B 11            mov a, b
1506   0D4C FD 77         inc b
1507   0D4E FA FA FF      lea d, [bp + -6] ; $i
1508   0D51 FD 43         mov [d], b
1509   0D53 27            mov b, a
1510   0D54 0A CA 0C      jmp _while40_cond
1511   0D57             _while40_exit:
1512   0D57             ; while (i > 0) { 
1513   0D57             _while47_cond:
1514   0D57 FA FA FF      lea d, [bp + -6] ; $i
1515   0D5A 2A            mov b, [d]
1516   0D5B 38 00 00      mov c, 0
1517   0D5E             ; --- START RELATIONAL
1518   0D5E D7            push a
1519   0D5F 11            mov a, b
1520   0D60 FD 2E 00 00   mov32 cb, $00000000
1520   0D64 00 00 
1521   0D66 B0            cmp a, b
1522   0D67 FD 7F         sgt ; >
1523   0D69 E4            pop a
1524   0D6A             ; --- END RELATIONAL
1525   0D6A C0 00 00      cmp b, 0
1526   0D6D C6 9F 0D      je _while47_exit
1527   0D70             _while47_block:
1528   0D70             ; i--; 
1529   0D70 FA FA FF      lea d, [bp + -6] ; $i
1530   0D73 2A            mov b, [d]
1531   0D74 38 00 00      mov c, 0
1532   0D77 11            mov a, b
1533   0D78 FD 7D         dec b
1534   0D7A FA FA FF      lea d, [bp + -6] ; $i
1535   0D7D FD 43         mov [d], b
1536   0D7F 27            mov b, a
1537   0D80             ; putchar(digits[i]); 
1538   0D80             ; --- START FUNCTION CALL
1539   0D80 FA FC FF      lea d, [bp + -4] ; $digits
1540   0D83 D7            push a
1541   0D84 DA            push d
1542   0D85 FA FA FF      lea d, [bp + -6] ; $i
1543   0D88 2A            mov b, [d]
1544   0D89 38 00 00      mov c, 0
1545   0D8C E7            pop d
1546   0D8D 5A            add d, b
1547   0D8E E4            pop a
1548   0D8F 32            mov bl, [d]
1549   0D90 A7 00         mov bh, 0
1550   0D92 38 00 00      mov c, 0
1551   0D95 DD            push bl
1552   0D96 07 68 09      call putchar
1553   0D99 51 01 00      add sp, 1
1554   0D9C             ; --- END FUNCTION CALL
1555   0D9C 0A 57 0D      jmp _while47_cond
1556   0D9F             _while47_exit:
1557   0D9F F9            leave
1558   0DA0 09            ret
1559   0DA1             
1560   0DA1             printx16:
1561   0DA1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1562   0DA4             ; --- BEGIN INLINE ASM SEGMENT
1563   0DA4 FA 05 00      lea d, [bp + 5] ; $hex
1564   0DA7 2A            mov b, [d]
1565   0DA8             print_u16x_printx16:
1566   0DA8 DD            push bl
1567   0DA9 30            mov bl, bh
1568   0DAA 07 C7 0D      call _itoa_printx16        ; convert bh to char in A
1569   0DAD 2F            mov bl, al        ; save al
1570   0DAE 19 00         mov al, 0
1571   0DB0 05 03         syscall sys_io        ; display AH
1572   0DB2 24            mov ah, bl        ; retrieve al
1573   0DB3 19 00         mov al, 0
1574   0DB5 05 03         syscall sys_io        ; display AL
1575   0DB7 EA            pop bl
1576   0DB8 07 C7 0D      call _itoa_printx16        ; convert bh to char in A
1577   0DBB 2F            mov bl, al        ; save al
1578   0DBC 19 00         mov al, 0
1579   0DBE 05 03         syscall sys_io        ; display AH
1580   0DC0 24            mov ah, bl        ; retrieve al
1581   0DC1 19 00         mov al, 0
1582   0DC3 05 03         syscall sys_io        ; display AL
1583   0DC5             ; --- END INLINE ASM SEGMENT
1584   0DC5             ; return; 
1585   0DC5 F9            leave
1586   0DC6 09            ret
1587   0DC7             ; --- BEGIN INLINE ASM SEGMENT
1588   0DC7             _itoa_printx16:
1589   0DC7 DA            push d
1590   0DC8 D8            push b
1591   0DC9 A7 00         mov bh, 0
1592   0DCB FD A4 04      shr bl, 4  
1593   0DCE 74            mov d, b
1594   0DCF 1F E1 0D      mov al, [d + s_hex_digits_printx16]
1595   0DD2 23            mov ah, al
1596   0DD3 E5            pop b
1597   0DD4 D8            push b
1598   0DD5 A7 00         mov bh, 0
1599   0DD7 FD 87 0F      and bl, $0F
1600   0DDA 74            mov d, b
1601   0DDB 1F E1 0D      mov al, [d + s_hex_digits_printx16]
1602   0DDE E5            pop b
1603   0DDF E7            pop d
1604   0DE0 09            ret
1605   0DE1 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
1605   0DE5 34 35 36 37 
1605   0DE9 38 39 41 42 
1605   0DED 43 44 45 46 
1606   0DF1             ; --- END INLINE ASM SEGMENT
1607   0DF1 F9            leave
1608   0DF2 09            ret
1609   0DF3             
1610   0DF3             getchar:
1611   0DF3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1612   0DF6             ; char c; 
1613   0DF6 52 01 00      sub sp, 1
1614   0DF9             ; --- BEGIN INLINE ASM SEGMENT
1615   0DF9 19 01         mov al, 1
1616   0DFB 05 03         syscall sys_io      ; receive in AH
1617   0DFD 1A            mov al, ah
1618   0DFE FA 00 00      lea d, [bp + 0] ; $c
1619   0E01 3E            mov [d], al
1620   0E02             ; --- END INLINE ASM SEGMENT
1621   0E02             ; return c; 
1622   0E02 FA 00 00      lea d, [bp + 0] ; $c
1623   0E05 32            mov bl, [d]
1624   0E06 A7 00         mov bh, 0
1625   0E08 38 00 00      mov c, 0
1626   0E0B F9            leave
1627   0E0C 09            ret
1628   0E0D             ; --- END TEXT SEGMENT
1629   0E0D             
1630   0E0D             ; --- BEGIN DATA SEGMENT
1631   0E0D 54 65 73 74 _s0: .db "Test of 5.25 inch Floppy Drive Interface.\n", 0
1631   0E11 20 6F 66 20 
1631   0E15 35 2E 32 35 
1631   0E19 20 69 6E 63 
1631   0E1D 68 20 46 6C 
1631   0E21 6F 70 70 79 
1631   0E25 20 44 72 69 
1631   0E29 76 65 20 49 
1631   0E2D 6E 74 65 72 
1631   0E31 66 61 63 65 
1631   0E35 2E 0A 00 
1632   0E38 0A 4F 70 74 _s1: .db "\nOption: ", 0
1632   0E3C 69 6F 6E 3A 
1632   0E40 20 00 
1633   0E42 0A 44 61 74 _s2: .db "\nData register value: %d\n", 0
1633   0E46 61 20 72 65 
1633   0E4A 67 69 73 74 
1633   0E4E 65 72 20 76 
1633   0E52 61 6C 75 65 
1633   0E56 3A 20 25 64 
1633   0E5A 0A 00 
1634   0E5C 0A 54 72 61 _s3: .db "\nTrack register value: %d\n", 0
1634   0E60 63 6B 20 72 
1634   0E64 65 67 69 73 
1634   0E68 74 65 72 20 
1634   0E6C 76 61 6C 75 
1634   0E70 65 3A 20 25 
1634   0E74 64 0A 00 
1635   0E77 55 6E 65 78 _s4: .db "Unexpected format in printf.", 0
1635   0E7B 70 65 63 74 
1635   0E7F 65 64 20 66 
1635   0E83 6F 72 6D 61 
1635   0E87 74 20 69 6E 
1635   0E8B 20 70 72 69 
1635   0E8F 6E 74 66 2E 
1635   0E93 00 
1636   0E94 45 72 72 6F _s5: .db "Error: Unknown argument type.\n", 0
1636   0E98 72 3A 20 55 
1636   0E9C 6E 6B 6E 6F 
1636   0EA0 77 6E 20 61 
1636   0EA4 72 67 75 6D 
1636   0EA8 65 6E 74 20 
1636   0EAC 74 79 70 65 
1636   0EB0 2E 0A 00 
1637   0EB3             
1638   0EB3 B5 0E       _heap_top: .dw _heap
1639   0EB5 00          _heap: .db 0
1640   0EB6             ; --- END DATA SEGMENT
1641   0EB6             
1642   0EB6             .end
tasm: Number of errors = 0
