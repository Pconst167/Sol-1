0001   0000             ; --- FILENAME: test
0002   0000             .include "lib/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; $i 
0011   0408 10 00 00      mov a, $0
0012   040B 45 FF FF      mov [bp + -1], a
0013   040E 52 02 00      sub sp, 2
0014   0411             ;; i++; 
0015   0411 FA FF FF      lea d, [bp + -1] ; $i
0016   0414 2A            mov b, [d]
0017   0415 FD 79         mov g, b
0018   0417 FD 77         inc b
0019   0419 FA FF FF      lea d, [bp + -1] ; $i
0020   041C FD 43         mov [d], b
0021   041E FD 27         mov b, g
0022   0420             ;; ++i; 
0023   0420 FA FF FF      lea d, [bp + -1] ; $i
0024   0423 2A            mov b, [d]
0025   0424 FD 77         inc b
0026   0426 FA FF FF      lea d, [bp + -1] ; $i
0027   0429 FD 43         mov [d], b
0028   042B             ;; printu(i); 
0029   042B FA FF FF      lea d, [bp + -1] ; $i
0030   042E 2A            mov b, [d]
0031   042F FD AB         swp b
0032   0431 D8            push b
0033   0432 07 99 0B      call printu
0034   0435 51 02 00      add sp, 2
0035   0438             ;; return 0; 
0036   0438 26 00 00      mov b, $0
0037   043B F9            leave
0038   043C 05 0B         syscall sys_terminate_proc
0039   043E             
0040   043E             strcpy:
0041   043E F8 00 00      enter 0 ; (push bp; mov bp, sp)
0042   0441             ; $psrc 
0043   0441             ; $pdest 
0044   0441 52 04 00      sub sp, 4
0045   0444             ;; psrc = src; 
0046   0444 FA FF FF      lea d, [bp + -1] ; $psrc
0047   0447 DA            push d
0048   0448 FA 05 00      lea d, [bp + 5] ; $src
0049   044B 2A            mov b, [d]
0050   044C E7            pop d
0051   044D FD 43         mov [d], b
0052   044F             ;; pdest = dest; 
0053   044F FA FD FF      lea d, [bp + -3] ; $pdest
0054   0452 DA            push d
0055   0453 FA 07 00      lea d, [bp + 7] ; $dest
0056   0456 2A            mov b, [d]
0057   0457 E7            pop d
0058   0458 FD 43         mov [d], b
0059   045A             ;; while(*psrc) *pdest++ = *psrc++; 
0060   045A             _while1_cond:
0061   045A FA FF FF      lea d, [bp + -1] ; $psrc
0062   045D 2A            mov b, [d]
0063   045E 74            mov d, b
0064   045F 32            mov bl, [d]
0065   0460 A7 00         mov bh, 0
0066   0462 C0 00 00      cmp b, 0
0067   0465 C6 91 04      je _while1_exit
0068   0468             _while1_block:
0069   0468             ;; *pdest++ = *psrc++; 
0070   0468 FA FD FF      lea d, [bp + -3] ; $pdest
0071   046B 2A            mov b, [d]
0072   046C FD 79         mov g, b
0073   046E FD 77         inc b
0074   0470 FA FD FF      lea d, [bp + -3] ; $pdest
0075   0473 FD 43         mov [d], b
0076   0475 FD 27         mov b, g
0077   0477 D8            push b
0078   0478 FA FF FF      lea d, [bp + -1] ; $psrc
0079   047B 2A            mov b, [d]
0080   047C FD 79         mov g, b
0081   047E FD 77         inc b
0082   0480 FA FF FF      lea d, [bp + -1] ; $psrc
0083   0483 FD 43         mov [d], b
0084   0485 FD 27         mov b, g
0085   0487 74            mov d, b
0086   0488 32            mov bl, [d]
0087   0489 A7 00         mov bh, 0
0088   048B E7            pop d
0089   048C FD 3E         mov [d], bl
0090   048E 0A 5A 04      jmp _while1_cond
0091   0491             _while1_exit:
0092   0491             ;; *pdest = '\0'; 
0093   0491 FA FD FF      lea d, [bp + -3] ; $pdest
0094   0494 2A            mov b, [d]
0095   0495 D8            push b
0096   0496 26 00 00      mov b, $0
0097   0499 E7            pop d
0098   049A FD 3E         mov [d], bl
0099   049C F9            leave
0100   049D 09            ret
0101   049E             
0102   049E             strcmp:
0103   049E F8 00 00      enter 0 ; (push bp; mov bp, sp)
0104   04A1             ;; while (*s1 && (*s1 == *s2)) { 
0105   04A1             _while2_cond:
0106   04A1 FA 07 00      lea d, [bp + 7] ; $s1
0107   04A4 2A            mov b, [d]
0108   04A5 74            mov d, b
0109   04A6 32            mov bl, [d]
0110   04A7 A7 00         mov bh, 0
0111   04A9 D7            push a
0112   04AA 11            mov a, b
0113   04AB FA 07 00      lea d, [bp + 7] ; $s1
0114   04AE 2A            mov b, [d]
0115   04AF 74            mov d, b
0116   04B0 32            mov bl, [d]
0117   04B1 A7 00         mov bh, 0
0118   04B3             ; START RELATIONAL
0119   04B3 D7            push a
0120   04B4 11            mov a, b
0121   04B5 FA 05 00      lea d, [bp + 5] ; $s2
0122   04B8 2A            mov b, [d]
0123   04B9 74            mov d, b
0124   04BA 32            mov bl, [d]
0125   04BB A7 00         mov bh, 0
0126   04BD B0            cmp a, b
0127   04BE FD 71         seq ; ==
0128   04C0 E4            pop a
0129   04C1             ; END RELATIONAL
0130   04C1 FD A7         sand a, b ; &&
0131   04C3 E4            pop a
0132   04C4 C0 00 00      cmp b, 0
0133   04C7 C6 EB 04      je _while2_exit
0134   04CA             _while2_block:
0135   04CA             ;; s1++; 
0136   04CA FA 07 00      lea d, [bp + 7] ; $s1
0137   04CD 2A            mov b, [d]
0138   04CE FD 79         mov g, b
0139   04D0 FD 77         inc b
0140   04D2 FA 07 00      lea d, [bp + 7] ; $s1
0141   04D5 FD 43         mov [d], b
0142   04D7 FD 27         mov b, g
0143   04D9             ;; s2++; 
0144   04D9 FA 05 00      lea d, [bp + 5] ; $s2
0145   04DC 2A            mov b, [d]
0146   04DD FD 79         mov g, b
0147   04DF FD 77         inc b
0148   04E1 FA 05 00      lea d, [bp + 5] ; $s2
0149   04E4 FD 43         mov [d], b
0150   04E6 FD 27         mov b, g
0151   04E8 0A A1 04      jmp _while2_cond
0152   04EB             _while2_exit:
0153   04EB             ;; return *s1 - *s2; 
0154   04EB FA 07 00      lea d, [bp + 7] ; $s1
0155   04EE 2A            mov b, [d]
0156   04EF 74            mov d, b
0157   04F0 32            mov bl, [d]
0158   04F1 A7 00         mov bh, 0
0159   04F3             ; START TERMS
0160   04F3 D7            push a
0161   04F4 11            mov a, b
0162   04F5 FA 05 00      lea d, [bp + 5] ; $s2
0163   04F8 2A            mov b, [d]
0164   04F9 74            mov d, b
0165   04FA 32            mov bl, [d]
0166   04FB A7 00         mov bh, 0
0167   04FD 60            sub a, b
0168   04FE 27            mov b, a
0169   04FF E4            pop a
0170   0500             ; END TERMS
0171   0500 F9            leave
0172   0501 09            ret
0173   0502             
0174   0502             strcat:
0175   0502 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0176   0505             ; $dest_len 
0177   0505             ; $i 
0178   0505 52 04 00      sub sp, 4
0179   0508             ;; dest_len = strlen(dest); 
0180   0508 FA FF FF      lea d, [bp + -1] ; $dest_len
0181   050B DA            push d
0182   050C FA 07 00      lea d, [bp + 7] ; $dest
0183   050F 2A            mov b, [d]
0184   0510 FD AB         swp b
0185   0512 D8            push b
0186   0513 07 B8 05      call strlen
0187   0516 51 02 00      add sp, 2
0188   0519 E7            pop d
0189   051A FD 43         mov [d], b
0190   051C             ;; for (i = 0; src[i] != 0; i=i+1) { 
0191   051C             _for3_init:
0192   051C FA FD FF      lea d, [bp + -3] ; $i
0193   051F DA            push d
0194   0520 26 00 00      mov b, $0
0195   0523 E7            pop d
0196   0524 FD 43         mov [d], b
0197   0526             _for3_cond:
0198   0526 FA 05 00      lea d, [bp + 5] ; $src
0199   0529 FD 2A         mov d, [d]
0200   052B D7            push a
0201   052C DA            push d
0202   052D FA FD FF      lea d, [bp + -3] ; $i
0203   0530 2A            mov b, [d]
0204   0531 E7            pop d
0205   0532 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0206   0536 E4            pop a
0207   0537 32            mov bl, [d]
0208   0538 A7 00         mov bh, 0
0209   053A             ; START RELATIONAL
0210   053A D7            push a
0211   053B 11            mov a, b
0212   053C 26 00 00      mov b, $0
0213   053F B0            cmp a, b
0214   0540 FD 72         sneq ; !=
0215   0542 E4            pop a
0216   0543             ; END RELATIONAL
0217   0543 C0 00 00      cmp b, 0
0218   0546 C6 91 05      je _for3_exit
0219   0549             _for3_block:
0220   0549             ;; dest[dest_len + i] = src[i]; 
0221   0549 FA 07 00      lea d, [bp + 7] ; $dest
0222   054C FD 2A         mov d, [d]
0223   054E D7            push a
0224   054F DA            push d
0225   0550 FA FF FF      lea d, [bp + -1] ; $dest_len
0226   0553 2A            mov b, [d]
0227   0554             ; START TERMS
0228   0554 D7            push a
0229   0555 11            mov a, b
0230   0556 FA FD FF      lea d, [bp + -3] ; $i
0231   0559 2A            mov b, [d]
0232   055A 54            add a, b
0233   055B 27            mov b, a
0234   055C E4            pop a
0235   055D             ; END TERMS
0236   055D E7            pop d
0237   055E FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0238   0562 E4            pop a
0239   0563 DA            push d
0240   0564 FA 05 00      lea d, [bp + 5] ; $src
0241   0567 FD 2A         mov d, [d]
0242   0569 D7            push a
0243   056A DA            push d
0244   056B FA FD FF      lea d, [bp + -3] ; $i
0245   056E 2A            mov b, [d]
0246   056F E7            pop d
0247   0570 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0248   0574 E4            pop a
0249   0575 32            mov bl, [d]
0250   0576 A7 00         mov bh, 0
0251   0578 E7            pop d
0252   0579 FD 3E         mov [d], bl
0253   057B             _for3_update:
0254   057B FA FD FF      lea d, [bp + -3] ; $i
0255   057E DA            push d
0256   057F FA FD FF      lea d, [bp + -3] ; $i
0257   0582 2A            mov b, [d]
0258   0583             ; START TERMS
0259   0583 D7            push a
0260   0584 11            mov a, b
0261   0585 26 01 00      mov b, $1
0262   0588 54            add a, b
0263   0589 27            mov b, a
0264   058A E4            pop a
0265   058B             ; END TERMS
0266   058B E7            pop d
0267   058C FD 43         mov [d], b
0268   058E 0A 26 05      jmp _for3_cond
0269   0591             _for3_exit:
0270   0591             ;; dest[dest_len + i] = 0; 
0271   0591 FA 07 00      lea d, [bp + 7] ; $dest
0272   0594 FD 2A         mov d, [d]
0273   0596 D7            push a
0274   0597 DA            push d
0275   0598 FA FF FF      lea d, [bp + -1] ; $dest_len
0276   059B 2A            mov b, [d]
0277   059C             ; START TERMS
0278   059C D7            push a
0279   059D 11            mov a, b
0280   059E FA FD FF      lea d, [bp + -3] ; $i
0281   05A1 2A            mov b, [d]
0282   05A2 54            add a, b
0283   05A3 27            mov b, a
0284   05A4 E4            pop a
0285   05A5             ; END TERMS
0286   05A5 E7            pop d
0287   05A6 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0288   05AA E4            pop a
0289   05AB DA            push d
0290   05AC 26 00 00      mov b, $0
0291   05AF E7            pop d
0292   05B0 FD 3E         mov [d], bl
0293   05B2             ;; return dest; 
0294   05B2 FA 07 00      lea d, [bp + 7] ; $dest
0295   05B5 2A            mov b, [d]
0296   05B6 F9            leave
0297   05B7 09            ret
0298   05B8             
0299   05B8             strlen:
0300   05B8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0301   05BB             ; $length 
0302   05BB 52 02 00      sub sp, 2
0303   05BE             ;; length = 0; 
0304   05BE FA FF FF      lea d, [bp + -1] ; $length
0305   05C1 DA            push d
0306   05C2 26 00 00      mov b, $0
0307   05C5 E7            pop d
0308   05C6 FD 43         mov [d], b
0309   05C8             ;; while (str[length] != 0) { 
0310   05C8             _while4_cond:
0311   05C8 FA 05 00      lea d, [bp + 5] ; $str
0312   05CB FD 2A         mov d, [d]
0313   05CD D7            push a
0314   05CE DA            push d
0315   05CF FA FF FF      lea d, [bp + -1] ; $length
0316   05D2 2A            mov b, [d]
0317   05D3 E7            pop d
0318   05D4 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0319   05D8 E4            pop a
0320   05D9 32            mov bl, [d]
0321   05DA A7 00         mov bh, 0
0322   05DC             ; START RELATIONAL
0323   05DC D7            push a
0324   05DD 11            mov a, b
0325   05DE 26 00 00      mov b, $0
0326   05E1 B0            cmp a, b
0327   05E2 FD 72         sneq ; !=
0328   05E4 E4            pop a
0329   05E5             ; END RELATIONAL
0330   05E5 C0 00 00      cmp b, 0
0331   05E8 C6 FD 05      je _while4_exit
0332   05EB             _while4_block:
0333   05EB             ;; length++; 
0334   05EB FA FF FF      lea d, [bp + -1] ; $length
0335   05EE 2A            mov b, [d]
0336   05EF FD 79         mov g, b
0337   05F1 FD 77         inc b
0338   05F3 FA FF FF      lea d, [bp + -1] ; $length
0339   05F6 FD 43         mov [d], b
0340   05F8 FD 27         mov b, g
0341   05FA 0A C8 05      jmp _while4_cond
0342   05FD             _while4_exit:
0343   05FD             ;; return length; 
0344   05FD FA FF FF      lea d, [bp + -1] ; $length
0345   0600 2A            mov b, [d]
0346   0601 F9            leave
0347   0602 09            ret
0348   0603             
0349   0603             va_arg:
0350   0603 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0351   0606             ; $val 
0352   0606 52 02 00      sub sp, 2
0353   0609             ;; if(size == 1){ 
0354   0609             _if5_cond:
0355   0609 FA 05 00      lea d, [bp + 5] ; $size
0356   060C 2A            mov b, [d]
0357   060D             ; START RELATIONAL
0358   060D D7            push a
0359   060E 11            mov a, b
0360   060F 26 01 00      mov b, $1
0361   0612 B0            cmp a, b
0362   0613 FD 71         seq ; ==
0363   0615 E4            pop a
0364   0616             ; END RELATIONAL
0365   0616 C0 00 00      cmp b, 0
0366   0619 C6 35 06      je _if5_else
0367   061C             _if5_true:
0368   061C             ;; val = *(char*)arg->p; 
0369   061C FA FF FF      lea d, [bp + -1] ; $val
0370   061F DA            push d
0371   0620 FA 07 00      lea d, [bp + 7] ; $arg
0372   0623 FD 2A         mov d, [d]
0373   0625 58 00 00      add d, 0
0374   0628 FD 14         clb
0375   062A 2A            mov b, [d]
0376   062B 74            mov d, b
0377   062C 32            mov bl, [d]
0378   062D A7 00         mov bh, 0
0379   062F E7            pop d
0380   0630 FD 43         mov [d], b
0381   0632 0A 6B 06      jmp _if5_exit
0382   0635             _if5_else:
0383   0635             ;; if(size == 2){ 
0384   0635             _if6_cond:
0385   0635 FA 05 00      lea d, [bp + 5] ; $size
0386   0638 2A            mov b, [d]
0387   0639             ; START RELATIONAL
0388   0639 D7            push a
0389   063A 11            mov a, b
0390   063B 26 02 00      mov b, $2
0391   063E B0            cmp a, b
0392   063F FD 71         seq ; ==
0393   0641 E4            pop a
0394   0642             ; END RELATIONAL
0395   0642 C0 00 00      cmp b, 0
0396   0645 C6 5F 06      je _if6_else
0397   0648             _if6_true:
0398   0648             ;; val = *(int*)arg->p; 
0399   0648 FA FF FF      lea d, [bp + -1] ; $val
0400   064B DA            push d
0401   064C FA 07 00      lea d, [bp + 7] ; $arg
0402   064F FD 2A         mov d, [d]
0403   0651 58 00 00      add d, 0
0404   0654 FD 14         clb
0405   0656 2A            mov b, [d]
0406   0657 74            mov d, b
0407   0658 2A            mov b, [d]
0408   0659 E7            pop d
0409   065A FD 43         mov [d], b
0410   065C 0A 6B 06      jmp _if6_exit
0411   065F             _if6_else:
0412   065F             ;; print("Unknown type size in va_arg() call. Size needs to be either 1 or 2."); 
0413   065F 26 9A 12      mov b, __s0 ; "Unknown type size in va_arg() call. Size needs to be either 1 or 2."
0414   0662 FD AB         swp b
0415   0664 D8            push b
0416   0665 07 CD 0C      call print
0417   0668 51 02 00      add sp, 2
0418   066B             _if6_exit:
0419   066B             _if5_exit:
0420   066B             ;; arg->p = arg->p + size; 
0421   066B FA 07 00      lea d, [bp + 7] ; $arg
0422   066E FD 2A         mov d, [d]
0423   0670 58 00 00      add d, 0
0424   0673 FD 14         clb
0425   0675 DA            push d
0426   0676 FA 07 00      lea d, [bp + 7] ; $arg
0427   0679 FD 2A         mov d, [d]
0428   067B 58 00 00      add d, 0
0429   067E FD 14         clb
0430   0680 2A            mov b, [d]
0431   0681             ; START TERMS
0432   0681 D7            push a
0433   0682 11            mov a, b
0434   0683 FA 05 00      lea d, [bp + 5] ; $size
0435   0686 2A            mov b, [d]
0436   0687 54            add a, b
0437   0688 27            mov b, a
0438   0689 E4            pop a
0439   068A             ; END TERMS
0440   068A E7            pop d
0441   068B FD 43         mov [d], b
0442   068D             ;; return val; 
0443   068D FA FF FF      lea d, [bp + -1] ; $val
0444   0690 2A            mov b, [d]
0445   0691 F9            leave
0446   0692 09            ret
0447   0693             
0448   0693             printf:
0449   0693 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0450   0696             ; $p 
0451   0696             ; $fp 
0452   0696             ; $i 
0453   0696 52 06 00      sub sp, 6
0454   0699             ;; fp = format; 
0455   0699 FA FD FF      lea d, [bp + -3] ; $fp
0456   069C DA            push d
0457   069D FA 05 00      lea d, [bp + 5] ; $format
0458   06A0 2A            mov b, [d]
0459   06A1 E7            pop d
0460   06A2 FD 43         mov [d], b
0461   06A4             ;; p = &format; 
0462   06A4 FA FF FF      lea d, [bp + -1] ; $p
0463   06A7 DA            push d
0464   06A8 FA 05 00      lea d, [bp + 5] ; $format
0465   06AB 2D            mov b, d
0466   06AC E7            pop d
0467   06AD FD 43         mov [d], b
0468   06AF             ;; for(;;){ 
0469   06AF             _for7_init:
0470   06AF             _for7_cond:
0471   06AF             _for7_block:
0472   06AF             ;; if(!*fp) break; 
0473   06AF             _if8_cond:
0474   06AF FA FD FF      lea d, [bp + -3] ; $fp
0475   06B2 2A            mov b, [d]
0476   06B3 74            mov d, b
0477   06B4 32            mov bl, [d]
0478   06B5 A7 00         mov bh, 0
0479   06B7 C0 00 00      cmp b, 0
0480   06BA FD 71         seq ; !
0481   06BC C0 00 00      cmp b, 0
0482   06BF C6 C8 06      je _if8_exit
0483   06C2             _if8_true:
0484   06C2             ;; break; 
0485   06C2 0A 12 08      jmp _for7_exit ; for break
0486   06C5 0A C8 06      jmp _if8_exit
0487   06C8             _if8_exit:
0488   06C8             ;; if(*fp == '%'){ 
0489   06C8             _if9_cond:
0490   06C8 FA FD FF      lea d, [bp + -3] ; $fp
0491   06CB 2A            mov b, [d]
0492   06CC 74            mov d, b
0493   06CD 32            mov bl, [d]
0494   06CE A7 00         mov bh, 0
0495   06D0             ; START RELATIONAL
0496   06D0 D7            push a
0497   06D1 11            mov a, b
0498   06D2 26 25 00      mov b, $25
0499   06D5 B0            cmp a, b
0500   06D6 FD 71         seq ; ==
0501   06D8 E4            pop a
0502   06D9             ; END RELATIONAL
0503   06D9 C0 00 00      cmp b, 0
0504   06DC C6 F1 07      je _if9_else
0505   06DF             _if9_true:
0506   06DF             ;; fp++; 
0507   06DF FA FD FF      lea d, [bp + -3] ; $fp
0508   06E2 2A            mov b, [d]
0509   06E3 FD 79         mov g, b
0510   06E5 FD 77         inc b
0511   06E7 FA FD FF      lea d, [bp + -3] ; $fp
0512   06EA FD 43         mov [d], b
0513   06EC FD 27         mov b, g
0514   06EE             ;; switch(*fp){ 
0515   06EE             _switch10_expr:
0516   06EE FA FD FF      lea d, [bp + -3] ; $fp
0517   06F1 2A            mov b, [d]
0518   06F2 74            mov d, b
0519   06F3 32            mov bl, [d]
0520   06F4 A7 00         mov bh, 0
0521   06F6             _switch10_comparisons:
0522   06F6 C1 64         cmp bl, $64
0523   06F8 C6 1A 07      je _switch10_case0
0524   06FB C1 69         cmp bl, $69
0525   06FD C6 1A 07      je _switch10_case1
0526   0700 C1 75         cmp bl, $75
0527   0702 C6 3F 07      je _switch10_case2
0528   0705 C1 78         cmp bl, $78
0529   0707 C6 64 07      je _switch10_case3
0530   070A C1 63         cmp bl, $63
0531   070C C6 89 07      je _switch10_case4
0532   070F C1 73         cmp bl, $73
0533   0711 C6 AE 07      je _switch10_case5
0534   0714 0A D3 07      jmp _switch10_default
0535   0717 0A DF 07      jmp _switch10_exit
0536   071A             _switch10_case0:
0537   071A             _switch10_case1:
0538   071A             ;; p = p - 2; 
0539   071A FA FF FF      lea d, [bp + -1] ; $p
0540   071D DA            push d
0541   071E FA FF FF      lea d, [bp + -1] ; $p
0542   0721 2A            mov b, [d]
0543   0722             ; START TERMS
0544   0722 D7            push a
0545   0723 11            mov a, b
0546   0724 26 02 00      mov b, $2
0547   0727 60            sub a, b
0548   0728 27            mov b, a
0549   0729 E4            pop a
0550   072A             ; END TERMS
0551   072A E7            pop d
0552   072B FD 43         mov [d], b
0553   072D             ;; prints(*(int*)p); 
0554   072D FA FF FF      lea d, [bp + -1] ; $p
0555   0730 2A            mov b, [d]
0556   0731 74            mov d, b
0557   0732 2A            mov b, [d]
0558   0733 FD AB         swp b
0559   0735 D8            push b
0560   0736 07 A4 0A      call prints
0561   0739 51 02 00      add sp, 2
0562   073C             ;; break; 
0563   073C 0A DF 07      jmp _switch10_exit ; case break
0564   073F             _switch10_case2:
0565   073F             ;; p = p - 2; 
0566   073F FA FF FF      lea d, [bp + -1] ; $p
0567   0742 DA            push d
0568   0743 FA FF FF      lea d, [bp + -1] ; $p
0569   0746 2A            mov b, [d]
0570   0747             ; START TERMS
0571   0747 D7            push a
0572   0748 11            mov a, b
0573   0749 26 02 00      mov b, $2
0574   074C 60            sub a, b
0575   074D 27            mov b, a
0576   074E E4            pop a
0577   074F             ; END TERMS
0578   074F E7            pop d
0579   0750 FD 43         mov [d], b
0580   0752             ;; printu(*(unsigned int*)p); 
0581   0752 FA FF FF      lea d, [bp + -1] ; $p
0582   0755 2A            mov b, [d]
0583   0756 74            mov d, b
0584   0757 2A            mov b, [d]
0585   0758 FD AB         swp b
0586   075A D8            push b
0587   075B 07 99 0B      call printu
0588   075E 51 02 00      add sp, 2
0589   0761             ;; break; 
0590   0761 0A DF 07      jmp _switch10_exit ; case break
0591   0764             _switch10_case3:
0592   0764             ;; p = p - 2; 
0593   0764 FA FF FF      lea d, [bp + -1] ; $p
0594   0767 DA            push d
0595   0768 FA FF FF      lea d, [bp + -1] ; $p
0596   076B 2A            mov b, [d]
0597   076C             ; START TERMS
0598   076C D7            push a
0599   076D 11            mov a, b
0600   076E 26 02 00      mov b, $2
0601   0771 60            sub a, b
0602   0772 27            mov b, a
0603   0773 E4            pop a
0604   0774             ; END TERMS
0605   0774 E7            pop d
0606   0775 FD 43         mov [d], b
0607   0777             ;; printx16(*(unsigned int*)p); 
0608   0777 FA FF FF      lea d, [bp + -1] ; $p
0609   077A 2A            mov b, [d]
0610   077B 74            mov d, b
0611   077C 2A            mov b, [d]
0612   077D FD AB         swp b
0613   077F D8            push b
0614   0780 07 14 08      call printx16
0615   0783 51 02 00      add sp, 2
0616   0786             ;; break; 
0617   0786 0A DF 07      jmp _switch10_exit ; case break
0618   0789             _switch10_case4:
0619   0789             ;; p = p - 2; 
0620   0789 FA FF FF      lea d, [bp + -1] ; $p
0621   078C DA            push d
0622   078D FA FF FF      lea d, [bp + -1] ; $p
0623   0790 2A            mov b, [d]
0624   0791             ; START TERMS
0625   0791 D7            push a
0626   0792 11            mov a, b
0627   0793 26 02 00      mov b, $2
0628   0796 60            sub a, b
0629   0797 27            mov b, a
0630   0798 E4            pop a
0631   0799             ; END TERMS
0632   0799 E7            pop d
0633   079A FD 43         mov [d], b
0634   079C             ;; putchar(*(char*)p); 
0635   079C FA FF FF      lea d, [bp + -1] ; $p
0636   079F 2A            mov b, [d]
0637   07A0 74            mov d, b
0638   07A1 32            mov bl, [d]
0639   07A2 A7 00         mov bh, 0
0640   07A4 DD            push bl
0641   07A5 07 85 0C      call putchar
0642   07A8 51 01 00      add sp, 1
0643   07AB             ;; break; 
0644   07AB 0A DF 07      jmp _switch10_exit ; case break
0645   07AE             _switch10_case5:
0646   07AE             ;; p = p - 2; 
0647   07AE FA FF FF      lea d, [bp + -1] ; $p
0648   07B1 DA            push d
0649   07B2 FA FF FF      lea d, [bp + -1] ; $p
0650   07B5 2A            mov b, [d]
0651   07B6             ; START TERMS
0652   07B6 D7            push a
0653   07B7 11            mov a, b
0654   07B8 26 02 00      mov b, $2
0655   07BB 60            sub a, b
0656   07BC 27            mov b, a
0657   07BD E4            pop a
0658   07BE             ; END TERMS
0659   07BE E7            pop d
0660   07BF FD 43         mov [d], b
0661   07C1             ;; print(*(char**)p); 
0662   07C1 FA FF FF      lea d, [bp + -1] ; $p
0663   07C4 2A            mov b, [d]
0664   07C5 74            mov d, b
0665   07C6 2A            mov b, [d]
0666   07C7 FD AB         swp b
0667   07C9 D8            push b
0668   07CA 07 CD 0C      call print
0669   07CD 51 02 00      add sp, 2
0670   07D0             ;; break; 
0671   07D0 0A DF 07      jmp _switch10_exit ; case break
0672   07D3             _switch10_default:
0673   07D3             ;; print("Error: Unknown argument type.\n"); 
0674   07D3 26 DE 12      mov b, __s1 ; "Error: Unknown argument type.\n"
0675   07D6 FD AB         swp b
0676   07D8 D8            push b
0677   07D9 07 CD 0C      call print
0678   07DC 51 02 00      add sp, 2
0679   07DF             _switch10_exit:
0680   07DF             ;; fp++; 
0681   07DF FA FD FF      lea d, [bp + -3] ; $fp
0682   07E2 2A            mov b, [d]
0683   07E3 FD 79         mov g, b
0684   07E5 FD 77         inc b
0685   07E7 FA FD FF      lea d, [bp + -3] ; $fp
0686   07EA FD 43         mov [d], b
0687   07EC FD 27         mov b, g
0688   07EE 0A 0F 08      jmp _if9_exit
0689   07F1             _if9_else:
0690   07F1             ;; putchar(*fp); 
0691   07F1 FA FD FF      lea d, [bp + -3] ; $fp
0692   07F4 2A            mov b, [d]
0693   07F5 74            mov d, b
0694   07F6 32            mov bl, [d]
0695   07F7 A7 00         mov bh, 0
0696   07F9 DD            push bl
0697   07FA 07 85 0C      call putchar
0698   07FD 51 01 00      add sp, 1
0699   0800             ;; fp++; 
0700   0800 FA FD FF      lea d, [bp + -3] ; $fp
0701   0803 2A            mov b, [d]
0702   0804 FD 79         mov g, b
0703   0806 FD 77         inc b
0704   0808 FA FD FF      lea d, [bp + -3] ; $fp
0705   080B FD 43         mov [d], b
0706   080D FD 27         mov b, g
0707   080F             _if9_exit:
0708   080F             _for7_update:
0709   080F 0A AF 06      jmp _for7_cond
0710   0812             _for7_exit:
0711   0812 F9            leave
0712   0813 09            ret
0713   0814             
0714   0814             printx16:
0715   0814 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0716   0817             
0717   0817             ; --- BEGIN INLINE ASM BLOCK
0718   0817 FA 05 00      lea d, [bp + 5] ; $hex
0719   081A 2A            mov b, [d]
0720   081B 07 A4 10      call print_u16x
0721   081E             ; --- END INLINE ASM BLOCK
0722   081E             
0723   081E F9            leave
0724   081F 09            ret
0725   0820             
0726   0820             printx8:
0727   0820 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0728   0823             
0729   0823             ; --- BEGIN INLINE ASM BLOCK
0730   0823 FA 05 00      lea d, [bp + 5] ; $hex
0731   0826 32            mov bl, [d]
0732   0827 07 E8 10      call print_u8x
0733   082A             ; --- END INLINE ASM BLOCK
0734   082A             
0735   082A F9            leave
0736   082B 09            ret
0737   082C             
0738   082C             hex_to_int:
0739   082C F8 00 00      enter 0 ; (push bp; mov bp, sp)
0740   082F             ; $value 
0741   082F 10 00 00      mov a, $0
0742   0832 45 FF FF      mov [bp + -1], a
0743   0835             ; $i 
0744   0835             ; $hex_char 
0745   0835             ; $len 
0746   0835 52 07 00      sub sp, 7
0747   0838             ;; len = strlen(hex_string); 
0748   0838 FA FA FF      lea d, [bp + -6] ; $len
0749   083B DA            push d
0750   083C FA 05 00      lea d, [bp + 5] ; $hex_string
0751   083F 2A            mov b, [d]
0752   0840 FD AB         swp b
0753   0842 D8            push b
0754   0843 07 B8 05      call strlen
0755   0846 51 02 00      add sp, 2
0756   0849 E7            pop d
0757   084A FD 43         mov [d], b
0758   084C             ;; for (i = 0; i < len; i++) { 
0759   084C             _for11_init:
0760   084C FA FD FF      lea d, [bp + -3] ; $i
0761   084F DA            push d
0762   0850 26 00 00      mov b, $0
0763   0853 E7            pop d
0764   0854 FD 43         mov [d], b
0765   0856             _for11_cond:
0766   0856 FA FD FF      lea d, [bp + -3] ; $i
0767   0859 2A            mov b, [d]
0768   085A             ; START RELATIONAL
0769   085A D7            push a
0770   085B 11            mov a, b
0771   085C FA FA FF      lea d, [bp + -6] ; $len
0772   085F 2A            mov b, [d]
0773   0860 B0            cmp a, b
0774   0861 FD 73         slt ; < 
0775   0863 E4            pop a
0776   0864             ; END RELATIONAL
0777   0864 C0 00 00      cmp b, 0
0778   0867 C6 6C 09      je _for11_exit
0779   086A             _for11_block:
0780   086A             ;; hex_char = hex_string[i]; 
0781   086A FA FC FF      lea d, [bp + -4] ; $hex_char
0782   086D DA            push d
0783   086E FA 05 00      lea d, [bp + 5] ; $hex_string
0784   0871 FD 2A         mov d, [d]
0785   0873 D7            push a
0786   0874 DA            push d
0787   0875 FA FD FF      lea d, [bp + -3] ; $i
0788   0878 2A            mov b, [d]
0789   0879 E7            pop d
0790   087A FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0791   087E E4            pop a
0792   087F 32            mov bl, [d]
0793   0880 A7 00         mov bh, 0
0794   0882 E7            pop d
0795   0883 FD 3E         mov [d], bl
0796   0885             ;; if (hex_char >= 'a' && hex_char <= 'f')  
0797   0885             _if12_cond:
0798   0885 FA FC FF      lea d, [bp + -4] ; $hex_char
0799   0888 32            mov bl, [d]
0800   0889 A7 00         mov bh, 0
0801   088B             ; START RELATIONAL
0802   088B D7            push a
0803   088C 11            mov a, b
0804   088D 26 61 00      mov b, $61
0805   0890 B0            cmp a, b
0806   0891 FD 80         sge ; >=
0807   0893 E4            pop a
0808   0894             ; END RELATIONAL
0809   0894 D7            push a
0810   0895 11            mov a, b
0811   0896 FA FC FF      lea d, [bp + -4] ; $hex_char
0812   0899 32            mov bl, [d]
0813   089A A7 00         mov bh, 0
0814   089C             ; START RELATIONAL
0815   089C D7            push a
0816   089D 11            mov a, b
0817   089E 26 66 00      mov b, $66
0818   08A1 B0            cmp a, b
0819   08A2 FD 74         sle ; <=
0820   08A4 E4            pop a
0821   08A5             ; END RELATIONAL
0822   08A5 FD A7         sand a, b ; &&
0823   08A7 E4            pop a
0824   08A8 C0 00 00      cmp b, 0
0825   08AB C6 DC 08      je _if12_else
0826   08AE             _if12_true:
0827   08AE             ;; value = (value * 16) + (hex_char - 'a' + 10); 
0828   08AE FA FF FF      lea d, [bp + -1] ; $value
0829   08B1 DA            push d
0830   08B2 FA FF FF      lea d, [bp + -1] ; $value
0831   08B5 2A            mov b, [d]
0832   08B6             ; START FACTORS
0833   08B6 D7            push a
0834   08B7 11            mov a, b
0835   08B8 26 10 00      mov b, $10
0836   08BB AC            mul a, b ; *
0837   08BC 11            mov a, b
0838   08BD 27            mov b, a
0839   08BE E4            pop a
0840   08BF             ; END FACTORS
0841   08BF             ; START TERMS
0842   08BF D7            push a
0843   08C0 11            mov a, b
0844   08C1 FA FC FF      lea d, [bp + -4] ; $hex_char
0845   08C4 32            mov bl, [d]
0846   08C5 A7 00         mov bh, 0
0847   08C7             ; START TERMS
0848   08C7 D7            push a
0849   08C8 11            mov a, b
0850   08C9 26 61 00      mov b, $61
0851   08CC 60            sub a, b
0852   08CD 26 0A 00      mov b, $a
0853   08D0 54            add a, b
0854   08D1 27            mov b, a
0855   08D2 E4            pop a
0856   08D3             ; END TERMS
0857   08D3 54            add a, b
0858   08D4 27            mov b, a
0859   08D5 E4            pop a
0860   08D6             ; END TERMS
0861   08D6 E7            pop d
0862   08D7 FD 43         mov [d], b
0863   08D9 0A 5A 09      jmp _if12_exit
0864   08DC             _if12_else:
0865   08DC             ;; if (hex_char >= 'A' && hex_char <= 'F')  
0866   08DC             _if13_cond:
0867   08DC FA FC FF      lea d, [bp + -4] ; $hex_char
0868   08DF 32            mov bl, [d]
0869   08E0 A7 00         mov bh, 0
0870   08E2             ; START RELATIONAL
0871   08E2 D7            push a
0872   08E3 11            mov a, b
0873   08E4 26 41 00      mov b, $41
0874   08E7 B0            cmp a, b
0875   08E8 FD 80         sge ; >=
0876   08EA E4            pop a
0877   08EB             ; END RELATIONAL
0878   08EB D7            push a
0879   08EC 11            mov a, b
0880   08ED FA FC FF      lea d, [bp + -4] ; $hex_char
0881   08F0 32            mov bl, [d]
0882   08F1 A7 00         mov bh, 0
0883   08F3             ; START RELATIONAL
0884   08F3 D7            push a
0885   08F4 11            mov a, b
0886   08F5 26 46 00      mov b, $46
0887   08F8 B0            cmp a, b
0888   08F9 FD 74         sle ; <=
0889   08FB E4            pop a
0890   08FC             ; END RELATIONAL
0891   08FC FD A7         sand a, b ; &&
0892   08FE E4            pop a
0893   08FF C0 00 00      cmp b, 0
0894   0902 C6 33 09      je _if13_else
0895   0905             _if13_true:
0896   0905             ;; value = (value * 16) + (hex_char - 'A' + 10); 
0897   0905 FA FF FF      lea d, [bp + -1] ; $value
0898   0908 DA            push d
0899   0909 FA FF FF      lea d, [bp + -1] ; $value
0900   090C 2A            mov b, [d]
0901   090D             ; START FACTORS
0902   090D D7            push a
0903   090E 11            mov a, b
0904   090F 26 10 00      mov b, $10
0905   0912 AC            mul a, b ; *
0906   0913 11            mov a, b
0907   0914 27            mov b, a
0908   0915 E4            pop a
0909   0916             ; END FACTORS
0910   0916             ; START TERMS
0911   0916 D7            push a
0912   0917 11            mov a, b
0913   0918 FA FC FF      lea d, [bp + -4] ; $hex_char
0914   091B 32            mov bl, [d]
0915   091C A7 00         mov bh, 0
0916   091E             ; START TERMS
0917   091E D7            push a
0918   091F 11            mov a, b
0919   0920 26 41 00      mov b, $41
0920   0923 60            sub a, b
0921   0924 26 0A 00      mov b, $a
0922   0927 54            add a, b
0923   0928 27            mov b, a
0924   0929 E4            pop a
0925   092A             ; END TERMS
0926   092A 54            add a, b
0927   092B 27            mov b, a
0928   092C E4            pop a
0929   092D             ; END TERMS
0930   092D E7            pop d
0931   092E FD 43         mov [d], b
0932   0930 0A 5A 09      jmp _if13_exit
0933   0933             _if13_else:
0934   0933             ;; value = (value * 16) + (hex_char - '0'); 
0935   0933 FA FF FF      lea d, [bp + -1] ; $value
0936   0936 DA            push d
0937   0937 FA FF FF      lea d, [bp + -1] ; $value
0938   093A 2A            mov b, [d]
0939   093B             ; START FACTORS
0940   093B D7            push a
0941   093C 11            mov a, b
0942   093D 26 10 00      mov b, $10
0943   0940 AC            mul a, b ; *
0944   0941 11            mov a, b
0945   0942 27            mov b, a
0946   0943 E4            pop a
0947   0944             ; END FACTORS
0948   0944             ; START TERMS
0949   0944 D7            push a
0950   0945 11            mov a, b
0951   0946 FA FC FF      lea d, [bp + -4] ; $hex_char
0952   0949 32            mov bl, [d]
0953   094A A7 00         mov bh, 0
0954   094C             ; START TERMS
0955   094C D7            push a
0956   094D 11            mov a, b
0957   094E 26 30 00      mov b, $30
0958   0951 60            sub a, b
0959   0952 27            mov b, a
0960   0953 E4            pop a
0961   0954             ; END TERMS
0962   0954 54            add a, b
0963   0955 27            mov b, a
0964   0956 E4            pop a
0965   0957             ; END TERMS
0966   0957 E7            pop d
0967   0958 FD 43         mov [d], b
0968   095A             _if13_exit:
0969   095A             _if12_exit:
0970   095A             _for11_update:
0971   095A FA FD FF      lea d, [bp + -3] ; $i
0972   095D 2A            mov b, [d]
0973   095E FD 79         mov g, b
0974   0960 FD 77         inc b
0975   0962 FA FD FF      lea d, [bp + -3] ; $i
0976   0965 FD 43         mov [d], b
0977   0967 FD 27         mov b, g
0978   0969 0A 56 08      jmp _for11_cond
0979   096C             _for11_exit:
0980   096C             ;; return value; 
0981   096C FA FF FF      lea d, [bp + -1] ; $value
0982   096F 2A            mov b, [d]
0983   0970 F9            leave
0984   0971 09            ret
0985   0972             
0986   0972             atoi:
0987   0972 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0988   0975             ; $result 
0989   0975 10 00 00      mov a, $0
0990   0978 45 FF FF      mov [bp + -1], a
0991   097B             ; $sign 
0992   097B 10 01 00      mov a, $1
0993   097E 45 FD FF      mov [bp + -3], a
0994   0981 52 04 00      sub sp, 4
0995   0984             ;; while (*str == ' ') str++; 
0996   0984             _while14_cond:
0997   0984 FA 05 00      lea d, [bp + 5] ; $str
0998   0987 2A            mov b, [d]
0999   0988 74            mov d, b
1000   0989 32            mov bl, [d]
1001   098A A7 00         mov bh, 0
1002   098C             ; START RELATIONAL
1003   098C D7            push a
1004   098D 11            mov a, b
1005   098E 26 20 00      mov b, $20
1006   0991 B0            cmp a, b
1007   0992 FD 71         seq ; ==
1008   0994 E4            pop a
1009   0995             ; END RELATIONAL
1010   0995 C0 00 00      cmp b, 0
1011   0998 C6 AD 09      je _while14_exit
1012   099B             _while14_block:
1013   099B             ;; str++; 
1014   099B FA 05 00      lea d, [bp + 5] ; $str
1015   099E 2A            mov b, [d]
1016   099F FD 79         mov g, b
1017   09A1 FD 77         inc b
1018   09A3 FA 05 00      lea d, [bp + 5] ; $str
1019   09A6 FD 43         mov [d], b
1020   09A8 FD 27         mov b, g
1021   09AA 0A 84 09      jmp _while14_cond
1022   09AD             _while14_exit:
1023   09AD             ;; if (*str == '-' || *str == '+') { 
1024   09AD             _if15_cond:
1025   09AD FA 05 00      lea d, [bp + 5] ; $str
1026   09B0 2A            mov b, [d]
1027   09B1 74            mov d, b
1028   09B2 32            mov bl, [d]
1029   09B3 A7 00         mov bh, 0
1030   09B5             ; START RELATIONAL
1031   09B5 D7            push a
1032   09B6 11            mov a, b
1033   09B7 26 2D 00      mov b, $2d
1034   09BA B0            cmp a, b
1035   09BB FD 71         seq ; ==
1036   09BD E4            pop a
1037   09BE             ; END RELATIONAL
1038   09BE D7            push a
1039   09BF 11            mov a, b
1040   09C0 FA 05 00      lea d, [bp + 5] ; $str
1041   09C3 2A            mov b, [d]
1042   09C4 74            mov d, b
1043   09C5 32            mov bl, [d]
1044   09C6 A7 00         mov bh, 0
1045   09C8             ; START RELATIONAL
1046   09C8 D7            push a
1047   09C9 11            mov a, b
1048   09CA 26 2B 00      mov b, $2b
1049   09CD B0            cmp a, b
1050   09CE FD 71         seq ; ==
1051   09D0 E4            pop a
1052   09D1             ; END RELATIONAL
1053   09D1 FD A8         sor a, b ; ||
1054   09D3 E4            pop a
1055   09D4 C0 00 00      cmp b, 0
1056   09D7 C6 12 0A      je _if15_exit
1057   09DA             _if15_true:
1058   09DA             ;; if (*str == '-') sign = -1; 
1059   09DA             _if16_cond:
1060   09DA FA 05 00      lea d, [bp + 5] ; $str
1061   09DD 2A            mov b, [d]
1062   09DE 74            mov d, b
1063   09DF 32            mov bl, [d]
1064   09E0 A7 00         mov bh, 0
1065   09E2             ; START RELATIONAL
1066   09E2 D7            push a
1067   09E3 11            mov a, b
1068   09E4 26 2D 00      mov b, $2d
1069   09E7 B0            cmp a, b
1070   09E8 FD 71         seq ; ==
1071   09EA E4            pop a
1072   09EB             ; END RELATIONAL
1073   09EB C0 00 00      cmp b, 0
1074   09EE C6 00 0A      je _if16_exit
1075   09F1             _if16_true:
1076   09F1             ;; sign = -1; 
1077   09F1 FA FD FF      lea d, [bp + -3] ; $sign
1078   09F4 DA            push d
1079   09F5 26 01 00      mov b, $1
1080   09F8 FD 97         neg b
1081   09FA E7            pop d
1082   09FB FD 43         mov [d], b
1083   09FD 0A 00 0A      jmp _if16_exit
1084   0A00             _if16_exit:
1085   0A00             ;; str++; 
1086   0A00 FA 05 00      lea d, [bp + 5] ; $str
1087   0A03 2A            mov b, [d]
1088   0A04 FD 79         mov g, b
1089   0A06 FD 77         inc b
1090   0A08 FA 05 00      lea d, [bp + 5] ; $str
1091   0A0B FD 43         mov [d], b
1092   0A0D FD 27         mov b, g
1093   0A0F 0A 12 0A      jmp _if15_exit
1094   0A12             _if15_exit:
1095   0A12             ;; while (*str >= '0' && *str <= '9') { 
1096   0A12             _while17_cond:
1097   0A12 FA 05 00      lea d, [bp + 5] ; $str
1098   0A15 2A            mov b, [d]
1099   0A16 74            mov d, b
1100   0A17 32            mov bl, [d]
1101   0A18 A7 00         mov bh, 0
1102   0A1A             ; START RELATIONAL
1103   0A1A D7            push a
1104   0A1B 11            mov a, b
1105   0A1C 26 30 00      mov b, $30
1106   0A1F B0            cmp a, b
1107   0A20 FD 80         sge ; >=
1108   0A22 E4            pop a
1109   0A23             ; END RELATIONAL
1110   0A23 D7            push a
1111   0A24 11            mov a, b
1112   0A25 FA 05 00      lea d, [bp + 5] ; $str
1113   0A28 2A            mov b, [d]
1114   0A29 74            mov d, b
1115   0A2A 32            mov bl, [d]
1116   0A2B A7 00         mov bh, 0
1117   0A2D             ; START RELATIONAL
1118   0A2D D7            push a
1119   0A2E 11            mov a, b
1120   0A2F 26 39 00      mov b, $39
1121   0A32 B0            cmp a, b
1122   0A33 FD 74         sle ; <=
1123   0A35 E4            pop a
1124   0A36             ; END RELATIONAL
1125   0A36 FD A7         sand a, b ; &&
1126   0A38 E4            pop a
1127   0A39 C0 00 00      cmp b, 0
1128   0A3C C6 7A 0A      je _while17_exit
1129   0A3F             _while17_block:
1130   0A3F             ;; result = result * 10 + (*str - '0'); 
1131   0A3F FA FF FF      lea d, [bp + -1] ; $result
1132   0A42 DA            push d
1133   0A43 FA FF FF      lea d, [bp + -1] ; $result
1134   0A46 2A            mov b, [d]
1135   0A47             ; START FACTORS
1136   0A47 D7            push a
1137   0A48 11            mov a, b
1138   0A49 26 0A 00      mov b, $a
1139   0A4C AC            mul a, b ; *
1140   0A4D 11            mov a, b
1141   0A4E 27            mov b, a
1142   0A4F E4            pop a
1143   0A50             ; END FACTORS
1144   0A50             ; START TERMS
1145   0A50 D7            push a
1146   0A51 11            mov a, b
1147   0A52 FA 05 00      lea d, [bp + 5] ; $str
1148   0A55 2A            mov b, [d]
1149   0A56 74            mov d, b
1150   0A57 32            mov bl, [d]
1151   0A58 A7 00         mov bh, 0
1152   0A5A             ; START TERMS
1153   0A5A D7            push a
1154   0A5B 11            mov a, b
1155   0A5C 26 30 00      mov b, $30
1156   0A5F 60            sub a, b
1157   0A60 27            mov b, a
1158   0A61 E4            pop a
1159   0A62             ; END TERMS
1160   0A62 54            add a, b
1161   0A63 27            mov b, a
1162   0A64 E4            pop a
1163   0A65             ; END TERMS
1164   0A65 E7            pop d
1165   0A66 FD 43         mov [d], b
1166   0A68             ;; str++; 
1167   0A68 FA 05 00      lea d, [bp + 5] ; $str
1168   0A6B 2A            mov b, [d]
1169   0A6C FD 79         mov g, b
1170   0A6E FD 77         inc b
1171   0A70 FA 05 00      lea d, [bp + 5] ; $str
1172   0A73 FD 43         mov [d], b
1173   0A75 FD 27         mov b, g
1174   0A77 0A 12 0A      jmp _while17_cond
1175   0A7A             _while17_exit:
1176   0A7A             ;; return sign * result; 
1177   0A7A FA FD FF      lea d, [bp + -3] ; $sign
1178   0A7D 2A            mov b, [d]
1179   0A7E             ; START FACTORS
1180   0A7E D7            push a
1181   0A7F 11            mov a, b
1182   0A80 FA FF FF      lea d, [bp + -1] ; $result
1183   0A83 2A            mov b, [d]
1184   0A84 AC            mul a, b ; *
1185   0A85 11            mov a, b
1186   0A86 27            mov b, a
1187   0A87 E4            pop a
1188   0A88             ; END FACTORS
1189   0A88 F9            leave
1190   0A89 09            ret
1191   0A8A             
1192   0A8A             gets:
1193   0A8A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1194   0A8D             
1195   0A8D             ; --- BEGIN INLINE ASM BLOCK
1196   0A8D FA 05 00      lea d, [bp + 5] ; $s
1197   0A90 15            mov a, [d]
1198   0A91 3C            mov d, a
1199   0A92 07 09 0F      call _gets
1200   0A95             ; --- END INLINE ASM BLOCK
1201   0A95             
1202   0A95             ;; return strlen(s); 
1203   0A95 FA 05 00      lea d, [bp + 5] ; $s
1204   0A98 2A            mov b, [d]
1205   0A99 FD AB         swp b
1206   0A9B D8            push b
1207   0A9C 07 B8 05      call strlen
1208   0A9F 51 02 00      add sp, 2
1209   0AA2 F9            leave
1210   0AA3 09            ret
1211   0AA4             
1212   0AA4             prints:
1213   0AA4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1214   0AA7             ; $digits 
1215   0AA7             ; $i 
1216   0AA7 10 00 00      mov a, $0
1217   0AAA 45 FA FF      mov [bp + -6], a
1218   0AAD 52 07 00      sub sp, 7
1219   0AB0             ;; if (num < 0) { 
1220   0AB0             _if18_cond:
1221   0AB0 FA 05 00      lea d, [bp + 5] ; $num
1222   0AB3 2A            mov b, [d]
1223   0AB4             ; START RELATIONAL
1224   0AB4 D7            push a
1225   0AB5 11            mov a, b
1226   0AB6 26 00 00      mov b, $0
1227   0AB9 B0            cmp a, b
1228   0ABA FD 73         slt ; < 
1229   0ABC E4            pop a
1230   0ABD             ; END RELATIONAL
1231   0ABD C0 00 00      cmp b, 0
1232   0AC0 C6 DD 0A      je _if18_else
1233   0AC3             _if18_true:
1234   0AC3             ;; putchar('-'); 
1235   0AC3 26 2D 00      mov b, $2d
1236   0AC6 DD            push bl
1237   0AC7 07 85 0C      call putchar
1238   0ACA 51 01 00      add sp, 1
1239   0ACD             ;; num = -num; 
1240   0ACD FA 05 00      lea d, [bp + 5] ; $num
1241   0AD0 DA            push d
1242   0AD1 FA 05 00      lea d, [bp + 5] ; $num
1243   0AD4 2A            mov b, [d]
1244   0AD5 FD 97         neg b
1245   0AD7 E7            pop d
1246   0AD8 FD 43         mov [d], b
1247   0ADA 0A FF 0A      jmp _if18_exit
1248   0ADD             _if18_else:
1249   0ADD             ;; if (num == 0) { 
1250   0ADD             _if19_cond:
1251   0ADD FA 05 00      lea d, [bp + 5] ; $num
1252   0AE0 2A            mov b, [d]
1253   0AE1             ; START RELATIONAL
1254   0AE1 D7            push a
1255   0AE2 11            mov a, b
1256   0AE3 26 00 00      mov b, $0
1257   0AE6 B0            cmp a, b
1258   0AE7 FD 71         seq ; ==
1259   0AE9 E4            pop a
1260   0AEA             ; END RELATIONAL
1261   0AEA C0 00 00      cmp b, 0
1262   0AED C6 FF 0A      je _if19_exit
1263   0AF0             _if19_true:
1264   0AF0             ;; putchar('0'); 
1265   0AF0 26 30 00      mov b, $30
1266   0AF3 DD            push bl
1267   0AF4 07 85 0C      call putchar
1268   0AF7 51 01 00      add sp, 1
1269   0AFA             ;; return; 
1270   0AFA F9            leave
1271   0AFB 09            ret
1272   0AFC 0A FF 0A      jmp _if19_exit
1273   0AFF             _if19_exit:
1274   0AFF             _if18_exit:
1275   0AFF             ;; while (num > 0) { 
1276   0AFF             _while20_cond:
1277   0AFF FA 05 00      lea d, [bp + 5] ; $num
1278   0B02 2A            mov b, [d]
1279   0B03             ; START RELATIONAL
1280   0B03 D7            push a
1281   0B04 11            mov a, b
1282   0B05 26 00 00      mov b, $0
1283   0B08 B0            cmp a, b
1284   0B09 FD 7F         sgt ; >
1285   0B0B E4            pop a
1286   0B0C             ; END RELATIONAL
1287   0B0C C0 00 00      cmp b, 0
1288   0B0F C6 5C 0B      je _while20_exit
1289   0B12             _while20_block:
1290   0B12             ;; digits[i] = '0' + (num % 10); 
1291   0B12 FA FC FF      lea d, [bp + -4] ; $digits
1292   0B15 D7            push a
1293   0B16 DA            push d
1294   0B17 FA FA FF      lea d, [bp + -6] ; $i
1295   0B1A 2A            mov b, [d]
1296   0B1B E7            pop d
1297   0B1C 5A            add d, b
1298   0B1D E4            pop a
1299   0B1E DA            push d
1300   0B1F 26 30 00      mov b, $30
1301   0B22             ; START TERMS
1302   0B22 D7            push a
1303   0B23 11            mov a, b
1304   0B24 FA 05 00      lea d, [bp + 5] ; $num
1305   0B27 2A            mov b, [d]
1306   0B28             ; START FACTORS
1307   0B28 D7            push a
1308   0B29 11            mov a, b
1309   0B2A 26 0A 00      mov b, $a
1310   0B2D AE            div a, b ; 
1311   0B2E 11            mov a, b
1312   0B2F 27            mov b, a
1313   0B30 E4            pop a
1314   0B31             ; END FACTORS
1315   0B31 54            add a, b
1316   0B32 27            mov b, a
1317   0B33 E4            pop a
1318   0B34             ; END TERMS
1319   0B34 E7            pop d
1320   0B35 FD 3E         mov [d], bl
1321   0B37             ;; num = num / 10; 
1322   0B37 FA 05 00      lea d, [bp + 5] ; $num
1323   0B3A DA            push d
1324   0B3B FA 05 00      lea d, [bp + 5] ; $num
1325   0B3E 2A            mov b, [d]
1326   0B3F             ; START FACTORS
1327   0B3F D7            push a
1328   0B40 11            mov a, b
1329   0B41 26 0A 00      mov b, $a
1330   0B44 AE            div a, b
1331   0B45 27            mov b, a
1332   0B46 E4            pop a
1333   0B47             ; END FACTORS
1334   0B47 E7            pop d
1335   0B48 FD 43         mov [d], b
1336   0B4A             ;; i++; 
1337   0B4A FA FA FF      lea d, [bp + -6] ; $i
1338   0B4D 2A            mov b, [d]
1339   0B4E FD 79         mov g, b
1340   0B50 FD 77         inc b
1341   0B52 FA FA FF      lea d, [bp + -6] ; $i
1342   0B55 FD 43         mov [d], b
1343   0B57 FD 27         mov b, g
1344   0B59 0A FF 0A      jmp _while20_cond
1345   0B5C             _while20_exit:
1346   0B5C             ;; while (i > 0) { 
1347   0B5C             _while21_cond:
1348   0B5C FA FA FF      lea d, [bp + -6] ; $i
1349   0B5F 2A            mov b, [d]
1350   0B60             ; START RELATIONAL
1351   0B60 D7            push a
1352   0B61 11            mov a, b
1353   0B62 26 00 00      mov b, $0
1354   0B65 B0            cmp a, b
1355   0B66 FD 7F         sgt ; >
1356   0B68 E4            pop a
1357   0B69             ; END RELATIONAL
1358   0B69 C0 00 00      cmp b, 0
1359   0B6C C6 97 0B      je _while21_exit
1360   0B6F             _while21_block:
1361   0B6F             ;; i--; 
1362   0B6F FA FA FF      lea d, [bp + -6] ; $i
1363   0B72 2A            mov b, [d]
1364   0B73 FD 79         mov g, b
1365   0B75 FD 7D         dec b
1366   0B77 FA FA FF      lea d, [bp + -6] ; $i
1367   0B7A FD 43         mov [d], b
1368   0B7C FD 27         mov b, g
1369   0B7E             ;; putchar(digits[i]); 
1370   0B7E FA FC FF      lea d, [bp + -4] ; $digits
1371   0B81 D7            push a
1372   0B82 DA            push d
1373   0B83 FA FA FF      lea d, [bp + -6] ; $i
1374   0B86 2A            mov b, [d]
1375   0B87 E7            pop d
1376   0B88 5A            add d, b
1377   0B89 E4            pop a
1378   0B8A 32            mov bl, [d]
1379   0B8B A7 00         mov bh, 0
1380   0B8D DD            push bl
1381   0B8E 07 85 0C      call putchar
1382   0B91 51 01 00      add sp, 1
1383   0B94 0A 5C 0B      jmp _while21_cond
1384   0B97             _while21_exit:
1385   0B97 F9            leave
1386   0B98 09            ret
1387   0B99             
1388   0B99             printu:
1389   0B99 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1390   0B9C             ; $digits 
1391   0B9C             ; $i 
1392   0B9C 52 07 00      sub sp, 7
1393   0B9F             ;; i = 0; 
1394   0B9F FA FA FF      lea d, [bp + -6] ; $i
1395   0BA2 DA            push d
1396   0BA3 26 00 00      mov b, $0
1397   0BA6 E7            pop d
1398   0BA7 FD 43         mov [d], b
1399   0BA9             ;; if(num == 0){ 
1400   0BA9             _if22_cond:
1401   0BA9 FA 05 00      lea d, [bp + 5] ; $num
1402   0BAC 2A            mov b, [d]
1403   0BAD             ; START RELATIONAL
1404   0BAD D7            push a
1405   0BAE 11            mov a, b
1406   0BAF 26 00 00      mov b, $0
1407   0BB2 B0            cmp a, b
1408   0BB3 FD 71         seq ; ==
1409   0BB5 E4            pop a
1410   0BB6             ; END RELATIONAL
1411   0BB6 C0 00 00      cmp b, 0
1412   0BB9 C6 CB 0B      je _if22_exit
1413   0BBC             _if22_true:
1414   0BBC             ;; putchar('0'); 
1415   0BBC 26 30 00      mov b, $30
1416   0BBF DD            push bl
1417   0BC0 07 85 0C      call putchar
1418   0BC3 51 01 00      add sp, 1
1419   0BC6             ;; return; 
1420   0BC6 F9            leave
1421   0BC7 09            ret
1422   0BC8 0A CB 0B      jmp _if22_exit
1423   0BCB             _if22_exit:
1424   0BCB             ;; while (num > 0) { 
1425   0BCB             _while23_cond:
1426   0BCB FA 05 00      lea d, [bp + 5] ; $num
1427   0BCE 2A            mov b, [d]
1428   0BCF             ; START RELATIONAL
1429   0BCF D7            push a
1430   0BD0 11            mov a, b
1431   0BD1 26 00 00      mov b, $0
1432   0BD4 B0            cmp a, b
1433   0BD5 FD 81         sgu ; > (unsigned)
1434   0BD7 E4            pop a
1435   0BD8             ; END RELATIONAL
1436   0BD8 C0 00 00      cmp b, 0
1437   0BDB C6 28 0C      je _while23_exit
1438   0BDE             _while23_block:
1439   0BDE             ;; digits[i] = '0' + (num % 10); 
1440   0BDE FA FC FF      lea d, [bp + -4] ; $digits
1441   0BE1 D7            push a
1442   0BE2 DA            push d
1443   0BE3 FA FA FF      lea d, [bp + -6] ; $i
1444   0BE6 2A            mov b, [d]
1445   0BE7 E7            pop d
1446   0BE8 5A            add d, b
1447   0BE9 E4            pop a
1448   0BEA DA            push d
1449   0BEB 26 30 00      mov b, $30
1450   0BEE             ; START TERMS
1451   0BEE D7            push a
1452   0BEF 11            mov a, b
1453   0BF0 FA 05 00      lea d, [bp + 5] ; $num
1454   0BF3 2A            mov b, [d]
1455   0BF4             ; START FACTORS
1456   0BF4 D7            push a
1457   0BF5 11            mov a, b
1458   0BF6 26 0A 00      mov b, $a
1459   0BF9 AE            div a, b ; 
1460   0BFA 11            mov a, b
1461   0BFB 27            mov b, a
1462   0BFC E4            pop a
1463   0BFD             ; END FACTORS
1464   0BFD 54            add a, b
1465   0BFE 27            mov b, a
1466   0BFF E4            pop a
1467   0C00             ; END TERMS
1468   0C00 E7            pop d
1469   0C01 FD 3E         mov [d], bl
1470   0C03             ;; num = num / 10; 
1471   0C03 FA 05 00      lea d, [bp + 5] ; $num
1472   0C06 DA            push d
1473   0C07 FA 05 00      lea d, [bp + 5] ; $num
1474   0C0A 2A            mov b, [d]
1475   0C0B             ; START FACTORS
1476   0C0B D7            push a
1477   0C0C 11            mov a, b
1478   0C0D 26 0A 00      mov b, $a
1479   0C10 AE            div a, b
1480   0C11 27            mov b, a
1481   0C12 E4            pop a
1482   0C13             ; END FACTORS
1483   0C13 E7            pop d
1484   0C14 FD 43         mov [d], b
1485   0C16             ;; i++; 
1486   0C16 FA FA FF      lea d, [bp + -6] ; $i
1487   0C19 2A            mov b, [d]
1488   0C1A FD 79         mov g, b
1489   0C1C FD 77         inc b
1490   0C1E FA FA FF      lea d, [bp + -6] ; $i
1491   0C21 FD 43         mov [d], b
1492   0C23 FD 27         mov b, g
1493   0C25 0A CB 0B      jmp _while23_cond
1494   0C28             _while23_exit:
1495   0C28             ;; while (i > 0) { 
1496   0C28             _while24_cond:
1497   0C28 FA FA FF      lea d, [bp + -6] ; $i
1498   0C2B 2A            mov b, [d]
1499   0C2C             ; START RELATIONAL
1500   0C2C D7            push a
1501   0C2D 11            mov a, b
1502   0C2E 26 00 00      mov b, $0
1503   0C31 B0            cmp a, b
1504   0C32 FD 7F         sgt ; >
1505   0C34 E4            pop a
1506   0C35             ; END RELATIONAL
1507   0C35 C0 00 00      cmp b, 0
1508   0C38 C6 63 0C      je _while24_exit
1509   0C3B             _while24_block:
1510   0C3B             ;; i--; 
1511   0C3B FA FA FF      lea d, [bp + -6] ; $i
1512   0C3E 2A            mov b, [d]
1513   0C3F FD 79         mov g, b
1514   0C41 FD 7D         dec b
1515   0C43 FA FA FF      lea d, [bp + -6] ; $i
1516   0C46 FD 43         mov [d], b
1517   0C48 FD 27         mov b, g
1518   0C4A             ;; putchar(digits[i]); 
1519   0C4A FA FC FF      lea d, [bp + -4] ; $digits
1520   0C4D D7            push a
1521   0C4E DA            push d
1522   0C4F FA FA FF      lea d, [bp + -6] ; $i
1523   0C52 2A            mov b, [d]
1524   0C53 E7            pop d
1525   0C54 5A            add d, b
1526   0C55 E4            pop a
1527   0C56 32            mov bl, [d]
1528   0C57 A7 00         mov bh, 0
1529   0C59 DD            push bl
1530   0C5A 07 85 0C      call putchar
1531   0C5D 51 01 00      add sp, 1
1532   0C60 0A 28 0C      jmp _while24_cond
1533   0C63             _while24_exit:
1534   0C63 F9            leave
1535   0C64 09            ret
1536   0C65             
1537   0C65             rand:
1538   0C65 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1539   0C68             ; $sec 
1540   0C68 52 01 00      sub sp, 1
1541   0C6B             
1542   0C6B             ; --- BEGIN INLINE ASM BLOCK
1543   0C6B 19 00         mov al, 0
1544   0C6D 05 01         syscall sys_rtc					
1545   0C6F 1A            mov al, ah
1546   0C70 FA 00 00      lea d, [bp + 0] ; $sec
1547   0C73 1E            mov al, [d]
1548   0C74             ; --- END INLINE ASM BLOCK
1549   0C74             
1550   0C74             ;; return sec; 
1551   0C74 FA 00 00      lea d, [bp + 0] ; $sec
1552   0C77 32            mov bl, [d]
1553   0C78 A7 00         mov bh, 0
1554   0C7A F9            leave
1555   0C7B 09            ret
1556   0C7C             
1557   0C7C             date:
1558   0C7C F8 00 00      enter 0 ; (push bp; mov bp, sp)
1559   0C7F             
1560   0C7F             ; --- BEGIN INLINE ASM BLOCK
1561   0C7F 19 00         mov al, 0 
1562   0C81 05 07         syscall sys_datetime
1563   0C83             ; --- END INLINE ASM BLOCK
1564   0C83             
1565   0C83 F9            leave
1566   0C84 09            ret
1567   0C85             
1568   0C85             putchar:
1569   0C85 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1570   0C88             
1571   0C88             ; --- BEGIN INLINE ASM BLOCK
1572   0C88 FA 05 00      lea d, [bp + 5] ; $c
1573   0C8B 1E            mov al, [d]
1574   0C8C 23            mov ah, al
1575   0C8D 07 02 0F      call _putchar
1576   0C90             ; --- END INLINE ASM BLOCK
1577   0C90             
1578   0C90 F9            leave
1579   0C91 09            ret
1580   0C92             
1581   0C92             getchar:
1582   0C92 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1583   0C95             ; $c 
1584   0C95 52 01 00      sub sp, 1
1585   0C98             
1586   0C98             ; --- BEGIN INLINE ASM BLOCK
1587   0C98 07 FB 0E      call getch
1588   0C9B 1A            mov al, ah
1589   0C9C FA 00 00      lea d, [bp + 0] ; $c
1590   0C9F 3E            mov [d], al
1591   0CA0             ; --- END INLINE ASM BLOCK
1592   0CA0             
1593   0CA0             ;; return c; 
1594   0CA0 FA 00 00      lea d, [bp + 0] ; $c
1595   0CA3 32            mov bl, [d]
1596   0CA4 A7 00         mov bh, 0
1597   0CA6 F9            leave
1598   0CA7 09            ret
1599   0CA8             
1600   0CA8             scann:
1601   0CA8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1602   0CAB             ; $m 
1603   0CAB 52 02 00      sub sp, 2
1604   0CAE             
1605   0CAE             ; --- BEGIN INLINE ASM BLOCK
1606   0CAE 07 46 11      call scan_u16d
1607   0CB1 FA FF FF      lea d, [bp + -1] ; $m
1608   0CB4 43            mov [d], a
1609   0CB5             ; --- END INLINE ASM BLOCK
1610   0CB5             
1611   0CB5             ;; return m; 
1612   0CB5 FA FF FF      lea d, [bp + -1] ; $m
1613   0CB8 2A            mov b, [d]
1614   0CB9 F9            leave
1615   0CBA 09            ret
1616   0CBB             
1617   0CBB             puts:
1618   0CBB F8 00 00      enter 0 ; (push bp; mov bp, sp)
1619   0CBE             
1620   0CBE             ; --- BEGIN INLINE ASM BLOCK
1621   0CBE FA 05 00      lea d, [bp + 5] ; $s
1622   0CC1 15            mov a, [d]
1623   0CC2 3C            mov d, a
1624   0CC3 07 4C 10      call _puts
1625   0CC6 10 00 0A      mov a, $0A00
1626   0CC9 05 03         syscall sys_io
1627   0CCB             ; --- END INLINE ASM BLOCK
1628   0CCB             
1629   0CCB F9            leave
1630   0CCC 09            ret
1631   0CCD             
1632   0CCD             print:
1633   0CCD F8 00 00      enter 0 ; (push bp; mov bp, sp)
1634   0CD0             
1635   0CD0             ; --- BEGIN INLINE ASM BLOCK
1636   0CD0 FA 05 00      lea d, [bp + 5] ; $s
1637   0CD3 FD 2A         mov d, [d]
1638   0CD5 07 4C 10      call _puts
1639   0CD8             ; --- END INLINE ASM BLOCK
1640   0CD8             
1641   0CD8 F9            leave
1642   0CD9 09            ret
1643   0CDA             
1644   0CDA             loadfile:
1645   0CDA F8 00 00      enter 0 ; (push bp; mov bp, sp)
1646   0CDD             
1647   0CDD             ; --- BEGIN INLINE ASM BLOCK
1648   0CDD FA 05 00      lea d, [bp + 5] ; $destination
1649   0CE0 15            mov a, [d]
1650   0CE1 4F            mov di, a
1651   0CE2 FA 07 00      lea d, [bp + 7] ; $filename
1652   0CE5 FD 2A         mov d, [d]
1653   0CE7 19 14         mov al, 20
1654   0CE9 05 04         syscall sys_filesystem
1655   0CEB             ; --- END INLINE ASM BLOCK
1656   0CEB             
1657   0CEB F9            leave
1658   0CEC 09            ret
1659   0CED             
1660   0CED             create_file:
1661   0CED F8 00 00      enter 0 ; (push bp; mov bp, sp)
1662   0CF0 F9            leave
1663   0CF1 09            ret
1664   0CF2             
1665   0CF2             delete_file:
1666   0CF2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1667   0CF5             
1668   0CF5             ; --- BEGIN INLINE ASM BLOCK
1669   0CF5 FA 05 00      lea d, [bp + 5] ; $filename
1670   0CF8 19 0A         mov al, 10
1671   0CFA 05 04         syscall sys_filesystem
1672   0CFC             ; --- END INLINE ASM BLOCK
1673   0CFC             
1674   0CFC F9            leave
1675   0CFD 09            ret
1676   0CFE             
1677   0CFE             fopen:
1678   0CFE F8 00 00      enter 0 ; (push bp; mov bp, sp)
1679   0D01 F9            leave
1680   0D02 09            ret
1681   0D03             
1682   0D03             fclose:
1683   0D03 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1684   0D06 F9            leave
1685   0D07 09            ret
1686   0D08             
1687   0D08             alloc:
1688   0D08 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1689   0D0B             ;; heap_top = heap_top + bytes; 
1690   0D0B 3B 07 13      mov d, _heap_top ; $heap_top
1691   0D0E DA            push d
1692   0D0F 3B 07 13      mov d, _heap_top ; $heap_top
1693   0D12 2A            mov b, [d]
1694   0D13             ; START TERMS
1695   0D13 D7            push a
1696   0D14 11            mov a, b
1697   0D15 FA 05 00      lea d, [bp + 5] ; $bytes
1698   0D18 2A            mov b, [d]
1699   0D19 54            add a, b
1700   0D1A 27            mov b, a
1701   0D1B E4            pop a
1702   0D1C             ; END TERMS
1703   0D1C E7            pop d
1704   0D1D FD 43         mov [d], b
1705   0D1F             ;; return heap_top - bytes; 
1706   0D1F 3B 07 13      mov d, _heap_top ; $heap_top
1707   0D22 2A            mov b, [d]
1708   0D23             ; START TERMS
1709   0D23 D7            push a
1710   0D24 11            mov a, b
1711   0D25 FA 05 00      lea d, [bp + 5] ; $bytes
1712   0D28 2A            mov b, [d]
1713   0D29 60            sub a, b
1714   0D2A 27            mov b, a
1715   0D2B E4            pop a
1716   0D2C             ; END TERMS
1717   0D2C F9            leave
1718   0D2D 09            ret
1719   0D2E             
1720   0D2E             free:
1721   0D2E F8 00 00      enter 0 ; (push bp; mov bp, sp)
1722   0D31             ;; return heap_top = heap_top - bytes; 
1723   0D31 3B 07 13      mov d, _heap_top ; $heap_top
1724   0D34 DA            push d
1725   0D35 3B 07 13      mov d, _heap_top ; $heap_top
1726   0D38 2A            mov b, [d]
1727   0D39             ; START TERMS
1728   0D39 D7            push a
1729   0D3A 11            mov a, b
1730   0D3B FA 05 00      lea d, [bp + 5] ; $bytes
1731   0D3E 2A            mov b, [d]
1732   0D3F 60            sub a, b
1733   0D40 27            mov b, a
1734   0D41 E4            pop a
1735   0D42             ; END TERMS
1736   0D42 E7            pop d
1737   0D43 FD 43         mov [d], b
1738   0D45 F9            leave
1739   0D46 09            ret
1740   0D47             
1741   0D47             exit:
1742   0D47 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1743   0D4A             
1744   0D4A             ; --- BEGIN INLINE ASM BLOCK
1745   0D4A 05 0B         syscall sys_terminate_proc
1746   0D4C             ; --- END INLINE ASM BLOCK
1747   0D4C             
1748   0D4C F9            leave
1749   0D4D 09            ret
1750   0D4E             
1751   0D4E             load_hex:
1752   0D4E F8 00 00      enter 0 ; (push bp; mov bp, sp)
1753   0D51             ; $temp 
1754   0D51 52 02 00      sub sp, 2
1755   0D54             ;; temp = alloc(32768); 
1756   0D54 FA FF FF      lea d, [bp + -1] ; $temp
1757   0D57 DA            push d
1758   0D58 26 00 80      mov b, $8000
1759   0D5B FD AB         swp b
1760   0D5D D8            push b
1761   0D5E 07 08 0D      call alloc
1762   0D61 51 02 00      add sp, 2
1763   0D64 E7            pop d
1764   0D65 FD 43         mov [d], b
1765   0D67             
1766   0D67             ; --- BEGIN INLINE ASM BLOCK
1767   0D67               
1768   0D67               
1769   0D67               
1770   0D67               
1771   0D67               
1772   0D67             _load_hex:
1773   0D67 D7            push a
1774   0D68 D8            push b
1775   0D69 DA            push d
1776   0D6A E2            push si
1777   0D6B E3            push di
1778   0D6C 52 00 80      sub sp, $8000      
1779   0D6F 38 00 00      mov c, 0
1780   0D72 48            mov a, sp
1781   0D73 77            inc a
1782   0D74 3C            mov d, a          
1783   0D75 07 09 0F      call _gets        
1784   0D78 4D            mov si, a
1785   0D79             __load_hex_loop:
1786   0D79 F6            lodsb             
1787   0D7A B9 00         cmp al, 0         
1788   0D7C C6 8A 0D      jz __load_hex_ret
1789   0D7F 36            mov bh, al
1790   0D80 F6            lodsb
1791   0D81 2F            mov bl, al
1792   0D82 07 BF 0E      call _atoi        
1793   0D85 F7            stosb             
1794   0D86 78            inc c
1795   0D87 0A 79 0D      jmp __load_hex_loop
1796   0D8A             __load_hex_ret:
1797   0D8A 51 00 80      add sp, $8000
1798   0D8D F0            pop di
1799   0D8E EF            pop si
1800   0D8F E7            pop d
1801   0D90 E5            pop b
1802   0D91 E4            pop a
1803   0D92             ; --- END INLINE ASM BLOCK
1804   0D92             
1805   0D92 F9            leave
1806   0D93 09            ret
1807   0D94             
1808   0D94             getparam:
1809   0D94 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1810   0D97             ; $data 
1811   0D97 52 01 00      sub sp, 1
1812   0D9A             
1813   0D9A             ; --- BEGIN INLINE ASM BLOCK
1814   0D9A 19 04         mov al, 4
1815   0D9C FA 05 00      lea d, [bp + 5] ; $address
1816   0D9F FD 2A         mov d, [d]
1817   0DA1 05 0C         syscall sys_system
1818   0DA3 FA 00 00      lea d, [bp + 0] ; $data
1819   0DA6 FD 3E         mov [d], bl
1820   0DA8             ; --- END INLINE ASM BLOCK
1821   0DA8             
1822   0DA8             ;; return data; 
1823   0DA8 FA 00 00      lea d, [bp + 0] ; $data
1824   0DAB 32            mov bl, [d]
1825   0DAC A7 00         mov bh, 0
1826   0DAE F9            leave
1827   0DAF 09            ret
1828   0DB0             
1829   0DB0             clear:
1830   0DB0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1831   0DB3             ;; print("\033[2J\033[H"); 
1832   0DB3 26 FD 12      mov b, __s2 ; "\033[2J\033[H"
1833   0DB6 FD AB         swp b
1834   0DB8 D8            push b
1835   0DB9 07 CD 0C      call print
1836   0DBC 51 02 00      add sp, 2
1837   0DBF F9            leave
1838   0DC0 09            ret
1839   0DC1             
1840   0DC1             printun:
1841   0DC1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1842   0DC4             ;; print(prompt); 
1843   0DC4 FA 07 00      lea d, [bp + 7] ; $prompt
1844   0DC7 2A            mov b, [d]
1845   0DC8 FD AB         swp b
1846   0DCA D8            push b
1847   0DCB 07 CD 0C      call print
1848   0DCE 51 02 00      add sp, 2
1849   0DD1             ;; printu(n); 
1850   0DD1 FA 05 00      lea d, [bp + 5] ; $n
1851   0DD4 2A            mov b, [d]
1852   0DD5 FD AB         swp b
1853   0DD7 D8            push b
1854   0DD8 07 99 0B      call printu
1855   0DDB 51 02 00      add sp, 2
1856   0DDE             ;; print("\n"); 
1857   0DDE 26 05 13      mov b, __s3 ; "\n"
1858   0DE1 FD AB         swp b
1859   0DE3 D8            push b
1860   0DE4 07 CD 0C      call print
1861   0DE7 51 02 00      add sp, 2
1862   0DEA F9            leave
1863   0DEB 09            ret
1864   0DEC             
1865   0DEC             printsn:
1866   0DEC F8 00 00      enter 0 ; (push bp; mov bp, sp)
1867   0DEF             ;; print(prompt); 
1868   0DEF FA 07 00      lea d, [bp + 7] ; $prompt
1869   0DF2 2A            mov b, [d]
1870   0DF3 FD AB         swp b
1871   0DF5 D8            push b
1872   0DF6 07 CD 0C      call print
1873   0DF9 51 02 00      add sp, 2
1874   0DFC             ;; prints(n); 
1875   0DFC FA 05 00      lea d, [bp + 5] ; $n
1876   0DFF 2A            mov b, [d]
1877   0E00 FD AB         swp b
1878   0E02 D8            push b
1879   0E03 07 A4 0A      call prints
1880   0E06 51 02 00      add sp, 2
1881   0E09             ;; print("\n"); 
1882   0E09 26 05 13      mov b, __s3 ; "\n"
1883   0E0C FD AB         swp b
1884   0E0E D8            push b
1885   0E0F 07 CD 0C      call print
1886   0E12 51 02 00      add sp, 2
1887   0E15 F9            leave
1888   0E16 09            ret
1889   0E17             
1890   0E17             include_stdio_asm:
1891   0E17 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1892   0E1A             
1893   0E1A             ; --- BEGIN INLINE ASM BLOCK
1894   0E1A             .include "lib/stdio.asm"
0001+  0E1A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0E1A             ; stdio.s
0003+  0E1A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0E1A             .include "lib/string.asm"
0001++ 0E1A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0E1A             ; string.s
0003++ 0E1A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0E1A             
0005++ 0E1A             
0006++ 0E1A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0E1A             ; _strrev
0008++ 0E1A             ; reverse a string
0009++ 0E1A             ; D = string address
0010++ 0E1A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0E1A             ; 01234
0012++ 0E1A             _strrev:
0013++ 0E1A 4B          	pusha
0014++ 0E1B 07 61 0E    	call _strlen	; length in C
0015++ 0E1E 12          	mov a, c
0016++ 0E1F AF 01 00    	cmp a, 1
0017++ 0E22 D0 3C 0E    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 0E25 7D          	dec a
0019++ 0E26 FD 4E       	mov si, d	; beginning of string
0020++ 0E28 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0E2A 59          	add d, a	; end of string
0022++ 0E2B 12          	mov a, c
0023++ 0E2C FD 9B       	shr a		; divide by 2
0024++ 0E2E 39          	mov c, a	; C now counts the steps
0025++ 0E2F             _strrev_L0:
0026++ 0E2F 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0E30 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0E31 3E          	mov [d], al	; store left char into right side
0029++ 0E32 1B          	mov al, bl
0030++ 0E33 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0E34 7E          	dec c
0032++ 0E35 7F          	dec d
0033++ 0E36 C2 00 00    	cmp c, 0
0034++ 0E39 C7 2F 0E    	jne _strrev_L0
0035++ 0E3C             _strrev_end:
0036++ 0E3C 4C          	popa
0037++ 0E3D 09          	ret
0038++ 0E3E             	
0039++ 0E3E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0E3E             ; _strchr
0041++ 0E3E             ; search string in D for char in AL
0042++ 0E3E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0E3E             _strchr:
0044++ 0E3E             _strchr_L0:
0045++ 0E3E 32          	mov bl, [d]
0046++ 0E3F C1 00       	cmp bl, 0
0047++ 0E41 C6 4C 0E    	je _strchr_end
0048++ 0E44 BA          	cmp al, bl
0049++ 0E45 C6 4C 0E    	je _strchr_end
0050++ 0E48 79          	inc d
0051++ 0E49 0A 3E 0E    	jmp _strchr_L0
0052++ 0E4C             _strchr_end:
0053++ 0E4C 1B          	mov al, bl
0054++ 0E4D 09          	ret
0055++ 0E4E             
0056++ 0E4E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0E4E             ; _strstr
0058++ 0E4E             ; find sub-string
0059++ 0E4E             ; str1 in SI
0060++ 0E4E             ; str2 in DI
0061++ 0E4E             ; SI points to end of source string
0062++ 0E4E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0E4E             _strstr:
0064++ 0E4E DB          	push al
0065++ 0E4F DA          	push d
0066++ 0E50 E3          	push di
0067++ 0E51             _strstr_loop:
0068++ 0E51 F3          	cmpsb					; compare a byte of the strings
0069++ 0E52 C7 5D 0E    	jne _strstr_ret
0070++ 0E55 FC 00 00    	lea d, [di + 0]
0071++ 0E58 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0E5A C7 51 0E    	jne _strstr_loop				; equal chars but not at end
0073++ 0E5D             _strstr_ret:
0074++ 0E5D F0          	pop di
0075++ 0E5E E7          	pop d
0076++ 0E5F E8          	pop al
0077++ 0E60 09          	ret
0078++ 0E61             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0E61             ; length of null terminated string
0080++ 0E61             ; result in C
0081++ 0E61             ; pointer in D
0082++ 0E61             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0E61             _strlen:
0084++ 0E61 DA          	push d
0085++ 0E62 38 00 00    	mov c, 0
0086++ 0E65             _strlen_L1:
0087++ 0E65 BD 00       	cmp byte [d], 0
0088++ 0E67 C6 6F 0E    	je _strlen_ret
0089++ 0E6A 79          	inc d
0090++ 0E6B 78          	inc c
0091++ 0E6C 0A 65 0E    	jmp _strlen_L1
0092++ 0E6F             _strlen_ret:
0093++ 0E6F E7          	pop d
0094++ 0E70 09          	ret
0095++ 0E71             
0096++ 0E71             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0E71             ; STRCMP
0098++ 0E71             ; compare two strings
0099++ 0E71             ; str1 in SI
0100++ 0E71             ; str2 in DI
0101++ 0E71             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0E71             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0E71             _strcmp:
0104++ 0E71 DB          	push al
0105++ 0E72 DA          	push d
0106++ 0E73 E3          	push di
0107++ 0E74 E2          	push si
0108++ 0E75             _strcmp_loop:
0109++ 0E75 F3          	cmpsb					; compare a byte of the strings
0110++ 0E76 C7 81 0E    	jne _strcmp_ret
0111++ 0E79 FB FF FF    	lea d, [si +- 1]
0112++ 0E7C BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0E7E C7 75 0E    	jne _strcmp_loop				; equal chars but not at end
0114++ 0E81             _strcmp_ret:
0115++ 0E81 EF          	pop si
0116++ 0E82 F0          	pop di
0117++ 0E83 E7          	pop d
0118++ 0E84 E8          	pop al
0119++ 0E85 09          	ret
0120++ 0E86             
0121++ 0E86             
0122++ 0E86             ; STRCPY
0123++ 0E86             ; copy null terminated string from SI to DI
0124++ 0E86             ; source in SI
0125++ 0E86             ; destination in DI
0126++ 0E86             _strcpy:
0127++ 0E86 E2          	push si
0128++ 0E87 E3          	push di
0129++ 0E88 DB          	push al
0130++ 0E89             _strcpy_L1:
0131++ 0E89 F6          	lodsb
0132++ 0E8A F7          	stosb
0133++ 0E8B B9 00       	cmp al, 0
0134++ 0E8D C7 89 0E    	jne _strcpy_L1
0135++ 0E90             _strcpy_end:
0136++ 0E90 E8          	pop al
0137++ 0E91 F0          	pop di
0138++ 0E92 EF          	pop si
0139++ 0E93 09          	ret
0140++ 0E94             
0141++ 0E94             ; STRCAT
0142++ 0E94             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0E94             ; source in SI
0144++ 0E94             ; destination in DI
0145++ 0E94             _strcat:
0146++ 0E94 E2          	push si
0147++ 0E95 E3          	push di
0148++ 0E96 D7          	push a
0149++ 0E97 DA          	push d
0150++ 0E98 50          	mov a, di
0151++ 0E99 3C          	mov d, a
0152++ 0E9A             _strcat_goto_end_L1:
0153++ 0E9A BD 00       	cmp byte[d], 0
0154++ 0E9C C6 A3 0E    	je _strcat_start
0155++ 0E9F 79          	inc d
0156++ 0EA0 0A 9A 0E    	jmp _strcat_goto_end_L1
0157++ 0EA3             _strcat_start:
0158++ 0EA3 FD 50       	mov di, d
0159++ 0EA5             _strcat_L1:
0160++ 0EA5 F6          	lodsb
0161++ 0EA6 F7          	stosb
0162++ 0EA7 B9 00       	cmp al, 0
0163++ 0EA9 C7 A5 0E    	jne _strcat_L1
0164++ 0EAC             _strcat_end:
0165++ 0EAC E7          	pop d
0166++ 0EAD E4          	pop a
0167++ 0EAE F0          	pop di
0168++ 0EAF EF          	pop si
0169++ 0EB0 09          	ret
0170++ 0EB1             
0171++ 0EB1             
0005+  0EB1             
0006+  0EB1             
0007+  0EB1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  0EB1             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  0EB1             ; ASCII in BL
0010+  0EB1             ; result in AL
0011+  0EB1             ; ascii for F = 0100 0110
0012+  0EB1             ; ascii for 9 = 0011 1001
0013+  0EB1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  0EB1             hex_ascii_encode:
0015+  0EB1 1B            mov al, bl
0016+  0EB2 93 40         test al, $40        ; test if letter or number
0017+  0EB4 C7 BA 0E      jnz hex_letter
0018+  0EB7 87 0F         and al, $0F        ; get number
0019+  0EB9 09            ret
0020+  0EBA             hex_letter:
0021+  0EBA 87 0F         and al, $0F        ; get letter
0022+  0EBC 6A 09         add al, 9
0023+  0EBE 09            ret
0024+  0EBF             
0025+  0EBF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0EBF             ; ATOI
0027+  0EBF             ; 2 letter hex string in B
0028+  0EBF             ; 8bit integer returned in AL
0029+  0EBF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  0EBF             _atoi:
0031+  0EBF D8            push b
0032+  0EC0 07 B1 0E      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  0EC3 30            mov bl, bh
0034+  0EC4 DB            push al          ; save a
0035+  0EC5 07 B1 0E      call hex_ascii_encode
0036+  0EC8 EA            pop bl  
0037+  0EC9 FD 9E 04      shl al, 4
0038+  0ECC 8C            or al, bl
0039+  0ECD E5            pop b
0040+  0ECE 09            ret  
0041+  0ECF             
0042+  0ECF             
0043+  0ECF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  0ECF             ; scanf
0045+  0ECF             ; no need for explanations!
0046+  0ECF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  0ECF             scanf:
0048+  0ECF 09            ret
0049+  0ED0             
0050+  0ED0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0ED0             ; ITOA
0052+  0ED0             ; 8bit value in BL
0053+  0ED0             ; 2 byte ASCII result in A
0054+  0ED0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0ED0             _itoa:
0056+  0ED0 DA            push d
0057+  0ED1 D8            push b
0058+  0ED2 A7 00         mov bh, 0
0059+  0ED4 FD A4 04      shr bl, 4  
0060+  0ED7 74            mov d, b
0061+  0ED8 1F 80 11      mov al, [d + s_hex_digits]
0062+  0EDB 23            mov ah, al
0063+  0EDC               
0064+  0EDC E5            pop b
0065+  0EDD D8            push b
0066+  0EDE A7 00         mov bh, 0
0067+  0EE0 FD 87 0F      and bl, $0F
0068+  0EE3 74            mov d, b
0069+  0EE4 1F 80 11      mov al, [d + s_hex_digits]
0070+  0EE7 E5            pop b
0071+  0EE8 E7            pop d
0072+  0EE9 09            ret
0073+  0EEA             
0074+  0EEA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  0EEA             ; HEX STRING TO BINARY
0076+  0EEA             ; di = destination address
0077+  0EEA             ; si = source
0078+  0EEA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  0EEA             _hex_to_int:
0080+  0EEA             _hex_to_int_L1:
0081+  0EEA F6            lodsb          ; load from [SI] to AL
0082+  0EEB B9 00         cmp al, 0        ; check if ASCII 0
0083+  0EED C6 FA 0E      jz _hex_to_int_ret
0084+  0EF0 36            mov bh, al
0085+  0EF1 F6            lodsb
0086+  0EF2 2F            mov bl, al
0087+  0EF3 07 BF 0E      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  0EF6 F7            stosb          ; store AL to [DI]
0089+  0EF7 0A EA 0E      jmp _hex_to_int_L1
0090+  0EFA             _hex_to_int_ret:
0091+  0EFA 09            ret    
0092+  0EFB             
0093+  0EFB             
0094+  0EFB             
0095+  0EFB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  0EFB             ; GETCHAR
0097+  0EFB             ; char in ah
0098+  0EFB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  0EFB             getch:
0100+  0EFB DB            push al
0101+  0EFC             getch_retry:
0102+  0EFC 19 01         mov al, 1
0103+  0EFE 05 03         syscall sys_io      ; receive in AH
0104+  0F00 E8            pop al
0105+  0F01 09            ret
0106+  0F02             
0107+  0F02             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  0F02             ; PUTCHAR
0109+  0F02             ; char in ah
0110+  0F02             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0F02             _putchar:
0112+  0F02 D7            push a
0113+  0F03 19 00         mov al, 0
0114+  0F05 05 03         syscall sys_io      ; char in AH
0115+  0F07 E4            pop a
0116+  0F08 09            ret
0117+  0F09             
0118+  0F09             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  0F09             ;; INPUT A STRING
0120+  0F09             ;; terminates with null
0121+  0F09             ;; pointer in D
0122+  0F09             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  0F09             _gets:
0124+  0F09 D7            push a
0125+  0F0A DA            push d
0126+  0F0B             _gets_loop:
0127+  0F0B 19 01         mov al, 1
0128+  0F0D 05 03         syscall sys_io      ; receive in AH
0129+  0F0F B9 00         cmp al, 0        ; check error code (AL)
0130+  0F11 C6 0B 0F      je _gets_loop      ; if no char received, retry
0131+  0F14             
0132+  0F14 76 1B         cmp ah, 27
0133+  0F16 C6 37 0F      je _gets_ansi_esc
0134+  0F19 76 0A         cmp ah, $0A        ; LF
0135+  0F1B C6 A2 0F      je _gets_end
0136+  0F1E 76 0D         cmp ah, $0D        ; CR
0137+  0F20 C6 A2 0F      je _gets_end
0138+  0F23 76 5C         cmp ah, $5C        ; '\\'
0139+  0F25 C6 63 0F      je _gets_escape
0140+  0F28               
0141+  0F28 76 08         cmp ah, $08      ; check for backspace
0142+  0F2A C6 33 0F      je _gets_backspace
0143+  0F2D             
0144+  0F2D 1A            mov al, ah
0145+  0F2E 3E            mov [d], al
0146+  0F2F 79            inc d
0147+  0F30 0A 0B 0F      jmp _gets_loop
0148+  0F33             _gets_backspace:
0149+  0F33 7F            dec d
0150+  0F34 0A 0B 0F      jmp _gets_loop
0151+  0F37             _gets_ansi_esc:
0152+  0F37 19 01         mov al, 1
0153+  0F39 05 03         syscall sys_io        ; receive in AH without echo
0154+  0F3B B9 00         cmp al, 0          ; check error code (AL)
0155+  0F3D C6 37 0F      je _gets_ansi_esc    ; if no char received, retry
0156+  0F40 76 5B         cmp ah, '['
0157+  0F42 C7 0B 0F      jne _gets_loop
0158+  0F45             _gets_ansi_esc_2:
0159+  0F45 19 01         mov al, 1
0160+  0F47 05 03         syscall sys_io          ; receive in AH without echo
0161+  0F49 B9 00         cmp al, 0            ; check error code (AL)
0162+  0F4B C6 45 0F      je _gets_ansi_esc_2  ; if no char received, retry
0163+  0F4E 76 44         cmp ah, 'D'
0164+  0F50 C6 5B 0F      je _gets_left_arrow
0165+  0F53 76 43         cmp ah, 'C'
0166+  0F55 C6 5F 0F      je _gets_right_arrow
0167+  0F58 0A 0B 0F      jmp _gets_loop
0168+  0F5B             _gets_left_arrow:
0169+  0F5B 7F            dec d
0170+  0F5C 0A 0B 0F      jmp _gets_loop
0171+  0F5F             _gets_right_arrow:
0172+  0F5F 79            inc d
0173+  0F60 0A 0B 0F      jmp _gets_loop
0174+  0F63             _gets_escape:
0175+  0F63 19 01         mov al, 1
0176+  0F65 05 03         syscall sys_io      ; receive in AH
0177+  0F67 B9 00         cmp al, 0        ; check error code (AL)
0178+  0F69 C6 63 0F      je _gets_escape      ; if no char received, retry
0179+  0F6C 76 6E         cmp ah, 'n'
0180+  0F6E C6 8D 0F      je _gets_LF
0181+  0F71 76 72         cmp ah, 'r'
0182+  0F73 C6 94 0F      je _gets_CR
0183+  0F76 76 30         cmp ah, '0'
0184+  0F78 C6 9B 0F      je _gets_NULL
0185+  0F7B 76 5C         cmp ah, $5C  ; '\'
0186+  0F7D C6 86 0F      je _gets_slash
0187+  0F80 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0188+  0F81 3E            mov [d], al
0189+  0F82 79            inc d
0190+  0F83 0A 0B 0F      jmp _gets_loop
0191+  0F86             _gets_slash:
0192+  0F86 19 5C         mov al, $5C
0193+  0F88 3E            mov [d], al
0194+  0F89 79            inc d
0195+  0F8A 0A 0B 0F      jmp _gets_loop
0196+  0F8D             _gets_LF:
0197+  0F8D 19 0A         mov al, $0A
0198+  0F8F 3E            mov [d], al
0199+  0F90 79            inc d
0200+  0F91 0A 0B 0F      jmp _gets_loop
0201+  0F94             _gets_CR:
0202+  0F94 19 0D         mov al, $0D
0203+  0F96 3E            mov [d], al
0204+  0F97 79            inc d
0205+  0F98 0A 0B 0F      jmp _gets_loop
0206+  0F9B             _gets_NULL:
0207+  0F9B 19 00         mov al, $00
0208+  0F9D 3E            mov [d], al
0209+  0F9E 79            inc d
0210+  0F9F 0A 0B 0F      jmp _gets_loop
0211+  0FA2             _gets_end:
0212+  0FA2 19 00         mov al, 0
0213+  0FA4 3E            mov [d], al        ; terminate string
0214+  0FA5 E7            pop d
0215+  0FA6 E4            pop a
0216+  0FA7 09            ret
0217+  0FA8             
0218+  0FA8             
0219+  0FA8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0220+  0FA8             ;; INPUT TEXT
0221+  0FA8             ;; terminated with CTRL+D
0222+  0FA8             ;; pointer in D
0223+  0FA8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0224+  0FA8             _gettxt:
0225+  0FA8 D7            push a
0226+  0FA9 DA            push d
0227+  0FAA             _gettxt_loop:
0228+  0FAA 19 01         mov al, 1
0229+  0FAC 05 03         syscall sys_io      ; receive in AH
0230+  0FAE B9 00         cmp al, 0        ; check error code (AL)
0231+  0FB0 C6 AA 0F      je _gettxt_loop    ; if no char received, retry
0232+  0FB3 76 04         cmp ah, 4      ; EOT
0233+  0FB5 C6 F3 0F      je _gettxt_end
0234+  0FB8 76 08         cmp ah, $08      ; check for backspace
0235+  0FBA C6 EF 0F      je _gettxt_backspace
0236+  0FBD 76 5C         cmp ah, $5C        ; '\'
0237+  0FBF C6 C8 0F      je _gettxt_escape
0238+  0FC2 1A            mov al, ah
0239+  0FC3 3E            mov [d], al
0240+  0FC4 79            inc d
0241+  0FC5 0A AA 0F      jmp _gettxt_loop
0242+  0FC8             _gettxt_escape:
0243+  0FC8 19 01         mov al, 1
0244+  0FCA 05 03         syscall sys_io      ; receive in AH
0245+  0FCC B9 00         cmp al, 0        ; check error code (AL)
0246+  0FCE C6 C8 0F      je _gettxt_escape    ; if no char received, retry
0247+  0FD1 76 6E         cmp ah, 'n'
0248+  0FD3 C6 E1 0F      je _gettxt_LF
0249+  0FD6 76 72         cmp ah, 'r'
0250+  0FD8 C6 E8 0F      je _gettxt_CR
0251+  0FDB 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0252+  0FDC 3E            mov [d], al
0253+  0FDD 79            inc d
0254+  0FDE 0A AA 0F      jmp _gettxt_loop
0255+  0FE1             _gettxt_LF:
0256+  0FE1 19 0A         mov al, $0A
0257+  0FE3 3E            mov [d], al
0258+  0FE4 79            inc d
0259+  0FE5 0A AA 0F      jmp _gettxt_loop
0260+  0FE8             _gettxt_CR:
0261+  0FE8 19 0D         mov al, $0D
0262+  0FEA 3E            mov [d], al
0263+  0FEB 79            inc d
0264+  0FEC 0A AA 0F      jmp _gettxt_loop
0265+  0FEF             _gettxt_backspace:
0266+  0FEF 7F            dec d
0267+  0FF0 0A AA 0F      jmp _gettxt_loop
0268+  0FF3             _gettxt_end:
0269+  0FF3 19 00         mov al, 0
0270+  0FF5 3E            mov [d], al        ; terminate string
0271+  0FF6 E7            pop d
0272+  0FF7 E4            pop a
0273+  0FF8 09            ret
0274+  0FF9             
0275+  0FF9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  0FF9             ; PRINT NEW LINE
0277+  0FF9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0278+  0FF9             printnl:
0279+  0FF9 D7            push a
0280+  0FFA 10 00 0A      mov a, $0A00
0281+  0FFD 05 03         syscall sys_io
0282+  0FFF 10 00 0D      mov a, $0D00
0283+  1002 05 03         syscall sys_io
0284+  1004 E4            pop a
0285+  1005 09            ret
0286+  1006             
0287+  1006             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  1006             ; _strtoint
0289+  1006             ; 4 digit hex string number in d
0290+  1006             ; integer returned in A
0291+  1006             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0292+  1006             _strtointx:
0293+  1006 D8            push b
0294+  1007 32            mov bl, [d]
0295+  1008 37            mov bh, bl
0296+  1009 33 01 00      mov bl, [d + 1]
0297+  100C 07 BF 0E      call _atoi        ; convert to int in AL
0298+  100F 23            mov ah, al        ; move to AH
0299+  1010 33 02 00      mov bl, [d + 2]
0300+  1013 37            mov bh, bl
0301+  1014 33 03 00      mov bl, [d + 3]
0302+  1017 07 BF 0E      call _atoi        ; convert to int in AL
0303+  101A E5            pop b
0304+  101B 09            ret
0305+  101C             
0306+  101C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0307+  101C             ; _strtoint
0308+  101C             ; 5 digit base10 string number in d
0309+  101C             ; integer returned in A
0310+  101C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0311+  101C             _strtoint:
0312+  101C E2            push si
0313+  101D D8            push b
0314+  101E D9            push c
0315+  101F DA            push d
0316+  1020 07 61 0E      call _strlen      ; get string length in C
0317+  1023 7E            dec c
0318+  1024 FD 4E         mov si, d
0319+  1026 12            mov a, c
0320+  1027 FD 99         shl a
0321+  1029 3B 98 11      mov d, table_power
0322+  102C 59            add d, a
0323+  102D 38 00 00      mov c, 0
0324+  1030             _strtoint_L0:
0325+  1030 F6            lodsb      ; load ASCII to al
0326+  1031 B9 00         cmp al, 0
0327+  1033 C6 46 10      je _strtoint_end
0328+  1036 6F 30         sub al, $30    ; make into integer
0329+  1038 22 00         mov ah, 0
0330+  103A 2A            mov b, [d]
0331+  103B AC            mul a, b      ; result in B since it fits in 16bits
0332+  103C 11            mov a, b
0333+  103D 28            mov b, c
0334+  103E 54            add a, b
0335+  103F 39            mov c, a
0336+  1040 63 02 00      sub d, 2
0337+  1043 0A 30 10      jmp _strtoint_L0
0338+  1046             _strtoint_end:
0339+  1046 12            mov a, c
0340+  1047 E7            pop d
0341+  1048 E6            pop c
0342+  1049 E5            pop b
0343+  104A EF            pop si
0344+  104B 09            ret
0345+  104C             
0346+  104C             
0347+  104C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0348+  104C             ; PRINT NULL TERMINATED STRING
0349+  104C             ; pointer in D
0350+  104C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0351+  104C             _puts:
0352+  104C D7            push a
0353+  104D DA            push d
0354+  104E             _puts_L1:
0355+  104E 1E            mov al, [d]
0356+  104F B9 00         cmp al, 0
0357+  1051 C6 5D 10      jz _puts_END
0358+  1054 23            mov ah, al
0359+  1055 19 00         mov al, 0
0360+  1057 05 03         syscall sys_io
0361+  1059 79            inc d
0362+  105A 0A 4E 10      jmp _puts_L1
0363+  105D             _puts_END:
0364+  105D E7            pop d
0365+  105E E4            pop a
0366+  105F 09            ret
0367+  1060             
0368+  1060             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0369+  1060             ; PRINT N SIZE STRING
0370+  1060             ; pointer in D
0371+  1060             ; size in C
0372+  1060             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0373+  1060             _putsn:
0374+  1060 DB            push al
0375+  1061 DA            push d
0376+  1062 D9            push c
0377+  1063             _putsn_L0:
0378+  1063 1E            mov al, [d]
0379+  1064 23            mov ah, al
0380+  1065 19 00         mov al, 0
0381+  1067 05 03         syscall sys_io
0382+  1069 79            inc d
0383+  106A 7E            dec c  
0384+  106B C2 00 00      cmp c, 0
0385+  106E C7 63 10      jne _putsn_L0
0386+  1071             _putsn_end:
0387+  1071 E6            pop c
0388+  1072 E7            pop d
0389+  1073 E8            pop al
0390+  1074 09            ret
0391+  1075             
0392+  1075             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0393+  1075             ; print 16bit decimal number
0394+  1075             ; input number in A
0395+  1075             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0396+  1075             print_u16d:
0397+  1075 D7            push a
0398+  1076 D8            push b
0399+  1077 26 10 27      mov b, 10000
0400+  107A AE            div a, b      ; get 10000's coeff.
0401+  107B 07 9D 10      call print_number
0402+  107E 11            mov a, b
0403+  107F 26 E8 03      mov b, 1000
0404+  1082 AE            div a, b      ; get 1000's coeff.
0405+  1083 07 9D 10      call print_number
0406+  1086 11            mov a, b
0407+  1087 26 64 00      mov b, 100
0408+  108A AE            div a, b
0409+  108B 07 9D 10      call print_number
0410+  108E 11            mov a, b
0411+  108F 26 0A 00      mov b, 10
0412+  1092 AE            div a, b
0413+  1093 07 9D 10      call print_number
0414+  1096 1B            mov al, bl      ; 1's coeff in bl
0415+  1097 07 9D 10      call print_number
0416+  109A E5            pop b
0417+  109B E4            pop a
0418+  109C 09            ret
0419+  109D             
0420+  109D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0421+  109D             ; print AL
0422+  109D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0423+  109D             print_number:
0424+  109D 6A 30         add al, $30
0425+  109F 23            mov ah, al
0426+  10A0 07 02 0F      call _putchar
0427+  10A3 09            ret
0428+  10A4             
0429+  10A4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0430+  10A4             ; PRINT 16BIT HEX INTEGER
0431+  10A4             ; integer value in reg B
0432+  10A4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  10A4             print_u16x:
0434+  10A4 D7            push a
0435+  10A5 D8            push b
0436+  10A6 DD            push bl
0437+  10A7 30            mov bl, bh
0438+  10A8 07 D0 0E      call _itoa        ; convert bh to char in A
0439+  10AB 2F            mov bl, al        ; save al
0440+  10AC 19 00         mov al, 0
0441+  10AE 05 03         syscall sys_io        ; display AH
0442+  10B0 24            mov ah, bl        ; retrieve al
0443+  10B1 19 00         mov al, 0
0444+  10B3 05 03         syscall sys_io        ; display AL
0445+  10B5             
0446+  10B5 EA            pop bl
0447+  10B6 07 D0 0E      call _itoa        ; convert bh to char in A
0448+  10B9 2F            mov bl, al        ; save al
0449+  10BA 19 00         mov al, 0
0450+  10BC 05 03         syscall sys_io        ; display AH
0451+  10BE 24            mov ah, bl        ; retrieve al
0452+  10BF 19 00         mov al, 0
0453+  10C1 05 03         syscall sys_io        ; display AL
0454+  10C3             
0455+  10C3 E5            pop b
0456+  10C4 E4            pop a
0457+  10C5 09            ret
0458+  10C6             
0459+  10C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0460+  10C6             ; INPUT 16BIT HEX INTEGER
0461+  10C6             ; read 16bit integer into A
0462+  10C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0463+  10C6             scan_u16x:
0464+  10C6 F8 10 00      enter 16
0465+  10C9 D8            push b
0466+  10CA DA            push d
0467+  10CB             
0468+  10CB FA F1 FF      lea d, [bp + -15]
0469+  10CE 07 09 0F      call _gets        ; get number
0470+  10D1             
0471+  10D1 32            mov bl, [d]
0472+  10D2 37            mov bh, bl
0473+  10D3 33 01 00      mov bl, [d + 1]
0474+  10D6 07 BF 0E      call _atoi        ; convert to int in AL
0475+  10D9 23            mov ah, al        ; move to AH
0476+  10DA             
0477+  10DA 33 02 00      mov bl, [d + 2]
0478+  10DD 37            mov bh, bl
0479+  10DE 33 03 00      mov bl, [d + 3]
0480+  10E1 07 BF 0E      call _atoi        ; convert to int in AL
0481+  10E4             
0482+  10E4 E7            pop d
0483+  10E5 E5            pop b
0484+  10E6 F9            leave
0485+  10E7 09            ret
0486+  10E8             
0487+  10E8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0488+  10E8             ; PRINT 8bit HEX INTEGER
0489+  10E8             ; integer value in reg bl
0490+  10E8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0491+  10E8             print_u8x:
0492+  10E8 D7            push a
0493+  10E9 DD            push bl
0494+  10EA             
0495+  10EA 07 D0 0E      call _itoa        ; convert bl to char in A
0496+  10ED 2F            mov bl, al        ; save al
0497+  10EE 19 00         mov al, 0
0498+  10F0 05 03         syscall sys_io        ; display AH
0499+  10F2 24            mov ah, bl        ; retrieve al
0500+  10F3 19 00         mov al, 0
0501+  10F5 05 03         syscall sys_io        ; display AL
0502+  10F7             
0503+  10F7 EA            pop bl
0504+  10F8 E4            pop a
0505+  10F9 09            ret
0506+  10FA             
0507+  10FA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0508+  10FA             ; print 8bit decimal unsigned number
0509+  10FA             ; input number in AL
0510+  10FA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0511+  10FA             print_u8d:
0512+  10FA D7            push a
0513+  10FB D8            push b
0514+  10FC             
0515+  10FC 22 00         mov ah, 0
0516+  10FE 26 64 00      mov b, 100
0517+  1101 AE            div a, b
0518+  1102 D8            push b      ; save remainder
0519+  1103 B9 00         cmp al, 0
0520+  1105 C6 0F 11      je skip100
0521+  1108 6A 30         add al, $30
0522+  110A 23            mov ah, al
0523+  110B 19 00         mov al, 0
0524+  110D 05 03         syscall sys_io  ; print coeff
0525+  110F             skip100:
0526+  110F E4            pop a
0527+  1110 22 00         mov ah, 0
0528+  1112 26 0A 00      mov b, 10
0529+  1115 AE            div a, b
0530+  1116 D8            push b      ; save remainder
0531+  1117 B9 00         cmp al, 0
0532+  1119 C6 23 11      je skip10
0533+  111C 6A 30         add al, $30
0534+  111E 23            mov ah, al
0535+  111F 19 00         mov al, 0
0536+  1121 05 03         syscall sys_io  ; print coeff
0537+  1123             skip10:
0538+  1123 E4            pop a
0539+  1124 1B            mov al, bl
0540+  1125 6A 30         add al, $30
0541+  1127 23            mov ah, al
0542+  1128 19 00         mov al, 0
0543+  112A 05 03         syscall sys_io  ; print coeff
0544+  112C E5            pop b
0545+  112D E4            pop a
0546+  112E 09            ret
0547+  112F             
0548+  112F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0549+  112F             ; INPUT 8BIT HEX INTEGER
0550+  112F             ; read 8bit integer into AL
0551+  112F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0552+  112F             scan_u8x:
0553+  112F F8 04 00      enter 4
0554+  1132 D8            push b
0555+  1133 DA            push d
0556+  1134             
0557+  1134 FA FD FF      lea d, [bp + -3]
0558+  1137 07 09 0F      call _gets        ; get number
0559+  113A             
0560+  113A 32            mov bl, [d]
0561+  113B 37            mov bh, bl
0562+  113C 33 01 00      mov bl, [d + 1]
0563+  113F 07 BF 0E      call _atoi        ; convert to int in AL
0564+  1142             
0565+  1142 E7            pop d
0566+  1143 E5            pop b
0567+  1144 F9            leave
0568+  1145 09            ret
0569+  1146             
0570+  1146             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  1146             ; input decimal number
0572+  1146             ; result in A
0573+  1146             ; 655'\0'
0574+  1146             ; low--------high
0575+  1146             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0576+  1146             scan_u16d:
0577+  1146 F8 08 00      enter 8
0578+  1149 E2            push si
0579+  114A D8            push b
0580+  114B D9            push c
0581+  114C DA            push d
0582+  114D FA F9 FF      lea d, [bp +- 7]
0583+  1150 07 09 0F      call _gets
0584+  1153 07 61 0E      call _strlen      ; get string length in C
0585+  1156 7E            dec c
0586+  1157 FD 4E         mov si, d
0587+  1159 12            mov a, c
0588+  115A FD 99         shl a
0589+  115C 3B 98 11      mov d, table_power
0590+  115F 59            add d, a
0591+  1160 38 00 00      mov c, 0
0592+  1163             mul_loop:
0593+  1163 F6            lodsb      ; load ASCII to al
0594+  1164 B9 00         cmp al, 0
0595+  1166 C6 79 11      je mul_exit
0596+  1169 6F 30         sub al, $30    ; make into integer
0597+  116B 22 00         mov ah, 0
0598+  116D 2A            mov b, [d]
0599+  116E AC            mul a, b      ; result in B since it fits in 16bits
0600+  116F 11            mov a, b
0601+  1170 28            mov b, c
0602+  1171 54            add a, b
0603+  1172 39            mov c, a
0604+  1173 63 02 00      sub d, 2
0605+  1176 0A 63 11      jmp mul_loop
0606+  1179             mul_exit:
0607+  1179 12            mov a, c
0608+  117A E7            pop d
0609+  117B E6            pop c
0610+  117C E5            pop b
0611+  117D EF            pop si
0612+  117E F9            leave
0613+  117F 09            ret
0614+  1180             
0615+  1180             
0616+  1180 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0616+  1184 34 35 36 37 
0616+  1188 38 39 41 42 
0616+  118C 43 44 45 46 
0617+  1190 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0617+  1194 1B 5B 48 00 
0618+  1198             
0619+  1198             table_power:
0620+  1198 01 00         .dw 1
0621+  119A 0A 00         .dw 10
0622+  119C 64 00         .dw 100
0623+  119E E8 03         .dw 1000
0624+  11A0 10 27         .dw 100001895   11A2             ; --- END INLINE ASM BLOCK
1896   11A2             
1897   11A2 F9            leave
1898   11A3 09            ret
1899   11A4             
1900   11A4             sqrt:
1901   11A4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1902   11A7             ; $x 
1903   11A7             ; $y 
1904   11A7 52 04 00      sub sp, 4
1905   11AA             ;; if (n <= 1) { 
1906   11AA             _if25_cond:
1907   11AA FA 05 00      lea d, [bp + 5] ; $n
1908   11AD 2A            mov b, [d]
1909   11AE             ; START RELATIONAL
1910   11AE D7            push a
1911   11AF 11            mov a, b
1912   11B0 26 01 00      mov b, $1
1913   11B3 B0            cmp a, b
1914   11B4 FD 74         sle ; <=
1915   11B6 E4            pop a
1916   11B7             ; END RELATIONAL
1917   11B7 C0 00 00      cmp b, 0
1918   11BA C6 C6 11      je _if25_exit
1919   11BD             _if25_true:
1920   11BD             ;; return n; 
1921   11BD FA 05 00      lea d, [bp + 5] ; $n
1922   11C0 2A            mov b, [d]
1923   11C1 F9            leave
1924   11C2 09            ret
1925   11C3 0A C6 11      jmp _if25_exit
1926   11C6             _if25_exit:
1927   11C6             ;; x = n; 
1928   11C6 FA FF FF      lea d, [bp + -1] ; $x
1929   11C9 DA            push d
1930   11CA FA 05 00      lea d, [bp + 5] ; $n
1931   11CD 2A            mov b, [d]
1932   11CE E7            pop d
1933   11CF FD 43         mov [d], b
1934   11D1             ;; y = (x + n / x) / 2; 
1935   11D1 FA FD FF      lea d, [bp + -3] ; $y
1936   11D4 DA            push d
1937   11D5 FA FF FF      lea d, [bp + -1] ; $x
1938   11D8 2A            mov b, [d]
1939   11D9             ; START TERMS
1940   11D9 D7            push a
1941   11DA 11            mov a, b
1942   11DB FA 05 00      lea d, [bp + 5] ; $n
1943   11DE 2A            mov b, [d]
1944   11DF             ; START FACTORS
1945   11DF D7            push a
1946   11E0 11            mov a, b
1947   11E1 FA FF FF      lea d, [bp + -1] ; $x
1948   11E4 2A            mov b, [d]
1949   11E5 AE            div a, b
1950   11E6 27            mov b, a
1951   11E7 E4            pop a
1952   11E8             ; END FACTORS
1953   11E8 54            add a, b
1954   11E9 27            mov b, a
1955   11EA E4            pop a
1956   11EB             ; END TERMS
1957   11EB             ; START FACTORS
1958   11EB D7            push a
1959   11EC 11            mov a, b
1960   11ED 26 02 00      mov b, $2
1961   11F0 AE            div a, b
1962   11F1 27            mov b, a
1963   11F2 E4            pop a
1964   11F3             ; END FACTORS
1965   11F3 E7            pop d
1966   11F4 FD 43         mov [d], b
1967   11F6             ;; while (y < x) { 
1968   11F6             _while26_cond:
1969   11F6 FA FD FF      lea d, [bp + -3] ; $y
1970   11F9 2A            mov b, [d]
1971   11FA             ; START RELATIONAL
1972   11FA D7            push a
1973   11FB 11            mov a, b
1974   11FC FA FF FF      lea d, [bp + -1] ; $x
1975   11FF 2A            mov b, [d]
1976   1200 B0            cmp a, b
1977   1201 FD 73         slt ; < 
1978   1203 E4            pop a
1979   1204             ; END RELATIONAL
1980   1204 C0 00 00      cmp b, 0
1981   1207 C6 3D 12      je _while26_exit
1982   120A             _while26_block:
1983   120A             ;; x = y; 
1984   120A FA FF FF      lea d, [bp + -1] ; $x
1985   120D DA            push d
1986   120E FA FD FF      lea d, [bp + -3] ; $y
1987   1211 2A            mov b, [d]
1988   1212 E7            pop d
1989   1213 FD 43         mov [d], b
1990   1215             ;; y = (x + n / x) / 2; 
1991   1215 FA FD FF      lea d, [bp + -3] ; $y
1992   1218 DA            push d
1993   1219 FA FF FF      lea d, [bp + -1] ; $x
1994   121C 2A            mov b, [d]
1995   121D             ; START TERMS
1996   121D D7            push a
1997   121E 11            mov a, b
1998   121F FA 05 00      lea d, [bp + 5] ; $n
1999   1222 2A            mov b, [d]
2000   1223             ; START FACTORS
2001   1223 D7            push a
2002   1224 11            mov a, b
2003   1225 FA FF FF      lea d, [bp + -1] ; $x
2004   1228 2A            mov b, [d]
2005   1229 AE            div a, b
2006   122A 27            mov b, a
2007   122B E4            pop a
2008   122C             ; END FACTORS
2009   122C 54            add a, b
2010   122D 27            mov b, a
2011   122E E4            pop a
2012   122F             ; END TERMS
2013   122F             ; START FACTORS
2014   122F D7            push a
2015   1230 11            mov a, b
2016   1231 26 02 00      mov b, $2
2017   1234 AE            div a, b
2018   1235 27            mov b, a
2019   1236 E4            pop a
2020   1237             ; END FACTORS
2021   1237 E7            pop d
2022   1238 FD 43         mov [d], b
2023   123A 0A F6 11      jmp _while26_cond
2024   123D             _while26_exit:
2025   123D             ;; return x; 
2026   123D FA FF FF      lea d, [bp + -1] ; $x
2027   1240 2A            mov b, [d]
2028   1241 F9            leave
2029   1242 09            ret
2030   1243             
2031   1243             exp:
2032   1243 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2033   1246             ; $i 
2034   1246             ; $result 
2035   1246 10 01 00      mov a, $1
2036   1249 45 FD FF      mov [bp + -3], a
2037   124C 52 04 00      sub sp, 4
2038   124F             ;; for(i = 0; i < exp; i++){ 
2039   124F             _for27_init:
2040   124F FA FF FF      lea d, [bp + -1] ; $i
2041   1252 DA            push d
2042   1253 26 00 00      mov b, $0
2043   1256 E7            pop d
2044   1257 FD 43         mov [d], b
2045   1259             _for27_cond:
2046   1259 FA FF FF      lea d, [bp + -1] ; $i
2047   125C 2A            mov b, [d]
2048   125D             ; START RELATIONAL
2049   125D D7            push a
2050   125E 11            mov a, b
2051   125F FA 05 00      lea d, [bp + 5] ; $exp
2052   1262 2A            mov b, [d]
2053   1263 B0            cmp a, b
2054   1264 FD 73         slt ; < 
2055   1266 E4            pop a
2056   1267             ; END RELATIONAL
2057   1267 C0 00 00      cmp b, 0
2058   126A C6 94 12      je _for27_exit
2059   126D             _for27_block:
2060   126D             ;; result = result * base; 
2061   126D FA FD FF      lea d, [bp + -3] ; $result
2062   1270 DA            push d
2063   1271 FA FD FF      lea d, [bp + -3] ; $result
2064   1274 2A            mov b, [d]
2065   1275             ; START FACTORS
2066   1275 D7            push a
2067   1276 11            mov a, b
2068   1277 FA 07 00      lea d, [bp + 7] ; $base
2069   127A 2A            mov b, [d]
2070   127B AC            mul a, b ; *
2071   127C 11            mov a, b
2072   127D 27            mov b, a
2073   127E E4            pop a
2074   127F             ; END FACTORS
2075   127F E7            pop d
2076   1280 FD 43         mov [d], b
2077   1282             _for27_update:
2078   1282 FA FF FF      lea d, [bp + -1] ; $i
2079   1285 2A            mov b, [d]
2080   1286 FD 79         mov g, b
2081   1288 FD 77         inc b
2082   128A FA FF FF      lea d, [bp + -1] ; $i
2083   128D FD 43         mov [d], b
2084   128F FD 27         mov b, g
2085   1291 0A 59 12      jmp _for27_cond
2086   1294             _for27_exit:
2087   1294             ;; return result; 
2088   1294 FA FD FF      lea d, [bp + -3] ; $result
2089   1297 2A            mov b, [d]
2090   1298 F9            leave
2091   1299 09            ret
2092   129A             ; --- END TEXT BLOCK
2093   129A             
2094   129A             ; --- BEGIN DATA BLOCK
2095   129A 55 6E 6B 6E __s0: .db "Unknown type size in va_arg() call. Size needs to be either 1 or 2.", 0
2095   129E 6F 77 6E 20 
2095   12A2 74 79 70 65 
2095   12A6 20 73 69 7A 
2095   12AA 65 20 69 6E 
2095   12AE 20 76 61 5F 
2095   12B2 61 72 67 28 
2095   12B6 29 20 63 61 
2095   12BA 6C 6C 2E 20 
2095   12BE 53 69 7A 65 
2095   12C2 20 6E 65 65 
2095   12C6 64 73 20 74 
2095   12CA 6F 20 62 65 
2095   12CE 20 65 69 74 
2095   12D2 68 65 72 20 
2095   12D6 31 20 6F 72 
2095   12DA 20 32 2E 00 
2096   12DE 45 72 72 6F __s1: .db "Error: Unknown argument type.\n", 0
2096   12E2 72 3A 20 55 
2096   12E6 6E 6B 6E 6F 
2096   12EA 77 6E 20 61 
2096   12EE 72 67 75 6D 
2096   12F2 65 6E 74 20 
2096   12F6 74 79 70 65 
2096   12FA 2E 0A 00 
2097   12FD 1B 5B 32 4A __s2: .db "\033[2J\033[H", 0
2097   1301 1B 5B 48 00 
2098   1305 0A 00       __s3: .db "\n", 0
2099   1307             
2100   1307 09 13       _heap_top: .dw _heap
2101   1309 00          _heap: .db 0
2102   130A             ; --- END DATA BLOCK
2103   130A             
2104   130A             .end
tasm: Number of errors = 0
