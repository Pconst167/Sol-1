0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT SEGMENT
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; printf("Hi"); 
0011   0408             ; --- START FUNCTION CALL
0012   0408 26 03 0D      mov b, _s0 ; "Hi"
0013   040B FD AB         swp b
0014   040D D8            push b
0015   040E 07 16 04      call printf
0016   0411 51 02 00      add sp, 2
0017   0414             ; --- END FUNCTION CALL
0018   0414 05 0B         syscall sys_terminate_proc
0019   0416             
0020   0416             printf:
0021   0416 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0022   0419             ; char *p, *format_p; 
0023   0419 52 02 00      sub sp, 2
0024   041C 52 02 00      sub sp, 2
0025   041F             ; format_p = format; 
0026   041F FA FD FF      lea d, [bp + -3] ; $format_p
0027   0422 DA            push d
0028   0423 FA 05 00      lea d, [bp + 5] ; $format
0029   0426 2A            mov b, [d]
0030   0427 38 00 00      mov c, 0
0031   042A E7            pop d
0032   042B FD 43         mov [d], b
0033   042D             ; p = &format + 2; 
0034   042D FA FF FF      lea d, [bp + -1] ; $p
0035   0430 DA            push d
0036   0431 FA 05 00      lea d, [bp + 5] ; $format
0037   0434 2D            mov b, d
0038   0435             ; --- START TERMS
0039   0435 D7            push a
0040   0436 11            mov a, b
0041   0437 FD 2E 02 00   mov32 cb, $00000002
0041   043B 00 00 
0042   043D 56            add b, a
0043   043E E4            pop a
0044   043F             ; --- END TERMS
0045   043F E7            pop d
0046   0440 FD 43         mov [d], b
0047   0442             ; for(;;){ 
0048   0442             _for1_init:
0049   0442             _for1_cond:
0050   0442             _for1_block:
0051   0442             ; if(!*format_p) break; 
0052   0442             _if2_cond:
0053   0442 FA FD FF      lea d, [bp + -3] ; $format_p
0054   0445 2A            mov b, [d]
0055   0446 38 00 00      mov c, 0
0056   0449 74            mov d, b
0057   044A 32            mov bl, [d]
0058   044B A7 00         mov bh, 0
0059   044D 38 00 00      mov c, 0
0060   0450 C0 00 00      cmp b, 0
0061   0453 FD 71         seq ; !
0062   0455 C0 00 00      cmp b, 0
0063   0458 C6 61 04      je _if2_else
0064   045B             _if2_TRUE:
0065   045B             ; break; 
0066   045B 0A 11 07      jmp _for1_exit ; for break
0067   045E 0A 0E 07      jmp _if2_exit
0068   0461             _if2_else:
0069   0461             ; if(*format_p == '%'){ 
0070   0461             _if3_cond:
0071   0461 FA FD FF      lea d, [bp + -3] ; $format_p
0072   0464 2A            mov b, [d]
0073   0465 38 00 00      mov c, 0
0074   0468 74            mov d, b
0075   0469 32            mov bl, [d]
0076   046A A7 00         mov bh, 0
0077   046C 38 00 00      mov c, 0
0078   046F             ; --- START RELATIONAL
0079   046F D7            push a
0080   0470 11            mov a, b
0081   0471 FD 2E 25 00   mov32 cb, $00000025
0081   0475 00 00 
0082   0477 B0            cmp a, b
0083   0478 FD 71         seq ; ==
0084   047A E4            pop a
0085   047B             ; --- END RELATIONAL
0086   047B C0 00 00      cmp b, 0
0087   047E C6 E9 06      je _if3_else
0088   0481             _if3_TRUE:
0089   0481             ; format_p++; 
0090   0481 FA FD FF      lea d, [bp + -3] ; $format_p
0091   0484 2A            mov b, [d]
0092   0485 38 00 00      mov c, 0
0093   0488 FD 77         inc b
0094   048A FA FD FF      lea d, [bp + -3] ; $format_p
0095   048D FD 43         mov [d], b
0096   048F FD 7D         dec b
0097   0491             ; switch(*format_p){ 
0098   0491             _switch4_expr:
0099   0491 FA FD FF      lea d, [bp + -3] ; $format_p
0100   0494 2A            mov b, [d]
0101   0495 38 00 00      mov c, 0
0102   0498 74            mov d, b
0103   0499 32            mov bl, [d]
0104   049A A7 00         mov bh, 0
0105   049C 38 00 00      mov c, 0
0106   049F             _switch4_comparisons:
0107   049F C1 6C         cmp bl, $6c
0108   04A1 C6 CD 04      je _switch4_case0
0109   04A4 C1 4C         cmp bl, $4c
0110   04A6 C6 CD 04      je _switch4_case1
0111   04A9 C1 64         cmp bl, $64
0112   04AB C6 DD 05      je _switch4_case2
0113   04AE C1 69         cmp bl, $69
0114   04B0 C6 DD 05      je _switch4_case3
0115   04B3 C1 75         cmp bl, $75
0116   04B5 C6 0D 06      je _switch4_case4
0117   04B8 C1 78         cmp bl, $78
0118   04BA C6 3D 06      je _switch4_case5
0119   04BD C1 63         cmp bl, $63
0120   04BF C6 6D 06      je _switch4_case6
0121   04C2 C1 73         cmp bl, $73
0122   04C4 C6 9D 06      je _switch4_case7
0123   04C7 0A CA 06      jmp _switch4_default
0124   04CA 0A D6 06      jmp _switch4_exit
0125   04CD             _switch4_case0:
0126   04CD             _switch4_case1:
0127   04CD             ; format_p++; 
0128   04CD FA FD FF      lea d, [bp + -3] ; $format_p
0129   04D0 2A            mov b, [d]
0130   04D1 38 00 00      mov c, 0
0131   04D4 FD 77         inc b
0132   04D6 FA FD FF      lea d, [bp + -3] ; $format_p
0133   04D9 FD 43         mov [d], b
0134   04DB FD 7D         dec b
0135   04DD             ; if(*format_p == 'd' || *format_p == 'i') 
0136   04DD             _if5_cond:
0137   04DD FA FD FF      lea d, [bp + -3] ; $format_p
0138   04E0 2A            mov b, [d]
0139   04E1 38 00 00      mov c, 0
0140   04E4 74            mov d, b
0141   04E5 32            mov bl, [d]
0142   04E6 A7 00         mov bh, 0
0143   04E8 38 00 00      mov c, 0
0144   04EB             ; --- START RELATIONAL
0145   04EB D7            push a
0146   04EC 11            mov a, b
0147   04ED FD 2E 64 00   mov32 cb, $00000064
0147   04F1 00 00 
0148   04F3 B0            cmp a, b
0149   04F4 FD 71         seq ; ==
0150   04F6 E4            pop a
0151   04F7             ; --- END RELATIONAL
0152   04F7             ; --- START LOGICAL OR
0153   04F7 D7            push a
0154   04F8 11            mov a, b
0155   04F9 FA FD FF      lea d, [bp + -3] ; $format_p
0156   04FC 2A            mov b, [d]
0157   04FD 38 00 00      mov c, 0
0158   0500 74            mov d, b
0159   0501 32            mov bl, [d]
0160   0502 A7 00         mov bh, 0
0161   0504 38 00 00      mov c, 0
0162   0507             ; --- START RELATIONAL
0163   0507 D7            push a
0164   0508 11            mov a, b
0165   0509 FD 2E 69 00   mov32 cb, $00000069
0165   050D 00 00 
0166   050F B0            cmp a, b
0167   0510 FD 71         seq ; ==
0168   0512 E4            pop a
0169   0513             ; --- END RELATIONAL
0170   0513 FD A8         sor a, b ; ||
0171   0515 E4            pop a
0172   0516             ; --- END LOGICAL OR
0173   0516 C0 00 00      cmp b, 0
0174   0519 C6 3A 05      je _if5_else
0175   051C             _if5_TRUE:
0176   051C             ; print_signed_long(*(long *)p); 
0177   051C             ; --- START FUNCTION CALL
0178   051C FA FF FF      lea d, [bp + -1] ; $p
0179   051F 2A            mov b, [d]
0180   0520 38 00 00      mov c, 0
0181   0523 74            mov d, b
0182   0524 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0183   0527 FD 39         mov c, b ; And place it into C
0184   0529 2A            mov b, [d] ; Lower Word in B
0185   052A 12            mov a, c
0186   052B FD AA         swp a
0187   052D D7            push a
0188   052E FD AB         swp b
0189   0530 D8            push b
0190   0531 07 13 07      call print_signed_long
0191   0534 51 04 00      add sp, 4
0192   0537             ; --- END FUNCTION CALL
0193   0537 0A C2 05      jmp _if5_exit
0194   053A             _if5_else:
0195   053A             ; if(*format_p == 'u') 
0196   053A             _if6_cond:
0197   053A FA FD FF      lea d, [bp + -3] ; $format_p
0198   053D 2A            mov b, [d]
0199   053E 38 00 00      mov c, 0
0200   0541 74            mov d, b
0201   0542 32            mov bl, [d]
0202   0543 A7 00         mov bh, 0
0203   0545 38 00 00      mov c, 0
0204   0548             ; --- START RELATIONAL
0205   0548 D7            push a
0206   0549 11            mov a, b
0207   054A FD 2E 75 00   mov32 cb, $00000075
0207   054E 00 00 
0208   0550 B0            cmp a, b
0209   0551 FD 71         seq ; ==
0210   0553 E4            pop a
0211   0554             ; --- END RELATIONAL
0212   0554 C0 00 00      cmp b, 0
0213   0557 C6 78 05      je _if6_else
0214   055A             _if6_TRUE:
0215   055A             ; print_unsigned_long(*(unsigned long *)p); 
0216   055A             ; --- START FUNCTION CALL
0217   055A FA FF FF      lea d, [bp + -1] ; $p
0218   055D 2A            mov b, [d]
0219   055E 38 00 00      mov c, 0
0220   0561 74            mov d, b
0221   0562 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0222   0565 FD 39         mov c, b ; And place it into C
0223   0567 2A            mov b, [d] ; Lower Word in B
0224   0568 12            mov a, c
0225   0569 FD AA         swp a
0226   056B D7            push a
0227   056C FD AB         swp b
0228   056E D8            push b
0229   056F 07 9E 08      call print_unsigned_long
0230   0572 51 04 00      add sp, 4
0231   0575             ; --- END FUNCTION CALL
0232   0575 0A C2 05      jmp _if6_exit
0233   0578             _if6_else:
0234   0578             ; if(*format_p == 'x') 
0235   0578             _if7_cond:
0236   0578 FA FD FF      lea d, [bp + -3] ; $format_p
0237   057B 2A            mov b, [d]
0238   057C 38 00 00      mov c, 0
0239   057F 74            mov d, b
0240   0580 32            mov bl, [d]
0241   0581 A7 00         mov bh, 0
0242   0583 38 00 00      mov c, 0
0243   0586             ; --- START RELATIONAL
0244   0586 D7            push a
0245   0587 11            mov a, b
0246   0588 FD 2E 78 00   mov32 cb, $00000078
0246   058C 00 00 
0247   058E B0            cmp a, b
0248   058F FD 71         seq ; ==
0249   0591 E4            pop a
0250   0592             ; --- END RELATIONAL
0251   0592 C0 00 00      cmp b, 0
0252   0595 C6 B6 05      je _if7_else
0253   0598             _if7_TRUE:
0254   0598             ; printx32(*(long int *)p); 
0255   0598             ; --- START FUNCTION CALL
0256   0598 FA FF FF      lea d, [bp + -1] ; $p
0257   059B 2A            mov b, [d]
0258   059C 38 00 00      mov c, 0
0259   059F 74            mov d, b
0260   05A0 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0261   05A3 FD 39         mov c, b ; And place it into C
0262   05A5 2A            mov b, [d] ; Lower Word in B
0263   05A6 12            mov a, c
0264   05A7 FD AA         swp a
0265   05A9 D7            push a
0266   05AA FD AB         swp b
0267   05AC D8            push b
0268   05AD 07 CA 09      call printx32
0269   05B0 51 04 00      add sp, 4
0270   05B3             ; --- END FUNCTION CALL
0271   05B3 0A C2 05      jmp _if7_exit
0272   05B6             _if7_else:
0273   05B6             ; err("Unexpected format in printf."); 
0274   05B6             ; --- START FUNCTION CALL
0275   05B6 26 06 0D      mov b, _s1 ; "Unexpected format in printf."
0276   05B9 FD AB         swp b
0277   05BB D8            push b
0278   05BC 07 2A 0A      call err
0279   05BF 51 02 00      add sp, 2
0280   05C2             ; --- END FUNCTION CALL
0281   05C2             _if7_exit:
0282   05C2             _if6_exit:
0283   05C2             _if5_exit:
0284   05C2             ; p = p + 4; 
0285   05C2 FA FF FF      lea d, [bp + -1] ; $p
0286   05C5 DA            push d
0287   05C6 FA FF FF      lea d, [bp + -1] ; $p
0288   05C9 2A            mov b, [d]
0289   05CA 38 00 00      mov c, 0
0290   05CD             ; --- START TERMS
0291   05CD D7            push a
0292   05CE 11            mov a, b
0293   05CF FD 2E 04 00   mov32 cb, $00000004
0293   05D3 00 00 
0294   05D5 56            add b, a
0295   05D6 E4            pop a
0296   05D7             ; --- END TERMS
0297   05D7 E7            pop d
0298   05D8 FD 43         mov [d], b
0299   05DA             ; break; 
0300   05DA 0A D6 06      jmp _switch4_exit ; case break
0301   05DD             _switch4_case2:
0302   05DD             _switch4_case3:
0303   05DD             ; print_signed(*(int*)p); 
0304   05DD             ; --- START FUNCTION CALL
0305   05DD FA FF FF      lea d, [bp + -1] ; $p
0306   05E0 2A            mov b, [d]
0307   05E1 38 00 00      mov c, 0
0308   05E4 74            mov d, b
0309   05E5 2A            mov b, [d]
0310   05E6 38 00 00      mov c, 0
0311   05E9 FD AB         swp b
0312   05EB D8            push b
0313   05EC 07 58 0A      call print_signed
0314   05EF 51 02 00      add sp, 2
0315   05F2             ; --- END FUNCTION CALL
0316   05F2             ; p = p + 2; 
0317   05F2 FA FF FF      lea d, [bp + -1] ; $p
0318   05F5 DA            push d
0319   05F6 FA FF FF      lea d, [bp + -1] ; $p
0320   05F9 2A            mov b, [d]
0321   05FA 38 00 00      mov c, 0
0322   05FD             ; --- START TERMS
0323   05FD D7            push a
0324   05FE 11            mov a, b
0325   05FF FD 2E 02 00   mov32 cb, $00000002
0325   0603 00 00 
0326   0605 56            add b, a
0327   0606 E4            pop a
0328   0607             ; --- END TERMS
0329   0607 E7            pop d
0330   0608 FD 43         mov [d], b
0331   060A             ; break; 
0332   060A 0A D6 06      jmp _switch4_exit ; case break
0333   060D             _switch4_case4:
0334   060D             ; print_unsigned(*(unsigned int*)p); 
0335   060D             ; --- START FUNCTION CALL
0336   060D FA FF FF      lea d, [bp + -1] ; $p
0337   0610 2A            mov b, [d]
0338   0611 38 00 00      mov c, 0
0339   0614 74            mov d, b
0340   0615 2A            mov b, [d]
0341   0616 38 00 00      mov c, 0
0342   0619 FD AB         swp b
0343   061B D8            push b
0344   061C 07 A1 0B      call print_unsigned
0345   061F 51 02 00      add sp, 2
0346   0622             ; --- END FUNCTION CALL
0347   0622             ; p = p + 2; 
0348   0622 FA FF FF      lea d, [bp + -1] ; $p
0349   0625 DA            push d
0350   0626 FA FF FF      lea d, [bp + -1] ; $p
0351   0629 2A            mov b, [d]
0352   062A 38 00 00      mov c, 0
0353   062D             ; --- START TERMS
0354   062D D7            push a
0355   062E 11            mov a, b
0356   062F FD 2E 02 00   mov32 cb, $00000002
0356   0633 00 00 
0357   0635 56            add b, a
0358   0636 E4            pop a
0359   0637             ; --- END TERMS
0360   0637 E7            pop d
0361   0638 FD 43         mov [d], b
0362   063A             ; break; 
0363   063A 0A D6 06      jmp _switch4_exit ; case break
0364   063D             _switch4_case5:
0365   063D             ; printx16(*(int*)p); 
0366   063D             ; --- START FUNCTION CALL
0367   063D FA FF FF      lea d, [bp + -1] ; $p
0368   0640 2A            mov b, [d]
0369   0641 38 00 00      mov c, 0
0370   0644 74            mov d, b
0371   0645 2A            mov b, [d]
0372   0646 38 00 00      mov c, 0
0373   0649 FD AB         swp b
0374   064B D8            push b
0375   064C 07 B1 0C      call printx16
0376   064F 51 02 00      add sp, 2
0377   0652             ; --- END FUNCTION CALL
0378   0652             ; p = p + 2; 
0379   0652 FA FF FF      lea d, [bp + -1] ; $p
0380   0655 DA            push d
0381   0656 FA FF FF      lea d, [bp + -1] ; $p
0382   0659 2A            mov b, [d]
0383   065A 38 00 00      mov c, 0
0384   065D             ; --- START TERMS
0385   065D D7            push a
0386   065E 11            mov a, b
0387   065F FD 2E 02 00   mov32 cb, $00000002
0387   0663 00 00 
0388   0665 56            add b, a
0389   0666 E4            pop a
0390   0667             ; --- END TERMS
0391   0667 E7            pop d
0392   0668 FD 43         mov [d], b
0393   066A             ; break; 
0394   066A 0A D6 06      jmp _switch4_exit ; case break
0395   066D             _switch4_case6:
0396   066D             ; putchar(*(char*)p); 
0397   066D             ; --- START FUNCTION CALL
0398   066D FA FF FF      lea d, [bp + -1] ; $p
0399   0670 2A            mov b, [d]
0400   0671 38 00 00      mov c, 0
0401   0674 74            mov d, b
0402   0675 32            mov bl, [d]
0403   0676 A7 00         mov bh, 0
0404   0678 38 00 00      mov c, 0
0405   067B DD            push bl
0406   067C 07 90 08      call putchar
0407   067F 51 01 00      add sp, 1
0408   0682             ; --- END FUNCTION CALL
0409   0682             ; p = p + 1; 
0410   0682 FA FF FF      lea d, [bp + -1] ; $p
0411   0685 DA            push d
0412   0686 FA FF FF      lea d, [bp + -1] ; $p
0413   0689 2A            mov b, [d]
0414   068A 38 00 00      mov c, 0
0415   068D             ; --- START TERMS
0416   068D D7            push a
0417   068E 11            mov a, b
0418   068F FD 2E 01 00   mov32 cb, $00000001
0418   0693 00 00 
0419   0695 56            add b, a
0420   0696 E4            pop a
0421   0697             ; --- END TERMS
0422   0697 E7            pop d
0423   0698 FD 43         mov [d], b
0424   069A             ; break; 
0425   069A 0A D6 06      jmp _switch4_exit ; case break
0426   069D             _switch4_case7:
0427   069D             ; print(*(char**)p); 
0428   069D             ; --- START FUNCTION CALL
0429   069D FA FF FF      lea d, [bp + -1] ; $p
0430   06A0 2A            mov b, [d]
0431   06A1 38 00 00      mov c, 0
0432   06A4 74            mov d, b
0433   06A5 2A            mov b, [d]
0434   06A6 FD AB         swp b
0435   06A8 D8            push b
0436   06A9 07 3F 0A      call print
0437   06AC 51 02 00      add sp, 2
0438   06AF             ; --- END FUNCTION CALL
0439   06AF             ; p = p + 2; 
0440   06AF FA FF FF      lea d, [bp + -1] ; $p
0441   06B2 DA            push d
0442   06B3 FA FF FF      lea d, [bp + -1] ; $p
0443   06B6 2A            mov b, [d]
0444   06B7 38 00 00      mov c, 0
0445   06BA             ; --- START TERMS
0446   06BA D7            push a
0447   06BB 11            mov a, b
0448   06BC FD 2E 02 00   mov32 cb, $00000002
0448   06C0 00 00 
0449   06C2 56            add b, a
0450   06C3 E4            pop a
0451   06C4             ; --- END TERMS
0452   06C4 E7            pop d
0453   06C5 FD 43         mov [d], b
0454   06C7             ; break; 
0455   06C7 0A D6 06      jmp _switch4_exit ; case break
0456   06CA             _switch4_default:
0457   06CA             ; print("Error: Unknown argument type.\n"); 
0458   06CA             ; --- START FUNCTION CALL
0459   06CA 26 23 0D      mov b, _s2 ; "Error: Unknown argument type.\n"
0460   06CD FD AB         swp b
0461   06CF D8            push b
0462   06D0 07 3F 0A      call print
0463   06D3 51 02 00      add sp, 2
0464   06D6             ; --- END FUNCTION CALL
0465   06D6             _switch4_exit:
0466   06D6             ; format_p++; 
0467   06D6 FA FD FF      lea d, [bp + -3] ; $format_p
0468   06D9 2A            mov b, [d]
0469   06DA 38 00 00      mov c, 0
0470   06DD FD 77         inc b
0471   06DF FA FD FF      lea d, [bp + -3] ; $format_p
0472   06E2 FD 43         mov [d], b
0473   06E4 FD 7D         dec b
0474   06E6 0A 0E 07      jmp _if3_exit
0475   06E9             _if3_else:
0476   06E9             ; putchar(*format_p); 
0477   06E9             ; --- START FUNCTION CALL
0478   06E9 FA FD FF      lea d, [bp + -3] ; $format_p
0479   06EC 2A            mov b, [d]
0480   06ED 38 00 00      mov c, 0
0481   06F0 74            mov d, b
0482   06F1 32            mov bl, [d]
0483   06F2 A7 00         mov bh, 0
0484   06F4 38 00 00      mov c, 0
0485   06F7 DD            push bl
0486   06F8 07 90 08      call putchar
0487   06FB 51 01 00      add sp, 1
0488   06FE             ; --- END FUNCTION CALL
0489   06FE             ; format_p++; 
0490   06FE FA FD FF      lea d, [bp + -3] ; $format_p
0491   0701 2A            mov b, [d]
0492   0702 38 00 00      mov c, 0
0493   0705 FD 77         inc b
0494   0707 FA FD FF      lea d, [bp + -3] ; $format_p
0495   070A FD 43         mov [d], b
0496   070C FD 7D         dec b
0497   070E             _if3_exit:
0498   070E             _if2_exit:
0499   070E             _for1_update:
0500   070E 0A 42 04      jmp _for1_cond
0501   0711             _for1_exit:
0502   0711 F9            leave
0503   0712 09            ret
0504   0713             
0505   0713             print_signed_long:
0506   0713 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0507   0716             ; char digits[10]; 
0508   0716 52 0A 00      sub sp, 10
0509   0719             ; int i = 0; 
0510   0719 52 02 00      sub sp, 2
0511   071C             ; --- START LOCAL VAR INITIALIZATION
0512   071C FA F5 FF      lea d, [bp + -11] ; $i
0513   071F DA            push d
0514   0720 FD 2E 00 00   mov32 cb, $00000000
0514   0724 00 00 
0515   0726 E7            pop d
0516   0727 FD 43         mov [d], b
0517   0729             ; --- END LOCAL VAR INITIALIZATION
0518   0729             ; if (num < 0) { 
0519   0729             _if8_cond:
0520   0729 FA 05 00      lea d, [bp + 5] ; $num
0521   072C 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0522   072F FD 39         mov c, b ; And place it into C
0523   0731 2A            mov b, [d] ; Lower Word in B
0524   0732             ; --- START RELATIONAL
0525   0732 D7            push a
0526   0733 FD D8         push g
0527   0735 11            mov a, b
0528   0736 FD 7A         mov g, c
0529   0738 FD 2E 00 00   mov32 cb, $00000000
0529   073C 00 00 
0530   073E FD AF         cmp32 ga, cb
0531   0740 FD 73         slt ; <
0532   0742 FD F1         pop g
0533   0744 E4            pop a
0534   0745             ; --- END RELATIONAL
0535   0745 C0 00 00      cmp b, 0
0536   0748 C6 7A 07      je _if8_else
0537   074B             _if8_TRUE:
0538   074B             ; putchar('-'); 
0539   074B             ; --- START FUNCTION CALL
0540   074B FD 2E 2D 00   mov32 cb, $0000002d
0540   074F 00 00 
0541   0751 DD            push bl
0542   0752 07 90 08      call putchar
0543   0755 51 01 00      add sp, 1
0544   0758             ; --- END FUNCTION CALL
0545   0758             ; num = -num; 
0546   0758 FA 05 00      lea d, [bp + 5] ; $num
0547   075B DA            push d
0548   075C FA 05 00      lea d, [bp + 5] ; $num
0549   075F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0550   0762 FD 39         mov c, b ; And place it into C
0551   0764 2A            mov b, [d] ; Lower Word in B
0552   0765 12            mov a, c
0553   0766 95            not a
0554   0767 97            not b
0555   0768 55 01 00      add b, 1
0556   076B 5B 00 00      adc a, 0
0557   076E 39            mov c, a
0558   076F E7            pop d
0559   0770 FD 43         mov [d], b
0560   0772 28            mov b, c
0561   0773 FD 44 02 00   mov [d + 2], b
0562   0777 0A AE 07      jmp _if8_exit
0563   077A             _if8_else:
0564   077A             ; if (num == 0) { 
0565   077A             _if9_cond:
0566   077A FA 05 00      lea d, [bp + 5] ; $num
0567   077D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0568   0780 FD 39         mov c, b ; And place it into C
0569   0782 2A            mov b, [d] ; Lower Word in B
0570   0783             ; --- START RELATIONAL
0571   0783 D7            push a
0572   0784 FD D8         push g
0573   0786 11            mov a, b
0574   0787 FD 7A         mov g, c
0575   0789 FD 2E 00 00   mov32 cb, $00000000
0575   078D 00 00 
0576   078F FD AF         cmp32 ga, cb
0577   0791 FD 71         seq ; ==
0578   0793 FD F1         pop g
0579   0795 E4            pop a
0580   0796             ; --- END RELATIONAL
0581   0796 C0 00 00      cmp b, 0
0582   0799 C6 AE 07      je _if9_exit
0583   079C             _if9_TRUE:
0584   079C             ; putchar('0'); 
0585   079C             ; --- START FUNCTION CALL
0586   079C FD 2E 30 00   mov32 cb, $00000030
0586   07A0 00 00 
0587   07A2 DD            push bl
0588   07A3 07 90 08      call putchar
0589   07A6 51 01 00      add sp, 1
0590   07A9             ; --- END FUNCTION CALL
0591   07A9             ; return; 
0592   07A9 F9            leave
0593   07AA 09            ret
0594   07AB 0A AE 07      jmp _if9_exit
0595   07AE             _if9_exit:
0596   07AE             _if8_exit:
0597   07AE             ; while (num > 0) { 
0598   07AE             _while10_cond:
0599   07AE FA 05 00      lea d, [bp + 5] ; $num
0600   07B1 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0601   07B4 FD 39         mov c, b ; And place it into C
0602   07B6 2A            mov b, [d] ; Lower Word in B
0603   07B7             ; --- START RELATIONAL
0604   07B7 D7            push a
0605   07B8 FD D8         push g
0606   07BA 11            mov a, b
0607   07BB FD 7A         mov g, c
0608   07BD FD 2E 00 00   mov32 cb, $00000000
0608   07C1 00 00 
0609   07C3 FD AF         cmp32 ga, cb
0610   07C5 FD 7F         sgt
0611   07C7 FD F1         pop g
0612   07C9 E4            pop a
0613   07CA             ; --- END RELATIONAL
0614   07CA C0 00 00      cmp b, 0
0615   07CD C6 46 08      je _while10_exit
0616   07D0             _while10_block:
0617   07D0             ; digits[i] = '0' + (num % 10); 
0618   07D0 FA F7 FF      lea d, [bp + -9] ; $digits
0619   07D3 D7            push a
0620   07D4 DA            push d
0621   07D5 FA F5 FF      lea d, [bp + -11] ; $i
0622   07D8 2A            mov b, [d]
0623   07D9 38 00 00      mov c, 0
0624   07DC E7            pop d
0625   07DD 5A            add d, b
0626   07DE E4            pop a
0627   07DF DA            push d
0628   07E0 FD 2E 30 00   mov32 cb, $00000030
0628   07E4 00 00 
0629   07E6             ; --- START TERMS
0630   07E6 D7            push a
0631   07E7 11            mov a, b
0632   07E8 FA 05 00      lea d, [bp + 5] ; $num
0633   07EB 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0634   07EE FD 39         mov c, b ; And place it into C
0635   07F0 2A            mov b, [d] ; Lower Word in B
0636   07F1             ; --- START FACTORS
0637   07F1 D7            push a
0638   07F2 FD D8         push g
0639   07F4 11            mov a, b
0640   07F5 FD 7A         mov g, c
0641   07F7 FD 2E 0A 00   mov32 cb, $0000000a
0641   07FB 00 00 
0642   07FD AE            div a, b ; 
0643   07FE 11            mov a, b
0644   07FF FD 38         mov c, g
0645   0801 27            mov b, a
0646   0802 FD F1         pop g
0647   0804 E4            pop a
0648   0805             ; --- END FACTORS
0649   0805 FD 15         add32 cb, ga
0650   0807 E4            pop a
0651   0808             ; --- END TERMS
0652   0808 E7            pop d
0653   0809 FD 3E         mov [d], bl
0654   080B             ; num = num / 10; 
0655   080B FA 05 00      lea d, [bp + 5] ; $num
0656   080E DA            push d
0657   080F FA 05 00      lea d, [bp + 5] ; $num
0658   0812 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0659   0815 FD 39         mov c, b ; And place it into C
0660   0817 2A            mov b, [d] ; Lower Word in B
0661   0818             ; --- START FACTORS
0662   0818 D7            push a
0663   0819 FD D8         push g
0664   081B 11            mov a, b
0665   081C FD 7A         mov g, c
0666   081E FD 2E 0A 00   mov32 cb, $0000000a
0666   0822 00 00 
0667   0824 AE            div a, b
0668   0825 FD 38         mov c, g
0669   0827 27            mov b, a
0670   0828 FD F1         pop g
0671   082A E4            pop a
0672   082B             ; --- END FACTORS
0673   082B E7            pop d
0674   082C FD 43         mov [d], b
0675   082E 28            mov b, c
0676   082F FD 44 02 00   mov [d + 2], b
0677   0833             ; i++; 
0678   0833 FA F5 FF      lea d, [bp + -11] ; $i
0679   0836 2A            mov b, [d]
0680   0837 38 00 00      mov c, 0
0681   083A 11            mov a, b
0682   083B FD 77         inc b
0683   083D FA F5 FF      lea d, [bp + -11] ; $i
0684   0840 FD 43         mov [d], b
0685   0842 27            mov b, a
0686   0843 0A AE 07      jmp _while10_cond
0687   0846             _while10_exit:
0688   0846             ; while (i > 0) { 
0689   0846             _while17_cond:
0690   0846 FA F5 FF      lea d, [bp + -11] ; $i
0691   0849 2A            mov b, [d]
0692   084A 38 00 00      mov c, 0
0693   084D             ; --- START RELATIONAL
0694   084D D7            push a
0695   084E 11            mov a, b
0696   084F FD 2E 00 00   mov32 cb, $00000000
0696   0853 00 00 
0697   0855 B0            cmp a, b
0698   0856 FD 7F         sgt ; >
0699   0858 E4            pop a
0700   0859             ; --- END RELATIONAL
0701   0859 C0 00 00      cmp b, 0
0702   085C C6 8E 08      je _while17_exit
0703   085F             _while17_block:
0704   085F             ; i--; 
0705   085F FA F5 FF      lea d, [bp + -11] ; $i
0706   0862 2A            mov b, [d]
0707   0863 38 00 00      mov c, 0
0708   0866 11            mov a, b
0709   0867 FD 7D         dec b
0710   0869 FA F5 FF      lea d, [bp + -11] ; $i
0711   086C FD 43         mov [d], b
0712   086E 27            mov b, a
0713   086F             ; putchar(digits[i]); 
0714   086F             ; --- START FUNCTION CALL
0715   086F FA F7 FF      lea d, [bp + -9] ; $digits
0716   0872 D7            push a
0717   0873 DA            push d
0718   0874 FA F5 FF      lea d, [bp + -11] ; $i
0719   0877 2A            mov b, [d]
0720   0878 38 00 00      mov c, 0
0721   087B E7            pop d
0722   087C 5A            add d, b
0723   087D E4            pop a
0724   087E 32            mov bl, [d]
0725   087F A7 00         mov bh, 0
0726   0881 38 00 00      mov c, 0
0727   0884 DD            push bl
0728   0885 07 90 08      call putchar
0729   0888 51 01 00      add sp, 1
0730   088B             ; --- END FUNCTION CALL
0731   088B 0A 46 08      jmp _while17_cond
0732   088E             _while17_exit:
0733   088E F9            leave
0734   088F 09            ret
0735   0890             
0736   0890             putchar:
0737   0890 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0738   0893             ; --- BEGIN INLINE ASM SEGMENT
0739   0893 FA 05 00      lea d, [bp + 5] ; $c
0740   0896 1E            mov al, [d]
0741   0897 23            mov ah, al
0742   0898 19 00         mov al, 0
0743   089A 05 03         syscall sys_io      
0744   089C             ; --- END INLINE ASM SEGMENT
0745   089C F9            leave
0746   089D 09            ret
0747   089E             
0748   089E             print_unsigned_long:
0749   089E F8 00 00      enter 0 ; (push bp; mov bp, sp)
0750   08A1             ; char digits[10]; 
0751   08A1 52 0A 00      sub sp, 10
0752   08A4             ; int i; 
0753   08A4 52 02 00      sub sp, 2
0754   08A7             ; i = 0; 
0755   08A7 FA F5 FF      lea d, [bp + -11] ; $i
0756   08AA DA            push d
0757   08AB FD 2E 00 00   mov32 cb, $00000000
0757   08AF 00 00 
0758   08B1 E7            pop d
0759   08B2 FD 43         mov [d], b
0760   08B4             ; if(num == 0){ 
0761   08B4             _if18_cond:
0762   08B4 FA 05 00      lea d, [bp + 5] ; $num
0763   08B7 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0764   08BA FD 39         mov c, b ; And place it into C
0765   08BC 2A            mov b, [d] ; Lower Word in B
0766   08BD             ; --- START RELATIONAL
0767   08BD D7            push a
0768   08BE FD D8         push g
0769   08C0 11            mov a, b
0770   08C1 FD 7A         mov g, c
0771   08C3 FD 2E 00 00   mov32 cb, $00000000
0771   08C7 00 00 
0772   08C9 FD AF         cmp32 ga, cb
0773   08CB FD 71         seq ; ==
0774   08CD FD F1         pop g
0775   08CF E4            pop a
0776   08D0             ; --- END RELATIONAL
0777   08D0 C0 00 00      cmp b, 0
0778   08D3 C6 E8 08      je _if18_exit
0779   08D6             _if18_TRUE:
0780   08D6             ; putchar('0'); 
0781   08D6             ; --- START FUNCTION CALL
0782   08D6 FD 2E 30 00   mov32 cb, $00000030
0782   08DA 00 00 
0783   08DC DD            push bl
0784   08DD 07 90 08      call putchar
0785   08E0 51 01 00      add sp, 1
0786   08E3             ; --- END FUNCTION CALL
0787   08E3             ; return; 
0788   08E3 F9            leave
0789   08E4 09            ret
0790   08E5 0A E8 08      jmp _if18_exit
0791   08E8             _if18_exit:
0792   08E8             ; while (num > 0) { 
0793   08E8             _while19_cond:
0794   08E8 FA 05 00      lea d, [bp + 5] ; $num
0795   08EB 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0796   08EE FD 39         mov c, b ; And place it into C
0797   08F0 2A            mov b, [d] ; Lower Word in B
0798   08F1             ; --- START RELATIONAL
0799   08F1 D7            push a
0800   08F2 FD D8         push g
0801   08F4 11            mov a, b
0802   08F5 FD 7A         mov g, c
0803   08F7 FD 2E 00 00   mov32 cb, $00000000
0803   08FB 00 00 
0804   08FD FD AF         cmp32 ga, cb
0805   08FF FD 81         sgu
0806   0901 FD F1         pop g
0807   0903 E4            pop a
0808   0904             ; --- END RELATIONAL
0809   0904 C0 00 00      cmp b, 0
0810   0907 C6 80 09      je _while19_exit
0811   090A             _while19_block:
0812   090A             ; digits[i] = '0' + (num % 10); 
0813   090A FA F7 FF      lea d, [bp + -9] ; $digits
0814   090D D7            push a
0815   090E DA            push d
0816   090F FA F5 FF      lea d, [bp + -11] ; $i
0817   0912 2A            mov b, [d]
0818   0913 38 00 00      mov c, 0
0819   0916 E7            pop d
0820   0917 5A            add d, b
0821   0918 E4            pop a
0822   0919 DA            push d
0823   091A FD 2E 30 00   mov32 cb, $00000030
0823   091E 00 00 
0824   0920             ; --- START TERMS
0825   0920 D7            push a
0826   0921 11            mov a, b
0827   0922 FA 05 00      lea d, [bp + 5] ; $num
0828   0925 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0829   0928 FD 39         mov c, b ; And place it into C
0830   092A 2A            mov b, [d] ; Lower Word in B
0831   092B             ; --- START FACTORS
0832   092B D7            push a
0833   092C FD D8         push g
0834   092E 11            mov a, b
0835   092F FD 7A         mov g, c
0836   0931 FD 2E 0A 00   mov32 cb, $0000000a
0836   0935 00 00 
0837   0937 AE            div a, b ; 
0838   0938 11            mov a, b
0839   0939 FD 38         mov c, g
0840   093B 27            mov b, a
0841   093C FD F1         pop g
0842   093E E4            pop a
0843   093F             ; --- END FACTORS
0844   093F FD 15         add32 cb, ga
0845   0941 E4            pop a
0846   0942             ; --- END TERMS
0847   0942 E7            pop d
0848   0943 FD 3E         mov [d], bl
0849   0945             ; num = num / 10; 
0850   0945 FA 05 00      lea d, [bp + 5] ; $num
0851   0948 DA            push d
0852   0949 FA 05 00      lea d, [bp + 5] ; $num
0853   094C 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0854   094F FD 39         mov c, b ; And place it into C
0855   0951 2A            mov b, [d] ; Lower Word in B
0856   0952             ; --- START FACTORS
0857   0952 D7            push a
0858   0953 FD D8         push g
0859   0955 11            mov a, b
0860   0956 FD 7A         mov g, c
0861   0958 FD 2E 0A 00   mov32 cb, $0000000a
0861   095C 00 00 
0862   095E AE            div a, b
0863   095F FD 38         mov c, g
0864   0961 27            mov b, a
0865   0962 FD F1         pop g
0866   0964 E4            pop a
0867   0965             ; --- END FACTORS
0868   0965 E7            pop d
0869   0966 FD 43         mov [d], b
0870   0968 28            mov b, c
0871   0969 FD 44 02 00   mov [d + 2], b
0872   096D             ; i++; 
0873   096D FA F5 FF      lea d, [bp + -11] ; $i
0874   0970 2A            mov b, [d]
0875   0971 38 00 00      mov c, 0
0876   0974 11            mov a, b
0877   0975 FD 77         inc b
0878   0977 FA F5 FF      lea d, [bp + -11] ; $i
0879   097A FD 43         mov [d], b
0880   097C 27            mov b, a
0881   097D 0A E8 08      jmp _while19_cond
0882   0980             _while19_exit:
0883   0980             ; while (i > 0) { 
0884   0980             _while26_cond:
0885   0980 FA F5 FF      lea d, [bp + -11] ; $i
0886   0983 2A            mov b, [d]
0887   0984 38 00 00      mov c, 0
0888   0987             ; --- START RELATIONAL
0889   0987 D7            push a
0890   0988 11            mov a, b
0891   0989 FD 2E 00 00   mov32 cb, $00000000
0891   098D 00 00 
0892   098F B0            cmp a, b
0893   0990 FD 7F         sgt ; >
0894   0992 E4            pop a
0895   0993             ; --- END RELATIONAL
0896   0993 C0 00 00      cmp b, 0
0897   0996 C6 C8 09      je _while26_exit
0898   0999             _while26_block:
0899   0999             ; i--; 
0900   0999 FA F5 FF      lea d, [bp + -11] ; $i
0901   099C 2A            mov b, [d]
0902   099D 38 00 00      mov c, 0
0903   09A0 11            mov a, b
0904   09A1 FD 7D         dec b
0905   09A3 FA F5 FF      lea d, [bp + -11] ; $i
0906   09A6 FD 43         mov [d], b
0907   09A8 27            mov b, a
0908   09A9             ; putchar(digits[i]); 
0909   09A9             ; --- START FUNCTION CALL
0910   09A9 FA F7 FF      lea d, [bp + -9] ; $digits
0911   09AC D7            push a
0912   09AD DA            push d
0913   09AE FA F5 FF      lea d, [bp + -11] ; $i
0914   09B1 2A            mov b, [d]
0915   09B2 38 00 00      mov c, 0
0916   09B5 E7            pop d
0917   09B6 5A            add d, b
0918   09B7 E4            pop a
0919   09B8 32            mov bl, [d]
0920   09B9 A7 00         mov bh, 0
0921   09BB 38 00 00      mov c, 0
0922   09BE DD            push bl
0923   09BF 07 90 08      call putchar
0924   09C2 51 01 00      add sp, 1
0925   09C5             ; --- END FUNCTION CALL
0926   09C5 0A 80 09      jmp _while26_cond
0927   09C8             _while26_exit:
0928   09C8 F9            leave
0929   09C9 09            ret
0930   09CA             
0931   09CA             printx32:
0932   09CA F8 00 00      enter 0 ; (push bp; mov bp, sp)
0933   09CD             ; --- BEGIN INLINE ASM SEGMENT
0934   09CD FA 05 00      lea d, [bp + 5] ; $hex
0935   09D0 2B 02 00      mov b, [d+2]
0936   09D3 07 DC 09      call print_u16x_printx32
0937   09D6 2A            mov b, [d]
0938   09D7 07 DC 09      call print_u16x_printx32
0939   09DA             ; --- END INLINE ASM SEGMENT
0940   09DA             ; return; 
0941   09DA F9            leave
0942   09DB 09            ret
0943   09DC             ; --- BEGIN INLINE ASM SEGMENT
0944   09DC             print_u16x_printx32:
0945   09DC D7            push a
0946   09DD D8            push b
0947   09DE DD            push bl
0948   09DF 30            mov bl, bh
0949   09E0 07 FE 09      call _itoa_printx32        
0950   09E3 2F            mov bl, al        
0951   09E4 19 00         mov al, 0
0952   09E6 05 03         syscall sys_io        
0953   09E8 24            mov ah, bl        
0954   09E9 19 00         mov al, 0
0955   09EB 05 03         syscall sys_io        
0956   09ED EA            pop bl
0957   09EE 07 FE 09      call _itoa_printx32        
0958   09F1 2F            mov bl, al        
0959   09F2 19 00         mov al, 0
0960   09F4 05 03         syscall sys_io        
0961   09F6 24            mov ah, bl        
0962   09F7 19 00         mov al, 0
0963   09F9 05 03         syscall sys_io        
0964   09FB E5            pop b
0965   09FC E4            pop a
0966   09FD 09            ret
0967   09FE             _itoa_printx32:
0968   09FE DA            push d
0969   09FF D8            push b
0970   0A00 A7 00         mov bh, 0
0971   0A02 FD A4 04      shr bl, 4  
0972   0A05 74            mov d, b
0973   0A06 1F 18 0A      mov al, [d + s_hex_digits_printx32]
0974   0A09 23            mov ah, al
0975   0A0A E5            pop b
0976   0A0B D8            push b
0977   0A0C A7 00         mov bh, 0
0978   0A0E FD 87 0F      and bl, $0F
0979   0A11 74            mov d, b
0980   0A12 1F 18 0A      mov al, [d + s_hex_digits_printx32]
0981   0A15 E5            pop b
0982   0A16 E7            pop d
0983   0A17 09            ret
0984   0A18 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
0984   0A1C 34 35 36 37 
0984   0A20 38 39 41 42 
0984   0A24 43 44 45 46 
0985   0A28             ; --- END INLINE ASM SEGMENT
0986   0A28 F9            leave
0987   0A29 09            ret
0988   0A2A             
0989   0A2A             err:
0990   0A2A F8 00 00      enter 0 ; (push bp; mov bp, sp)
0991   0A2D             ; print(e); 
0992   0A2D             ; --- START FUNCTION CALL
0993   0A2D FA 05 00      lea d, [bp + 5] ; $e
0994   0A30 2A            mov b, [d]
0995   0A31 38 00 00      mov c, 0
0996   0A34 FD AB         swp b
0997   0A36 D8            push b
0998   0A37 07 3F 0A      call print
0999   0A3A 51 02 00      add sp, 2
1000   0A3D             ; --- END FUNCTION CALL
1001   0A3D F9            leave
1002   0A3E 09            ret
1003   0A3F             
1004   0A3F             print:
1005   0A3F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1006   0A42             ; --- BEGIN INLINE ASM SEGMENT
1007   0A42 FA 05 00      lea d, [bp + 5] ; $s
1008   0A45 FD 2A         mov d, [d]
1009   0A47             _puts_L1_print:
1010   0A47 1E            mov al, [d]
1011   0A48 B9 00         cmp al, 0
1012   0A4A C6 56 0A      jz _puts_END_print
1013   0A4D 23            mov ah, al
1014   0A4E 19 00         mov al, 0
1015   0A50 05 03         syscall sys_io
1016   0A52 79            inc d
1017   0A53 0A 47 0A      jmp _puts_L1_print
1018   0A56             _puts_END_print:
1019   0A56             ; --- END INLINE ASM SEGMENT
1020   0A56 F9            leave
1021   0A57 09            ret
1022   0A58             
1023   0A58             print_signed:
1024   0A58 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1025   0A5B             ; char digits[5]; 
1026   0A5B 52 05 00      sub sp, 5
1027   0A5E             ; int i = 0; 
1028   0A5E 52 02 00      sub sp, 2
1029   0A61             ; --- START LOCAL VAR INITIALIZATION
1030   0A61 FA FA FF      lea d, [bp + -6] ; $i
1031   0A64 DA            push d
1032   0A65 FD 2E 00 00   mov32 cb, $00000000
1032   0A69 00 00 
1033   0A6B E7            pop d
1034   0A6C FD 43         mov [d], b
1035   0A6E             ; --- END LOCAL VAR INITIALIZATION
1036   0A6E             ; if (num < 0) { 
1037   0A6E             _if27_cond:
1038   0A6E FA 05 00      lea d, [bp + 5] ; $num
1039   0A71 2A            mov b, [d]
1040   0A72 38 00 00      mov c, 0
1041   0A75             ; --- START RELATIONAL
1042   0A75 D7            push a
1043   0A76 11            mov a, b
1044   0A77 FD 2E 00 00   mov32 cb, $00000000
1044   0A7B 00 00 
1045   0A7D B0            cmp a, b
1046   0A7E FD 73         slt ; < (signed)
1047   0A80 E4            pop a
1048   0A81             ; --- END RELATIONAL
1049   0A81 C0 00 00      cmp b, 0
1050   0A84 C6 A7 0A      je _if27_else
1051   0A87             _if27_TRUE:
1052   0A87             ; putchar('-'); 
1053   0A87             ; --- START FUNCTION CALL
1054   0A87 FD 2E 2D 00   mov32 cb, $0000002d
1054   0A8B 00 00 
1055   0A8D DD            push bl
1056   0A8E 07 90 08      call putchar
1057   0A91 51 01 00      add sp, 1
1058   0A94             ; --- END FUNCTION CALL
1059   0A94             ; num = -num; 
1060   0A94 FA 05 00      lea d, [bp + 5] ; $num
1061   0A97 DA            push d
1062   0A98 FA 05 00      lea d, [bp + 5] ; $num
1063   0A9B 2A            mov b, [d]
1064   0A9C 38 00 00      mov c, 0
1065   0A9F FD 97         neg b
1066   0AA1 E7            pop d
1067   0AA2 FD 43         mov [d], b
1068   0AA4 0A D2 0A      jmp _if27_exit
1069   0AA7             _if27_else:
1070   0AA7             ; if (num == 0) { 
1071   0AA7             _if28_cond:
1072   0AA7 FA 05 00      lea d, [bp + 5] ; $num
1073   0AAA 2A            mov b, [d]
1074   0AAB 38 00 00      mov c, 0
1075   0AAE             ; --- START RELATIONAL
1076   0AAE D7            push a
1077   0AAF 11            mov a, b
1078   0AB0 FD 2E 00 00   mov32 cb, $00000000
1078   0AB4 00 00 
1079   0AB6 B0            cmp a, b
1080   0AB7 FD 71         seq ; ==
1081   0AB9 E4            pop a
1082   0ABA             ; --- END RELATIONAL
1083   0ABA C0 00 00      cmp b, 0
1084   0ABD C6 D2 0A      je _if28_exit
1085   0AC0             _if28_TRUE:
1086   0AC0             ; putchar('0'); 
1087   0AC0             ; --- START FUNCTION CALL
1088   0AC0 FD 2E 30 00   mov32 cb, $00000030
1088   0AC4 00 00 
1089   0AC6 DD            push bl
1090   0AC7 07 90 08      call putchar
1091   0ACA 51 01 00      add sp, 1
1092   0ACD             ; --- END FUNCTION CALL
1093   0ACD             ; return; 
1094   0ACD F9            leave
1095   0ACE 09            ret
1096   0ACF 0A D2 0A      jmp _if28_exit
1097   0AD2             _if28_exit:
1098   0AD2             _if27_exit:
1099   0AD2             ; while (num > 0) { 
1100   0AD2             _while29_cond:
1101   0AD2 FA 05 00      lea d, [bp + 5] ; $num
1102   0AD5 2A            mov b, [d]
1103   0AD6 38 00 00      mov c, 0
1104   0AD9             ; --- START RELATIONAL
1105   0AD9 D7            push a
1106   0ADA 11            mov a, b
1107   0ADB FD 2E 00 00   mov32 cb, $00000000
1107   0ADF 00 00 
1108   0AE1 B0            cmp a, b
1109   0AE2 FD 7F         sgt ; >
1110   0AE4 E4            pop a
1111   0AE5             ; --- END RELATIONAL
1112   0AE5 C0 00 00      cmp b, 0
1113   0AE8 C6 57 0B      je _while29_exit
1114   0AEB             _while29_block:
1115   0AEB             ; digits[i] = '0' + (num % 10); 
1116   0AEB FA FC FF      lea d, [bp + -4] ; $digits
1117   0AEE D7            push a
1118   0AEF DA            push d
1119   0AF0 FA FA FF      lea d, [bp + -6] ; $i
1120   0AF3 2A            mov b, [d]
1121   0AF4 38 00 00      mov c, 0
1122   0AF7 E7            pop d
1123   0AF8 5A            add d, b
1124   0AF9 E4            pop a
1125   0AFA DA            push d
1126   0AFB FD 2E 30 00   mov32 cb, $00000030
1126   0AFF 00 00 
1127   0B01             ; --- START TERMS
1128   0B01 D7            push a
1129   0B02 11            mov a, b
1130   0B03 FA 05 00      lea d, [bp + 5] ; $num
1131   0B06 2A            mov b, [d]
1132   0B07 38 00 00      mov c, 0
1133   0B0A             ; --- START FACTORS
1134   0B0A D7            push a
1135   0B0B FD D8         push g
1136   0B0D 11            mov a, b
1137   0B0E FD 7A         mov g, c
1138   0B10 FD 2E 0A 00   mov32 cb, $0000000a
1138   0B14 00 00 
1139   0B16 AE            div a, b ; 
1140   0B17 11            mov a, b
1141   0B18 FD 38         mov c, g
1142   0B1A 27            mov b, a
1143   0B1B FD F1         pop g
1144   0B1D E4            pop a
1145   0B1E             ; --- END FACTORS
1146   0B1E 56            add b, a
1147   0B1F E4            pop a
1148   0B20             ; --- END TERMS
1149   0B20 E7            pop d
1150   0B21 FD 3E         mov [d], bl
1151   0B23             ; num = num / 10; 
1152   0B23 FA 05 00      lea d, [bp + 5] ; $num
1153   0B26 DA            push d
1154   0B27 FA 05 00      lea d, [bp + 5] ; $num
1155   0B2A 2A            mov b, [d]
1156   0B2B 38 00 00      mov c, 0
1157   0B2E             ; --- START FACTORS
1158   0B2E D7            push a
1159   0B2F FD D8         push g
1160   0B31 11            mov a, b
1161   0B32 FD 7A         mov g, c
1162   0B34 FD 2E 0A 00   mov32 cb, $0000000a
1162   0B38 00 00 
1163   0B3A AE            div a, b
1164   0B3B FD 38         mov c, g
1165   0B3D 27            mov b, a
1166   0B3E FD F1         pop g
1167   0B40 E4            pop a
1168   0B41             ; --- END FACTORS
1169   0B41 E7            pop d
1170   0B42 FD 43         mov [d], b
1171   0B44             ; i++; 
1172   0B44 FA FA FF      lea d, [bp + -6] ; $i
1173   0B47 2A            mov b, [d]
1174   0B48 38 00 00      mov c, 0
1175   0B4B 11            mov a, b
1176   0B4C FD 77         inc b
1177   0B4E FA FA FF      lea d, [bp + -6] ; $i
1178   0B51 FD 43         mov [d], b
1179   0B53 27            mov b, a
1180   0B54 0A D2 0A      jmp _while29_cond
1181   0B57             _while29_exit:
1182   0B57             ; while (i > 0) { 
1183   0B57             _while36_cond:
1184   0B57 FA FA FF      lea d, [bp + -6] ; $i
1185   0B5A 2A            mov b, [d]
1186   0B5B 38 00 00      mov c, 0
1187   0B5E             ; --- START RELATIONAL
1188   0B5E D7            push a
1189   0B5F 11            mov a, b
1190   0B60 FD 2E 00 00   mov32 cb, $00000000
1190   0B64 00 00 
1191   0B66 B0            cmp a, b
1192   0B67 FD 7F         sgt ; >
1193   0B69 E4            pop a
1194   0B6A             ; --- END RELATIONAL
1195   0B6A C0 00 00      cmp b, 0
1196   0B6D C6 9F 0B      je _while36_exit
1197   0B70             _while36_block:
1198   0B70             ; i--; 
1199   0B70 FA FA FF      lea d, [bp + -6] ; $i
1200   0B73 2A            mov b, [d]
1201   0B74 38 00 00      mov c, 0
1202   0B77 11            mov a, b
1203   0B78 FD 7D         dec b
1204   0B7A FA FA FF      lea d, [bp + -6] ; $i
1205   0B7D FD 43         mov [d], b
1206   0B7F 27            mov b, a
1207   0B80             ; putchar(digits[i]); 
1208   0B80             ; --- START FUNCTION CALL
1209   0B80 FA FC FF      lea d, [bp + -4] ; $digits
1210   0B83 D7            push a
1211   0B84 DA            push d
1212   0B85 FA FA FF      lea d, [bp + -6] ; $i
1213   0B88 2A            mov b, [d]
1214   0B89 38 00 00      mov c, 0
1215   0B8C E7            pop d
1216   0B8D 5A            add d, b
1217   0B8E E4            pop a
1218   0B8F 32            mov bl, [d]
1219   0B90 A7 00         mov bh, 0
1220   0B92 38 00 00      mov c, 0
1221   0B95 DD            push bl
1222   0B96 07 90 08      call putchar
1223   0B99 51 01 00      add sp, 1
1224   0B9C             ; --- END FUNCTION CALL
1225   0B9C 0A 57 0B      jmp _while36_cond
1226   0B9F             _while36_exit:
1227   0B9F F9            leave
1228   0BA0 09            ret
1229   0BA1             
1230   0BA1             print_unsigned:
1231   0BA1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1232   0BA4             ; char digits[5]; 
1233   0BA4 52 05 00      sub sp, 5
1234   0BA7             ; int i; 
1235   0BA7 52 02 00      sub sp, 2
1236   0BAA             ; i = 0; 
1237   0BAA FA FA FF      lea d, [bp + -6] ; $i
1238   0BAD DA            push d
1239   0BAE FD 2E 00 00   mov32 cb, $00000000
1239   0BB2 00 00 
1240   0BB4 E7            pop d
1241   0BB5 FD 43         mov [d], b
1242   0BB7             ; if(num == 0){ 
1243   0BB7             _if37_cond:
1244   0BB7 FA 05 00      lea d, [bp + 5] ; $num
1245   0BBA 2A            mov b, [d]
1246   0BBB 38 00 00      mov c, 0
1247   0BBE             ; --- START RELATIONAL
1248   0BBE D7            push a
1249   0BBF 11            mov a, b
1250   0BC0 FD 2E 00 00   mov32 cb, $00000000
1250   0BC4 00 00 
1251   0BC6 B0            cmp a, b
1252   0BC7 FD 71         seq ; ==
1253   0BC9 E4            pop a
1254   0BCA             ; --- END RELATIONAL
1255   0BCA C0 00 00      cmp b, 0
1256   0BCD C6 E2 0B      je _if37_exit
1257   0BD0             _if37_TRUE:
1258   0BD0             ; putchar('0'); 
1259   0BD0             ; --- START FUNCTION CALL
1260   0BD0 FD 2E 30 00   mov32 cb, $00000030
1260   0BD4 00 00 
1261   0BD6 DD            push bl
1262   0BD7 07 90 08      call putchar
1263   0BDA 51 01 00      add sp, 1
1264   0BDD             ; --- END FUNCTION CALL
1265   0BDD             ; return; 
1266   0BDD F9            leave
1267   0BDE 09            ret
1268   0BDF 0A E2 0B      jmp _if37_exit
1269   0BE2             _if37_exit:
1270   0BE2             ; while (num > 0) { 
1271   0BE2             _while38_cond:
1272   0BE2 FA 05 00      lea d, [bp + 5] ; $num
1273   0BE5 2A            mov b, [d]
1274   0BE6 38 00 00      mov c, 0
1275   0BE9             ; --- START RELATIONAL
1276   0BE9 D7            push a
1277   0BEA 11            mov a, b
1278   0BEB FD 2E 00 00   mov32 cb, $00000000
1278   0BEF 00 00 
1279   0BF1 B0            cmp a, b
1280   0BF2 FD 81         sgu ; > (unsigned)
1281   0BF4 E4            pop a
1282   0BF5             ; --- END RELATIONAL
1283   0BF5 C0 00 00      cmp b, 0
1284   0BF8 C6 67 0C      je _while38_exit
1285   0BFB             _while38_block:
1286   0BFB             ; digits[i] = '0' + (num % 10); 
1287   0BFB FA FC FF      lea d, [bp + -4] ; $digits
1288   0BFE D7            push a
1289   0BFF DA            push d
1290   0C00 FA FA FF      lea d, [bp + -6] ; $i
1291   0C03 2A            mov b, [d]
1292   0C04 38 00 00      mov c, 0
1293   0C07 E7            pop d
1294   0C08 5A            add d, b
1295   0C09 E4            pop a
1296   0C0A DA            push d
1297   0C0B FD 2E 30 00   mov32 cb, $00000030
1297   0C0F 00 00 
1298   0C11             ; --- START TERMS
1299   0C11 D7            push a
1300   0C12 11            mov a, b
1301   0C13 FA 05 00      lea d, [bp + 5] ; $num
1302   0C16 2A            mov b, [d]
1303   0C17 38 00 00      mov c, 0
1304   0C1A             ; --- START FACTORS
1305   0C1A D7            push a
1306   0C1B FD D8         push g
1307   0C1D 11            mov a, b
1308   0C1E FD 7A         mov g, c
1309   0C20 FD 2E 0A 00   mov32 cb, $0000000a
1309   0C24 00 00 
1310   0C26 AE            div a, b ; 
1311   0C27 11            mov a, b
1312   0C28 FD 38         mov c, g
1313   0C2A 27            mov b, a
1314   0C2B FD F1         pop g
1315   0C2D E4            pop a
1316   0C2E             ; --- END FACTORS
1317   0C2E 56            add b, a
1318   0C2F E4            pop a
1319   0C30             ; --- END TERMS
1320   0C30 E7            pop d
1321   0C31 FD 3E         mov [d], bl
1322   0C33             ; num = num / 10; 
1323   0C33 FA 05 00      lea d, [bp + 5] ; $num
1324   0C36 DA            push d
1325   0C37 FA 05 00      lea d, [bp + 5] ; $num
1326   0C3A 2A            mov b, [d]
1327   0C3B 38 00 00      mov c, 0
1328   0C3E             ; --- START FACTORS
1329   0C3E D7            push a
1330   0C3F FD D8         push g
1331   0C41 11            mov a, b
1332   0C42 FD 7A         mov g, c
1333   0C44 FD 2E 0A 00   mov32 cb, $0000000a
1333   0C48 00 00 
1334   0C4A AE            div a, b
1335   0C4B FD 38         mov c, g
1336   0C4D 27            mov b, a
1337   0C4E FD F1         pop g
1338   0C50 E4            pop a
1339   0C51             ; --- END FACTORS
1340   0C51 E7            pop d
1341   0C52 FD 43         mov [d], b
1342   0C54             ; i++; 
1343   0C54 FA FA FF      lea d, [bp + -6] ; $i
1344   0C57 2A            mov b, [d]
1345   0C58 38 00 00      mov c, 0
1346   0C5B 11            mov a, b
1347   0C5C FD 77         inc b
1348   0C5E FA FA FF      lea d, [bp + -6] ; $i
1349   0C61 FD 43         mov [d], b
1350   0C63 27            mov b, a
1351   0C64 0A E2 0B      jmp _while38_cond
1352   0C67             _while38_exit:
1353   0C67             ; while (i > 0) { 
1354   0C67             _while45_cond:
1355   0C67 FA FA FF      lea d, [bp + -6] ; $i
1356   0C6A 2A            mov b, [d]
1357   0C6B 38 00 00      mov c, 0
1358   0C6E             ; --- START RELATIONAL
1359   0C6E D7            push a
1360   0C6F 11            mov a, b
1361   0C70 FD 2E 00 00   mov32 cb, $00000000
1361   0C74 00 00 
1362   0C76 B0            cmp a, b
1363   0C77 FD 7F         sgt ; >
1364   0C79 E4            pop a
1365   0C7A             ; --- END RELATIONAL
1366   0C7A C0 00 00      cmp b, 0
1367   0C7D C6 AF 0C      je _while45_exit
1368   0C80             _while45_block:
1369   0C80             ; i--; 
1370   0C80 FA FA FF      lea d, [bp + -6] ; $i
1371   0C83 2A            mov b, [d]
1372   0C84 38 00 00      mov c, 0
1373   0C87 11            mov a, b
1374   0C88 FD 7D         dec b
1375   0C8A FA FA FF      lea d, [bp + -6] ; $i
1376   0C8D FD 43         mov [d], b
1377   0C8F 27            mov b, a
1378   0C90             ; putchar(digits[i]); 
1379   0C90             ; --- START FUNCTION CALL
1380   0C90 FA FC FF      lea d, [bp + -4] ; $digits
1381   0C93 D7            push a
1382   0C94 DA            push d
1383   0C95 FA FA FF      lea d, [bp + -6] ; $i
1384   0C98 2A            mov b, [d]
1385   0C99 38 00 00      mov c, 0
1386   0C9C E7            pop d
1387   0C9D 5A            add d, b
1388   0C9E E4            pop a
1389   0C9F 32            mov bl, [d]
1390   0CA0 A7 00         mov bh, 0
1391   0CA2 38 00 00      mov c, 0
1392   0CA5 DD            push bl
1393   0CA6 07 90 08      call putchar
1394   0CA9 51 01 00      add sp, 1
1395   0CAC             ; --- END FUNCTION CALL
1396   0CAC 0A 67 0C      jmp _while45_cond
1397   0CAF             _while45_exit:
1398   0CAF F9            leave
1399   0CB0 09            ret
1400   0CB1             
1401   0CB1             printx16:
1402   0CB1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1403   0CB4             ; --- BEGIN INLINE ASM SEGMENT
1404   0CB4 FA 05 00      lea d, [bp + 5] ; $hex
1405   0CB7 2A            mov b, [d]
1406   0CB8             print_u16x_printx16:
1407   0CB8 DD            push bl
1408   0CB9 30            mov bl, bh
1409   0CBA 07 D7 0C      call _itoa_printx16        
1410   0CBD 2F            mov bl, al        
1411   0CBE 19 00         mov al, 0
1412   0CC0 05 03         syscall sys_io        
1413   0CC2 24            mov ah, bl        
1414   0CC3 19 00         mov al, 0
1415   0CC5 05 03         syscall sys_io        
1416   0CC7 EA            pop bl
1417   0CC8 07 D7 0C      call _itoa_printx16        
1418   0CCB 2F            mov bl, al        
1419   0CCC 19 00         mov al, 0
1420   0CCE 05 03         syscall sys_io        
1421   0CD0 24            mov ah, bl        
1422   0CD1 19 00         mov al, 0
1423   0CD3 05 03         syscall sys_io        
1424   0CD5             ; --- END INLINE ASM SEGMENT
1425   0CD5             ; return; 
1426   0CD5 F9            leave
1427   0CD6 09            ret
1428   0CD7             ; --- BEGIN INLINE ASM SEGMENT
1429   0CD7             _itoa_printx16:
1430   0CD7 DA            push d
1431   0CD8 D8            push b
1432   0CD9 A7 00         mov bh, 0
1433   0CDB FD A4 04      shr bl, 4  
1434   0CDE 74            mov d, b
1435   0CDF 1F F1 0C      mov al, [d + s_hex_digits_printx16]
1436   0CE2 23            mov ah, al
1437   0CE3 E5            pop b
1438   0CE4 D8            push b
1439   0CE5 A7 00         mov bh, 0
1440   0CE7 FD 87 0F      and bl, $0F
1441   0CEA 74            mov d, b
1442   0CEB 1F F1 0C      mov al, [d + s_hex_digits_printx16]
1443   0CEE E5            pop b
1444   0CEF E7            pop d
1445   0CF0 09            ret
1446   0CF1 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
1446   0CF5 34 35 36 37 
1446   0CF9 38 39 41 42 
1446   0CFD 43 44 45 46 
1447   0D01             ; --- END INLINE ASM SEGMENT
1448   0D01 F9            leave
1449   0D02 09            ret
1450   0D03             ; --- END TEXT SEGMENT
1451   0D03             
1452   0D03             ; --- BEGIN DATA SEGMENT
1453   0D03 48 69 00    _s0: .db "Hi", 0
1454   0D06 55 6E 65 78 _s1: .db "Unexpected format in printf.", 0
1454   0D0A 70 65 63 74 
1454   0D0E 65 64 20 66 
1454   0D12 6F 72 6D 61 
1454   0D16 74 20 69 6E 
1454   0D1A 20 70 72 69 
1454   0D1E 6E 74 66 2E 
1454   0D22 00 
1455   0D23 45 72 72 6F _s2: .db "Error: Unknown argument type.\n", 0
1455   0D27 72 3A 20 55 
1455   0D2B 6E 6B 6E 6F 
1455   0D2F 77 6E 20 61 
1455   0D33 72 67 75 6D 
1455   0D37 65 6E 74 20 
1455   0D3B 74 79 70 65 
1455   0D3F 2E 0A 00 
1456   0D42             
1457   0D42 44 0D       _heap_top: .dw _heap
1458   0D44 00          _heap: .db 0
1459   0D45             ; --- END DATA SEGMENT
1460   0D45             
1461   0D45             .end
tasm: Number of errors = 0
