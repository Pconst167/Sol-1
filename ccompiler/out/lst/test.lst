0001   0000             ; --- FILENAME: test
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ;; c || a; 
0011   0408 3B 81 14      mov d, _c ; $c
0012   040B 32            mov bl, [d]
0013   040C A7 00         mov bh, 0
0014   040E D7            push a
0015   040F 11            mov a, b
0016   0410 3B 7D 14      mov d, _a ; $a
0017   0413 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0018   0416 FD 39         mov c, b ; And place it into C
0019   0418 2A            mov b, [d] ; Lower Word in B
0020   0419 FD A8         sor a, b ; ||
0021   041B D8            push b
0022   041C 26 00 00      mov b, 0
0023   041F 12            mov a, c
0024   0420 FD A8         sor a, b ; ||
0025   0422 E4            pop a
0026   0423 FD A8         sor a, b ; ||
0027   0425 E4            pop a
0028   0426 05 0B         syscall sys_terminate_proc
0029   0428             
0030   0428             strcpy:
0031   0428 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0032   042B             ; $psrc 
0033   042B             ; $pdest 
0034   042B 52 04 00      sub sp, 4
0035   042E             ;; psrc = src; 
0036   042E FA FF FF      lea d, [bp + -1] ; $psrc
0037   0431 DA            push d
0038   0432 FA 07 00      lea d, [bp + 7] ; $src
0039   0435 2A            mov b, [d]
0040   0436 E7            pop d
0041   0437 FD 43         mov [d], b
0042   0439             ;; pdest = dest; 
0043   0439 FA FD FF      lea d, [bp + -3] ; $pdest
0044   043C DA            push d
0045   043D FA 05 00      lea d, [bp + 5] ; $dest
0046   0440 2A            mov b, [d]
0047   0441 E7            pop d
0048   0442 FD 43         mov [d], b
0049   0444             ;; while(*psrc) *pdest++ = *psrc++; 
0050   0444             _while1_cond:
0051   0444 FA FF FF      lea d, [bp + -1] ; $psrc
0052   0447 2A            mov b, [d]
0053   0448 74            mov d, b
0054   0449 32            mov bl, [d]
0055   044A A7 00         mov bh, 0
0056   044C C0 00 00      cmp b, 0
0057   044F C6 77 04      je _while1_exit
0058   0452             _while1_block:
0059   0452             ;; *pdest++ = *psrc++; 
0060   0452 FA FD FF      lea d, [bp + -3] ; $pdest
0061   0455 2A            mov b, [d]
0062   0456 D8            push b
0063   0457 FD 77         inc b
0064   0459 FA FD FF      lea d, [bp + -3] ; $pdest
0065   045C FD 43         mov [d], b
0066   045E E5            pop b
0067   045F D8            push b
0068   0460 FA FF FF      lea d, [bp + -1] ; $psrc
0069   0463 2A            mov b, [d]
0070   0464 D8            push b
0071   0465 FD 77         inc b
0072   0467 FA FF FF      lea d, [bp + -1] ; $psrc
0073   046A FD 43         mov [d], b
0074   046C E5            pop b
0075   046D 74            mov d, b
0076   046E 32            mov bl, [d]
0077   046F A7 00         mov bh, 0
0078   0471 E7            pop d
0079   0472 FD 3E         mov [d], bl
0080   0474 0A 44 04      jmp _while1_cond
0081   0477             _while1_exit:
0082   0477             ;; *pdest = '\0'; 
0083   0477 FA FD FF      lea d, [bp + -3] ; $pdest
0084   047A 2A            mov b, [d]
0085   047B D8            push b
0086   047C 26 00 00      mov b, $0
0087   047F E7            pop d
0088   0480 FD 3E         mov [d], bl
0089   0482 F9            leave
0090   0483 09            ret
0091   0484             
0092   0484             strcmp:
0093   0484 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0094   0487             ;; while (*s1 && (*s1 == *s2)) { 
0095   0487             _while2_cond:
0096   0487 FA 05 00      lea d, [bp + 5] ; $s1
0097   048A 2A            mov b, [d]
0098   048B 74            mov d, b
0099   048C 32            mov bl, [d]
0100   048D A7 00         mov bh, 0
0101   048F D7            push a
0102   0490 11            mov a, b
0103   0491 FA 05 00      lea d, [bp + 5] ; $s1
0104   0494 2A            mov b, [d]
0105   0495 74            mov d, b
0106   0496 32            mov bl, [d]
0107   0497 A7 00         mov bh, 0
0108   0499             ; START RELATIONAL
0109   0499 D7            push a
0110   049A 11            mov a, b
0111   049B FA 07 00      lea d, [bp + 7] ; $s2
0112   049E 2A            mov b, [d]
0113   049F 74            mov d, b
0114   04A0 32            mov bl, [d]
0115   04A1 A7 00         mov bh, 0
0116   04A3 B0            cmp a, b
0117   04A4 FD 71         seq ; ==
0118   04A6 E4            pop a
0119   04A7             ; END RELATIONAL
0120   04A7 FD A7         sand a, b ; &&
0121   04A9 E4            pop a
0122   04AA C0 00 00      cmp b, 0
0123   04AD C6 CD 04      je _while2_exit
0124   04B0             _while2_block:
0125   04B0             ;; s1++; 
0126   04B0 FA 05 00      lea d, [bp + 5] ; $s1
0127   04B3 2A            mov b, [d]
0128   04B4 D8            push b
0129   04B5 FD 77         inc b
0130   04B7 FA 05 00      lea d, [bp + 5] ; $s1
0131   04BA FD 43         mov [d], b
0132   04BC E5            pop b
0133   04BD             ;; s2++; 
0134   04BD FA 07 00      lea d, [bp + 7] ; $s2
0135   04C0 2A            mov b, [d]
0136   04C1 D8            push b
0137   04C2 FD 77         inc b
0138   04C4 FA 07 00      lea d, [bp + 7] ; $s2
0139   04C7 FD 43         mov [d], b
0140   04C9 E5            pop b
0141   04CA 0A 87 04      jmp _while2_cond
0142   04CD             _while2_exit:
0143   04CD             ;; return *s1 - *s2; 
0144   04CD FA 05 00      lea d, [bp + 5] ; $s1
0145   04D0 2A            mov b, [d]
0146   04D1 74            mov d, b
0147   04D2 32            mov bl, [d]
0148   04D3 A7 00         mov bh, 0
0149   04D5             ; START TERMS
0150   04D5 D7            push a
0151   04D6 11            mov a, b
0152   04D7 FA 07 00      lea d, [bp + 7] ; $s2
0153   04DA 2A            mov b, [d]
0154   04DB 74            mov d, b
0155   04DC 32            mov bl, [d]
0156   04DD A7 00         mov bh, 0
0157   04DF 60            sub a, b
0158   04E0 27            mov b, a
0159   04E1 E4            pop a
0160   04E2             ; END TERMS
0161   04E2 F9            leave
0162   04E3 09            ret
0163   04E4             
0164   04E4             strcat:
0165   04E4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0166   04E7             ; $dest_len 
0167   04E7             ; $i 
0168   04E7 52 04 00      sub sp, 4
0169   04EA             ;; dest_len = strlen(dest); 
0170   04EA FA FF FF      lea d, [bp + -1] ; $dest_len
0171   04ED DA            push d
0172   04EE FA 05 00      lea d, [bp + 5] ; $dest
0173   04F1 2A            mov b, [d]
0174   04F2 FD AB         swp b
0175   04F4 D8            push b
0176   04F5 07 9A 05      call strlen
0177   04F8 51 02 00      add sp, 2
0178   04FB E7            pop d
0179   04FC FD 43         mov [d], b
0180   04FE             ;; for (i = 0; src[i] != 0; i=i+1) { 
0181   04FE             _for3_init:
0182   04FE FA FD FF      lea d, [bp + -3] ; $i
0183   0501 DA            push d
0184   0502 26 00 00      mov b, $0
0185   0505 E7            pop d
0186   0506 FD 43         mov [d], b
0187   0508             _for3_cond:
0188   0508 FA 07 00      lea d, [bp + 7] ; $src
0189   050B FD 2A         mov d, [d]
0190   050D D7            push a
0191   050E DA            push d
0192   050F FA FD FF      lea d, [bp + -3] ; $i
0193   0512 2A            mov b, [d]
0194   0513 E7            pop d
0195   0514 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0196   0518 E4            pop a
0197   0519 32            mov bl, [d]
0198   051A A7 00         mov bh, 0
0199   051C             ; START RELATIONAL
0200   051C D7            push a
0201   051D 11            mov a, b
0202   051E 26 00 00      mov b, $0
0203   0521 B0            cmp a, b
0204   0522 FD 72         sneq ; !=
0205   0524 E4            pop a
0206   0525             ; END RELATIONAL
0207   0525 C0 00 00      cmp b, 0
0208   0528 C6 73 05      je _for3_exit
0209   052B             _for3_block:
0210   052B             ;; dest[dest_len + i] = src[i]; 
0211   052B FA 05 00      lea d, [bp + 5] ; $dest
0212   052E FD 2A         mov d, [d]
0213   0530 D7            push a
0214   0531 DA            push d
0215   0532 FA FF FF      lea d, [bp + -1] ; $dest_len
0216   0535 2A            mov b, [d]
0217   0536             ; START TERMS
0218   0536 D7            push a
0219   0537 11            mov a, b
0220   0538 FA FD FF      lea d, [bp + -3] ; $i
0221   053B 2A            mov b, [d]
0222   053C 54            add a, b
0223   053D 27            mov b, a
0224   053E E4            pop a
0225   053F             ; END TERMS
0226   053F E7            pop d
0227   0540 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0228   0544 E4            pop a
0229   0545 DA            push d
0230   0546 FA 07 00      lea d, [bp + 7] ; $src
0231   0549 FD 2A         mov d, [d]
0232   054B D7            push a
0233   054C DA            push d
0234   054D FA FD FF      lea d, [bp + -3] ; $i
0235   0550 2A            mov b, [d]
0236   0551 E7            pop d
0237   0552 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0238   0556 E4            pop a
0239   0557 32            mov bl, [d]
0240   0558 A7 00         mov bh, 0
0241   055A E7            pop d
0242   055B FD 3E         mov [d], bl
0243   055D             _for3_update:
0244   055D FA FD FF      lea d, [bp + -3] ; $i
0245   0560 DA            push d
0246   0561 FA FD FF      lea d, [bp + -3] ; $i
0247   0564 2A            mov b, [d]
0248   0565             ; START TERMS
0249   0565 D7            push a
0250   0566 11            mov a, b
0251   0567 26 01 00      mov b, $1
0252   056A 54            add a, b
0253   056B 27            mov b, a
0254   056C E4            pop a
0255   056D             ; END TERMS
0256   056D E7            pop d
0257   056E FD 43         mov [d], b
0258   0570 0A 08 05      jmp _for3_cond
0259   0573             _for3_exit:
0260   0573             ;; dest[dest_len + i] = 0; 
0261   0573 FA 05 00      lea d, [bp + 5] ; $dest
0262   0576 FD 2A         mov d, [d]
0263   0578 D7            push a
0264   0579 DA            push d
0265   057A FA FF FF      lea d, [bp + -1] ; $dest_len
0266   057D 2A            mov b, [d]
0267   057E             ; START TERMS
0268   057E D7            push a
0269   057F 11            mov a, b
0270   0580 FA FD FF      lea d, [bp + -3] ; $i
0271   0583 2A            mov b, [d]
0272   0584 54            add a, b
0273   0585 27            mov b, a
0274   0586 E4            pop a
0275   0587             ; END TERMS
0276   0587 E7            pop d
0277   0588 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0278   058C E4            pop a
0279   058D DA            push d
0280   058E 26 00 00      mov b, $0
0281   0591 E7            pop d
0282   0592 FD 3E         mov [d], bl
0283   0594             ;; return dest; 
0284   0594 FA 05 00      lea d, [bp + 5] ; $dest
0285   0597 2A            mov b, [d]
0286   0598 F9            leave
0287   0599 09            ret
0288   059A             
0289   059A             strlen:
0290   059A F8 00 00      enter 0 ; (push bp; mov bp, sp)
0291   059D             ; $length 
0292   059D 52 02 00      sub sp, 2
0293   05A0             ;; length = 0; 
0294   05A0 FA FF FF      lea d, [bp + -1] ; $length
0295   05A3 DA            push d
0296   05A4 26 00 00      mov b, $0
0297   05A7 E7            pop d
0298   05A8 FD 43         mov [d], b
0299   05AA             ;; while (str[length] != 0) { 
0300   05AA             _while4_cond:
0301   05AA FA 05 00      lea d, [bp + 5] ; $str
0302   05AD FD 2A         mov d, [d]
0303   05AF D7            push a
0304   05B0 DA            push d
0305   05B1 FA FF FF      lea d, [bp + -1] ; $length
0306   05B4 2A            mov b, [d]
0307   05B5 E7            pop d
0308   05B6 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0309   05BA E4            pop a
0310   05BB 32            mov bl, [d]
0311   05BC A7 00         mov bh, 0
0312   05BE             ; START RELATIONAL
0313   05BE D7            push a
0314   05BF 11            mov a, b
0315   05C0 26 00 00      mov b, $0
0316   05C3 B0            cmp a, b
0317   05C4 FD 72         sneq ; !=
0318   05C6 E4            pop a
0319   05C7             ; END RELATIONAL
0320   05C7 C0 00 00      cmp b, 0
0321   05CA C6 DD 05      je _while4_exit
0322   05CD             _while4_block:
0323   05CD             ;; length++; 
0324   05CD FA FF FF      lea d, [bp + -1] ; $length
0325   05D0 2A            mov b, [d]
0326   05D1 D8            push b
0327   05D2 FD 77         inc b
0328   05D4 FA FF FF      lea d, [bp + -1] ; $length
0329   05D7 FD 43         mov [d], b
0330   05D9 E5            pop b
0331   05DA 0A AA 05      jmp _while4_cond
0332   05DD             _while4_exit:
0333   05DD             ;; return length; 
0334   05DD FA FF FF      lea d, [bp + -1] ; $length
0335   05E0 2A            mov b, [d]
0336   05E1 F9            leave
0337   05E2 09            ret
0338   05E3             
0339   05E3             exit:
0340   05E3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0341   05E6             
0342   05E6             ; --- BEGIN INLINE ASM BLOCK
0343   05E6 05 0B         syscall sys_terminate_proc
0344   05E8             ; --- END INLINE ASM BLOCK
0345   05E8             
0346   05E8 F9            leave
0347   05E9 09            ret
0348   05EA             
0349   05EA             atoi:
0350   05EA F8 00 00      enter 0 ; (push bp; mov bp, sp)
0351   05ED             ; $result 
0352   05ED 10 00 00      mov a, $0
0353   05F0 45 FF FF      mov [bp + -1], a
0354   05F3             ; $sign 
0355   05F3 10 01 00      mov a, $1
0356   05F6 45 FD FF      mov [bp + -3], a
0357   05F9 52 04 00      sub sp, 4
0358   05FC             ;; while (*str == ' ') str++; 
0359   05FC             _while5_cond:
0360   05FC FA 05 00      lea d, [bp + 5] ; $str
0361   05FF 2A            mov b, [d]
0362   0600 74            mov d, b
0363   0601 32            mov bl, [d]
0364   0602 A7 00         mov bh, 0
0365   0604             ; START RELATIONAL
0366   0604 D7            push a
0367   0605 11            mov a, b
0368   0606 26 20 00      mov b, $20
0369   0609 B0            cmp a, b
0370   060A FD 71         seq ; ==
0371   060C E4            pop a
0372   060D             ; END RELATIONAL
0373   060D C0 00 00      cmp b, 0
0374   0610 C6 23 06      je _while5_exit
0375   0613             _while5_block:
0376   0613             ;; str++; 
0377   0613 FA 05 00      lea d, [bp + 5] ; $str
0378   0616 2A            mov b, [d]
0379   0617 D8            push b
0380   0618 FD 77         inc b
0381   061A FA 05 00      lea d, [bp + 5] ; $str
0382   061D FD 43         mov [d], b
0383   061F E5            pop b
0384   0620 0A FC 05      jmp _while5_cond
0385   0623             _while5_exit:
0386   0623             ;; if (*str == '-' || *str == '+') { 
0387   0623             _if6_cond:
0388   0623 FA 05 00      lea d, [bp + 5] ; $str
0389   0626 2A            mov b, [d]
0390   0627 74            mov d, b
0391   0628 32            mov bl, [d]
0392   0629 A7 00         mov bh, 0
0393   062B             ; START RELATIONAL
0394   062B D7            push a
0395   062C 11            mov a, b
0396   062D 26 2D 00      mov b, $2d
0397   0630 B0            cmp a, b
0398   0631 FD 71         seq ; ==
0399   0633 E4            pop a
0400   0634             ; END RELATIONAL
0401   0634 D7            push a
0402   0635 11            mov a, b
0403   0636 FA 05 00      lea d, [bp + 5] ; $str
0404   0639 2A            mov b, [d]
0405   063A 74            mov d, b
0406   063B 32            mov bl, [d]
0407   063C A7 00         mov bh, 0
0408   063E             ; START RELATIONAL
0409   063E D7            push a
0410   063F 11            mov a, b
0411   0640 26 2B 00      mov b, $2b
0412   0643 B0            cmp a, b
0413   0644 FD 71         seq ; ==
0414   0646 E4            pop a
0415   0647             ; END RELATIONAL
0416   0647 FD A8         sor a, b ; ||
0417   0649 E4            pop a
0418   064A C0 00 00      cmp b, 0
0419   064D C6 84 06      je _if6_exit
0420   0650             _if6_true:
0421   0650             ;; if (*str == '-') sign = -1; 
0422   0650             _if7_cond:
0423   0650 FA 05 00      lea d, [bp + 5] ; $str
0424   0653 2A            mov b, [d]
0425   0654 74            mov d, b
0426   0655 32            mov bl, [d]
0427   0656 A7 00         mov bh, 0
0428   0658             ; START RELATIONAL
0429   0658 D7            push a
0430   0659 11            mov a, b
0431   065A 26 2D 00      mov b, $2d
0432   065D B0            cmp a, b
0433   065E FD 71         seq ; ==
0434   0660 E4            pop a
0435   0661             ; END RELATIONAL
0436   0661 C0 00 00      cmp b, 0
0437   0664 C6 74 06      je _if7_exit
0438   0667             _if7_true:
0439   0667             ;; sign = -1; 
0440   0667 FA FD FF      lea d, [bp + -3] ; $sign
0441   066A DA            push d
0442   066B 26 FF FF      mov b, $ffffffff
0443   066E E7            pop d
0444   066F FD 43         mov [d], b
0445   0671 0A 74 06      jmp _if7_exit
0446   0674             _if7_exit:
0447   0674             ;; str++; 
0448   0674 FA 05 00      lea d, [bp + 5] ; $str
0449   0677 2A            mov b, [d]
0450   0678 D8            push b
0451   0679 FD 77         inc b
0452   067B FA 05 00      lea d, [bp + 5] ; $str
0453   067E FD 43         mov [d], b
0454   0680 E5            pop b
0455   0681 0A 84 06      jmp _if6_exit
0456   0684             _if6_exit:
0457   0684             ;; while (*str >= '0' && *str <= '9') { 
0458   0684             _while8_cond:
0459   0684 FA 05 00      lea d, [bp + 5] ; $str
0460   0687 2A            mov b, [d]
0461   0688 74            mov d, b
0462   0689 32            mov bl, [d]
0463   068A A7 00         mov bh, 0
0464   068C             ; START RELATIONAL
0465   068C D7            push a
0466   068D 11            mov a, b
0467   068E 26 30 00      mov b, $30
0468   0691 B0            cmp a, b
0469   0692 FD 82         sgeu ; >= (unsigned)
0470   0694 E4            pop a
0471   0695             ; END RELATIONAL
0472   0695 D7            push a
0473   0696 11            mov a, b
0474   0697 FA 05 00      lea d, [bp + 5] ; $str
0475   069A 2A            mov b, [d]
0476   069B 74            mov d, b
0477   069C 32            mov bl, [d]
0478   069D A7 00         mov bh, 0
0479   069F             ; START RELATIONAL
0480   069F D7            push a
0481   06A0 11            mov a, b
0482   06A1 26 39 00      mov b, $39
0483   06A4 B0            cmp a, b
0484   06A5 FD 76         sleu ; <= (unsigned)
0485   06A7 E4            pop a
0486   06A8             ; END RELATIONAL
0487   06A8 FD A7         sand a, b ; &&
0488   06AA E4            pop a
0489   06AB C0 00 00      cmp b, 0
0490   06AE C6 EA 06      je _while8_exit
0491   06B1             _while8_block:
0492   06B1             ;; result = result * 10 + (*str - '0'); 
0493   06B1 FA FF FF      lea d, [bp + -1] ; $result
0494   06B4 DA            push d
0495   06B5 FA FF FF      lea d, [bp + -1] ; $result
0496   06B8 2A            mov b, [d]
0497   06B9             ; START FACTORS
0498   06B9 D7            push a
0499   06BA 11            mov a, b
0500   06BB 26 0A 00      mov b, $a
0501   06BE AC            mul a, b ; *
0502   06BF 11            mov a, b
0503   06C0 27            mov b, a
0504   06C1 E4            pop a
0505   06C2             ; END FACTORS
0506   06C2             ; START TERMS
0507   06C2 D7            push a
0508   06C3 11            mov a, b
0509   06C4 FA 05 00      lea d, [bp + 5] ; $str
0510   06C7 2A            mov b, [d]
0511   06C8 74            mov d, b
0512   06C9 32            mov bl, [d]
0513   06CA A7 00         mov bh, 0
0514   06CC             ; START TERMS
0515   06CC D7            push a
0516   06CD 11            mov a, b
0517   06CE 26 30 00      mov b, $30
0518   06D1 60            sub a, b
0519   06D2 27            mov b, a
0520   06D3 E4            pop a
0521   06D4             ; END TERMS
0522   06D4 54            add a, b
0523   06D5 27            mov b, a
0524   06D6 E4            pop a
0525   06D7             ; END TERMS
0526   06D7 E7            pop d
0527   06D8 FD 43         mov [d], b
0528   06DA             ;; str++; 
0529   06DA FA 05 00      lea d, [bp + 5] ; $str
0530   06DD 2A            mov b, [d]
0531   06DE D8            push b
0532   06DF FD 77         inc b
0533   06E1 FA 05 00      lea d, [bp + 5] ; $str
0534   06E4 FD 43         mov [d], b
0535   06E6 E5            pop b
0536   06E7 0A 84 06      jmp _while8_cond
0537   06EA             _while8_exit:
0538   06EA             ;; return sign * result; 
0539   06EA FA FD FF      lea d, [bp + -3] ; $sign
0540   06ED 2A            mov b, [d]
0541   06EE             ; START FACTORS
0542   06EE D7            push a
0543   06EF 11            mov a, b
0544   06F0 FA FF FF      lea d, [bp + -1] ; $result
0545   06F3 2A            mov b, [d]
0546   06F4 AC            mul a, b ; *
0547   06F5 11            mov a, b
0548   06F6 27            mov b, a
0549   06F7 E4            pop a
0550   06F8             ; END FACTORS
0551   06F8 F9            leave
0552   06F9 09            ret
0553   06FA             
0554   06FA             rand:
0555   06FA F8 00 00      enter 0 ; (push bp; mov bp, sp)
0556   06FD             ; $sec 
0557   06FD 52 02 00      sub sp, 2
0558   0700             
0559   0700             ; --- BEGIN INLINE ASM BLOCK
0560   0700 19 00         mov al, 0
0561   0702 05 01         syscall sys_rtc					
0562   0704 1A            mov al, ah
0563   0705 FA FF FF      lea d, [bp + -1] ; $sec
0564   0708 1E            mov al, [d]
0565   0709 22 00         mov ah, 0
0566   070B             ; --- END INLINE ASM BLOCK
0567   070B             
0568   070B             ;; return sec; 
0569   070B FA FF FF      lea d, [bp + -1] ; $sec
0570   070E 2A            mov b, [d]
0571   070F F9            leave
0572   0710 09            ret
0573   0711             
0574   0711             srand:
0575   0711 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0576   0714 F9            leave
0577   0715 09            ret
0578   0716             
0579   0716             malloc:
0580   0716 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0581   0719 F9            leave
0582   071A 09            ret
0583   071B             
0584   071B             calloc:
0585   071B F8 00 00      enter 0 ; (push bp; mov bp, sp)
0586   071E F9            leave
0587   071F 09            ret
0588   0720             
0589   0720             realloc:
0590   0720 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0591   0723 F9            leave
0592   0724 09            ret
0593   0725             
0594   0725             alloc:
0595   0725 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0596   0728             ;; heap_top = heap_top + bytes; 
0597   0728 3B C6 14      mov d, _heap_top ; $heap_top
0598   072B DA            push d
0599   072C 3B C6 14      mov d, _heap_top ; $heap_top
0600   072F 2A            mov b, [d]
0601   0730             ; START TERMS
0602   0730 D7            push a
0603   0731 11            mov a, b
0604   0732 FA 05 00      lea d, [bp + 5] ; $bytes
0605   0735 2A            mov b, [d]
0606   0736 54            add a, b
0607   0737 27            mov b, a
0608   0738 E4            pop a
0609   0739             ; END TERMS
0610   0739 E7            pop d
0611   073A FD 43         mov [d], b
0612   073C             ;; return heap_top - bytes; 
0613   073C 3B C6 14      mov d, _heap_top ; $heap_top
0614   073F 2A            mov b, [d]
0615   0740             ; START TERMS
0616   0740 D7            push a
0617   0741 11            mov a, b
0618   0742 FA 05 00      lea d, [bp + 5] ; $bytes
0619   0745 2A            mov b, [d]
0620   0746 60            sub a, b
0621   0747 27            mov b, a
0622   0748 E4            pop a
0623   0749             ; END TERMS
0624   0749 F9            leave
0625   074A 09            ret
0626   074B             
0627   074B             free:
0628   074B F8 00 00      enter 0 ; (push bp; mov bp, sp)
0629   074E             ;; return heap_top = heap_top - bytes; 
0630   074E 3B C6 14      mov d, _heap_top ; $heap_top
0631   0751 DA            push d
0632   0752 3B C6 14      mov d, _heap_top ; $heap_top
0633   0755 2A            mov b, [d]
0634   0756             ; START TERMS
0635   0756 D7            push a
0636   0757 11            mov a, b
0637   0758 FA 05 00      lea d, [bp + 5] ; $bytes
0638   075B 2A            mov b, [d]
0639   075C 60            sub a, b
0640   075D 27            mov b, a
0641   075E E4            pop a
0642   075F             ; END TERMS
0643   075F E7            pop d
0644   0760 FD 43         mov [d], b
0645   0762 F9            leave
0646   0763 09            ret
0647   0764             
0648   0764             va_start:
0649   0764 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0650   0767             ;; argp->current_arg = first_fixed_param + sizeof(first_fixed_param); 
0651   0767 FA 05 00      lea d, [bp + 5] ; $argp
0652   076A FD 2A         mov d, [d]
0653   076C 58 00 00      add d, 0
0654   076F DA            push d
0655   0770 FA 07 00      lea d, [bp + 7] ; $first_fixed_param
0656   0773 2A            mov b, [d]
0657   0774             ; START TERMS
0658   0774 D7            push a
0659   0775 11            mov a, b
0660   0776 26 02 00      mov b, 2
0661   0779 54            add a, b
0662   077A 27            mov b, a
0663   077B E4            pop a
0664   077C             ; END TERMS
0665   077C E7            pop d
0666   077D FD 43         mov [d], b
0667   077F F9            leave
0668   0780 09            ret
0669   0781             
0670   0781             va_arg:
0671   0781 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0672   0784             ; $p 
0673   0784 52 02 00      sub sp, 2
0674   0787             ;; p = argp->current_arg; 
0675   0787 FA FF FF      lea d, [bp + -1] ; $p
0676   078A DA            push d
0677   078B FA 05 00      lea d, [bp + 5] ; $argp
0678   078E FD 2A         mov d, [d]
0679   0790 58 00 00      add d, 0
0680   0793 2A            mov b, [d]
0681   0794 E7            pop d
0682   0795 FD 43         mov [d], b
0683   0797             ;; argp->current_arg = argp->current_arg + size; 
0684   0797 FA 05 00      lea d, [bp + 5] ; $argp
0685   079A FD 2A         mov d, [d]
0686   079C 58 00 00      add d, 0
0687   079F DA            push d
0688   07A0 FA 05 00      lea d, [bp + 5] ; $argp
0689   07A3 FD 2A         mov d, [d]
0690   07A5 58 00 00      add d, 0
0691   07A8 2A            mov b, [d]
0692   07A9             ; START TERMS
0693   07A9 D7            push a
0694   07AA 11            mov a, b
0695   07AB FA 07 00      lea d, [bp + 7] ; $size
0696   07AE 2A            mov b, [d]
0697   07AF 54            add a, b
0698   07B0 27            mov b, a
0699   07B1 E4            pop a
0700   07B2             ; END TERMS
0701   07B2 E7            pop d
0702   07B3 FD 43         mov [d], b
0703   07B5             ;; return p; 
0704   07B5 FA FF FF      lea d, [bp + -1] ; $p
0705   07B8 2A            mov b, [d]
0706   07B9 F9            leave
0707   07BA 09            ret
0708   07BB             
0709   07BB             va_end:
0710   07BB F8 00 00      enter 0 ; (push bp; mov bp, sp)
0711   07BE             ;; argp->current_arg =   0   ; 
0712   07BE FA 05 00      lea d, [bp + 5] ; $argp
0713   07C1 FD 2A         mov d, [d]
0714   07C3 58 00 00      add d, 0
0715   07C6 DA            push d
0716   07C7 26 00 00      mov b, $0
0717   07CA E7            pop d
0718   07CB FD 43         mov [d], b
0719   07CD F9            leave
0720   07CE 09            ret
0721   07CF             
0722   07CF             printf:
0723   07CF F8 00 00      enter 0 ; (push bp; mov bp, sp)
0724   07D2             ; $p 
0725   07D2             ; $fp 
0726   07D2             ; $i 
0727   07D2 52 06 00      sub sp, 6
0728   07D5             ;; fp = format; 
0729   07D5 FA FD FF      lea d, [bp + -3] ; $fp
0730   07D8 DA            push d
0731   07D9 FA 05 00      lea d, [bp + 5] ; $format
0732   07DC 2A            mov b, [d]
0733   07DD E7            pop d
0734   07DE FD 43         mov [d], b
0735   07E0             ;; p = &format + 2; 
0736   07E0 FA FF FF      lea d, [bp + -1] ; $p
0737   07E3 DA            push d
0738   07E4 FA 05 00      lea d, [bp + 5] ; $format
0739   07E7 2D            mov b, d
0740   07E8             ; START TERMS
0741   07E8 D7            push a
0742   07E9 11            mov a, b
0743   07EA 26 02 00      mov b, $2
0744   07ED 54            add a, b
0745   07EE 27            mov b, a
0746   07EF E4            pop a
0747   07F0             ; END TERMS
0748   07F0 E7            pop d
0749   07F1 FD 43         mov [d], b
0750   07F3             ;; for(;;){ 
0751   07F3             _for9_init:
0752   07F3             _for9_cond:
0753   07F3             _for9_block:
0754   07F3             ;; if(!*fp) break; 
0755   07F3             _if10_cond:
0756   07F3 FA FD FF      lea d, [bp + -3] ; $fp
0757   07F6 2A            mov b, [d]
0758   07F7 74            mov d, b
0759   07F8 32            mov bl, [d]
0760   07F9 A7 00         mov bh, 0
0761   07FB C0 00 00      cmp b, 0
0762   07FE FD 71         seq ; !
0763   0800 C0 00 00      cmp b, 0
0764   0803 C6 0C 08      je _if10_else
0765   0806             _if10_true:
0766   0806             ;; break; 
0767   0806 0A 18 0A      jmp _for9_exit ; for break
0768   0809 0A 15 0A      jmp _if10_exit
0769   080C             _if10_else:
0770   080C             ;; if(*fp == '%'){ 
0771   080C             _if11_cond:
0772   080C FA FD FF      lea d, [bp + -3] ; $fp
0773   080F 2A            mov b, [d]
0774   0810 74            mov d, b
0775   0811 32            mov bl, [d]
0776   0812 A7 00         mov bh, 0
0777   0814             ; START RELATIONAL
0778   0814 D7            push a
0779   0815 11            mov a, b
0780   0816 26 25 00      mov b, $25
0781   0819 B0            cmp a, b
0782   081A FD 71         seq ; ==
0783   081C E4            pop a
0784   081D             ; END RELATIONAL
0785   081D C0 00 00      cmp b, 0
0786   0820 C6 F9 09      je _if11_else
0787   0823             _if11_true:
0788   0823             ;; fp++; 
0789   0823 FA FD FF      lea d, [bp + -3] ; $fp
0790   0826 2A            mov b, [d]
0791   0827 D8            push b
0792   0828 FD 77         inc b
0793   082A FA FD FF      lea d, [bp + -3] ; $fp
0794   082D FD 43         mov [d], b
0795   082F E5            pop b
0796   0830             ;; switch(*fp){ 
0797   0830             _switch12_expr:
0798   0830 FA FD FF      lea d, [bp + -3] ; $fp
0799   0833 2A            mov b, [d]
0800   0834 74            mov d, b
0801   0835 32            mov bl, [d]
0802   0836 A7 00         mov bh, 0
0803   0838             _switch12_comparisons:
0804   0838 C1 6C         cmp bl, $6c
0805   083A C6 66 08      je _switch12_case0
0806   083D C1 4C         cmp bl, $4c
0807   083F C6 66 08      je _switch12_case1
0808   0842 C1 64         cmp bl, $64
0809   0844 C6 34 09      je _switch12_case2
0810   0847 C1 69         cmp bl, $69
0811   0849 C6 34 09      je _switch12_case3
0812   084C C1 75         cmp bl, $75
0813   084E C6 59 09      je _switch12_case4
0814   0851 C1 78         cmp bl, $78
0815   0853 C6 7E 09      je _switch12_case5
0816   0856 C1 63         cmp bl, $63
0817   0858 C6 9D 09      je _switch12_case6
0818   085B C1 73         cmp bl, $73
0819   085D C6 BD 09      je _switch12_case7
0820   0860 0A DD 09      jmp _switch12_default
0821   0863 0A E9 09      jmp _switch12_exit
0822   0866             _switch12_case0:
0823   0866             _switch12_case1:
0824   0866             ;; fp++; 
0825   0866 FA FD FF      lea d, [bp + -3] ; $fp
0826   0869 2A            mov b, [d]
0827   086A D8            push b
0828   086B FD 77         inc b
0829   086D FA FD FF      lea d, [bp + -3] ; $fp
0830   0870 FD 43         mov [d], b
0831   0872 E5            pop b
0832   0873             ;; if(*fp == 'd' || *fp == 'i') 
0833   0873             _if13_cond:
0834   0873 FA FD FF      lea d, [bp + -3] ; $fp
0835   0876 2A            mov b, [d]
0836   0877 74            mov d, b
0837   0878 32            mov bl, [d]
0838   0879 A7 00         mov bh, 0
0839   087B             ; START RELATIONAL
0840   087B D7            push a
0841   087C 11            mov a, b
0842   087D 26 64 00      mov b, $64
0843   0880 B0            cmp a, b
0844   0881 FD 71         seq ; ==
0845   0883 E4            pop a
0846   0884             ; END RELATIONAL
0847   0884 D7            push a
0848   0885 11            mov a, b
0849   0886 FA FD FF      lea d, [bp + -3] ; $fp
0850   0889 2A            mov b, [d]
0851   088A 74            mov d, b
0852   088B 32            mov bl, [d]
0853   088C A7 00         mov bh, 0
0854   088E             ; START RELATIONAL
0855   088E D7            push a
0856   088F 11            mov a, b
0857   0890 26 69 00      mov b, $69
0858   0893 B0            cmp a, b
0859   0894 FD 71         seq ; ==
0860   0896 E4            pop a
0861   0897             ; END RELATIONAL
0862   0897 FD A8         sor a, b ; ||
0863   0899 E4            pop a
0864   089A C0 00 00      cmp b, 0
0865   089D C6 B4 08      je _if13_else
0866   08A0             _if13_true:
0867   08A0             ;; print_signed_long(*(long *)p); 
0868   08A0 FD 79         mov g, b
0869   08A2 28            mov b, c
0870   08A3 FD AB         swp b
0871   08A5 D8            push b
0872   08A6 FD 27         mov b, g
0873   08A8 FD AB         swp b
0874   08AA D8            push b
0875   08AB 07 D8 0C      call print_signed_long
0876   08AE 51 04 00      add sp, 4
0877   08B1 0A 1E 09      jmp _if13_exit
0878   08B4             _if13_else:
0879   08B4             ;; if(*fp == 'u') 
0880   08B4             _if14_cond:
0881   08B4 FA FD FF      lea d, [bp + -3] ; $fp
0882   08B7 2A            mov b, [d]
0883   08B8 74            mov d, b
0884   08B9 32            mov bl, [d]
0885   08BA A7 00         mov bh, 0
0886   08BC             ; START RELATIONAL
0887   08BC D7            push a
0888   08BD 11            mov a, b
0889   08BE 26 75 00      mov b, $75
0890   08C1 B0            cmp a, b
0891   08C2 FD 71         seq ; ==
0892   08C4 E4            pop a
0893   08C5             ; END RELATIONAL
0894   08C5 C0 00 00      cmp b, 0
0895   08C8 C6 DF 08      je _if14_else
0896   08CB             _if14_true:
0897   08CB             ;; print_unsigned_long(*(unsigned long *)p); 
0898   08CB FD 79         mov g, b
0899   08CD 28            mov b, c
0900   08CE FD AB         swp b
0901   08D0 D8            push b
0902   08D1 FD 27         mov b, g
0903   08D3 FD AB         swp b
0904   08D5 D8            push b
0905   08D6 07 2B 0E      call print_unsigned_long
0906   08D9 51 04 00      add sp, 4
0907   08DC 0A 1E 09      jmp _if14_exit
0908   08DF             _if14_else:
0909   08DF             ;; if(*fp == 'x') 
0910   08DF             _if15_cond:
0911   08DF FA FD FF      lea d, [bp + -3] ; $fp
0912   08E2 2A            mov b, [d]
0913   08E3 74            mov d, b
0914   08E4 32            mov bl, [d]
0915   08E5 A7 00         mov bh, 0
0916   08E7             ; START RELATIONAL
0917   08E7 D7            push a
0918   08E8 11            mov a, b
0919   08E9 26 78 00      mov b, $78
0920   08EC B0            cmp a, b
0921   08ED FD 71         seq ; ==
0922   08EF E4            pop a
0923   08F0             ; END RELATIONAL
0924   08F0 C0 00 00      cmp b, 0
0925   08F3 C6 15 09      je _if15_else
0926   08F6             _if15_true:
0927   08F6             ;; printx32(*(long int *)p); 
0928   08F6 FA FF FF      lea d, [bp + -1] ; $p
0929   08F9 2A            mov b, [d]
0930   08FA 74            mov d, b
0931   08FB 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0932   08FE FD 39         mov c, b ; And place it into C
0933   0900 2A            mov b, [d] ; Lower Word in B
0934   0901 FD 79         mov g, b
0935   0903 28            mov b, c
0936   0904 FD AB         swp b
0937   0906 D8            push b
0938   0907 FD 27         mov b, g
0939   0909 FD AB         swp b
0940   090B D8            push b
0941   090C 07 2F 0A      call printx32
0942   090F 51 04 00      add sp, 4
0943   0912 0A 1E 09      jmp _if15_exit
0944   0915             _if15_else:
0945   0915             ;; err("Unexpected format in printf."); 
0946   0915 26 82 14      mov b, __s0 ; "Unexpected format in printf."
0947   0918 FD AB         swp b
0948   091A D8            push b
0949   091B 07 1A 0A      call err
0950   091E             _if15_exit:
0951   091E             _if14_exit:
0952   091E             _if13_exit:
0953   091E             ;; p = p + 4; 
0954   091E FA FF FF      lea d, [bp + -1] ; $p
0955   0921 DA            push d
0956   0922 FA FF FF      lea d, [bp + -1] ; $p
0957   0925 2A            mov b, [d]
0958   0926             ; START TERMS
0959   0926 D7            push a
0960   0927 11            mov a, b
0961   0928 26 04 00      mov b, $4
0962   092B 54            add a, b
0963   092C 27            mov b, a
0964   092D E4            pop a
0965   092E             ; END TERMS
0966   092E E7            pop d
0967   092F FD 43         mov [d], b
0968   0931             ;; break; 
0969   0931 0A E9 09      jmp _switch12_exit ; case break
0970   0934             _switch12_case2:
0971   0934             _switch12_case3:
0972   0934             ;; print_signed(*(int*)p); 
0973   0934 FA FF FF      lea d, [bp + -1] ; $p
0974   0937 2A            mov b, [d]
0975   0938 74            mov d, b
0976   0939 2A            mov b, [d]
0977   093A FD AB         swp b
0978   093C D8            push b
0979   093D 07 D0 0B      call print_signed
0980   0940 51 02 00      add sp, 2
0981   0943             ;; p = p + 2; 
0982   0943 FA FF FF      lea d, [bp + -1] ; $p
0983   0946 DA            push d
0984   0947 FA FF FF      lea d, [bp + -1] ; $p
0985   094A 2A            mov b, [d]
0986   094B             ; START TERMS
0987   094B D7            push a
0988   094C 11            mov a, b
0989   094D 26 02 00      mov b, $2
0990   0950 54            add a, b
0991   0951 27            mov b, a
0992   0952 E4            pop a
0993   0953             ; END TERMS
0994   0953 E7            pop d
0995   0954 FD 43         mov [d], b
0996   0956             ;; break; 
0997   0956 0A E9 09      jmp _switch12_exit ; case break
0998   0959             _switch12_case4:
0999   0959             ;; print_unsigned(*(unsigned int*)p); 
1000   0959 FA FF FF      lea d, [bp + -1] ; $p
1001   095C 2A            mov b, [d]
1002   095D 74            mov d, b
1003   095E 2A            mov b, [d]
1004   095F FD AB         swp b
1005   0961 D8            push b
1006   0962 07 29 0F      call print_unsigned
1007   0965 51 02 00      add sp, 2
1008   0968             ;; p = p + 2; 
1009   0968 FA FF FF      lea d, [bp + -1] ; $p
1010   096B DA            push d
1011   096C FA FF FF      lea d, [bp + -1] ; $p
1012   096F 2A            mov b, [d]
1013   0970             ; START TERMS
1014   0970 D7            push a
1015   0971 11            mov a, b
1016   0972 26 02 00      mov b, $2
1017   0975 54            add a, b
1018   0976 27            mov b, a
1019   0977 E4            pop a
1020   0978             ; END TERMS
1021   0978 E7            pop d
1022   0979 FD 43         mov [d], b
1023   097B             ;; break; 
1024   097B 0A E9 09      jmp _switch12_exit ; case break
1025   097E             _switch12_case5:
1026   097E             
1027   097E             ; --- BEGIN INLINE ASM BLOCK
1028   097E FA FF FF      lea d, [bp + -1] ; $p
1029   0981 FD 2A         mov d, [d]
1030   0983 2A            mov b, [d]
1031   0984 07 7D 13      call print_u16x
1032   0987             ; --- END INLINE ASM BLOCK
1033   0987             
1034   0987             ;; p = p + 2; 
1035   0987 FA FF FF      lea d, [bp + -1] ; $p
1036   098A DA            push d
1037   098B FA FF FF      lea d, [bp + -1] ; $p
1038   098E 2A            mov b, [d]
1039   098F             ; START TERMS
1040   098F D7            push a
1041   0990 11            mov a, b
1042   0991 26 02 00      mov b, $2
1043   0994 54            add a, b
1044   0995 27            mov b, a
1045   0996 E4            pop a
1046   0997             ; END TERMS
1047   0997 E7            pop d
1048   0998 FD 43         mov [d], b
1049   099A             ;; break; 
1050   099A 0A E9 09      jmp _switch12_exit ; case break
1051   099D             _switch12_case6:
1052   099D             
1053   099D             ; --- BEGIN INLINE ASM BLOCK
1054   099D FA FF FF      lea d, [bp + -1] ; $p
1055   09A0 FD 2A         mov d, [d]
1056   09A2 1E            mov al, [d]
1057   09A3 23            mov ah, al
1058   09A4 07 DB 11      call _putchar
1059   09A7             ; --- END INLINE ASM BLOCK
1060   09A7             
1061   09A7             ;; p = p + 2; 
1062   09A7 FA FF FF      lea d, [bp + -1] ; $p
1063   09AA DA            push d
1064   09AB FA FF FF      lea d, [bp + -1] ; $p
1065   09AE 2A            mov b, [d]
1066   09AF             ; START TERMS
1067   09AF D7            push a
1068   09B0 11            mov a, b
1069   09B1 26 02 00      mov b, $2
1070   09B4 54            add a, b
1071   09B5 27            mov b, a
1072   09B6 E4            pop a
1073   09B7             ; END TERMS
1074   09B7 E7            pop d
1075   09B8 FD 43         mov [d], b
1076   09BA             ;; break; 
1077   09BA 0A E9 09      jmp _switch12_exit ; case break
1078   09BD             _switch12_case7:
1079   09BD             
1080   09BD             ; --- BEGIN INLINE ASM BLOCK
1081   09BD FA FF FF      lea d, [bp + -1] ; $p
1082   09C0 FD 2A         mov d, [d]
1083   09C2 FD 2A         mov d, [d]
1084   09C4 07 25 13      call _puts
1085   09C7             ; --- END INLINE ASM BLOCK
1086   09C7             
1087   09C7             ;; p = p + 2; 
1088   09C7 FA FF FF      lea d, [bp + -1] ; $p
1089   09CA DA            push d
1090   09CB FA FF FF      lea d, [bp + -1] ; $p
1091   09CE 2A            mov b, [d]
1092   09CF             ; START TERMS
1093   09CF D7            push a
1094   09D0 11            mov a, b
1095   09D1 26 02 00      mov b, $2
1096   09D4 54            add a, b
1097   09D5 27            mov b, a
1098   09D6 E4            pop a
1099   09D7             ; END TERMS
1100   09D7 E7            pop d
1101   09D8 FD 43         mov [d], b
1102   09DA             ;; break; 
1103   09DA 0A E9 09      jmp _switch12_exit ; case break
1104   09DD             _switch12_default:
1105   09DD             ;; print("Error: Unknown argument type.\n"); 
1106   09DD 26 9F 14      mov b, __s1 ; "Error: Unknown argument type.\n"
1107   09E0 FD AB         swp b
1108   09E2 D8            push b
1109   09E3 07 42 10      call print
1110   09E6 51 02 00      add sp, 2
1111   09E9             _switch12_exit:
1112   09E9             ;; fp++; 
1113   09E9 FA FD FF      lea d, [bp + -3] ; $fp
1114   09EC 2A            mov b, [d]
1115   09ED D8            push b
1116   09EE FD 77         inc b
1117   09F0 FA FD FF      lea d, [bp + -3] ; $fp
1118   09F3 FD 43         mov [d], b
1119   09F5 E5            pop b
1120   09F6 0A 15 0A      jmp _if11_exit
1121   09F9             _if11_else:
1122   09F9             ;; putchar(*fp); 
1123   09F9 FA FD FF      lea d, [bp + -3] ; $fp
1124   09FC 2A            mov b, [d]
1125   09FD 74            mov d, b
1126   09FE 32            mov bl, [d]
1127   09FF A7 00         mov bh, 0
1128   0A01 DD            push bl
1129   0A02 07 FA 0F      call putchar
1130   0A05 51 01 00      add sp, 1
1131   0A08             ;; fp++; 
1132   0A08 FA FD FF      lea d, [bp + -3] ; $fp
1133   0A0B 2A            mov b, [d]
1134   0A0C D8            push b
1135   0A0D FD 77         inc b
1136   0A0F FA FD FF      lea d, [bp + -3] ; $fp
1137   0A12 FD 43         mov [d], b
1138   0A14 E5            pop b
1139   0A15             _if11_exit:
1140   0A15             _if10_exit:
1141   0A15             _for9_update:
1142   0A15 0A F3 07      jmp _for9_cond
1143   0A18             _for9_exit:
1144   0A18 F9            leave
1145   0A19 09            ret
1146   0A1A             
1147   0A1A             err:
1148   0A1A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1149   0A1D             ;; print(e); 
1150   0A1D FA 05 00      lea d, [bp + 5] ; $e
1151   0A20 2A            mov b, [d]
1152   0A21 FD AB         swp b
1153   0A23 D8            push b
1154   0A24 07 42 10      call print
1155   0A27 51 02 00      add sp, 2
1156   0A2A             ;; exit(); 
1157   0A2A 07 E3 05      call exit
1158   0A2D F9            leave
1159   0A2E 09            ret
1160   0A2F             
1161   0A2F             printx32:
1162   0A2F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1163   0A32             
1164   0A32             ; --- BEGIN INLINE ASM BLOCK
1165   0A32 FA 05 00      lea d, [bp + 5] ; $hex
1166   0A35 2B 02 00      mov b, [d+2]
1167   0A38 07 7D 13      call print_u16x
1168   0A3B 2A            mov b, [d]
1169   0A3C 07 7D 13      call print_u16x
1170   0A3F             ; --- END INLINE ASM BLOCK
1171   0A3F             
1172   0A3F F9            leave
1173   0A40 09            ret
1174   0A41             
1175   0A41             printx16:
1176   0A41 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1177   0A44             
1178   0A44             ; --- BEGIN INLINE ASM BLOCK
1179   0A44 FA 05 00      lea d, [bp + 5] ; $hex
1180   0A47 2A            mov b, [d]
1181   0A48 07 7D 13      call print_u16x
1182   0A4B             ; --- END INLINE ASM BLOCK
1183   0A4B             
1184   0A4B F9            leave
1185   0A4C 09            ret
1186   0A4D             
1187   0A4D             printx8:
1188   0A4D F8 00 00      enter 0 ; (push bp; mov bp, sp)
1189   0A50             
1190   0A50             ; --- BEGIN INLINE ASM BLOCK
1191   0A50 FA 05 00      lea d, [bp + 5] ; $hex
1192   0A53 32            mov bl, [d]
1193   0A54 07 C1 13      call print_u8x
1194   0A57             ; --- END INLINE ASM BLOCK
1195   0A57             
1196   0A57 F9            leave
1197   0A58 09            ret
1198   0A59             
1199   0A59             hex_to_int:
1200   0A59 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1201   0A5C             ; $value 
1202   0A5C 10 00 00      mov a, $0
1203   0A5F 45 FF FF      mov [bp + -1], a
1204   0A62             ; $i 
1205   0A62             ; $hex_char 
1206   0A62             ; $len 
1207   0A62 52 07 00      sub sp, 7
1208   0A65             ;; len = strlen(hex_string); 
1209   0A65 FA FA FF      lea d, [bp + -6] ; $len
1210   0A68 DA            push d
1211   0A69 FA 05 00      lea d, [bp + 5] ; $hex_string
1212   0A6C 2A            mov b, [d]
1213   0A6D FD AB         swp b
1214   0A6F D8            push b
1215   0A70 07 9A 05      call strlen
1216   0A73 51 02 00      add sp, 2
1217   0A76 E7            pop d
1218   0A77 FD 43         mov [d], b
1219   0A79             ;; for (i = 0; i < len; i++) { 
1220   0A79             _for16_init:
1221   0A79 FA FD FF      lea d, [bp + -3] ; $i
1222   0A7C DA            push d
1223   0A7D 26 00 00      mov b, $0
1224   0A80 E7            pop d
1225   0A81 FD 43         mov [d], b
1226   0A83             _for16_cond:
1227   0A83 FA FD FF      lea d, [bp + -3] ; $i
1228   0A86 2A            mov b, [d]
1229   0A87             ; START RELATIONAL
1230   0A87 D7            push a
1231   0A88 11            mov a, b
1232   0A89 FA FA FF      lea d, [bp + -6] ; $len
1233   0A8C 2A            mov b, [d]
1234   0A8D 4D            mov si, a
1235   0A8E 11            mov a, b
1236   0A8F 4F            mov di, a
1237   0A90 FD 12         mov a, g
1238   0A92 28            mov b, c
1239   0A93 B0            cmp a, b
1240   0A94 FD 75         slu ; <
1241   0A96 D8            push b
1242   0A97 28            mov b, c
1243   0A98 FD 71         seq ; ==
1244   0A9A D8            push b
1245   0A9B 50            mov a, di
1246   0A9C 27            mov b, a
1247   0A9D 4E            mov a, si
1248   0A9E B0            cmp a, b
1249   0A9F FD 75         slu ; <
1250   0AA1 E4            pop a
1251   0AA2 FD 92         and b, a
1252   0AA4 E4            pop a
1253   0AA5 FD 70         or b, a
1254   0AA7               
1255   0AA7 E4            pop a
1256   0AA8             ; END RELATIONAL
1257   0AA8 C0 00 00      cmp b, 0
1258   0AAB C6 B0 0B      je _for16_exit
1259   0AAE             _for16_block:
1260   0AAE             ;; hex_char = hex_string[i]; 
1261   0AAE FA FC FF      lea d, [bp + -4] ; $hex_char
1262   0AB1 DA            push d
1263   0AB2 FA 05 00      lea d, [bp + 5] ; $hex_string
1264   0AB5 FD 2A         mov d, [d]
1265   0AB7 D7            push a
1266   0AB8 DA            push d
1267   0AB9 FA FD FF      lea d, [bp + -3] ; $i
1268   0ABC 2A            mov b, [d]
1269   0ABD E7            pop d
1270   0ABE FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
1271   0AC2 E4            pop a
1272   0AC3 32            mov bl, [d]
1273   0AC4 A7 00         mov bh, 0
1274   0AC6 E7            pop d
1275   0AC7 FD 3E         mov [d], bl
1276   0AC9             ;; if (hex_char >= 'a' && hex_char <= 'f')  
1277   0AC9             _if17_cond:
1278   0AC9 FA FC FF      lea d, [bp + -4] ; $hex_char
1279   0ACC 32            mov bl, [d]
1280   0ACD A7 00         mov bh, 0
1281   0ACF             ; START RELATIONAL
1282   0ACF D7            push a
1283   0AD0 11            mov a, b
1284   0AD1 26 61 00      mov b, $61
1285   0AD4 B0            cmp a, b
1286   0AD5 FD 80         sge ; >=
1287   0AD7 E4            pop a
1288   0AD8             ; END RELATIONAL
1289   0AD8 D7            push a
1290   0AD9 11            mov a, b
1291   0ADA FA FC FF      lea d, [bp + -4] ; $hex_char
1292   0ADD 32            mov bl, [d]
1293   0ADE A7 00         mov bh, 0
1294   0AE0             ; START RELATIONAL
1295   0AE0 D7            push a
1296   0AE1 11            mov a, b
1297   0AE2 26 66 00      mov b, $66
1298   0AE5 B0            cmp a, b
1299   0AE6 FD 74         sle ; <=
1300   0AE8 E4            pop a
1301   0AE9             ; END RELATIONAL
1302   0AE9 FD A7         sand a, b ; &&
1303   0AEB E4            pop a
1304   0AEC C0 00 00      cmp b, 0
1305   0AEF C6 21 0B      je _if17_else
1306   0AF2             _if17_true:
1307   0AF2             ;; value = (value * 16) + (hex_char - 'a' + 10); 
1308   0AF2 FA FF FF      lea d, [bp + -1] ; $value
1309   0AF5 DA            push d
1310   0AF6 FA FF FF      lea d, [bp + -1] ; $value
1311   0AF9 2A            mov b, [d]
1312   0AFA             ; START FACTORS
1313   0AFA D7            push a
1314   0AFB 11            mov a, b
1315   0AFC 26 10 00      mov b, $10
1316   0AFF AC            mul a, b ; *
1317   0B00 11            mov a, b
1318   0B01 27            mov b, a
1319   0B02 E4            pop a
1320   0B03             ; END FACTORS
1321   0B03             ; START TERMS
1322   0B03 D7            push a
1323   0B04 11            mov a, b
1324   0B05 FA FC FF      lea d, [bp + -4] ; $hex_char
1325   0B08 32            mov bl, [d]
1326   0B09 A7 00         mov bh, 0
1327   0B0B             ; START TERMS
1328   0B0B D7            push a
1329   0B0C 11            mov a, b
1330   0B0D 26 61 00      mov b, $61
1331   0B10 60            sub a, b
1332   0B11 11            mov a, b
1333   0B12 26 0A 00      mov b, $a
1334   0B15 54            add a, b
1335   0B16 27            mov b, a
1336   0B17 E4            pop a
1337   0B18             ; END TERMS
1338   0B18 54            add a, b
1339   0B19 27            mov b, a
1340   0B1A E4            pop a
1341   0B1B             ; END TERMS
1342   0B1B E7            pop d
1343   0B1C FD 43         mov [d], b
1344   0B1E 0A A0 0B      jmp _if17_exit
1345   0B21             _if17_else:
1346   0B21             ;; if (hex_char >= 'A' && hex_char <= 'F')  
1347   0B21             _if18_cond:
1348   0B21 FA FC FF      lea d, [bp + -4] ; $hex_char
1349   0B24 32            mov bl, [d]
1350   0B25 A7 00         mov bh, 0
1351   0B27             ; START RELATIONAL
1352   0B27 D7            push a
1353   0B28 11            mov a, b
1354   0B29 26 41 00      mov b, $41
1355   0B2C B0            cmp a, b
1356   0B2D FD 80         sge ; >=
1357   0B2F E4            pop a
1358   0B30             ; END RELATIONAL
1359   0B30 D7            push a
1360   0B31 11            mov a, b
1361   0B32 FA FC FF      lea d, [bp + -4] ; $hex_char
1362   0B35 32            mov bl, [d]
1363   0B36 A7 00         mov bh, 0
1364   0B38             ; START RELATIONAL
1365   0B38 D7            push a
1366   0B39 11            mov a, b
1367   0B3A 26 46 00      mov b, $46
1368   0B3D B0            cmp a, b
1369   0B3E FD 74         sle ; <=
1370   0B40 E4            pop a
1371   0B41             ; END RELATIONAL
1372   0B41 FD A7         sand a, b ; &&
1373   0B43 E4            pop a
1374   0B44 C0 00 00      cmp b, 0
1375   0B47 C6 79 0B      je _if18_else
1376   0B4A             _if18_true:
1377   0B4A             ;; value = (value * 16) + (hex_char - 'A' + 10); 
1378   0B4A FA FF FF      lea d, [bp + -1] ; $value
1379   0B4D DA            push d
1380   0B4E FA FF FF      lea d, [bp + -1] ; $value
1381   0B51 2A            mov b, [d]
1382   0B52             ; START FACTORS
1383   0B52 D7            push a
1384   0B53 11            mov a, b
1385   0B54 26 10 00      mov b, $10
1386   0B57 AC            mul a, b ; *
1387   0B58 11            mov a, b
1388   0B59 27            mov b, a
1389   0B5A E4            pop a
1390   0B5B             ; END FACTORS
1391   0B5B             ; START TERMS
1392   0B5B D7            push a
1393   0B5C 11            mov a, b
1394   0B5D FA FC FF      lea d, [bp + -4] ; $hex_char
1395   0B60 32            mov bl, [d]
1396   0B61 A7 00         mov bh, 0
1397   0B63             ; START TERMS
1398   0B63 D7            push a
1399   0B64 11            mov a, b
1400   0B65 26 41 00      mov b, $41
1401   0B68 60            sub a, b
1402   0B69 11            mov a, b
1403   0B6A 26 0A 00      mov b, $a
1404   0B6D 54            add a, b
1405   0B6E 27            mov b, a
1406   0B6F E4            pop a
1407   0B70             ; END TERMS
1408   0B70 54            add a, b
1409   0B71 27            mov b, a
1410   0B72 E4            pop a
1411   0B73             ; END TERMS
1412   0B73 E7            pop d
1413   0B74 FD 43         mov [d], b
1414   0B76 0A A0 0B      jmp _if18_exit
1415   0B79             _if18_else:
1416   0B79             ;; value = (value * 16) + (hex_char - '0'); 
1417   0B79 FA FF FF      lea d, [bp + -1] ; $value
1418   0B7C DA            push d
1419   0B7D FA FF FF      lea d, [bp + -1] ; $value
1420   0B80 2A            mov b, [d]
1421   0B81             ; START FACTORS
1422   0B81 D7            push a
1423   0B82 11            mov a, b
1424   0B83 26 10 00      mov b, $10
1425   0B86 AC            mul a, b ; *
1426   0B87 11            mov a, b
1427   0B88 27            mov b, a
1428   0B89 E4            pop a
1429   0B8A             ; END FACTORS
1430   0B8A             ; START TERMS
1431   0B8A D7            push a
1432   0B8B 11            mov a, b
1433   0B8C FA FC FF      lea d, [bp + -4] ; $hex_char
1434   0B8F 32            mov bl, [d]
1435   0B90 A7 00         mov bh, 0
1436   0B92             ; START TERMS
1437   0B92 D7            push a
1438   0B93 11            mov a, b
1439   0B94 26 30 00      mov b, $30
1440   0B97 60            sub a, b
1441   0B98 27            mov b, a
1442   0B99 E4            pop a
1443   0B9A             ; END TERMS
1444   0B9A 54            add a, b
1445   0B9B 27            mov b, a
1446   0B9C E4            pop a
1447   0B9D             ; END TERMS
1448   0B9D E7            pop d
1449   0B9E FD 43         mov [d], b
1450   0BA0             _if18_exit:
1451   0BA0             _if17_exit:
1452   0BA0             _for16_update:
1453   0BA0 FA FD FF      lea d, [bp + -3] ; $i
1454   0BA3 2A            mov b, [d]
1455   0BA4 D8            push b
1456   0BA5 FD 77         inc b
1457   0BA7 FA FD FF      lea d, [bp + -3] ; $i
1458   0BAA FD 43         mov [d], b
1459   0BAC E5            pop b
1460   0BAD 0A 83 0A      jmp _for16_cond
1461   0BB0             _for16_exit:
1462   0BB0             ;; return value; 
1463   0BB0 FA FF FF      lea d, [bp + -1] ; $value
1464   0BB3 2A            mov b, [d]
1465   0BB4 F9            leave
1466   0BB5 09            ret
1467   0BB6             
1468   0BB6             gets:
1469   0BB6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1470   0BB9             
1471   0BB9             ; --- BEGIN INLINE ASM BLOCK
1472   0BB9 FA 05 00      lea d, [bp + 5] ; $s
1473   0BBC 15            mov a, [d]
1474   0BBD 3C            mov d, a
1475   0BBE 07 E2 11      call _gets
1476   0BC1             ; --- END INLINE ASM BLOCK
1477   0BC1             
1478   0BC1             ;; return strlen(s); 
1479   0BC1 FA 05 00      lea d, [bp + 5] ; $s
1480   0BC4 2A            mov b, [d]
1481   0BC5 FD AB         swp b
1482   0BC7 D8            push b
1483   0BC8 07 9A 05      call strlen
1484   0BCB 51 02 00      add sp, 2
1485   0BCE F9            leave
1486   0BCF 09            ret
1487   0BD0             
1488   0BD0             print_signed:
1489   0BD0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1490   0BD3             ; $digits 
1491   0BD3             ; $i 
1492   0BD3 10 00 00      mov a, $0
1493   0BD6 45 FA FF      mov [bp + -6], a
1494   0BD9 52 07 00      sub sp, 7
1495   0BDC             ;; if (num < 0) { 
1496   0BDC             _if19_cond:
1497   0BDC FA 05 00      lea d, [bp + 5] ; $num
1498   0BDF 2A            mov b, [d]
1499   0BE0             ; START RELATIONAL
1500   0BE0 D7            push a
1501   0BE1 11            mov a, b
1502   0BE2 26 00 00      mov b, $0
1503   0BE5 4D            mov si, a
1504   0BE6 11            mov a, b
1505   0BE7 4F            mov di, a
1506   0BE8 FD 12         mov a, g
1507   0BEA 28            mov b, c
1508   0BEB B0            cmp a, b
1509   0BEC FD 75         slu ; <
1510   0BEE D8            push b
1511   0BEF 28            mov b, c
1512   0BF0 FD 71         seq ; ==
1513   0BF2 D8            push b
1514   0BF3 50            mov a, di
1515   0BF4 27            mov b, a
1516   0BF5 4E            mov a, si
1517   0BF6 B0            cmp a, b
1518   0BF7 FD 75         slu ; <
1519   0BF9 E4            pop a
1520   0BFA FD 92         and b, a
1521   0BFC E4            pop a
1522   0BFD FD 70         or b, a
1523   0BFF               
1524   0BFF E4            pop a
1525   0C00             ; END RELATIONAL
1526   0C00 C0 00 00      cmp b, 0
1527   0C03 C6 20 0C      je _if19_else
1528   0C06             _if19_true:
1529   0C06             ;; putchar('-'); 
1530   0C06 26 2D 00      mov b, $2d
1531   0C09 DD            push bl
1532   0C0A 07 FA 0F      call putchar
1533   0C0D 51 01 00      add sp, 1
1534   0C10             ;; num = -num; 
1535   0C10 FA 05 00      lea d, [bp + 5] ; $num
1536   0C13 DA            push d
1537   0C14 FA 05 00      lea d, [bp + 5] ; $num
1538   0C17 2A            mov b, [d]
1539   0C18 FD 97         neg b
1540   0C1A E7            pop d
1541   0C1B FD 43         mov [d], b
1542   0C1D 0A 42 0C      jmp _if19_exit
1543   0C20             _if19_else:
1544   0C20             ;; if (num == 0) { 
1545   0C20             _if20_cond:
1546   0C20 FA 05 00      lea d, [bp + 5] ; $num
1547   0C23 2A            mov b, [d]
1548   0C24             ; START RELATIONAL
1549   0C24 D7            push a
1550   0C25 11            mov a, b
1551   0C26 26 00 00      mov b, $0
1552   0C29 B0            cmp a, b
1553   0C2A FD 71         seq ; ==
1554   0C2C E4            pop a
1555   0C2D             ; END RELATIONAL
1556   0C2D C0 00 00      cmp b, 0
1557   0C30 C6 42 0C      je _if20_exit
1558   0C33             _if20_true:
1559   0C33             ;; putchar('0'); 
1560   0C33 26 30 00      mov b, $30
1561   0C36 DD            push bl
1562   0C37 07 FA 0F      call putchar
1563   0C3A 51 01 00      add sp, 1
1564   0C3D             ;; return; 
1565   0C3D F9            leave
1566   0C3E 09            ret
1567   0C3F 0A 42 0C      jmp _if20_exit
1568   0C42             _if20_exit:
1569   0C42             _if19_exit:
1570   0C42             ;; while (num > 0) { 
1571   0C42             _while21_cond:
1572   0C42 FA 05 00      lea d, [bp + 5] ; $num
1573   0C45 2A            mov b, [d]
1574   0C46             ; START RELATIONAL
1575   0C46 D7            push a
1576   0C47 11            mov a, b
1577   0C48 26 00 00      mov b, $0
1578   0C4B B0            cmp a, b
1579   0C4C FD 7F         sgt ; >
1580   0C4E E4            pop a
1581   0C4F             ; END RELATIONAL
1582   0C4F C0 00 00      cmp b, 0
1583   0C52 C6 9D 0C      je _while21_exit
1584   0C55             _while21_block:
1585   0C55             ;; digits[i] = '0' + (num % 10); 
1586   0C55 FA FC FF      lea d, [bp + -4] ; $digits
1587   0C58 D7            push a
1588   0C59 DA            push d
1589   0C5A FA FA FF      lea d, [bp + -6] ; $i
1590   0C5D 2A            mov b, [d]
1591   0C5E E7            pop d
1592   0C5F 5A            add d, b
1593   0C60 E4            pop a
1594   0C61 DA            push d
1595   0C62 26 30 00      mov b, $30
1596   0C65             ; START TERMS
1597   0C65 D7            push a
1598   0C66 11            mov a, b
1599   0C67 FA 05 00      lea d, [bp + 5] ; $num
1600   0C6A 2A            mov b, [d]
1601   0C6B             ; START FACTORS
1602   0C6B D7            push a
1603   0C6C 11            mov a, b
1604   0C6D 26 0A 00      mov b, $a
1605   0C70 AE            div a, b ; 
1606   0C71 11            mov a, b
1607   0C72 27            mov b, a
1608   0C73 E4            pop a
1609   0C74             ; END FACTORS
1610   0C74 54            add a, b
1611   0C75 27            mov b, a
1612   0C76 E4            pop a
1613   0C77             ; END TERMS
1614   0C77 E7            pop d
1615   0C78 FD 3E         mov [d], bl
1616   0C7A             ;; num = num / 10; 
1617   0C7A FA 05 00      lea d, [bp + 5] ; $num
1618   0C7D DA            push d
1619   0C7E FA 05 00      lea d, [bp + 5] ; $num
1620   0C81 2A            mov b, [d]
1621   0C82             ; START FACTORS
1622   0C82 D7            push a
1623   0C83 11            mov a, b
1624   0C84 26 0A 00      mov b, $a
1625   0C87 AE            div a, b
1626   0C88 27            mov b, a
1627   0C89 E4            pop a
1628   0C8A             ; END FACTORS
1629   0C8A E7            pop d
1630   0C8B FD 43         mov [d], b
1631   0C8D             ;; i++; 
1632   0C8D FA FA FF      lea d, [bp + -6] ; $i
1633   0C90 2A            mov b, [d]
1634   0C91 D8            push b
1635   0C92 FD 77         inc b
1636   0C94 FA FA FF      lea d, [bp + -6] ; $i
1637   0C97 FD 43         mov [d], b
1638   0C99 E5            pop b
1639   0C9A 0A 42 0C      jmp _while21_cond
1640   0C9D             _while21_exit:
1641   0C9D             ;; while (i > 0) { 
1642   0C9D             _while22_cond:
1643   0C9D FA FA FF      lea d, [bp + -6] ; $i
1644   0CA0 2A            mov b, [d]
1645   0CA1             ; START RELATIONAL
1646   0CA1 D7            push a
1647   0CA2 11            mov a, b
1648   0CA3 26 00 00      mov b, $0
1649   0CA6 B0            cmp a, b
1650   0CA7 FD 7F         sgt ; >
1651   0CA9 E4            pop a
1652   0CAA             ; END RELATIONAL
1653   0CAA C0 00 00      cmp b, 0
1654   0CAD C6 D6 0C      je _while22_exit
1655   0CB0             _while22_block:
1656   0CB0             ;; i--; 
1657   0CB0 FA FA FF      lea d, [bp + -6] ; $i
1658   0CB3 2A            mov b, [d]
1659   0CB4 D8            push b
1660   0CB5 FD 7D         dec b
1661   0CB7 FA FA FF      lea d, [bp + -6] ; $i
1662   0CBA FD 43         mov [d], b
1663   0CBC E5            pop b
1664   0CBD             ;; putchar(digits[i]); 
1665   0CBD FA FC FF      lea d, [bp + -4] ; $digits
1666   0CC0 D7            push a
1667   0CC1 DA            push d
1668   0CC2 FA FA FF      lea d, [bp + -6] ; $i
1669   0CC5 2A            mov b, [d]
1670   0CC6 E7            pop d
1671   0CC7 5A            add d, b
1672   0CC8 E4            pop a
1673   0CC9 32            mov bl, [d]
1674   0CCA A7 00         mov bh, 0
1675   0CCC DD            push bl
1676   0CCD 07 FA 0F      call putchar
1677   0CD0 51 01 00      add sp, 1
1678   0CD3 0A 9D 0C      jmp _while22_cond
1679   0CD6             _while22_exit:
1680   0CD6 F9            leave
1681   0CD7 09            ret
1682   0CD8             
1683   0CD8             print_signed_long:
1684   0CD8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1685   0CDB             ; $digits 
1686   0CDB             ; $i 
1687   0CDB 10 00 00      mov a, $0
1688   0CDE 45 F5 FF      mov [bp + -11], a
1689   0CE1 52 0C 00      sub sp, 12
1690   0CE4             ;; if (num < 0) { 
1691   0CE4             _if23_cond:
1692   0CE4 FA 05 00      lea d, [bp + 5] ; $num
1693   0CE7 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1694   0CEA FD 39         mov c, b ; And place it into C
1695   0CEC 2A            mov b, [d] ; Lower Word in B
1696   0CED             ; START RELATIONAL
1697   0CED D7            push a
1698   0CEE FD D8         push g
1699   0CF0 11            mov a, b
1700   0CF1 FD 7A         mov g, c
1701   0CF3 26 00 00      mov b, $0
1702   0CF6 4D            mov si, a
1703   0CF7 11            mov a, b
1704   0CF8 4F            mov di, a
1705   0CF9 FD 12         mov a, g
1706   0CFB 28            mov b, c
1707   0CFC B0            cmp a, b
1708   0CFD FD 75         slu ; <
1709   0CFF D8            push b
1710   0D00 28            mov b, c
1711   0D01 FD 71         seq ; ==
1712   0D03 D8            push b
1713   0D04 50            mov a, di
1714   0D05 27            mov b, a
1715   0D06 4E            mov a, si
1716   0D07 B0            cmp a, b
1717   0D08 FD 75         slu ; <
1718   0D0A E4            pop a
1719   0D0B FD 92         and b, a
1720   0D0D E4            pop a
1721   0D0E FD 70         or b, a
1722   0D10               
1723   0D10 FD F1         pop g
1724   0D12 E4            pop a
1725   0D13             ; END RELATIONAL
1726   0D13 C0 00 00      cmp b, 0
1727   0D16 C6 3D 0D      je _if23_else
1728   0D19             _if23_true:
1729   0D19             ;; putchar('-'); 
1730   0D19 26 2D 00      mov b, $2d
1731   0D1C DD            push bl
1732   0D1D 07 FA 0F      call putchar
1733   0D20 51 01 00      add sp, 1
1734   0D23             ;; num = -num; 
1735   0D23 FA 05 00      lea d, [bp + 5] ; $num
1736   0D26 DA            push d
1737   0D27 FA 05 00      lea d, [bp + 5] ; $num
1738   0D2A 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1739   0D2D FD 39         mov c, b ; And place it into C
1740   0D2F 2A            mov b, [d] ; Lower Word in B
1741   0D30 FD 97         neg b
1742   0D32 E7            pop d
1743   0D33 FD 43         mov [d], b
1744   0D35 28            mov b, c
1745   0D36 FD 44 02 00   mov [d + 2], b
1746   0D3A 0A 74 0D      jmp _if23_exit
1747   0D3D             _if23_else:
1748   0D3D             ;; if (num == 0) { 
1749   0D3D             _if24_cond:
1750   0D3D FA 05 00      lea d, [bp + 5] ; $num
1751   0D40 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1752   0D43 FD 39         mov c, b ; And place it into C
1753   0D45 2A            mov b, [d] ; Lower Word in B
1754   0D46             ; START RELATIONAL
1755   0D46 D7            push a
1756   0D47 FD D8         push g
1757   0D49 11            mov a, b
1758   0D4A FD 7A         mov g, c
1759   0D4C 26 00 00      mov b, $0
1760   0D4F B0            cmp a, b
1761   0D50 FD 71         seq ; ==
1762   0D52 D8            push b
1763   0D53 12            mov a, c
1764   0D54 FD 27         mov b, g
1765   0D56 B0            cmp a, b
1766   0D57 FD 71         seq ; ==
1767   0D59 E4            pop a
1768   0D5A FD A7         sand a, b
1769   0D5C FD F1         pop g
1770   0D5E E4            pop a
1771   0D5F             ; END RELATIONAL
1772   0D5F C0 00 00      cmp b, 0
1773   0D62 C6 74 0D      je _if24_exit
1774   0D65             _if24_true:
1775   0D65             ;; putchar('0'); 
1776   0D65 26 30 00      mov b, $30
1777   0D68 DD            push bl
1778   0D69 07 FA 0F      call putchar
1779   0D6C 51 01 00      add sp, 1
1780   0D6F             ;; return; 
1781   0D6F F9            leave
1782   0D70 09            ret
1783   0D71 0A 74 0D      jmp _if24_exit
1784   0D74             _if24_exit:
1785   0D74             _if23_exit:
1786   0D74             ;; while (num > 0) { 
1787   0D74             _while25_cond:
1788   0D74 FA 05 00      lea d, [bp + 5] ; $num
1789   0D77 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1790   0D7A FD 39         mov c, b ; And place it into C
1791   0D7C 2A            mov b, [d] ; Lower Word in B
1792   0D7D             ; START RELATIONAL
1793   0D7D D7            push a
1794   0D7E FD D8         push g
1795   0D80 11            mov a, b
1796   0D81 FD 7A         mov g, c
1797   0D83 26 00 00      mov b, $0
1798   0D86 B0            cmp a, b
1799   0D87 FD 7F         sgt ; >
1800   0D89 FD F1         pop g
1801   0D8B E4            pop a
1802   0D8C             ; END RELATIONAL
1803   0D8C C0 00 00      cmp b, 0
1804   0D8F C6 F0 0D      je _while25_exit
1805   0D92             _while25_block:
1806   0D92             ;; digits[i] = '0' + (num % 10); 
1807   0D92 FA F7 FF      lea d, [bp + -9] ; $digits
1808   0D95 D7            push a
1809   0D96 DA            push d
1810   0D97 FA F5 FF      lea d, [bp + -11] ; $i
1811   0D9A 2A            mov b, [d]
1812   0D9B E7            pop d
1813   0D9C 5A            add d, b
1814   0D9D E4            pop a
1815   0D9E DA            push d
1816   0D9F 26 30 00      mov b, $30
1817   0DA2             ; START TERMS
1818   0DA2 D7            push a
1819   0DA3 11            mov a, b
1820   0DA4 FA 05 00      lea d, [bp + 5] ; $num
1821   0DA7 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1822   0DAA FD 39         mov c, b ; And place it into C
1823   0DAC 2A            mov b, [d] ; Lower Word in B
1824   0DAD             ; START FACTORS
1825   0DAD D7            push a
1826   0DAE 11            mov a, b
1827   0DAF 26 0A 00      mov b, $a
1828   0DB2 AE            div a, b ; 
1829   0DB3 11            mov a, b
1830   0DB4 27            mov b, a
1831   0DB5 E4            pop a
1832   0DB6             ; END FACTORS
1833   0DB6 54            add a, b
1834   0DB7 D7            push a
1835   0DB8 FD 12         mov a, g
1836   0DBA 28            mov b, c
1837   0DBB 5C            adc a, b
1838   0DBC 39            mov c, a
1839   0DBD E5            pop b
1840   0DBE 27            mov b, a
1841   0DBF E4            pop a
1842   0DC0             ; END TERMS
1843   0DC0 E7            pop d
1844   0DC1 FD 3E         mov [d], bl
1845   0DC3             ;; num = num / 10; 
1846   0DC3 FA 05 00      lea d, [bp + 5] ; $num
1847   0DC6 DA            push d
1848   0DC7 FA 05 00      lea d, [bp + 5] ; $num
1849   0DCA 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1850   0DCD FD 39         mov c, b ; And place it into C
1851   0DCF 2A            mov b, [d] ; Lower Word in B
1852   0DD0             ; START FACTORS
1853   0DD0 D7            push a
1854   0DD1 11            mov a, b
1855   0DD2 26 0A 00      mov b, $a
1856   0DD5 AE            div a, b
1857   0DD6 27            mov b, a
1858   0DD7 E4            pop a
1859   0DD8             ; END FACTORS
1860   0DD8 E7            pop d
1861   0DD9 FD 43         mov [d], b
1862   0DDB 28            mov b, c
1863   0DDC FD 44 02 00   mov [d + 2], b
1864   0DE0             ;; i++; 
1865   0DE0 FA F5 FF      lea d, [bp + -11] ; $i
1866   0DE3 2A            mov b, [d]
1867   0DE4 D8            push b
1868   0DE5 FD 77         inc b
1869   0DE7 FA F5 FF      lea d, [bp + -11] ; $i
1870   0DEA FD 43         mov [d], b
1871   0DEC E5            pop b
1872   0DED 0A 74 0D      jmp _while25_cond
1873   0DF0             _while25_exit:
1874   0DF0             ;; while (i > 0) { 
1875   0DF0             _while26_cond:
1876   0DF0 FA F5 FF      lea d, [bp + -11] ; $i
1877   0DF3 2A            mov b, [d]
1878   0DF4             ; START RELATIONAL
1879   0DF4 D7            push a
1880   0DF5 11            mov a, b
1881   0DF6 26 00 00      mov b, $0
1882   0DF9 B0            cmp a, b
1883   0DFA FD 7F         sgt ; >
1884   0DFC E4            pop a
1885   0DFD             ; END RELATIONAL
1886   0DFD C0 00 00      cmp b, 0
1887   0E00 C6 29 0E      je _while26_exit
1888   0E03             _while26_block:
1889   0E03             ;; i--; 
1890   0E03 FA F5 FF      lea d, [bp + -11] ; $i
1891   0E06 2A            mov b, [d]
1892   0E07 D8            push b
1893   0E08 FD 7D         dec b
1894   0E0A FA F5 FF      lea d, [bp + -11] ; $i
1895   0E0D FD 43         mov [d], b
1896   0E0F E5            pop b
1897   0E10             ;; putchar(digits[i]); 
1898   0E10 FA F7 FF      lea d, [bp + -9] ; $digits
1899   0E13 D7            push a
1900   0E14 DA            push d
1901   0E15 FA F5 FF      lea d, [bp + -11] ; $i
1902   0E18 2A            mov b, [d]
1903   0E19 E7            pop d
1904   0E1A 5A            add d, b
1905   0E1B E4            pop a
1906   0E1C 32            mov bl, [d]
1907   0E1D A7 00         mov bh, 0
1908   0E1F DD            push bl
1909   0E20 07 FA 0F      call putchar
1910   0E23 51 01 00      add sp, 1
1911   0E26 0A F0 0D      jmp _while26_cond
1912   0E29             _while26_exit:
1913   0E29 F9            leave
1914   0E2A 09            ret
1915   0E2B             
1916   0E2B             print_unsigned_long:
1917   0E2B F8 00 00      enter 0 ; (push bp; mov bp, sp)
1918   0E2E             ; $digits 
1919   0E2E             ; $i 
1920   0E2E 52 0C 00      sub sp, 12
1921   0E31             ;; i = 0; 
1922   0E31 FA F5 FF      lea d, [bp + -11] ; $i
1923   0E34 DA            push d
1924   0E35 26 00 00      mov b, $0
1925   0E38 E7            pop d
1926   0E39 FD 43         mov [d], b
1927   0E3B             ;; if(num == 0){ 
1928   0E3B             _if27_cond:
1929   0E3B FA 05 00      lea d, [bp + 5] ; $num
1930   0E3E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1931   0E41 FD 39         mov c, b ; And place it into C
1932   0E43 2A            mov b, [d] ; Lower Word in B
1933   0E44             ; START RELATIONAL
1934   0E44 D7            push a
1935   0E45 FD D8         push g
1936   0E47 11            mov a, b
1937   0E48 FD 7A         mov g, c
1938   0E4A 26 00 00      mov b, $0
1939   0E4D B0            cmp a, b
1940   0E4E FD 71         seq ; ==
1941   0E50 D8            push b
1942   0E51 12            mov a, c
1943   0E52 FD 27         mov b, g
1944   0E54 B0            cmp a, b
1945   0E55 FD 71         seq ; ==
1946   0E57 E4            pop a
1947   0E58 FD A7         sand a, b
1948   0E5A FD F1         pop g
1949   0E5C E4            pop a
1950   0E5D             ; END RELATIONAL
1951   0E5D C0 00 00      cmp b, 0
1952   0E60 C6 72 0E      je _if27_exit
1953   0E63             _if27_true:
1954   0E63             ;; putchar('0'); 
1955   0E63 26 30 00      mov b, $30
1956   0E66 DD            push bl
1957   0E67 07 FA 0F      call putchar
1958   0E6A 51 01 00      add sp, 1
1959   0E6D             ;; return; 
1960   0E6D F9            leave
1961   0E6E 09            ret
1962   0E6F 0A 72 0E      jmp _if27_exit
1963   0E72             _if27_exit:
1964   0E72             ;; while (num > 0) { 
1965   0E72             _while28_cond:
1966   0E72 FA 05 00      lea d, [bp + 5] ; $num
1967   0E75 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1968   0E78 FD 39         mov c, b ; And place it into C
1969   0E7A 2A            mov b, [d] ; Lower Word in B
1970   0E7B             ; START RELATIONAL
1971   0E7B D7            push a
1972   0E7C FD D8         push g
1973   0E7E 11            mov a, b
1974   0E7F FD 7A         mov g, c
1975   0E81 26 00 00      mov b, $0
1976   0E84 B0            cmp a, b
1977   0E85 FD 81         sgu ; > (unsigned)
1978   0E87 FD F1         pop g
1979   0E89 E4            pop a
1980   0E8A             ; END RELATIONAL
1981   0E8A C0 00 00      cmp b, 0
1982   0E8D C6 EE 0E      je _while28_exit
1983   0E90             _while28_block:
1984   0E90             ;; digits[i] = '0' + (num % 10); 
1985   0E90 FA F7 FF      lea d, [bp + -9] ; $digits
1986   0E93 D7            push a
1987   0E94 DA            push d
1988   0E95 FA F5 FF      lea d, [bp + -11] ; $i
1989   0E98 2A            mov b, [d]
1990   0E99 E7            pop d
1991   0E9A 5A            add d, b
1992   0E9B E4            pop a
1993   0E9C DA            push d
1994   0E9D 26 30 00      mov b, $30
1995   0EA0             ; START TERMS
1996   0EA0 D7            push a
1997   0EA1 11            mov a, b
1998   0EA2 FA 05 00      lea d, [bp + 5] ; $num
1999   0EA5 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2000   0EA8 FD 39         mov c, b ; And place it into C
2001   0EAA 2A            mov b, [d] ; Lower Word in B
2002   0EAB             ; START FACTORS
2003   0EAB D7            push a
2004   0EAC 11            mov a, b
2005   0EAD 26 0A 00      mov b, $a
2006   0EB0 AE            div a, b ; 
2007   0EB1 11            mov a, b
2008   0EB2 27            mov b, a
2009   0EB3 E4            pop a
2010   0EB4             ; END FACTORS
2011   0EB4 54            add a, b
2012   0EB5 D7            push a
2013   0EB6 FD 12         mov a, g
2014   0EB8 28            mov b, c
2015   0EB9 5C            adc a, b
2016   0EBA 39            mov c, a
2017   0EBB E5            pop b
2018   0EBC 27            mov b, a
2019   0EBD E4            pop a
2020   0EBE             ; END TERMS
2021   0EBE E7            pop d
2022   0EBF FD 3E         mov [d], bl
2023   0EC1             ;; num = num / 10; 
2024   0EC1 FA 05 00      lea d, [bp + 5] ; $num
2025   0EC4 DA            push d
2026   0EC5 FA 05 00      lea d, [bp + 5] ; $num
2027   0EC8 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2028   0ECB FD 39         mov c, b ; And place it into C
2029   0ECD 2A            mov b, [d] ; Lower Word in B
2030   0ECE             ; START FACTORS
2031   0ECE D7            push a
2032   0ECF 11            mov a, b
2033   0ED0 26 0A 00      mov b, $a
2034   0ED3 AE            div a, b
2035   0ED4 27            mov b, a
2036   0ED5 E4            pop a
2037   0ED6             ; END FACTORS
2038   0ED6 E7            pop d
2039   0ED7 FD 43         mov [d], b
2040   0ED9 28            mov b, c
2041   0EDA FD 44 02 00   mov [d + 2], b
2042   0EDE             ;; i++; 
2043   0EDE FA F5 FF      lea d, [bp + -11] ; $i
2044   0EE1 2A            mov b, [d]
2045   0EE2 D8            push b
2046   0EE3 FD 77         inc b
2047   0EE5 FA F5 FF      lea d, [bp + -11] ; $i
2048   0EE8 FD 43         mov [d], b
2049   0EEA E5            pop b
2050   0EEB 0A 72 0E      jmp _while28_cond
2051   0EEE             _while28_exit:
2052   0EEE             ;; while (i > 0) { 
2053   0EEE             _while29_cond:
2054   0EEE FA F5 FF      lea d, [bp + -11] ; $i
2055   0EF1 2A            mov b, [d]
2056   0EF2             ; START RELATIONAL
2057   0EF2 D7            push a
2058   0EF3 11            mov a, b
2059   0EF4 26 00 00      mov b, $0
2060   0EF7 B0            cmp a, b
2061   0EF8 FD 7F         sgt ; >
2062   0EFA E4            pop a
2063   0EFB             ; END RELATIONAL
2064   0EFB C0 00 00      cmp b, 0
2065   0EFE C6 27 0F      je _while29_exit
2066   0F01             _while29_block:
2067   0F01             ;; i--; 
2068   0F01 FA F5 FF      lea d, [bp + -11] ; $i
2069   0F04 2A            mov b, [d]
2070   0F05 D8            push b
2071   0F06 FD 7D         dec b
2072   0F08 FA F5 FF      lea d, [bp + -11] ; $i
2073   0F0B FD 43         mov [d], b
2074   0F0D E5            pop b
2075   0F0E             ;; putchar(digits[i]); 
2076   0F0E FA F7 FF      lea d, [bp + -9] ; $digits
2077   0F11 D7            push a
2078   0F12 DA            push d
2079   0F13 FA F5 FF      lea d, [bp + -11] ; $i
2080   0F16 2A            mov b, [d]
2081   0F17 E7            pop d
2082   0F18 5A            add d, b
2083   0F19 E4            pop a
2084   0F1A 32            mov bl, [d]
2085   0F1B A7 00         mov bh, 0
2086   0F1D DD            push bl
2087   0F1E 07 FA 0F      call putchar
2088   0F21 51 01 00      add sp, 1
2089   0F24 0A EE 0E      jmp _while29_cond
2090   0F27             _while29_exit:
2091   0F27 F9            leave
2092   0F28 09            ret
2093   0F29             
2094   0F29             print_unsigned:
2095   0F29 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2096   0F2C             ; $digits 
2097   0F2C             ; $i 
2098   0F2C 52 07 00      sub sp, 7
2099   0F2F             ;; i = 0; 
2100   0F2F FA FA FF      lea d, [bp + -6] ; $i
2101   0F32 DA            push d
2102   0F33 26 00 00      mov b, $0
2103   0F36 E7            pop d
2104   0F37 FD 43         mov [d], b
2105   0F39             ;; if(num == 0){ 
2106   0F39             _if30_cond:
2107   0F39 FA 05 00      lea d, [bp + 5] ; $num
2108   0F3C 2A            mov b, [d]
2109   0F3D             ; START RELATIONAL
2110   0F3D D7            push a
2111   0F3E 11            mov a, b
2112   0F3F 26 00 00      mov b, $0
2113   0F42 B0            cmp a, b
2114   0F43 FD 71         seq ; ==
2115   0F45 E4            pop a
2116   0F46             ; END RELATIONAL
2117   0F46 C0 00 00      cmp b, 0
2118   0F49 C6 5B 0F      je _if30_exit
2119   0F4C             _if30_true:
2120   0F4C             ;; putchar('0'); 
2121   0F4C 26 30 00      mov b, $30
2122   0F4F DD            push bl
2123   0F50 07 FA 0F      call putchar
2124   0F53 51 01 00      add sp, 1
2125   0F56             ;; return; 
2126   0F56 F9            leave
2127   0F57 09            ret
2128   0F58 0A 5B 0F      jmp _if30_exit
2129   0F5B             _if30_exit:
2130   0F5B             ;; while (num > 0) { 
2131   0F5B             _while31_cond:
2132   0F5B FA 05 00      lea d, [bp + 5] ; $num
2133   0F5E 2A            mov b, [d]
2134   0F5F             ; START RELATIONAL
2135   0F5F D7            push a
2136   0F60 11            mov a, b
2137   0F61 26 00 00      mov b, $0
2138   0F64 B0            cmp a, b
2139   0F65 FD 81         sgu ; > (unsigned)
2140   0F67 E4            pop a
2141   0F68             ; END RELATIONAL
2142   0F68 C0 00 00      cmp b, 0
2143   0F6B C6 B6 0F      je _while31_exit
2144   0F6E             _while31_block:
2145   0F6E             ;; digits[i] = '0' + (num % 10); 
2146   0F6E FA FC FF      lea d, [bp + -4] ; $digits
2147   0F71 D7            push a
2148   0F72 DA            push d
2149   0F73 FA FA FF      lea d, [bp + -6] ; $i
2150   0F76 2A            mov b, [d]
2151   0F77 E7            pop d
2152   0F78 5A            add d, b
2153   0F79 E4            pop a
2154   0F7A DA            push d
2155   0F7B 26 30 00      mov b, $30
2156   0F7E             ; START TERMS
2157   0F7E D7            push a
2158   0F7F 11            mov a, b
2159   0F80 FA 05 00      lea d, [bp + 5] ; $num
2160   0F83 2A            mov b, [d]
2161   0F84             ; START FACTORS
2162   0F84 D7            push a
2163   0F85 11            mov a, b
2164   0F86 26 0A 00      mov b, $a
2165   0F89 AE            div a, b ; 
2166   0F8A 11            mov a, b
2167   0F8B 27            mov b, a
2168   0F8C E4            pop a
2169   0F8D             ; END FACTORS
2170   0F8D 54            add a, b
2171   0F8E 27            mov b, a
2172   0F8F E4            pop a
2173   0F90             ; END TERMS
2174   0F90 E7            pop d
2175   0F91 FD 3E         mov [d], bl
2176   0F93             ;; num = num / 10; 
2177   0F93 FA 05 00      lea d, [bp + 5] ; $num
2178   0F96 DA            push d
2179   0F97 FA 05 00      lea d, [bp + 5] ; $num
2180   0F9A 2A            mov b, [d]
2181   0F9B             ; START FACTORS
2182   0F9B D7            push a
2183   0F9C 11            mov a, b
2184   0F9D 26 0A 00      mov b, $a
2185   0FA0 AE            div a, b
2186   0FA1 27            mov b, a
2187   0FA2 E4            pop a
2188   0FA3             ; END FACTORS
2189   0FA3 E7            pop d
2190   0FA4 FD 43         mov [d], b
2191   0FA6             ;; i++; 
2192   0FA6 FA FA FF      lea d, [bp + -6] ; $i
2193   0FA9 2A            mov b, [d]
2194   0FAA D8            push b
2195   0FAB FD 77         inc b
2196   0FAD FA FA FF      lea d, [bp + -6] ; $i
2197   0FB0 FD 43         mov [d], b
2198   0FB2 E5            pop b
2199   0FB3 0A 5B 0F      jmp _while31_cond
2200   0FB6             _while31_exit:
2201   0FB6             ;; while (i > 0) { 
2202   0FB6             _while32_cond:
2203   0FB6 FA FA FF      lea d, [bp + -6] ; $i
2204   0FB9 2A            mov b, [d]
2205   0FBA             ; START RELATIONAL
2206   0FBA D7            push a
2207   0FBB 11            mov a, b
2208   0FBC 26 00 00      mov b, $0
2209   0FBF B0            cmp a, b
2210   0FC0 FD 7F         sgt ; >
2211   0FC2 E4            pop a
2212   0FC3             ; END RELATIONAL
2213   0FC3 C0 00 00      cmp b, 0
2214   0FC6 C6 EF 0F      je _while32_exit
2215   0FC9             _while32_block:
2216   0FC9             ;; i--; 
2217   0FC9 FA FA FF      lea d, [bp + -6] ; $i
2218   0FCC 2A            mov b, [d]
2219   0FCD D8            push b
2220   0FCE FD 7D         dec b
2221   0FD0 FA FA FF      lea d, [bp + -6] ; $i
2222   0FD3 FD 43         mov [d], b
2223   0FD5 E5            pop b
2224   0FD6             ;; putchar(digits[i]); 
2225   0FD6 FA FC FF      lea d, [bp + -4] ; $digits
2226   0FD9 D7            push a
2227   0FDA DA            push d
2228   0FDB FA FA FF      lea d, [bp + -6] ; $i
2229   0FDE 2A            mov b, [d]
2230   0FDF E7            pop d
2231   0FE0 5A            add d, b
2232   0FE1 E4            pop a
2233   0FE2 32            mov bl, [d]
2234   0FE3 A7 00         mov bh, 0
2235   0FE5 DD            push bl
2236   0FE6 07 FA 0F      call putchar
2237   0FE9 51 01 00      add sp, 1
2238   0FEC 0A B6 0F      jmp _while32_cond
2239   0FEF             _while32_exit:
2240   0FEF F9            leave
2241   0FF0 09            ret
2242   0FF1             
2243   0FF1             date:
2244   0FF1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2245   0FF4             
2246   0FF4             ; --- BEGIN INLINE ASM BLOCK
2247   0FF4 19 00         mov al, 0 
2248   0FF6 05 07         syscall sys_datetime
2249   0FF8             ; --- END INLINE ASM BLOCK
2250   0FF8             
2251   0FF8 F9            leave
2252   0FF9 09            ret
2253   0FFA             
2254   0FFA             putchar:
2255   0FFA F8 00 00      enter 0 ; (push bp; mov bp, sp)
2256   0FFD             
2257   0FFD             ; --- BEGIN INLINE ASM BLOCK
2258   0FFD FA 05 00      lea d, [bp + 5] ; $c
2259   1000 1E            mov al, [d]
2260   1001 23            mov ah, al
2261   1002 07 DB 11      call _putchar
2262   1005             ; --- END INLINE ASM BLOCK
2263   1005             
2264   1005 F9            leave
2265   1006 09            ret
2266   1007             
2267   1007             getchar:
2268   1007 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2269   100A             ; $c 
2270   100A 52 01 00      sub sp, 1
2271   100D             
2272   100D             ; --- BEGIN INLINE ASM BLOCK
2273   100D 07 D4 11      call getch
2274   1010 1A            mov al, ah
2275   1011 FA 00 00      lea d, [bp + 0] ; $c
2276   1014 3E            mov [d], al
2277   1015             ; --- END INLINE ASM BLOCK
2278   1015             
2279   1015             ;; return c; 
2280   1015 FA 00 00      lea d, [bp + 0] ; $c
2281   1018 32            mov bl, [d]
2282   1019 A7 00         mov bh, 0
2283   101B F9            leave
2284   101C 09            ret
2285   101D             
2286   101D             scann:
2287   101D F8 00 00      enter 0 ; (push bp; mov bp, sp)
2288   1020             ; $m 
2289   1020 52 02 00      sub sp, 2
2290   1023             
2291   1023             ; --- BEGIN INLINE ASM BLOCK
2292   1023 07 1F 14      call scan_u16d
2293   1026 FA FF FF      lea d, [bp + -1] ; $m
2294   1029 43            mov [d], a
2295   102A             ; --- END INLINE ASM BLOCK
2296   102A             
2297   102A             ;; return m; 
2298   102A FA FF FF      lea d, [bp + -1] ; $m
2299   102D 2A            mov b, [d]
2300   102E F9            leave
2301   102F 09            ret
2302   1030             
2303   1030             puts:
2304   1030 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2305   1033             
2306   1033             ; --- BEGIN INLINE ASM BLOCK
2307   1033 FA 05 00      lea d, [bp + 5] ; $s
2308   1036 15            mov a, [d]
2309   1037 3C            mov d, a
2310   1038 07 25 13      call _puts
2311   103B 10 00 0A      mov a, $0A00
2312   103E 05 03         syscall sys_io
2313   1040             ; --- END INLINE ASM BLOCK
2314   1040             
2315   1040 F9            leave
2316   1041 09            ret
2317   1042             
2318   1042             print:
2319   1042 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2320   1045             
2321   1045             ; --- BEGIN INLINE ASM BLOCK
2322   1045 FA 05 00      lea d, [bp + 5] ; $s
2323   1048 FD 2A         mov d, [d]
2324   104A 07 25 13      call _puts
2325   104D             ; --- END INLINE ASM BLOCK
2326   104D             
2327   104D F9            leave
2328   104E 09            ret
2329   104F             
2330   104F             loadfile:
2331   104F F8 00 00      enter 0 ; (push bp; mov bp, sp)
2332   1052             
2333   1052             ; --- BEGIN INLINE ASM BLOCK
2334   1052 FA 07 00      lea d, [bp + 7] ; $destination
2335   1055 15            mov a, [d]
2336   1056 4F            mov di, a
2337   1057 FA 05 00      lea d, [bp + 5] ; $filename
2338   105A FD 2A         mov d, [d]
2339   105C 19 14         mov al, 20
2340   105E 05 04         syscall sys_filesystem
2341   1060             ; --- END INLINE ASM BLOCK
2342   1060             
2343   1060 F9            leave
2344   1061 09            ret
2345   1062             
2346   1062             create_file:
2347   1062 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2348   1065 F9            leave
2349   1066 09            ret
2350   1067             
2351   1067             delete_file:
2352   1067 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2353   106A             
2354   106A             ; --- BEGIN INLINE ASM BLOCK
2355   106A FA 05 00      lea d, [bp + 5] ; $filename
2356   106D 19 0A         mov al, 10
2357   106F 05 04         syscall sys_filesystem
2358   1071             ; --- END INLINE ASM BLOCK
2359   1071             
2360   1071 F9            leave
2361   1072 09            ret
2362   1073             
2363   1073             fopen:
2364   1073 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2365   1076 F9            leave
2366   1077 09            ret
2367   1078             
2368   1078             fclose:
2369   1078 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2370   107B F9            leave
2371   107C 09            ret
2372   107D             
2373   107D             load_hex:
2374   107D F8 00 00      enter 0 ; (push bp; mov bp, sp)
2375   1080             ; $temp 
2376   1080 52 02 00      sub sp, 2
2377   1083             ;; temp = alloc(32768); 
2378   1083 FA FF FF      lea d, [bp + -1] ; $temp
2379   1086 DA            push d
2380   1087 26 00 80      mov b, $8000
2381   108A FD AB         swp b
2382   108C D8            push b
2383   108D 07 25 07      call alloc
2384   1090 51 02 00      add sp, 2
2385   1093 E7            pop d
2386   1094 FD 43         mov [d], b
2387   1096             
2388   1096             ; --- BEGIN INLINE ASM BLOCK
2389   1096               
2390   1096               
2391   1096               
2392   1096               
2393   1096               
2394   1096             _load_hex:
2395   1096 D7            push a
2396   1097 D8            push b
2397   1098 DA            push d
2398   1099 E2            push si
2399   109A E3            push di
2400   109B 52 00 80      sub sp, $8000      
2401   109E 38 00 00      mov c, 0
2402   10A1 48            mov a, sp
2403   10A2 77            inc a
2404   10A3 3C            mov d, a          
2405   10A4 07 E2 11      call _gets        
2406   10A7 4D            mov si, a
2407   10A8             __load_hex_loop:
2408   10A8 F6            lodsb             
2409   10A9 B9 00         cmp al, 0         
2410   10AB C6 B9 10      jz __load_hex_ret
2411   10AE 36            mov bh, al
2412   10AF F6            lodsb
2413   10B0 2F            mov bl, al
2414   10B1 07 98 11      call _atoi        
2415   10B4 F7            stosb             
2416   10B5 78            inc c
2417   10B6 0A A8 10      jmp __load_hex_loop
2418   10B9             __load_hex_ret:
2419   10B9 51 00 80      add sp, $8000
2420   10BC F0            pop di
2421   10BD EF            pop si
2422   10BE E7            pop d
2423   10BF E5            pop b
2424   10C0 E4            pop a
2425   10C1             ; --- END INLINE ASM BLOCK
2426   10C1             
2427   10C1 F9            leave
2428   10C2 09            ret
2429   10C3             
2430   10C3             getparam:
2431   10C3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2432   10C6             ; $data 
2433   10C6 52 01 00      sub sp, 1
2434   10C9             
2435   10C9             ; --- BEGIN INLINE ASM BLOCK
2436   10C9 19 04         mov al, 4
2437   10CB FA 05 00      lea d, [bp + 5] ; $address
2438   10CE FD 2A         mov d, [d]
2439   10D0 05 0C         syscall sys_system
2440   10D2 FA 00 00      lea d, [bp + 0] ; $data
2441   10D5 FD 3E         mov [d], bl
2442   10D7             ; --- END INLINE ASM BLOCK
2443   10D7             
2444   10D7             ;; return data; 
2445   10D7 FA 00 00      lea d, [bp + 0] ; $data
2446   10DA 32            mov bl, [d]
2447   10DB A7 00         mov bh, 0
2448   10DD F9            leave
2449   10DE 09            ret
2450   10DF             
2451   10DF             clear:
2452   10DF F8 00 00      enter 0 ; (push bp; mov bp, sp)
2453   10E2             ;; print("\033[2J\033[H"); 
2454   10E2 26 BE 14      mov b, __s2 ; "\033[2J\033[H"
2455   10E5 FD AB         swp b
2456   10E7 D8            push b
2457   10E8 07 42 10      call print
2458   10EB 51 02 00      add sp, 2
2459   10EE F9            leave
2460   10EF 09            ret
2461   10F0             
2462   10F0             include_stdio_asm:
2463   10F0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2464   10F3             
2465   10F3             ; --- BEGIN INLINE ASM BLOCK
2466   10F3             .include "lib/asm/stdio.asm"
0001+  10F3             ;-----------------------------------------------------------------------------
0002+  10F3             ; stdio.s
0003+  10F3             ;-----------------------------------------------------------------------------
0004+  10F3             .include "lib/asm/string.asm"
0001++ 10F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 10F3             ; string.s
0003++ 10F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 10F3             
0005++ 10F3             
0006++ 10F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 10F3             ; _strrev
0008++ 10F3             ; reverse a string
0009++ 10F3             ; D = string address
0010++ 10F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 10F3             ; 01234
0012++ 10F3             _strrev:
0013++ 10F3 4B          	pusha
0014++ 10F4 07 3A 11    	call _strlen	; length in C
0015++ 10F7 12          	mov a, c
0016++ 10F8 AF 01 00    	cmp a, 1
0017++ 10FB D0 15 11    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 10FE 7D          	dec a
0019++ 10FF FD 4E       	mov si, d	; beginning of string
0020++ 1101 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 1103 59          	add d, a	; end of string
0022++ 1104 12          	mov a, c
0023++ 1105 FD 9B       	shr a		; divide by 2
0024++ 1107 39          	mov c, a	; C now counts the steps
0025++ 1108             _strrev_L0:
0026++ 1108 32          	mov bl, [d]	; save load right-side char into BL
0027++ 1109 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 110A 3E          	mov [d], al	; store left char into right side
0029++ 110B 1B          	mov al, bl
0030++ 110C F7          	stosb		; store right-side char into left-side; increase DI
0031++ 110D 7E          	dec c
0032++ 110E 7F          	dec d
0033++ 110F C2 00 00    	cmp c, 0
0034++ 1112 C7 08 11    	jne _strrev_L0
0035++ 1115             _strrev_end:
0036++ 1115 4C          	popa
0037++ 1116 09          	ret
0038++ 1117             	
0039++ 1117             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 1117             ; _strchr
0041++ 1117             ; search string in D for char in AL
0042++ 1117             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 1117             _strchr:
0044++ 1117             _strchr_L0:
0045++ 1117 32          	mov bl, [d]
0046++ 1118 C1 00       	cmp bl, 0
0047++ 111A C6 25 11    	je _strchr_end
0048++ 111D BA          	cmp al, bl
0049++ 111E C6 25 11    	je _strchr_end
0050++ 1121 79          	inc d
0051++ 1122 0A 17 11    	jmp _strchr_L0
0052++ 1125             _strchr_end:
0053++ 1125 1B          	mov al, bl
0054++ 1126 09          	ret
0055++ 1127             
0056++ 1127             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 1127             ; _strstr
0058++ 1127             ; find sub-string
0059++ 1127             ; str1 in SI
0060++ 1127             ; str2 in DI
0061++ 1127             ; SI points to end of source string
0062++ 1127             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 1127             _strstr:
0064++ 1127 DB          	push al
0065++ 1128 DA          	push d
0066++ 1129 E3          	push di
0067++ 112A             _strstr_loop:
0068++ 112A F3          	cmpsb					; compare a byte of the strings
0069++ 112B C7 36 11    	jne _strstr_ret
0070++ 112E FC 00 00    	lea d, [di + 0]
0071++ 1131 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1133 C7 2A 11    	jne _strstr_loop				; equal chars but not at end
0073++ 1136             _strstr_ret:
0074++ 1136 F0          	pop di
0075++ 1137 E7          	pop d
0076++ 1138 E8          	pop al
0077++ 1139 09          	ret
0078++ 113A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 113A             ; length of null terminated string
0080++ 113A             ; result in C
0081++ 113A             ; pointer in D
0082++ 113A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 113A             _strlen:
0084++ 113A DA          	push d
0085++ 113B 38 00 00    	mov c, 0
0086++ 113E             _strlen_L1:
0087++ 113E BD 00       	cmp byte [d], 0
0088++ 1140 C6 48 11    	je _strlen_ret
0089++ 1143 79          	inc d
0090++ 1144 78          	inc c
0091++ 1145 0A 3E 11    	jmp _strlen_L1
0092++ 1148             _strlen_ret:
0093++ 1148 E7          	pop d
0094++ 1149 09          	ret
0095++ 114A             
0096++ 114A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 114A             ; STRCMP
0098++ 114A             ; compare two strings
0099++ 114A             ; str1 in SI
0100++ 114A             ; str2 in DI
0101++ 114A             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 114A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 114A             _strcmp:
0104++ 114A DB          	push al
0105++ 114B DA          	push d
0106++ 114C E3          	push di
0107++ 114D E2          	push si
0108++ 114E             _strcmp_loop:
0109++ 114E F3          	cmpsb					; compare a byte of the strings
0110++ 114F C7 5A 11    	jne _strcmp_ret
0111++ 1152 FB FF FF    	lea d, [si +- 1]
0112++ 1155 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1157 C7 4E 11    	jne _strcmp_loop				; equal chars but not at end
0114++ 115A             _strcmp_ret:
0115++ 115A EF          	pop si
0116++ 115B F0          	pop di
0117++ 115C E7          	pop d
0118++ 115D E8          	pop al
0119++ 115E 09          	ret
0120++ 115F             
0121++ 115F             
0122++ 115F             ; STRCPY
0123++ 115F             ; copy null terminated string from SI to DI
0124++ 115F             ; source in SI
0125++ 115F             ; destination in DI
0126++ 115F             _strcpy:
0127++ 115F E2          	push si
0128++ 1160 E3          	push di
0129++ 1161 DB          	push al
0130++ 1162             _strcpy_L1:
0131++ 1162 F6          	lodsb
0132++ 1163 F7          	stosb
0133++ 1164 B9 00       	cmp al, 0
0134++ 1166 C7 62 11    	jne _strcpy_L1
0135++ 1169             _strcpy_end:
0136++ 1169 E8          	pop al
0137++ 116A F0          	pop di
0138++ 116B EF          	pop si
0139++ 116C 09          	ret
0140++ 116D             
0141++ 116D             ; STRCAT
0142++ 116D             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 116D             ; source in SI
0144++ 116D             ; destination in DI
0145++ 116D             _strcat:
0146++ 116D E2          	push si
0147++ 116E E3          	push di
0148++ 116F D7          	push a
0149++ 1170 DA          	push d
0150++ 1171 50          	mov a, di
0151++ 1172 3C          	mov d, a
0152++ 1173             _strcat_goto_end_L1:
0153++ 1173 BD 00       	cmp byte[d], 0
0154++ 1175 C6 7C 11    	je _strcat_start
0155++ 1178 79          	inc d
0156++ 1179 0A 73 11    	jmp _strcat_goto_end_L1
0157++ 117C             _strcat_start:
0158++ 117C FD 50       	mov di, d
0159++ 117E             _strcat_L1:
0160++ 117E F6          	lodsb
0161++ 117F F7          	stosb
0162++ 1180 B9 00       	cmp al, 0
0163++ 1182 C7 7E 11    	jne _strcat_L1
0164++ 1185             _strcat_end:
0165++ 1185 E7          	pop d
0166++ 1186 E4          	pop a
0167++ 1187 F0          	pop di
0168++ 1188 EF          	pop si
0169++ 1189 09          	ret
0170++ 118A             
0171++ 118A             
0005+  118A             
0006+  118A             ;-----------------------------------------------------------------------------
0007+  118A             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0008+  118A             ; ASCII in BL
0009+  118A             ; result in AL
0010+  118A             ; ascii for F = 0100 0110
0011+  118A             ; ascii for 9 = 0011 1001
0012+  118A             ;-----------------------------------------------------------------------------
0013+  118A             hex_ascii_encode:
0014+  118A 1B            mov al, bl
0015+  118B 93 40         test al, $40        ; test if letter or number
0016+  118D C7 93 11      jnz hex_letter
0017+  1190 87 0F         and al, $0F        ; get number
0018+  1192 09            ret
0019+  1193             hex_letter:
0020+  1193 87 0F         and al, $0F        ; get letter
0021+  1195 6A 09         add al, 9
0022+  1197 09            ret
0023+  1198             
0024+  1198             ;-----------------------------------------------------------------------------
0025+  1198             ; ATOI
0026+  1198             ; 2 letter hex string in B
0027+  1198             ; 8bit integer returned in AL
0028+  1198             ;-----------------------------------------------------------------------------
0029+  1198             _atoi:
0030+  1198 D8            push b
0031+  1199 07 8A 11      call hex_ascii_encode      ; convert BL to 4bit code in AL
0032+  119C 30            mov bl, bh
0033+  119D DB            push al          ; save a
0034+  119E 07 8A 11      call hex_ascii_encode
0035+  11A1 EA            pop bl  
0036+  11A2 FD 9E 04      shl al, 4
0037+  11A5 8C            or al, bl
0038+  11A6 E5            pop b
0039+  11A7 09            ret  
0040+  11A8             
0041+  11A8             ;-----------------------------------------------------------------------------
0042+  11A8             ; scanf
0043+  11A8             ; no need for explanations!
0044+  11A8             ;-----------------------------------------------------------------------------
0045+  11A8             scanf:
0046+  11A8 09            ret
0047+  11A9             
0048+  11A9             ;-----------------------------------------------------------------------------
0049+  11A9             ; ITOA
0050+  11A9             ; 8bit value in BL
0051+  11A9             ; 2 byte ASCII result in A
0052+  11A9             ;-----------------------------------------------------------------------------
0053+  11A9             _itoa:
0054+  11A9 DA            push d
0055+  11AA D8            push b
0056+  11AB A7 00         mov bh, 0
0057+  11AD FD A4 04      shr bl, 4  
0058+  11B0 74            mov d, b
0059+  11B1 1F 59 14      mov al, [d + s_hex_digits]
0060+  11B4 23            mov ah, al
0061+  11B5               
0062+  11B5 E5            pop b
0063+  11B6 D8            push b
0064+  11B7 A7 00         mov bh, 0
0065+  11B9 FD 87 0F      and bl, $0F
0066+  11BC 74            mov d, b
0067+  11BD 1F 59 14      mov al, [d + s_hex_digits]
0068+  11C0 E5            pop b
0069+  11C1 E7            pop d
0070+  11C2 09            ret
0071+  11C3             
0072+  11C3             ;-----------------------------------------------------------------------------
0073+  11C3             ; HEX STRING TO BINARY
0074+  11C3             ; di = destination address
0075+  11C3             ; si = source
0076+  11C3             ;-----------------------------------------------------------------------------
0077+  11C3             _hex_to_int:
0078+  11C3             _hex_to_int_L1:
0079+  11C3 F6            lodsb          ; load from [SI] to AL
0080+  11C4 B9 00         cmp al, 0        ; check if ASCII 0
0081+  11C6 C6 D3 11      jz _hex_to_int_ret
0082+  11C9 36            mov bh, al
0083+  11CA F6            lodsb
0084+  11CB 2F            mov bl, al
0085+  11CC 07 98 11      call _atoi        ; convert ASCII byte in B to int (to AL)
0086+  11CF F7            stosb          ; store AL to [DI]
0087+  11D0 0A C3 11      jmp _hex_to_int_L1
0088+  11D3             _hex_to_int_ret:
0089+  11D3 09            ret    
0090+  11D4             
0091+  11D4             ;-----------------------------------------------------------------------------
0092+  11D4             ; GETCHAR
0093+  11D4             ; char in ah
0094+  11D4             ;-----------------------------------------------------------------------------
0095+  11D4             getch:
0096+  11D4 DB            push al
0097+  11D5             getch_retry:
0098+  11D5 19 01         mov al, 1
0099+  11D7 05 03         syscall sys_io      ; receive in AH
0100+  11D9 E8            pop al
0101+  11DA 09            ret
0102+  11DB             
0103+  11DB             ;-----------------------------------------------------------------------------
0104+  11DB             ; PUTCHAR
0105+  11DB             ; char in ah
0106+  11DB             ;-----------------------------------------------------------------------------
0107+  11DB             _putchar:
0108+  11DB D7            push a
0109+  11DC 19 00         mov al, 0
0110+  11DE 05 03         syscall sys_io      ; char in AH
0111+  11E0 E4            pop a
0112+  11E1 09            ret
0113+  11E2             
0114+  11E2             ;-----------------------------------------------------------------------------
0115+  11E2             ;; INPUT A STRING
0116+  11E2             ;; terminates with null
0117+  11E2             ;; pointer in D
0118+  11E2             ;-----------------------------------------------------------------------------
0119+  11E2             _gets:
0120+  11E2 D7            push a
0121+  11E3 DA            push d
0122+  11E4             _gets_loop:
0123+  11E4 19 01         mov al, 1
0124+  11E6 05 03         syscall sys_io      ; receive in AH
0125+  11E8 B9 00         cmp al, 0        ; check error code (AL)
0126+  11EA C6 E4 11      je _gets_loop      ; if no char received, retry
0127+  11ED             
0128+  11ED 76 1B         cmp ah, 27
0129+  11EF C6 10 12      je _gets_ansi_esc
0130+  11F2 76 0A         cmp ah, $0A        ; LF
0131+  11F4 C6 7B 12      je _gets_end
0132+  11F7 76 0D         cmp ah, $0D        ; CR
0133+  11F9 C6 7B 12      je _gets_end
0134+  11FC 76 5C         cmp ah, $5C        ; '\\'
0135+  11FE C6 3C 12      je _gets_escape
0136+  1201               
0137+  1201 76 08         cmp ah, $08      ; check for backspace
0138+  1203 C6 0C 12      je _gets_backspace
0139+  1206             
0140+  1206 1A            mov al, ah
0141+  1207 3E            mov [d], al
0142+  1208 79            inc d
0143+  1209 0A E4 11      jmp _gets_loop
0144+  120C             _gets_backspace:
0145+  120C 7F            dec d
0146+  120D 0A E4 11      jmp _gets_loop
0147+  1210             _gets_ansi_esc:
0148+  1210 19 01         mov al, 1
0149+  1212 05 03         syscall sys_io        ; receive in AH without echo
0150+  1214 B9 00         cmp al, 0          ; check error code (AL)
0151+  1216 C6 10 12      je _gets_ansi_esc    ; if no char received, retry
0152+  1219 76 5B         cmp ah, '['
0153+  121B C7 E4 11      jne _gets_loop
0154+  121E             _gets_ansi_esc_2:
0155+  121E 19 01         mov al, 1
0156+  1220 05 03         syscall sys_io          ; receive in AH without echo
0157+  1222 B9 00         cmp al, 0            ; check error code (AL)
0158+  1224 C6 1E 12      je _gets_ansi_esc_2  ; if no char received, retry
0159+  1227 76 44         cmp ah, 'D'
0160+  1229 C6 34 12      je _gets_left_arrow
0161+  122C 76 43         cmp ah, 'C'
0162+  122E C6 38 12      je _gets_right_arrow
0163+  1231 0A E4 11      jmp _gets_loop
0164+  1234             _gets_left_arrow:
0165+  1234 7F            dec d
0166+  1235 0A E4 11      jmp _gets_loop
0167+  1238             _gets_right_arrow:
0168+  1238 79            inc d
0169+  1239 0A E4 11      jmp _gets_loop
0170+  123C             _gets_escape:
0171+  123C 19 01         mov al, 1
0172+  123E 05 03         syscall sys_io      ; receive in AH
0173+  1240 B9 00         cmp al, 0        ; check error code (AL)
0174+  1242 C6 3C 12      je _gets_escape      ; if no char received, retry
0175+  1245 76 6E         cmp ah, 'n'
0176+  1247 C6 66 12      je _gets_LF
0177+  124A 76 72         cmp ah, 'r'
0178+  124C C6 6D 12      je _gets_CR
0179+  124F 76 30         cmp ah, '0'
0180+  1251 C6 74 12      je _gets_NULL
0181+  1254 76 5C         cmp ah, $5C  ; '\'
0182+  1256 C6 5F 12      je _gets_slash
0183+  1259 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0184+  125A 3E            mov [d], al
0185+  125B 79            inc d
0186+  125C 0A E4 11      jmp _gets_loop
0187+  125F             _gets_slash:
0188+  125F 19 5C         mov al, $5C
0189+  1261 3E            mov [d], al
0190+  1262 79            inc d
0191+  1263 0A E4 11      jmp _gets_loop
0192+  1266             _gets_LF:
0193+  1266 19 0A         mov al, $0A
0194+  1268 3E            mov [d], al
0195+  1269 79            inc d
0196+  126A 0A E4 11      jmp _gets_loop
0197+  126D             _gets_CR:
0198+  126D 19 0D         mov al, $0D
0199+  126F 3E            mov [d], al
0200+  1270 79            inc d
0201+  1271 0A E4 11      jmp _gets_loop
0202+  1274             _gets_NULL:
0203+  1274 19 00         mov al, $00
0204+  1276 3E            mov [d], al
0205+  1277 79            inc d
0206+  1278 0A E4 11      jmp _gets_loop
0207+  127B             _gets_end:
0208+  127B 19 00         mov al, 0
0209+  127D 3E            mov [d], al        ; terminate string
0210+  127E E7            pop d
0211+  127F E4            pop a
0212+  1280 09            ret
0213+  1281             
0214+  1281             ;-----------------------------------------------------------------------------
0215+  1281             ;; INPUT TEXT
0216+  1281             ;; terminated with CTRL+D
0217+  1281             ;; pointer in D
0218+  1281             ;-----------------------------------------------------------------------------
0219+  1281             _gettxt:
0220+  1281 D7            push a
0221+  1282 DA            push d
0222+  1283             _gettxt_loop:
0223+  1283 19 01         mov al, 1
0224+  1285 05 03         syscall sys_io      ; receive in AH
0225+  1287 B9 00         cmp al, 0        ; check error code (AL)
0226+  1289 C6 83 12      je _gettxt_loop    ; if no char received, retry
0227+  128C 76 04         cmp ah, 4      ; EOT
0228+  128E C6 CC 12      je _gettxt_end
0229+  1291 76 08         cmp ah, $08      ; check for backspace
0230+  1293 C6 C8 12      je _gettxt_backspace
0231+  1296 76 5C         cmp ah, $5C        ; '\'
0232+  1298 C6 A1 12      je _gettxt_escape
0233+  129B 1A            mov al, ah
0234+  129C 3E            mov [d], al
0235+  129D 79            inc d
0236+  129E 0A 83 12      jmp _gettxt_loop
0237+  12A1             _gettxt_escape:
0238+  12A1 19 01         mov al, 1
0239+  12A3 05 03         syscall sys_io      ; receive in AH
0240+  12A5 B9 00         cmp al, 0        ; check error code (AL)
0241+  12A7 C6 A1 12      je _gettxt_escape    ; if no char received, retry
0242+  12AA 76 6E         cmp ah, 'n'
0243+  12AC C6 BA 12      je _gettxt_LF
0244+  12AF 76 72         cmp ah, 'r'
0245+  12B1 C6 C1 12      je _gettxt_CR
0246+  12B4 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0247+  12B5 3E            mov [d], al
0248+  12B6 79            inc d
0249+  12B7 0A 83 12      jmp _gettxt_loop
0250+  12BA             _gettxt_LF:
0251+  12BA 19 0A         mov al, $0A
0252+  12BC 3E            mov [d], al
0253+  12BD 79            inc d
0254+  12BE 0A 83 12      jmp _gettxt_loop
0255+  12C1             _gettxt_CR:
0256+  12C1 19 0D         mov al, $0D
0257+  12C3 3E            mov [d], al
0258+  12C4 79            inc d
0259+  12C5 0A 83 12      jmp _gettxt_loop
0260+  12C8             _gettxt_backspace:
0261+  12C8 7F            dec d
0262+  12C9 0A 83 12      jmp _gettxt_loop
0263+  12CC             _gettxt_end:
0264+  12CC 19 00         mov al, 0
0265+  12CE 3E            mov [d], al        ; terminate string
0266+  12CF E7            pop d
0267+  12D0 E4            pop a
0268+  12D1 09            ret
0269+  12D2             
0270+  12D2             ;-----------------------------------------------------------------------------
0271+  12D2             ; PRINT NEW LINE
0272+  12D2             ;-----------------------------------------------------------------------------
0273+  12D2             printnl:
0274+  12D2 D7            push a
0275+  12D3 10 00 0A      mov a, $0A00
0276+  12D6 05 03         syscall sys_io
0277+  12D8 10 00 0D      mov a, $0D00
0278+  12DB 05 03         syscall sys_io
0279+  12DD E4            pop a
0280+  12DE 09            ret
0281+  12DF             
0282+  12DF             ;-----------------------------------------------------------------------------
0283+  12DF             ; _strtoint
0284+  12DF             ; 4 digit hex string number in d
0285+  12DF             ; integer returned in A
0286+  12DF             ;-----------------------------------------------------------------------------
0287+  12DF             _strtointx:
0288+  12DF D8            push b
0289+  12E0 32            mov bl, [d]
0290+  12E1 37            mov bh, bl
0291+  12E2 33 01 00      mov bl, [d + 1]
0292+  12E5 07 98 11      call _atoi        ; convert to int in AL
0293+  12E8 23            mov ah, al        ; move to AH
0294+  12E9 33 02 00      mov bl, [d + 2]
0295+  12EC 37            mov bh, bl
0296+  12ED 33 03 00      mov bl, [d + 3]
0297+  12F0 07 98 11      call _atoi        ; convert to int in AL
0298+  12F3 E5            pop b
0299+  12F4 09            ret
0300+  12F5             
0301+  12F5             ;-----------------------------------------------------------------------------
0302+  12F5             ; _strtoint
0303+  12F5             ; 5 digit base10 string number in d
0304+  12F5             ; integer returned in A
0305+  12F5             ;-----------------------------------------------------------------------------
0306+  12F5             _strtoint:
0307+  12F5 E2            push si
0308+  12F6 D8            push b
0309+  12F7 D9            push c
0310+  12F8 DA            push d
0311+  12F9 07 3A 11      call _strlen      ; get string length in C
0312+  12FC 7E            dec c
0313+  12FD FD 4E         mov si, d
0314+  12FF 12            mov a, c
0315+  1300 FD 99         shl a
0316+  1302 3B 71 14      mov d, table_power
0317+  1305 59            add d, a
0318+  1306 38 00 00      mov c, 0
0319+  1309             _strtoint_L0:
0320+  1309 F6            lodsb      ; load ASCII to al
0321+  130A B9 00         cmp al, 0
0322+  130C C6 1F 13      je _strtoint_end
0323+  130F 6F 30         sub al, $30    ; make into integer
0324+  1311 22 00         mov ah, 0
0325+  1313 2A            mov b, [d]
0326+  1314 AC            mul a, b      ; result in B since it fits in 16bits
0327+  1315 11            mov a, b
0328+  1316 28            mov b, c
0329+  1317 54            add a, b
0330+  1318 39            mov c, a
0331+  1319 63 02 00      sub d, 2
0332+  131C 0A 09 13      jmp _strtoint_L0
0333+  131F             _strtoint_end:
0334+  131F 12            mov a, c
0335+  1320 E7            pop d
0336+  1321 E6            pop c
0337+  1322 E5            pop b
0338+  1323 EF            pop si
0339+  1324 09            ret
0340+  1325             
0341+  1325             ;-----------------------------------------------------------------------------
0342+  1325             ; PRINT NULL TERMINATED STRING
0343+  1325             ; pointer in D
0344+  1325             ;-----------------------------------------------------------------------------
0345+  1325             _puts:
0346+  1325 D7            push a
0347+  1326 DA            push d
0348+  1327             _puts_L1:
0349+  1327 1E            mov al, [d]
0350+  1328 B9 00         cmp al, 0
0351+  132A C6 36 13      jz _puts_END
0352+  132D 23            mov ah, al
0353+  132E 19 00         mov al, 0
0354+  1330 05 03         syscall sys_io
0355+  1332 79            inc d
0356+  1333 0A 27 13      jmp _puts_L1
0357+  1336             _puts_END:
0358+  1336 E7            pop d
0359+  1337 E4            pop a
0360+  1338 09            ret
0361+  1339             
0362+  1339             ;-----------------------------------------------------------------------------
0363+  1339             ; PRINT N SIZE STRING
0364+  1339             ; pointer in D
0365+  1339             ; size in C
0366+  1339             ;-----------------------------------------------------------------------------
0367+  1339             _putsn:
0368+  1339 DB            push al
0369+  133A DA            push d
0370+  133B D9            push c
0371+  133C             _putsn_L0:
0372+  133C 1E            mov al, [d]
0373+  133D 23            mov ah, al
0374+  133E 19 00         mov al, 0
0375+  1340 05 03         syscall sys_io
0376+  1342 79            inc d
0377+  1343 7E            dec c  
0378+  1344 C2 00 00      cmp c, 0
0379+  1347 C7 3C 13      jne _putsn_L0
0380+  134A             _putsn_end:
0381+  134A E6            pop c
0382+  134B E7            pop d
0383+  134C E8            pop al
0384+  134D 09            ret
0385+  134E             
0386+  134E             ;-----------------------------------------------------------------------------
0387+  134E             ; print 16bit decimal number
0388+  134E             ; input number in A
0389+  134E             ;-----------------------------------------------------------------------------
0390+  134E             print_u16d:
0391+  134E D7            push a
0392+  134F D8            push b
0393+  1350 26 10 27      mov b, 10000
0394+  1353 AE            div a, b      ; get 10000's coeff.
0395+  1354 07 76 13      call print_number
0396+  1357 11            mov a, b
0397+  1358 26 E8 03      mov b, 1000
0398+  135B AE            div a, b      ; get 1000's coeff.
0399+  135C 07 76 13      call print_number
0400+  135F 11            mov a, b
0401+  1360 26 64 00      mov b, 100
0402+  1363 AE            div a, b
0403+  1364 07 76 13      call print_number
0404+  1367 11            mov a, b
0405+  1368 26 0A 00      mov b, 10
0406+  136B AE            div a, b
0407+  136C 07 76 13      call print_number
0408+  136F 1B            mov al, bl      ; 1's coeff in bl
0409+  1370 07 76 13      call print_number
0410+  1373 E5            pop b
0411+  1374 E4            pop a
0412+  1375 09            ret
0413+  1376             
0414+  1376             ;-----------------------------------------------------------------------------
0415+  1376             ; print AL
0416+  1376             ;-----------------------------------------------------------------------------
0417+  1376             print_number:
0418+  1376 6A 30         add al, $30
0419+  1378 23            mov ah, al
0420+  1379 07 DB 11      call _putchar
0421+  137C 09            ret
0422+  137D             
0423+  137D             ;-----------------------------------------------------------------------------
0424+  137D             ; PRINT 16BIT HEX INTEGER
0425+  137D             ; integer value in reg B
0426+  137D             ;-----------------------------------------------------------------------------
0427+  137D             print_u16x:
0428+  137D D7            push a
0429+  137E D8            push b
0430+  137F DD            push bl
0431+  1380 30            mov bl, bh
0432+  1381 07 A9 11      call _itoa        ; convert bh to char in A
0433+  1384 2F            mov bl, al        ; save al
0434+  1385 19 00         mov al, 0
0435+  1387 05 03         syscall sys_io        ; display AH
0436+  1389 24            mov ah, bl        ; retrieve al
0437+  138A 19 00         mov al, 0
0438+  138C 05 03         syscall sys_io        ; display AL
0439+  138E             
0440+  138E EA            pop bl
0441+  138F 07 A9 11      call _itoa        ; convert bh to char in A
0442+  1392 2F            mov bl, al        ; save al
0443+  1393 19 00         mov al, 0
0444+  1395 05 03         syscall sys_io        ; display AH
0445+  1397 24            mov ah, bl        ; retrieve al
0446+  1398 19 00         mov al, 0
0447+  139A 05 03         syscall sys_io        ; display AL
0448+  139C             
0449+  139C E5            pop b
0450+  139D E4            pop a
0451+  139E 09            ret
0452+  139F             
0453+  139F             ;-----------------------------------------------------------------------------
0454+  139F             ; INPUT 16BIT HEX INTEGER
0455+  139F             ; read 16bit integer into A
0456+  139F             ;-----------------------------------------------------------------------------
0457+  139F             scan_u16x:
0458+  139F F8 10 00      enter 16
0459+  13A2 D8            push b
0460+  13A3 DA            push d
0461+  13A4             
0462+  13A4 FA F1 FF      lea d, [bp + -15]
0463+  13A7 07 E2 11      call _gets        ; get number
0464+  13AA             
0465+  13AA 32            mov bl, [d]
0466+  13AB 37            mov bh, bl
0467+  13AC 33 01 00      mov bl, [d + 1]
0468+  13AF 07 98 11      call _atoi        ; convert to int in AL
0469+  13B2 23            mov ah, al        ; move to AH
0470+  13B3             
0471+  13B3 33 02 00      mov bl, [d + 2]
0472+  13B6 37            mov bh, bl
0473+  13B7 33 03 00      mov bl, [d + 3]
0474+  13BA 07 98 11      call _atoi        ; convert to int in AL
0475+  13BD             
0476+  13BD E7            pop d
0477+  13BE E5            pop b
0478+  13BF F9            leave
0479+  13C0 09            ret
0480+  13C1             
0481+  13C1             ;-----------------------------------------------------------------------------
0482+  13C1             ; PRINT 8bit HEX INTEGER
0483+  13C1             ; integer value in reg bl
0484+  13C1             ;-----------------------------------------------------------------------------
0485+  13C1             print_u8x:
0486+  13C1 D7            push a
0487+  13C2 DD            push bl
0488+  13C3             
0489+  13C3 07 A9 11      call _itoa        ; convert bl to char in A
0490+  13C6 2F            mov bl, al        ; save al
0491+  13C7 19 00         mov al, 0
0492+  13C9 05 03         syscall sys_io        ; display AH
0493+  13CB 24            mov ah, bl        ; retrieve al
0494+  13CC 19 00         mov al, 0
0495+  13CE 05 03         syscall sys_io        ; display AL
0496+  13D0             
0497+  13D0 EA            pop bl
0498+  13D1 E4            pop a
0499+  13D2 09            ret
0500+  13D3             
0501+  13D3             ;-----------------------------------------------------------------------------
0502+  13D3             ; print 8bit decimal unsigned number
0503+  13D3             ; input number in AL
0504+  13D3             ;-----------------------------------------------------------------------------
0505+  13D3             print_u8d:
0506+  13D3 D7            push a
0507+  13D4 D8            push b
0508+  13D5             
0509+  13D5 22 00         mov ah, 0
0510+  13D7 26 64 00      mov b, 100
0511+  13DA AE            div a, b
0512+  13DB D8            push b      ; save remainder
0513+  13DC B9 00         cmp al, 0
0514+  13DE C6 E8 13      je skip100
0515+  13E1 6A 30         add al, $30
0516+  13E3 23            mov ah, al
0517+  13E4 19 00         mov al, 0
0518+  13E6 05 03         syscall sys_io  ; print coeff
0519+  13E8             skip100:
0520+  13E8 E4            pop a
0521+  13E9 22 00         mov ah, 0
0522+  13EB 26 0A 00      mov b, 10
0523+  13EE AE            div a, b
0524+  13EF D8            push b      ; save remainder
0525+  13F0 B9 00         cmp al, 0
0526+  13F2 C6 FC 13      je skip10
0527+  13F5 6A 30         add al, $30
0528+  13F7 23            mov ah, al
0529+  13F8 19 00         mov al, 0
0530+  13FA 05 03         syscall sys_io  ; print coeff
0531+  13FC             skip10:
0532+  13FC E4            pop a
0533+  13FD 1B            mov al, bl
0534+  13FE 6A 30         add al, $30
0535+  1400 23            mov ah, al
0536+  1401 19 00         mov al, 0
0537+  1403 05 03         syscall sys_io  ; print coeff
0538+  1405 E5            pop b
0539+  1406 E4            pop a
0540+  1407 09            ret
0541+  1408             
0542+  1408             ;-----------------------------------------------------------------------------
0543+  1408             ; INPUT 8BIT HEX INTEGER
0544+  1408             ; read 8bit integer into AL
0545+  1408             ;-----------------------------------------------------------------------------
0546+  1408             scan_u8x:
0547+  1408 F8 04 00      enter 4
0548+  140B D8            push b
0549+  140C DA            push d
0550+  140D             
0551+  140D FA FD FF      lea d, [bp + -3]
0552+  1410 07 E2 11      call _gets        ; get number
0553+  1413             
0554+  1413 32            mov bl, [d]
0555+  1414 37            mov bh, bl
0556+  1415 33 01 00      mov bl, [d + 1]
0557+  1418 07 98 11      call _atoi        ; convert to int in AL
0558+  141B             
0559+  141B E7            pop d
0560+  141C E5            pop b
0561+  141D F9            leave
0562+  141E 09            ret
0563+  141F             
0564+  141F             ;-----------------------------------------------------------------------------
0565+  141F             ; input decimal number
0566+  141F             ; result in A
0567+  141F             ; 655'\0'
0568+  141F             ; low--------high
0569+  141F             ;-----------------------------------------------------------------------------
0570+  141F             scan_u16d:
0571+  141F F8 08 00      enter 8
0572+  1422 E2            push si
0573+  1423 D8            push b
0574+  1424 D9            push c
0575+  1425 DA            push d
0576+  1426 FA F9 FF      lea d, [bp +- 7]
0577+  1429 07 E2 11      call _gets
0578+  142C 07 3A 11      call _strlen      ; get string length in C
0579+  142F 7E            dec c
0580+  1430 FD 4E         mov si, d
0581+  1432 12            mov a, c
0582+  1433 FD 99         shl a
0583+  1435 3B 71 14      mov d, table_power
0584+  1438 59            add d, a
0585+  1439 38 00 00      mov c, 0
0586+  143C             mul_loop:
0587+  143C F6            lodsb      ; load ASCII to al
0588+  143D B9 00         cmp al, 0
0589+  143F C6 52 14      je mul_exit
0590+  1442 6F 30         sub al, $30    ; make into integer
0591+  1444 22 00         mov ah, 0
0592+  1446 2A            mov b, [d]
0593+  1447 AC            mul a, b      ; result in B since it fits in 16bits
0594+  1448 11            mov a, b
0595+  1449 28            mov b, c
0596+  144A 54            add a, b
0597+  144B 39            mov c, a
0598+  144C 63 02 00      sub d, 2
0599+  144F 0A 3C 14      jmp mul_loop
0600+  1452             mul_exit:
0601+  1452 12            mov a, c
0602+  1453 E7            pop d
0603+  1454 E6            pop c
0604+  1455 E5            pop b
0605+  1456 EF            pop si
0606+  1457 F9            leave
0607+  1458 09            ret
0608+  1459             
0609+  1459 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0609+  145D 34 35 36 37 
0609+  1461 38 39 41 42 
0609+  1465 43 44 45 46 
0610+  1469 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0610+  146D 1B 5B 48 00 
0611+  1471             
0612+  1471             table_power:
0613+  1471 01 00         .dw 1
0614+  1473 0A 00         .dw 10
0615+  1475 64 00         .dw 100
0616+  1477 E8 03         .dw 1000
0617+  1479 10 27         .dw 100002467   147B             ; --- END INLINE ASM BLOCK
2468   147B             
2469   147B F9            leave
2470   147C 09            ret
2471   147D             ; --- END TEXT BLOCK
2472   147D             
2473   147D             ; --- BEGIN DATA BLOCK
2474   147D 14 00       _a: .dw 20
2475   147F 0A 00       _b: .dw 10
2476   1481 41          _c: .db $41
2477   1482 55 6E 65 78 __s0: .db "Unexpected format in printf.", 0
2477   1486 70 65 63 74 
2477   148A 65 64 20 66 
2477   148E 6F 72 6D 61 
2477   1492 74 20 69 6E 
2477   1496 20 70 72 69 
2477   149A 6E 74 66 2E 
2477   149E 00 
2478   149F 45 72 72 6F __s1: .db "Error: Unknown argument type.\n", 0
2478   14A3 72 3A 20 55 
2478   14A7 6E 6B 6E 6F 
2478   14AB 77 6E 20 61 
2478   14AF 72 67 75 6D 
2478   14B3 65 6E 74 20 
2478   14B7 74 79 70 65 
2478   14BB 2E 0A 00 
2479   14BE 1B 5B 32 4A __s2: .db "\033[2J\033[H", 0
2479   14C2 1B 5B 48 00 
2480   14C6             
2481   14C6 C8 14       _heap_top: .dw _heap
2482   14C8 00          _heap: .db 0
2483   14C9             ; --- END DATA BLOCK
2484   14C9             
2485   14C9             .end
tasm: Number of errors = 0
