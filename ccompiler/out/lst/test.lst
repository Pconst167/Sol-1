0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT SEGMENT
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; 120 + myfunc(1); 
0011   0408 FD 2E 78 00   mov32 cb, $00000078
0011   040C 00 00 
0012   040E             ; --- START TERMS
0013   040E D7            push a
0014   040F 11            mov a, b
0015   0410             ; --- START FUNCTION CALL
0016   0410 FD 2E 01 00   mov32 cb, $00000001
0016   0414 00 00 
0017   0416 FD AB         swp b
0018   0418 D8            push b
0019   0419 07 79 21      call myfunc
0020   041C 51 02 00      add sp, 2
0021   041F             ; --- END FUNCTION CALL
0022   041F 56            add b, a
0023   0420 E4            pop a
0024   0421             ; --- END TERMS
0025   0421             ; printf("Hello"); 
0026   0421             ; --- START FUNCTION CALL
0027   0421 26 80 21      mov b, _s0 ; "Hello"
0028   0424 FD AB         swp b
0029   0426 D8            push b
0030   0427 07 6F 09      call printf
0031   042A 51 02 00      add sp, 2
0032   042D             ; --- END FUNCTION CALL
0033   042D             ; print_signed(123); 
0034   042D             ; --- START FUNCTION CALL
0035   042D FD 2E 7B 00   mov32 cb, $0000007b
0035   0431 00 00 
0036   0433 FD AB         swp b
0037   0435 D8            push b
0038   0436 07 E4 14      call print_signed
0039   0439 51 02 00      add sp, 2
0040   043C             ; --- END FUNCTION CALL
0041   043C 05 0B         syscall sys_terminate_proc
0042   043E             
0043   043E             strcpy:
0044   043E F8 00 00      enter 0 ; (push bp; mov bp, sp)
0045   0441             ; char *psrc; 
0046   0441 52 02 00      sub sp, 2
0047   0444             ; char *pdest; 
0048   0444 52 02 00      sub sp, 2
0049   0447             ; psrc = src; 
0050   0447 FA FF FF      lea d, [bp + -1] ; $psrc
0051   044A DA            push d
0052   044B FA 07 00      lea d, [bp + 7] ; $src
0053   044E 2A            mov b, [d]
0054   044F 38 00 00      mov c, 0
0055   0452 E7            pop d
0056   0453 FD 43         mov [d], b
0057   0455             ; pdest = dest; 
0058   0455 FA FD FF      lea d, [bp + -3] ; $pdest
0059   0458 DA            push d
0060   0459 FA 05 00      lea d, [bp + 5] ; $dest
0061   045C 2A            mov b, [d]
0062   045D 38 00 00      mov c, 0
0063   0460 E7            pop d
0064   0461 FD 43         mov [d], b
0065   0463             ; while(*psrc) *pdest++ = *psrc++; 
0066   0463             _while1_cond:
0067   0463 FA FF FF      lea d, [bp + -1] ; $psrc
0068   0466 2A            mov b, [d]
0069   0467 38 00 00      mov c, 0
0070   046A 74            mov d, b
0071   046B 32            mov bl, [d]
0072   046C A7 00         mov bh, 0
0073   046E 38 00 00      mov c, 0
0074   0471 C0 00 00      cmp b, 0
0075   0474 C6 A5 04      je _while1_exit
0076   0477             _while1_block:
0077   0477             ; *pdest++ = *psrc++; 
0078   0477 FA FD FF      lea d, [bp + -3] ; $pdest
0079   047A 2A            mov b, [d]
0080   047B 38 00 00      mov c, 0
0081   047E FD 77         inc b
0082   0480 FA FD FF      lea d, [bp + -3] ; $pdest
0083   0483 FD 43         mov [d], b
0084   0485 FD 7D         dec b
0085   0487 D8            push b
0086   0488 FA FF FF      lea d, [bp + -1] ; $psrc
0087   048B 2A            mov b, [d]
0088   048C 38 00 00      mov c, 0
0089   048F FD 77         inc b
0090   0491 FA FF FF      lea d, [bp + -1] ; $psrc
0091   0494 FD 43         mov [d], b
0092   0496 FD 7D         dec b
0093   0498 74            mov d, b
0094   0499 32            mov bl, [d]
0095   049A A7 00         mov bh, 0
0096   049C 38 00 00      mov c, 0
0097   049F E7            pop d
0098   04A0 FD 3E         mov [d], bl
0099   04A2 0A 63 04      jmp _while1_cond
0100   04A5             _while1_exit:
0101   04A5             ; *pdest = '\0'; 
0102   04A5 FA FD FF      lea d, [bp + -3] ; $pdest
0103   04A8 2A            mov b, [d]
0104   04A9 38 00 00      mov c, 0
0105   04AC D8            push b
0106   04AD FD 2E 00 00   mov32 cb, $00000000
0106   04B1 00 00 
0107   04B3 E7            pop d
0108   04B4 FD 3E         mov [d], bl
0109   04B6 F9            leave
0110   04B7 09            ret
0111   04B8             
0112   04B8             strcmp:
0113   04B8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0114   04BB             ; while (*s1 && (*s1 == *s2)) { 
0115   04BB             _while2_cond:
0116   04BB FA 05 00      lea d, [bp + 5] ; $s1
0117   04BE 2A            mov b, [d]
0118   04BF 38 00 00      mov c, 0
0119   04C2 74            mov d, b
0120   04C3 32            mov bl, [d]
0121   04C4 A7 00         mov bh, 0
0122   04C6 38 00 00      mov c, 0
0123   04C9             ; --- START LOGICAL AND
0124   04C9 D7            push a
0125   04CA 11            mov a, b
0126   04CB FA 05 00      lea d, [bp + 5] ; $s1
0127   04CE 2A            mov b, [d]
0128   04CF 38 00 00      mov c, 0
0129   04D2 74            mov d, b
0130   04D3 32            mov bl, [d]
0131   04D4 A7 00         mov bh, 0
0132   04D6 38 00 00      mov c, 0
0133   04D9             ; --- START RELATIONAL
0134   04D9 D7            push a
0135   04DA 11            mov a, b
0136   04DB FA 07 00      lea d, [bp + 7] ; $s2
0137   04DE 2A            mov b, [d]
0138   04DF 38 00 00      mov c, 0
0139   04E2 74            mov d, b
0140   04E3 32            mov bl, [d]
0141   04E4 A7 00         mov bh, 0
0142   04E6 38 00 00      mov c, 0
0143   04E9 B0            cmp a, b
0144   04EA FD 71         seq ; ==
0145   04EC E4            pop a
0146   04ED             ; --- END RELATIONAL
0147   04ED FD A7         sand a, b
0148   04EF E4            pop a
0149   04F0             ; --- END LOGICAL AND
0150   04F0 C0 00 00      cmp b, 0
0151   04F3 C6 19 05      je _while2_exit
0152   04F6             _while2_block:
0153   04F6             ; s1++; 
0154   04F6 FA 05 00      lea d, [bp + 5] ; $s1
0155   04F9 2A            mov b, [d]
0156   04FA 38 00 00      mov c, 0
0157   04FD FD 77         inc b
0158   04FF FA 05 00      lea d, [bp + 5] ; $s1
0159   0502 FD 43         mov [d], b
0160   0504 FD 7D         dec b
0161   0506             ; s2++; 
0162   0506 FA 07 00      lea d, [bp + 7] ; $s2
0163   0509 2A            mov b, [d]
0164   050A 38 00 00      mov c, 0
0165   050D FD 77         inc b
0166   050F FA 07 00      lea d, [bp + 7] ; $s2
0167   0512 FD 43         mov [d], b
0168   0514 FD 7D         dec b
0169   0516 0A BB 04      jmp _while2_cond
0170   0519             _while2_exit:
0171   0519             ; return *s1 - *s2; 
0172   0519 FA 05 00      lea d, [bp + 5] ; $s1
0173   051C 2A            mov b, [d]
0174   051D 38 00 00      mov c, 0
0175   0520 74            mov d, b
0176   0521 32            mov bl, [d]
0177   0522 A7 00         mov bh, 0
0178   0524 38 00 00      mov c, 0
0179   0527             ; --- START TERMS
0180   0527 D7            push a
0181   0528 11            mov a, b
0182   0529 FA 07 00      lea d, [bp + 7] ; $s2
0183   052C 2A            mov b, [d]
0184   052D 38 00 00      mov c, 0
0185   0530 74            mov d, b
0186   0531 32            mov bl, [d]
0187   0532 A7 00         mov bh, 0
0188   0534 38 00 00      mov c, 0
0189   0537 60            sub a, b
0190   0538 27            mov b, a
0191   0539 E4            pop a
0192   053A             ; --- END TERMS
0193   053A F9            leave
0194   053B 09            ret
0195   053C             
0196   053C             strncmp:
0197   053C F8 00 00      enter 0 ; (push bp; mov bp, sp)
0198   053F F9            leave
0199   0540 09            ret
0200   0541             
0201   0541             strcat:
0202   0541 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0203   0544             ; int dest_len; 
0204   0544 52 02 00      sub sp, 2
0205   0547             ; int i; 
0206   0547 52 02 00      sub sp, 2
0207   054A             ; dest_len = strlen(dest); 
0208   054A FA FF FF      lea d, [bp + -1] ; $dest_len
0209   054D DA            push d
0210   054E             ; --- START FUNCTION CALL
0211   054E FA 05 00      lea d, [bp + 5] ; $dest
0212   0551 2A            mov b, [d]
0213   0552 38 00 00      mov c, 0
0214   0555 FD AB         swp b
0215   0557 D8            push b
0216   0558 07 24 06      call strlen
0217   055B 51 02 00      add sp, 2
0218   055E             ; --- END FUNCTION CALL
0219   055E E7            pop d
0220   055F FD 43         mov [d], b
0221   0561             ; for (i = 0; src[i] != 0; i=i+1) { 
0222   0561             _for3_init:
0223   0561 FA FD FF      lea d, [bp + -3] ; $i
0224   0564 DA            push d
0225   0565 FD 2E 00 00   mov32 cb, $00000000
0225   0569 00 00 
0226   056B E7            pop d
0227   056C FD 43         mov [d], b
0228   056E             _for3_cond:
0229   056E FA 07 00      lea d, [bp + 7] ; $src
0230   0571 FD 2A         mov d, [d]
0231   0573 D7            push a
0232   0574 DA            push d
0233   0575 FA FD FF      lea d, [bp + -3] ; $i
0234   0578 2A            mov b, [d]
0235   0579 38 00 00      mov c, 0
0236   057C E7            pop d
0237   057D FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0238   0581 E4            pop a
0239   0582 32            mov bl, [d]
0240   0583 A7 00         mov bh, 0
0241   0585 38 00 00      mov c, 0
0242   0588             ; --- START RELATIONAL
0243   0588 D7            push a
0244   0589 11            mov a, b
0245   058A FD 2E 00 00   mov32 cb, $00000000
0245   058E 00 00 
0246   0590 B0            cmp a, b
0247   0591 FD 72         sneq ; !=
0248   0593 E4            pop a
0249   0594             ; --- END RELATIONAL
0250   0594 C0 00 00      cmp b, 0
0251   0597 C6 F2 05      je _for3_exit
0252   059A             _for3_block:
0253   059A             ; dest[dest_len + i] = src[i]; 
0254   059A FA 05 00      lea d, [bp + 5] ; $dest
0255   059D FD 2A         mov d, [d]
0256   059F D7            push a
0257   05A0 DA            push d
0258   05A1 FA FF FF      lea d, [bp + -1] ; $dest_len
0259   05A4 2A            mov b, [d]
0260   05A5 38 00 00      mov c, 0
0261   05A8             ; --- START TERMS
0262   05A8 D7            push a
0263   05A9 11            mov a, b
0264   05AA FA FD FF      lea d, [bp + -3] ; $i
0265   05AD 2A            mov b, [d]
0266   05AE 38 00 00      mov c, 0
0267   05B1 56            add b, a
0268   05B2 E4            pop a
0269   05B3             ; --- END TERMS
0270   05B3 E7            pop d
0271   05B4 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0272   05B8 E4            pop a
0273   05B9 DA            push d
0274   05BA FA 07 00      lea d, [bp + 7] ; $src
0275   05BD FD 2A         mov d, [d]
0276   05BF D7            push a
0277   05C0 DA            push d
0278   05C1 FA FD FF      lea d, [bp + -3] ; $i
0279   05C4 2A            mov b, [d]
0280   05C5 38 00 00      mov c, 0
0281   05C8 E7            pop d
0282   05C9 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0283   05CD E4            pop a
0284   05CE 32            mov bl, [d]
0285   05CF A7 00         mov bh, 0
0286   05D1 38 00 00      mov c, 0
0287   05D4 E7            pop d
0288   05D5 FD 3E         mov [d], bl
0289   05D7             _for3_update:
0290   05D7 FA FD FF      lea d, [bp + -3] ; $i
0291   05DA DA            push d
0292   05DB FA FD FF      lea d, [bp + -3] ; $i
0293   05DE 2A            mov b, [d]
0294   05DF 38 00 00      mov c, 0
0295   05E2             ; --- START TERMS
0296   05E2 D7            push a
0297   05E3 11            mov a, b
0298   05E4 FD 2E 01 00   mov32 cb, $00000001
0298   05E8 00 00 
0299   05EA 56            add b, a
0300   05EB E4            pop a
0301   05EC             ; --- END TERMS
0302   05EC E7            pop d
0303   05ED FD 43         mov [d], b
0304   05EF 0A 6E 05      jmp _for3_cond
0305   05F2             _for3_exit:
0306   05F2             ; dest[dest_len + i] = 0; 
0307   05F2 FA 05 00      lea d, [bp + 5] ; $dest
0308   05F5 FD 2A         mov d, [d]
0309   05F7 D7            push a
0310   05F8 DA            push d
0311   05F9 FA FF FF      lea d, [bp + -1] ; $dest_len
0312   05FC 2A            mov b, [d]
0313   05FD 38 00 00      mov c, 0
0314   0600             ; --- START TERMS
0315   0600 D7            push a
0316   0601 11            mov a, b
0317   0602 FA FD FF      lea d, [bp + -3] ; $i
0318   0605 2A            mov b, [d]
0319   0606 38 00 00      mov c, 0
0320   0609 56            add b, a
0321   060A E4            pop a
0322   060B             ; --- END TERMS
0323   060B E7            pop d
0324   060C FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0325   0610 E4            pop a
0326   0611 DA            push d
0327   0612 FD 2E 00 00   mov32 cb, $00000000
0327   0616 00 00 
0328   0618 E7            pop d
0329   0619 FD 3E         mov [d], bl
0330   061B             ; return dest; 
0331   061B FA 05 00      lea d, [bp + 5] ; $dest
0332   061E 2A            mov b, [d]
0333   061F 38 00 00      mov c, 0
0334   0622 F9            leave
0335   0623 09            ret
0336   0624             
0337   0624             strlen:
0338   0624 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0339   0627             ; int length; 
0340   0627 52 02 00      sub sp, 2
0341   062A             ; length = 0; 
0342   062A FA FF FF      lea d, [bp + -1] ; $length
0343   062D DA            push d
0344   062E FD 2E 00 00   mov32 cb, $00000000
0344   0632 00 00 
0345   0634 E7            pop d
0346   0635 FD 43         mov [d], b
0347   0637             ; while (str[length] != 0) { 
0348   0637             _while4_cond:
0349   0637 FA 05 00      lea d, [bp + 5] ; $str
0350   063A FD 2A         mov d, [d]
0351   063C D7            push a
0352   063D DA            push d
0353   063E FA FF FF      lea d, [bp + -1] ; $length
0354   0641 2A            mov b, [d]
0355   0642 38 00 00      mov c, 0
0356   0645 E7            pop d
0357   0646 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0358   064A E4            pop a
0359   064B 32            mov bl, [d]
0360   064C A7 00         mov bh, 0
0361   064E 38 00 00      mov c, 0
0362   0651             ; --- START RELATIONAL
0363   0651 D7            push a
0364   0652 11            mov a, b
0365   0653 FD 2E 00 00   mov32 cb, $00000000
0365   0657 00 00 
0366   0659 B0            cmp a, b
0367   065A FD 72         sneq ; !=
0368   065C E4            pop a
0369   065D             ; --- END RELATIONAL
0370   065D C0 00 00      cmp b, 0
0371   0660 C6 76 06      je _while4_exit
0372   0663             _while4_block:
0373   0663             ; length++; 
0374   0663 FA FF FF      lea d, [bp + -1] ; $length
0375   0666 2A            mov b, [d]
0376   0667 38 00 00      mov c, 0
0377   066A 11            mov a, b
0378   066B FD 77         inc b
0379   066D FA FF FF      lea d, [bp + -1] ; $length
0380   0670 FD 43         mov [d], b
0381   0672 27            mov b, a
0382   0673 0A 37 06      jmp _while4_cond
0383   0676             _while4_exit:
0384   0676             ; return length; 
0385   0676 FA FF FF      lea d, [bp + -1] ; $length
0386   0679 2A            mov b, [d]
0387   067A 38 00 00      mov c, 0
0388   067D F9            leave
0389   067E 09            ret
0390   067F             
0391   067F             exit:
0392   067F F8 00 00      enter 0 ; (push bp; mov bp, sp)
0393   0682             
0394   0682             ; --- BEGIN INLINE ASM SEGMENT
0395   0682 05 0B         syscall sys_terminate_proc
0396   0684             ; --- END INLINE ASM SEGMENT
0397   0684             
0398   0684 F9            leave
0399   0685 09            ret
0400   0686             
0401   0686             memset:
0402   0686 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0403   0689             ; int i; 
0404   0689 52 02 00      sub sp, 2
0405   068C             ; for(i = 0; i < size; i++){ 
0406   068C             _for5_init:
0407   068C FA FF FF      lea d, [bp + -1] ; $i
0408   068F DA            push d
0409   0690 FD 2E 00 00   mov32 cb, $00000000
0409   0694 00 00 
0410   0696 E7            pop d
0411   0697 FD 43         mov [d], b
0412   0699             _for5_cond:
0413   0699 FA FF FF      lea d, [bp + -1] ; $i
0414   069C 2A            mov b, [d]
0415   069D 38 00 00      mov c, 0
0416   06A0             ; --- START RELATIONAL
0417   06A0 D7            push a
0418   06A1 11            mov a, b
0419   06A2 FA 08 00      lea d, [bp + 8] ; $size
0420   06A5 2A            mov b, [d]
0421   06A6 38 00 00      mov c, 0
0422   06A9 B0            cmp a, b
0423   06AA FD 73         slt ; < (signed)
0424   06AC E4            pop a
0425   06AD             ; --- END RELATIONAL
0426   06AD C0 00 00      cmp b, 0
0427   06B0 C6 E5 06      je _for5_exit
0428   06B3             _for5_block:
0429   06B3             ; *(s+i) = c; 
0430   06B3 FA 05 00      lea d, [bp + 5] ; $s
0431   06B6 2A            mov b, [d]
0432   06B7 38 00 00      mov c, 0
0433   06BA             ; --- START TERMS
0434   06BA D7            push a
0435   06BB 11            mov a, b
0436   06BC FA FF FF      lea d, [bp + -1] ; $i
0437   06BF 2A            mov b, [d]
0438   06C0 38 00 00      mov c, 0
0439   06C3 56            add b, a
0440   06C4 E4            pop a
0441   06C5             ; --- END TERMS
0442   06C5 D8            push b
0443   06C6 FA 07 00      lea d, [bp + 7] ; $c
0444   06C9 32            mov bl, [d]
0445   06CA A7 00         mov bh, 0
0446   06CC 38 00 00      mov c, 0
0447   06CF E7            pop d
0448   06D0 FD 3E         mov [d], bl
0449   06D2             _for5_update:
0450   06D2 FA FF FF      lea d, [bp + -1] ; $i
0451   06D5 2A            mov b, [d]
0452   06D6 38 00 00      mov c, 0
0453   06D9 11            mov a, b
0454   06DA FD 77         inc b
0455   06DC FA FF FF      lea d, [bp + -1] ; $i
0456   06DF FD 43         mov [d], b
0457   06E1 27            mov b, a
0458   06E2 0A 99 06      jmp _for5_cond
0459   06E5             _for5_exit:
0460   06E5             ; return s; 
0461   06E5 FA 05 00      lea d, [bp + 5] ; $s
0462   06E8 2A            mov b, [d]
0463   06E9 38 00 00      mov c, 0
0464   06EC F9            leave
0465   06ED 09            ret
0466   06EE             
0467   06EE             atoi:
0468   06EE F8 00 00      enter 0 ; (push bp; mov bp, sp)
0469   06F1             ; int result = 0;  // Initialize result 
0470   06F1 52 02 00      sub sp, 2
0471   06F4             ; --- START LOCAL VAR INITIALIZATION
0472   06F4 FA FF FF      lea d, [bp + -1] ; $result
0473   06F7 DA            push d
0474   06F8 FD 2E 00 00   mov32 cb, $00000000
0474   06FC 00 00 
0475   06FE E7            pop d
0476   06FF FD 43         mov [d], b
0477   0701             ; --- END LOCAL VAR INITIALIZATION
0478   0701             ; int sign = 1;    // Initialize sign as positive 
0479   0701 52 02 00      sub sp, 2
0480   0704             ; --- START LOCAL VAR INITIALIZATION
0481   0704 FA FD FF      lea d, [bp + -3] ; $sign
0482   0707 DA            push d
0483   0708 FD 2E 01 00   mov32 cb, $00000001
0483   070C 00 00 
0484   070E E7            pop d
0485   070F FD 43         mov [d], b
0486   0711             ; --- END LOCAL VAR INITIALIZATION
0487   0711             ; while (*str == ' ') str++; 
0488   0711             _while6_cond:
0489   0711 FA 05 00      lea d, [bp + 5] ; $str
0490   0714 2A            mov b, [d]
0491   0715 38 00 00      mov c, 0
0492   0718 74            mov d, b
0493   0719 32            mov bl, [d]
0494   071A A7 00         mov bh, 0
0495   071C 38 00 00      mov c, 0
0496   071F             ; --- START RELATIONAL
0497   071F D7            push a
0498   0720 11            mov a, b
0499   0721 FD 2E 20 00   mov32 cb, $00000020
0499   0725 00 00 
0500   0727 B0            cmp a, b
0501   0728 FD 71         seq ; ==
0502   072A E4            pop a
0503   072B             ; --- END RELATIONAL
0504   072B C0 00 00      cmp b, 0
0505   072E C6 44 07      je _while6_exit
0506   0731             _while6_block:
0507   0731             ; str++; 
0508   0731 FA 05 00      lea d, [bp + 5] ; $str
0509   0734 2A            mov b, [d]
0510   0735 38 00 00      mov c, 0
0511   0738 FD 77         inc b
0512   073A FA 05 00      lea d, [bp + 5] ; $str
0513   073D FD 43         mov [d], b
0514   073F FD 7D         dec b
0515   0741 0A 11 07      jmp _while6_cond
0516   0744             _while6_exit:
0517   0744             ; if (*str == '-' || *str == '+') { 
0518   0744             _if7_cond:
0519   0744 FA 05 00      lea d, [bp + 5] ; $str
0520   0747 2A            mov b, [d]
0521   0748 38 00 00      mov c, 0
0522   074B 74            mov d, b
0523   074C 32            mov bl, [d]
0524   074D A7 00         mov bh, 0
0525   074F 38 00 00      mov c, 0
0526   0752             ; --- START RELATIONAL
0527   0752 D7            push a
0528   0753 11            mov a, b
0529   0754 FD 2E 2D 00   mov32 cb, $0000002d
0529   0758 00 00 
0530   075A B0            cmp a, b
0531   075B FD 71         seq ; ==
0532   075D E4            pop a
0533   075E             ; --- END RELATIONAL
0534   075E             ; --- START LOGICAL OR
0535   075E D7            push a
0536   075F 11            mov a, b
0537   0760 FA 05 00      lea d, [bp + 5] ; $str
0538   0763 2A            mov b, [d]
0539   0764 38 00 00      mov c, 0
0540   0767 74            mov d, b
0541   0768 32            mov bl, [d]
0542   0769 A7 00         mov bh, 0
0543   076B 38 00 00      mov c, 0
0544   076E             ; --- START RELATIONAL
0545   076E D7            push a
0546   076F 11            mov a, b
0547   0770 FD 2E 2B 00   mov32 cb, $0000002b
0547   0774 00 00 
0548   0776 B0            cmp a, b
0549   0777 FD 71         seq ; ==
0550   0779 E4            pop a
0551   077A             ; --- END RELATIONAL
0552   077A FD A8         sor a, b ; ||
0553   077C E4            pop a
0554   077D             ; --- END LOGICAL OR
0555   077D C0 00 00      cmp b, 0
0556   0780 C6 C8 07      je _if7_exit
0557   0783             _if7_TRUE:
0558   0783             ; if (*str == '-') sign = -1; 
0559   0783             _if8_cond:
0560   0783 FA 05 00      lea d, [bp + 5] ; $str
0561   0786 2A            mov b, [d]
0562   0787 38 00 00      mov c, 0
0563   078A 74            mov d, b
0564   078B 32            mov bl, [d]
0565   078C A7 00         mov bh, 0
0566   078E 38 00 00      mov c, 0
0567   0791             ; --- START RELATIONAL
0568   0791 D7            push a
0569   0792 11            mov a, b
0570   0793 FD 2E 2D 00   mov32 cb, $0000002d
0570   0797 00 00 
0571   0799 B0            cmp a, b
0572   079A FD 71         seq ; ==
0573   079C E4            pop a
0574   079D             ; --- END RELATIONAL
0575   079D C0 00 00      cmp b, 0
0576   07A0 C6 B5 07      je _if8_exit
0577   07A3             _if8_TRUE:
0578   07A3             ; sign = -1; 
0579   07A3 FA FD FF      lea d, [bp + -3] ; $sign
0580   07A6 DA            push d
0581   07A7 FD 2E 01 00   mov32 cb, $00000001
0581   07AB 00 00 
0582   07AD FD 97         neg b
0583   07AF E7            pop d
0584   07B0 FD 43         mov [d], b
0585   07B2 0A B5 07      jmp _if8_exit
0586   07B5             _if8_exit:
0587   07B5             ; str++; 
0588   07B5 FA 05 00      lea d, [bp + 5] ; $str
0589   07B8 2A            mov b, [d]
0590   07B9 38 00 00      mov c, 0
0591   07BC FD 77         inc b
0592   07BE FA 05 00      lea d, [bp + 5] ; $str
0593   07C1 FD 43         mov [d], b
0594   07C3 FD 7D         dec b
0595   07C5 0A C8 07      jmp _if7_exit
0596   07C8             _if7_exit:
0597   07C8             ; while (*str >= '0' && *str <= '9') { 
0598   07C8             _while9_cond:
0599   07C8 FA 05 00      lea d, [bp + 5] ; $str
0600   07CB 2A            mov b, [d]
0601   07CC 38 00 00      mov c, 0
0602   07CF 74            mov d, b
0603   07D0 32            mov bl, [d]
0604   07D1 A7 00         mov bh, 0
0605   07D3 38 00 00      mov c, 0
0606   07D6             ; --- START RELATIONAL
0607   07D6 D7            push a
0608   07D7 11            mov a, b
0609   07D8 FD 2E 30 00   mov32 cb, $00000030
0609   07DC 00 00 
0610   07DE B0            cmp a, b
0611   07DF FD 82         sgeu ; >= (unsigned)
0612   07E1 E4            pop a
0613   07E2             ; --- END RELATIONAL
0614   07E2             ; --- START LOGICAL AND
0615   07E2 D7            push a
0616   07E3 11            mov a, b
0617   07E4 FA 05 00      lea d, [bp + 5] ; $str
0618   07E7 2A            mov b, [d]
0619   07E8 38 00 00      mov c, 0
0620   07EB 74            mov d, b
0621   07EC 32            mov bl, [d]
0622   07ED A7 00         mov bh, 0
0623   07EF 38 00 00      mov c, 0
0624   07F2             ; --- START RELATIONAL
0625   07F2 D7            push a
0626   07F3 11            mov a, b
0627   07F4 FD 2E 39 00   mov32 cb, $00000039
0627   07F8 00 00 
0628   07FA B0            cmp a, b
0629   07FB FD 76         sleu ; <= (unsigned)
0630   07FD E4            pop a
0631   07FE             ; --- END RELATIONAL
0632   07FE FD A7         sand a, b
0633   0800 E4            pop a
0634   0801             ; --- END LOGICAL AND
0635   0801 C0 00 00      cmp b, 0
0636   0804 C6 51 08      je _while9_exit
0637   0807             _while9_block:
0638   0807             ; result = result * 10 + (*str - '0'); 
0639   0807 FA FF FF      lea d, [bp + -1] ; $result
0640   080A DA            push d
0641   080B FA FF FF      lea d, [bp + -1] ; $result
0642   080E 2A            mov b, [d]
0643   080F 38 00 00      mov c, 0
0644   0812             ; --- START FACTORS
0645   0812 D7            push a
0646   0813 11            mov a, b
0647   0814 FD 2E 0A 00   mov32 cb, $0000000a
0647   0818 00 00 
0648   081A AC            mul a, b ; *
0649   081B 11            mov a, b
0650   081C 27            mov b, a
0651   081D E4            pop a
0652   081E             ; --- END FACTORS
0653   081E             ; --- START TERMS
0654   081E D7            push a
0655   081F 11            mov a, b
0656   0820 FA 05 00      lea d, [bp + 5] ; $str
0657   0823 2A            mov b, [d]
0658   0824 38 00 00      mov c, 0
0659   0827 74            mov d, b
0660   0828 32            mov bl, [d]
0661   0829 A7 00         mov bh, 0
0662   082B 38 00 00      mov c, 0
0663   082E             ; --- START TERMS
0664   082E D7            push a
0665   082F 11            mov a, b
0666   0830 FD 2E 30 00   mov32 cb, $00000030
0666   0834 00 00 
0667   0836 60            sub a, b
0668   0837 27            mov b, a
0669   0838 E4            pop a
0670   0839             ; --- END TERMS
0671   0839 56            add b, a
0672   083A E4            pop a
0673   083B             ; --- END TERMS
0674   083B E7            pop d
0675   083C FD 43         mov [d], b
0676   083E             ; str++; 
0677   083E FA 05 00      lea d, [bp + 5] ; $str
0678   0841 2A            mov b, [d]
0679   0842 38 00 00      mov c, 0
0680   0845 FD 77         inc b
0681   0847 FA 05 00      lea d, [bp + 5] ; $str
0682   084A FD 43         mov [d], b
0683   084C FD 7D         dec b
0684   084E 0A C8 07      jmp _while9_cond
0685   0851             _while9_exit:
0686   0851             ; return sign * result; 
0687   0851 FA FD FF      lea d, [bp + -3] ; $sign
0688   0854 2A            mov b, [d]
0689   0855 38 00 00      mov c, 0
0690   0858             ; --- START FACTORS
0691   0858 D7            push a
0692   0859 11            mov a, b
0693   085A FA FF FF      lea d, [bp + -1] ; $result
0694   085D 2A            mov b, [d]
0695   085E 38 00 00      mov c, 0
0696   0861 AC            mul a, b ; *
0697   0862 11            mov a, b
0698   0863 27            mov b, a
0699   0864 E4            pop a
0700   0865             ; --- END FACTORS
0701   0865 F9            leave
0702   0866 09            ret
0703   0867             
0704   0867             rand:
0705   0867 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0706   086A             ; int  sec; 
0707   086A 52 02 00      sub sp, 2
0708   086D             
0709   086D             ; --- BEGIN INLINE ASM SEGMENT
0710   086D 19 00         mov al, 0
0711   086F 05 01         syscall sys_rtc					
0712   0871 1A            mov al, ah
0713   0872 FA FF FF      lea d, [bp + -1] ; $sec
0714   0875 1E            mov al, [d]
0715   0876 22 00         mov ah, 0
0716   0878             ; --- END INLINE ASM SEGMENT
0717   0878             
0718   0878             ; return sec; 
0719   0878 FA FF FF      lea d, [bp + -1] ; $sec
0720   087B 2A            mov b, [d]
0721   087C 38 00 00      mov c, 0
0722   087F F9            leave
0723   0880 09            ret
0724   0881             
0725   0881             alloc:
0726   0881 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0727   0884             ; heap_top = heap_top + bytes; 
0728   0884 3B CA 21      mov d, _heap_top ; $heap_top
0729   0887 DA            push d
0730   0888 3B CA 21      mov d, _heap_top ; $heap_top
0731   088B 2A            mov b, [d]
0732   088C 38 00 00      mov c, 0
0733   088F             ; --- START TERMS
0734   088F D7            push a
0735   0890 11            mov a, b
0736   0891 FA 05 00      lea d, [bp + 5] ; $bytes
0737   0894 2A            mov b, [d]
0738   0895 38 00 00      mov c, 0
0739   0898 56            add b, a
0740   0899 E4            pop a
0741   089A             ; --- END TERMS
0742   089A E7            pop d
0743   089B FD 43         mov [d], b
0744   089D             ; return heap_top - bytes; 
0745   089D 3B CA 21      mov d, _heap_top ; $heap_top
0746   08A0 2A            mov b, [d]
0747   08A1 38 00 00      mov c, 0
0748   08A4             ; --- START TERMS
0749   08A4 D7            push a
0750   08A5 11            mov a, b
0751   08A6 FA 05 00      lea d, [bp + 5] ; $bytes
0752   08A9 2A            mov b, [d]
0753   08AA 38 00 00      mov c, 0
0754   08AD 60            sub a, b
0755   08AE 27            mov b, a
0756   08AF E4            pop a
0757   08B0             ; --- END TERMS
0758   08B0 F9            leave
0759   08B1 09            ret
0760   08B2             
0761   08B2             free:
0762   08B2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0763   08B5             ; return heap_top = heap_top - bytes; 
0764   08B5 3B CA 21      mov d, _heap_top ; $heap_top
0765   08B8 DA            push d
0766   08B9 3B CA 21      mov d, _heap_top ; $heap_top
0767   08BC 2A            mov b, [d]
0768   08BD 38 00 00      mov c, 0
0769   08C0             ; --- START TERMS
0770   08C0 D7            push a
0771   08C1 11            mov a, b
0772   08C2 FA 05 00      lea d, [bp + 5] ; $bytes
0773   08C5 2A            mov b, [d]
0774   08C6 38 00 00      mov c, 0
0775   08C9 60            sub a, b
0776   08CA 27            mov b, a
0777   08CB E4            pop a
0778   08CC             ; --- END TERMS
0779   08CC E7            pop d
0780   08CD FD 43         mov [d], b
0781   08CF F9            leave
0782   08D0 09            ret
0783   08D1             
0784   08D1             fopen:
0785   08D1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0786   08D4             ; FILE *fp; 
0787   08D4 52 02 00      sub sp, 2
0788   08D7             ; static int max_handle = 0; 
0789   08D7 52 02 00      sub sp, 2
0790   08DA             ; fp = alloc(sizeof(FILE)); 
0791   08DA FA FF FF      lea d, [bp + -1] ; $fp
0792   08DD DA            push d
0793   08DE             ; --- START FUNCTION CALL
0794   08DE FD 2E 04 01   mov32 cb, 260
0794   08E2 00 00 
0795   08E4 FD AB         swp b
0796   08E6 D8            push b
0797   08E7 07 81 08      call alloc
0798   08EA 51 02 00      add sp, 2
0799   08ED             ; --- END FUNCTION CALL
0800   08ED E7            pop d
0801   08EE FD 43         mov [d], b
0802   08F0             ; strcpy(fp->filename, filename); 
0803   08F0             ; --- START FUNCTION CALL
0804   08F0 FA 05 00      lea d, [bp + 5] ; $filename
0805   08F3 2A            mov b, [d]
0806   08F4 38 00 00      mov c, 0
0807   08F7 FD AB         swp b
0808   08F9 D8            push b
0809   08FA FA FF FF      lea d, [bp + -1] ; $fp
0810   08FD FD 2A         mov d, [d]
0811   08FF 58 02 00      add d, 2
0812   0902 2D            mov b, d
0813   0903 38 00 00      mov c, 0
0814   0906 FD AB         swp b
0815   0908 D8            push b
0816   0909 07 3E 04      call strcpy
0817   090C 51 04 00      add sp, 4
0818   090F             ; --- END FUNCTION CALL
0819   090F             ; fp->handle = max_handle; 
0820   090F FA FF FF      lea d, [bp + -1] ; $fp
0821   0912 FD 2A         mov d, [d]
0822   0914 58 00 00      add d, 0
0823   0917 DA            push d
0824   0918 3B 7E 21      mov d, st_fopen_max_handle ; static max_handle
0825   091B 2A            mov b, [d]
0826   091C 38 00 00      mov c, 0
0827   091F E7            pop d
0828   0920 FD 43         mov [d], b
0829   0922             ; fp->mode = mode; 
0830   0922 FA FF FF      lea d, [bp + -1] ; $fp
0831   0925 FD 2A         mov d, [d]
0832   0927 58 02 01      add d, 258
0833   092A DA            push d
0834   092B FA 07 00      lea d, [bp + 7] ; $mode
0835   092E 32            mov bl, [d]
0836   092F A7 00         mov bh, 0
0837   0931 38 00 00      mov c, 0
0838   0934 E7            pop d
0839   0935 FD 3E         mov [d], bl
0840   0937             ; fp->loc = 0; 
0841   0937 FA FF FF      lea d, [bp + -1] ; $fp
0842   093A FD 2A         mov d, [d]
0843   093C 58 03 01      add d, 259
0844   093F DA            push d
0845   0940 FD 2E 00 00   mov32 cb, $00000000
0845   0944 00 00 
0846   0946 E7            pop d
0847   0947 FD 3E         mov [d], bl
0848   0949             ; max_handle++; 
0849   0949 3B 7E 21      mov d, st_fopen_max_handle ; static max_handle
0850   094C 2A            mov b, [d]
0851   094D 38 00 00      mov c, 0
0852   0950 11            mov a, b
0853   0951 FD 77         inc b
0854   0953 3B 7E 21      mov d, st_fopen_max_handle ; static max_handle
0855   0956 FD 43         mov [d], b
0856   0958 27            mov b, a
0857   0959 F9            leave
0858   095A 09            ret
0859   095B             
0860   095B             fclose:
0861   095B F8 00 00      enter 0 ; (push bp; mov bp, sp)
0862   095E             ; free(sizeof(FILE)); 
0863   095E             ; --- START FUNCTION CALL
0864   095E FD 2E 04 01   mov32 cb, 260
0864   0962 00 00 
0865   0964 FD AB         swp b
0866   0966 D8            push b
0867   0967 07 B2 08      call free
0868   096A 51 02 00      add sp, 2
0869   096D             ; --- END FUNCTION CALL
0870   096D F9            leave
0871   096E 09            ret
0872   096F             
0873   096F             printf:
0874   096F F8 00 00      enter 0 ; (push bp; mov bp, sp)
0875   0972             ; char *p, *format_p; 
0876   0972 52 02 00      sub sp, 2
0877   0975 52 02 00      sub sp, 2
0878   0978             ; format_p = format; 
0879   0978 FA FD FF      lea d, [bp + -3] ; $format_p
0880   097B DA            push d
0881   097C FA 05 00      lea d, [bp + 5] ; $format
0882   097F 2A            mov b, [d]
0883   0980 38 00 00      mov c, 0
0884   0983 E7            pop d
0885   0984 FD 43         mov [d], b
0886   0986             ; p = &format + 2; 
0887   0986 FA FF FF      lea d, [bp + -1] ; $p
0888   0989 DA            push d
0889   098A FA 05 00      lea d, [bp + 5] ; $format
0890   098D 2D            mov b, d
0891   098E             ; --- START TERMS
0892   098E D7            push a
0893   098F 11            mov a, b
0894   0990 FD 2E 02 00   mov32 cb, $00000002
0894   0994 00 00 
0895   0996 56            add b, a
0896   0997 E4            pop a
0897   0998             ; --- END TERMS
0898   0998 E7            pop d
0899   0999 FD 43         mov [d], b
0900   099B             ; for(;;){ 
0901   099B             _for10_init:
0902   099B             _for10_cond:
0903   099B             _for10_block:
0904   099B             ; if(!*format_p) break; 
0905   099B             _if11_cond:
0906   099B FA FD FF      lea d, [bp + -3] ; $format_p
0907   099E 2A            mov b, [d]
0908   099F 38 00 00      mov c, 0
0909   09A2 74            mov d, b
0910   09A3 32            mov bl, [d]
0911   09A4 A7 00         mov bh, 0
0912   09A6 38 00 00      mov c, 0
0913   09A9 C0 00 00      cmp b, 0
0914   09AC FD 71         seq ; !
0915   09AE C0 00 00      cmp b, 0
0916   09B1 C6 BA 09      je _if11_else
0917   09B4             _if11_TRUE:
0918   09B4             ; break; 
0919   09B4 0A 4B 0C      jmp _for10_exit ; for break
0920   09B7 0A 48 0C      jmp _if11_exit
0921   09BA             _if11_else:
0922   09BA             ; if(*format_p == '%'){ 
0923   09BA             _if12_cond:
0924   09BA FA FD FF      lea d, [bp + -3] ; $format_p
0925   09BD 2A            mov b, [d]
0926   09BE 38 00 00      mov c, 0
0927   09C1 74            mov d, b
0928   09C2 32            mov bl, [d]
0929   09C3 A7 00         mov bh, 0
0930   09C5 38 00 00      mov c, 0
0931   09C8             ; --- START RELATIONAL
0932   09C8 D7            push a
0933   09C9 11            mov a, b
0934   09CA FD 2E 25 00   mov32 cb, $00000025
0934   09CE 00 00 
0935   09D0 B0            cmp a, b
0936   09D1 FD 71         seq ; ==
0937   09D3 E4            pop a
0938   09D4             ; --- END RELATIONAL
0939   09D4 C0 00 00      cmp b, 0
0940   09D7 C6 23 0C      je _if12_else
0941   09DA             _if12_TRUE:
0942   09DA             ; format_p++; 
0943   09DA FA FD FF      lea d, [bp + -3] ; $format_p
0944   09DD 2A            mov b, [d]
0945   09DE 38 00 00      mov c, 0
0946   09E1 FD 77         inc b
0947   09E3 FA FD FF      lea d, [bp + -3] ; $format_p
0948   09E6 FD 43         mov [d], b
0949   09E8 FD 7D         dec b
0950   09EA             ; switch(*format_p){ 
0951   09EA             _switch13_expr:
0952   09EA FA FD FF      lea d, [bp + -3] ; $format_p
0953   09ED 2A            mov b, [d]
0954   09EE 38 00 00      mov c, 0
0955   09F1 74            mov d, b
0956   09F2 32            mov bl, [d]
0957   09F3 A7 00         mov bh, 0
0958   09F5 38 00 00      mov c, 0
0959   09F8             _switch13_comparisons:
0960   09F8 C1 6C         cmp bl, $6c
0961   09FA C6 26 0A      je _switch13_case0
0962   09FD C1 4C         cmp bl, $4c
0963   09FF C6 26 0A      je _switch13_case1
0964   0A02 C1 64         cmp bl, $64
0965   0A04 C6 36 0B      je _switch13_case2
0966   0A07 C1 69         cmp bl, $69
0967   0A09 C6 36 0B      je _switch13_case3
0968   0A0C C1 75         cmp bl, $75
0969   0A0E C6 66 0B      je _switch13_case4
0970   0A11 C1 78         cmp bl, $78
0971   0A13 C6 96 0B      je _switch13_case5
0972   0A16 C1 63         cmp bl, $63
0973   0A18 C6 BA 0B      je _switch13_case6
0974   0A1B C1 73         cmp bl, $73
0975   0A1D C6 DF 0B      je _switch13_case7
0976   0A20 0A 04 0C      jmp _switch13_default
0977   0A23 0A 10 0C      jmp _switch13_exit
0978   0A26             _switch13_case0:
0979   0A26             _switch13_case1:
0980   0A26             ; format_p++; 
0981   0A26 FA FD FF      lea d, [bp + -3] ; $format_p
0982   0A29 2A            mov b, [d]
0983   0A2A 38 00 00      mov c, 0
0984   0A2D FD 77         inc b
0985   0A2F FA FD FF      lea d, [bp + -3] ; $format_p
0986   0A32 FD 43         mov [d], b
0987   0A34 FD 7D         dec b
0988   0A36             ; if(*format_p == 'd' || *format_p == 'i') 
0989   0A36             _if14_cond:
0990   0A36 FA FD FF      lea d, [bp + -3] ; $format_p
0991   0A39 2A            mov b, [d]
0992   0A3A 38 00 00      mov c, 0
0993   0A3D 74            mov d, b
0994   0A3E 32            mov bl, [d]
0995   0A3F A7 00         mov bh, 0
0996   0A41 38 00 00      mov c, 0
0997   0A44             ; --- START RELATIONAL
0998   0A44 D7            push a
0999   0A45 11            mov a, b
1000   0A46 FD 2E 64 00   mov32 cb, $00000064
1000   0A4A 00 00 
1001   0A4C B0            cmp a, b
1002   0A4D FD 71         seq ; ==
1003   0A4F E4            pop a
1004   0A50             ; --- END RELATIONAL
1005   0A50             ; --- START LOGICAL OR
1006   0A50 D7            push a
1007   0A51 11            mov a, b
1008   0A52 FA FD FF      lea d, [bp + -3] ; $format_p
1009   0A55 2A            mov b, [d]
1010   0A56 38 00 00      mov c, 0
1011   0A59 74            mov d, b
1012   0A5A 32            mov bl, [d]
1013   0A5B A7 00         mov bh, 0
1014   0A5D 38 00 00      mov c, 0
1015   0A60             ; --- START RELATIONAL
1016   0A60 D7            push a
1017   0A61 11            mov a, b
1018   0A62 FD 2E 69 00   mov32 cb, $00000069
1018   0A66 00 00 
1019   0A68 B0            cmp a, b
1020   0A69 FD 71         seq ; ==
1021   0A6B E4            pop a
1022   0A6C             ; --- END RELATIONAL
1023   0A6C FD A8         sor a, b ; ||
1024   0A6E E4            pop a
1025   0A6F             ; --- END LOGICAL OR
1026   0A6F C0 00 00      cmp b, 0
1027   0A72 C6 93 0A      je _if14_else
1028   0A75             _if14_TRUE:
1029   0A75             ; print_signed_long(*(long *)p); 
1030   0A75             ; --- START FUNCTION CALL
1031   0A75 FA FF FF      lea d, [bp + -1] ; $p
1032   0A78 2A            mov b, [d]
1033   0A79 38 00 00      mov c, 0
1034   0A7C 74            mov d, b
1035   0A7D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1036   0A80 FD 39         mov c, b ; And place it into C
1037   0A82 2A            mov b, [d] ; Lower Word in B
1038   0A83 12            mov a, c
1039   0A84 FD AA         swp a
1040   0A86 D7            push a
1041   0A87 FD AB         swp b
1042   0A89 D8            push b
1043   0A8A 07 1D 16      call print_signed_long
1044   0A8D 51 04 00      add sp, 4
1045   0A90             ; --- END FUNCTION CALL
1046   0A90 0A 1B 0B      jmp _if14_exit
1047   0A93             _if14_else:
1048   0A93             ; if(*format_p == 'u') 
1049   0A93             _if15_cond:
1050   0A93 FA FD FF      lea d, [bp + -3] ; $format_p
1051   0A96 2A            mov b, [d]
1052   0A97 38 00 00      mov c, 0
1053   0A9A 74            mov d, b
1054   0A9B 32            mov bl, [d]
1055   0A9C A7 00         mov bh, 0
1056   0A9E 38 00 00      mov c, 0
1057   0AA1             ; --- START RELATIONAL
1058   0AA1 D7            push a
1059   0AA2 11            mov a, b
1060   0AA3 FD 2E 75 00   mov32 cb, $00000075
1060   0AA7 00 00 
1061   0AA9 B0            cmp a, b
1062   0AAA FD 71         seq ; ==
1063   0AAC E4            pop a
1064   0AAD             ; --- END RELATIONAL
1065   0AAD C0 00 00      cmp b, 0
1066   0AB0 C6 D1 0A      je _if15_else
1067   0AB3             _if15_TRUE:
1068   0AB3             ; print_unsigned_long(*(unsigned long *)p); 
1069   0AB3             ; --- START FUNCTION CALL
1070   0AB3 FA FF FF      lea d, [bp + -1] ; $p
1071   0AB6 2A            mov b, [d]
1072   0AB7 38 00 00      mov c, 0
1073   0ABA 74            mov d, b
1074   0ABB 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1075   0ABE FD 39         mov c, b ; And place it into C
1076   0AC0 2A            mov b, [d] ; Lower Word in B
1077   0AC1 12            mov a, c
1078   0AC2 FD AA         swp a
1079   0AC4 D7            push a
1080   0AC5 FD AB         swp b
1081   0AC7 D8            push b
1082   0AC8 07 8C 17      call print_unsigned_long
1083   0ACB 51 04 00      add sp, 4
1084   0ACE             ; --- END FUNCTION CALL
1085   0ACE 0A 1B 0B      jmp _if15_exit
1086   0AD1             _if15_else:
1087   0AD1             ; if(*format_p == 'x') 
1088   0AD1             _if16_cond:
1089   0AD1 FA FD FF      lea d, [bp + -3] ; $format_p
1090   0AD4 2A            mov b, [d]
1091   0AD5 38 00 00      mov c, 0
1092   0AD8 74            mov d, b
1093   0AD9 32            mov bl, [d]
1094   0ADA A7 00         mov bh, 0
1095   0ADC 38 00 00      mov c, 0
1096   0ADF             ; --- START RELATIONAL
1097   0ADF D7            push a
1098   0AE0 11            mov a, b
1099   0AE1 FD 2E 78 00   mov32 cb, $00000078
1099   0AE5 00 00 
1100   0AE7 B0            cmp a, b
1101   0AE8 FD 71         seq ; ==
1102   0AEA E4            pop a
1103   0AEB             ; --- END RELATIONAL
1104   0AEB C0 00 00      cmp b, 0
1105   0AEE C6 0F 0B      je _if16_else
1106   0AF1             _if16_TRUE:
1107   0AF1             ; printx32(*(long int *)p); 
1108   0AF1             ; --- START FUNCTION CALL
1109   0AF1 FA FF FF      lea d, [bp + -1] ; $p
1110   0AF4 2A            mov b, [d]
1111   0AF5 38 00 00      mov c, 0
1112   0AF8 74            mov d, b
1113   0AF9 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1114   0AFC FD 39         mov c, b ; And place it into C
1115   0AFE 2A            mov b, [d] ; Lower Word in B
1116   0AFF 12            mov a, c
1117   0B00 FD AA         swp a
1118   0B02 D7            push a
1119   0B03 FD AB         swp b
1120   0B05 D8            push b
1121   0B06 07 F0 12      call printx32
1122   0B09 51 04 00      add sp, 4
1123   0B0C             ; --- END FUNCTION CALL
1124   0B0C 0A 1B 0B      jmp _if16_exit
1125   0B0F             _if16_else:
1126   0B0F             ; err("Unexpected format in printf."); 
1127   0B0F             ; --- START FUNCTION CALL
1128   0B0F 26 86 21      mov b, _s1 ; "Unexpected format in printf."
1129   0B12 FD AB         swp b
1130   0B14 D8            push b
1131   0B15 07 DB 12      call err
1132   0B18 51 02 00      add sp, 2
1133   0B1B             ; --- END FUNCTION CALL
1134   0B1B             _if16_exit:
1135   0B1B             _if15_exit:
1136   0B1B             _if14_exit:
1137   0B1B             ; p = p + 4; 
1138   0B1B FA FF FF      lea d, [bp + -1] ; $p
1139   0B1E DA            push d
1140   0B1F FA FF FF      lea d, [bp + -1] ; $p
1141   0B22 2A            mov b, [d]
1142   0B23 38 00 00      mov c, 0
1143   0B26             ; --- START TERMS
1144   0B26 D7            push a
1145   0B27 11            mov a, b
1146   0B28 FD 2E 04 00   mov32 cb, $00000004
1146   0B2C 00 00 
1147   0B2E 56            add b, a
1148   0B2F E4            pop a
1149   0B30             ; --- END TERMS
1150   0B30 E7            pop d
1151   0B31 FD 43         mov [d], b
1152   0B33             ; break; 
1153   0B33 0A 10 0C      jmp _switch13_exit ; case break
1154   0B36             _switch13_case2:
1155   0B36             _switch13_case3:
1156   0B36             ; print_signed(*(int*)p); 
1157   0B36             ; --- START FUNCTION CALL
1158   0B36 FA FF FF      lea d, [bp + -1] ; $p
1159   0B39 2A            mov b, [d]
1160   0B3A 38 00 00      mov c, 0
1161   0B3D 74            mov d, b
1162   0B3E 2A            mov b, [d]
1163   0B3F 38 00 00      mov c, 0
1164   0B42 FD AB         swp b
1165   0B44 D8            push b
1166   0B45 07 E4 14      call print_signed
1167   0B48 51 02 00      add sp, 2
1168   0B4B             ; --- END FUNCTION CALL
1169   0B4B             ; p = p + 2; 
1170   0B4B FA FF FF      lea d, [bp + -1] ; $p
1171   0B4E DA            push d
1172   0B4F FA FF FF      lea d, [bp + -1] ; $p
1173   0B52 2A            mov b, [d]
1174   0B53 38 00 00      mov c, 0
1175   0B56             ; --- START TERMS
1176   0B56 D7            push a
1177   0B57 11            mov a, b
1178   0B58 FD 2E 02 00   mov32 cb, $00000002
1178   0B5C 00 00 
1179   0B5E 56            add b, a
1180   0B5F E4            pop a
1181   0B60             ; --- END TERMS
1182   0B60 E7            pop d
1183   0B61 FD 43         mov [d], b
1184   0B63             ; break; 
1185   0B63 0A 10 0C      jmp _switch13_exit ; case break
1186   0B66             _switch13_case4:
1187   0B66             ; print_unsigned(*(unsigned int*)p); 
1188   0B66             ; --- START FUNCTION CALL
1189   0B66 FA FF FF      lea d, [bp + -1] ; $p
1190   0B69 2A            mov b, [d]
1191   0B6A 38 00 00      mov c, 0
1192   0B6D 74            mov d, b
1193   0B6E 2A            mov b, [d]
1194   0B6F 38 00 00      mov c, 0
1195   0B72 FD AB         swp b
1196   0B74 D8            push b
1197   0B75 07 00 1A      call print_unsigned
1198   0B78 51 02 00      add sp, 2
1199   0B7B             ; --- END FUNCTION CALL
1200   0B7B             ; p = p + 2; 
1201   0B7B FA FF FF      lea d, [bp + -1] ; $p
1202   0B7E DA            push d
1203   0B7F FA FF FF      lea d, [bp + -1] ; $p
1204   0B82 2A            mov b, [d]
1205   0B83 38 00 00      mov c, 0
1206   0B86             ; --- START TERMS
1207   0B86 D7            push a
1208   0B87 11            mov a, b
1209   0B88 FD 2E 02 00   mov32 cb, $00000002
1209   0B8C 00 00 
1210   0B8E 56            add b, a
1211   0B8F E4            pop a
1212   0B90             ; --- END TERMS
1213   0B90 E7            pop d
1214   0B91 FD 43         mov [d], b
1215   0B93             ; break; 
1216   0B93 0A 10 0C      jmp _switch13_exit ; case break
1217   0B96             _switch13_case5:
1218   0B96             
1219   0B96             ; --- BEGIN INLINE ASM SEGMENT
1220   0B96 FA FF FF      lea d, [bp + -1] ; $p
1221   0B99 FD 2A         mov d, [d]
1222   0B9B 2A            mov b, [d]
1223   0B9C 07 79 20      call print_u16x
1224   0B9F             ; --- END INLINE ASM SEGMENT
1225   0B9F             
1226   0B9F             ; p = p + 2; 
1227   0B9F FA FF FF      lea d, [bp + -1] ; $p
1228   0BA2 DA            push d
1229   0BA3 FA FF FF      lea d, [bp + -1] ; $p
1230   0BA6 2A            mov b, [d]
1231   0BA7 38 00 00      mov c, 0
1232   0BAA             ; --- START TERMS
1233   0BAA D7            push a
1234   0BAB 11            mov a, b
1235   0BAC FD 2E 02 00   mov32 cb, $00000002
1235   0BB0 00 00 
1236   0BB2 56            add b, a
1237   0BB3 E4            pop a
1238   0BB4             ; --- END TERMS
1239   0BB4 E7            pop d
1240   0BB5 FD 43         mov [d], b
1241   0BB7             ; break; 
1242   0BB7 0A 10 0C      jmp _switch13_exit ; case break
1243   0BBA             _switch13_case6:
1244   0BBA             
1245   0BBA             ; --- BEGIN INLINE ASM SEGMENT
1246   0BBA FA FF FF      lea d, [bp + -1] ; $p
1247   0BBD FD 2A         mov d, [d]
1248   0BBF 1E            mov al, [d]
1249   0BC0 23            mov ah, al
1250   0BC1 07 D7 1E      call _putchar
1251   0BC4             ; --- END INLINE ASM SEGMENT
1252   0BC4             
1253   0BC4             ; p = p + 1; 
1254   0BC4 FA FF FF      lea d, [bp + -1] ; $p
1255   0BC7 DA            push d
1256   0BC8 FA FF FF      lea d, [bp + -1] ; $p
1257   0BCB 2A            mov b, [d]
1258   0BCC 38 00 00      mov c, 0
1259   0BCF             ; --- START TERMS
1260   0BCF D7            push a
1261   0BD0 11            mov a, b
1262   0BD1 FD 2E 01 00   mov32 cb, $00000001
1262   0BD5 00 00 
1263   0BD7 56            add b, a
1264   0BD8 E4            pop a
1265   0BD9             ; --- END TERMS
1266   0BD9 E7            pop d
1267   0BDA FD 43         mov [d], b
1268   0BDC             ; break; 
1269   0BDC 0A 10 0C      jmp _switch13_exit ; case break
1270   0BDF             _switch13_case7:
1271   0BDF             
1272   0BDF             ; --- BEGIN INLINE ASM SEGMENT
1273   0BDF FA FF FF      lea d, [bp + -1] ; $p
1274   0BE2 FD 2A         mov d, [d]
1275   0BE4 FD 2A         mov d, [d]
1276   0BE6 07 21 20      call _puts
1277   0BE9             ; --- END INLINE ASM SEGMENT
1278   0BE9             
1279   0BE9             ; p = p + 2; 
1280   0BE9 FA FF FF      lea d, [bp + -1] ; $p
1281   0BEC DA            push d
1282   0BED FA FF FF      lea d, [bp + -1] ; $p
1283   0BF0 2A            mov b, [d]
1284   0BF1 38 00 00      mov c, 0
1285   0BF4             ; --- START TERMS
1286   0BF4 D7            push a
1287   0BF5 11            mov a, b
1288   0BF6 FD 2E 02 00   mov32 cb, $00000002
1288   0BFA 00 00 
1289   0BFC 56            add b, a
1290   0BFD E4            pop a
1291   0BFE             ; --- END TERMS
1292   0BFE E7            pop d
1293   0BFF FD 43         mov [d], b
1294   0C01             ; break; 
1295   0C01 0A 10 0C      jmp _switch13_exit ; case break
1296   0C04             _switch13_default:
1297   0C04             ; print("Error: Unknown argument type.\n"); 
1298   0C04             ; --- START FUNCTION CALL
1299   0C04 26 A3 21      mov b, _s2 ; "Error: Unknown argument type.\n"
1300   0C07 FD AB         swp b
1301   0C09 D8            push b
1302   0C0A 07 16 1D      call print
1303   0C0D 51 02 00      add sp, 2
1304   0C10             ; --- END FUNCTION CALL
1305   0C10             _switch13_exit:
1306   0C10             ; format_p++; 
1307   0C10 FA FD FF      lea d, [bp + -3] ; $format_p
1308   0C13 2A            mov b, [d]
1309   0C14 38 00 00      mov c, 0
1310   0C17 FD 77         inc b
1311   0C19 FA FD FF      lea d, [bp + -3] ; $format_p
1312   0C1C FD 43         mov [d], b
1313   0C1E FD 7D         dec b
1314   0C20 0A 48 0C      jmp _if12_exit
1315   0C23             _if12_else:
1316   0C23             ; putchar(*format_p); 
1317   0C23             ; --- START FUNCTION CALL
1318   0C23 FA FD FF      lea d, [bp + -3] ; $format_p
1319   0C26 2A            mov b, [d]
1320   0C27 38 00 00      mov c, 0
1321   0C2A 74            mov d, b
1322   0C2B 32            mov bl, [d]
1323   0C2C A7 00         mov bh, 0
1324   0C2E 38 00 00      mov c, 0
1325   0C31 DD            push bl
1326   0C32 07 C8 1C      call putchar
1327   0C35 51 01 00      add sp, 1
1328   0C38             ; --- END FUNCTION CALL
1329   0C38             ; format_p++; 
1330   0C38 FA FD FF      lea d, [bp + -3] ; $format_p
1331   0C3B 2A            mov b, [d]
1332   0C3C 38 00 00      mov c, 0
1333   0C3F FD 77         inc b
1334   0C41 FA FD FF      lea d, [bp + -3] ; $format_p
1335   0C44 FD 43         mov [d], b
1336   0C46 FD 7D         dec b
1337   0C48             _if12_exit:
1338   0C48             _if11_exit:
1339   0C48             _for10_update:
1340   0C48 0A 9B 09      jmp _for10_cond
1341   0C4B             _for10_exit:
1342   0C4B F9            leave
1343   0C4C 09            ret
1344   0C4D             
1345   0C4D             scanf:
1346   0C4D F8 00 00      enter 0 ; (push bp; mov bp, sp)
1347   0C50             ; char *p, *format_p; 
1348   0C50 52 02 00      sub sp, 2
1349   0C53 52 02 00      sub sp, 2
1350   0C56             ; char c; 
1351   0C56 52 01 00      sub sp, 1
1352   0C59             ; int i; 
1353   0C59 52 02 00      sub sp, 2
1354   0C5C             ; char input_string[  512                    ]; 
1355   0C5C 52 00 02      sub sp, 512
1356   0C5F             ; format_p = format; 
1357   0C5F FA FD FF      lea d, [bp + -3] ; $format_p
1358   0C62 DA            push d
1359   0C63 FA 05 00      lea d, [bp + 5] ; $format
1360   0C66 2A            mov b, [d]
1361   0C67 38 00 00      mov c, 0
1362   0C6A E7            pop d
1363   0C6B FD 43         mov [d], b
1364   0C6D             ; p = &format + 2; 
1365   0C6D FA FF FF      lea d, [bp + -1] ; $p
1366   0C70 DA            push d
1367   0C71 FA 05 00      lea d, [bp + 5] ; $format
1368   0C74 2D            mov b, d
1369   0C75             ; --- START TERMS
1370   0C75 D7            push a
1371   0C76 11            mov a, b
1372   0C77 FD 2E 02 00   mov32 cb, $00000002
1372   0C7B 00 00 
1373   0C7D 56            add b, a
1374   0C7E E4            pop a
1375   0C7F             ; --- END TERMS
1376   0C7F E7            pop d
1377   0C80 FD 43         mov [d], b
1378   0C82             ; for(;;){ 
1379   0C82             _for17_init:
1380   0C82             _for17_cond:
1381   0C82             _for17_block:
1382   0C82             ; if(!*format_p) break; 
1383   0C82             _if18_cond:
1384   0C82 FA FD FF      lea d, [bp + -3] ; $format_p
1385   0C85 2A            mov b, [d]
1386   0C86 38 00 00      mov c, 0
1387   0C89 74            mov d, b
1388   0C8A 32            mov bl, [d]
1389   0C8B A7 00         mov bh, 0
1390   0C8D 38 00 00      mov c, 0
1391   0C90 C0 00 00      cmp b, 0
1392   0C93 FD 71         seq ; !
1393   0C95 C0 00 00      cmp b, 0
1394   0C98 C6 A1 0C      je _if18_else
1395   0C9B             _if18_TRUE:
1396   0C9B             ; break; 
1397   0C9B 0A 29 0F      jmp _for17_exit ; for break
1398   0C9E 0A 26 0F      jmp _if18_exit
1399   0CA1             _if18_else:
1400   0CA1             ; if(*format_p == '%'){ 
1401   0CA1             _if19_cond:
1402   0CA1 FA FD FF      lea d, [bp + -3] ; $format_p
1403   0CA4 2A            mov b, [d]
1404   0CA5 38 00 00      mov c, 0
1405   0CA8 74            mov d, b
1406   0CA9 32            mov bl, [d]
1407   0CAA A7 00         mov bh, 0
1408   0CAC 38 00 00      mov c, 0
1409   0CAF             ; --- START RELATIONAL
1410   0CAF D7            push a
1411   0CB0 11            mov a, b
1412   0CB1 FD 2E 25 00   mov32 cb, $00000025
1412   0CB5 00 00 
1413   0CB7 B0            cmp a, b
1414   0CB8 FD 71         seq ; ==
1415   0CBA E4            pop a
1416   0CBB             ; --- END RELATIONAL
1417   0CBB C0 00 00      cmp b, 0
1418   0CBE C6 01 0F      je _if19_else
1419   0CC1             _if19_TRUE:
1420   0CC1             ; format_p++; 
1421   0CC1 FA FD FF      lea d, [bp + -3] ; $format_p
1422   0CC4 2A            mov b, [d]
1423   0CC5 38 00 00      mov c, 0
1424   0CC8 FD 77         inc b
1425   0CCA FA FD FF      lea d, [bp + -3] ; $format_p
1426   0CCD FD 43         mov [d], b
1427   0CCF FD 7D         dec b
1428   0CD1             ; switch(*format_p){ 
1429   0CD1             _switch20_expr:
1430   0CD1 FA FD FF      lea d, [bp + -3] ; $format_p
1431   0CD4 2A            mov b, [d]
1432   0CD5 38 00 00      mov c, 0
1433   0CD8 74            mov d, b
1434   0CD9 32            mov bl, [d]
1435   0CDA A7 00         mov bh, 0
1436   0CDC 38 00 00      mov c, 0
1437   0CDF             _switch20_comparisons:
1438   0CDF C1 6C         cmp bl, $6c
1439   0CE1 C6 0D 0D      je _switch20_case0
1440   0CE4 C1 4C         cmp bl, $4c
1441   0CE6 C6 0D 0D      je _switch20_case1
1442   0CE9 C1 64         cmp bl, $64
1443   0CEB C6 CC 0D      je _switch20_case2
1444   0CEE C1 69         cmp bl, $69
1445   0CF0 C6 CC 0D      je _switch20_case3
1446   0CF3 C1 75         cmp bl, $75
1447   0CF5 C6 05 0E      je _switch20_case4
1448   0CF8 C1 78         cmp bl, $78
1449   0CFA C6 3E 0E      je _switch20_case5
1450   0CFD C1 63         cmp bl, $63
1451   0CFF C6 59 0E      je _switch20_case6
1452   0D02 C1 73         cmp bl, $73
1453   0D04 C6 9B 0E      je _switch20_case7
1454   0D07 0A E2 0E      jmp _switch20_default
1455   0D0A 0A EE 0E      jmp _switch20_exit
1456   0D0D             _switch20_case0:
1457   0D0D             _switch20_case1:
1458   0D0D             ; format_p++; 
1459   0D0D FA FD FF      lea d, [bp + -3] ; $format_p
1460   0D10 2A            mov b, [d]
1461   0D11 38 00 00      mov c, 0
1462   0D14 FD 77         inc b
1463   0D16 FA FD FF      lea d, [bp + -3] ; $format_p
1464   0D19 FD 43         mov [d], b
1465   0D1B FD 7D         dec b
1466   0D1D             ; if(*format_p == 'd' || *format_p == 'i'); 
1467   0D1D             _if21_cond:
1468   0D1D FA FD FF      lea d, [bp + -3] ; $format_p
1469   0D20 2A            mov b, [d]
1470   0D21 38 00 00      mov c, 0
1471   0D24 74            mov d, b
1472   0D25 32            mov bl, [d]
1473   0D26 A7 00         mov bh, 0
1474   0D28 38 00 00      mov c, 0
1475   0D2B             ; --- START RELATIONAL
1476   0D2B D7            push a
1477   0D2C 11            mov a, b
1478   0D2D FD 2E 64 00   mov32 cb, $00000064
1478   0D31 00 00 
1479   0D33 B0            cmp a, b
1480   0D34 FD 71         seq ; ==
1481   0D36 E4            pop a
1482   0D37             ; --- END RELATIONAL
1483   0D37             ; --- START LOGICAL OR
1484   0D37 D7            push a
1485   0D38 11            mov a, b
1486   0D39 FA FD FF      lea d, [bp + -3] ; $format_p
1487   0D3C 2A            mov b, [d]
1488   0D3D 38 00 00      mov c, 0
1489   0D40 74            mov d, b
1490   0D41 32            mov bl, [d]
1491   0D42 A7 00         mov bh, 0
1492   0D44 38 00 00      mov c, 0
1493   0D47             ; --- START RELATIONAL
1494   0D47 D7            push a
1495   0D48 11            mov a, b
1496   0D49 FD 2E 69 00   mov32 cb, $00000069
1496   0D4D 00 00 
1497   0D4F B0            cmp a, b
1498   0D50 FD 71         seq ; ==
1499   0D52 E4            pop a
1500   0D53             ; --- END RELATIONAL
1501   0D53 FD A8         sor a, b ; ||
1502   0D55 E4            pop a
1503   0D56             ; --- END LOGICAL OR
1504   0D56 C0 00 00      cmp b, 0
1505   0D59 C6 5F 0D      je _if21_else
1506   0D5C             _if21_TRUE:
1507   0D5C             ; ; 
1508   0D5C 0A B1 0D      jmp _if21_exit
1509   0D5F             _if21_else:
1510   0D5F             ; if(*format_p == 'u'); 
1511   0D5F             _if22_cond:
1512   0D5F FA FD FF      lea d, [bp + -3] ; $format_p
1513   0D62 2A            mov b, [d]
1514   0D63 38 00 00      mov c, 0
1515   0D66 74            mov d, b
1516   0D67 32            mov bl, [d]
1517   0D68 A7 00         mov bh, 0
1518   0D6A 38 00 00      mov c, 0
1519   0D6D             ; --- START RELATIONAL
1520   0D6D D7            push a
1521   0D6E 11            mov a, b
1522   0D6F FD 2E 75 00   mov32 cb, $00000075
1522   0D73 00 00 
1523   0D75 B0            cmp a, b
1524   0D76 FD 71         seq ; ==
1525   0D78 E4            pop a
1526   0D79             ; --- END RELATIONAL
1527   0D79 C0 00 00      cmp b, 0
1528   0D7C C6 82 0D      je _if22_else
1529   0D7F             _if22_TRUE:
1530   0D7F             ; ; 
1531   0D7F 0A B1 0D      jmp _if22_exit
1532   0D82             _if22_else:
1533   0D82             ; if(*format_p == 'x'); 
1534   0D82             _if23_cond:
1535   0D82 FA FD FF      lea d, [bp + -3] ; $format_p
1536   0D85 2A            mov b, [d]
1537   0D86 38 00 00      mov c, 0
1538   0D89 74            mov d, b
1539   0D8A 32            mov bl, [d]
1540   0D8B A7 00         mov bh, 0
1541   0D8D 38 00 00      mov c, 0
1542   0D90             ; --- START RELATIONAL
1543   0D90 D7            push a
1544   0D91 11            mov a, b
1545   0D92 FD 2E 78 00   mov32 cb, $00000078
1545   0D96 00 00 
1546   0D98 B0            cmp a, b
1547   0D99 FD 71         seq ; ==
1548   0D9B E4            pop a
1549   0D9C             ; --- END RELATIONAL
1550   0D9C C0 00 00      cmp b, 0
1551   0D9F C6 A5 0D      je _if23_else
1552   0DA2             _if23_TRUE:
1553   0DA2             ; ; 
1554   0DA2 0A B1 0D      jmp _if23_exit
1555   0DA5             _if23_else:
1556   0DA5             ; err("Unexpected format in printf."); 
1557   0DA5             ; --- START FUNCTION CALL
1558   0DA5 26 86 21      mov b, _s1 ; "Unexpected format in printf."
1559   0DA8 FD AB         swp b
1560   0DAA D8            push b
1561   0DAB 07 DB 12      call err
1562   0DAE 51 02 00      add sp, 2
1563   0DB1             ; --- END FUNCTION CALL
1564   0DB1             _if23_exit:
1565   0DB1             _if22_exit:
1566   0DB1             _if21_exit:
1567   0DB1             ; p = p + 4; 
1568   0DB1 FA FF FF      lea d, [bp + -1] ; $p
1569   0DB4 DA            push d
1570   0DB5 FA FF FF      lea d, [bp + -1] ; $p
1571   0DB8 2A            mov b, [d]
1572   0DB9 38 00 00      mov c, 0
1573   0DBC             ; --- START TERMS
1574   0DBC D7            push a
1575   0DBD 11            mov a, b
1576   0DBE FD 2E 04 00   mov32 cb, $00000004
1576   0DC2 00 00 
1577   0DC4 56            add b, a
1578   0DC5 E4            pop a
1579   0DC6             ; --- END TERMS
1580   0DC6 E7            pop d
1581   0DC7 FD 43         mov [d], b
1582   0DC9             ; break; 
1583   0DC9 0A EE 0E      jmp _switch20_exit ; case break
1584   0DCC             _switch20_case2:
1585   0DCC             _switch20_case3:
1586   0DCC             ; i = scann(); 
1587   0DCC FA FA FF      lea d, [bp + -6] ; $i
1588   0DCF DA            push d
1589   0DD0             ; --- START FUNCTION CALL
1590   0DD0 07 EE 1C      call scann
1591   0DD3 E7            pop d
1592   0DD4 FD 43         mov [d], b
1593   0DD6             ; **(int **)p = i; 
1594   0DD6 FA FF FF      lea d, [bp + -1] ; $p
1595   0DD9 2A            mov b, [d]
1596   0DDA 38 00 00      mov c, 0
1597   0DDD 74            mov d, b
1598   0DDE 2A            mov b, [d]
1599   0DDF D8            push b
1600   0DE0 FA FA FF      lea d, [bp + -6] ; $i
1601   0DE3 2A            mov b, [d]
1602   0DE4 38 00 00      mov c, 0
1603   0DE7 E7            pop d
1604   0DE8 FD 43         mov [d], b
1605   0DEA             ; p = p + 2; 
1606   0DEA FA FF FF      lea d, [bp + -1] ; $p
1607   0DED DA            push d
1608   0DEE FA FF FF      lea d, [bp + -1] ; $p
1609   0DF1 2A            mov b, [d]
1610   0DF2 38 00 00      mov c, 0
1611   0DF5             ; --- START TERMS
1612   0DF5 D7            push a
1613   0DF6 11            mov a, b
1614   0DF7 FD 2E 02 00   mov32 cb, $00000002
1614   0DFB 00 00 
1615   0DFD 56            add b, a
1616   0DFE E4            pop a
1617   0DFF             ; --- END TERMS
1618   0DFF E7            pop d
1619   0E00 FD 43         mov [d], b
1620   0E02             ; break; 
1621   0E02 0A EE 0E      jmp _switch20_exit ; case break
1622   0E05             _switch20_case4:
1623   0E05             ; i = scann(); 
1624   0E05 FA FA FF      lea d, [bp + -6] ; $i
1625   0E08 DA            push d
1626   0E09             ; --- START FUNCTION CALL
1627   0E09 07 EE 1C      call scann
1628   0E0C E7            pop d
1629   0E0D FD 43         mov [d], b
1630   0E0F             ; **(int **)p = i; 
1631   0E0F FA FF FF      lea d, [bp + -1] ; $p
1632   0E12 2A            mov b, [d]
1633   0E13 38 00 00      mov c, 0
1634   0E16 74            mov d, b
1635   0E17 2A            mov b, [d]
1636   0E18 D8            push b
1637   0E19 FA FA FF      lea d, [bp + -6] ; $i
1638   0E1C 2A            mov b, [d]
1639   0E1D 38 00 00      mov c, 0
1640   0E20 E7            pop d
1641   0E21 FD 43         mov [d], b
1642   0E23             ; p = p + 2; 
1643   0E23 FA FF FF      lea d, [bp + -1] ; $p
1644   0E26 DA            push d
1645   0E27 FA FF FF      lea d, [bp + -1] ; $p
1646   0E2A 2A            mov b, [d]
1647   0E2B 38 00 00      mov c, 0
1648   0E2E             ; --- START TERMS
1649   0E2E D7            push a
1650   0E2F 11            mov a, b
1651   0E30 FD 2E 02 00   mov32 cb, $00000002
1651   0E34 00 00 
1652   0E36 56            add b, a
1653   0E37 E4            pop a
1654   0E38             ; --- END TERMS
1655   0E38 E7            pop d
1656   0E39 FD 43         mov [d], b
1657   0E3B             ; break; 
1658   0E3B 0A EE 0E      jmp _switch20_exit ; case break
1659   0E3E             _switch20_case5:
1660   0E3E             ; p = p + 2; 
1661   0E3E FA FF FF      lea d, [bp + -1] ; $p
1662   0E41 DA            push d
1663   0E42 FA FF FF      lea d, [bp + -1] ; $p
1664   0E45 2A            mov b, [d]
1665   0E46 38 00 00      mov c, 0
1666   0E49             ; --- START TERMS
1667   0E49 D7            push a
1668   0E4A 11            mov a, b
1669   0E4B FD 2E 02 00   mov32 cb, $00000002
1669   0E4F 00 00 
1670   0E51 56            add b, a
1671   0E52 E4            pop a
1672   0E53             ; --- END TERMS
1673   0E53 E7            pop d
1674   0E54 FD 43         mov [d], b
1675   0E56             ; break; 
1676   0E56 0A EE 0E      jmp _switch20_exit ; case break
1677   0E59             _switch20_case6:
1678   0E59             ; c = getchar(); 
1679   0E59 FA FC FF      lea d, [bp + -4] ; $c
1680   0E5C DA            push d
1681   0E5D             ; --- START FUNCTION CALL
1682   0E5D 07 D5 1C      call getchar
1683   0E60 E7            pop d
1684   0E61 FD 3E         mov [d], bl
1685   0E63             ; **(char **)p = *(char *)c; 
1686   0E63 FA FF FF      lea d, [bp + -1] ; $p
1687   0E66 2A            mov b, [d]
1688   0E67 38 00 00      mov c, 0
1689   0E6A 74            mov d, b
1690   0E6B 2A            mov b, [d]
1691   0E6C D8            push b
1692   0E6D FA FC FF      lea d, [bp + -4] ; $c
1693   0E70 32            mov bl, [d]
1694   0E71 A7 00         mov bh, 0
1695   0E73 38 00 00      mov c, 0
1696   0E76 74            mov d, b
1697   0E77 32            mov bl, [d]
1698   0E78 A7 00         mov bh, 0
1699   0E7A 38 00 00      mov c, 0
1700   0E7D E7            pop d
1701   0E7E FD 43         mov [d], b
1702   0E80             ; p = p + 1; 
1703   0E80 FA FF FF      lea d, [bp + -1] ; $p
1704   0E83 DA            push d
1705   0E84 FA FF FF      lea d, [bp + -1] ; $p
1706   0E87 2A            mov b, [d]
1707   0E88 38 00 00      mov c, 0
1708   0E8B             ; --- START TERMS
1709   0E8B D7            push a
1710   0E8C 11            mov a, b
1711   0E8D FD 2E 01 00   mov32 cb, $00000001
1711   0E91 00 00 
1712   0E93 56            add b, a
1713   0E94 E4            pop a
1714   0E95             ; --- END TERMS
1715   0E95 E7            pop d
1716   0E96 FD 43         mov [d], b
1717   0E98             ; break; 
1718   0E98 0A EE 0E      jmp _switch20_exit ; case break
1719   0E9B             _switch20_case7:
1720   0E9B             ; gets(input_string); 
1721   0E9B             ; --- START FUNCTION CALL
1722   0E9B FA FA FD      lea d, [bp + -518] ; $input_string
1723   0E9E 2D            mov b, d
1724   0E9F 38 00 00      mov c, 0
1725   0EA2 FD AB         swp b
1726   0EA4 D8            push b
1727   0EA5 07 C7 14      call gets
1728   0EA8 51 02 00      add sp, 2
1729   0EAB             ; --- END FUNCTION CALL
1730   0EAB             ; strcpy(*(char **)p, input_string); 
1731   0EAB             ; --- START FUNCTION CALL
1732   0EAB FA FA FD      lea d, [bp + -518] ; $input_string
1733   0EAE 2D            mov b, d
1734   0EAF 38 00 00      mov c, 0
1735   0EB2 FD AB         swp b
1736   0EB4 D8            push b
1737   0EB5 FA FF FF      lea d, [bp + -1] ; $p
1738   0EB8 2A            mov b, [d]
1739   0EB9 38 00 00      mov c, 0
1740   0EBC 74            mov d, b
1741   0EBD 2A            mov b, [d]
1742   0EBE FD AB         swp b
1743   0EC0 D8            push b
1744   0EC1 07 3E 04      call strcpy
1745   0EC4 51 04 00      add sp, 4
1746   0EC7             ; --- END FUNCTION CALL
1747   0EC7             ; p = p + 2; 
1748   0EC7 FA FF FF      lea d, [bp + -1] ; $p
1749   0ECA DA            push d
1750   0ECB FA FF FF      lea d, [bp + -1] ; $p
1751   0ECE 2A            mov b, [d]
1752   0ECF 38 00 00      mov c, 0
1753   0ED2             ; --- START TERMS
1754   0ED2 D7            push a
1755   0ED3 11            mov a, b
1756   0ED4 FD 2E 02 00   mov32 cb, $00000002
1756   0ED8 00 00 
1757   0EDA 56            add b, a
1758   0EDB E4            pop a
1759   0EDC             ; --- END TERMS
1760   0EDC E7            pop d
1761   0EDD FD 43         mov [d], b
1762   0EDF             ; break; 
1763   0EDF 0A EE 0E      jmp _switch20_exit ; case break
1764   0EE2             _switch20_default:
1765   0EE2             ; print("Error: Unknown argument type.\n"); 
1766   0EE2             ; --- START FUNCTION CALL
1767   0EE2 26 A3 21      mov b, _s2 ; "Error: Unknown argument type.\n"
1768   0EE5 FD AB         swp b
1769   0EE7 D8            push b
1770   0EE8 07 16 1D      call print
1771   0EEB 51 02 00      add sp, 2
1772   0EEE             ; --- END FUNCTION CALL
1773   0EEE             _switch20_exit:
1774   0EEE             ; format_p++; 
1775   0EEE FA FD FF      lea d, [bp + -3] ; $format_p
1776   0EF1 2A            mov b, [d]
1777   0EF2 38 00 00      mov c, 0
1778   0EF5 FD 77         inc b
1779   0EF7 FA FD FF      lea d, [bp + -3] ; $format_p
1780   0EFA FD 43         mov [d], b
1781   0EFC FD 7D         dec b
1782   0EFE 0A 26 0F      jmp _if19_exit
1783   0F01             _if19_else:
1784   0F01             ; putchar(*format_p); 
1785   0F01             ; --- START FUNCTION CALL
1786   0F01 FA FD FF      lea d, [bp + -3] ; $format_p
1787   0F04 2A            mov b, [d]
1788   0F05 38 00 00      mov c, 0
1789   0F08 74            mov d, b
1790   0F09 32            mov bl, [d]
1791   0F0A A7 00         mov bh, 0
1792   0F0C 38 00 00      mov c, 0
1793   0F0F DD            push bl
1794   0F10 07 C8 1C      call putchar
1795   0F13 51 01 00      add sp, 1
1796   0F16             ; --- END FUNCTION CALL
1797   0F16             ; format_p++; 
1798   0F16 FA FD FF      lea d, [bp + -3] ; $format_p
1799   0F19 2A            mov b, [d]
1800   0F1A 38 00 00      mov c, 0
1801   0F1D FD 77         inc b
1802   0F1F FA FD FF      lea d, [bp + -3] ; $format_p
1803   0F22 FD 43         mov [d], b
1804   0F24 FD 7D         dec b
1805   0F26             _if19_exit:
1806   0F26             _if18_exit:
1807   0F26             _for17_update:
1808   0F26 0A 82 0C      jmp _for17_cond
1809   0F29             _for17_exit:
1810   0F29 F9            leave
1811   0F2A 09            ret
1812   0F2B             
1813   0F2B             sprintf:
1814   0F2B F8 00 00      enter 0 ; (push bp; mov bp, sp)
1815   0F2E             ; char *p, *format_p; 
1816   0F2E 52 02 00      sub sp, 2
1817   0F31 52 02 00      sub sp, 2
1818   0F34             ; char *sp; 
1819   0F34 52 02 00      sub sp, 2
1820   0F37             ; sp = dest; 
1821   0F37 FA FB FF      lea d, [bp + -5] ; $sp
1822   0F3A DA            push d
1823   0F3B FA 05 00      lea d, [bp + 5] ; $dest
1824   0F3E 2A            mov b, [d]
1825   0F3F 38 00 00      mov c, 0
1826   0F42 E7            pop d
1827   0F43 FD 43         mov [d], b
1828   0F45             ; format_p = format; 
1829   0F45 FA FD FF      lea d, [bp + -3] ; $format_p
1830   0F48 DA            push d
1831   0F49 FA 07 00      lea d, [bp + 7] ; $format
1832   0F4C 2A            mov b, [d]
1833   0F4D 38 00 00      mov c, 0
1834   0F50 E7            pop d
1835   0F51 FD 43         mov [d], b
1836   0F53             ; p = &format + 2; 
1837   0F53 FA FF FF      lea d, [bp + -1] ; $p
1838   0F56 DA            push d
1839   0F57 FA 07 00      lea d, [bp + 7] ; $format
1840   0F5A 2D            mov b, d
1841   0F5B             ; --- START TERMS
1842   0F5B D7            push a
1843   0F5C 11            mov a, b
1844   0F5D FD 2E 02 00   mov32 cb, $00000002
1844   0F61 00 00 
1845   0F63 56            add b, a
1846   0F64 E4            pop a
1847   0F65             ; --- END TERMS
1848   0F65 E7            pop d
1849   0F66 FD 43         mov [d], b
1850   0F68             ; for(;;){ 
1851   0F68             _for24_init:
1852   0F68             _for24_cond:
1853   0F68             _for24_block:
1854   0F68             ; if(!*format_p) break; 
1855   0F68             _if25_cond:
1856   0F68 FA FD FF      lea d, [bp + -3] ; $format_p
1857   0F6B 2A            mov b, [d]
1858   0F6C 38 00 00      mov c, 0
1859   0F6F 74            mov d, b
1860   0F70 32            mov bl, [d]
1861   0F71 A7 00         mov bh, 0
1862   0F73 38 00 00      mov c, 0
1863   0F76 C0 00 00      cmp b, 0
1864   0F79 FD 71         seq ; !
1865   0F7B C0 00 00      cmp b, 0
1866   0F7E C6 87 0F      je _if25_else
1867   0F81             _if25_TRUE:
1868   0F81             ; break; 
1869   0F81 0A B5 12      jmp _for24_exit ; for break
1870   0F84 0A B2 12      jmp _if25_exit
1871   0F87             _if25_else:
1872   0F87             ; if(*format_p == '%'){ 
1873   0F87             _if26_cond:
1874   0F87 FA FD FF      lea d, [bp + -3] ; $format_p
1875   0F8A 2A            mov b, [d]
1876   0F8B 38 00 00      mov c, 0
1877   0F8E 74            mov d, b
1878   0F8F 32            mov bl, [d]
1879   0F90 A7 00         mov bh, 0
1880   0F92 38 00 00      mov c, 0
1881   0F95             ; --- START RELATIONAL
1882   0F95 D7            push a
1883   0F96 11            mov a, b
1884   0F97 FD 2E 25 00   mov32 cb, $00000025
1884   0F9B 00 00 
1885   0F9D B0            cmp a, b
1886   0F9E FD 71         seq ; ==
1887   0FA0 E4            pop a
1888   0FA1             ; --- END RELATIONAL
1889   0FA1 C0 00 00      cmp b, 0
1890   0FA4 C6 87 12      je _if26_else
1891   0FA7             _if26_TRUE:
1892   0FA7             ; format_p++; 
1893   0FA7 FA FD FF      lea d, [bp + -3] ; $format_p
1894   0FAA 2A            mov b, [d]
1895   0FAB 38 00 00      mov c, 0
1896   0FAE FD 77         inc b
1897   0FB0 FA FD FF      lea d, [bp + -3] ; $format_p
1898   0FB3 FD 43         mov [d], b
1899   0FB5 FD 7D         dec b
1900   0FB7             ; switch(*format_p){ 
1901   0FB7             _switch27_expr:
1902   0FB7 FA FD FF      lea d, [bp + -3] ; $format_p
1903   0FBA 2A            mov b, [d]
1904   0FBB 38 00 00      mov c, 0
1905   0FBE 74            mov d, b
1906   0FBF 32            mov bl, [d]
1907   0FC0 A7 00         mov bh, 0
1908   0FC2 38 00 00      mov c, 0
1909   0FC5             _switch27_comparisons:
1910   0FC5 C1 6C         cmp bl, $6c
1911   0FC7 C6 F3 0F      je _switch27_case0
1912   0FCA C1 4C         cmp bl, $4c
1913   0FCC C6 F3 0F      je _switch27_case1
1914   0FCF C1 64         cmp bl, $64
1915   0FD1 C6 03 11      je _switch27_case2
1916   0FD4 C1 69         cmp bl, $69
1917   0FD6 C6 03 11      je _switch27_case3
1918   0FD9 C1 75         cmp bl, $75
1919   0FDB C6 4F 11      je _switch27_case4
1920   0FDE C1 78         cmp bl, $78
1921   0FE0 C6 9B 11      je _switch27_case5
1922   0FE3 C1 63         cmp bl, $63
1923   0FE5 C6 BF 11      je _switch27_case6
1924   0FE8 C1 73         cmp bl, $73
1925   0FEA C6 FC 11      je _switch27_case7
1926   0FED 0A 68 12      jmp _switch27_default
1927   0FF0 0A 74 12      jmp _switch27_exit
1928   0FF3             _switch27_case0:
1929   0FF3             _switch27_case1:
1930   0FF3             ; format_p++; 
1931   0FF3 FA FD FF      lea d, [bp + -3] ; $format_p
1932   0FF6 2A            mov b, [d]
1933   0FF7 38 00 00      mov c, 0
1934   0FFA FD 77         inc b
1935   0FFC FA FD FF      lea d, [bp + -3] ; $format_p
1936   0FFF FD 43         mov [d], b
1937   1001 FD 7D         dec b
1938   1003             ; if(*format_p == 'd' || *format_p == 'i') 
1939   1003             _if28_cond:
1940   1003 FA FD FF      lea d, [bp + -3] ; $format_p
1941   1006 2A            mov b, [d]
1942   1007 38 00 00      mov c, 0
1943   100A 74            mov d, b
1944   100B 32            mov bl, [d]
1945   100C A7 00         mov bh, 0
1946   100E 38 00 00      mov c, 0
1947   1011             ; --- START RELATIONAL
1948   1011 D7            push a
1949   1012 11            mov a, b
1950   1013 FD 2E 64 00   mov32 cb, $00000064
1950   1017 00 00 
1951   1019 B0            cmp a, b
1952   101A FD 71         seq ; ==
1953   101C E4            pop a
1954   101D             ; --- END RELATIONAL
1955   101D             ; --- START LOGICAL OR
1956   101D D7            push a
1957   101E 11            mov a, b
1958   101F FA FD FF      lea d, [bp + -3] ; $format_p
1959   1022 2A            mov b, [d]
1960   1023 38 00 00      mov c, 0
1961   1026 74            mov d, b
1962   1027 32            mov bl, [d]
1963   1028 A7 00         mov bh, 0
1964   102A 38 00 00      mov c, 0
1965   102D             ; --- START RELATIONAL
1966   102D D7            push a
1967   102E 11            mov a, b
1968   102F FD 2E 69 00   mov32 cb, $00000069
1968   1033 00 00 
1969   1035 B0            cmp a, b
1970   1036 FD 71         seq ; ==
1971   1038 E4            pop a
1972   1039             ; --- END RELATIONAL
1973   1039 FD A8         sor a, b ; ||
1974   103B E4            pop a
1975   103C             ; --- END LOGICAL OR
1976   103C C0 00 00      cmp b, 0
1977   103F C6 60 10      je _if28_else
1978   1042             _if28_TRUE:
1979   1042             ; print_signed_long(*(long *)p); 
1980   1042             ; --- START FUNCTION CALL
1981   1042 FA FF FF      lea d, [bp + -1] ; $p
1982   1045 2A            mov b, [d]
1983   1046 38 00 00      mov c, 0
1984   1049 74            mov d, b
1985   104A 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1986   104D FD 39         mov c, b ; And place it into C
1987   104F 2A            mov b, [d] ; Lower Word in B
1988   1050 12            mov a, c
1989   1051 FD AA         swp a
1990   1053 D7            push a
1991   1054 FD AB         swp b
1992   1056 D8            push b
1993   1057 07 1D 16      call print_signed_long
1994   105A 51 04 00      add sp, 4
1995   105D             ; --- END FUNCTION CALL
1996   105D 0A E8 10      jmp _if28_exit
1997   1060             _if28_else:
1998   1060             ; if(*format_p == 'u') 
1999   1060             _if29_cond:
2000   1060 FA FD FF      lea d, [bp + -3] ; $format_p
2001   1063 2A            mov b, [d]
2002   1064 38 00 00      mov c, 0
2003   1067 74            mov d, b
2004   1068 32            mov bl, [d]
2005   1069 A7 00         mov bh, 0
2006   106B 38 00 00      mov c, 0
2007   106E             ; --- START RELATIONAL
2008   106E D7            push a
2009   106F 11            mov a, b
2010   1070 FD 2E 75 00   mov32 cb, $00000075
2010   1074 00 00 
2011   1076 B0            cmp a, b
2012   1077 FD 71         seq ; ==
2013   1079 E4            pop a
2014   107A             ; --- END RELATIONAL
2015   107A C0 00 00      cmp b, 0
2016   107D C6 9E 10      je _if29_else
2017   1080             _if29_TRUE:
2018   1080             ; print_unsigned_long(*(unsigned long *)p); 
2019   1080             ; --- START FUNCTION CALL
2020   1080 FA FF FF      lea d, [bp + -1] ; $p
2021   1083 2A            mov b, [d]
2022   1084 38 00 00      mov c, 0
2023   1087 74            mov d, b
2024   1088 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2025   108B FD 39         mov c, b ; And place it into C
2026   108D 2A            mov b, [d] ; Lower Word in B
2027   108E 12            mov a, c
2028   108F FD AA         swp a
2029   1091 D7            push a
2030   1092 FD AB         swp b
2031   1094 D8            push b
2032   1095 07 8C 17      call print_unsigned_long
2033   1098 51 04 00      add sp, 4
2034   109B             ; --- END FUNCTION CALL
2035   109B 0A E8 10      jmp _if29_exit
2036   109E             _if29_else:
2037   109E             ; if(*format_p == 'x') 
2038   109E             _if30_cond:
2039   109E FA FD FF      lea d, [bp + -3] ; $format_p
2040   10A1 2A            mov b, [d]
2041   10A2 38 00 00      mov c, 0
2042   10A5 74            mov d, b
2043   10A6 32            mov bl, [d]
2044   10A7 A7 00         mov bh, 0
2045   10A9 38 00 00      mov c, 0
2046   10AC             ; --- START RELATIONAL
2047   10AC D7            push a
2048   10AD 11            mov a, b
2049   10AE FD 2E 78 00   mov32 cb, $00000078
2049   10B2 00 00 
2050   10B4 B0            cmp a, b
2051   10B5 FD 71         seq ; ==
2052   10B7 E4            pop a
2053   10B8             ; --- END RELATIONAL
2054   10B8 C0 00 00      cmp b, 0
2055   10BB C6 DC 10      je _if30_else
2056   10BE             _if30_TRUE:
2057   10BE             ; printx32(*(long int *)p); 
2058   10BE             ; --- START FUNCTION CALL
2059   10BE FA FF FF      lea d, [bp + -1] ; $p
2060   10C1 2A            mov b, [d]
2061   10C2 38 00 00      mov c, 0
2062   10C5 74            mov d, b
2063   10C6 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2064   10C9 FD 39         mov c, b ; And place it into C
2065   10CB 2A            mov b, [d] ; Lower Word in B
2066   10CC 12            mov a, c
2067   10CD FD AA         swp a
2068   10CF D7            push a
2069   10D0 FD AB         swp b
2070   10D2 D8            push b
2071   10D3 07 F0 12      call printx32
2072   10D6 51 04 00      add sp, 4
2073   10D9             ; --- END FUNCTION CALL
2074   10D9 0A E8 10      jmp _if30_exit
2075   10DC             _if30_else:
2076   10DC             ; err("Unexpected format in printf."); 
2077   10DC             ; --- START FUNCTION CALL
2078   10DC 26 86 21      mov b, _s1 ; "Unexpected format in printf."
2079   10DF FD AB         swp b
2080   10E1 D8            push b
2081   10E2 07 DB 12      call err
2082   10E5 51 02 00      add sp, 2
2083   10E8             ; --- END FUNCTION CALL
2084   10E8             _if30_exit:
2085   10E8             _if29_exit:
2086   10E8             _if28_exit:
2087   10E8             ; p = p + 4; 
2088   10E8 FA FF FF      lea d, [bp + -1] ; $p
2089   10EB DA            push d
2090   10EC FA FF FF      lea d, [bp + -1] ; $p
2091   10EF 2A            mov b, [d]
2092   10F0 38 00 00      mov c, 0
2093   10F3             ; --- START TERMS
2094   10F3 D7            push a
2095   10F4 11            mov a, b
2096   10F5 FD 2E 04 00   mov32 cb, $00000004
2096   10F9 00 00 
2097   10FB 56            add b, a
2098   10FC E4            pop a
2099   10FD             ; --- END TERMS
2100   10FD E7            pop d
2101   10FE FD 43         mov [d], b
2102   1100             ; break; 
2103   1100 0A 74 12      jmp _switch27_exit ; case break
2104   1103             _switch27_case2:
2105   1103             _switch27_case3:
2106   1103             ; sp = sp + sprint_signed(sp, *(int*)p); 
2107   1103 FA FB FF      lea d, [bp + -5] ; $sp
2108   1106 DA            push d
2109   1107 FA FB FF      lea d, [bp + -5] ; $sp
2110   110A 2A            mov b, [d]
2111   110B 38 00 00      mov c, 0
2112   110E             ; --- START TERMS
2113   110E D7            push a
2114   110F 11            mov a, b
2115   1110             ; --- START FUNCTION CALL
2116   1110 FA FF FF      lea d, [bp + -1] ; $p
2117   1113 2A            mov b, [d]
2118   1114 38 00 00      mov c, 0
2119   1117 74            mov d, b
2120   1118 2A            mov b, [d]
2121   1119 38 00 00      mov c, 0
2122   111C FD AB         swp b
2123   111E D8            push b
2124   111F FA FB FF      lea d, [bp + -5] ; $sp
2125   1122 2A            mov b, [d]
2126   1123 38 00 00      mov c, 0
2127   1126 FD AB         swp b
2128   1128 D8            push b
2129   1129 07 00 1B      call sprint_signed
2130   112C 51 04 00      add sp, 4
2131   112F             ; --- END FUNCTION CALL
2132   112F 56            add b, a
2133   1130 E4            pop a
2134   1131             ; --- END TERMS
2135   1131 E7            pop d
2136   1132 FD 43         mov [d], b
2137   1134             ; p = p + 2; 
2138   1134 FA FF FF      lea d, [bp + -1] ; $p
2139   1137 DA            push d
2140   1138 FA FF FF      lea d, [bp + -1] ; $p
2141   113B 2A            mov b, [d]
2142   113C 38 00 00      mov c, 0
2143   113F             ; --- START TERMS
2144   113F D7            push a
2145   1140 11            mov a, b
2146   1141 FD 2E 02 00   mov32 cb, $00000002
2146   1145 00 00 
2147   1147 56            add b, a
2148   1148 E4            pop a
2149   1149             ; --- END TERMS
2150   1149 E7            pop d
2151   114A FD 43         mov [d], b
2152   114C             ; break; 
2153   114C 0A 74 12      jmp _switch27_exit ; case break
2154   114F             _switch27_case4:
2155   114F             ; sp = sp + sprint_unsigned(sp, *(unsigned int*)p); 
2156   114F FA FB FF      lea d, [bp + -5] ; $sp
2157   1152 DA            push d
2158   1153 FA FB FF      lea d, [bp + -5] ; $sp
2159   1156 2A            mov b, [d]
2160   1157 38 00 00      mov c, 0
2161   115A             ; --- START TERMS
2162   115A D7            push a
2163   115B 11            mov a, b
2164   115C             ; --- START FUNCTION CALL
2165   115C FA FF FF      lea d, [bp + -1] ; $p
2166   115F 2A            mov b, [d]
2167   1160 38 00 00      mov c, 0
2168   1163 74            mov d, b
2169   1164 2A            mov b, [d]
2170   1165 38 00 00      mov c, 0
2171   1168 FD AB         swp b
2172   116A D8            push b
2173   116B FA FB FF      lea d, [bp + -5] ; $sp
2174   116E 2A            mov b, [d]
2175   116F 38 00 00      mov c, 0
2176   1172 FD AB         swp b
2177   1174 D8            push b
2178   1175 07 A8 18      call sprint_unsigned
2179   1178 51 04 00      add sp, 4
2180   117B             ; --- END FUNCTION CALL
2181   117B 56            add b, a
2182   117C E4            pop a
2183   117D             ; --- END TERMS
2184   117D E7            pop d
2185   117E FD 43         mov [d], b
2186   1180             ; p = p + 2; 
2187   1180 FA FF FF      lea d, [bp + -1] ; $p
2188   1183 DA            push d
2189   1184 FA FF FF      lea d, [bp + -1] ; $p
2190   1187 2A            mov b, [d]
2191   1188 38 00 00      mov c, 0
2192   118B             ; --- START TERMS
2193   118B D7            push a
2194   118C 11            mov a, b
2195   118D FD 2E 02 00   mov32 cb, $00000002
2195   1191 00 00 
2196   1193 56            add b, a
2197   1194 E4            pop a
2198   1195             ; --- END TERMS
2199   1195 E7            pop d
2200   1196 FD 43         mov [d], b
2201   1198             ; break; 
2202   1198 0A 74 12      jmp _switch27_exit ; case break
2203   119B             _switch27_case5:
2204   119B             
2205   119B             ; --- BEGIN INLINE ASM SEGMENT
2206   119B FA FF FF      lea d, [bp + -1] ; $p
2207   119E FD 2A         mov d, [d]
2208   11A0 2A            mov b, [d]
2209   11A1 07 79 20      call print_u16x
2210   11A4             ; --- END INLINE ASM SEGMENT
2211   11A4             
2212   11A4             ; p = p + 2; 
2213   11A4 FA FF FF      lea d, [bp + -1] ; $p
2214   11A7 DA            push d
2215   11A8 FA FF FF      lea d, [bp + -1] ; $p
2216   11AB 2A            mov b, [d]
2217   11AC 38 00 00      mov c, 0
2218   11AF             ; --- START TERMS
2219   11AF D7            push a
2220   11B0 11            mov a, b
2221   11B1 FD 2E 02 00   mov32 cb, $00000002
2221   11B5 00 00 
2222   11B7 56            add b, a
2223   11B8 E4            pop a
2224   11B9             ; --- END TERMS
2225   11B9 E7            pop d
2226   11BA FD 43         mov [d], b
2227   11BC             ; break; 
2228   11BC 0A 74 12      jmp _switch27_exit ; case break
2229   11BF             _switch27_case6:
2230   11BF             ; *sp++ = *(char *)p; 
2231   11BF FA FB FF      lea d, [bp + -5] ; $sp
2232   11C2 2A            mov b, [d]
2233   11C3 38 00 00      mov c, 0
2234   11C6 FD 77         inc b
2235   11C8 FA FB FF      lea d, [bp + -5] ; $sp
2236   11CB FD 43         mov [d], b
2237   11CD FD 7D         dec b
2238   11CF D8            push b
2239   11D0 FA FF FF      lea d, [bp + -1] ; $p
2240   11D3 2A            mov b, [d]
2241   11D4 38 00 00      mov c, 0
2242   11D7 74            mov d, b
2243   11D8 32            mov bl, [d]
2244   11D9 A7 00         mov bh, 0
2245   11DB 38 00 00      mov c, 0
2246   11DE E7            pop d
2247   11DF FD 3E         mov [d], bl
2248   11E1             ; p = p + 1; 
2249   11E1 FA FF FF      lea d, [bp + -1] ; $p
2250   11E4 DA            push d
2251   11E5 FA FF FF      lea d, [bp + -1] ; $p
2252   11E8 2A            mov b, [d]
2253   11E9 38 00 00      mov c, 0
2254   11EC             ; --- START TERMS
2255   11EC D7            push a
2256   11ED 11            mov a, b
2257   11EE FD 2E 01 00   mov32 cb, $00000001
2257   11F2 00 00 
2258   11F4 56            add b, a
2259   11F5 E4            pop a
2260   11F6             ; --- END TERMS
2261   11F6 E7            pop d
2262   11F7 FD 43         mov [d], b
2263   11F9             ; break; 
2264   11F9 0A 74 12      jmp _switch27_exit ; case break
2265   11FC             _switch27_case7:
2266   11FC             ; int len = strlen(*(char **)p); 
2267   11FC 52 02 00      sub sp, 2
2268   11FF             ; --- START LOCAL VAR INITIALIZATION
2269   11FF FA F9 FF      lea d, [bp + -7] ; $len
2270   1202 DA            push d
2271   1203             ; --- START FUNCTION CALL
2272   1203 FA FF FF      lea d, [bp + -1] ; $p
2273   1206 2A            mov b, [d]
2274   1207 38 00 00      mov c, 0
2275   120A 74            mov d, b
2276   120B 2A            mov b, [d]
2277   120C FD AB         swp b
2278   120E D8            push b
2279   120F 07 24 06      call strlen
2280   1212 51 02 00      add sp, 2
2281   1215             ; --- END FUNCTION CALL
2282   1215 E7            pop d
2283   1216 FD 43         mov [d], b
2284   1218             ; --- END LOCAL VAR INITIALIZATION
2285   1218             ; strcpy(sp, *(char **)p); 
2286   1218             ; --- START FUNCTION CALL
2287   1218 FA FF FF      lea d, [bp + -1] ; $p
2288   121B 2A            mov b, [d]
2289   121C 38 00 00      mov c, 0
2290   121F 74            mov d, b
2291   1220 2A            mov b, [d]
2292   1221 FD AB         swp b
2293   1223 D8            push b
2294   1224 FA FB FF      lea d, [bp + -5] ; $sp
2295   1227 2A            mov b, [d]
2296   1228 38 00 00      mov c, 0
2297   122B FD AB         swp b
2298   122D D8            push b
2299   122E 07 3E 04      call strcpy
2300   1231 51 04 00      add sp, 4
2301   1234             ; --- END FUNCTION CALL
2302   1234             ; sp = sp + len; 
2303   1234 FA FB FF      lea d, [bp + -5] ; $sp
2304   1237 DA            push d
2305   1238 FA FB FF      lea d, [bp + -5] ; $sp
2306   123B 2A            mov b, [d]
2307   123C 38 00 00      mov c, 0
2308   123F             ; --- START TERMS
2309   123F D7            push a
2310   1240 11            mov a, b
2311   1241 FA F9 FF      lea d, [bp + -7] ; $len
2312   1244 2A            mov b, [d]
2313   1245 38 00 00      mov c, 0
2314   1248 56            add b, a
2315   1249 E4            pop a
2316   124A             ; --- END TERMS
2317   124A E7            pop d
2318   124B FD 43         mov [d], b
2319   124D             ; p = p + 2; 
2320   124D FA FF FF      lea d, [bp + -1] ; $p
2321   1250 DA            push d
2322   1251 FA FF FF      lea d, [bp + -1] ; $p
2323   1254 2A            mov b, [d]
2324   1255 38 00 00      mov c, 0
2325   1258             ; --- START TERMS
2326   1258 D7            push a
2327   1259 11            mov a, b
2328   125A FD 2E 02 00   mov32 cb, $00000002
2328   125E 00 00 
2329   1260 56            add b, a
2330   1261 E4            pop a
2331   1262             ; --- END TERMS
2332   1262 E7            pop d
2333   1263 FD 43         mov [d], b
2334   1265             ; break; 
2335   1265 0A 74 12      jmp _switch27_exit ; case break
2336   1268             _switch27_default:
2337   1268             ; print("Error: Unknown argument type.\n"); 
2338   1268             ; --- START FUNCTION CALL
2339   1268 26 A3 21      mov b, _s2 ; "Error: Unknown argument type.\n"
2340   126B FD AB         swp b
2341   126D D8            push b
2342   126E 07 16 1D      call print
2343   1271 51 02 00      add sp, 2
2344   1274             ; --- END FUNCTION CALL
2345   1274             _switch27_exit:
2346   1274             ; format_p++; 
2347   1274 FA FD FF      lea d, [bp + -3] ; $format_p
2348   1277 2A            mov b, [d]
2349   1278 38 00 00      mov c, 0
2350   127B FD 77         inc b
2351   127D FA FD FF      lea d, [bp + -3] ; $format_p
2352   1280 FD 43         mov [d], b
2353   1282 FD 7D         dec b
2354   1284 0A B2 12      jmp _if26_exit
2355   1287             _if26_else:
2356   1287             ; *sp++ = *format_p++; 
2357   1287 FA FB FF      lea d, [bp + -5] ; $sp
2358   128A 2A            mov b, [d]
2359   128B 38 00 00      mov c, 0
2360   128E FD 77         inc b
2361   1290 FA FB FF      lea d, [bp + -5] ; $sp
2362   1293 FD 43         mov [d], b
2363   1295 FD 7D         dec b
2364   1297 D8            push b
2365   1298 FA FD FF      lea d, [bp + -3] ; $format_p
2366   129B 2A            mov b, [d]
2367   129C 38 00 00      mov c, 0
2368   129F FD 77         inc b
2369   12A1 FA FD FF      lea d, [bp + -3] ; $format_p
2370   12A4 FD 43         mov [d], b
2371   12A6 FD 7D         dec b
2372   12A8 74            mov d, b
2373   12A9 32            mov bl, [d]
2374   12AA A7 00         mov bh, 0
2375   12AC 38 00 00      mov c, 0
2376   12AF E7            pop d
2377   12B0 FD 3E         mov [d], bl
2378   12B2             _if26_exit:
2379   12B2             _if25_exit:
2380   12B2             _for24_update:
2381   12B2 0A 68 0F      jmp _for24_cond
2382   12B5             _for24_exit:
2383   12B5             ; *sp = '\0'; 
2384   12B5 FA FB FF      lea d, [bp + -5] ; $sp
2385   12B8 2A            mov b, [d]
2386   12B9 38 00 00      mov c, 0
2387   12BC D8            push b
2388   12BD FD 2E 00 00   mov32 cb, $00000000
2388   12C1 00 00 
2389   12C3 E7            pop d
2390   12C4 FD 3E         mov [d], bl
2391   12C6             ; return sp - dest; // return total number of chars written 
2392   12C6 FA FB FF      lea d, [bp + -5] ; $sp
2393   12C9 2A            mov b, [d]
2394   12CA 38 00 00      mov c, 0
2395   12CD             ; --- START TERMS
2396   12CD D7            push a
2397   12CE 11            mov a, b
2398   12CF FA 05 00      lea d, [bp + 5] ; $dest
2399   12D2 2A            mov b, [d]
2400   12D3 38 00 00      mov c, 0
2401   12D6 60            sub a, b
2402   12D7 27            mov b, a
2403   12D8 E4            pop a
2404   12D9             ; --- END TERMS
2405   12D9 F9            leave
2406   12DA 09            ret
2407   12DB             
2408   12DB             err:
2409   12DB F8 00 00      enter 0 ; (push bp; mov bp, sp)
2410   12DE             ; print(e); 
2411   12DE             ; --- START FUNCTION CALL
2412   12DE FA 05 00      lea d, [bp + 5] ; $e
2413   12E1 2A            mov b, [d]
2414   12E2 38 00 00      mov c, 0
2415   12E5 FD AB         swp b
2416   12E7 D8            push b
2417   12E8 07 16 1D      call print
2418   12EB 51 02 00      add sp, 2
2419   12EE             ; --- END FUNCTION CALL
2420   12EE F9            leave
2421   12EF 09            ret
2422   12F0             
2423   12F0             printx32:
2424   12F0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2425   12F3             
2426   12F3             ; --- BEGIN INLINE ASM SEGMENT
2427   12F3 FA 05 00      lea d, [bp + 5] ; $hex
2428   12F6 2B 02 00      mov b, [d+2]
2429   12F9 07 79 20      call print_u16x
2430   12FC 2A            mov b, [d]
2431   12FD 07 79 20      call print_u16x
2432   1300             ; --- END INLINE ASM SEGMENT
2433   1300             
2434   1300 F9            leave
2435   1301 09            ret
2436   1302             
2437   1302             printx16:
2438   1302 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2439   1305             
2440   1305             ; --- BEGIN INLINE ASM SEGMENT
2441   1305 FA 05 00      lea d, [bp + 5] ; $hex
2442   1308 2A            mov b, [d]
2443   1309 07 79 20      call print_u16x
2444   130C             ; --- END INLINE ASM SEGMENT
2445   130C             
2446   130C F9            leave
2447   130D 09            ret
2448   130E             
2449   130E             printx8:
2450   130E F8 00 00      enter 0 ; (push bp; mov bp, sp)
2451   1311             
2452   1311             ; --- BEGIN INLINE ASM SEGMENT
2453   1311 FA 05 00      lea d, [bp + 5] ; $hex
2454   1314 32            mov bl, [d]
2455   1315 07 BD 20      call print_u8x
2456   1318             ; --- END INLINE ASM SEGMENT
2457   1318             
2458   1318 F9            leave
2459   1319 09            ret
2460   131A             
2461   131A             hex_str_to_int:
2462   131A F8 00 00      enter 0 ; (push bp; mov bp, sp)
2463   131D             ; int value = 0; 
2464   131D 52 02 00      sub sp, 2
2465   1320             ; --- START LOCAL VAR INITIALIZATION
2466   1320 FA FF FF      lea d, [bp + -1] ; $value
2467   1323 DA            push d
2468   1324 FD 2E 00 00   mov32 cb, $00000000
2468   1328 00 00 
2469   132A E7            pop d
2470   132B FD 43         mov [d], b
2471   132D             ; --- END LOCAL VAR INITIALIZATION
2472   132D             ; int i; 
2473   132D 52 02 00      sub sp, 2
2474   1330             ; char hex_char; 
2475   1330 52 01 00      sub sp, 1
2476   1333             ; int len; 
2477   1333 52 02 00      sub sp, 2
2478   1336             ; len = strlen(hex_string); 
2479   1336 FA FA FF      lea d, [bp + -6] ; $len
2480   1339 DA            push d
2481   133A             ; --- START FUNCTION CALL
2482   133A FA 05 00      lea d, [bp + 5] ; $hex_string
2483   133D 2A            mov b, [d]
2484   133E 38 00 00      mov c, 0
2485   1341 FD AB         swp b
2486   1343 D8            push b
2487   1344 07 24 06      call strlen
2488   1347 51 02 00      add sp, 2
2489   134A             ; --- END FUNCTION CALL
2490   134A E7            pop d
2491   134B FD 43         mov [d], b
2492   134D             ; for (i = 0; i < len; i++) { 
2493   134D             _for31_init:
2494   134D FA FD FF      lea d, [bp + -3] ; $i
2495   1350 DA            push d
2496   1351 FD 2E 00 00   mov32 cb, $00000000
2496   1355 00 00 
2497   1357 E7            pop d
2498   1358 FD 43         mov [d], b
2499   135A             _for31_cond:
2500   135A FA FD FF      lea d, [bp + -3] ; $i
2501   135D 2A            mov b, [d]
2502   135E 38 00 00      mov c, 0
2503   1361             ; --- START RELATIONAL
2504   1361 D7            push a
2505   1362 11            mov a, b
2506   1363 FA FA FF      lea d, [bp + -6] ; $len
2507   1366 2A            mov b, [d]
2508   1367 38 00 00      mov c, 0
2509   136A B0            cmp a, b
2510   136B FD 73         slt ; < (signed)
2511   136D E4            pop a
2512   136E             ; --- END RELATIONAL
2513   136E C0 00 00      cmp b, 0
2514   1371 C6 BE 14      je _for31_exit
2515   1374             _for31_block:
2516   1374             ; hex_char = hex_string[i]; 
2517   1374 FA FC FF      lea d, [bp + -4] ; $hex_char
2518   1377 DA            push d
2519   1378 FA 05 00      lea d, [bp + 5] ; $hex_string
2520   137B FD 2A         mov d, [d]
2521   137D D7            push a
2522   137E DA            push d
2523   137F FA FD FF      lea d, [bp + -3] ; $i
2524   1382 2A            mov b, [d]
2525   1383 38 00 00      mov c, 0
2526   1386 E7            pop d
2527   1387 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
2528   138B E4            pop a
2529   138C 32            mov bl, [d]
2530   138D A7 00         mov bh, 0
2531   138F 38 00 00      mov c, 0
2532   1392 E7            pop d
2533   1393 FD 3E         mov [d], bl
2534   1395             ; if (hex_char >= 'a' && hex_char <= 'f')  
2535   1395             _if32_cond:
2536   1395 FA FC FF      lea d, [bp + -4] ; $hex_char
2537   1398 32            mov bl, [d]
2538   1399 A7 00         mov bh, 0
2539   139B 38 00 00      mov c, 0
2540   139E             ; --- START RELATIONAL
2541   139E D7            push a
2542   139F 11            mov a, b
2543   13A0 FD 2E 61 00   mov32 cb, $00000061
2543   13A4 00 00 
2544   13A6 B0            cmp a, b
2545   13A7 FD 80         sge ; >=
2546   13A9 E4            pop a
2547   13AA             ; --- END RELATIONAL
2548   13AA             ; --- START LOGICAL AND
2549   13AA D7            push a
2550   13AB 11            mov a, b
2551   13AC FA FC FF      lea d, [bp + -4] ; $hex_char
2552   13AF 32            mov bl, [d]
2553   13B0 A7 00         mov bh, 0
2554   13B2 38 00 00      mov c, 0
2555   13B5             ; --- START RELATIONAL
2556   13B5 D7            push a
2557   13B6 11            mov a, b
2558   13B7 FD 2E 66 00   mov32 cb, $00000066
2558   13BB 00 00 
2559   13BD B0            cmp a, b
2560   13BE FD 74         sle ; <= (signed)
2561   13C0 E4            pop a
2562   13C1             ; --- END RELATIONAL
2563   13C1 FD A7         sand a, b
2564   13C3 E4            pop a
2565   13C4             ; --- END LOGICAL AND
2566   13C4 C0 00 00      cmp b, 0
2567   13C7 C6 07 14      je _if32_else
2568   13CA             _if32_TRUE:
2569   13CA             ; value = (value * 16) + (hex_char - 'a' + 10); 
2570   13CA FA FF FF      lea d, [bp + -1] ; $value
2571   13CD DA            push d
2572   13CE FA FF FF      lea d, [bp + -1] ; $value
2573   13D1 2A            mov b, [d]
2574   13D2 38 00 00      mov c, 0
2575   13D5             ; --- START FACTORS
2576   13D5 D7            push a
2577   13D6 11            mov a, b
2578   13D7 FD 2E 10 00   mov32 cb, $00000010
2578   13DB 00 00 
2579   13DD AC            mul a, b ; *
2580   13DE 11            mov a, b
2581   13DF 27            mov b, a
2582   13E0 E4            pop a
2583   13E1             ; --- END FACTORS
2584   13E1             ; --- START TERMS
2585   13E1 D7            push a
2586   13E2 11            mov a, b
2587   13E3 FA FC FF      lea d, [bp + -4] ; $hex_char
2588   13E6 32            mov bl, [d]
2589   13E7 A7 00         mov bh, 0
2590   13E9 38 00 00      mov c, 0
2591   13EC             ; --- START TERMS
2592   13EC D7            push a
2593   13ED 11            mov a, b
2594   13EE FD 2E 61 00   mov32 cb, $00000061
2594   13F2 00 00 
2595   13F4 60            sub a, b
2596   13F5 27            mov b, a
2597   13F6 11            mov a, b
2598   13F7 FD 2E 0A 00   mov32 cb, $0000000a
2598   13FB 00 00 
2599   13FD 56            add b, a
2600   13FE E4            pop a
2601   13FF             ; --- END TERMS
2602   13FF 56            add b, a
2603   1400 E4            pop a
2604   1401             ; --- END TERMS
2605   1401 E7            pop d
2606   1402 FD 43         mov [d], b
2607   1404 0A AB 14      jmp _if32_exit
2608   1407             _if32_else:
2609   1407             ; if (hex_char >= 'A' && hex_char <= 'F')  
2610   1407             _if33_cond:
2611   1407 FA FC FF      lea d, [bp + -4] ; $hex_char
2612   140A 32            mov bl, [d]
2613   140B A7 00         mov bh, 0
2614   140D 38 00 00      mov c, 0
2615   1410             ; --- START RELATIONAL
2616   1410 D7            push a
2617   1411 11            mov a, b
2618   1412 FD 2E 41 00   mov32 cb, $00000041
2618   1416 00 00 
2619   1418 B0            cmp a, b
2620   1419 FD 80         sge ; >=
2621   141B E4            pop a
2622   141C             ; --- END RELATIONAL
2623   141C             ; --- START LOGICAL AND
2624   141C D7            push a
2625   141D 11            mov a, b
2626   141E FA FC FF      lea d, [bp + -4] ; $hex_char
2627   1421 32            mov bl, [d]
2628   1422 A7 00         mov bh, 0
2629   1424 38 00 00      mov c, 0
2630   1427             ; --- START RELATIONAL
2631   1427 D7            push a
2632   1428 11            mov a, b
2633   1429 FD 2E 46 00   mov32 cb, $00000046
2633   142D 00 00 
2634   142F B0            cmp a, b
2635   1430 FD 74         sle ; <= (signed)
2636   1432 E4            pop a
2637   1433             ; --- END RELATIONAL
2638   1433 FD A7         sand a, b
2639   1435 E4            pop a
2640   1436             ; --- END LOGICAL AND
2641   1436 C0 00 00      cmp b, 0
2642   1439 C6 79 14      je _if33_else
2643   143C             _if33_TRUE:
2644   143C             ; value = (value * 16) + (hex_char - 'A' + 10); 
2645   143C FA FF FF      lea d, [bp + -1] ; $value
2646   143F DA            push d
2647   1440 FA FF FF      lea d, [bp + -1] ; $value
2648   1443 2A            mov b, [d]
2649   1444 38 00 00      mov c, 0
2650   1447             ; --- START FACTORS
2651   1447 D7            push a
2652   1448 11            mov a, b
2653   1449 FD 2E 10 00   mov32 cb, $00000010
2653   144D 00 00 
2654   144F AC            mul a, b ; *
2655   1450 11            mov a, b
2656   1451 27            mov b, a
2657   1452 E4            pop a
2658   1453             ; --- END FACTORS
2659   1453             ; --- START TERMS
2660   1453 D7            push a
2661   1454 11            mov a, b
2662   1455 FA FC FF      lea d, [bp + -4] ; $hex_char
2663   1458 32            mov bl, [d]
2664   1459 A7 00         mov bh, 0
2665   145B 38 00 00      mov c, 0
2666   145E             ; --- START TERMS
2667   145E D7            push a
2668   145F 11            mov a, b
2669   1460 FD 2E 41 00   mov32 cb, $00000041
2669   1464 00 00 
2670   1466 60            sub a, b
2671   1467 27            mov b, a
2672   1468 11            mov a, b
2673   1469 FD 2E 0A 00   mov32 cb, $0000000a
2673   146D 00 00 
2674   146F 56            add b, a
2675   1470 E4            pop a
2676   1471             ; --- END TERMS
2677   1471 56            add b, a
2678   1472 E4            pop a
2679   1473             ; --- END TERMS
2680   1473 E7            pop d
2681   1474 FD 43         mov [d], b
2682   1476 0A AB 14      jmp _if33_exit
2683   1479             _if33_else:
2684   1479             ; value = (value * 16) + (hex_char - '0'); 
2685   1479 FA FF FF      lea d, [bp + -1] ; $value
2686   147C DA            push d
2687   147D FA FF FF      lea d, [bp + -1] ; $value
2688   1480 2A            mov b, [d]
2689   1481 38 00 00      mov c, 0
2690   1484             ; --- START FACTORS
2691   1484 D7            push a
2692   1485 11            mov a, b
2693   1486 FD 2E 10 00   mov32 cb, $00000010
2693   148A 00 00 
2694   148C AC            mul a, b ; *
2695   148D 11            mov a, b
2696   148E 27            mov b, a
2697   148F E4            pop a
2698   1490             ; --- END FACTORS
2699   1490             ; --- START TERMS
2700   1490 D7            push a
2701   1491 11            mov a, b
2702   1492 FA FC FF      lea d, [bp + -4] ; $hex_char
2703   1495 32            mov bl, [d]
2704   1496 A7 00         mov bh, 0
2705   1498 38 00 00      mov c, 0
2706   149B             ; --- START TERMS
2707   149B D7            push a
2708   149C 11            mov a, b
2709   149D FD 2E 30 00   mov32 cb, $00000030
2709   14A1 00 00 
2710   14A3 60            sub a, b
2711   14A4 27            mov b, a
2712   14A5 E4            pop a
2713   14A6             ; --- END TERMS
2714   14A6 56            add b, a
2715   14A7 E4            pop a
2716   14A8             ; --- END TERMS
2717   14A8 E7            pop d
2718   14A9 FD 43         mov [d], b
2719   14AB             _if33_exit:
2720   14AB             _if32_exit:
2721   14AB             _for31_update:
2722   14AB FA FD FF      lea d, [bp + -3] ; $i
2723   14AE 2A            mov b, [d]
2724   14AF 38 00 00      mov c, 0
2725   14B2 11            mov a, b
2726   14B3 FD 77         inc b
2727   14B5 FA FD FF      lea d, [bp + -3] ; $i
2728   14B8 FD 43         mov [d], b
2729   14BA 27            mov b, a
2730   14BB 0A 5A 13      jmp _for31_cond
2731   14BE             _for31_exit:
2732   14BE             ; return value; 
2733   14BE FA FF FF      lea d, [bp + -1] ; $value
2734   14C1 2A            mov b, [d]
2735   14C2 38 00 00      mov c, 0
2736   14C5 F9            leave
2737   14C6 09            ret
2738   14C7             
2739   14C7             gets:
2740   14C7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2741   14CA             
2742   14CA             ; --- BEGIN INLINE ASM SEGMENT
2743   14CA FA 05 00      lea d, [bp + 5] ; $s
2744   14CD 15            mov a, [d]
2745   14CE 3C            mov d, a
2746   14CF 07 DE 1E      call _gets
2747   14D2             ; --- END INLINE ASM SEGMENT
2748   14D2             
2749   14D2             ; return strlen(s); 
2750   14D2             ; --- START FUNCTION CALL
2751   14D2 FA 05 00      lea d, [bp + 5] ; $s
2752   14D5 2A            mov b, [d]
2753   14D6 38 00 00      mov c, 0
2754   14D9 FD AB         swp b
2755   14DB D8            push b
2756   14DC 07 24 06      call strlen
2757   14DF 51 02 00      add sp, 2
2758   14E2             ; --- END FUNCTION CALL
2759   14E2 F9            leave
2760   14E3 09            ret
2761   14E4             
2762   14E4             print_signed:
2763   14E4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2764   14E7             ; char digits[5]; 
2765   14E7 52 05 00      sub sp, 5
2766   14EA             ; int i = 0; 
2767   14EA 52 02 00      sub sp, 2
2768   14ED             ; --- START LOCAL VAR INITIALIZATION
2769   14ED FA FA FF      lea d, [bp + -6] ; $i
2770   14F0 DA            push d
2771   14F1 FD 2E 00 00   mov32 cb, $00000000
2771   14F5 00 00 
2772   14F7 E7            pop d
2773   14F8 FD 43         mov [d], b
2774   14FA             ; --- END LOCAL VAR INITIALIZATION
2775   14FA             ; if (num < 0) { 
2776   14FA             _if34_cond:
2777   14FA FA 05 00      lea d, [bp + 5] ; $num
2778   14FD 2A            mov b, [d]
2779   14FE 38 00 00      mov c, 0
2780   1501             ; --- START RELATIONAL
2781   1501 D7            push a
2782   1502 11            mov a, b
2783   1503 FD 2E 00 00   mov32 cb, $00000000
2783   1507 00 00 
2784   1509 B0            cmp a, b
2785   150A FD 73         slt ; < (signed)
2786   150C E4            pop a
2787   150D             ; --- END RELATIONAL
2788   150D C0 00 00      cmp b, 0
2789   1510 C6 33 15      je _if34_else
2790   1513             _if34_TRUE:
2791   1513             ; putchar('-'); 
2792   1513             ; --- START FUNCTION CALL
2793   1513 FD 2E 2D 00   mov32 cb, $0000002d
2793   1517 00 00 
2794   1519 DD            push bl
2795   151A 07 C8 1C      call putchar
2796   151D 51 01 00      add sp, 1
2797   1520             ; --- END FUNCTION CALL
2798   1520             ; num = -num; 
2799   1520 FA 05 00      lea d, [bp + 5] ; $num
2800   1523 DA            push d
2801   1524 FA 05 00      lea d, [bp + 5] ; $num
2802   1527 2A            mov b, [d]
2803   1528 38 00 00      mov c, 0
2804   152B FD 97         neg b
2805   152D E7            pop d
2806   152E FD 43         mov [d], b
2807   1530 0A 5E 15      jmp _if34_exit
2808   1533             _if34_else:
2809   1533             ; if (num == 0) { 
2810   1533             _if35_cond:
2811   1533 FA 05 00      lea d, [bp + 5] ; $num
2812   1536 2A            mov b, [d]
2813   1537 38 00 00      mov c, 0
2814   153A             ; --- START RELATIONAL
2815   153A D7            push a
2816   153B 11            mov a, b
2817   153C FD 2E 00 00   mov32 cb, $00000000
2817   1540 00 00 
2818   1542 B0            cmp a, b
2819   1543 FD 71         seq ; ==
2820   1545 E4            pop a
2821   1546             ; --- END RELATIONAL
2822   1546 C0 00 00      cmp b, 0
2823   1549 C6 5E 15      je _if35_exit
2824   154C             _if35_TRUE:
2825   154C             ; putchar('0'); 
2826   154C             ; --- START FUNCTION CALL
2827   154C FD 2E 30 00   mov32 cb, $00000030
2827   1550 00 00 
2828   1552 DD            push bl
2829   1553 07 C8 1C      call putchar
2830   1556 51 01 00      add sp, 1
2831   1559             ; --- END FUNCTION CALL
2832   1559             ; return; 
2833   1559 F9            leave
2834   155A 09            ret
2835   155B 0A 5E 15      jmp _if35_exit
2836   155E             _if35_exit:
2837   155E             _if34_exit:
2838   155E             ; while (num > 0) { 
2839   155E             _while36_cond:
2840   155E FA 05 00      lea d, [bp + 5] ; $num
2841   1561 2A            mov b, [d]
2842   1562 38 00 00      mov c, 0
2843   1565             ; --- START RELATIONAL
2844   1565 D7            push a
2845   1566 11            mov a, b
2846   1567 FD 2E 00 00   mov32 cb, $00000000
2846   156B 00 00 
2847   156D B0            cmp a, b
2848   156E FD 7F         sgt ; >
2849   1570 E4            pop a
2850   1571             ; --- END RELATIONAL
2851   1571 C0 00 00      cmp b, 0
2852   1574 C6 D3 15      je _while36_exit
2853   1577             _while36_block:
2854   1577             ; digits[i] = '0' + (num % 10); 
2855   1577 FA FC FF      lea d, [bp + -4] ; $digits
2856   157A D7            push a
2857   157B DA            push d
2858   157C FA FA FF      lea d, [bp + -6] ; $i
2859   157F 2A            mov b, [d]
2860   1580 38 00 00      mov c, 0
2861   1583 E7            pop d
2862   1584 5A            add d, b
2863   1585 E4            pop a
2864   1586 DA            push d
2865   1587 FD 2E 30 00   mov32 cb, $00000030
2865   158B 00 00 
2866   158D             ; --- START TERMS
2867   158D D7            push a
2868   158E 11            mov a, b
2869   158F FA 05 00      lea d, [bp + 5] ; $num
2870   1592 2A            mov b, [d]
2871   1593 38 00 00      mov c, 0
2872   1596             ; --- START FACTORS
2873   1596 D7            push a
2874   1597 11            mov a, b
2875   1598 FD 2E 0A 00   mov32 cb, $0000000a
2875   159C 00 00 
2876   159E AE            div a, b ; 
2877   159F 11            mov a, b
2878   15A0 27            mov b, a
2879   15A1 E4            pop a
2880   15A2             ; --- END FACTORS
2881   15A2 56            add b, a
2882   15A3 E4            pop a
2883   15A4             ; --- END TERMS
2884   15A4 E7            pop d
2885   15A5 FD 3E         mov [d], bl
2886   15A7             ; num = num / 10; 
2887   15A7 FA 05 00      lea d, [bp + 5] ; $num
2888   15AA DA            push d
2889   15AB FA 05 00      lea d, [bp + 5] ; $num
2890   15AE 2A            mov b, [d]
2891   15AF 38 00 00      mov c, 0
2892   15B2             ; --- START FACTORS
2893   15B2 D7            push a
2894   15B3 11            mov a, b
2895   15B4 FD 2E 0A 00   mov32 cb, $0000000a
2895   15B8 00 00 
2896   15BA AE            div a, b
2897   15BB 27            mov b, a
2898   15BC E4            pop a
2899   15BD             ; --- END FACTORS
2900   15BD E7            pop d
2901   15BE FD 43         mov [d], b
2902   15C0             ; i++; 
2903   15C0 FA FA FF      lea d, [bp + -6] ; $i
2904   15C3 2A            mov b, [d]
2905   15C4 38 00 00      mov c, 0
2906   15C7 11            mov a, b
2907   15C8 FD 77         inc b
2908   15CA FA FA FF      lea d, [bp + -6] ; $i
2909   15CD FD 43         mov [d], b
2910   15CF 27            mov b, a
2911   15D0 0A 5E 15      jmp _while36_cond
2912   15D3             _while36_exit:
2913   15D3             ; while (i > 0) { 
2914   15D3             _while37_cond:
2915   15D3 FA FA FF      lea d, [bp + -6] ; $i
2916   15D6 2A            mov b, [d]
2917   15D7 38 00 00      mov c, 0
2918   15DA             ; --- START RELATIONAL
2919   15DA D7            push a
2920   15DB 11            mov a, b
2921   15DC FD 2E 00 00   mov32 cb, $00000000
2921   15E0 00 00 
2922   15E2 B0            cmp a, b
2923   15E3 FD 7F         sgt ; >
2924   15E5 E4            pop a
2925   15E6             ; --- END RELATIONAL
2926   15E6 C0 00 00      cmp b, 0
2927   15E9 C6 1B 16      je _while37_exit
2928   15EC             _while37_block:
2929   15EC             ; i--; 
2930   15EC FA FA FF      lea d, [bp + -6] ; $i
2931   15EF 2A            mov b, [d]
2932   15F0 38 00 00      mov c, 0
2933   15F3 11            mov a, b
2934   15F4 FD 7D         dec b
2935   15F6 FA FA FF      lea d, [bp + -6] ; $i
2936   15F9 FD 43         mov [d], b
2937   15FB 27            mov b, a
2938   15FC             ; putchar(digits[i]); 
2939   15FC             ; --- START FUNCTION CALL
2940   15FC FA FC FF      lea d, [bp + -4] ; $digits
2941   15FF D7            push a
2942   1600 DA            push d
2943   1601 FA FA FF      lea d, [bp + -6] ; $i
2944   1604 2A            mov b, [d]
2945   1605 38 00 00      mov c, 0
2946   1608 E7            pop d
2947   1609 5A            add d, b
2948   160A E4            pop a
2949   160B 32            mov bl, [d]
2950   160C A7 00         mov bh, 0
2951   160E 38 00 00      mov c, 0
2952   1611 DD            push bl
2953   1612 07 C8 1C      call putchar
2954   1615 51 01 00      add sp, 1
2955   1618             ; --- END FUNCTION CALL
2956   1618 0A D3 15      jmp _while37_cond
2957   161B             _while37_exit:
2958   161B F9            leave
2959   161C 09            ret
2960   161D             
2961   161D             print_signed_long:
2962   161D F8 00 00      enter 0 ; (push bp; mov bp, sp)
2963   1620             ; char digits[10]; 
2964   1620 52 0A 00      sub sp, 10
2965   1623             ; int i = 0; 
2966   1623 52 02 00      sub sp, 2
2967   1626             ; --- START LOCAL VAR INITIALIZATION
2968   1626 FA F5 FF      lea d, [bp + -11] ; $i
2969   1629 DA            push d
2970   162A FD 2E 00 00   mov32 cb, $00000000
2970   162E 00 00 
2971   1630 E7            pop d
2972   1631 FD 43         mov [d], b
2973   1633             ; --- END LOCAL VAR INITIALIZATION
2974   1633             ; if (num < 0) { 
2975   1633             _if38_cond:
2976   1633 FA 05 00      lea d, [bp + 5] ; $num
2977   1636 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2978   1639 FD 39         mov c, b ; And place it into C
2979   163B 2A            mov b, [d] ; Lower Word in B
2980   163C             ; --- START RELATIONAL
2981   163C D7            push a
2982   163D FD D8         push g
2983   163F 11            mov a, b
2984   1640 FD 7A         mov g, c
2985   1642 FD 2E 00 00   mov32 cb, $00000000
2985   1646 00 00 
2986   1648 FD AF         cmp32 ga, cb
2987   164A FD 73         slt ; <
2988   164C FD F1         pop g
2989   164E E4            pop a
2990   164F             ; --- END RELATIONAL
2991   164F C0 00 00      cmp b, 0
2992   1652 C6 86 16      je _if38_else
2993   1655             _if38_TRUE:
2994   1655             ; putchar('-'); 
2995   1655             ; --- START FUNCTION CALL
2996   1655 FD 2E 2D 00   mov32 cb, $0000002d
2996   1659 00 00 
2997   165B DD            push bl
2998   165C 07 C8 1C      call putchar
2999   165F 51 01 00      add sp, 1
3000   1662             ; --- END FUNCTION CALL
3001   1662             ; num = -num; 
3002   1662 FA 05 00      lea d, [bp + 5] ; $num
3003   1665 DA            push d
3004   1666 FA 05 00      lea d, [bp + 5] ; $num
3005   1669 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3006   166C FD 39         mov c, b ; And place it into C
3007   166E 2A            mov b, [d] ; Lower Word in B
3008   166F 12            mov a, c
3009   1670 95            not a
3010   1671 97            not b
3011   1672 55 01 00      add b, 1
3012   1675 5B 00 00      adc a, 0
3013   1678 39            mov c, a
3014   1679 E7            pop d
3015   167A FD 43         mov [d], b
3016   167C 26 00 00      mov b, 0
3017   167F FD 44 02 00   mov [d + 2], b
3018   1683 0A BA 16      jmp _if38_exit
3019   1686             _if38_else:
3020   1686             ; if (num == 0) { 
3021   1686             _if39_cond:
3022   1686 FA 05 00      lea d, [bp + 5] ; $num
3023   1689 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3024   168C FD 39         mov c, b ; And place it into C
3025   168E 2A            mov b, [d] ; Lower Word in B
3026   168F             ; --- START RELATIONAL
3027   168F D7            push a
3028   1690 FD D8         push g
3029   1692 11            mov a, b
3030   1693 FD 7A         mov g, c
3031   1695 FD 2E 00 00   mov32 cb, $00000000
3031   1699 00 00 
3032   169B FD AF         cmp32 ga, cb
3033   169D FD 71         seq ; ==
3034   169F FD F1         pop g
3035   16A1 E4            pop a
3036   16A2             ; --- END RELATIONAL
3037   16A2 C0 00 00      cmp b, 0
3038   16A5 C6 BA 16      je _if39_exit
3039   16A8             _if39_TRUE:
3040   16A8             ; putchar('0'); 
3041   16A8             ; --- START FUNCTION CALL
3042   16A8 FD 2E 30 00   mov32 cb, $00000030
3042   16AC 00 00 
3043   16AE DD            push bl
3044   16AF 07 C8 1C      call putchar
3045   16B2 51 01 00      add sp, 1
3046   16B5             ; --- END FUNCTION CALL
3047   16B5             ; return; 
3048   16B5 F9            leave
3049   16B6 09            ret
3050   16B7 0A BA 16      jmp _if39_exit
3051   16BA             _if39_exit:
3052   16BA             _if38_exit:
3053   16BA             ; while (num > 0) { 
3054   16BA             _while40_cond:
3055   16BA FA 05 00      lea d, [bp + 5] ; $num
3056   16BD 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3057   16C0 FD 39         mov c, b ; And place it into C
3058   16C2 2A            mov b, [d] ; Lower Word in B
3059   16C3             ; --- START RELATIONAL
3060   16C3 D7            push a
3061   16C4 FD D8         push g
3062   16C6 11            mov a, b
3063   16C7 FD 7A         mov g, c
3064   16C9 FD 2E 00 00   mov32 cb, $00000000
3064   16CD 00 00 
3065   16CF FD AF         cmp32 ga, cb
3066   16D1 FD 7F         sgt
3067   16D3 FD F1         pop g
3068   16D5 E4            pop a
3069   16D6             ; --- END RELATIONAL
3070   16D6 C0 00 00      cmp b, 0
3071   16D9 C6 42 17      je _while40_exit
3072   16DC             _while40_block:
3073   16DC             ; digits[i] = '0' + (num % 10); 
3074   16DC FA F7 FF      lea d, [bp + -9] ; $digits
3075   16DF D7            push a
3076   16E0 DA            push d
3077   16E1 FA F5 FF      lea d, [bp + -11] ; $i
3078   16E4 2A            mov b, [d]
3079   16E5 38 00 00      mov c, 0
3080   16E8 E7            pop d
3081   16E9 5A            add d, b
3082   16EA E4            pop a
3083   16EB DA            push d
3084   16EC FD 2E 30 00   mov32 cb, $00000030
3084   16F0 00 00 
3085   16F2             ; --- START TERMS
3086   16F2 D7            push a
3087   16F3 11            mov a, b
3088   16F4 FA 05 00      lea d, [bp + 5] ; $num
3089   16F7 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3090   16FA FD 39         mov c, b ; And place it into C
3091   16FC 2A            mov b, [d] ; Lower Word in B
3092   16FD             ; --- START FACTORS
3093   16FD D7            push a
3094   16FE 11            mov a, b
3095   16FF FD 2E 0A 00   mov32 cb, $0000000a
3095   1703 00 00 
3096   1705 AE            div a, b ; 
3097   1706 11            mov a, b
3098   1707 27            mov b, a
3099   1708 E4            pop a
3100   1709             ; --- END FACTORS
3101   1709 FD 15         add32 cb, ga
3102   170B E4            pop a
3103   170C             ; --- END TERMS
3104   170C E7            pop d
3105   170D FD 3E         mov [d], bl
3106   170F             ; num = num / 10; 
3107   170F FA 05 00      lea d, [bp + 5] ; $num
3108   1712 DA            push d
3109   1713 FA 05 00      lea d, [bp + 5] ; $num
3110   1716 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3111   1719 FD 39         mov c, b ; And place it into C
3112   171B 2A            mov b, [d] ; Lower Word in B
3113   171C             ; --- START FACTORS
3114   171C D7            push a
3115   171D 11            mov a, b
3116   171E FD 2E 0A 00   mov32 cb, $0000000a
3116   1722 00 00 
3117   1724 AE            div a, b
3118   1725 27            mov b, a
3119   1726 E4            pop a
3120   1727             ; --- END FACTORS
3121   1727 E7            pop d
3122   1728 FD 43         mov [d], b
3123   172A 28            mov b, c
3124   172B FD 44 02 00   mov [d + 2], b
3125   172F             ; i++; 
3126   172F FA F5 FF      lea d, [bp + -11] ; $i
3127   1732 2A            mov b, [d]
3128   1733 38 00 00      mov c, 0
3129   1736 11            mov a, b
3130   1737 FD 77         inc b
3131   1739 FA F5 FF      lea d, [bp + -11] ; $i
3132   173C FD 43         mov [d], b
3133   173E 27            mov b, a
3134   173F 0A BA 16      jmp _while40_cond
3135   1742             _while40_exit:
3136   1742             ; while (i > 0) { 
3137   1742             _while41_cond:
3138   1742 FA F5 FF      lea d, [bp + -11] ; $i
3139   1745 2A            mov b, [d]
3140   1746 38 00 00      mov c, 0
3141   1749             ; --- START RELATIONAL
3142   1749 D7            push a
3143   174A 11            mov a, b
3144   174B FD 2E 00 00   mov32 cb, $00000000
3144   174F 00 00 
3145   1751 B0            cmp a, b
3146   1752 FD 7F         sgt ; >
3147   1754 E4            pop a
3148   1755             ; --- END RELATIONAL
3149   1755 C0 00 00      cmp b, 0
3150   1758 C6 8A 17      je _while41_exit
3151   175B             _while41_block:
3152   175B             ; i--; 
3153   175B FA F5 FF      lea d, [bp + -11] ; $i
3154   175E 2A            mov b, [d]
3155   175F 38 00 00      mov c, 0
3156   1762 11            mov a, b
3157   1763 FD 7D         dec b
3158   1765 FA F5 FF      lea d, [bp + -11] ; $i
3159   1768 FD 43         mov [d], b
3160   176A 27            mov b, a
3161   176B             ; putchar(digits[i]); 
3162   176B             ; --- START FUNCTION CALL
3163   176B FA F7 FF      lea d, [bp + -9] ; $digits
3164   176E D7            push a
3165   176F DA            push d
3166   1770 FA F5 FF      lea d, [bp + -11] ; $i
3167   1773 2A            mov b, [d]
3168   1774 38 00 00      mov c, 0
3169   1777 E7            pop d
3170   1778 5A            add d, b
3171   1779 E4            pop a
3172   177A 32            mov bl, [d]
3173   177B A7 00         mov bh, 0
3174   177D 38 00 00      mov c, 0
3175   1780 DD            push bl
3176   1781 07 C8 1C      call putchar
3177   1784 51 01 00      add sp, 1
3178   1787             ; --- END FUNCTION CALL
3179   1787 0A 42 17      jmp _while41_cond
3180   178A             _while41_exit:
3181   178A F9            leave
3182   178B 09            ret
3183   178C             
3184   178C             print_unsigned_long:
3185   178C F8 00 00      enter 0 ; (push bp; mov bp, sp)
3186   178F             ; char digits[10]; 
3187   178F 52 0A 00      sub sp, 10
3188   1792             ; int i; 
3189   1792 52 02 00      sub sp, 2
3190   1795             ; i = 0; 
3191   1795 FA F5 FF      lea d, [bp + -11] ; $i
3192   1798 DA            push d
3193   1799 FD 2E 00 00   mov32 cb, $00000000
3193   179D 00 00 
3194   179F E7            pop d
3195   17A0 FD 43         mov [d], b
3196   17A2             ; if(num == 0){ 
3197   17A2             _if42_cond:
3198   17A2 FA 05 00      lea d, [bp + 5] ; $num
3199   17A5 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3200   17A8 FD 39         mov c, b ; And place it into C
3201   17AA 2A            mov b, [d] ; Lower Word in B
3202   17AB             ; --- START RELATIONAL
3203   17AB D7            push a
3204   17AC FD D8         push g
3205   17AE 11            mov a, b
3206   17AF FD 7A         mov g, c
3207   17B1 FD 2E 00 00   mov32 cb, $00000000
3207   17B5 00 00 
3208   17B7 FD AF         cmp32 ga, cb
3209   17B9 FD 71         seq ; ==
3210   17BB FD F1         pop g
3211   17BD E4            pop a
3212   17BE             ; --- END RELATIONAL
3213   17BE C0 00 00      cmp b, 0
3214   17C1 C6 D6 17      je _if42_exit
3215   17C4             _if42_TRUE:
3216   17C4             ; putchar('0'); 
3217   17C4             ; --- START FUNCTION CALL
3218   17C4 FD 2E 30 00   mov32 cb, $00000030
3218   17C8 00 00 
3219   17CA DD            push bl
3220   17CB 07 C8 1C      call putchar
3221   17CE 51 01 00      add sp, 1
3222   17D1             ; --- END FUNCTION CALL
3223   17D1             ; return; 
3224   17D1 F9            leave
3225   17D2 09            ret
3226   17D3 0A D6 17      jmp _if42_exit
3227   17D6             _if42_exit:
3228   17D6             ; while (num > 0) { 
3229   17D6             _while43_cond:
3230   17D6 FA 05 00      lea d, [bp + 5] ; $num
3231   17D9 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3232   17DC FD 39         mov c, b ; And place it into C
3233   17DE 2A            mov b, [d] ; Lower Word in B
3234   17DF             ; --- START RELATIONAL
3235   17DF D7            push a
3236   17E0 FD D8         push g
3237   17E2 11            mov a, b
3238   17E3 FD 7A         mov g, c
3239   17E5 FD 2E 00 00   mov32 cb, $00000000
3239   17E9 00 00 
3240   17EB FD AF         cmp32 ga, cb
3241   17ED FD 81         sgu
3242   17EF FD F1         pop g
3243   17F1 E4            pop a
3244   17F2             ; --- END RELATIONAL
3245   17F2 C0 00 00      cmp b, 0
3246   17F5 C6 5E 18      je _while43_exit
3247   17F8             _while43_block:
3248   17F8             ; digits[i] = '0' + (num % 10); 
3249   17F8 FA F7 FF      lea d, [bp + -9] ; $digits
3250   17FB D7            push a
3251   17FC DA            push d
3252   17FD FA F5 FF      lea d, [bp + -11] ; $i
3253   1800 2A            mov b, [d]
3254   1801 38 00 00      mov c, 0
3255   1804 E7            pop d
3256   1805 5A            add d, b
3257   1806 E4            pop a
3258   1807 DA            push d
3259   1808 FD 2E 30 00   mov32 cb, $00000030
3259   180C 00 00 
3260   180E             ; --- START TERMS
3261   180E D7            push a
3262   180F 11            mov a, b
3263   1810 FA 05 00      lea d, [bp + 5] ; $num
3264   1813 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3265   1816 FD 39         mov c, b ; And place it into C
3266   1818 2A            mov b, [d] ; Lower Word in B
3267   1819             ; --- START FACTORS
3268   1819 D7            push a
3269   181A 11            mov a, b
3270   181B FD 2E 0A 00   mov32 cb, $0000000a
3270   181F 00 00 
3271   1821 AE            div a, b ; 
3272   1822 11            mov a, b
3273   1823 27            mov b, a
3274   1824 E4            pop a
3275   1825             ; --- END FACTORS
3276   1825 FD 15         add32 cb, ga
3277   1827 E4            pop a
3278   1828             ; --- END TERMS
3279   1828 E7            pop d
3280   1829 FD 3E         mov [d], bl
3281   182B             ; num = num / 10; 
3282   182B FA 05 00      lea d, [bp + 5] ; $num
3283   182E DA            push d
3284   182F FA 05 00      lea d, [bp + 5] ; $num
3285   1832 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3286   1835 FD 39         mov c, b ; And place it into C
3287   1837 2A            mov b, [d] ; Lower Word in B
3288   1838             ; --- START FACTORS
3289   1838 D7            push a
3290   1839 11            mov a, b
3291   183A FD 2E 0A 00   mov32 cb, $0000000a
3291   183E 00 00 
3292   1840 AE            div a, b
3293   1841 27            mov b, a
3294   1842 E4            pop a
3295   1843             ; --- END FACTORS
3296   1843 E7            pop d
3297   1844 FD 43         mov [d], b
3298   1846 28            mov b, c
3299   1847 FD 44 02 00   mov [d + 2], b
3300   184B             ; i++; 
3301   184B FA F5 FF      lea d, [bp + -11] ; $i
3302   184E 2A            mov b, [d]
3303   184F 38 00 00      mov c, 0
3304   1852 11            mov a, b
3305   1853 FD 77         inc b
3306   1855 FA F5 FF      lea d, [bp + -11] ; $i
3307   1858 FD 43         mov [d], b
3308   185A 27            mov b, a
3309   185B 0A D6 17      jmp _while43_cond
3310   185E             _while43_exit:
3311   185E             ; while (i > 0) { 
3312   185E             _while44_cond:
3313   185E FA F5 FF      lea d, [bp + -11] ; $i
3314   1861 2A            mov b, [d]
3315   1862 38 00 00      mov c, 0
3316   1865             ; --- START RELATIONAL
3317   1865 D7            push a
3318   1866 11            mov a, b
3319   1867 FD 2E 00 00   mov32 cb, $00000000
3319   186B 00 00 
3320   186D B0            cmp a, b
3321   186E FD 7F         sgt ; >
3322   1870 E4            pop a
3323   1871             ; --- END RELATIONAL
3324   1871 C0 00 00      cmp b, 0
3325   1874 C6 A6 18      je _while44_exit
3326   1877             _while44_block:
3327   1877             ; i--; 
3328   1877 FA F5 FF      lea d, [bp + -11] ; $i
3329   187A 2A            mov b, [d]
3330   187B 38 00 00      mov c, 0
3331   187E 11            mov a, b
3332   187F FD 7D         dec b
3333   1881 FA F5 FF      lea d, [bp + -11] ; $i
3334   1884 FD 43         mov [d], b
3335   1886 27            mov b, a
3336   1887             ; putchar(digits[i]); 
3337   1887             ; --- START FUNCTION CALL
3338   1887 FA F7 FF      lea d, [bp + -9] ; $digits
3339   188A D7            push a
3340   188B DA            push d
3341   188C FA F5 FF      lea d, [bp + -11] ; $i
3342   188F 2A            mov b, [d]
3343   1890 38 00 00      mov c, 0
3344   1893 E7            pop d
3345   1894 5A            add d, b
3346   1895 E4            pop a
3347   1896 32            mov bl, [d]
3348   1897 A7 00         mov bh, 0
3349   1899 38 00 00      mov c, 0
3350   189C DD            push bl
3351   189D 07 C8 1C      call putchar
3352   18A0 51 01 00      add sp, 1
3353   18A3             ; --- END FUNCTION CALL
3354   18A3 0A 5E 18      jmp _while44_cond
3355   18A6             _while44_exit:
3356   18A6 F9            leave
3357   18A7 09            ret
3358   18A8             
3359   18A8             sprint_unsigned:
3360   18A8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3361   18AB             ; char digits[5]; 
3362   18AB 52 05 00      sub sp, 5
3363   18AE             ; int i; 
3364   18AE 52 02 00      sub sp, 2
3365   18B1             ; int len = 0; 
3366   18B1 52 02 00      sub sp, 2
3367   18B4             ; --- START LOCAL VAR INITIALIZATION
3368   18B4 FA F8 FF      lea d, [bp + -8] ; $len
3369   18B7 DA            push d
3370   18B8 FD 2E 00 00   mov32 cb, $00000000
3370   18BC 00 00 
3371   18BE E7            pop d
3372   18BF FD 43         mov [d], b
3373   18C1             ; --- END LOCAL VAR INITIALIZATION
3374   18C1             ; i = 0; 
3375   18C1 FA FA FF      lea d, [bp + -6] ; $i
3376   18C4 DA            push d
3377   18C5 FD 2E 00 00   mov32 cb, $00000000
3377   18C9 00 00 
3378   18CB E7            pop d
3379   18CC FD 43         mov [d], b
3380   18CE             ; if(num == 0){ 
3381   18CE             _if45_cond:
3382   18CE FA 07 00      lea d, [bp + 7] ; $num
3383   18D1 2A            mov b, [d]
3384   18D2 38 00 00      mov c, 0
3385   18D5             ; --- START RELATIONAL
3386   18D5 D7            push a
3387   18D6 11            mov a, b
3388   18D7 FD 2E 00 00   mov32 cb, $00000000
3388   18DB 00 00 
3389   18DD B0            cmp a, b
3390   18DE FD 71         seq ; ==
3391   18E0 E4            pop a
3392   18E1             ; --- END RELATIONAL
3393   18E1 C0 00 00      cmp b, 0
3394   18E4 C6 0C 19      je _if45_exit
3395   18E7             _if45_TRUE:
3396   18E7             ; *dest++ = '0'; 
3397   18E7 FA 05 00      lea d, [bp + 5] ; $dest
3398   18EA 2A            mov b, [d]
3399   18EB 38 00 00      mov c, 0
3400   18EE FD 77         inc b
3401   18F0 FA 05 00      lea d, [bp + 5] ; $dest
3402   18F3 FD 43         mov [d], b
3403   18F5 FD 7D         dec b
3404   18F7 D8            push b
3405   18F8 FD 2E 30 00   mov32 cb, $00000030
3405   18FC 00 00 
3406   18FE E7            pop d
3407   18FF FD 3E         mov [d], bl
3408   1901             ; return 1; 
3409   1901 FD 2E 01 00   mov32 cb, $00000001
3409   1905 00 00 
3410   1907 F9            leave
3411   1908 09            ret
3412   1909 0A 0C 19      jmp _if45_exit
3413   190C             _if45_exit:
3414   190C             ; while (num > 0) { 
3415   190C             _while46_cond:
3416   190C FA 07 00      lea d, [bp + 7] ; $num
3417   190F 2A            mov b, [d]
3418   1910 38 00 00      mov c, 0
3419   1913             ; --- START RELATIONAL
3420   1913 D7            push a
3421   1914 11            mov a, b
3422   1915 FD 2E 00 00   mov32 cb, $00000000
3422   1919 00 00 
3423   191B B0            cmp a, b
3424   191C FD 81         sgu ; > (unsigned)
3425   191E E4            pop a
3426   191F             ; --- END RELATIONAL
3427   191F C0 00 00      cmp b, 0
3428   1922 C6 81 19      je _while46_exit
3429   1925             _while46_block:
3430   1925             ; digits[i] = '0' + (num % 10); 
3431   1925 FA FC FF      lea d, [bp + -4] ; $digits
3432   1928 D7            push a
3433   1929 DA            push d
3434   192A FA FA FF      lea d, [bp + -6] ; $i
3435   192D 2A            mov b, [d]
3436   192E 38 00 00      mov c, 0
3437   1931 E7            pop d
3438   1932 5A            add d, b
3439   1933 E4            pop a
3440   1934 DA            push d
3441   1935 FD 2E 30 00   mov32 cb, $00000030
3441   1939 00 00 
3442   193B             ; --- START TERMS
3443   193B D7            push a
3444   193C 11            mov a, b
3445   193D FA 07 00      lea d, [bp + 7] ; $num
3446   1940 2A            mov b, [d]
3447   1941 38 00 00      mov c, 0
3448   1944             ; --- START FACTORS
3449   1944 D7            push a
3450   1945 11            mov a, b
3451   1946 FD 2E 0A 00   mov32 cb, $0000000a
3451   194A 00 00 
3452   194C AE            div a, b ; 
3453   194D 11            mov a, b
3454   194E 27            mov b, a
3455   194F E4            pop a
3456   1950             ; --- END FACTORS
3457   1950 56            add b, a
3458   1951 E4            pop a
3459   1952             ; --- END TERMS
3460   1952 E7            pop d
3461   1953 FD 3E         mov [d], bl
3462   1955             ; num = num / 10; 
3463   1955 FA 07 00      lea d, [bp + 7] ; $num
3464   1958 DA            push d
3465   1959 FA 07 00      lea d, [bp + 7] ; $num
3466   195C 2A            mov b, [d]
3467   195D 38 00 00      mov c, 0
3468   1960             ; --- START FACTORS
3469   1960 D7            push a
3470   1961 11            mov a, b
3471   1962 FD 2E 0A 00   mov32 cb, $0000000a
3471   1966 00 00 
3472   1968 AE            div a, b
3473   1969 27            mov b, a
3474   196A E4            pop a
3475   196B             ; --- END FACTORS
3476   196B E7            pop d
3477   196C FD 43         mov [d], b
3478   196E             ; i++; 
3479   196E FA FA FF      lea d, [bp + -6] ; $i
3480   1971 2A            mov b, [d]
3481   1972 38 00 00      mov c, 0
3482   1975 11            mov a, b
3483   1976 FD 77         inc b
3484   1978 FA FA FF      lea d, [bp + -6] ; $i
3485   197B FD 43         mov [d], b
3486   197D 27            mov b, a
3487   197E 0A 0C 19      jmp _while46_cond
3488   1981             _while46_exit:
3489   1981             ; while (i > 0) { 
3490   1981             _while47_cond:
3491   1981 FA FA FF      lea d, [bp + -6] ; $i
3492   1984 2A            mov b, [d]
3493   1985 38 00 00      mov c, 0
3494   1988             ; --- START RELATIONAL
3495   1988 D7            push a
3496   1989 11            mov a, b
3497   198A FD 2E 00 00   mov32 cb, $00000000
3497   198E 00 00 
3498   1990 B0            cmp a, b
3499   1991 FD 7F         sgt ; >
3500   1993 E4            pop a
3501   1994             ; --- END RELATIONAL
3502   1994 C0 00 00      cmp b, 0
3503   1997 C6 E6 19      je _while47_exit
3504   199A             _while47_block:
3505   199A             ; i--; 
3506   199A FA FA FF      lea d, [bp + -6] ; $i
3507   199D 2A            mov b, [d]
3508   199E 38 00 00      mov c, 0
3509   19A1 11            mov a, b
3510   19A2 FD 7D         dec b
3511   19A4 FA FA FF      lea d, [bp + -6] ; $i
3512   19A7 FD 43         mov [d], b
3513   19A9 27            mov b, a
3514   19AA             ; *dest++ = digits[i]; 
3515   19AA FA 05 00      lea d, [bp + 5] ; $dest
3516   19AD 2A            mov b, [d]
3517   19AE 38 00 00      mov c, 0
3518   19B1 FD 77         inc b
3519   19B3 FA 05 00      lea d, [bp + 5] ; $dest
3520   19B6 FD 43         mov [d], b
3521   19B8 FD 7D         dec b
3522   19BA D8            push b
3523   19BB FA FC FF      lea d, [bp + -4] ; $digits
3524   19BE D7            push a
3525   19BF DA            push d
3526   19C0 FA FA FF      lea d, [bp + -6] ; $i
3527   19C3 2A            mov b, [d]
3528   19C4 38 00 00      mov c, 0
3529   19C7 E7            pop d
3530   19C8 5A            add d, b
3531   19C9 E4            pop a
3532   19CA 32            mov bl, [d]
3533   19CB A7 00         mov bh, 0
3534   19CD 38 00 00      mov c, 0
3535   19D0 E7            pop d
3536   19D1 FD 3E         mov [d], bl
3537   19D3             ; len++; 
3538   19D3 FA F8 FF      lea d, [bp + -8] ; $len
3539   19D6 2A            mov b, [d]
3540   19D7 38 00 00      mov c, 0
3541   19DA 11            mov a, b
3542   19DB FD 77         inc b
3543   19DD FA F8 FF      lea d, [bp + -8] ; $len
3544   19E0 FD 43         mov [d], b
3545   19E2 27            mov b, a
3546   19E3 0A 81 19      jmp _while47_cond
3547   19E6             _while47_exit:
3548   19E6             ; *dest = '\0'; 
3549   19E6 FA 05 00      lea d, [bp + 5] ; $dest
3550   19E9 2A            mov b, [d]
3551   19EA 38 00 00      mov c, 0
3552   19ED D8            push b
3553   19EE FD 2E 00 00   mov32 cb, $00000000
3553   19F2 00 00 
3554   19F4 E7            pop d
3555   19F5 FD 3E         mov [d], bl
3556   19F7             ; return len; 
3557   19F7 FA F8 FF      lea d, [bp + -8] ; $len
3558   19FA 2A            mov b, [d]
3559   19FB 38 00 00      mov c, 0
3560   19FE F9            leave
3561   19FF 09            ret
3562   1A00             
3563   1A00             print_unsigned:
3564   1A00 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3565   1A03             ; char digits[5]; 
3566   1A03 52 05 00      sub sp, 5
3567   1A06             ; int i; 
3568   1A06 52 02 00      sub sp, 2
3569   1A09             ; i = 0; 
3570   1A09 FA FA FF      lea d, [bp + -6] ; $i
3571   1A0C DA            push d
3572   1A0D FD 2E 00 00   mov32 cb, $00000000
3572   1A11 00 00 
3573   1A13 E7            pop d
3574   1A14 FD 43         mov [d], b
3575   1A16             ; if(num == 0){ 
3576   1A16             _if48_cond:
3577   1A16 FA 05 00      lea d, [bp + 5] ; $num
3578   1A19 2A            mov b, [d]
3579   1A1A 38 00 00      mov c, 0
3580   1A1D             ; --- START RELATIONAL
3581   1A1D D7            push a
3582   1A1E 11            mov a, b
3583   1A1F FD 2E 00 00   mov32 cb, $00000000
3583   1A23 00 00 
3584   1A25 B0            cmp a, b
3585   1A26 FD 71         seq ; ==
3586   1A28 E4            pop a
3587   1A29             ; --- END RELATIONAL
3588   1A29 C0 00 00      cmp b, 0
3589   1A2C C6 41 1A      je _if48_exit
3590   1A2F             _if48_TRUE:
3591   1A2F             ; putchar('0'); 
3592   1A2F             ; --- START FUNCTION CALL
3593   1A2F FD 2E 30 00   mov32 cb, $00000030
3593   1A33 00 00 
3594   1A35 DD            push bl
3595   1A36 07 C8 1C      call putchar
3596   1A39 51 01 00      add sp, 1
3597   1A3C             ; --- END FUNCTION CALL
3598   1A3C             ; return; 
3599   1A3C F9            leave
3600   1A3D 09            ret
3601   1A3E 0A 41 1A      jmp _if48_exit
3602   1A41             _if48_exit:
3603   1A41             ; while (num > 0) { 
3604   1A41             _while49_cond:
3605   1A41 FA 05 00      lea d, [bp + 5] ; $num
3606   1A44 2A            mov b, [d]
3607   1A45 38 00 00      mov c, 0
3608   1A48             ; --- START RELATIONAL
3609   1A48 D7            push a
3610   1A49 11            mov a, b
3611   1A4A FD 2E 00 00   mov32 cb, $00000000
3611   1A4E 00 00 
3612   1A50 B0            cmp a, b
3613   1A51 FD 81         sgu ; > (unsigned)
3614   1A53 E4            pop a
3615   1A54             ; --- END RELATIONAL
3616   1A54 C0 00 00      cmp b, 0
3617   1A57 C6 B6 1A      je _while49_exit
3618   1A5A             _while49_block:
3619   1A5A             ; digits[i] = '0' + (num % 10); 
3620   1A5A FA FC FF      lea d, [bp + -4] ; $digits
3621   1A5D D7            push a
3622   1A5E DA            push d
3623   1A5F FA FA FF      lea d, [bp + -6] ; $i
3624   1A62 2A            mov b, [d]
3625   1A63 38 00 00      mov c, 0
3626   1A66 E7            pop d
3627   1A67 5A            add d, b
3628   1A68 E4            pop a
3629   1A69 DA            push d
3630   1A6A FD 2E 30 00   mov32 cb, $00000030
3630   1A6E 00 00 
3631   1A70             ; --- START TERMS
3632   1A70 D7            push a
3633   1A71 11            mov a, b
3634   1A72 FA 05 00      lea d, [bp + 5] ; $num
3635   1A75 2A            mov b, [d]
3636   1A76 38 00 00      mov c, 0
3637   1A79             ; --- START FACTORS
3638   1A79 D7            push a
3639   1A7A 11            mov a, b
3640   1A7B FD 2E 0A 00   mov32 cb, $0000000a
3640   1A7F 00 00 
3641   1A81 AE            div a, b ; 
3642   1A82 11            mov a, b
3643   1A83 27            mov b, a
3644   1A84 E4            pop a
3645   1A85             ; --- END FACTORS
3646   1A85 56            add b, a
3647   1A86 E4            pop a
3648   1A87             ; --- END TERMS
3649   1A87 E7            pop d
3650   1A88 FD 3E         mov [d], bl
3651   1A8A             ; num = num / 10; 
3652   1A8A FA 05 00      lea d, [bp + 5] ; $num
3653   1A8D DA            push d
3654   1A8E FA 05 00      lea d, [bp + 5] ; $num
3655   1A91 2A            mov b, [d]
3656   1A92 38 00 00      mov c, 0
3657   1A95             ; --- START FACTORS
3658   1A95 D7            push a
3659   1A96 11            mov a, b
3660   1A97 FD 2E 0A 00   mov32 cb, $0000000a
3660   1A9B 00 00 
3661   1A9D AE            div a, b
3662   1A9E 27            mov b, a
3663   1A9F E4            pop a
3664   1AA0             ; --- END FACTORS
3665   1AA0 E7            pop d
3666   1AA1 FD 43         mov [d], b
3667   1AA3             ; i++; 
3668   1AA3 FA FA FF      lea d, [bp + -6] ; $i
3669   1AA6 2A            mov b, [d]
3670   1AA7 38 00 00      mov c, 0
3671   1AAA 11            mov a, b
3672   1AAB FD 77         inc b
3673   1AAD FA FA FF      lea d, [bp + -6] ; $i
3674   1AB0 FD 43         mov [d], b
3675   1AB2 27            mov b, a
3676   1AB3 0A 41 1A      jmp _while49_cond
3677   1AB6             _while49_exit:
3678   1AB6             ; while (i > 0) { 
3679   1AB6             _while50_cond:
3680   1AB6 FA FA FF      lea d, [bp + -6] ; $i
3681   1AB9 2A            mov b, [d]
3682   1ABA 38 00 00      mov c, 0
3683   1ABD             ; --- START RELATIONAL
3684   1ABD D7            push a
3685   1ABE 11            mov a, b
3686   1ABF FD 2E 00 00   mov32 cb, $00000000
3686   1AC3 00 00 
3687   1AC5 B0            cmp a, b
3688   1AC6 FD 7F         sgt ; >
3689   1AC8 E4            pop a
3690   1AC9             ; --- END RELATIONAL
3691   1AC9 C0 00 00      cmp b, 0
3692   1ACC C6 FE 1A      je _while50_exit
3693   1ACF             _while50_block:
3694   1ACF             ; i--; 
3695   1ACF FA FA FF      lea d, [bp + -6] ; $i
3696   1AD2 2A            mov b, [d]
3697   1AD3 38 00 00      mov c, 0
3698   1AD6 11            mov a, b
3699   1AD7 FD 7D         dec b
3700   1AD9 FA FA FF      lea d, [bp + -6] ; $i
3701   1ADC FD 43         mov [d], b
3702   1ADE 27            mov b, a
3703   1ADF             ; putchar(digits[i]); 
3704   1ADF             ; --- START FUNCTION CALL
3705   1ADF FA FC FF      lea d, [bp + -4] ; $digits
3706   1AE2 D7            push a
3707   1AE3 DA            push d
3708   1AE4 FA FA FF      lea d, [bp + -6] ; $i
3709   1AE7 2A            mov b, [d]
3710   1AE8 38 00 00      mov c, 0
3711   1AEB E7            pop d
3712   1AEC 5A            add d, b
3713   1AED E4            pop a
3714   1AEE 32            mov bl, [d]
3715   1AEF A7 00         mov bh, 0
3716   1AF1 38 00 00      mov c, 0
3717   1AF4 DD            push bl
3718   1AF5 07 C8 1C      call putchar
3719   1AF8 51 01 00      add sp, 1
3720   1AFB             ; --- END FUNCTION CALL
3721   1AFB 0A B6 1A      jmp _while50_cond
3722   1AFE             _while50_exit:
3723   1AFE F9            leave
3724   1AFF 09            ret
3725   1B00             
3726   1B00             sprint_signed:
3727   1B00 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3728   1B03             ; char digits[5]; 
3729   1B03 52 05 00      sub sp, 5
3730   1B06             ; int i = 0; 
3731   1B06 52 02 00      sub sp, 2
3732   1B09             ; --- START LOCAL VAR INITIALIZATION
3733   1B09 FA FA FF      lea d, [bp + -6] ; $i
3734   1B0C DA            push d
3735   1B0D FD 2E 00 00   mov32 cb, $00000000
3735   1B11 00 00 
3736   1B13 E7            pop d
3737   1B14 FD 43         mov [d], b
3738   1B16             ; --- END LOCAL VAR INITIALIZATION
3739   1B16             ; int len = 0; 
3740   1B16 52 02 00      sub sp, 2
3741   1B19             ; --- START LOCAL VAR INITIALIZATION
3742   1B19 FA F8 FF      lea d, [bp + -8] ; $len
3743   1B1C DA            push d
3744   1B1D FD 2E 00 00   mov32 cb, $00000000
3744   1B21 00 00 
3745   1B23 E7            pop d
3746   1B24 FD 43         mov [d], b
3747   1B26             ; --- END LOCAL VAR INITIALIZATION
3748   1B26             ; if (num < 0) { 
3749   1B26             _if51_cond:
3750   1B26 FA 07 00      lea d, [bp + 7] ; $num
3751   1B29 2A            mov b, [d]
3752   1B2A 38 00 00      mov c, 0
3753   1B2D             ; --- START RELATIONAL
3754   1B2D D7            push a
3755   1B2E 11            mov a, b
3756   1B2F FD 2E 00 00   mov32 cb, $00000000
3756   1B33 00 00 
3757   1B35 B0            cmp a, b
3758   1B36 FD 73         slt ; < (signed)
3759   1B38 E4            pop a
3760   1B39             ; --- END RELATIONAL
3761   1B39 C0 00 00      cmp b, 0
3762   1B3C C6 7C 1B      je _if51_else
3763   1B3F             _if51_TRUE:
3764   1B3F             ; *dest++ = '-'; 
3765   1B3F FA 05 00      lea d, [bp + 5] ; $dest
3766   1B42 2A            mov b, [d]
3767   1B43 38 00 00      mov c, 0
3768   1B46 FD 77         inc b
3769   1B48 FA 05 00      lea d, [bp + 5] ; $dest
3770   1B4B FD 43         mov [d], b
3771   1B4D FD 7D         dec b
3772   1B4F D8            push b
3773   1B50 FD 2E 2D 00   mov32 cb, $0000002d
3773   1B54 00 00 
3774   1B56 E7            pop d
3775   1B57 FD 3E         mov [d], bl
3776   1B59             ; num = -num; 
3777   1B59 FA 07 00      lea d, [bp + 7] ; $num
3778   1B5C DA            push d
3779   1B5D FA 07 00      lea d, [bp + 7] ; $num
3780   1B60 2A            mov b, [d]
3781   1B61 38 00 00      mov c, 0
3782   1B64 FD 97         neg b
3783   1B66 E7            pop d
3784   1B67 FD 43         mov [d], b
3785   1B69             ; len++; 
3786   1B69 FA F8 FF      lea d, [bp + -8] ; $len
3787   1B6C 2A            mov b, [d]
3788   1B6D 38 00 00      mov c, 0
3789   1B70 11            mov a, b
3790   1B71 FD 77         inc b
3791   1B73 FA F8 FF      lea d, [bp + -8] ; $len
3792   1B76 FD 43         mov [d], b
3793   1B78 27            mov b, a
3794   1B79 0A CB 1B      jmp _if51_exit
3795   1B7C             _if51_else:
3796   1B7C             ; if (num == 0) { 
3797   1B7C             _if52_cond:
3798   1B7C FA 07 00      lea d, [bp + 7] ; $num
3799   1B7F 2A            mov b, [d]
3800   1B80 38 00 00      mov c, 0
3801   1B83             ; --- START RELATIONAL
3802   1B83 D7            push a
3803   1B84 11            mov a, b
3804   1B85 FD 2E 00 00   mov32 cb, $00000000
3804   1B89 00 00 
3805   1B8B B0            cmp a, b
3806   1B8C FD 71         seq ; ==
3807   1B8E E4            pop a
3808   1B8F             ; --- END RELATIONAL
3809   1B8F C0 00 00      cmp b, 0
3810   1B92 C6 CB 1B      je _if52_exit
3811   1B95             _if52_TRUE:
3812   1B95             ; *dest++ = '0'; 
3813   1B95 FA 05 00      lea d, [bp + 5] ; $dest
3814   1B98 2A            mov b, [d]
3815   1B99 38 00 00      mov c, 0
3816   1B9C FD 77         inc b
3817   1B9E FA 05 00      lea d, [bp + 5] ; $dest
3818   1BA1 FD 43         mov [d], b
3819   1BA3 FD 7D         dec b
3820   1BA5 D8            push b
3821   1BA6 FD 2E 30 00   mov32 cb, $00000030
3821   1BAA 00 00 
3822   1BAC E7            pop d
3823   1BAD FD 3E         mov [d], bl
3824   1BAF             ; *dest = '\0'; 
3825   1BAF FA 05 00      lea d, [bp + 5] ; $dest
3826   1BB2 2A            mov b, [d]
3827   1BB3 38 00 00      mov c, 0
3828   1BB6 D8            push b
3829   1BB7 FD 2E 00 00   mov32 cb, $00000000
3829   1BBB 00 00 
3830   1BBD E7            pop d
3831   1BBE FD 3E         mov [d], bl
3832   1BC0             ; return 1; 
3833   1BC0 FD 2E 01 00   mov32 cb, $00000001
3833   1BC4 00 00 
3834   1BC6 F9            leave
3835   1BC7 09            ret
3836   1BC8 0A CB 1B      jmp _if52_exit
3837   1BCB             _if52_exit:
3838   1BCB             _if51_exit:
3839   1BCB             ; while (num > 0) { 
3840   1BCB             _while53_cond:
3841   1BCB FA 07 00      lea d, [bp + 7] ; $num
3842   1BCE 2A            mov b, [d]
3843   1BCF 38 00 00      mov c, 0
3844   1BD2             ; --- START RELATIONAL
3845   1BD2 D7            push a
3846   1BD3 11            mov a, b
3847   1BD4 FD 2E 00 00   mov32 cb, $00000000
3847   1BD8 00 00 
3848   1BDA B0            cmp a, b
3849   1BDB FD 7F         sgt ; >
3850   1BDD E4            pop a
3851   1BDE             ; --- END RELATIONAL
3852   1BDE C0 00 00      cmp b, 0
3853   1BE1 C6 40 1C      je _while53_exit
3854   1BE4             _while53_block:
3855   1BE4             ; digits[i] = '0' + (num % 10); 
3856   1BE4 FA FC FF      lea d, [bp + -4] ; $digits
3857   1BE7 D7            push a
3858   1BE8 DA            push d
3859   1BE9 FA FA FF      lea d, [bp + -6] ; $i
3860   1BEC 2A            mov b, [d]
3861   1BED 38 00 00      mov c, 0
3862   1BF0 E7            pop d
3863   1BF1 5A            add d, b
3864   1BF2 E4            pop a
3865   1BF3 DA            push d
3866   1BF4 FD 2E 30 00   mov32 cb, $00000030
3866   1BF8 00 00 
3867   1BFA             ; --- START TERMS
3868   1BFA D7            push a
3869   1BFB 11            mov a, b
3870   1BFC FA 07 00      lea d, [bp + 7] ; $num
3871   1BFF 2A            mov b, [d]
3872   1C00 38 00 00      mov c, 0
3873   1C03             ; --- START FACTORS
3874   1C03 D7            push a
3875   1C04 11            mov a, b
3876   1C05 FD 2E 0A 00   mov32 cb, $0000000a
3876   1C09 00 00 
3877   1C0B AE            div a, b ; 
3878   1C0C 11            mov a, b
3879   1C0D 27            mov b, a
3880   1C0E E4            pop a
3881   1C0F             ; --- END FACTORS
3882   1C0F 56            add b, a
3883   1C10 E4            pop a
3884   1C11             ; --- END TERMS
3885   1C11 E7            pop d
3886   1C12 FD 3E         mov [d], bl
3887   1C14             ; num = num / 10; 
3888   1C14 FA 07 00      lea d, [bp + 7] ; $num
3889   1C17 DA            push d
3890   1C18 FA 07 00      lea d, [bp + 7] ; $num
3891   1C1B 2A            mov b, [d]
3892   1C1C 38 00 00      mov c, 0
3893   1C1F             ; --- START FACTORS
3894   1C1F D7            push a
3895   1C20 11            mov a, b
3896   1C21 FD 2E 0A 00   mov32 cb, $0000000a
3896   1C25 00 00 
3897   1C27 AE            div a, b
3898   1C28 27            mov b, a
3899   1C29 E4            pop a
3900   1C2A             ; --- END FACTORS
3901   1C2A E7            pop d
3902   1C2B FD 43         mov [d], b
3903   1C2D             ; i++; 
3904   1C2D FA FA FF      lea d, [bp + -6] ; $i
3905   1C30 2A            mov b, [d]
3906   1C31 38 00 00      mov c, 0
3907   1C34 11            mov a, b
3908   1C35 FD 77         inc b
3909   1C37 FA FA FF      lea d, [bp + -6] ; $i
3910   1C3A FD 43         mov [d], b
3911   1C3C 27            mov b, a
3912   1C3D 0A CB 1B      jmp _while53_cond
3913   1C40             _while53_exit:
3914   1C40             ; while (i > 0) { 
3915   1C40             _while54_cond:
3916   1C40 FA FA FF      lea d, [bp + -6] ; $i
3917   1C43 2A            mov b, [d]
3918   1C44 38 00 00      mov c, 0
3919   1C47             ; --- START RELATIONAL
3920   1C47 D7            push a
3921   1C48 11            mov a, b
3922   1C49 FD 2E 00 00   mov32 cb, $00000000
3922   1C4D 00 00 
3923   1C4F B0            cmp a, b
3924   1C50 FD 7F         sgt ; >
3925   1C52 E4            pop a
3926   1C53             ; --- END RELATIONAL
3927   1C53 C0 00 00      cmp b, 0
3928   1C56 C6 A5 1C      je _while54_exit
3929   1C59             _while54_block:
3930   1C59             ; i--; 
3931   1C59 FA FA FF      lea d, [bp + -6] ; $i
3932   1C5C 2A            mov b, [d]
3933   1C5D 38 00 00      mov c, 0
3934   1C60 11            mov a, b
3935   1C61 FD 7D         dec b
3936   1C63 FA FA FF      lea d, [bp + -6] ; $i
3937   1C66 FD 43         mov [d], b
3938   1C68 27            mov b, a
3939   1C69             ; *dest++ = digits[i]; 
3940   1C69 FA 05 00      lea d, [bp + 5] ; $dest
3941   1C6C 2A            mov b, [d]
3942   1C6D 38 00 00      mov c, 0
3943   1C70 FD 77         inc b
3944   1C72 FA 05 00      lea d, [bp + 5] ; $dest
3945   1C75 FD 43         mov [d], b
3946   1C77 FD 7D         dec b
3947   1C79 D8            push b
3948   1C7A FA FC FF      lea d, [bp + -4] ; $digits
3949   1C7D D7            push a
3950   1C7E DA            push d
3951   1C7F FA FA FF      lea d, [bp + -6] ; $i
3952   1C82 2A            mov b, [d]
3953   1C83 38 00 00      mov c, 0
3954   1C86 E7            pop d
3955   1C87 5A            add d, b
3956   1C88 E4            pop a
3957   1C89 32            mov bl, [d]
3958   1C8A A7 00         mov bh, 0
3959   1C8C 38 00 00      mov c, 0
3960   1C8F E7            pop d
3961   1C90 FD 3E         mov [d], bl
3962   1C92             ; len++; 
3963   1C92 FA F8 FF      lea d, [bp + -8] ; $len
3964   1C95 2A            mov b, [d]
3965   1C96 38 00 00      mov c, 0
3966   1C99 11            mov a, b
3967   1C9A FD 77         inc b
3968   1C9C FA F8 FF      lea d, [bp + -8] ; $len
3969   1C9F FD 43         mov [d], b
3970   1CA1 27            mov b, a
3971   1CA2 0A 40 1C      jmp _while54_cond
3972   1CA5             _while54_exit:
3973   1CA5             ; *dest = '\0'; 
3974   1CA5 FA 05 00      lea d, [bp + 5] ; $dest
3975   1CA8 2A            mov b, [d]
3976   1CA9 38 00 00      mov c, 0
3977   1CAC D8            push b
3978   1CAD FD 2E 00 00   mov32 cb, $00000000
3978   1CB1 00 00 
3979   1CB3 E7            pop d
3980   1CB4 FD 3E         mov [d], bl
3981   1CB6             ; return len; 
3982   1CB6 FA F8 FF      lea d, [bp + -8] ; $len
3983   1CB9 2A            mov b, [d]
3984   1CBA 38 00 00      mov c, 0
3985   1CBD F9            leave
3986   1CBE 09            ret
3987   1CBF             
3988   1CBF             date:
3989   1CBF F8 00 00      enter 0 ; (push bp; mov bp, sp)
3990   1CC2             
3991   1CC2             ; --- BEGIN INLINE ASM SEGMENT
3992   1CC2 19 00         mov al, 0 
3993   1CC4 05 07         syscall sys_datetime
3994   1CC6             ; --- END INLINE ASM SEGMENT
3995   1CC6             
3996   1CC6 F9            leave
3997   1CC7 09            ret
3998   1CC8             
3999   1CC8             putchar:
4000   1CC8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4001   1CCB             
4002   1CCB             ; --- BEGIN INLINE ASM SEGMENT
4003   1CCB FA 05 00      lea d, [bp + 5] ; $c
4004   1CCE 1E            mov al, [d]
4005   1CCF 23            mov ah, al
4006   1CD0 07 D7 1E      call _putchar
4007   1CD3             ; --- END INLINE ASM SEGMENT
4008   1CD3             
4009   1CD3 F9            leave
4010   1CD4 09            ret
4011   1CD5             
4012   1CD5             getchar:
4013   1CD5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4014   1CD8             ; char c; 
4015   1CD8 52 01 00      sub sp, 1
4016   1CDB             
4017   1CDB             ; --- BEGIN INLINE ASM SEGMENT
4018   1CDB 07 D0 1E      call getch
4019   1CDE 1A            mov al, ah
4020   1CDF FA 00 00      lea d, [bp + 0] ; $c
4021   1CE2 3E            mov [d], al
4022   1CE3             ; --- END INLINE ASM SEGMENT
4023   1CE3             
4024   1CE3             ; return c; 
4025   1CE3 FA 00 00      lea d, [bp + 0] ; $c
4026   1CE6 32            mov bl, [d]
4027   1CE7 A7 00         mov bh, 0
4028   1CE9 38 00 00      mov c, 0
4029   1CEC F9            leave
4030   1CED 09            ret
4031   1CEE             
4032   1CEE             scann:
4033   1CEE F8 00 00      enter 0 ; (push bp; mov bp, sp)
4034   1CF1             ; int m; 
4035   1CF1 52 02 00      sub sp, 2
4036   1CF4             
4037   1CF4             ; --- BEGIN INLINE ASM SEGMENT
4038   1CF4 07 1B 21      call scan_u16d
4039   1CF7 FA FF FF      lea d, [bp + -1] ; $m
4040   1CFA 43            mov [d], a
4041   1CFB             ; --- END INLINE ASM SEGMENT
4042   1CFB             
4043   1CFB             ; return m; 
4044   1CFB FA FF FF      lea d, [bp + -1] ; $m
4045   1CFE 2A            mov b, [d]
4046   1CFF 38 00 00      mov c, 0
4047   1D02 F9            leave
4048   1D03 09            ret
4049   1D04             
4050   1D04             puts:
4051   1D04 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4052   1D07             
4053   1D07             ; --- BEGIN INLINE ASM SEGMENT
4054   1D07 FA 05 00      lea d, [bp + 5] ; $s
4055   1D0A 15            mov a, [d]
4056   1D0B 3C            mov d, a
4057   1D0C 07 21 20      call _puts
4058   1D0F 10 00 0A      mov a, $0A00
4059   1D12 05 03         syscall sys_io
4060   1D14             ; --- END INLINE ASM SEGMENT
4061   1D14             
4062   1D14 F9            leave
4063   1D15 09            ret
4064   1D16             
4065   1D16             print:
4066   1D16 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4067   1D19             
4068   1D19             ; --- BEGIN INLINE ASM SEGMENT
4069   1D19 FA 05 00      lea d, [bp + 5] ; $s
4070   1D1C FD 2A         mov d, [d]
4071   1D1E 07 21 20      call _puts
4072   1D21             ; --- END INLINE ASM SEGMENT
4073   1D21             
4074   1D21 F9            leave
4075   1D22 09            ret
4076   1D23             
4077   1D23             getparam:
4078   1D23 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4079   1D26             ; char data; 
4080   1D26 52 01 00      sub sp, 1
4081   1D29             
4082   1D29             ; --- BEGIN INLINE ASM SEGMENT
4083   1D29 19 04         mov al, 4
4084   1D2B FA 05 00      lea d, [bp + 5] ; $address
4085   1D2E FD 2A         mov d, [d]
4086   1D30 05 0C         syscall sys_system
4087   1D32 FA 00 00      lea d, [bp + 0] ; $data
4088   1D35 FD 3E         mov [d], bl
4089   1D37             ; --- END INLINE ASM SEGMENT
4090   1D37             
4091   1D37             ; return data; 
4092   1D37 FA 00 00      lea d, [bp + 0] ; $data
4093   1D3A 32            mov bl, [d]
4094   1D3B A7 00         mov bh, 0
4095   1D3D 38 00 00      mov c, 0
4096   1D40 F9            leave
4097   1D41 09            ret
4098   1D42             
4099   1D42             clear:
4100   1D42 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4101   1D45             ; print("\033[2J\033[H"); 
4102   1D45             ; --- START FUNCTION CALL
4103   1D45 26 C2 21      mov b, _s3 ; "\033[2J\033[H"
4104   1D48 FD AB         swp b
4105   1D4A D8            push b
4106   1D4B 07 16 1D      call print
4107   1D4E 51 02 00      add sp, 2
4108   1D51             ; --- END FUNCTION CALL
4109   1D51 F9            leave
4110   1D52 09            ret
4111   1D53             
4112   1D53             abs:
4113   1D53 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4114   1D56             ; return i < 0 ? -i : i; 
4115   1D56             _ternary55_cond:
4116   1D56 FA 05 00      lea d, [bp + 5] ; $i
4117   1D59 2A            mov b, [d]
4118   1D5A 38 00 00      mov c, 0
4119   1D5D             ; --- START RELATIONAL
4120   1D5D D7            push a
4121   1D5E 11            mov a, b
4122   1D5F FD 2E 00 00   mov32 cb, $00000000
4122   1D63 00 00 
4123   1D65 B0            cmp a, b
4124   1D66 FD 73         slt ; < (signed)
4125   1D68 E4            pop a
4126   1D69             ; --- END RELATIONAL
4127   1D69 C0 00 00      cmp b, 0
4128   1D6C C6 7B 1D      je _ternary55_FALSE
4129   1D6F             _ternary55_TRUE:
4130   1D6F FA 05 00      lea d, [bp + 5] ; $i
4131   1D72 2A            mov b, [d]
4132   1D73 38 00 00      mov c, 0
4133   1D76 FD 97         neg b
4134   1D78 0A 82 1D      jmp _ternary55_exit
4135   1D7B             _ternary55_FALSE:
4136   1D7B FA 05 00      lea d, [bp + 5] ; $i
4137   1D7E 2A            mov b, [d]
4138   1D7F 38 00 00      mov c, 0
4139   1D82             _ternary55_exit:
4140   1D82 F9            leave
4141   1D83 09            ret
4142   1D84             
4143   1D84             loadfile:
4144   1D84 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4145   1D87             
4146   1D87             ; --- BEGIN INLINE ASM SEGMENT
4147   1D87 FA 07 00      lea d, [bp + 7] ; $destination
4148   1D8A 15            mov a, [d]
4149   1D8B 4F            mov di, a
4150   1D8C FA 05 00      lea d, [bp + 5] ; $filename
4151   1D8F FD 2A         mov d, [d]
4152   1D91 19 14         mov al, 20
4153   1D93 05 04         syscall sys_filesystem
4154   1D95             ; --- END INLINE ASM SEGMENT
4155   1D95             
4156   1D95 F9            leave
4157   1D96 09            ret
4158   1D97             
4159   1D97             create_file:
4160   1D97 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4161   1D9A F9            leave
4162   1D9B 09            ret
4163   1D9C             
4164   1D9C             delete_file:
4165   1D9C F8 00 00      enter 0 ; (push bp; mov bp, sp)
4166   1D9F             
4167   1D9F             ; --- BEGIN INLINE ASM SEGMENT
4168   1D9F FA 05 00      lea d, [bp + 5] ; $filename
4169   1DA2 19 0A         mov al, 10
4170   1DA4 05 04         syscall sys_filesystem
4171   1DA6             ; --- END INLINE ASM SEGMENT
4172   1DA6             
4173   1DA6 F9            leave
4174   1DA7 09            ret
4175   1DA8             
4176   1DA8             load_hex:
4177   1DA8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4178   1DAB             ; char *temp; 
4179   1DAB 52 02 00      sub sp, 2
4180   1DAE             ; temp = alloc(32768); 
4181   1DAE FA FF FF      lea d, [bp + -1] ; $temp
4182   1DB1 DA            push d
4183   1DB2             ; --- START FUNCTION CALL
4184   1DB2 FD 2E 00 80   mov32 cb, $00008000
4184   1DB6 00 00 
4185   1DB8 FD AB         swp b
4186   1DBA D8            push b
4187   1DBB 07 81 08      call alloc
4188   1DBE 51 02 00      add sp, 2
4189   1DC1             ; --- END FUNCTION CALL
4190   1DC1 E7            pop d
4191   1DC2 FD 43         mov [d], b
4192   1DC4             
4193   1DC4             ; --- BEGIN INLINE ASM SEGMENT
4194   1DC4               
4195   1DC4               
4196   1DC4               
4197   1DC4             _load_hex:
4198   1DC4 FA 05 00      lea d, [bp + 5] ; $destination
4199   1DC7 FD 2A         mov d, [d]
4200   1DC9 FD 50         mov di, d
4201   1DCB FA FF FF      lea d, [bp + -1] ; $temp
4202   1DCE FD 2A         mov d, [d]
4203   1DD0 38 00 00      mov c, 0
4204   1DD3 48            mov a, sp
4205   1DD4 77            inc a
4206   1DD5 3C            mov d, a          
4207   1DD6 07 DE 1E      call _gets        
4208   1DD9 4D            mov si, a
4209   1DDA             __load_hex_loop:
4210   1DDA F6            lodsb             
4211   1DDB B9 00         cmp al, 0         
4212   1DDD C6 EB 1D      jz __load_hex_ret
4213   1DE0 36            mov bh, al
4214   1DE1 F6            lodsb
4215   1DE2 2F            mov bl, al
4216   1DE3 07 95 1E      call _atoi        
4217   1DE6 F7            stosb             
4218   1DE7 78            inc c
4219   1DE8 0A DA 1D      jmp __load_hex_loop
4220   1DEB             __load_hex_ret:
4221   1DEB             ; --- END INLINE ASM SEGMENT
4222   1DEB             
4223   1DEB F9            leave
4224   1DEC 09            ret
4225   1DED             
4226   1DED             include_stdio_asm:
4227   1DED F8 00 00      enter 0 ; (push bp; mov bp, sp)
4228   1DF0             
4229   1DF0             ; --- BEGIN INLINE ASM SEGMENT
4230   1DF0             .include "lib/asm/stdio.asm"
0001+  1DF0             ;-----------------------------------------------------------------------------
0002+  1DF0             ; stdio.s
0003+  1DF0             ;-----------------------------------------------------------------------------
0004+  1DF0             .include "lib/asm/string.asm"
0001++ 1DF0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 1DF0             ; string.s
0003++ 1DF0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 1DF0             
0005++ 1DF0             
0006++ 1DF0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 1DF0             ; _strrev
0008++ 1DF0             ; reverse a string
0009++ 1DF0             ; D = string address
0010++ 1DF0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 1DF0             ; 01234
0012++ 1DF0             _strrev:
0013++ 1DF0 4B          	pusha
0014++ 1DF1 07 37 1E    	call _strlen	; length in C
0015++ 1DF4 12          	mov a, c
0016++ 1DF5 AF 01 00    	cmp a, 1
0017++ 1DF8 D0 12 1E    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 1DFB 7D          	dec a
0019++ 1DFC FD 4E       	mov si, d	; beginning of string
0020++ 1DFE FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 1E00 59          	add d, a	; end of string
0022++ 1E01 12          	mov a, c
0023++ 1E02 FD 9B       	shr a		; divide by 2
0024++ 1E04 39          	mov c, a	; C now counts the steps
0025++ 1E05             _strrev_L0:
0026++ 1E05 32          	mov bl, [d]	; save load right-side char into BL
0027++ 1E06 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 1E07 3E          	mov [d], al	; store left char into right side
0029++ 1E08 1B          	mov al, bl
0030++ 1E09 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 1E0A 7E          	dec c
0032++ 1E0B 7F          	dec d
0033++ 1E0C C2 00 00    	cmp c, 0
0034++ 1E0F C7 05 1E    	jne _strrev_L0
0035++ 1E12             _strrev_end:
0036++ 1E12 4C          	popa
0037++ 1E13 09          	ret
0038++ 1E14             	
0039++ 1E14             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 1E14             ; _strchr
0041++ 1E14             ; search string in D for char in AL
0042++ 1E14             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 1E14             _strchr:
0044++ 1E14             _strchr_L0:
0045++ 1E14 32          	mov bl, [d]
0046++ 1E15 C1 00       	cmp bl, 0
0047++ 1E17 C6 22 1E    	je _strchr_end
0048++ 1E1A BA          	cmp al, bl
0049++ 1E1B C6 22 1E    	je _strchr_end
0050++ 1E1E 79          	inc d
0051++ 1E1F 0A 14 1E    	jmp _strchr_L0
0052++ 1E22             _strchr_end:
0053++ 1E22 1B          	mov al, bl
0054++ 1E23 09          	ret
0055++ 1E24             
0056++ 1E24             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 1E24             ; _strstr
0058++ 1E24             ; find sub-string
0059++ 1E24             ; str1 in SI
0060++ 1E24             ; str2 in DI
0061++ 1E24             ; SI points to end of source string
0062++ 1E24             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 1E24             _strstr:
0064++ 1E24 DB          	push al
0065++ 1E25 DA          	push d
0066++ 1E26 E3          	push di
0067++ 1E27             _strstr_loop:
0068++ 1E27 F3          	cmpsb					; compare a byte of the strings
0069++ 1E28 C7 33 1E    	jne _strstr_ret
0070++ 1E2B FC 00 00    	lea d, [di + 0]
0071++ 1E2E BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1E30 C7 27 1E    	jne _strstr_loop				; equal chars but not at end
0073++ 1E33             _strstr_ret:
0074++ 1E33 F0          	pop di
0075++ 1E34 E7          	pop d
0076++ 1E35 E8          	pop al
0077++ 1E36 09          	ret
0078++ 1E37             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1E37             ; length of null terminated string
0080++ 1E37             ; result in C
0081++ 1E37             ; pointer in D
0082++ 1E37             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1E37             _strlen:
0084++ 1E37 DA          	push d
0085++ 1E38 38 00 00    	mov c, 0
0086++ 1E3B             _strlen_L1:
0087++ 1E3B BD 00       	cmp byte [d], 0
0088++ 1E3D C6 45 1E    	je _strlen_ret
0089++ 1E40 79          	inc d
0090++ 1E41 78          	inc c
0091++ 1E42 0A 3B 1E    	jmp _strlen_L1
0092++ 1E45             _strlen_ret:
0093++ 1E45 E7          	pop d
0094++ 1E46 09          	ret
0095++ 1E47             
0096++ 1E47             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1E47             ; STRCMP
0098++ 1E47             ; compare two strings
0099++ 1E47             ; str1 in SI
0100++ 1E47             ; str2 in DI
0101++ 1E47             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 1E47             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1E47             _strcmp:
0104++ 1E47 DB          	push al
0105++ 1E48 DA          	push d
0106++ 1E49 E3          	push di
0107++ 1E4A E2          	push si
0108++ 1E4B             _strcmp_loop:
0109++ 1E4B F3          	cmpsb					; compare a byte of the strings
0110++ 1E4C C7 57 1E    	jne _strcmp_ret
0111++ 1E4F FB FF FF    	lea d, [si +- 1]
0112++ 1E52 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1E54 C7 4B 1E    	jne _strcmp_loop				; equal chars but not at end
0114++ 1E57             _strcmp_ret:
0115++ 1E57 EF          	pop si
0116++ 1E58 F0          	pop di
0117++ 1E59 E7          	pop d
0118++ 1E5A E8          	pop al
0119++ 1E5B 09          	ret
0120++ 1E5C             
0121++ 1E5C             
0122++ 1E5C             ; STRCPY
0123++ 1E5C             ; copy null terminated string from SI to DI
0124++ 1E5C             ; source in SI
0125++ 1E5C             ; destination in DI
0126++ 1E5C             _strcpy:
0127++ 1E5C E2          	push si
0128++ 1E5D E3          	push di
0129++ 1E5E DB          	push al
0130++ 1E5F             _strcpy_L1:
0131++ 1E5F F6          	lodsb
0132++ 1E60 F7          	stosb
0133++ 1E61 B9 00       	cmp al, 0
0134++ 1E63 C7 5F 1E    	jne _strcpy_L1
0135++ 1E66             _strcpy_end:
0136++ 1E66 E8          	pop al
0137++ 1E67 F0          	pop di
0138++ 1E68 EF          	pop si
0139++ 1E69 09          	ret
0140++ 1E6A             
0141++ 1E6A             ; STRCAT
0142++ 1E6A             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 1E6A             ; source in SI
0144++ 1E6A             ; destination in DI
0145++ 1E6A             _strcat:
0146++ 1E6A E2          	push si
0147++ 1E6B E3          	push di
0148++ 1E6C D7          	push a
0149++ 1E6D DA          	push d
0150++ 1E6E 50          	mov a, di
0151++ 1E6F 3C          	mov d, a
0152++ 1E70             _strcat_goto_end_L1:
0153++ 1E70 BD 00       	cmp byte[d], 0
0154++ 1E72 C6 79 1E    	je _strcat_start
0155++ 1E75 79          	inc d
0156++ 1E76 0A 70 1E    	jmp _strcat_goto_end_L1
0157++ 1E79             _strcat_start:
0158++ 1E79 FD 50       	mov di, d
0159++ 1E7B             _strcat_L1:
0160++ 1E7B F6          	lodsb
0161++ 1E7C F7          	stosb
0162++ 1E7D B9 00       	cmp al, 0
0163++ 1E7F C7 7B 1E    	jne _strcat_L1
0164++ 1E82             _strcat_end:
0165++ 1E82 E7          	pop d
0166++ 1E83 E4          	pop a
0167++ 1E84 F0          	pop di
0168++ 1E85 EF          	pop si
0169++ 1E86 09          	ret
0170++ 1E87             
0171++ 1E87             
0005+  1E87             
0006+  1E87             ;-----------------------------------------------------------------------------
0007+  1E87             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0008+  1E87             ; ASCII in BL
0009+  1E87             ; result in AL
0010+  1E87             ; ascii for F = 0100 0110
0011+  1E87             ; ascii for 9 = 0011 1001
0012+  1E87             ;-----------------------------------------------------------------------------
0013+  1E87             hex_ascii_encode:
0014+  1E87 1B            mov al, bl
0015+  1E88 93 40         test al, $40        ; test if letter or number
0016+  1E8A C7 90 1E      jnz hex_letter
0017+  1E8D 87 0F         and al, $0F        ; get number
0018+  1E8F 09            ret
0019+  1E90             hex_letter:
0020+  1E90 87 0F         and al, $0F        ; get letter
0021+  1E92 6A 09         add al, 9
0022+  1E94 09            ret
0023+  1E95             
0024+  1E95             ;-----------------------------------------------------------------------------
0025+  1E95             ; ATOI
0026+  1E95             ; 2 letter hex string in B
0027+  1E95             ; 8bit integer returned in AL
0028+  1E95             ;-----------------------------------------------------------------------------
0029+  1E95             _atoi:
0030+  1E95 D8            push b
0031+  1E96 07 87 1E      call hex_ascii_encode      ; convert BL to 4bit code in AL
0032+  1E99 30            mov bl, bh
0033+  1E9A DB            push al          ; save a
0034+  1E9B 07 87 1E      call hex_ascii_encode
0035+  1E9E EA            pop bl  
0036+  1E9F FD 9E 04      shl al, 4
0037+  1EA2 8C            or al, bl
0038+  1EA3 E5            pop b
0039+  1EA4 09            ret  
0040+  1EA5             
0041+  1EA5             
0042+  1EA5             ;-----------------------------------------------------------------------------
0043+  1EA5             ; ITOA
0044+  1EA5             ; 8bit value in BL
0045+  1EA5             ; 2 byte ASCII result in A
0046+  1EA5             ;-----------------------------------------------------------------------------
0047+  1EA5             _itoa:
0048+  1EA5 DA            push d
0049+  1EA6 D8            push b
0050+  1EA7 A7 00         mov bh, 0
0051+  1EA9 FD A4 04      shr bl, 4  
0052+  1EAC 74            mov d, b
0053+  1EAD 1F 55 21      mov al, [d + s_hex_digits]
0054+  1EB0 23            mov ah, al
0055+  1EB1               
0056+  1EB1 E5            pop b
0057+  1EB2 D8            push b
0058+  1EB3 A7 00         mov bh, 0
0059+  1EB5 FD 87 0F      and bl, $0F
0060+  1EB8 74            mov d, b
0061+  1EB9 1F 55 21      mov al, [d + s_hex_digits]
0062+  1EBC E5            pop b
0063+  1EBD E7            pop d
0064+  1EBE 09            ret
0065+  1EBF             
0066+  1EBF             ;-----------------------------------------------------------------------------
0067+  1EBF             ; HEX STRING TO BINARY
0068+  1EBF             ; di = destination address
0069+  1EBF             ; si = source
0070+  1EBF             ;-----------------------------------------------------------------------------
0071+  1EBF             _hex_to_int:
0072+  1EBF             _hex_to_int_L1:
0073+  1EBF F6            lodsb          ; load from [SI] to AL
0074+  1EC0 B9 00         cmp al, 0        ; check if ASCII 0
0075+  1EC2 C6 CF 1E      jz _hex_to_int_ret
0076+  1EC5 36            mov bh, al
0077+  1EC6 F6            lodsb
0078+  1EC7 2F            mov bl, al
0079+  1EC8 07 95 1E      call _atoi        ; convert ASCII byte in B to int (to AL)
0080+  1ECB F7            stosb          ; store AL to [DI]
0081+  1ECC 0A BF 1E      jmp _hex_to_int_L1
0082+  1ECF             _hex_to_int_ret:
0083+  1ECF 09            ret    
0084+  1ED0             
0085+  1ED0             ;-----------------------------------------------------------------------------
0086+  1ED0             ; GETCHAR
0087+  1ED0             ; char in ah
0088+  1ED0             ;-----------------------------------------------------------------------------
0089+  1ED0             getch:
0090+  1ED0 DB            push al
0091+  1ED1             getch_retry:
0092+  1ED1 19 01         mov al, 1
0093+  1ED3 05 03         syscall sys_io      ; receive in AH
0094+  1ED5 E8            pop al
0095+  1ED6 09            ret
0096+  1ED7             
0097+  1ED7             ;-----------------------------------------------------------------------------
0098+  1ED7             ; PUTCHAR
0099+  1ED7             ; char in ah
0100+  1ED7             ;-----------------------------------------------------------------------------
0101+  1ED7             _putchar:
0102+  1ED7 D7            push a
0103+  1ED8 19 00         mov al, 0
0104+  1EDA 05 03         syscall sys_io      ; char in AH
0105+  1EDC E4            pop a
0106+  1EDD 09            ret
0107+  1EDE             
0108+  1EDE             ;-----------------------------------------------------------------------------
0109+  1EDE             ;; INPUT A STRING
0110+  1EDE             ;; terminates with null
0111+  1EDE             ;; pointer in D
0112+  1EDE             ;-----------------------------------------------------------------------------
0113+  1EDE             _gets:
0114+  1EDE D7            push a
0115+  1EDF DA            push d
0116+  1EE0             _gets_loop:
0117+  1EE0 19 01         mov al, 1
0118+  1EE2 05 03         syscall sys_io      ; receive in AH
0119+  1EE4 B9 00         cmp al, 0        ; check error code (AL)
0120+  1EE6 C6 E0 1E      je _gets_loop      ; if no char received, retry
0121+  1EE9             
0122+  1EE9 76 1B         cmp ah, 27
0123+  1EEB C6 0C 1F      je _gets_ansi_esc
0124+  1EEE 76 0A         cmp ah, $0A        ; LF
0125+  1EF0 C6 77 1F      je _gets_end
0126+  1EF3 76 0D         cmp ah, $0D        ; CR
0127+  1EF5 C6 77 1F      je _gets_end
0128+  1EF8 76 5C         cmp ah, $5C        ; '\\'
0129+  1EFA C6 38 1F      je _gets_escape
0130+  1EFD               
0131+  1EFD 76 08         cmp ah, $08      ; check for backspace
0132+  1EFF C6 08 1F      je _gets_backspace
0133+  1F02             
0134+  1F02 1A            mov al, ah
0135+  1F03 3E            mov [d], al
0136+  1F04 79            inc d
0137+  1F05 0A E0 1E      jmp _gets_loop
0138+  1F08             _gets_backspace:
0139+  1F08 7F            dec d
0140+  1F09 0A E0 1E      jmp _gets_loop
0141+  1F0C             _gets_ansi_esc:
0142+  1F0C 19 01         mov al, 1
0143+  1F0E 05 03         syscall sys_io        ; receive in AH without echo
0144+  1F10 B9 00         cmp al, 0          ; check error code (AL)
0145+  1F12 C6 0C 1F      je _gets_ansi_esc    ; if no char received, retry
0146+  1F15 76 5B         cmp ah, '['
0147+  1F17 C7 E0 1E      jne _gets_loop
0148+  1F1A             _gets_ansi_esc_2:
0149+  1F1A 19 01         mov al, 1
0150+  1F1C 05 03         syscall sys_io          ; receive in AH without echo
0151+  1F1E B9 00         cmp al, 0            ; check error code (AL)
0152+  1F20 C6 1A 1F      je _gets_ansi_esc_2  ; if no char received, retry
0153+  1F23 76 44         cmp ah, 'D'
0154+  1F25 C6 30 1F      je _gets_left_arrow
0155+  1F28 76 43         cmp ah, 'C'
0156+  1F2A C6 34 1F      je _gets_right_arrow
0157+  1F2D 0A E0 1E      jmp _gets_loop
0158+  1F30             _gets_left_arrow:
0159+  1F30 7F            dec d
0160+  1F31 0A E0 1E      jmp _gets_loop
0161+  1F34             _gets_right_arrow:
0162+  1F34 79            inc d
0163+  1F35 0A E0 1E      jmp _gets_loop
0164+  1F38             _gets_escape:
0165+  1F38 19 01         mov al, 1
0166+  1F3A 05 03         syscall sys_io      ; receive in AH
0167+  1F3C B9 00         cmp al, 0        ; check error code (AL)
0168+  1F3E C6 38 1F      je _gets_escape      ; if no char received, retry
0169+  1F41 76 6E         cmp ah, 'n'
0170+  1F43 C6 62 1F      je _gets_LF
0171+  1F46 76 72         cmp ah, 'r'
0172+  1F48 C6 69 1F      je _gets_CR
0173+  1F4B 76 30         cmp ah, '0'
0174+  1F4D C6 70 1F      je _gets_NULL
0175+  1F50 76 5C         cmp ah, $5C  ; '\'
0176+  1F52 C6 5B 1F      je _gets_slash
0177+  1F55 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0178+  1F56 3E            mov [d], al
0179+  1F57 79            inc d
0180+  1F58 0A E0 1E      jmp _gets_loop
0181+  1F5B             _gets_slash:
0182+  1F5B 19 5C         mov al, $5C
0183+  1F5D 3E            mov [d], al
0184+  1F5E 79            inc d
0185+  1F5F 0A E0 1E      jmp _gets_loop
0186+  1F62             _gets_LF:
0187+  1F62 19 0A         mov al, $0A
0188+  1F64 3E            mov [d], al
0189+  1F65 79            inc d
0190+  1F66 0A E0 1E      jmp _gets_loop
0191+  1F69             _gets_CR:
0192+  1F69 19 0D         mov al, $0D
0193+  1F6B 3E            mov [d], al
0194+  1F6C 79            inc d
0195+  1F6D 0A E0 1E      jmp _gets_loop
0196+  1F70             _gets_NULL:
0197+  1F70 19 00         mov al, $00
0198+  1F72 3E            mov [d], al
0199+  1F73 79            inc d
0200+  1F74 0A E0 1E      jmp _gets_loop
0201+  1F77             _gets_end:
0202+  1F77 19 00         mov al, 0
0203+  1F79 3E            mov [d], al        ; terminate string
0204+  1F7A E7            pop d
0205+  1F7B E4            pop a
0206+  1F7C 09            ret
0207+  1F7D             
0208+  1F7D             ;-----------------------------------------------------------------------------
0209+  1F7D             ;; INPUT TEXT
0210+  1F7D             ;; terminated with CTRL+D
0211+  1F7D             ;; pointer in D
0212+  1F7D             ;-----------------------------------------------------------------------------
0213+  1F7D             _gettxt:
0214+  1F7D D7            push a
0215+  1F7E DA            push d
0216+  1F7F             _gettxt_loop:
0217+  1F7F 19 01         mov al, 1
0218+  1F81 05 03         syscall sys_io      ; receive in AH
0219+  1F83 B9 00         cmp al, 0        ; check error code (AL)
0220+  1F85 C6 7F 1F      je _gettxt_loop    ; if no char received, retry
0221+  1F88 76 04         cmp ah, 4      ; EOT
0222+  1F8A C6 C8 1F      je _gettxt_end
0223+  1F8D 76 08         cmp ah, $08      ; check for backspace
0224+  1F8F C6 C4 1F      je _gettxt_backspace
0225+  1F92 76 5C         cmp ah, $5C        ; '\'
0226+  1F94 C6 9D 1F      je _gettxt_escape
0227+  1F97 1A            mov al, ah
0228+  1F98 3E            mov [d], al
0229+  1F99 79            inc d
0230+  1F9A 0A 7F 1F      jmp _gettxt_loop
0231+  1F9D             _gettxt_escape:
0232+  1F9D 19 01         mov al, 1
0233+  1F9F 05 03         syscall sys_io      ; receive in AH
0234+  1FA1 B9 00         cmp al, 0        ; check error code (AL)
0235+  1FA3 C6 9D 1F      je _gettxt_escape    ; if no char received, retry
0236+  1FA6 76 6E         cmp ah, 'n'
0237+  1FA8 C6 B6 1F      je _gettxt_LF
0238+  1FAB 76 72         cmp ah, 'r'
0239+  1FAD C6 BD 1F      je _gettxt_CR
0240+  1FB0 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0241+  1FB1 3E            mov [d], al
0242+  1FB2 79            inc d
0243+  1FB3 0A 7F 1F      jmp _gettxt_loop
0244+  1FB6             _gettxt_LF:
0245+  1FB6 19 0A         mov al, $0A
0246+  1FB8 3E            mov [d], al
0247+  1FB9 79            inc d
0248+  1FBA 0A 7F 1F      jmp _gettxt_loop
0249+  1FBD             _gettxt_CR:
0250+  1FBD 19 0D         mov al, $0D
0251+  1FBF 3E            mov [d], al
0252+  1FC0 79            inc d
0253+  1FC1 0A 7F 1F      jmp _gettxt_loop
0254+  1FC4             _gettxt_backspace:
0255+  1FC4 7F            dec d
0256+  1FC5 0A 7F 1F      jmp _gettxt_loop
0257+  1FC8             _gettxt_end:
0258+  1FC8 19 00         mov al, 0
0259+  1FCA 3E            mov [d], al        ; terminate string
0260+  1FCB E7            pop d
0261+  1FCC E4            pop a
0262+  1FCD 09            ret
0263+  1FCE             
0264+  1FCE             ;-----------------------------------------------------------------------------
0265+  1FCE             ; PRINT NEW LINE
0266+  1FCE             ;-----------------------------------------------------------------------------
0267+  1FCE             printnl:
0268+  1FCE D7            push a
0269+  1FCF 10 00 0A      mov a, $0A00
0270+  1FD2 05 03         syscall sys_io
0271+  1FD4 10 00 0D      mov a, $0D00
0272+  1FD7 05 03         syscall sys_io
0273+  1FD9 E4            pop a
0274+  1FDA 09            ret
0275+  1FDB             
0276+  1FDB             ;-----------------------------------------------------------------------------
0277+  1FDB             ; _strtoint
0278+  1FDB             ; 4 digit hex string number in d
0279+  1FDB             ; integer returned in A
0280+  1FDB             ;-----------------------------------------------------------------------------
0281+  1FDB             _strtointx:
0282+  1FDB D8            push b
0283+  1FDC 32            mov bl, [d]
0284+  1FDD 37            mov bh, bl
0285+  1FDE 33 01 00      mov bl, [d + 1]
0286+  1FE1 07 95 1E      call _atoi        ; convert to int in AL
0287+  1FE4 23            mov ah, al        ; move to AH
0288+  1FE5 33 02 00      mov bl, [d + 2]
0289+  1FE8 37            mov bh, bl
0290+  1FE9 33 03 00      mov bl, [d + 3]
0291+  1FEC 07 95 1E      call _atoi        ; convert to int in AL
0292+  1FEF E5            pop b
0293+  1FF0 09            ret
0294+  1FF1             
0295+  1FF1             ;-----------------------------------------------------------------------------
0296+  1FF1             ; _strtoint
0297+  1FF1             ; 5 digit base10 string number in d
0298+  1FF1             ; integer returned in A
0299+  1FF1             ;-----------------------------------------------------------------------------
0300+  1FF1             _strtoint:
0301+  1FF1 E2            push si
0302+  1FF2 D8            push b
0303+  1FF3 D9            push c
0304+  1FF4 DA            push d
0305+  1FF5 07 37 1E      call _strlen      ; get string length in C
0306+  1FF8 7E            dec c
0307+  1FF9 FD 4E         mov si, d
0308+  1FFB 12            mov a, c
0309+  1FFC FD 99         shl a
0310+  1FFE 3B 6D 21      mov d, table_power
0311+  2001 59            add d, a
0312+  2002 38 00 00      mov c, 0
0313+  2005             _strtoint_L0:
0314+  2005 F6            lodsb      ; load ASCII to al
0315+  2006 B9 00         cmp al, 0
0316+  2008 C6 1B 20      je _strtoint_end
0317+  200B 6F 30         sub al, $30    ; make into integer
0318+  200D 22 00         mov ah, 0
0319+  200F 2A            mov b, [d]
0320+  2010 AC            mul a, b      ; result in B since it fits in 16bits
0321+  2011 11            mov a, b
0322+  2012 28            mov b, c
0323+  2013 54            add a, b
0324+  2014 39            mov c, a
0325+  2015 63 02 00      sub d, 2
0326+  2018 0A 05 20      jmp _strtoint_L0
0327+  201B             _strtoint_end:
0328+  201B 12            mov a, c
0329+  201C E7            pop d
0330+  201D E6            pop c
0331+  201E E5            pop b
0332+  201F EF            pop si
0333+  2020 09            ret
0334+  2021             
0335+  2021             ;-----------------------------------------------------------------------------
0336+  2021             ; PRINT NULL TERMINATED STRING
0337+  2021             ; pointer in D
0338+  2021             ;-----------------------------------------------------------------------------
0339+  2021             _puts:
0340+  2021 D7            push a
0341+  2022 DA            push d
0342+  2023             _puts_L1:
0343+  2023 1E            mov al, [d]
0344+  2024 B9 00         cmp al, 0
0345+  2026 C6 32 20      jz _puts_END
0346+  2029 23            mov ah, al
0347+  202A 19 00         mov al, 0
0348+  202C 05 03         syscall sys_io
0349+  202E 79            inc d
0350+  202F 0A 23 20      jmp _puts_L1
0351+  2032             _puts_END:
0352+  2032 E7            pop d
0353+  2033 E4            pop a
0354+  2034 09            ret
0355+  2035             
0356+  2035             ;-----------------------------------------------------------------------------
0357+  2035             ; PRINT N SIZE STRING
0358+  2035             ; pointer in D
0359+  2035             ; size in C
0360+  2035             ;-----------------------------------------------------------------------------
0361+  2035             _putsn:
0362+  2035 DB            push al
0363+  2036 DA            push d
0364+  2037 D9            push c
0365+  2038             _putsn_L0:
0366+  2038 1E            mov al, [d]
0367+  2039 23            mov ah, al
0368+  203A 19 00         mov al, 0
0369+  203C 05 03         syscall sys_io
0370+  203E 79            inc d
0371+  203F 7E            dec c  
0372+  2040 C2 00 00      cmp c, 0
0373+  2043 C7 38 20      jne _putsn_L0
0374+  2046             _putsn_end:
0375+  2046 E6            pop c
0376+  2047 E7            pop d
0377+  2048 E8            pop al
0378+  2049 09            ret
0379+  204A             
0380+  204A             ;-----------------------------------------------------------------------------
0381+  204A             ; print 16bit decimal number
0382+  204A             ; input number in A
0383+  204A             ;-----------------------------------------------------------------------------
0384+  204A             print_u16d:
0385+  204A D7            push a
0386+  204B D8            push b
0387+  204C 26 10 27      mov b, 10000
0388+  204F AE            div a, b      ; get 10000's coeff.
0389+  2050 07 72 20      call print_number
0390+  2053 11            mov a, b
0391+  2054 26 E8 03      mov b, 1000
0392+  2057 AE            div a, b      ; get 1000's coeff.
0393+  2058 07 72 20      call print_number
0394+  205B 11            mov a, b
0395+  205C 26 64 00      mov b, 100
0396+  205F AE            div a, b
0397+  2060 07 72 20      call print_number
0398+  2063 11            mov a, b
0399+  2064 26 0A 00      mov b, 10
0400+  2067 AE            div a, b
0401+  2068 07 72 20      call print_number
0402+  206B 1B            mov al, bl      ; 1's coeff in bl
0403+  206C 07 72 20      call print_number
0404+  206F E5            pop b
0405+  2070 E4            pop a
0406+  2071 09            ret
0407+  2072             
0408+  2072             ;-----------------------------------------------------------------------------
0409+  2072             ; print AL
0410+  2072             ;-----------------------------------------------------------------------------
0411+  2072             print_number:
0412+  2072 6A 30         add al, $30
0413+  2074 23            mov ah, al
0414+  2075 07 D7 1E      call _putchar
0415+  2078 09            ret
0416+  2079             
0417+  2079             ;-----------------------------------------------------------------------------
0418+  2079             ; PRINT 16BIT HEX INTEGER
0419+  2079             ; integer value in reg B
0420+  2079             ;-----------------------------------------------------------------------------
0421+  2079             print_u16x:
0422+  2079 D7            push a
0423+  207A D8            push b
0424+  207B DD            push bl
0425+  207C 30            mov bl, bh
0426+  207D 07 A5 1E      call _itoa        ; convert bh to char in A
0427+  2080 2F            mov bl, al        ; save al
0428+  2081 19 00         mov al, 0
0429+  2083 05 03         syscall sys_io        ; display AH
0430+  2085 24            mov ah, bl        ; retrieve al
0431+  2086 19 00         mov al, 0
0432+  2088 05 03         syscall sys_io        ; display AL
0433+  208A             
0434+  208A EA            pop bl
0435+  208B 07 A5 1E      call _itoa        ; convert bh to char in A
0436+  208E 2F            mov bl, al        ; save al
0437+  208F 19 00         mov al, 0
0438+  2091 05 03         syscall sys_io        ; display AH
0439+  2093 24            mov ah, bl        ; retrieve al
0440+  2094 19 00         mov al, 0
0441+  2096 05 03         syscall sys_io        ; display AL
0442+  2098             
0443+  2098 E5            pop b
0444+  2099 E4            pop a
0445+  209A 09            ret
0446+  209B             
0447+  209B             ;-----------------------------------------------------------------------------
0448+  209B             ; INPUT 16BIT HEX INTEGER
0449+  209B             ; read 16bit integer into A
0450+  209B             ;-----------------------------------------------------------------------------
0451+  209B             scan_u16x:
0452+  209B F8 10 00      enter 16
0453+  209E D8            push b
0454+  209F DA            push d
0455+  20A0             
0456+  20A0 FA F1 FF      lea d, [bp + -15]
0457+  20A3 07 DE 1E      call _gets        ; get number
0458+  20A6             
0459+  20A6 32            mov bl, [d]
0460+  20A7 37            mov bh, bl
0461+  20A8 33 01 00      mov bl, [d + 1]
0462+  20AB 07 95 1E      call _atoi        ; convert to int in AL
0463+  20AE 23            mov ah, al        ; move to AH
0464+  20AF             
0465+  20AF 33 02 00      mov bl, [d + 2]
0466+  20B2 37            mov bh, bl
0467+  20B3 33 03 00      mov bl, [d + 3]
0468+  20B6 07 95 1E      call _atoi        ; convert to int in AL
0469+  20B9             
0470+  20B9 E7            pop d
0471+  20BA E5            pop b
0472+  20BB F9            leave
0473+  20BC 09            ret
0474+  20BD             
0475+  20BD             ;-----------------------------------------------------------------------------
0476+  20BD             ; PRINT 8bit HEX INTEGER
0477+  20BD             ; integer value in reg bl
0478+  20BD             ;-----------------------------------------------------------------------------
0479+  20BD             print_u8x:
0480+  20BD D7            push a
0481+  20BE DD            push bl
0482+  20BF             
0483+  20BF 07 A5 1E      call _itoa        ; convert bl to char in A
0484+  20C2 2F            mov bl, al        ; save al
0485+  20C3 19 00         mov al, 0
0486+  20C5 05 03         syscall sys_io        ; display AH
0487+  20C7 24            mov ah, bl        ; retrieve al
0488+  20C8 19 00         mov al, 0
0489+  20CA 05 03         syscall sys_io        ; display AL
0490+  20CC             
0491+  20CC EA            pop bl
0492+  20CD E4            pop a
0493+  20CE 09            ret
0494+  20CF             
0495+  20CF             ;-----------------------------------------------------------------------------
0496+  20CF             ; print 8bit decimal unsigned number
0497+  20CF             ; input number in AL
0498+  20CF             ;-----------------------------------------------------------------------------
0499+  20CF             print_u8d:
0500+  20CF D7            push a
0501+  20D0 D8            push b
0502+  20D1             
0503+  20D1 22 00         mov ah, 0
0504+  20D3 26 64 00      mov b, 100
0505+  20D6 AE            div a, b
0506+  20D7 D8            push b      ; save remainder
0507+  20D8 B9 00         cmp al, 0
0508+  20DA C6 E4 20      je skip100
0509+  20DD 6A 30         add al, $30
0510+  20DF 23            mov ah, al
0511+  20E0 19 00         mov al, 0
0512+  20E2 05 03         syscall sys_io  ; print coeff
0513+  20E4             skip100:
0514+  20E4 E4            pop a
0515+  20E5 22 00         mov ah, 0
0516+  20E7 26 0A 00      mov b, 10
0517+  20EA AE            div a, b
0518+  20EB D8            push b      ; save remainder
0519+  20EC B9 00         cmp al, 0
0520+  20EE C6 F8 20      je skip10
0521+  20F1 6A 30         add al, $30
0522+  20F3 23            mov ah, al
0523+  20F4 19 00         mov al, 0
0524+  20F6 05 03         syscall sys_io  ; print coeff
0525+  20F8             skip10:
0526+  20F8 E4            pop a
0527+  20F9 1B            mov al, bl
0528+  20FA 6A 30         add al, $30
0529+  20FC 23            mov ah, al
0530+  20FD 19 00         mov al, 0
0531+  20FF 05 03         syscall sys_io  ; print coeff
0532+  2101 E5            pop b
0533+  2102 E4            pop a
0534+  2103 09            ret
0535+  2104             
0536+  2104             ;-----------------------------------------------------------------------------
0537+  2104             ; INPUT 8BIT HEX INTEGER
0538+  2104             ; read 8bit integer into AL
0539+  2104             ;-----------------------------------------------------------------------------
0540+  2104             scan_u8x:
0541+  2104 F8 04 00      enter 4
0542+  2107 D8            push b
0543+  2108 DA            push d
0544+  2109             
0545+  2109 FA FD FF      lea d, [bp + -3]
0546+  210C 07 DE 1E      call _gets        ; get number
0547+  210F             
0548+  210F 32            mov bl, [d]
0549+  2110 37            mov bh, bl
0550+  2111 33 01 00      mov bl, [d + 1]
0551+  2114 07 95 1E      call _atoi        ; convert to int in AL
0552+  2117             
0553+  2117 E7            pop d
0554+  2118 E5            pop b
0555+  2119 F9            leave
0556+  211A 09            ret
0557+  211B             
0558+  211B             ;-----------------------------------------------------------------------------
0559+  211B             ; input decimal number
0560+  211B             ; result in A
0561+  211B             ; 655'\0'
0562+  211B             ; low--------high
0563+  211B             ;-----------------------------------------------------------------------------
0564+  211B             scan_u16d:
0565+  211B F8 08 00      enter 8
0566+  211E E2            push si
0567+  211F D8            push b
0568+  2120 D9            push c
0569+  2121 DA            push d
0570+  2122 FA F9 FF      lea d, [bp +- 7]
0571+  2125 07 DE 1E      call _gets
0572+  2128 07 37 1E      call _strlen      ; get string length in C
0573+  212B 7E            dec c
0574+  212C FD 4E         mov si, d
0575+  212E 12            mov a, c
0576+  212F FD 99         shl a
0577+  2131 3B 6D 21      mov d, table_power
0578+  2134 59            add d, a
0579+  2135 38 00 00      mov c, 0
0580+  2138             mul_loop:
0581+  2138 F6            lodsb      ; load ASCII to al
0582+  2139 B9 00         cmp al, 0
0583+  213B C6 4E 21      je mul_exit
0584+  213E 6F 30         sub al, $30    ; make into integer
0585+  2140 22 00         mov ah, 0
0586+  2142 2A            mov b, [d]
0587+  2143 AC            mul a, b      ; result in B since it fits in 16bits
0588+  2144 11            mov a, b
0589+  2145 28            mov b, c
0590+  2146 54            add a, b
0591+  2147 39            mov c, a
0592+  2148 63 02 00      sub d, 2
0593+  214B 0A 38 21      jmp mul_loop
0594+  214E             mul_exit:
0595+  214E 12            mov a, c
0596+  214F E7            pop d
0597+  2150 E6            pop c
0598+  2151 E5            pop b
0599+  2152 EF            pop si
0600+  2153 F9            leave
0601+  2154 09            ret
0602+  2155             
0603+  2155 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0603+  2159 34 35 36 37 
0603+  215D 38 39 41 42 
0603+  2161 43 44 45 46 
0604+  2165 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0604+  2169 1B 5B 48 00 
0605+  216D             
0606+  216D             table_power:
0607+  216D 01 00         .dw 1
0608+  216F 0A 00         .dw 10
0609+  2171 64 00         .dw 100
0610+  2173 E8 03         .dw 1000
0611+  2175 10 27         .dw 100004231   2177             ; --- END INLINE ASM SEGMENT
4232   2177             
4233   2177 F9            leave
4234   2178 09            ret
4235   2179             
4236   2179             myfunc:
4237   2179 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4238   217C F9            leave
4239   217D 09            ret
4240   217E             ; --- END TEXT SEGMENT
4241   217E             
4242   217E             ; --- BEGIN DATA SEGMENT
4243   217E 00 00       st_fopen_max_handle: .dw 0
4244   2180 48 65 6C 6C _s0: .db "Hello", 0
4244   2184 6F 00 
4245   2186 55 6E 65 78 _s1: .db "Unexpected format in printf.", 0
4245   218A 70 65 63 74 
4245   218E 65 64 20 66 
4245   2192 6F 72 6D 61 
4245   2196 74 20 69 6E 
4245   219A 20 70 72 69 
4245   219E 6E 74 66 2E 
4245   21A2 00 
4246   21A3 45 72 72 6F _s2: .db "Error: Unknown argument type.\n", 0
4246   21A7 72 3A 20 55 
4246   21AB 6E 6B 6E 6F 
4246   21AF 77 6E 20 61 
4246   21B3 72 67 75 6D 
4246   21B7 65 6E 74 20 
4246   21BB 74 79 70 65 
4246   21BF 2E 0A 00 
4247   21C2 1B 5B 32 4A _s3: .db "\033[2J\033[H", 0
4247   21C6 1B 5B 48 00 
4248   21CA             
4249   21CA CC 21       _heap_top: .dw _heap
4250   21CC 00          _heap: .db 0
4251   21CD             ; --- END DATA SEGMENT
4252   21CD             
4253   21CD             .end
tasm: Number of errors = 0
