0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0000             
0005   0000             ; --- BEGIN TEXT SEGMENT
0006   0400             .org text_org
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; printf("Test of 5.25 inch Floppy Drive Interface.\n"); 
0011   0408             ; --- START FUNCTION CALL
0012   0408 26 13 0D      mov b, _s0 ; "Test of 5.25 inch Floppy Drive Interface.\n"
0013   040B FD AB         swp b
0014   040D D8            push b
0015   040E 07 16 04      call printf
0016   0411 51 02 00      add sp, 2
0017   0414             ; --- END FUNCTION CALL
0018   0414 05 0B         syscall sys_terminate_proc
0019   0416             
0020   0416             printf:
0021   0416 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0022   0419             ; char *p, *format_p; 
0023   0419 52 02 00      sub sp, 2
0024   041C 52 02 00      sub sp, 2
0025   041F             ; format_p = format; 
0026   041F FA FD FF      lea d, [bp + -3] ; $format_p
0027   0422 DA            push d
0028   0423 FA 05 00      lea d, [bp + 5] ; $format
0029   0426 2A            mov b, [d]
0030   0427 38 00 00      mov c, 0
0031   042A E7            pop d
0032   042B FD 43         mov [d], b
0033   042D             ; p = &format + 2; 
0034   042D FA FF FF      lea d, [bp + -1] ; $p
0035   0430 DA            push d
0036   0431 FA 05 00      lea d, [bp + 5] ; $format
0037   0434 2D            mov b, d
0038   0435             ; --- START TERMS
0039   0435 D7            push a
0040   0436 11            mov a, b
0041   0437 FD 2E 02 00   mov32 cb, $00000002
0041   043B 00 00 
0042   043D 56            add b, a
0043   043E E4            pop a
0044   043F             ; --- END TERMS
0045   043F E7            pop d
0046   0440 FD 43         mov [d], b
0047   0442             ; for(;;){ 
0048   0442             _for1_init:
0049   0442             _for1_cond:
0050   0442             _for1_block:
0051   0442             ; if(!*format_p) break; 
0052   0442             _if2_cond:
0053   0442 FA FD FF      lea d, [bp + -3] ; $format_p
0054   0445 2A            mov b, [d]
0055   0446 38 00 00      mov c, 0
0056   0449 74            mov d, b
0057   044A 32            mov bl, [d]
0058   044B A7 00         mov bh, 0
0059   044D 38 00 00      mov c, 0
0060   0450 C0 00 00      cmp b, 0
0061   0453 FD 71         seq ; !
0062   0455 C0 00 00      cmp b, 0
0063   0458 C6 61 04      je _if2_else
0064   045B             _if2_TRUE:
0065   045B             ; break; 
0066   045B 0A 01 07      jmp _for1_exit ; for break
0067   045E 0A EE 06      jmp _if2_exit
0068   0461             _if2_else:
0069   0461             ; if(*format_p == '%'){ 
0070   0461             _if3_cond:
0071   0461 FA FD FF      lea d, [bp + -3] ; $format_p
0072   0464 2A            mov b, [d]
0073   0465 38 00 00      mov c, 0
0074   0468 74            mov d, b
0075   0469 32            mov bl, [d]
0076   046A A7 00         mov bh, 0
0077   046C 38 00 00      mov c, 0
0078   046F             ; --- START RELATIONAL
0079   046F D7            push a
0080   0470 11            mov a, b
0081   0471 FD 2E 25 00   mov32 cb, $00000025
0081   0475 00 00 
0082   0477 B0            cmp a, b
0083   0478 FD 71         seq ; ==
0084   047A E4            pop a
0085   047B             ; --- END RELATIONAL
0086   047B C0 00 00      cmp b, 0
0087   047E C6 D9 06      je _if3_else
0088   0481             _if3_TRUE:
0089   0481             ; format_p++; 
0090   0481 FA FD FF      lea d, [bp + -3] ; $format_p
0091   0484 2A            mov b, [d]
0092   0485 38 00 00      mov c, 0
0093   0488 FD 77         inc b
0094   048A FA FD FF      lea d, [bp + -3] ; $format_p
0095   048D FD 43         mov [d], b
0096   048F FD 7D         dec b
0097   0491             ; switch(*format_p){ 
0098   0491             _switch4_expr:
0099   0491 FA FD FF      lea d, [bp + -3] ; $format_p
0100   0494 2A            mov b, [d]
0101   0495 38 00 00      mov c, 0
0102   0498 74            mov d, b
0103   0499 32            mov bl, [d]
0104   049A A7 00         mov bh, 0
0105   049C 38 00 00      mov c, 0
0106   049F             _switch4_comparisons:
0107   049F C1 6C         cmp bl, $6c
0108   04A1 C6 CD 04      je _switch4_case0
0109   04A4 C1 4C         cmp bl, $4c
0110   04A6 C6 CD 04      je _switch4_case1
0111   04A9 C1 64         cmp bl, $64
0112   04AB C6 DD 05      je _switch4_case2
0113   04AE C1 69         cmp bl, $69
0114   04B0 C6 DD 05      je _switch4_case3
0115   04B3 C1 75         cmp bl, $75
0116   04B5 C6 0D 06      je _switch4_case4
0117   04B8 C1 78         cmp bl, $78
0118   04BA C6 3D 06      je _switch4_case5
0119   04BD C1 63         cmp bl, $63
0120   04BF C6 6D 06      je _switch4_case6
0121   04C2 C1 73         cmp bl, $73
0122   04C4 C6 9D 06      je _switch4_case7
0123   04C7 0A CA 06      jmp _switch4_default
0124   04CA 0A D6 06      jmp _switch4_exit
0125   04CD             _switch4_case0:
0126   04CD             _switch4_case1:
0127   04CD             ; format_p++; 
0128   04CD FA FD FF      lea d, [bp + -3] ; $format_p
0129   04D0 2A            mov b, [d]
0130   04D1 38 00 00      mov c, 0
0131   04D4 FD 77         inc b
0132   04D6 FA FD FF      lea d, [bp + -3] ; $format_p
0133   04D9 FD 43         mov [d], b
0134   04DB FD 7D         dec b
0135   04DD             ; if(*format_p == 'd' || *format_p == 'i') 
0136   04DD             _if5_cond:
0137   04DD FA FD FF      lea d, [bp + -3] ; $format_p
0138   04E0 2A            mov b, [d]
0139   04E1 38 00 00      mov c, 0
0140   04E4 74            mov d, b
0141   04E5 32            mov bl, [d]
0142   04E6 A7 00         mov bh, 0
0143   04E8 38 00 00      mov c, 0
0144   04EB             ; --- START RELATIONAL
0145   04EB D7            push a
0146   04EC 11            mov a, b
0147   04ED FD 2E 64 00   mov32 cb, $00000064
0147   04F1 00 00 
0148   04F3 B0            cmp a, b
0149   04F4 FD 71         seq ; ==
0150   04F6 E4            pop a
0151   04F7             ; --- END RELATIONAL
0152   04F7             ; --- START LOGICAL OR
0153   04F7 D7            push a
0154   04F8 11            mov a, b
0155   04F9 FA FD FF      lea d, [bp + -3] ; $format_p
0156   04FC 2A            mov b, [d]
0157   04FD 38 00 00      mov c, 0
0158   0500 74            mov d, b
0159   0501 32            mov bl, [d]
0160   0502 A7 00         mov bh, 0
0161   0504 38 00 00      mov c, 0
0162   0507             ; --- START RELATIONAL
0163   0507 D7            push a
0164   0508 11            mov a, b
0165   0509 FD 2E 69 00   mov32 cb, $00000069
0165   050D 00 00 
0166   050F B0            cmp a, b
0167   0510 FD 71         seq ; ==
0168   0512 E4            pop a
0169   0513             ; --- END RELATIONAL
0170   0513 FD A8         sor a, b ; ||
0171   0515 E4            pop a
0172   0516             ; --- END LOGICAL OR
0173   0516 C0 00 00      cmp b, 0
0174   0519 C6 3A 05      je _if5_else
0175   051C             _if5_TRUE:
0176   051C             ; print_signed_long(*(long *)p); 
0177   051C             ; --- START FUNCTION CALL
0178   051C FA FF FF      lea d, [bp + -1] ; $p
0179   051F 2A            mov b, [d]
0180   0520 38 00 00      mov c, 0
0181   0523 74            mov d, b
0182   0524 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0183   0527 FD 39         mov c, b ; And place it into C
0184   0529 2A            mov b, [d] ; Lower Word in B
0185   052A 12            mov a, c
0186   052B FD AA         swp a
0187   052D D7            push a
0188   052E FD AB         swp b
0189   0530 D8            push b
0190   0531 07 03 07      call print_signed_long
0191   0534 51 04 00      add sp, 4
0192   0537             ; --- END FUNCTION CALL
0193   0537 0A C2 05      jmp _if5_exit
0194   053A             _if5_else:
0195   053A             ; if(*format_p == 'u') 
0196   053A             _if6_cond:
0197   053A FA FD FF      lea d, [bp + -3] ; $format_p
0198   053D 2A            mov b, [d]
0199   053E 38 00 00      mov c, 0
0200   0541 74            mov d, b
0201   0542 32            mov bl, [d]
0202   0543 A7 00         mov bh, 0
0203   0545 38 00 00      mov c, 0
0204   0548             ; --- START RELATIONAL
0205   0548 D7            push a
0206   0549 11            mov a, b
0207   054A FD 2E 75 00   mov32 cb, $00000075
0207   054E 00 00 
0208   0550 B0            cmp a, b
0209   0551 FD 71         seq ; ==
0210   0553 E4            pop a
0211   0554             ; --- END RELATIONAL
0212   0554 C0 00 00      cmp b, 0
0213   0557 C6 78 05      je _if6_else
0214   055A             _if6_TRUE:
0215   055A             ; print_unsigned_long(*(unsigned long *)p); 
0216   055A             ; --- START FUNCTION CALL
0217   055A FA FF FF      lea d, [bp + -1] ; $p
0218   055D 2A            mov b, [d]
0219   055E 38 00 00      mov c, 0
0220   0561 74            mov d, b
0221   0562 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0222   0565 FD 39         mov c, b ; And place it into C
0223   0567 2A            mov b, [d] ; Lower Word in B
0224   0568 12            mov a, c
0225   0569 FD AA         swp a
0226   056B D7            push a
0227   056C FD AB         swp b
0228   056E D8            push b
0229   056F 07 96 08      call print_unsigned_long
0230   0572 51 04 00      add sp, 4
0231   0575             ; --- END FUNCTION CALL
0232   0575 0A C2 05      jmp _if6_exit
0233   0578             _if6_else:
0234   0578             ; if(*format_p == 'x') 
0235   0578             _if7_cond:
0236   0578 FA FD FF      lea d, [bp + -3] ; $format_p
0237   057B 2A            mov b, [d]
0238   057C 38 00 00      mov c, 0
0239   057F 74            mov d, b
0240   0580 32            mov bl, [d]
0241   0581 A7 00         mov bh, 0
0242   0583 38 00 00      mov c, 0
0243   0586             ; --- START RELATIONAL
0244   0586 D7            push a
0245   0587 11            mov a, b
0246   0588 FD 2E 78 00   mov32 cb, $00000078
0246   058C 00 00 
0247   058E B0            cmp a, b
0248   058F FD 71         seq ; ==
0249   0591 E4            pop a
0250   0592             ; --- END RELATIONAL
0251   0592 C0 00 00      cmp b, 0
0252   0595 C6 B6 05      je _if7_else
0253   0598             _if7_TRUE:
0254   0598             ; printx32(*(long int *)p); 
0255   0598             ; --- START FUNCTION CALL
0256   0598 FA FF FF      lea d, [bp + -1] ; $p
0257   059B 2A            mov b, [d]
0258   059C 38 00 00      mov c, 0
0259   059F 74            mov d, b
0260   05A0 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0261   05A3 FD 39         mov c, b ; And place it into C
0262   05A5 2A            mov b, [d] ; Lower Word in B
0263   05A6 12            mov a, c
0264   05A7 FD AA         swp a
0265   05A9 D7            push a
0266   05AA FD AB         swp b
0267   05AC D8            push b
0268   05AD 07 CA 09      call printx32
0269   05B0 51 04 00      add sp, 4
0270   05B3             ; --- END FUNCTION CALL
0271   05B3 0A C2 05      jmp _if7_exit
0272   05B6             _if7_else:
0273   05B6             ; err("Unexpected format in printf."); 
0274   05B6             ; --- START FUNCTION CALL
0275   05B6 26 3E 0D      mov b, _s1 ; "Unexpected format in printf."
0276   05B9 FD AB         swp b
0277   05BB D8            push b
0278   05BC 07 2A 0A      call err
0279   05BF 51 02 00      add sp, 2
0280   05C2             ; --- END FUNCTION CALL
0281   05C2             _if7_exit:
0282   05C2             _if6_exit:
0283   05C2             _if5_exit:
0284   05C2             ; p = p + 4; 
0285   05C2 FA FF FF      lea d, [bp + -1] ; $p
0286   05C5 DA            push d
0287   05C6 FA FF FF      lea d, [bp + -1] ; $p
0288   05C9 2A            mov b, [d]
0289   05CA 38 00 00      mov c, 0
0290   05CD             ; --- START TERMS
0291   05CD D7            push a
0292   05CE 11            mov a, b
0293   05CF FD 2E 04 00   mov32 cb, $00000004
0293   05D3 00 00 
0294   05D5 56            add b, a
0295   05D6 E4            pop a
0296   05D7             ; --- END TERMS
0297   05D7 E7            pop d
0298   05D8 FD 43         mov [d], b
0299   05DA             ; break; 
0300   05DA 0A D6 06      jmp _switch4_exit ; case break
0301   05DD             _switch4_case2:
0302   05DD             _switch4_case3:
0303   05DD             ; print_signed(*(int*)p); 
0304   05DD             ; --- START FUNCTION CALL
0305   05DD FA FF FF      lea d, [bp + -1] ; $p
0306   05E0 2A            mov b, [d]
0307   05E1 38 00 00      mov c, 0
0308   05E4 74            mov d, b
0309   05E5 2A            mov b, [d]
0310   05E6 38 00 00      mov c, 0
0311   05E9 FD AB         swp b
0312   05EB D8            push b
0313   05EC 07 58 0A      call print_signed
0314   05EF 51 02 00      add sp, 2
0315   05F2             ; --- END FUNCTION CALL
0316   05F2             ; p = p + 2; 
0317   05F2 FA FF FF      lea d, [bp + -1] ; $p
0318   05F5 DA            push d
0319   05F6 FA FF FF      lea d, [bp + -1] ; $p
0320   05F9 2A            mov b, [d]
0321   05FA 38 00 00      mov c, 0
0322   05FD             ; --- START TERMS
0323   05FD D7            push a
0324   05FE 11            mov a, b
0325   05FF FD 2E 02 00   mov32 cb, $00000002
0325   0603 00 00 
0326   0605 56            add b, a
0327   0606 E4            pop a
0328   0607             ; --- END TERMS
0329   0607 E7            pop d
0330   0608 FD 43         mov [d], b
0331   060A             ; break; 
0332   060A 0A D6 06      jmp _switch4_exit ; case break
0333   060D             _switch4_case4:
0334   060D             ; print_unsigned(*(unsigned int*)p); 
0335   060D             ; --- START FUNCTION CALL
0336   060D FA FF FF      lea d, [bp + -1] ; $p
0337   0610 2A            mov b, [d]
0338   0611 38 00 00      mov c, 0
0339   0614 74            mov d, b
0340   0615 2A            mov b, [d]
0341   0616 38 00 00      mov c, 0
0342   0619 FD AB         swp b
0343   061B D8            push b
0344   061C 07 A9 0B      call print_unsigned
0345   061F 51 02 00      add sp, 2
0346   0622             ; --- END FUNCTION CALL
0347   0622             ; p = p + 2; 
0348   0622 FA FF FF      lea d, [bp + -1] ; $p
0349   0625 DA            push d
0350   0626 FA FF FF      lea d, [bp + -1] ; $p
0351   0629 2A            mov b, [d]
0352   062A 38 00 00      mov c, 0
0353   062D             ; --- START TERMS
0354   062D D7            push a
0355   062E 11            mov a, b
0356   062F FD 2E 02 00   mov32 cb, $00000002
0356   0633 00 00 
0357   0635 56            add b, a
0358   0636 E4            pop a
0359   0637             ; --- END TERMS
0360   0637 E7            pop d
0361   0638 FD 43         mov [d], b
0362   063A             ; break; 
0363   063A 0A D6 06      jmp _switch4_exit ; case break
0364   063D             _switch4_case5:
0365   063D             ; printx16(*(int*)p); 
0366   063D             ; --- START FUNCTION CALL
0367   063D FA FF FF      lea d, [bp + -1] ; $p
0368   0640 2A            mov b, [d]
0369   0641 38 00 00      mov c, 0
0370   0644 74            mov d, b
0371   0645 2A            mov b, [d]
0372   0646 38 00 00      mov c, 0
0373   0649 FD AB         swp b
0374   064B D8            push b
0375   064C 07 C1 0C      call printx16
0376   064F 51 02 00      add sp, 2
0377   0652             ; --- END FUNCTION CALL
0378   0652             ; p = p + 2; 
0379   0652 FA FF FF      lea d, [bp + -1] ; $p
0380   0655 DA            push d
0381   0656 FA FF FF      lea d, [bp + -1] ; $p
0382   0659 2A            mov b, [d]
0383   065A 38 00 00      mov c, 0
0384   065D             ; --- START TERMS
0385   065D D7            push a
0386   065E 11            mov a, b
0387   065F FD 2E 02 00   mov32 cb, $00000002
0387   0663 00 00 
0388   0665 56            add b, a
0389   0666 E4            pop a
0390   0667             ; --- END TERMS
0391   0667 E7            pop d
0392   0668 FD 43         mov [d], b
0393   066A             ; break; 
0394   066A 0A D6 06      jmp _switch4_exit ; case break
0395   066D             _switch4_case6:
0396   066D             ; putchar(*(char*)p); 
0397   066D             ; --- START FUNCTION CALL
0398   066D FA FF FF      lea d, [bp + -1] ; $p
0399   0670 2A            mov b, [d]
0400   0671 38 00 00      mov c, 0
0401   0674 74            mov d, b
0402   0675 32            mov bl, [d]
0403   0676 A7 00         mov bh, 0
0404   0678 38 00 00      mov c, 0
0405   067B DD            push bl
0406   067C 07 88 08      call putchar
0407   067F 51 01 00      add sp, 1
0408   0682             ; --- END FUNCTION CALL
0409   0682             ; p = p + 2; 
0410   0682 FA FF FF      lea d, [bp + -1] ; $p
0411   0685 DA            push d
0412   0686 FA FF FF      lea d, [bp + -1] ; $p
0413   0689 2A            mov b, [d]
0414   068A 38 00 00      mov c, 0
0415   068D             ; --- START TERMS
0416   068D D7            push a
0417   068E 11            mov a, b
0418   068F FD 2E 02 00   mov32 cb, $00000002
0418   0693 00 00 
0419   0695 56            add b, a
0420   0696 E4            pop a
0421   0697             ; --- END TERMS
0422   0697 E7            pop d
0423   0698 FD 43         mov [d], b
0424   069A             ; break; 
0425   069A 0A D6 06      jmp _switch4_exit ; case break
0426   069D             _switch4_case7:
0427   069D             ; print(*(char**)p); 
0428   069D             ; --- START FUNCTION CALL
0429   069D FA FF FF      lea d, [bp + -1] ; $p
0430   06A0 2A            mov b, [d]
0431   06A1 38 00 00      mov c, 0
0432   06A4 74            mov d, b
0433   06A5 2A            mov b, [d]
0434   06A6 FD AB         swp b
0435   06A8 D8            push b
0436   06A9 07 3F 0A      call print
0437   06AC 51 02 00      add sp, 2
0438   06AF             ; --- END FUNCTION CALL
0439   06AF             ; p = p + 2; 
0440   06AF FA FF FF      lea d, [bp + -1] ; $p
0441   06B2 DA            push d
0442   06B3 FA FF FF      lea d, [bp + -1] ; $p
0443   06B6 2A            mov b, [d]
0444   06B7 38 00 00      mov c, 0
0445   06BA             ; --- START TERMS
0446   06BA D7            push a
0447   06BB 11            mov a, b
0448   06BC FD 2E 02 00   mov32 cb, $00000002
0448   06C0 00 00 
0449   06C2 56            add b, a
0450   06C3 E4            pop a
0451   06C4             ; --- END TERMS
0452   06C4 E7            pop d
0453   06C5 FD 43         mov [d], b
0454   06C7             ; break; 
0455   06C7 0A D6 06      jmp _switch4_exit ; case break
0456   06CA             _switch4_default:
0457   06CA             ; print("Error: Unknown argument type.\n"); 
0458   06CA             ; --- START FUNCTION CALL
0459   06CA 26 5B 0D      mov b, _s2 ; "Error: Unknown argument type.\n"
0460   06CD FD AB         swp b
0461   06CF D8            push b
0462   06D0 07 3F 0A      call print
0463   06D3 51 02 00      add sp, 2
0464   06D6             ; --- END FUNCTION CALL
0465   06D6             _switch4_exit:
0466   06D6 0A EE 06      jmp _if3_exit
0467   06D9             _if3_else:
0468   06D9             ; putchar(*format_p); 
0469   06D9             ; --- START FUNCTION CALL
0470   06D9 FA FD FF      lea d, [bp + -3] ; $format_p
0471   06DC 2A            mov b, [d]
0472   06DD 38 00 00      mov c, 0
0473   06E0 74            mov d, b
0474   06E1 32            mov bl, [d]
0475   06E2 A7 00         mov bh, 0
0476   06E4 38 00 00      mov c, 0
0477   06E7 DD            push bl
0478   06E8 07 88 08      call putchar
0479   06EB 51 01 00      add sp, 1
0480   06EE             ; --- END FUNCTION CALL
0481   06EE             _if3_exit:
0482   06EE             _if2_exit:
0483   06EE             ; format_p++; 
0484   06EE FA FD FF      lea d, [bp + -3] ; $format_p
0485   06F1 2A            mov b, [d]
0486   06F2 38 00 00      mov c, 0
0487   06F5 FD 77         inc b
0488   06F7 FA FD FF      lea d, [bp + -3] ; $format_p
0489   06FA FD 43         mov [d], b
0490   06FC FD 7D         dec b
0491   06FE             _for1_update:
0492   06FE 0A 42 04      jmp _for1_cond
0493   0701             _for1_exit:
0494   0701 F9            leave
0495   0702 09            ret
0496   0703             
0497   0703             print_signed_long:
0498   0703 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0499   0706             ; char digits[10]; 
0500   0706 52 0A 00      sub sp, 10
0501   0709             ; int i = 0; 
0502   0709 52 02 00      sub sp, 2
0503   070C             ; --- START LOCAL VAR INITIALIZATION
0504   070C FA F5 FF      lea d, [bp + -11] ; $i
0505   070F DA            push d
0506   0710 FD 2E 00 00   mov32 cb, $00000000
0506   0714 00 00 
0507   0716 E7            pop d
0508   0717 FD 43         mov [d], b
0509   0719             ; --- END LOCAL VAR INITIALIZATION
0510   0719             ; if (num < 0) { 
0511   0719             _if8_cond:
0512   0719 FA 05 00      lea d, [bp + 5] ; $num
0513   071C 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0514   071F FD 39         mov c, b ; And place it into C
0515   0721 2A            mov b, [d] ; Lower Word in B
0516   0722             ; --- START RELATIONAL
0517   0722 D7            push a
0518   0723 FD D8         push g
0519   0725 11            mov a, b
0520   0726 FD 7A         mov g, c
0521   0728 FD 2E 00 00   mov32 cb, $00000000
0521   072C 00 00 
0522   072E FD AF         cmp32 ga, cb
0523   0730 FD 73         slt ; <
0524   0732 FD F1         pop g
0525   0734 E4            pop a
0526   0735             ; --- END RELATIONAL
0527   0735 C0 00 00      cmp b, 0
0528   0738 C6 6A 07      je _if8_else
0529   073B             _if8_TRUE:
0530   073B             ; putchar('-'); 
0531   073B             ; --- START FUNCTION CALL
0532   073B FD 2E 2D 00   mov32 cb, $0000002d
0532   073F 00 00 
0533   0741 DD            push bl
0534   0742 07 88 08      call putchar
0535   0745 51 01 00      add sp, 1
0536   0748             ; --- END FUNCTION CALL
0537   0748             ; num = -num; 
0538   0748 FA 05 00      lea d, [bp + 5] ; $num
0539   074B DA            push d
0540   074C FA 05 00      lea d, [bp + 5] ; $num
0541   074F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0542   0752 FD 39         mov c, b ; And place it into C
0543   0754 2A            mov b, [d] ; Lower Word in B
0544   0755 12            mov a, c
0545   0756 95            not a
0546   0757 97            not b
0547   0758 55 01 00      add b, 1
0548   075B 5B 00 00      adc a, 0
0549   075E 39            mov c, a
0550   075F E7            pop d
0551   0760 FD 43         mov [d], b
0552   0762 28            mov b, c
0553   0763 FD 44 02 00   mov [d + 2], b
0554   0767 0A 9E 07      jmp _if8_exit
0555   076A             _if8_else:
0556   076A             ; if (num == 0) { 
0557   076A             _if9_cond:
0558   076A FA 05 00      lea d, [bp + 5] ; $num
0559   076D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0560   0770 FD 39         mov c, b ; And place it into C
0561   0772 2A            mov b, [d] ; Lower Word in B
0562   0773             ; --- START RELATIONAL
0563   0773 D7            push a
0564   0774 FD D8         push g
0565   0776 11            mov a, b
0566   0777 FD 7A         mov g, c
0567   0779 FD 2E 00 00   mov32 cb, $00000000
0567   077D 00 00 
0568   077F FD AF         cmp32 ga, cb
0569   0781 FD 71         seq ; ==
0570   0783 FD F1         pop g
0571   0785 E4            pop a
0572   0786             ; --- END RELATIONAL
0573   0786 C0 00 00      cmp b, 0
0574   0789 C6 9E 07      je _if9_exit
0575   078C             _if9_TRUE:
0576   078C             ; putchar('0'); 
0577   078C             ; --- START FUNCTION CALL
0578   078C FD 2E 30 00   mov32 cb, $00000030
0578   0790 00 00 
0579   0792 DD            push bl
0580   0793 07 88 08      call putchar
0581   0796 51 01 00      add sp, 1
0582   0799             ; --- END FUNCTION CALL
0583   0799             ; return; 
0584   0799 F9            leave
0585   079A 09            ret
0586   079B 0A 9E 07      jmp _if9_exit
0587   079E             _if9_exit:
0588   079E             _if8_exit:
0589   079E             ; while (num > 0) { 
0590   079E             _while10_cond:
0591   079E FA 05 00      lea d, [bp + 5] ; $num
0592   07A1 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0593   07A4 FD 39         mov c, b ; And place it into C
0594   07A6 2A            mov b, [d] ; Lower Word in B
0595   07A7             ; --- START RELATIONAL
0596   07A7 D7            push a
0597   07A8 FD D8         push g
0598   07AA 11            mov a, b
0599   07AB FD 7A         mov g, c
0600   07AD FD 2E 00 00   mov32 cb, $00000000
0600   07B1 00 00 
0601   07B3 FD AF         cmp32 ga, cb
0602   07B5 FD 7F         sgt
0603   07B7 FD F1         pop g
0604   07B9 E4            pop a
0605   07BA             ; --- END RELATIONAL
0606   07BA C0 00 00      cmp b, 0
0607   07BD C6 3E 08      je _while10_exit
0608   07C0             _while10_block:
0609   07C0             ; digits[i] = '0' + (num % 10); 
0610   07C0 FA F7 FF      lea d, [bp + -9] ; $digits
0611   07C3 D7            push a
0612   07C4 DA            push d
0613   07C5 FA F5 FF      lea d, [bp + -11] ; $i
0614   07C8 2A            mov b, [d]
0615   07C9 38 00 00      mov c, 0
0616   07CC E7            pop d
0617   07CD 5A            add d, b
0618   07CE E4            pop a
0619   07CF DA            push d
0620   07D0 FD 2E 30 00   mov32 cb, $00000030
0620   07D4 00 00 
0621   07D6             ; --- START TERMS
0622   07D6 D7            push a
0623   07D7 11            mov a, b
0624   07D8 FA 05 00      lea d, [bp + 5] ; $num
0625   07DB 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0626   07DE FD 39         mov c, b ; And place it into C
0627   07E0 2A            mov b, [d] ; Lower Word in B
0628   07E1             ; --- START FACTORS
0629   07E1 D7            push a
0630   07E2 FD D8         push g
0631   07E4 11            mov a, b
0632   07E5 FD 7A         mov g, c
0633   07E7 FD 2E 0A 00   mov32 cb, $0000000a
0633   07EB 00 00 
0634   07ED FD D8         push g ; save 'g' as the div instruction uses it
0635   07EF AE            div a, b ; %, a: quotient, b: remainder
0636   07F0 11            mov a, b
0637   07F1 FD F1         pop g
0638   07F3 FD 38         mov c, g
0639   07F5 27            mov b, a
0640   07F6 FD F1         pop g
0641   07F8 E4            pop a
0642   07F9             ; --- END FACTORS
0643   07F9 FD 15         add32 cb, ga
0644   07FB E4            pop a
0645   07FC             ; --- END TERMS
0646   07FC E7            pop d
0647   07FD FD 3E         mov [d], bl
0648   07FF             ; num = num / 10; 
0649   07FF FA 05 00      lea d, [bp + 5] ; $num
0650   0802 DA            push d
0651   0803 FA 05 00      lea d, [bp + 5] ; $num
0652   0806 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0653   0809 FD 39         mov c, b ; And place it into C
0654   080B 2A            mov b, [d] ; Lower Word in B
0655   080C             ; --- START FACTORS
0656   080C D7            push a
0657   080D FD D8         push g
0658   080F 11            mov a, b
0659   0810 FD 7A         mov g, c
0660   0812 FD 2E 0A 00   mov32 cb, $0000000a
0660   0816 00 00 
0661   0818 FD D8         push g ; save 'g' as the div instruction uses it
0662   081A AE            div a, b ; /, a: quotient, b: remainder
0663   081B FD F1         pop g
0664   081D FD 38         mov c, g
0665   081F 27            mov b, a
0666   0820 FD F1         pop g
0667   0822 E4            pop a
0668   0823             ; --- END FACTORS
0669   0823 E7            pop d
0670   0824 FD 43         mov [d], b
0671   0826 28            mov b, c
0672   0827 FD 44 02 00   mov [d + 2], b
0673   082B             ; i++; 
0674   082B FA F5 FF      lea d, [bp + -11] ; $i
0675   082E 2A            mov b, [d]
0676   082F 38 00 00      mov c, 0
0677   0832 11            mov a, b
0678   0833 FD 77         inc b
0679   0835 FA F5 FF      lea d, [bp + -11] ; $i
0680   0838 FD 43         mov [d], b
0681   083A 27            mov b, a
0682   083B 0A 9E 07      jmp _while10_cond
0683   083E             _while10_exit:
0684   083E             ; while (i > 0) { 
0685   083E             _while17_cond:
0686   083E FA F5 FF      lea d, [bp + -11] ; $i
0687   0841 2A            mov b, [d]
0688   0842 38 00 00      mov c, 0
0689   0845             ; --- START RELATIONAL
0690   0845 D7            push a
0691   0846 11            mov a, b
0692   0847 FD 2E 00 00   mov32 cb, $00000000
0692   084B 00 00 
0693   084D B0            cmp a, b
0694   084E FD 7F         sgt ; >
0695   0850 E4            pop a
0696   0851             ; --- END RELATIONAL
0697   0851 C0 00 00      cmp b, 0
0698   0854 C6 86 08      je _while17_exit
0699   0857             _while17_block:
0700   0857             ; i--; 
0701   0857 FA F5 FF      lea d, [bp + -11] ; $i
0702   085A 2A            mov b, [d]
0703   085B 38 00 00      mov c, 0
0704   085E 11            mov a, b
0705   085F FD 7D         dec b
0706   0861 FA F5 FF      lea d, [bp + -11] ; $i
0707   0864 FD 43         mov [d], b
0708   0866 27            mov b, a
0709   0867             ; putchar(digits[i]); 
0710   0867             ; --- START FUNCTION CALL
0711   0867 FA F7 FF      lea d, [bp + -9] ; $digits
0712   086A D7            push a
0713   086B DA            push d
0714   086C FA F5 FF      lea d, [bp + -11] ; $i
0715   086F 2A            mov b, [d]
0716   0870 38 00 00      mov c, 0
0717   0873 E7            pop d
0718   0874 5A            add d, b
0719   0875 E4            pop a
0720   0876 32            mov bl, [d]
0721   0877 A7 00         mov bh, 0
0722   0879 38 00 00      mov c, 0
0723   087C DD            push bl
0724   087D 07 88 08      call putchar
0725   0880 51 01 00      add sp, 1
0726   0883             ; --- END FUNCTION CALL
0727   0883 0A 3E 08      jmp _while17_cond
0728   0886             _while17_exit:
0729   0886 F9            leave
0730   0887 09            ret
0731   0888             
0732   0888             putchar:
0733   0888 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0734   088B             ; --- BEGIN INLINE ASM SEGMENT
0735   088B FA 05 00      lea d, [bp + 5] ; $c
0736   088E 1E            mov al, [d]
0737   088F 23            mov ah, al
0738   0890 19 00         mov al, 0
0739   0892 05 03         syscall sys_io      ; char in AH
0740   0894             ; --- END INLINE ASM SEGMENT
0741   0894 F9            leave
0742   0895 09            ret
0743   0896             
0744   0896             print_unsigned_long:
0745   0896 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0746   0899             ; char digits[10]; 
0747   0899 52 0A 00      sub sp, 10
0748   089C             ; int i; 
0749   089C 52 02 00      sub sp, 2
0750   089F             ; i = 0; 
0751   089F FA F5 FF      lea d, [bp + -11] ; $i
0752   08A2 DA            push d
0753   08A3 FD 2E 00 00   mov32 cb, $00000000
0753   08A7 00 00 
0754   08A9 E7            pop d
0755   08AA FD 43         mov [d], b
0756   08AC             ; if(num == 0){ 
0757   08AC             _if18_cond:
0758   08AC FA 05 00      lea d, [bp + 5] ; $num
0759   08AF 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0760   08B2 FD 39         mov c, b ; And place it into C
0761   08B4 2A            mov b, [d] ; Lower Word in B
0762   08B5             ; --- START RELATIONAL
0763   08B5 D7            push a
0764   08B6 FD D8         push g
0765   08B8 11            mov a, b
0766   08B9 FD 7A         mov g, c
0767   08BB FD 2E 00 00   mov32 cb, $00000000
0767   08BF 00 00 
0768   08C1 FD AF         cmp32 ga, cb
0769   08C3 FD 71         seq ; ==
0770   08C5 FD F1         pop g
0771   08C7 E4            pop a
0772   08C8             ; --- END RELATIONAL
0773   08C8 C0 00 00      cmp b, 0
0774   08CB C6 E0 08      je _if18_exit
0775   08CE             _if18_TRUE:
0776   08CE             ; putchar('0'); 
0777   08CE             ; --- START FUNCTION CALL
0778   08CE FD 2E 30 00   mov32 cb, $00000030
0778   08D2 00 00 
0779   08D4 DD            push bl
0780   08D5 07 88 08      call putchar
0781   08D8 51 01 00      add sp, 1
0782   08DB             ; --- END FUNCTION CALL
0783   08DB             ; return; 
0784   08DB F9            leave
0785   08DC 09            ret
0786   08DD 0A E0 08      jmp _if18_exit
0787   08E0             _if18_exit:
0788   08E0             ; while (num > 0) { 
0789   08E0             _while19_cond:
0790   08E0 FA 05 00      lea d, [bp + 5] ; $num
0791   08E3 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0792   08E6 FD 39         mov c, b ; And place it into C
0793   08E8 2A            mov b, [d] ; Lower Word in B
0794   08E9             ; --- START RELATIONAL
0795   08E9 D7            push a
0796   08EA FD D8         push g
0797   08EC 11            mov a, b
0798   08ED FD 7A         mov g, c
0799   08EF FD 2E 00 00   mov32 cb, $00000000
0799   08F3 00 00 
0800   08F5 FD AF         cmp32 ga, cb
0801   08F7 FD 81         sgu
0802   08F9 FD F1         pop g
0803   08FB E4            pop a
0804   08FC             ; --- END RELATIONAL
0805   08FC C0 00 00      cmp b, 0
0806   08FF C6 80 09      je _while19_exit
0807   0902             _while19_block:
0808   0902             ; digits[i] = '0' + (num % 10); 
0809   0902 FA F7 FF      lea d, [bp + -9] ; $digits
0810   0905 D7            push a
0811   0906 DA            push d
0812   0907 FA F5 FF      lea d, [bp + -11] ; $i
0813   090A 2A            mov b, [d]
0814   090B 38 00 00      mov c, 0
0815   090E E7            pop d
0816   090F 5A            add d, b
0817   0910 E4            pop a
0818   0911 DA            push d
0819   0912 FD 2E 30 00   mov32 cb, $00000030
0819   0916 00 00 
0820   0918             ; --- START TERMS
0821   0918 D7            push a
0822   0919 11            mov a, b
0823   091A FA 05 00      lea d, [bp + 5] ; $num
0824   091D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0825   0920 FD 39         mov c, b ; And place it into C
0826   0922 2A            mov b, [d] ; Lower Word in B
0827   0923             ; --- START FACTORS
0828   0923 D7            push a
0829   0924 FD D8         push g
0830   0926 11            mov a, b
0831   0927 FD 7A         mov g, c
0832   0929 FD 2E 0A 00   mov32 cb, $0000000a
0832   092D 00 00 
0833   092F FD D8         push g ; save 'g' as the div instruction uses it
0834   0931 AE            div a, b ; %, a: quotient, b: remainder
0835   0932 11            mov a, b
0836   0933 FD F1         pop g
0837   0935 FD 38         mov c, g
0838   0937 27            mov b, a
0839   0938 FD F1         pop g
0840   093A E4            pop a
0841   093B             ; --- END FACTORS
0842   093B FD 15         add32 cb, ga
0843   093D E4            pop a
0844   093E             ; --- END TERMS
0845   093E E7            pop d
0846   093F FD 3E         mov [d], bl
0847   0941             ; num = num / 10; 
0848   0941 FA 05 00      lea d, [bp + 5] ; $num
0849   0944 DA            push d
0850   0945 FA 05 00      lea d, [bp + 5] ; $num
0851   0948 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0852   094B FD 39         mov c, b ; And place it into C
0853   094D 2A            mov b, [d] ; Lower Word in B
0854   094E             ; --- START FACTORS
0855   094E D7            push a
0856   094F FD D8         push g
0857   0951 11            mov a, b
0858   0952 FD 7A         mov g, c
0859   0954 FD 2E 0A 00   mov32 cb, $0000000a
0859   0958 00 00 
0860   095A FD D8         push g ; save 'g' as the div instruction uses it
0861   095C AE            div a, b ; /, a: quotient, b: remainder
0862   095D FD F1         pop g
0863   095F FD 38         mov c, g
0864   0961 27            mov b, a
0865   0962 FD F1         pop g
0866   0964 E4            pop a
0867   0965             ; --- END FACTORS
0868   0965 E7            pop d
0869   0966 FD 43         mov [d], b
0870   0968 28            mov b, c
0871   0969 FD 44 02 00   mov [d + 2], b
0872   096D             ; i++; 
0873   096D FA F5 FF      lea d, [bp + -11] ; $i
0874   0970 2A            mov b, [d]
0875   0971 38 00 00      mov c, 0
0876   0974 11            mov a, b
0877   0975 FD 77         inc b
0878   0977 FA F5 FF      lea d, [bp + -11] ; $i
0879   097A FD 43         mov [d], b
0880   097C 27            mov b, a
0881   097D 0A E0 08      jmp _while19_cond
0882   0980             _while19_exit:
0883   0980             ; while (i > 0) { 
0884   0980             _while26_cond:
0885   0980 FA F5 FF      lea d, [bp + -11] ; $i
0886   0983 2A            mov b, [d]
0887   0984 38 00 00      mov c, 0
0888   0987             ; --- START RELATIONAL
0889   0987 D7            push a
0890   0988 11            mov a, b
0891   0989 FD 2E 00 00   mov32 cb, $00000000
0891   098D 00 00 
0892   098F B0            cmp a, b
0893   0990 FD 7F         sgt ; >
0894   0992 E4            pop a
0895   0993             ; --- END RELATIONAL
0896   0993 C0 00 00      cmp b, 0
0897   0996 C6 C8 09      je _while26_exit
0898   0999             _while26_block:
0899   0999             ; i--; 
0900   0999 FA F5 FF      lea d, [bp + -11] ; $i
0901   099C 2A            mov b, [d]
0902   099D 38 00 00      mov c, 0
0903   09A0 11            mov a, b
0904   09A1 FD 7D         dec b
0905   09A3 FA F5 FF      lea d, [bp + -11] ; $i
0906   09A6 FD 43         mov [d], b
0907   09A8 27            mov b, a
0908   09A9             ; putchar(digits[i]); 
0909   09A9             ; --- START FUNCTION CALL
0910   09A9 FA F7 FF      lea d, [bp + -9] ; $digits
0911   09AC D7            push a
0912   09AD DA            push d
0913   09AE FA F5 FF      lea d, [bp + -11] ; $i
0914   09B1 2A            mov b, [d]
0915   09B2 38 00 00      mov c, 0
0916   09B5 E7            pop d
0917   09B6 5A            add d, b
0918   09B7 E4            pop a
0919   09B8 32            mov bl, [d]
0920   09B9 A7 00         mov bh, 0
0921   09BB 38 00 00      mov c, 0
0922   09BE DD            push bl
0923   09BF 07 88 08      call putchar
0924   09C2 51 01 00      add sp, 1
0925   09C5             ; --- END FUNCTION CALL
0926   09C5 0A 80 09      jmp _while26_cond
0927   09C8             _while26_exit:
0928   09C8 F9            leave
0929   09C9 09            ret
0930   09CA             
0931   09CA             printx32:
0932   09CA F8 00 00      enter 0 ; (push bp; mov bp, sp)
0933   09CD             ; --- BEGIN INLINE ASM SEGMENT
0934   09CD FA 05 00      lea d, [bp + 5] ; $hex
0935   09D0 2B 02 00      mov b, [d+2]
0936   09D3 07 DC 09      call print_u16x_printx32
0937   09D6 2A            mov b, [d]
0938   09D7 07 DC 09      call print_u16x_printx32
0939   09DA             ; --- END INLINE ASM SEGMENT
0940   09DA             ; return; 
0941   09DA F9            leave
0942   09DB 09            ret
0943   09DC             ; --- BEGIN INLINE ASM SEGMENT
0944   09DC             print_u16x_printx32:
0945   09DC D7            push a
0946   09DD D8            push b
0947   09DE DD            push bl
0948   09DF 30            mov bl, bh
0949   09E0 07 FE 09      call _itoa_printx32        ; convert bh to char in A
0950   09E3 2F            mov bl, al        ; save al
0951   09E4 19 00         mov al, 0
0952   09E6 05 03         syscall sys_io        ; display AH
0953   09E8 24            mov ah, bl        ; retrieve al
0954   09E9 19 00         mov al, 0
0955   09EB 05 03         syscall sys_io        ; display AL
0956   09ED EA            pop bl
0957   09EE 07 FE 09      call _itoa_printx32        ; convert bh to char in A
0958   09F1 2F            mov bl, al        ; save al
0959   09F2 19 00         mov al, 0
0960   09F4 05 03         syscall sys_io        ; display AH
0961   09F6 24            mov ah, bl        ; retrieve al
0962   09F7 19 00         mov al, 0
0963   09F9 05 03         syscall sys_io        ; display AL
0964   09FB E5            pop b
0965   09FC E4            pop a
0966   09FD 09            ret
0967   09FE             _itoa_printx32:
0968   09FE DA            push d
0969   09FF D8            push b
0970   0A00 A7 00         mov bh, 0
0971   0A02 FD A4 04      shr bl, 4  
0972   0A05 74            mov d, b
0973   0A06 1F 18 0A      mov al, [d + s_hex_digits_printx32]
0974   0A09 23            mov ah, al
0975   0A0A E5            pop b
0976   0A0B D8            push b
0977   0A0C A7 00         mov bh, 0
0978   0A0E FD 87 0F      and bl, $0F
0979   0A11 74            mov d, b
0980   0A12 1F 18 0A      mov al, [d + s_hex_digits_printx32]
0981   0A15 E5            pop b
0982   0A16 E7            pop d
0983   0A17 09            ret
0984   0A18 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
0984   0A1C 34 35 36 37 
0984   0A20 38 39 41 42 
0984   0A24 43 44 45 46 
0985   0A28             ; --- END INLINE ASM SEGMENT
0986   0A28 F9            leave
0987   0A29 09            ret
0988   0A2A             
0989   0A2A             err:
0990   0A2A F8 00 00      enter 0 ; (push bp; mov bp, sp)
0991   0A2D             ; print(e); 
0992   0A2D             ; --- START FUNCTION CALL
0993   0A2D FA 05 00      lea d, [bp + 5] ; $e
0994   0A30 2A            mov b, [d]
0995   0A31 38 00 00      mov c, 0
0996   0A34 FD AB         swp b
0997   0A36 D8            push b
0998   0A37 07 3F 0A      call print
0999   0A3A 51 02 00      add sp, 2
1000   0A3D             ; --- END FUNCTION CALL
1001   0A3D F9            leave
1002   0A3E 09            ret
1003   0A3F             
1004   0A3F             print:
1005   0A3F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1006   0A42             ; --- BEGIN INLINE ASM SEGMENT
1007   0A42 FA 05 00      lea d, [bp + 5] ; $s
1008   0A45 FD 2A         mov d, [d]
1009   0A47             _puts_L1_print:
1010   0A47 1E            mov al, [d]
1011   0A48 B9 00         cmp al, 0
1012   0A4A C6 56 0A      jz _puts_END_print
1013   0A4D 23            mov ah, al
1014   0A4E 19 00         mov al, 0
1015   0A50 05 03         syscall sys_io
1016   0A52 79            inc d
1017   0A53 0A 47 0A      jmp _puts_L1_print
1018   0A56             _puts_END_print:
1019   0A56             ; --- END INLINE ASM SEGMENT
1020   0A56 F9            leave
1021   0A57 09            ret
1022   0A58             
1023   0A58             print_signed:
1024   0A58 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1025   0A5B             ; char digits[5]; 
1026   0A5B 52 05 00      sub sp, 5
1027   0A5E             ; int i = 0; 
1028   0A5E 52 02 00      sub sp, 2
1029   0A61             ; --- START LOCAL VAR INITIALIZATION
1030   0A61 FA FA FF      lea d, [bp + -6] ; $i
1031   0A64 DA            push d
1032   0A65 FD 2E 00 00   mov32 cb, $00000000
1032   0A69 00 00 
1033   0A6B E7            pop d
1034   0A6C FD 43         mov [d], b
1035   0A6E             ; --- END LOCAL VAR INITIALIZATION
1036   0A6E             ; if (num < 0) { 
1037   0A6E             _if27_cond:
1038   0A6E FA 05 00      lea d, [bp + 5] ; $num
1039   0A71 2A            mov b, [d]
1040   0A72 38 00 00      mov c, 0
1041   0A75             ; --- START RELATIONAL
1042   0A75 D7            push a
1043   0A76 11            mov a, b
1044   0A77 FD 2E 00 00   mov32 cb, $00000000
1044   0A7B 00 00 
1045   0A7D B0            cmp a, b
1046   0A7E FD 73         slt ; < (signed)
1047   0A80 E4            pop a
1048   0A81             ; --- END RELATIONAL
1049   0A81 C0 00 00      cmp b, 0
1050   0A84 C6 A7 0A      je _if27_else
1051   0A87             _if27_TRUE:
1052   0A87             ; putchar('-'); 
1053   0A87             ; --- START FUNCTION CALL
1054   0A87 FD 2E 2D 00   mov32 cb, $0000002d
1054   0A8B 00 00 
1055   0A8D DD            push bl
1056   0A8E 07 88 08      call putchar
1057   0A91 51 01 00      add sp, 1
1058   0A94             ; --- END FUNCTION CALL
1059   0A94             ; num = -num; 
1060   0A94 FA 05 00      lea d, [bp + 5] ; $num
1061   0A97 DA            push d
1062   0A98 FA 05 00      lea d, [bp + 5] ; $num
1063   0A9B 2A            mov b, [d]
1064   0A9C 38 00 00      mov c, 0
1065   0A9F FD 97         neg b
1066   0AA1 E7            pop d
1067   0AA2 FD 43         mov [d], b
1068   0AA4 0A D2 0A      jmp _if27_exit
1069   0AA7             _if27_else:
1070   0AA7             ; if (num == 0) { 
1071   0AA7             _if28_cond:
1072   0AA7 FA 05 00      lea d, [bp + 5] ; $num
1073   0AAA 2A            mov b, [d]
1074   0AAB 38 00 00      mov c, 0
1075   0AAE             ; --- START RELATIONAL
1076   0AAE D7            push a
1077   0AAF 11            mov a, b
1078   0AB0 FD 2E 00 00   mov32 cb, $00000000
1078   0AB4 00 00 
1079   0AB6 B0            cmp a, b
1080   0AB7 FD 71         seq ; ==
1081   0AB9 E4            pop a
1082   0ABA             ; --- END RELATIONAL
1083   0ABA C0 00 00      cmp b, 0
1084   0ABD C6 D2 0A      je _if28_exit
1085   0AC0             _if28_TRUE:
1086   0AC0             ; putchar('0'); 
1087   0AC0             ; --- START FUNCTION CALL
1088   0AC0 FD 2E 30 00   mov32 cb, $00000030
1088   0AC4 00 00 
1089   0AC6 DD            push bl
1090   0AC7 07 88 08      call putchar
1091   0ACA 51 01 00      add sp, 1
1092   0ACD             ; --- END FUNCTION CALL
1093   0ACD             ; return; 
1094   0ACD F9            leave
1095   0ACE 09            ret
1096   0ACF 0A D2 0A      jmp _if28_exit
1097   0AD2             _if28_exit:
1098   0AD2             _if27_exit:
1099   0AD2             ; while (num > 0) { 
1100   0AD2             _while29_cond:
1101   0AD2 FA 05 00      lea d, [bp + 5] ; $num
1102   0AD5 2A            mov b, [d]
1103   0AD6 38 00 00      mov c, 0
1104   0AD9             ; --- START RELATIONAL
1105   0AD9 D7            push a
1106   0ADA 11            mov a, b
1107   0ADB FD 2E 00 00   mov32 cb, $00000000
1107   0ADF 00 00 
1108   0AE1 B0            cmp a, b
1109   0AE2 FD 7F         sgt ; >
1110   0AE4 E4            pop a
1111   0AE5             ; --- END RELATIONAL
1112   0AE5 C0 00 00      cmp b, 0
1113   0AE8 C6 5F 0B      je _while29_exit
1114   0AEB             _while29_block:
1115   0AEB             ; digits[i] = '0' + (num % 10); 
1116   0AEB FA FC FF      lea d, [bp + -4] ; $digits
1117   0AEE D7            push a
1118   0AEF DA            push d
1119   0AF0 FA FA FF      lea d, [bp + -6] ; $i
1120   0AF3 2A            mov b, [d]
1121   0AF4 38 00 00      mov c, 0
1122   0AF7 E7            pop d
1123   0AF8 5A            add d, b
1124   0AF9 E4            pop a
1125   0AFA DA            push d
1126   0AFB FD 2E 30 00   mov32 cb, $00000030
1126   0AFF 00 00 
1127   0B01             ; --- START TERMS
1128   0B01 D7            push a
1129   0B02 11            mov a, b
1130   0B03 FA 05 00      lea d, [bp + 5] ; $num
1131   0B06 2A            mov b, [d]
1132   0B07 38 00 00      mov c, 0
1133   0B0A             ; --- START FACTORS
1134   0B0A D7            push a
1135   0B0B FD D8         push g
1136   0B0D 11            mov a, b
1137   0B0E FD 7A         mov g, c
1138   0B10 FD 2E 0A 00   mov32 cb, $0000000a
1138   0B14 00 00 
1139   0B16 FD D8         push g ; save 'g' as the div instruction uses it
1140   0B18 AE            div a, b ; %, a: quotient, b: remainder
1141   0B19 11            mov a, b
1142   0B1A FD F1         pop g
1143   0B1C FD 38         mov c, g
1144   0B1E 27            mov b, a
1145   0B1F FD F1         pop g
1146   0B21 E4            pop a
1147   0B22             ; --- END FACTORS
1148   0B22 56            add b, a
1149   0B23 E4            pop a
1150   0B24             ; --- END TERMS
1151   0B24 E7            pop d
1152   0B25 FD 3E         mov [d], bl
1153   0B27             ; num = num / 10; 
1154   0B27 FA 05 00      lea d, [bp + 5] ; $num
1155   0B2A DA            push d
1156   0B2B FA 05 00      lea d, [bp + 5] ; $num
1157   0B2E 2A            mov b, [d]
1158   0B2F 38 00 00      mov c, 0
1159   0B32             ; --- START FACTORS
1160   0B32 D7            push a
1161   0B33 FD D8         push g
1162   0B35 11            mov a, b
1163   0B36 FD 7A         mov g, c
1164   0B38 FD 2E 0A 00   mov32 cb, $0000000a
1164   0B3C 00 00 
1165   0B3E FD D8         push g ; save 'g' as the div instruction uses it
1166   0B40 AE            div a, b ; /, a: quotient, b: remainder
1167   0B41 FD F1         pop g
1168   0B43 FD 38         mov c, g
1169   0B45 27            mov b, a
1170   0B46 FD F1         pop g
1171   0B48 E4            pop a
1172   0B49             ; --- END FACTORS
1173   0B49 E7            pop d
1174   0B4A FD 43         mov [d], b
1175   0B4C             ; i++; 
1176   0B4C FA FA FF      lea d, [bp + -6] ; $i
1177   0B4F 2A            mov b, [d]
1178   0B50 38 00 00      mov c, 0
1179   0B53 11            mov a, b
1180   0B54 FD 77         inc b
1181   0B56 FA FA FF      lea d, [bp + -6] ; $i
1182   0B59 FD 43         mov [d], b
1183   0B5B 27            mov b, a
1184   0B5C 0A D2 0A      jmp _while29_cond
1185   0B5F             _while29_exit:
1186   0B5F             ; while (i > 0) { 
1187   0B5F             _while36_cond:
1188   0B5F FA FA FF      lea d, [bp + -6] ; $i
1189   0B62 2A            mov b, [d]
1190   0B63 38 00 00      mov c, 0
1191   0B66             ; --- START RELATIONAL
1192   0B66 D7            push a
1193   0B67 11            mov a, b
1194   0B68 FD 2E 00 00   mov32 cb, $00000000
1194   0B6C 00 00 
1195   0B6E B0            cmp a, b
1196   0B6F FD 7F         sgt ; >
1197   0B71 E4            pop a
1198   0B72             ; --- END RELATIONAL
1199   0B72 C0 00 00      cmp b, 0
1200   0B75 C6 A7 0B      je _while36_exit
1201   0B78             _while36_block:
1202   0B78             ; i--; 
1203   0B78 FA FA FF      lea d, [bp + -6] ; $i
1204   0B7B 2A            mov b, [d]
1205   0B7C 38 00 00      mov c, 0
1206   0B7F 11            mov a, b
1207   0B80 FD 7D         dec b
1208   0B82 FA FA FF      lea d, [bp + -6] ; $i
1209   0B85 FD 43         mov [d], b
1210   0B87 27            mov b, a
1211   0B88             ; putchar(digits[i]); 
1212   0B88             ; --- START FUNCTION CALL
1213   0B88 FA FC FF      lea d, [bp + -4] ; $digits
1214   0B8B D7            push a
1215   0B8C DA            push d
1216   0B8D FA FA FF      lea d, [bp + -6] ; $i
1217   0B90 2A            mov b, [d]
1218   0B91 38 00 00      mov c, 0
1219   0B94 E7            pop d
1220   0B95 5A            add d, b
1221   0B96 E4            pop a
1222   0B97 32            mov bl, [d]
1223   0B98 A7 00         mov bh, 0
1224   0B9A 38 00 00      mov c, 0
1225   0B9D DD            push bl
1226   0B9E 07 88 08      call putchar
1227   0BA1 51 01 00      add sp, 1
1228   0BA4             ; --- END FUNCTION CALL
1229   0BA4 0A 5F 0B      jmp _while36_cond
1230   0BA7             _while36_exit:
1231   0BA7 F9            leave
1232   0BA8 09            ret
1233   0BA9             
1234   0BA9             print_unsigned:
1235   0BA9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1236   0BAC             ; char digits[5]; 
1237   0BAC 52 05 00      sub sp, 5
1238   0BAF             ; int i; 
1239   0BAF 52 02 00      sub sp, 2
1240   0BB2             ; i = 0; 
1241   0BB2 FA FA FF      lea d, [bp + -6] ; $i
1242   0BB5 DA            push d
1243   0BB6 FD 2E 00 00   mov32 cb, $00000000
1243   0BBA 00 00 
1244   0BBC E7            pop d
1245   0BBD FD 43         mov [d], b
1246   0BBF             ; if(num == 0){ 
1247   0BBF             _if37_cond:
1248   0BBF FA 05 00      lea d, [bp + 5] ; $num
1249   0BC2 2A            mov b, [d]
1250   0BC3 38 00 00      mov c, 0
1251   0BC6             ; --- START RELATIONAL
1252   0BC6 D7            push a
1253   0BC7 11            mov a, b
1254   0BC8 FD 2E 00 00   mov32 cb, $00000000
1254   0BCC 00 00 
1255   0BCE B0            cmp a, b
1256   0BCF FD 71         seq ; ==
1257   0BD1 E4            pop a
1258   0BD2             ; --- END RELATIONAL
1259   0BD2 C0 00 00      cmp b, 0
1260   0BD5 C6 EA 0B      je _if37_exit
1261   0BD8             _if37_TRUE:
1262   0BD8             ; putchar('0'); 
1263   0BD8             ; --- START FUNCTION CALL
1264   0BD8 FD 2E 30 00   mov32 cb, $00000030
1264   0BDC 00 00 
1265   0BDE DD            push bl
1266   0BDF 07 88 08      call putchar
1267   0BE2 51 01 00      add sp, 1
1268   0BE5             ; --- END FUNCTION CALL
1269   0BE5             ; return; 
1270   0BE5 F9            leave
1271   0BE6 09            ret
1272   0BE7 0A EA 0B      jmp _if37_exit
1273   0BEA             _if37_exit:
1274   0BEA             ; while (num > 0) { 
1275   0BEA             _while38_cond:
1276   0BEA FA 05 00      lea d, [bp + 5] ; $num
1277   0BED 2A            mov b, [d]
1278   0BEE 38 00 00      mov c, 0
1279   0BF1             ; --- START RELATIONAL
1280   0BF1 D7            push a
1281   0BF2 11            mov a, b
1282   0BF3 FD 2E 00 00   mov32 cb, $00000000
1282   0BF7 00 00 
1283   0BF9 B0            cmp a, b
1284   0BFA FD 81         sgu ; > (unsigned)
1285   0BFC E4            pop a
1286   0BFD             ; --- END RELATIONAL
1287   0BFD C0 00 00      cmp b, 0
1288   0C00 C6 77 0C      je _while38_exit
1289   0C03             _while38_block:
1290   0C03             ; digits[i] = '0' + (num % 10); 
1291   0C03 FA FC FF      lea d, [bp + -4] ; $digits
1292   0C06 D7            push a
1293   0C07 DA            push d
1294   0C08 FA FA FF      lea d, [bp + -6] ; $i
1295   0C0B 2A            mov b, [d]
1296   0C0C 38 00 00      mov c, 0
1297   0C0F E7            pop d
1298   0C10 5A            add d, b
1299   0C11 E4            pop a
1300   0C12 DA            push d
1301   0C13 FD 2E 30 00   mov32 cb, $00000030
1301   0C17 00 00 
1302   0C19             ; --- START TERMS
1303   0C19 D7            push a
1304   0C1A 11            mov a, b
1305   0C1B FA 05 00      lea d, [bp + 5] ; $num
1306   0C1E 2A            mov b, [d]
1307   0C1F 38 00 00      mov c, 0
1308   0C22             ; --- START FACTORS
1309   0C22 D7            push a
1310   0C23 FD D8         push g
1311   0C25 11            mov a, b
1312   0C26 FD 7A         mov g, c
1313   0C28 FD 2E 0A 00   mov32 cb, $0000000a
1313   0C2C 00 00 
1314   0C2E FD D8         push g ; save 'g' as the div instruction uses it
1315   0C30 AE            div a, b ; %, a: quotient, b: remainder
1316   0C31 11            mov a, b
1317   0C32 FD F1         pop g
1318   0C34 FD 38         mov c, g
1319   0C36 27            mov b, a
1320   0C37 FD F1         pop g
1321   0C39 E4            pop a
1322   0C3A             ; --- END FACTORS
1323   0C3A 56            add b, a
1324   0C3B E4            pop a
1325   0C3C             ; --- END TERMS
1326   0C3C E7            pop d
1327   0C3D FD 3E         mov [d], bl
1328   0C3F             ; num = num / 10; 
1329   0C3F FA 05 00      lea d, [bp + 5] ; $num
1330   0C42 DA            push d
1331   0C43 FA 05 00      lea d, [bp + 5] ; $num
1332   0C46 2A            mov b, [d]
1333   0C47 38 00 00      mov c, 0
1334   0C4A             ; --- START FACTORS
1335   0C4A D7            push a
1336   0C4B FD D8         push g
1337   0C4D 11            mov a, b
1338   0C4E FD 7A         mov g, c
1339   0C50 FD 2E 0A 00   mov32 cb, $0000000a
1339   0C54 00 00 
1340   0C56 FD D8         push g ; save 'g' as the div instruction uses it
1341   0C58 AE            div a, b ; /, a: quotient, b: remainder
1342   0C59 FD F1         pop g
1343   0C5B FD 38         mov c, g
1344   0C5D 27            mov b, a
1345   0C5E FD F1         pop g
1346   0C60 E4            pop a
1347   0C61             ; --- END FACTORS
1348   0C61 E7            pop d
1349   0C62 FD 43         mov [d], b
1350   0C64             ; i++; 
1351   0C64 FA FA FF      lea d, [bp + -6] ; $i
1352   0C67 2A            mov b, [d]
1353   0C68 38 00 00      mov c, 0
1354   0C6B 11            mov a, b
1355   0C6C FD 77         inc b
1356   0C6E FA FA FF      lea d, [bp + -6] ; $i
1357   0C71 FD 43         mov [d], b
1358   0C73 27            mov b, a
1359   0C74 0A EA 0B      jmp _while38_cond
1360   0C77             _while38_exit:
1361   0C77             ; while (i > 0) { 
1362   0C77             _while45_cond:
1363   0C77 FA FA FF      lea d, [bp + -6] ; $i
1364   0C7A 2A            mov b, [d]
1365   0C7B 38 00 00      mov c, 0
1366   0C7E             ; --- START RELATIONAL
1367   0C7E D7            push a
1368   0C7F 11            mov a, b
1369   0C80 FD 2E 00 00   mov32 cb, $00000000
1369   0C84 00 00 
1370   0C86 B0            cmp a, b
1371   0C87 FD 7F         sgt ; >
1372   0C89 E4            pop a
1373   0C8A             ; --- END RELATIONAL
1374   0C8A C0 00 00      cmp b, 0
1375   0C8D C6 BF 0C      je _while45_exit
1376   0C90             _while45_block:
1377   0C90             ; i--; 
1378   0C90 FA FA FF      lea d, [bp + -6] ; $i
1379   0C93 2A            mov b, [d]
1380   0C94 38 00 00      mov c, 0
1381   0C97 11            mov a, b
1382   0C98 FD 7D         dec b
1383   0C9A FA FA FF      lea d, [bp + -6] ; $i
1384   0C9D FD 43         mov [d], b
1385   0C9F 27            mov b, a
1386   0CA0             ; putchar(digits[i]); 
1387   0CA0             ; --- START FUNCTION CALL
1388   0CA0 FA FC FF      lea d, [bp + -4] ; $digits
1389   0CA3 D7            push a
1390   0CA4 DA            push d
1391   0CA5 FA FA FF      lea d, [bp + -6] ; $i
1392   0CA8 2A            mov b, [d]
1393   0CA9 38 00 00      mov c, 0
1394   0CAC E7            pop d
1395   0CAD 5A            add d, b
1396   0CAE E4            pop a
1397   0CAF 32            mov bl, [d]
1398   0CB0 A7 00         mov bh, 0
1399   0CB2 38 00 00      mov c, 0
1400   0CB5 DD            push bl
1401   0CB6 07 88 08      call putchar
1402   0CB9 51 01 00      add sp, 1
1403   0CBC             ; --- END FUNCTION CALL
1404   0CBC 0A 77 0C      jmp _while45_cond
1405   0CBF             _while45_exit:
1406   0CBF F9            leave
1407   0CC0 09            ret
1408   0CC1             
1409   0CC1             printx16:
1410   0CC1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1411   0CC4             ; --- BEGIN INLINE ASM SEGMENT
1412   0CC4 FA 05 00      lea d, [bp + 5] ; $hex
1413   0CC7 2A            mov b, [d]
1414   0CC8             print_u16x_printx16:
1415   0CC8 DD            push bl
1416   0CC9 30            mov bl, bh
1417   0CCA 07 E7 0C      call _itoa_printx16        ; convert bh to char in A
1418   0CCD 2F            mov bl, al        ; save al
1419   0CCE 19 00         mov al, 0
1420   0CD0 05 03         syscall sys_io        ; display AH
1421   0CD2 24            mov ah, bl        ; retrieve al
1422   0CD3 19 00         mov al, 0
1423   0CD5 05 03         syscall sys_io        ; display AL
1424   0CD7 EA            pop bl
1425   0CD8 07 E7 0C      call _itoa_printx16        ; convert bh to char in A
1426   0CDB 2F            mov bl, al        ; save al
1427   0CDC 19 00         mov al, 0
1428   0CDE 05 03         syscall sys_io        ; display AH
1429   0CE0 24            mov ah, bl        ; retrieve al
1430   0CE1 19 00         mov al, 0
1431   0CE3 05 03         syscall sys_io        ; display AL
1432   0CE5             ; --- END INLINE ASM SEGMENT
1433   0CE5             ; return; 
1434   0CE5 F9            leave
1435   0CE6 09            ret
1436   0CE7             ; --- BEGIN INLINE ASM SEGMENT
1437   0CE7             _itoa_printx16:
1438   0CE7 DA            push d
1439   0CE8 D8            push b
1440   0CE9 A7 00         mov bh, 0
1441   0CEB FD A4 04      shr bl, 4  
1442   0CEE 74            mov d, b
1443   0CEF 1F 01 0D      mov al, [d + s_hex_digits_printx16]
1444   0CF2 23            mov ah, al
1445   0CF3 E5            pop b
1446   0CF4 D8            push b
1447   0CF5 A7 00         mov bh, 0
1448   0CF7 FD 87 0F      and bl, $0F
1449   0CFA 74            mov d, b
1450   0CFB 1F 01 0D      mov al, [d + s_hex_digits_printx16]
1451   0CFE E5            pop b
1452   0CFF E7            pop d
1453   0D00 09            ret
1454   0D01 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
1454   0D05 34 35 36 37 
1454   0D09 38 39 41 42 
1454   0D0D 43 44 45 46 
1455   0D11             ; --- END INLINE ASM SEGMENT
1456   0D11 F9            leave
1457   0D12 09            ret
1458   0D13             ; --- END TEXT SEGMENT
1459   0D13             
1460   0D13             ; --- BEGIN DATA SEGMENT
1461   0D13 54 65 73 74 _s0: .db "Test of 5.25 inch Floppy Drive Interface.\n", 0
1461   0D17 20 6F 66 20 
1461   0D1B 35 2E 32 35 
1461   0D1F 20 69 6E 63 
1461   0D23 68 20 46 6C 
1461   0D27 6F 70 70 79 
1461   0D2B 20 44 72 69 
1461   0D2F 76 65 20 49 
1461   0D33 6E 74 65 72 
1461   0D37 66 61 63 65 
1461   0D3B 2E 0A 00 
1462   0D3E 55 6E 65 78 _s1: .db "Unexpected format in printf.", 0
1462   0D42 70 65 63 74 
1462   0D46 65 64 20 66 
1462   0D4A 6F 72 6D 61 
1462   0D4E 74 20 69 6E 
1462   0D52 20 70 72 69 
1462   0D56 6E 74 66 2E 
1462   0D5A 00 
1463   0D5B 45 72 72 6F _s2: .db "Error: Unknown argument type.\n", 0
1463   0D5F 72 3A 20 55 
1463   0D63 6E 6B 6E 6F 
1463   0D67 77 6E 20 61 
1463   0D6B 72 67 75 6D 
1463   0D6F 65 6E 74 20 
1463   0D73 74 79 70 65 
1463   0D77 2E 0A 00 
1464   0D7A             
1465   0D7A 7C 0D       _heap_top: .dw _heap
1466   0D7C 00          _heap: .db 0
1467   0D7D             ; --- END DATA SEGMENT
1468   0D7D             
1469   0D7D             .end
tasm: Number of errors = 0
