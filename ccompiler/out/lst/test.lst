0001   0000             ; --- FILENAME: test
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; $pass 
0011   0408             ; $i 
0012   0408             ; $nbr_tests 
0013   0408 10 0A 00      mov a, $a
0014   040B 45 E9 FF      mov [bp + -23], a
0015   040E 52 18 00      sub sp, 24
0016   0411             ;; for(i = 0; i < nbr_tests; i++){ 
0017   0411             _for1_init:
0018   0411 FA EB FF      lea d, [bp + -21] ; $i
0019   0414 DA            push d
0020   0415 26 00 00      mov b, $0
0021   0418 E7            pop d
0022   0419 FD 43         mov [d], b
0023   041B             _for1_cond:
0024   041B FA EB FF      lea d, [bp + -21] ; $i
0025   041E 2A            mov b, [d]
0026   041F             ; START RELATIONAL
0027   041F D7            push a
0028   0420 11            mov a, b
0029   0421 FA E9 FF      lea d, [bp + -23] ; $nbr_tests
0030   0424 2A            mov b, [d]
0031   0425 B0            cmp a, b
0032   0426 FD 75         slu ; <= (unsigned)
0033   0428 E4            pop a
0034   0429             ; END RELATIONAL
0035   0429 C0 00 00      cmp b, 0
0036   042C C6 55 04      je _for1_exit
0037   042F             _for1_block:
0038   042F             ;; pass[i] = -1; 
0039   042F FA ED FF      lea d, [bp + -19] ; $pass
0040   0432 D7            push a
0041   0433 DA            push d
0042   0434 FA EB FF      lea d, [bp + -21] ; $i
0043   0437 2A            mov b, [d]
0044   0438 E7            pop d
0045   0439 FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
0046   043D E4            pop a
0047   043E DA            push d
0048   043F 26 FF FF      mov b, $ffff
0049   0442 E7            pop d
0050   0443 FD 43         mov [d], b
0051   0445             _for1_update:
0052   0445 FA EB FF      lea d, [bp + -21] ; $i
0053   0448 2A            mov b, [d]
0054   0449 D8            push b
0055   044A FD 77         inc b
0056   044C FA EB FF      lea d, [bp + -21] ; $i
0057   044F FD 43         mov [d], b
0058   0451 E5            pop b
0059   0452 0A 1B 04      jmp _for1_cond
0060   0455             _for1_exit:
0061   0455             ;; for(i = 0; i < nbr_tests; i++){ 
0062   0455             _for2_init:
0063   0455 FA EB FF      lea d, [bp + -21] ; $i
0064   0458 DA            push d
0065   0459 26 00 00      mov b, $0
0066   045C E7            pop d
0067   045D FD 43         mov [d], b
0068   045F             _for2_cond:
0069   045F FA EB FF      lea d, [bp + -21] ; $i
0070   0462 2A            mov b, [d]
0071   0463             ; START RELATIONAL
0072   0463 D7            push a
0073   0464 11            mov a, b
0074   0465 FA E9 FF      lea d, [bp + -23] ; $nbr_tests
0075   0468 2A            mov b, [d]
0076   0469 B0            cmp a, b
0077   046A FD 75         slu ; <= (unsigned)
0078   046C E4            pop a
0079   046D             ; END RELATIONAL
0080   046D C0 00 00      cmp b, 0
0081   0470 C6 A6 04      je _for2_exit
0082   0473             _for2_block:
0083   0473             ;; printf("Test %d, Result: %u\n", i, pass[i]); 
0084   0473 FA ED FF      lea d, [bp + -19] ; $pass
0085   0476 D7            push a
0086   0477 DA            push d
0087   0478 FA EB FF      lea d, [bp + -21] ; $i
0088   047B 2A            mov b, [d]
0089   047C E7            pop d
0090   047D FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
0091   0481 E4            pop a
0092   0482 2A            mov b, [d]
0093   0483 FD AB         swp b
0094   0485 D8            push b
0095   0486 FA EB FF      lea d, [bp + -21] ; $i
0096   0489 2A            mov b, [d]
0097   048A FD AB         swp b
0098   048C D8            push b
0099   048D 26 C7 14      mov b, __s0 ; "Test %d, Result: %u\n"
0100   0490 FD AB         swp b
0101   0492 D8            push b
0102   0493 07 48 08      call printf
0103   0496             _for2_update:
0104   0496 FA EB FF      lea d, [bp + -21] ; $i
0105   0499 2A            mov b, [d]
0106   049A D8            push b
0107   049B FD 77         inc b
0108   049D FA EB FF      lea d, [bp + -21] ; $i
0109   04A0 FD 43         mov [d], b
0110   04A2 E5            pop b
0111   04A3 0A 5F 04      jmp _for2_cond
0112   04A6             _for2_exit:
0113   04A6 05 0B         syscall sys_terminate_proc
0114   04A8             
0115   04A8             strcpy:
0116   04A8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0117   04AB             ; $psrc 
0118   04AB             ; $pdest 
0119   04AB 52 04 00      sub sp, 4
0120   04AE             ;; psrc = src; 
0121   04AE FA FF FF      lea d, [bp + -1] ; $psrc
0122   04B1 DA            push d
0123   04B2 FA 07 00      lea d, [bp + 7] ; $src
0124   04B5 2A            mov b, [d]
0125   04B6 E7            pop d
0126   04B7 FD 43         mov [d], b
0127   04B9             ;; pdest = dest; 
0128   04B9 FA FD FF      lea d, [bp + -3] ; $pdest
0129   04BC DA            push d
0130   04BD FA 05 00      lea d, [bp + 5] ; $dest
0131   04C0 2A            mov b, [d]
0132   04C1 E7            pop d
0133   04C2 FD 43         mov [d], b
0134   04C4             ;; while(*psrc) *pdest++ = *psrc++; 
0135   04C4             _while3_cond:
0136   04C4 FA FF FF      lea d, [bp + -1] ; $psrc
0137   04C7 2A            mov b, [d]
0138   04C8 74            mov d, b
0139   04C9 32            mov bl, [d]
0140   04CA A7 00         mov bh, 0
0141   04CC C0 00 00      cmp b, 0
0142   04CF C6 F7 04      je _while3_exit
0143   04D2             _while3_block:
0144   04D2             ;; *pdest++ = *psrc++; 
0145   04D2 FA FD FF      lea d, [bp + -3] ; $pdest
0146   04D5 2A            mov b, [d]
0147   04D6 D8            push b
0148   04D7 FD 77         inc b
0149   04D9 FA FD FF      lea d, [bp + -3] ; $pdest
0150   04DC FD 43         mov [d], b
0151   04DE E5            pop b
0152   04DF D8            push b
0153   04E0 FA FF FF      lea d, [bp + -1] ; $psrc
0154   04E3 2A            mov b, [d]
0155   04E4 D8            push b
0156   04E5 FD 77         inc b
0157   04E7 FA FF FF      lea d, [bp + -1] ; $psrc
0158   04EA FD 43         mov [d], b
0159   04EC E5            pop b
0160   04ED 74            mov d, b
0161   04EE 32            mov bl, [d]
0162   04EF A7 00         mov bh, 0
0163   04F1 E7            pop d
0164   04F2 FD 3E         mov [d], bl
0165   04F4 0A C4 04      jmp _while3_cond
0166   04F7             _while3_exit:
0167   04F7             ;; *pdest = '\0'; 
0168   04F7 FA FD FF      lea d, [bp + -3] ; $pdest
0169   04FA 2A            mov b, [d]
0170   04FB D8            push b
0171   04FC 26 00 00      mov b, $0
0172   04FF E7            pop d
0173   0500 FD 3E         mov [d], bl
0174   0502 F9            leave
0175   0503 09            ret
0176   0504             
0177   0504             strcmp:
0178   0504 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0179   0507             ;; while (*s1 && (*s1 == *s2)) { 
0180   0507             _while4_cond:
0181   0507 FA 05 00      lea d, [bp + 5] ; $s1
0182   050A 2A            mov b, [d]
0183   050B 74            mov d, b
0184   050C 32            mov bl, [d]
0185   050D A7 00         mov bh, 0
0186   050F D7            push a
0187   0510 11            mov a, b
0188   0511 FA 05 00      lea d, [bp + 5] ; $s1
0189   0514 2A            mov b, [d]
0190   0515 74            mov d, b
0191   0516 32            mov bl, [d]
0192   0517 A7 00         mov bh, 0
0193   0519             ; START RELATIONAL
0194   0519 D7            push a
0195   051A 11            mov a, b
0196   051B FA 07 00      lea d, [bp + 7] ; $s2
0197   051E 2A            mov b, [d]
0198   051F 74            mov d, b
0199   0520 32            mov bl, [d]
0200   0521 A7 00         mov bh, 0
0201   0523 B0            cmp a, b
0202   0524 FD 71         seq ; ==
0203   0526 E4            pop a
0204   0527             ; END RELATIONAL
0205   0527 FD A7         sand a, b ; &&
0206   0529 E4            pop a
0207   052A C0 00 00      cmp b, 0
0208   052D C6 4D 05      je _while4_exit
0209   0530             _while4_block:
0210   0530             ;; s1++; 
0211   0530 FA 05 00      lea d, [bp + 5] ; $s1
0212   0533 2A            mov b, [d]
0213   0534 D8            push b
0214   0535 FD 77         inc b
0215   0537 FA 05 00      lea d, [bp + 5] ; $s1
0216   053A FD 43         mov [d], b
0217   053C E5            pop b
0218   053D             ;; s2++; 
0219   053D FA 07 00      lea d, [bp + 7] ; $s2
0220   0540 2A            mov b, [d]
0221   0541 D8            push b
0222   0542 FD 77         inc b
0223   0544 FA 07 00      lea d, [bp + 7] ; $s2
0224   0547 FD 43         mov [d], b
0225   0549 E5            pop b
0226   054A 0A 07 05      jmp _while4_cond
0227   054D             _while4_exit:
0228   054D             ;; return *s1 - *s2; 
0229   054D FA 05 00      lea d, [bp + 5] ; $s1
0230   0550 2A            mov b, [d]
0231   0551 74            mov d, b
0232   0552 32            mov bl, [d]
0233   0553 A7 00         mov bh, 0
0234   0555             ; START TERMS
0235   0555 D7            push a
0236   0556 11            mov a, b
0237   0557 FA 07 00      lea d, [bp + 7] ; $s2
0238   055A 2A            mov b, [d]
0239   055B 74            mov d, b
0240   055C 32            mov bl, [d]
0241   055D A7 00         mov bh, 0
0242   055F 60            sub a, b
0243   0560 27            mov b, a
0244   0561 E4            pop a
0245   0562             ; END TERMS
0246   0562 F9            leave
0247   0563 09            ret
0248   0564             
0249   0564             strcat:
0250   0564 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0251   0567             ; $dest_len 
0252   0567             ; $i 
0253   0567 52 04 00      sub sp, 4
0254   056A             ;; dest_len = strlen(dest); 
0255   056A FA FF FF      lea d, [bp + -1] ; $dest_len
0256   056D DA            push d
0257   056E FA 05 00      lea d, [bp + 5] ; $dest
0258   0571 2A            mov b, [d]
0259   0572 FD AB         swp b
0260   0574 D8            push b
0261   0575 07 17 06      call strlen
0262   0578 51 02 00      add sp, 2
0263   057B E7            pop d
0264   057C FD 43         mov [d], b
0265   057E             ;; for (i = 0; src[i] != 0; i=i+1) { 
0266   057E             _for5_init:
0267   057E FA FD FF      lea d, [bp + -3] ; $i
0268   0581 DA            push d
0269   0582 26 00 00      mov b, $0
0270   0585 E7            pop d
0271   0586 FD 43         mov [d], b
0272   0588             _for5_cond:
0273   0588 FA 07 00      lea d, [bp + 7] ; $src
0274   058B FD 2A         mov d, [d]
0275   058D D7            push a
0276   058E DA            push d
0277   058F FA FD FF      lea d, [bp + -3] ; $i
0278   0592 2A            mov b, [d]
0279   0593 E7            pop d
0280   0594 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0281   0598 E4            pop a
0282   0599 32            mov bl, [d]
0283   059A A7 00         mov bh, 0
0284   059C             ; START RELATIONAL
0285   059C D7            push a
0286   059D 11            mov a, b
0287   059E 26 00 00      mov b, $0
0288   05A1 B0            cmp a, b
0289   05A2 FD 72         sneq ; !=
0290   05A4 E4            pop a
0291   05A5             ; END RELATIONAL
0292   05A5 C0 00 00      cmp b, 0
0293   05A8 C6 F1 05      je _for5_exit
0294   05AB             _for5_block:
0295   05AB             ;; dest[dest_len + i] = src[i]; 
0296   05AB FA 05 00      lea d, [bp + 5] ; $dest
0297   05AE FD 2A         mov d, [d]
0298   05B0 D7            push a
0299   05B1 DA            push d
0300   05B2 FA FF FF      lea d, [bp + -1] ; $dest_len
0301   05B5 2A            mov b, [d]
0302   05B6             ; START TERMS
0303   05B6 D7            push a
0304   05B7 11            mov a, b
0305   05B8 FA FD FF      lea d, [bp + -3] ; $i
0306   05BB 2A            mov b, [d]
0307   05BC 56            add b, a
0308   05BD E4            pop a
0309   05BE             ; END TERMS
0310   05BE E7            pop d
0311   05BF FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0312   05C3 E4            pop a
0313   05C4 DA            push d
0314   05C5 FA 07 00      lea d, [bp + 7] ; $src
0315   05C8 FD 2A         mov d, [d]
0316   05CA D7            push a
0317   05CB DA            push d
0318   05CC FA FD FF      lea d, [bp + -3] ; $i
0319   05CF 2A            mov b, [d]
0320   05D0 E7            pop d
0321   05D1 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0322   05D5 E4            pop a
0323   05D6 32            mov bl, [d]
0324   05D7 A7 00         mov bh, 0
0325   05D9 E7            pop d
0326   05DA FD 3E         mov [d], bl
0327   05DC             _for5_update:
0328   05DC FA FD FF      lea d, [bp + -3] ; $i
0329   05DF DA            push d
0330   05E0 FA FD FF      lea d, [bp + -3] ; $i
0331   05E3 2A            mov b, [d]
0332   05E4             ; START TERMS
0333   05E4 D7            push a
0334   05E5 11            mov a, b
0335   05E6 26 01 00      mov b, $1
0336   05E9 56            add b, a
0337   05EA E4            pop a
0338   05EB             ; END TERMS
0339   05EB E7            pop d
0340   05EC FD 43         mov [d], b
0341   05EE 0A 88 05      jmp _for5_cond
0342   05F1             _for5_exit:
0343   05F1             ;; dest[dest_len + i] = 0; 
0344   05F1 FA 05 00      lea d, [bp + 5] ; $dest
0345   05F4 FD 2A         mov d, [d]
0346   05F6 D7            push a
0347   05F7 DA            push d
0348   05F8 FA FF FF      lea d, [bp + -1] ; $dest_len
0349   05FB 2A            mov b, [d]
0350   05FC             ; START TERMS
0351   05FC D7            push a
0352   05FD 11            mov a, b
0353   05FE FA FD FF      lea d, [bp + -3] ; $i
0354   0601 2A            mov b, [d]
0355   0602 56            add b, a
0356   0603 E4            pop a
0357   0604             ; END TERMS
0358   0604 E7            pop d
0359   0605 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0360   0609 E4            pop a
0361   060A DA            push d
0362   060B 26 00 00      mov b, $0
0363   060E E7            pop d
0364   060F FD 3E         mov [d], bl
0365   0611             ;; return dest; 
0366   0611 FA 05 00      lea d, [bp + 5] ; $dest
0367   0614 2A            mov b, [d]
0368   0615 F9            leave
0369   0616 09            ret
0370   0617             
0371   0617             strlen:
0372   0617 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0373   061A             ; $length 
0374   061A 52 02 00      sub sp, 2
0375   061D             ;; length = 0; 
0376   061D FA FF FF      lea d, [bp + -1] ; $length
0377   0620 DA            push d
0378   0621 26 00 00      mov b, $0
0379   0624 E7            pop d
0380   0625 FD 43         mov [d], b
0381   0627             ;; while (str[length] != 0) { 
0382   0627             _while6_cond:
0383   0627 FA 05 00      lea d, [bp + 5] ; $str
0384   062A FD 2A         mov d, [d]
0385   062C D7            push a
0386   062D DA            push d
0387   062E FA FF FF      lea d, [bp + -1] ; $length
0388   0631 2A            mov b, [d]
0389   0632 E7            pop d
0390   0633 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0391   0637 E4            pop a
0392   0638 32            mov bl, [d]
0393   0639 A7 00         mov bh, 0
0394   063B             ; START RELATIONAL
0395   063B D7            push a
0396   063C 11            mov a, b
0397   063D 26 00 00      mov b, $0
0398   0640 B0            cmp a, b
0399   0641 FD 72         sneq ; !=
0400   0643 E4            pop a
0401   0644             ; END RELATIONAL
0402   0644 C0 00 00      cmp b, 0
0403   0647 C6 5A 06      je _while6_exit
0404   064A             _while6_block:
0405   064A             ;; length++; 
0406   064A FA FF FF      lea d, [bp + -1] ; $length
0407   064D 2A            mov b, [d]
0408   064E D8            push b
0409   064F FD 77         inc b
0410   0651 FA FF FF      lea d, [bp + -1] ; $length
0411   0654 FD 43         mov [d], b
0412   0656 E5            pop b
0413   0657 0A 27 06      jmp _while6_cond
0414   065A             _while6_exit:
0415   065A             ;; return length; 
0416   065A FA FF FF      lea d, [bp + -1] ; $length
0417   065D 2A            mov b, [d]
0418   065E F9            leave
0419   065F 09            ret
0420   0660             
0421   0660             exit:
0422   0660 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0423   0663             
0424   0663             ; --- BEGIN INLINE ASM BLOCK
0425   0663 05 0B         syscall sys_terminate_proc
0426   0665             ; --- END INLINE ASM BLOCK
0427   0665             
0428   0665 F9            leave
0429   0666 09            ret
0430   0667             
0431   0667             atoi:
0432   0667 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0433   066A             ; $result 
0434   066A 10 00 00      mov a, $0
0435   066D 45 FF FF      mov [bp + -1], a
0436   0670             ; $sign 
0437   0670 10 01 00      mov a, $1
0438   0673 45 FD FF      mov [bp + -3], a
0439   0676 52 04 00      sub sp, 4
0440   0679             ;; while (*str == ' ') str++; 
0441   0679             _while7_cond:
0442   0679 FA 05 00      lea d, [bp + 5] ; $str
0443   067C 2A            mov b, [d]
0444   067D 74            mov d, b
0445   067E 32            mov bl, [d]
0446   067F A7 00         mov bh, 0
0447   0681             ; START RELATIONAL
0448   0681 D7            push a
0449   0682 11            mov a, b
0450   0683 26 20 00      mov b, $20
0451   0686 B0            cmp a, b
0452   0687 FD 71         seq ; ==
0453   0689 E4            pop a
0454   068A             ; END RELATIONAL
0455   068A C0 00 00      cmp b, 0
0456   068D C6 A0 06      je _while7_exit
0457   0690             _while7_block:
0458   0690             ;; str++; 
0459   0690 FA 05 00      lea d, [bp + 5] ; $str
0460   0693 2A            mov b, [d]
0461   0694 D8            push b
0462   0695 FD 77         inc b
0463   0697 FA 05 00      lea d, [bp + 5] ; $str
0464   069A FD 43         mov [d], b
0465   069C E5            pop b
0466   069D 0A 79 06      jmp _while7_cond
0467   06A0             _while7_exit:
0468   06A0             ;; if (*str == '-' || *str == '+') { 
0469   06A0             _if8_cond:
0470   06A0 FA 05 00      lea d, [bp + 5] ; $str
0471   06A3 2A            mov b, [d]
0472   06A4 74            mov d, b
0473   06A5 32            mov bl, [d]
0474   06A6 A7 00         mov bh, 0
0475   06A8             ; START RELATIONAL
0476   06A8 D7            push a
0477   06A9 11            mov a, b
0478   06AA 26 2D 00      mov b, $2d
0479   06AD B0            cmp a, b
0480   06AE FD 71         seq ; ==
0481   06B0 E4            pop a
0482   06B1             ; END RELATIONAL
0483   06B1 D7            push a
0484   06B2 11            mov a, b
0485   06B3 FA 05 00      lea d, [bp + 5] ; $str
0486   06B6 2A            mov b, [d]
0487   06B7 74            mov d, b
0488   06B8 32            mov bl, [d]
0489   06B9 A7 00         mov bh, 0
0490   06BB             ; START RELATIONAL
0491   06BB D7            push a
0492   06BC 11            mov a, b
0493   06BD 26 2B 00      mov b, $2b
0494   06C0 B0            cmp a, b
0495   06C1 FD 71         seq ; ==
0496   06C3 E4            pop a
0497   06C4             ; END RELATIONAL
0498   06C4 FD A8         sor a, b ; ||
0499   06C6 E4            pop a
0500   06C7 C0 00 00      cmp b, 0
0501   06CA C6 01 07      je _if8_exit
0502   06CD             _if8_true:
0503   06CD             ;; if (*str == '-') sign = -1; 
0504   06CD             _if9_cond:
0505   06CD FA 05 00      lea d, [bp + 5] ; $str
0506   06D0 2A            mov b, [d]
0507   06D1 74            mov d, b
0508   06D2 32            mov bl, [d]
0509   06D3 A7 00         mov bh, 0
0510   06D5             ; START RELATIONAL
0511   06D5 D7            push a
0512   06D6 11            mov a, b
0513   06D7 26 2D 00      mov b, $2d
0514   06DA B0            cmp a, b
0515   06DB FD 71         seq ; ==
0516   06DD E4            pop a
0517   06DE             ; END RELATIONAL
0518   06DE C0 00 00      cmp b, 0
0519   06E1 C6 F1 06      je _if9_exit
0520   06E4             _if9_true:
0521   06E4             ;; sign = -1; 
0522   06E4 FA FD FF      lea d, [bp + -3] ; $sign
0523   06E7 DA            push d
0524   06E8 26 FF FF      mov b, $ffff
0525   06EB E7            pop d
0526   06EC FD 43         mov [d], b
0527   06EE 0A F1 06      jmp _if9_exit
0528   06F1             _if9_exit:
0529   06F1             ;; str++; 
0530   06F1 FA 05 00      lea d, [bp + 5] ; $str
0531   06F4 2A            mov b, [d]
0532   06F5 D8            push b
0533   06F6 FD 77         inc b
0534   06F8 FA 05 00      lea d, [bp + 5] ; $str
0535   06FB FD 43         mov [d], b
0536   06FD E5            pop b
0537   06FE 0A 01 07      jmp _if8_exit
0538   0701             _if8_exit:
0539   0701             ;; while (*str >= '0' && *str <= '9') { 
0540   0701             _while10_cond:
0541   0701 FA 05 00      lea d, [bp + 5] ; $str
0542   0704 2A            mov b, [d]
0543   0705 74            mov d, b
0544   0706 32            mov bl, [d]
0545   0707 A7 00         mov bh, 0
0546   0709             ; START RELATIONAL
0547   0709 D7            push a
0548   070A 11            mov a, b
0549   070B 26 30 00      mov b, $30
0550   070E B0            cmp a, b
0551   070F FD 82         sgeu ; >= (unsigned)
0552   0711 E4            pop a
0553   0712             ; END RELATIONAL
0554   0712 D7            push a
0555   0713 11            mov a, b
0556   0714 FA 05 00      lea d, [bp + 5] ; $str
0557   0717 2A            mov b, [d]
0558   0718 74            mov d, b
0559   0719 32            mov bl, [d]
0560   071A A7 00         mov bh, 0
0561   071C             ; START RELATIONAL
0562   071C D7            push a
0563   071D 11            mov a, b
0564   071E 26 39 00      mov b, $39
0565   0721 B0            cmp a, b
0566   0722 FD 76         sleu ; <= (unsigned)
0567   0724 E4            pop a
0568   0725             ; END RELATIONAL
0569   0725 FD A7         sand a, b ; &&
0570   0727 E4            pop a
0571   0728 C0 00 00      cmp b, 0
0572   072B C6 66 07      je _while10_exit
0573   072E             _while10_block:
0574   072E             ;; result = result * 10 + (*str - '0'); 
0575   072E FA FF FF      lea d, [bp + -1] ; $result
0576   0731 DA            push d
0577   0732 FA FF FF      lea d, [bp + -1] ; $result
0578   0735 2A            mov b, [d]
0579   0736             ; START FACTORS
0580   0736 D7            push a
0581   0737 11            mov a, b
0582   0738 26 0A 00      mov b, $a
0583   073B AC            mul a, b ; *
0584   073C 11            mov a, b
0585   073D 27            mov b, a
0586   073E E4            pop a
0587   073F             ; END FACTORS
0588   073F             ; START TERMS
0589   073F D7            push a
0590   0740 11            mov a, b
0591   0741 FA 05 00      lea d, [bp + 5] ; $str
0592   0744 2A            mov b, [d]
0593   0745 74            mov d, b
0594   0746 32            mov bl, [d]
0595   0747 A7 00         mov bh, 0
0596   0749             ; START TERMS
0597   0749 D7            push a
0598   074A 11            mov a, b
0599   074B 26 30 00      mov b, $30
0600   074E 60            sub a, b
0601   074F 27            mov b, a
0602   0750 E4            pop a
0603   0751             ; END TERMS
0604   0751 56            add b, a
0605   0752 E4            pop a
0606   0753             ; END TERMS
0607   0753 E7            pop d
0608   0754 FD 43         mov [d], b
0609   0756             ;; str++; 
0610   0756 FA 05 00      lea d, [bp + 5] ; $str
0611   0759 2A            mov b, [d]
0612   075A D8            push b
0613   075B FD 77         inc b
0614   075D FA 05 00      lea d, [bp + 5] ; $str
0615   0760 FD 43         mov [d], b
0616   0762 E5            pop b
0617   0763 0A 01 07      jmp _while10_cond
0618   0766             _while10_exit:
0619   0766             ;; return sign * result; 
0620   0766 FA FD FF      lea d, [bp + -3] ; $sign
0621   0769 2A            mov b, [d]
0622   076A             ; START FACTORS
0623   076A D7            push a
0624   076B 11            mov a, b
0625   076C FA FF FF      lea d, [bp + -1] ; $result
0626   076F 2A            mov b, [d]
0627   0770 AC            mul a, b ; *
0628   0771 11            mov a, b
0629   0772 27            mov b, a
0630   0773 E4            pop a
0631   0774             ; END FACTORS
0632   0774 F9            leave
0633   0775 09            ret
0634   0776             
0635   0776             rand:
0636   0776 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0637   0779             ; $sec 
0638   0779 52 02 00      sub sp, 2
0639   077C             
0640   077C             ; --- BEGIN INLINE ASM BLOCK
0641   077C 19 00         mov al, 0
0642   077E 05 01         syscall sys_rtc					
0643   0780 1A            mov al, ah
0644   0781 FA FF FF      lea d, [bp + -1] ; $sec
0645   0784 1E            mov al, [d]
0646   0785 22 00         mov ah, 0
0647   0787             ; --- END INLINE ASM BLOCK
0648   0787             
0649   0787             ;; return sec; 
0650   0787 FA FF FF      lea d, [bp + -1] ; $sec
0651   078A 2A            mov b, [d]
0652   078B F9            leave
0653   078C 09            ret
0654   078D             
0655   078D             srand:
0656   078D F8 00 00      enter 0 ; (push bp; mov bp, sp)
0657   0790 F9            leave
0658   0791 09            ret
0659   0792             
0660   0792             malloc:
0661   0792 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0662   0795 F9            leave
0663   0796 09            ret
0664   0797             
0665   0797             calloc:
0666   0797 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0667   079A F9            leave
0668   079B 09            ret
0669   079C             
0670   079C             realloc:
0671   079C F8 00 00      enter 0 ; (push bp; mov bp, sp)
0672   079F F9            leave
0673   07A0 09            ret
0674   07A1             
0675   07A1             alloc:
0676   07A1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0677   07A4             ;; heap_top = heap_top + bytes; 
0678   07A4 3B 20 15      mov d, _heap_top ; $heap_top
0679   07A7 DA            push d
0680   07A8 3B 20 15      mov d, _heap_top ; $heap_top
0681   07AB 2A            mov b, [d]
0682   07AC             ; START TERMS
0683   07AC D7            push a
0684   07AD 11            mov a, b
0685   07AE FA 05 00      lea d, [bp + 5] ; $bytes
0686   07B1 2A            mov b, [d]
0687   07B2 56            add b, a
0688   07B3 E4            pop a
0689   07B4             ; END TERMS
0690   07B4 E7            pop d
0691   07B5 FD 43         mov [d], b
0692   07B7             ;; return heap_top - bytes; 
0693   07B7 3B 20 15      mov d, _heap_top ; $heap_top
0694   07BA 2A            mov b, [d]
0695   07BB             ; START TERMS
0696   07BB D7            push a
0697   07BC 11            mov a, b
0698   07BD FA 05 00      lea d, [bp + 5] ; $bytes
0699   07C0 2A            mov b, [d]
0700   07C1 60            sub a, b
0701   07C2 27            mov b, a
0702   07C3 E4            pop a
0703   07C4             ; END TERMS
0704   07C4 F9            leave
0705   07C5 09            ret
0706   07C6             
0707   07C6             free:
0708   07C6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0709   07C9             ;; return heap_top = heap_top - bytes; 
0710   07C9 3B 20 15      mov d, _heap_top ; $heap_top
0711   07CC DA            push d
0712   07CD 3B 20 15      mov d, _heap_top ; $heap_top
0713   07D0 2A            mov b, [d]
0714   07D1             ; START TERMS
0715   07D1 D7            push a
0716   07D2 11            mov a, b
0717   07D3 FA 05 00      lea d, [bp + 5] ; $bytes
0718   07D6 2A            mov b, [d]
0719   07D7 60            sub a, b
0720   07D8 27            mov b, a
0721   07D9 E4            pop a
0722   07DA             ; END TERMS
0723   07DA E7            pop d
0724   07DB FD 43         mov [d], b
0725   07DD F9            leave
0726   07DE 09            ret
0727   07DF             
0728   07DF             va_start:
0729   07DF F8 00 00      enter 0 ; (push bp; mov bp, sp)
0730   07E2             ;; argp->current_arg = first_fixed_param + sizeof(first_fixed_param); 
0731   07E2 FA 05 00      lea d, [bp + 5] ; $argp
0732   07E5 FD 2A         mov d, [d]
0733   07E7 58 00 00      add d, 0
0734   07EA DA            push d
0735   07EB FA 07 00      lea d, [bp + 7] ; $first_fixed_param
0736   07EE 2A            mov b, [d]
0737   07EF             ; START TERMS
0738   07EF D7            push a
0739   07F0 11            mov a, b
0740   07F1 26 02 00      mov b, 2
0741   07F4 56            add b, a
0742   07F5 E4            pop a
0743   07F6             ; END TERMS
0744   07F6 E7            pop d
0745   07F7 FD 43         mov [d], b
0746   07F9 F9            leave
0747   07FA 09            ret
0748   07FB             
0749   07FB             va_arg:
0750   07FB F8 00 00      enter 0 ; (push bp; mov bp, sp)
0751   07FE             ; $p 
0752   07FE 52 02 00      sub sp, 2
0753   0801             ;; p = argp->current_arg; 
0754   0801 FA FF FF      lea d, [bp + -1] ; $p
0755   0804 DA            push d
0756   0805 FA 05 00      lea d, [bp + 5] ; $argp
0757   0808 FD 2A         mov d, [d]
0758   080A 58 00 00      add d, 0
0759   080D 2A            mov b, [d]
0760   080E E7            pop d
0761   080F FD 43         mov [d], b
0762   0811             ;; argp->current_arg = argp->current_arg + size; 
0763   0811 FA 05 00      lea d, [bp + 5] ; $argp
0764   0814 FD 2A         mov d, [d]
0765   0816 58 00 00      add d, 0
0766   0819 DA            push d
0767   081A FA 05 00      lea d, [bp + 5] ; $argp
0768   081D FD 2A         mov d, [d]
0769   081F 58 00 00      add d, 0
0770   0822 2A            mov b, [d]
0771   0823             ; START TERMS
0772   0823 D7            push a
0773   0824 11            mov a, b
0774   0825 FA 07 00      lea d, [bp + 7] ; $size
0775   0828 2A            mov b, [d]
0776   0829 56            add b, a
0777   082A E4            pop a
0778   082B             ; END TERMS
0779   082B E7            pop d
0780   082C FD 43         mov [d], b
0781   082E             ;; return p; 
0782   082E FA FF FF      lea d, [bp + -1] ; $p
0783   0831 2A            mov b, [d]
0784   0832 F9            leave
0785   0833 09            ret
0786   0834             
0787   0834             va_end:
0788   0834 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0789   0837             ;; argp->current_arg =   0   ; 
0790   0837 FA 05 00      lea d, [bp + 5] ; $argp
0791   083A FD 2A         mov d, [d]
0792   083C 58 00 00      add d, 0
0793   083F DA            push d
0794   0840 26 00 00      mov b, $0
0795   0843 E7            pop d
0796   0844 FD 43         mov [d], b
0797   0846 F9            leave
0798   0847 09            ret
0799   0848             
0800   0848             printf:
0801   0848 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0802   084B             ; $p 
0803   084B             ; $fp 
0804   084B             ; $i 
0805   084B 52 06 00      sub sp, 6
0806   084E             ;; fp = format; 
0807   084E FA FD FF      lea d, [bp + -3] ; $fp
0808   0851 DA            push d
0809   0852 FA 05 00      lea d, [bp + 5] ; $format
0810   0855 2A            mov b, [d]
0811   0856 E7            pop d
0812   0857 FD 43         mov [d], b
0813   0859             ;; p = &format + 2; 
0814   0859 FA FF FF      lea d, [bp + -1] ; $p
0815   085C DA            push d
0816   085D FA 05 00      lea d, [bp + 5] ; $format
0817   0860 2D            mov b, d
0818   0861             ; START TERMS
0819   0861 D7            push a
0820   0862 11            mov a, b
0821   0863 26 02 00      mov b, $2
0822   0866 56            add b, a
0823   0867 E4            pop a
0824   0868             ; END TERMS
0825   0868 E7            pop d
0826   0869 FD 43         mov [d], b
0827   086B             ;; for(;;){ 
0828   086B             _for11_init:
0829   086B             _for11_cond:
0830   086B             _for11_block:
0831   086B             ;; if(!*fp) break; 
0832   086B             _if12_cond:
0833   086B FA FD FF      lea d, [bp + -3] ; $fp
0834   086E 2A            mov b, [d]
0835   086F 74            mov d, b
0836   0870 32            mov bl, [d]
0837   0871 A7 00         mov bh, 0
0838   0873 C0 00 00      cmp b, 0
0839   0876 FD 71         seq ; !
0840   0878 C0 00 00      cmp b, 0
0841   087B C6 84 08      je _if12_else
0842   087E             _if12_true:
0843   087E             ;; break; 
0844   087E 0A 8A 0A      jmp _for11_exit ; for break
0845   0881 0A 87 0A      jmp _if12_exit
0846   0884             _if12_else:
0847   0884             ;; if(*fp == '%'){ 
0848   0884             _if13_cond:
0849   0884 FA FD FF      lea d, [bp + -3] ; $fp
0850   0887 2A            mov b, [d]
0851   0888 74            mov d, b
0852   0889 32            mov bl, [d]
0853   088A A7 00         mov bh, 0
0854   088C             ; START RELATIONAL
0855   088C D7            push a
0856   088D 11            mov a, b
0857   088E 26 25 00      mov b, $25
0858   0891 B0            cmp a, b
0859   0892 FD 71         seq ; ==
0860   0894 E4            pop a
0861   0895             ; END RELATIONAL
0862   0895 C0 00 00      cmp b, 0
0863   0898 C6 6B 0A      je _if13_else
0864   089B             _if13_true:
0865   089B             ;; fp++; 
0866   089B FA FD FF      lea d, [bp + -3] ; $fp
0867   089E 2A            mov b, [d]
0868   089F D8            push b
0869   08A0 FD 77         inc b
0870   08A2 FA FD FF      lea d, [bp + -3] ; $fp
0871   08A5 FD 43         mov [d], b
0872   08A7 E5            pop b
0873   08A8             ;; switch(*fp){ 
0874   08A8             _switch14_expr:
0875   08A8 FA FD FF      lea d, [bp + -3] ; $fp
0876   08AB 2A            mov b, [d]
0877   08AC 74            mov d, b
0878   08AD 32            mov bl, [d]
0879   08AE A7 00         mov bh, 0
0880   08B0             _switch14_comparisons:
0881   08B0 C1 6C         cmp bl, $6c
0882   08B2 C6 DE 08      je _switch14_case0
0883   08B5 C1 4C         cmp bl, $4c
0884   08B7 C6 DE 08      je _switch14_case1
0885   08BA C1 64         cmp bl, $64
0886   08BC C6 AB 09      je _switch14_case2
0887   08BF C1 69         cmp bl, $69
0888   08C1 C6 AB 09      je _switch14_case3
0889   08C4 C1 75         cmp bl, $75
0890   08C6 C6 CF 09      je _switch14_case4
0891   08C9 C1 78         cmp bl, $78
0892   08CB C6 F3 09      je _switch14_case5
0893   08CE C1 63         cmp bl, $63
0894   08D0 C6 11 0A      je _switch14_case6
0895   08D3 C1 73         cmp bl, $73
0896   08D5 C6 30 0A      je _switch14_case7
0897   08D8 0A 4F 0A      jmp _switch14_default
0898   08DB 0A 5B 0A      jmp _switch14_exit
0899   08DE             _switch14_case0:
0900   08DE             _switch14_case1:
0901   08DE             ;; fp++; 
0902   08DE FA FD FF      lea d, [bp + -3] ; $fp
0903   08E1 2A            mov b, [d]
0904   08E2 D8            push b
0905   08E3 FD 77         inc b
0906   08E5 FA FD FF      lea d, [bp + -3] ; $fp
0907   08E8 FD 43         mov [d], b
0908   08EA E5            pop b
0909   08EB             ;; if(*fp == 'd' || *fp == 'i') 
0910   08EB             _if15_cond:
0911   08EB FA FD FF      lea d, [bp + -3] ; $fp
0912   08EE 2A            mov b, [d]
0913   08EF 74            mov d, b
0914   08F0 32            mov bl, [d]
0915   08F1 A7 00         mov bh, 0
0916   08F3             ; START RELATIONAL
0917   08F3 D7            push a
0918   08F4 11            mov a, b
0919   08F5 26 64 00      mov b, $64
0920   08F8 B0            cmp a, b
0921   08F9 FD 71         seq ; ==
0922   08FB E4            pop a
0923   08FC             ; END RELATIONAL
0924   08FC D7            push a
0925   08FD 11            mov a, b
0926   08FE FA FD FF      lea d, [bp + -3] ; $fp
0927   0901 2A            mov b, [d]
0928   0902 74            mov d, b
0929   0903 32            mov bl, [d]
0930   0904 A7 00         mov bh, 0
0931   0906             ; START RELATIONAL
0932   0906 D7            push a
0933   0907 11            mov a, b
0934   0908 26 69 00      mov b, $69
0935   090B B0            cmp a, b
0936   090C FD 71         seq ; ==
0937   090E E4            pop a
0938   090F             ; END RELATIONAL
0939   090F FD A8         sor a, b ; ||
0940   0911 E4            pop a
0941   0912 C0 00 00      cmp b, 0
0942   0915 C6 2C 09      je _if15_else
0943   0918             _if15_true:
0944   0918             ;; print_signed_long(*(long *)p); 
0945   0918 FD 79         mov g, b
0946   091A 28            mov b, c
0947   091B FD AB         swp b
0948   091D D8            push b
0949   091E FD 27         mov b, g
0950   0920 FD AB         swp b
0951   0922 D8            push b
0952   0923 07 18 0D      call print_signed_long
0953   0926 51 04 00      add sp, 4
0954   0929 0A 96 09      jmp _if15_exit
0955   092C             _if15_else:
0956   092C             ;; if(*fp == 'u') 
0957   092C             _if16_cond:
0958   092C FA FD FF      lea d, [bp + -3] ; $fp
0959   092F 2A            mov b, [d]
0960   0930 74            mov d, b
0961   0931 32            mov bl, [d]
0962   0932 A7 00         mov bh, 0
0963   0934             ; START RELATIONAL
0964   0934 D7            push a
0965   0935 11            mov a, b
0966   0936 26 75 00      mov b, $75
0967   0939 B0            cmp a, b
0968   093A FD 71         seq ; ==
0969   093C E4            pop a
0970   093D             ; END RELATIONAL
0971   093D C0 00 00      cmp b, 0
0972   0940 C6 57 09      je _if16_else
0973   0943             _if16_true:
0974   0943             ;; print_unsigned_long(*(unsigned long *)p); 
0975   0943 FD 79         mov g, b
0976   0945 28            mov b, c
0977   0946 FD AB         swp b
0978   0948 D8            push b
0979   0949 FD 27         mov b, g
0980   094B FD AB         swp b
0981   094D D8            push b
0982   094E 07 6A 0E      call print_unsigned_long
0983   0951 51 04 00      add sp, 4
0984   0954 0A 96 09      jmp _if16_exit
0985   0957             _if16_else:
0986   0957             ;; if(*fp == 'x') 
0987   0957             _if17_cond:
0988   0957 FA FD FF      lea d, [bp + -3] ; $fp
0989   095A 2A            mov b, [d]
0990   095B 74            mov d, b
0991   095C 32            mov bl, [d]
0992   095D A7 00         mov bh, 0
0993   095F             ; START RELATIONAL
0994   095F D7            push a
0995   0960 11            mov a, b
0996   0961 26 78 00      mov b, $78
0997   0964 B0            cmp a, b
0998   0965 FD 71         seq ; ==
0999   0967 E4            pop a
1000   0968             ; END RELATIONAL
1001   0968 C0 00 00      cmp b, 0
1002   096B C6 8D 09      je _if17_else
1003   096E             _if17_true:
1004   096E             ;; printx32(*(long int *)p); 
1005   096E FA FF FF      lea d, [bp + -1] ; $p
1006   0971 2A            mov b, [d]
1007   0972 74            mov d, b
1008   0973 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1009   0976 FD 39         mov c, b ; And place it into C
1010   0978 2A            mov b, [d] ; Lower Word in B
1011   0979 FD 79         mov g, b
1012   097B 28            mov b, c
1013   097C FD AB         swp b
1014   097E D8            push b
1015   097F FD 27         mov b, g
1016   0981 FD AB         swp b
1017   0983 D8            push b
1018   0984 07 A1 0A      call printx32
1019   0987 51 04 00      add sp, 4
1020   098A 0A 96 09      jmp _if17_exit
1021   098D             _if17_else:
1022   098D             ;; err("Unexpected format in printf."); 
1023   098D 26 DC 14      mov b, __s1 ; "Unexpected format in printf."
1024   0990 FD AB         swp b
1025   0992 D8            push b
1026   0993 07 8C 0A      call err
1027   0996             _if17_exit:
1028   0996             _if16_exit:
1029   0996             _if15_exit:
1030   0996             ;; p = p + 4; 
1031   0996 FA FF FF      lea d, [bp + -1] ; $p
1032   0999 DA            push d
1033   099A FA FF FF      lea d, [bp + -1] ; $p
1034   099D 2A            mov b, [d]
1035   099E             ; START TERMS
1036   099E D7            push a
1037   099F 11            mov a, b
1038   09A0 26 04 00      mov b, $4
1039   09A3 56            add b, a
1040   09A4 E4            pop a
1041   09A5             ; END TERMS
1042   09A5 E7            pop d
1043   09A6 FD 43         mov [d], b
1044   09A8             ;; break; 
1045   09A8 0A 5B 0A      jmp _switch14_exit ; case break
1046   09AB             _switch14_case2:
1047   09AB             _switch14_case3:
1048   09AB             ;; print_signed(*(int*)p); 
1049   09AB FA FF FF      lea d, [bp + -1] ; $p
1050   09AE 2A            mov b, [d]
1051   09AF 74            mov d, b
1052   09B0 2A            mov b, [d]
1053   09B1 FD AB         swp b
1054   09B3 D8            push b
1055   09B4 07 28 0C      call print_signed
1056   09B7 51 02 00      add sp, 2
1057   09BA             ;; p = p + 2; 
1058   09BA FA FF FF      lea d, [bp + -1] ; $p
1059   09BD DA            push d
1060   09BE FA FF FF      lea d, [bp + -1] ; $p
1061   09C1 2A            mov b, [d]
1062   09C2             ; START TERMS
1063   09C2 D7            push a
1064   09C3 11            mov a, b
1065   09C4 26 02 00      mov b, $2
1066   09C7 56            add b, a
1067   09C8 E4            pop a
1068   09C9             ; END TERMS
1069   09C9 E7            pop d
1070   09CA FD 43         mov [d], b
1071   09CC             ;; break; 
1072   09CC 0A 5B 0A      jmp _switch14_exit ; case break
1073   09CF             _switch14_case4:
1074   09CF             ;; print_unsigned(*(unsigned int*)p); 
1075   09CF FA FF FF      lea d, [bp + -1] ; $p
1076   09D2 2A            mov b, [d]
1077   09D3 74            mov d, b
1078   09D4 2A            mov b, [d]
1079   09D5 FD AB         swp b
1080   09D7 D8            push b
1081   09D8 07 67 0F      call print_unsigned
1082   09DB 51 02 00      add sp, 2
1083   09DE             ;; p = p + 2; 
1084   09DE FA FF FF      lea d, [bp + -1] ; $p
1085   09E1 DA            push d
1086   09E2 FA FF FF      lea d, [bp + -1] ; $p
1087   09E5 2A            mov b, [d]
1088   09E6             ; START TERMS
1089   09E6 D7            push a
1090   09E7 11            mov a, b
1091   09E8 26 02 00      mov b, $2
1092   09EB 56            add b, a
1093   09EC E4            pop a
1094   09ED             ; END TERMS
1095   09ED E7            pop d
1096   09EE FD 43         mov [d], b
1097   09F0             ;; break; 
1098   09F0 0A 5B 0A      jmp _switch14_exit ; case break
1099   09F3             _switch14_case5:
1100   09F3             
1101   09F3             ; --- BEGIN INLINE ASM BLOCK
1102   09F3 FA FF FF      lea d, [bp + -1] ; $p
1103   09F6 FD 2A         mov d, [d]
1104   09F8 2A            mov b, [d]
1105   09F9 07 BA 13      call print_u16x
1106   09FC             ; --- END INLINE ASM BLOCK
1107   09FC             
1108   09FC             ;; p = p + 2; 
1109   09FC FA FF FF      lea d, [bp + -1] ; $p
1110   09FF DA            push d
1111   0A00 FA FF FF      lea d, [bp + -1] ; $p
1112   0A03 2A            mov b, [d]
1113   0A04             ; START TERMS
1114   0A04 D7            push a
1115   0A05 11            mov a, b
1116   0A06 26 02 00      mov b, $2
1117   0A09 56            add b, a
1118   0A0A E4            pop a
1119   0A0B             ; END TERMS
1120   0A0B E7            pop d
1121   0A0C FD 43         mov [d], b
1122   0A0E             ;; break; 
1123   0A0E 0A 5B 0A      jmp _switch14_exit ; case break
1124   0A11             _switch14_case6:
1125   0A11             
1126   0A11             ; --- BEGIN INLINE ASM BLOCK
1127   0A11 FA FF FF      lea d, [bp + -1] ; $p
1128   0A14 FD 2A         mov d, [d]
1129   0A16 1E            mov al, [d]
1130   0A17 23            mov ah, al
1131   0A18 07 18 12      call _putchar
1132   0A1B             ; --- END INLINE ASM BLOCK
1133   0A1B             
1134   0A1B             ;; p = p + 2; 
1135   0A1B FA FF FF      lea d, [bp + -1] ; $p
1136   0A1E DA            push d
1137   0A1F FA FF FF      lea d, [bp + -1] ; $p
1138   0A22 2A            mov b, [d]
1139   0A23             ; START TERMS
1140   0A23 D7            push a
1141   0A24 11            mov a, b
1142   0A25 26 02 00      mov b, $2
1143   0A28 56            add b, a
1144   0A29 E4            pop a
1145   0A2A             ; END TERMS
1146   0A2A E7            pop d
1147   0A2B FD 43         mov [d], b
1148   0A2D             ;; break; 
1149   0A2D 0A 5B 0A      jmp _switch14_exit ; case break
1150   0A30             _switch14_case7:
1151   0A30             
1152   0A30             ; --- BEGIN INLINE ASM BLOCK
1153   0A30 FA FF FF      lea d, [bp + -1] ; $p
1154   0A33 FD 2A         mov d, [d]
1155   0A35 FD 2A         mov d, [d]
1156   0A37 07 62 13      call _puts
1157   0A3A             ; --- END INLINE ASM BLOCK
1158   0A3A             
1159   0A3A             ;; p = p + 2; 
1160   0A3A FA FF FF      lea d, [bp + -1] ; $p
1161   0A3D DA            push d
1162   0A3E FA FF FF      lea d, [bp + -1] ; $p
1163   0A41 2A            mov b, [d]
1164   0A42             ; START TERMS
1165   0A42 D7            push a
1166   0A43 11            mov a, b
1167   0A44 26 02 00      mov b, $2
1168   0A47 56            add b, a
1169   0A48 E4            pop a
1170   0A49             ; END TERMS
1171   0A49 E7            pop d
1172   0A4A FD 43         mov [d], b
1173   0A4C             ;; break; 
1174   0A4C 0A 5B 0A      jmp _switch14_exit ; case break
1175   0A4F             _switch14_default:
1176   0A4F             ;; print("Error: Unknown argument type.\n"); 
1177   0A4F 26 F9 14      mov b, __s2 ; "Error: Unknown argument type.\n"
1178   0A52 FD AB         swp b
1179   0A54 D8            push b
1180   0A55 07 7F 10      call print
1181   0A58 51 02 00      add sp, 2
1182   0A5B             _switch14_exit:
1183   0A5B             ;; fp++; 
1184   0A5B FA FD FF      lea d, [bp + -3] ; $fp
1185   0A5E 2A            mov b, [d]
1186   0A5F D8            push b
1187   0A60 FD 77         inc b
1188   0A62 FA FD FF      lea d, [bp + -3] ; $fp
1189   0A65 FD 43         mov [d], b
1190   0A67 E5            pop b
1191   0A68 0A 87 0A      jmp _if13_exit
1192   0A6B             _if13_else:
1193   0A6B             ;; putchar(*fp); 
1194   0A6B FA FD FF      lea d, [bp + -3] ; $fp
1195   0A6E 2A            mov b, [d]
1196   0A6F 74            mov d, b
1197   0A70 32            mov bl, [d]
1198   0A71 A7 00         mov bh, 0
1199   0A73 DD            push bl
1200   0A74 07 37 10      call putchar
1201   0A77 51 01 00      add sp, 1
1202   0A7A             ;; fp++; 
1203   0A7A FA FD FF      lea d, [bp + -3] ; $fp
1204   0A7D 2A            mov b, [d]
1205   0A7E D8            push b
1206   0A7F FD 77         inc b
1207   0A81 FA FD FF      lea d, [bp + -3] ; $fp
1208   0A84 FD 43         mov [d], b
1209   0A86 E5            pop b
1210   0A87             _if13_exit:
1211   0A87             _if12_exit:
1212   0A87             _for11_update:
1213   0A87 0A 6B 08      jmp _for11_cond
1214   0A8A             _for11_exit:
1215   0A8A F9            leave
1216   0A8B 09            ret
1217   0A8C             
1218   0A8C             err:
1219   0A8C F8 00 00      enter 0 ; (push bp; mov bp, sp)
1220   0A8F             ;; print(e); 
1221   0A8F FA 05 00      lea d, [bp + 5] ; $e
1222   0A92 2A            mov b, [d]
1223   0A93 FD AB         swp b
1224   0A95 D8            push b
1225   0A96 07 7F 10      call print
1226   0A99 51 02 00      add sp, 2
1227   0A9C             ;; exit(); 
1228   0A9C 07 60 06      call exit
1229   0A9F F9            leave
1230   0AA0 09            ret
1231   0AA1             
1232   0AA1             printx32:
1233   0AA1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1234   0AA4             
1235   0AA4             ; --- BEGIN INLINE ASM BLOCK
1236   0AA4 FA 05 00      lea d, [bp + 5] ; $hex
1237   0AA7 2B 02 00      mov b, [d+2]
1238   0AAA 07 BA 13      call print_u16x
1239   0AAD 2A            mov b, [d]
1240   0AAE 07 BA 13      call print_u16x
1241   0AB1             ; --- END INLINE ASM BLOCK
1242   0AB1             
1243   0AB1 F9            leave
1244   0AB2 09            ret
1245   0AB3             
1246   0AB3             printx16:
1247   0AB3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1248   0AB6             
1249   0AB6             ; --- BEGIN INLINE ASM BLOCK
1250   0AB6 FA 05 00      lea d, [bp + 5] ; $hex
1251   0AB9 2A            mov b, [d]
1252   0ABA 07 BA 13      call print_u16x
1253   0ABD             ; --- END INLINE ASM BLOCK
1254   0ABD             
1255   0ABD F9            leave
1256   0ABE 09            ret
1257   0ABF             
1258   0ABF             printx8:
1259   0ABF F8 00 00      enter 0 ; (push bp; mov bp, sp)
1260   0AC2             
1261   0AC2             ; --- BEGIN INLINE ASM BLOCK
1262   0AC2 FA 05 00      lea d, [bp + 5] ; $hex
1263   0AC5 32            mov bl, [d]
1264   0AC6 07 FE 13      call print_u8x
1265   0AC9             ; --- END INLINE ASM BLOCK
1266   0AC9             
1267   0AC9 F9            leave
1268   0ACA 09            ret
1269   0ACB             
1270   0ACB             hex_to_int:
1271   0ACB F8 00 00      enter 0 ; (push bp; mov bp, sp)
1272   0ACE             ; $value 
1273   0ACE 10 00 00      mov a, $0
1274   0AD1 45 FF FF      mov [bp + -1], a
1275   0AD4             ; $i 
1276   0AD4             ; $hex_char 
1277   0AD4             ; $len 
1278   0AD4 52 07 00      sub sp, 7
1279   0AD7             ;; len = strlen(hex_string); 
1280   0AD7 FA FA FF      lea d, [bp + -6] ; $len
1281   0ADA DA            push d
1282   0ADB FA 05 00      lea d, [bp + 5] ; $hex_string
1283   0ADE 2A            mov b, [d]
1284   0ADF FD AB         swp b
1285   0AE1 D8            push b
1286   0AE2 07 17 06      call strlen
1287   0AE5 51 02 00      add sp, 2
1288   0AE8 E7            pop d
1289   0AE9 FD 43         mov [d], b
1290   0AEB             ;; for (i = 0; i < len; i++) { 
1291   0AEB             _for18_init:
1292   0AEB FA FD FF      lea d, [bp + -3] ; $i
1293   0AEE DA            push d
1294   0AEF 26 00 00      mov b, $0
1295   0AF2 E7            pop d
1296   0AF3 FD 43         mov [d], b
1297   0AF5             _for18_cond:
1298   0AF5 FA FD FF      lea d, [bp + -3] ; $i
1299   0AF8 2A            mov b, [d]
1300   0AF9             ; START RELATIONAL
1301   0AF9 D7            push a
1302   0AFA 11            mov a, b
1303   0AFB FA FA FF      lea d, [bp + -6] ; $len
1304   0AFE 2A            mov b, [d]
1305   0AFF B0            cmp a, b
1306   0B00 FD 75         slu ; <= (unsigned)
1307   0B02 E4            pop a
1308   0B03             ; END RELATIONAL
1309   0B03 C0 00 00      cmp b, 0
1310   0B06 C6 08 0C      je _for18_exit
1311   0B09             _for18_block:
1312   0B09             ;; hex_char = hex_string[i]; 
1313   0B09 FA FC FF      lea d, [bp + -4] ; $hex_char
1314   0B0C DA            push d
1315   0B0D FA 05 00      lea d, [bp + 5] ; $hex_string
1316   0B10 FD 2A         mov d, [d]
1317   0B12 D7            push a
1318   0B13 DA            push d
1319   0B14 FA FD FF      lea d, [bp + -3] ; $i
1320   0B17 2A            mov b, [d]
1321   0B18 E7            pop d
1322   0B19 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
1323   0B1D E4            pop a
1324   0B1E 32            mov bl, [d]
1325   0B1F A7 00         mov bh, 0
1326   0B21 E7            pop d
1327   0B22 FD 3E         mov [d], bl
1328   0B24             ;; if (hex_char >= 'a' && hex_char <= 'f')  
1329   0B24             _if19_cond:
1330   0B24 FA FC FF      lea d, [bp + -4] ; $hex_char
1331   0B27 32            mov bl, [d]
1332   0B28 A7 00         mov bh, 0
1333   0B2A             ; START RELATIONAL
1334   0B2A D7            push a
1335   0B2B 11            mov a, b
1336   0B2C 26 61 00      mov b, $61
1337   0B2F B0            cmp a, b
1338   0B30 FD 80         sge ; >=
1339   0B32 E4            pop a
1340   0B33             ; END RELATIONAL
1341   0B33 D7            push a
1342   0B34 11            mov a, b
1343   0B35 FA FC FF      lea d, [bp + -4] ; $hex_char
1344   0B38 32            mov bl, [d]
1345   0B39 A7 00         mov bh, 0
1346   0B3B             ; START RELATIONAL
1347   0B3B D7            push a
1348   0B3C 11            mov a, b
1349   0B3D 26 66 00      mov b, $66
1350   0B40 B0            cmp a, b
1351   0B41 FD 74         sle ; <=
1352   0B43 E4            pop a
1353   0B44             ; END RELATIONAL
1354   0B44 FD A7         sand a, b ; &&
1355   0B46 E4            pop a
1356   0B47 C0 00 00      cmp b, 0
1357   0B4A C6 7B 0B      je _if19_else
1358   0B4D             _if19_true:
1359   0B4D             ;; value = (value * 16) + (hex_char - 'a' + 10); 
1360   0B4D FA FF FF      lea d, [bp + -1] ; $value
1361   0B50 DA            push d
1362   0B51 FA FF FF      lea d, [bp + -1] ; $value
1363   0B54 2A            mov b, [d]
1364   0B55             ; START FACTORS
1365   0B55 D7            push a
1366   0B56 11            mov a, b
1367   0B57 26 10 00      mov b, $10
1368   0B5A AC            mul a, b ; *
1369   0B5B 11            mov a, b
1370   0B5C 27            mov b, a
1371   0B5D E4            pop a
1372   0B5E             ; END FACTORS
1373   0B5E             ; START TERMS
1374   0B5E D7            push a
1375   0B5F 11            mov a, b
1376   0B60 FA FC FF      lea d, [bp + -4] ; $hex_char
1377   0B63 32            mov bl, [d]
1378   0B64 A7 00         mov bh, 0
1379   0B66             ; START TERMS
1380   0B66 D7            push a
1381   0B67 11            mov a, b
1382   0B68 26 61 00      mov b, $61
1383   0B6B 60            sub a, b
1384   0B6C 27            mov b, a
1385   0B6D 11            mov a, b
1386   0B6E 26 0A 00      mov b, $a
1387   0B71 56            add b, a
1388   0B72 E4            pop a
1389   0B73             ; END TERMS
1390   0B73 56            add b, a
1391   0B74 E4            pop a
1392   0B75             ; END TERMS
1393   0B75 E7            pop d
1394   0B76 FD 43         mov [d], b
1395   0B78 0A F8 0B      jmp _if19_exit
1396   0B7B             _if19_else:
1397   0B7B             ;; if (hex_char >= 'A' && hex_char <= 'F')  
1398   0B7B             _if20_cond:
1399   0B7B FA FC FF      lea d, [bp + -4] ; $hex_char
1400   0B7E 32            mov bl, [d]
1401   0B7F A7 00         mov bh, 0
1402   0B81             ; START RELATIONAL
1403   0B81 D7            push a
1404   0B82 11            mov a, b
1405   0B83 26 41 00      mov b, $41
1406   0B86 B0            cmp a, b
1407   0B87 FD 80         sge ; >=
1408   0B89 E4            pop a
1409   0B8A             ; END RELATIONAL
1410   0B8A D7            push a
1411   0B8B 11            mov a, b
1412   0B8C FA FC FF      lea d, [bp + -4] ; $hex_char
1413   0B8F 32            mov bl, [d]
1414   0B90 A7 00         mov bh, 0
1415   0B92             ; START RELATIONAL
1416   0B92 D7            push a
1417   0B93 11            mov a, b
1418   0B94 26 46 00      mov b, $46
1419   0B97 B0            cmp a, b
1420   0B98 FD 74         sle ; <=
1421   0B9A E4            pop a
1422   0B9B             ; END RELATIONAL
1423   0B9B FD A7         sand a, b ; &&
1424   0B9D E4            pop a
1425   0B9E C0 00 00      cmp b, 0
1426   0BA1 C6 D2 0B      je _if20_else
1427   0BA4             _if20_true:
1428   0BA4             ;; value = (value * 16) + (hex_char - 'A' + 10); 
1429   0BA4 FA FF FF      lea d, [bp + -1] ; $value
1430   0BA7 DA            push d
1431   0BA8 FA FF FF      lea d, [bp + -1] ; $value
1432   0BAB 2A            mov b, [d]
1433   0BAC             ; START FACTORS
1434   0BAC D7            push a
1435   0BAD 11            mov a, b
1436   0BAE 26 10 00      mov b, $10
1437   0BB1 AC            mul a, b ; *
1438   0BB2 11            mov a, b
1439   0BB3 27            mov b, a
1440   0BB4 E4            pop a
1441   0BB5             ; END FACTORS
1442   0BB5             ; START TERMS
1443   0BB5 D7            push a
1444   0BB6 11            mov a, b
1445   0BB7 FA FC FF      lea d, [bp + -4] ; $hex_char
1446   0BBA 32            mov bl, [d]
1447   0BBB A7 00         mov bh, 0
1448   0BBD             ; START TERMS
1449   0BBD D7            push a
1450   0BBE 11            mov a, b
1451   0BBF 26 41 00      mov b, $41
1452   0BC2 60            sub a, b
1453   0BC3 27            mov b, a
1454   0BC4 11            mov a, b
1455   0BC5 26 0A 00      mov b, $a
1456   0BC8 56            add b, a
1457   0BC9 E4            pop a
1458   0BCA             ; END TERMS
1459   0BCA 56            add b, a
1460   0BCB E4            pop a
1461   0BCC             ; END TERMS
1462   0BCC E7            pop d
1463   0BCD FD 43         mov [d], b
1464   0BCF 0A F8 0B      jmp _if20_exit
1465   0BD2             _if20_else:
1466   0BD2             ;; value = (value * 16) + (hex_char - '0'); 
1467   0BD2 FA FF FF      lea d, [bp + -1] ; $value
1468   0BD5 DA            push d
1469   0BD6 FA FF FF      lea d, [bp + -1] ; $value
1470   0BD9 2A            mov b, [d]
1471   0BDA             ; START FACTORS
1472   0BDA D7            push a
1473   0BDB 11            mov a, b
1474   0BDC 26 10 00      mov b, $10
1475   0BDF AC            mul a, b ; *
1476   0BE0 11            mov a, b
1477   0BE1 27            mov b, a
1478   0BE2 E4            pop a
1479   0BE3             ; END FACTORS
1480   0BE3             ; START TERMS
1481   0BE3 D7            push a
1482   0BE4 11            mov a, b
1483   0BE5 FA FC FF      lea d, [bp + -4] ; $hex_char
1484   0BE8 32            mov bl, [d]
1485   0BE9 A7 00         mov bh, 0
1486   0BEB             ; START TERMS
1487   0BEB D7            push a
1488   0BEC 11            mov a, b
1489   0BED 26 30 00      mov b, $30
1490   0BF0 60            sub a, b
1491   0BF1 27            mov b, a
1492   0BF2 E4            pop a
1493   0BF3             ; END TERMS
1494   0BF3 56            add b, a
1495   0BF4 E4            pop a
1496   0BF5             ; END TERMS
1497   0BF5 E7            pop d
1498   0BF6 FD 43         mov [d], b
1499   0BF8             _if20_exit:
1500   0BF8             _if19_exit:
1501   0BF8             _for18_update:
1502   0BF8 FA FD FF      lea d, [bp + -3] ; $i
1503   0BFB 2A            mov b, [d]
1504   0BFC D8            push b
1505   0BFD FD 77         inc b
1506   0BFF FA FD FF      lea d, [bp + -3] ; $i
1507   0C02 FD 43         mov [d], b
1508   0C04 E5            pop b
1509   0C05 0A F5 0A      jmp _for18_cond
1510   0C08             _for18_exit:
1511   0C08             ;; return value; 
1512   0C08 FA FF FF      lea d, [bp + -1] ; $value
1513   0C0B 2A            mov b, [d]
1514   0C0C F9            leave
1515   0C0D 09            ret
1516   0C0E             
1517   0C0E             gets:
1518   0C0E F8 00 00      enter 0 ; (push bp; mov bp, sp)
1519   0C11             
1520   0C11             ; --- BEGIN INLINE ASM BLOCK
1521   0C11 FA 05 00      lea d, [bp + 5] ; $s
1522   0C14 15            mov a, [d]
1523   0C15 3C            mov d, a
1524   0C16 07 1F 12      call _gets
1525   0C19             ; --- END INLINE ASM BLOCK
1526   0C19             
1527   0C19             ;; return strlen(s); 
1528   0C19 FA 05 00      lea d, [bp + 5] ; $s
1529   0C1C 2A            mov b, [d]
1530   0C1D FD AB         swp b
1531   0C1F D8            push b
1532   0C20 07 17 06      call strlen
1533   0C23 51 02 00      add sp, 2
1534   0C26 F9            leave
1535   0C27 09            ret
1536   0C28             
1537   0C28             print_signed:
1538   0C28 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1539   0C2B             ; $digits 
1540   0C2B             ; $i 
1541   0C2B 10 00 00      mov a, $0
1542   0C2E 45 FA FF      mov [bp + -6], a
1543   0C31 52 07 00      sub sp, 7
1544   0C34             ;; if (num < 0) { 
1545   0C34             _if21_cond:
1546   0C34 FA 05 00      lea d, [bp + 5] ; $num
1547   0C37 2A            mov b, [d]
1548   0C38             ; START RELATIONAL
1549   0C38 D7            push a
1550   0C39 11            mov a, b
1551   0C3A 26 00 00      mov b, $0
1552   0C3D B0            cmp a, b
1553   0C3E FD 75         slu ; <= (unsigned)
1554   0C40 E4            pop a
1555   0C41             ; END RELATIONAL
1556   0C41 C0 00 00      cmp b, 0
1557   0C44 C6 61 0C      je _if21_else
1558   0C47             _if21_true:
1559   0C47             ;; putchar('-'); 
1560   0C47 26 2D 00      mov b, $2d
1561   0C4A DD            push bl
1562   0C4B 07 37 10      call putchar
1563   0C4E 51 01 00      add sp, 1
1564   0C51             ;; num = -num; 
1565   0C51 FA 05 00      lea d, [bp + 5] ; $num
1566   0C54 DA            push d
1567   0C55 FA 05 00      lea d, [bp + 5] ; $num
1568   0C58 2A            mov b, [d]
1569   0C59 FD 97         neg b
1570   0C5B E7            pop d
1571   0C5C FD 43         mov [d], b
1572   0C5E 0A 83 0C      jmp _if21_exit
1573   0C61             _if21_else:
1574   0C61             ;; if (num == 0) { 
1575   0C61             _if22_cond:
1576   0C61 FA 05 00      lea d, [bp + 5] ; $num
1577   0C64 2A            mov b, [d]
1578   0C65             ; START RELATIONAL
1579   0C65 D7            push a
1580   0C66 11            mov a, b
1581   0C67 26 00 00      mov b, $0
1582   0C6A B0            cmp a, b
1583   0C6B FD 71         seq ; ==
1584   0C6D E4            pop a
1585   0C6E             ; END RELATIONAL
1586   0C6E C0 00 00      cmp b, 0
1587   0C71 C6 83 0C      je _if22_exit
1588   0C74             _if22_true:
1589   0C74             ;; putchar('0'); 
1590   0C74 26 30 00      mov b, $30
1591   0C77 DD            push bl
1592   0C78 07 37 10      call putchar
1593   0C7B 51 01 00      add sp, 1
1594   0C7E             ;; return; 
1595   0C7E F9            leave
1596   0C7F 09            ret
1597   0C80 0A 83 0C      jmp _if22_exit
1598   0C83             _if22_exit:
1599   0C83             _if21_exit:
1600   0C83             ;; while (num > 0) { 
1601   0C83             _while23_cond:
1602   0C83 FA 05 00      lea d, [bp + 5] ; $num
1603   0C86 2A            mov b, [d]
1604   0C87             ; START RELATIONAL
1605   0C87 D7            push a
1606   0C88 11            mov a, b
1607   0C89 26 00 00      mov b, $0
1608   0C8C B0            cmp a, b
1609   0C8D FD 7F         sgt ; >
1610   0C8F E4            pop a
1611   0C90             ; END RELATIONAL
1612   0C90 C0 00 00      cmp b, 0
1613   0C93 C6 DD 0C      je _while23_exit
1614   0C96             _while23_block:
1615   0C96             ;; digits[i] = '0' + (num % 10); 
1616   0C96 FA FC FF      lea d, [bp + -4] ; $digits
1617   0C99 D7            push a
1618   0C9A DA            push d
1619   0C9B FA FA FF      lea d, [bp + -6] ; $i
1620   0C9E 2A            mov b, [d]
1621   0C9F E7            pop d
1622   0CA0 5A            add d, b
1623   0CA1 E4            pop a
1624   0CA2 DA            push d
1625   0CA3 26 30 00      mov b, $30
1626   0CA6             ; START TERMS
1627   0CA6 D7            push a
1628   0CA7 11            mov a, b
1629   0CA8 FA 05 00      lea d, [bp + 5] ; $num
1630   0CAB 2A            mov b, [d]
1631   0CAC             ; START FACTORS
1632   0CAC D7            push a
1633   0CAD 11            mov a, b
1634   0CAE 26 0A 00      mov b, $a
1635   0CB1 AE            div a, b ; 
1636   0CB2 11            mov a, b
1637   0CB3 27            mov b, a
1638   0CB4 E4            pop a
1639   0CB5             ; END FACTORS
1640   0CB5 56            add b, a
1641   0CB6 E4            pop a
1642   0CB7             ; END TERMS
1643   0CB7 E7            pop d
1644   0CB8 FD 3E         mov [d], bl
1645   0CBA             ;; num = num / 10; 
1646   0CBA FA 05 00      lea d, [bp + 5] ; $num
1647   0CBD DA            push d
1648   0CBE FA 05 00      lea d, [bp + 5] ; $num
1649   0CC1 2A            mov b, [d]
1650   0CC2             ; START FACTORS
1651   0CC2 D7            push a
1652   0CC3 11            mov a, b
1653   0CC4 26 0A 00      mov b, $a
1654   0CC7 AE            div a, b
1655   0CC8 27            mov b, a
1656   0CC9 E4            pop a
1657   0CCA             ; END FACTORS
1658   0CCA E7            pop d
1659   0CCB FD 43         mov [d], b
1660   0CCD             ;; i++; 
1661   0CCD FA FA FF      lea d, [bp + -6] ; $i
1662   0CD0 2A            mov b, [d]
1663   0CD1 D8            push b
1664   0CD2 FD 77         inc b
1665   0CD4 FA FA FF      lea d, [bp + -6] ; $i
1666   0CD7 FD 43         mov [d], b
1667   0CD9 E5            pop b
1668   0CDA 0A 83 0C      jmp _while23_cond
1669   0CDD             _while23_exit:
1670   0CDD             ;; while (i > 0) { 
1671   0CDD             _while24_cond:
1672   0CDD FA FA FF      lea d, [bp + -6] ; $i
1673   0CE0 2A            mov b, [d]
1674   0CE1             ; START RELATIONAL
1675   0CE1 D7            push a
1676   0CE2 11            mov a, b
1677   0CE3 26 00 00      mov b, $0
1678   0CE6 B0            cmp a, b
1679   0CE7 FD 7F         sgt ; >
1680   0CE9 E4            pop a
1681   0CEA             ; END RELATIONAL
1682   0CEA C0 00 00      cmp b, 0
1683   0CED C6 16 0D      je _while24_exit
1684   0CF0             _while24_block:
1685   0CF0             ;; i--; 
1686   0CF0 FA FA FF      lea d, [bp + -6] ; $i
1687   0CF3 2A            mov b, [d]
1688   0CF4 D8            push b
1689   0CF5 FD 7D         dec b
1690   0CF7 FA FA FF      lea d, [bp + -6] ; $i
1691   0CFA FD 43         mov [d], b
1692   0CFC E5            pop b
1693   0CFD             ;; putchar(digits[i]); 
1694   0CFD FA FC FF      lea d, [bp + -4] ; $digits
1695   0D00 D7            push a
1696   0D01 DA            push d
1697   0D02 FA FA FF      lea d, [bp + -6] ; $i
1698   0D05 2A            mov b, [d]
1699   0D06 E7            pop d
1700   0D07 5A            add d, b
1701   0D08 E4            pop a
1702   0D09 32            mov bl, [d]
1703   0D0A A7 00         mov bh, 0
1704   0D0C DD            push bl
1705   0D0D 07 37 10      call putchar
1706   0D10 51 01 00      add sp, 1
1707   0D13 0A DD 0C      jmp _while24_cond
1708   0D16             _while24_exit:
1709   0D16 F9            leave
1710   0D17 09            ret
1711   0D18             
1712   0D18             print_signed_long:
1713   0D18 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1714   0D1B             ; $digits 
1715   0D1B             ; $i 
1716   0D1B 10 00 00      mov a, $0
1717   0D1E 45 F5 FF      mov [bp + -11], a
1718   0D21 52 0C 00      sub sp, 12
1719   0D24             ;; if (num < 0) { 
1720   0D24             _if25_cond:
1721   0D24 FA 05 00      lea d, [bp + 5] ; $num
1722   0D27 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1723   0D2A FD 39         mov c, b ; And place it into C
1724   0D2C 2A            mov b, [d] ; Lower Word in B
1725   0D2D             ; START RELATIONAL
1726   0D2D D7            push a
1727   0D2E FD D8         push g
1728   0D30 11            mov a, b
1729   0D31 FD 7A         mov g, c
1730   0D33 26 00 00      mov b, $0
1731   0D36 4D            mov si, a
1732   0D37 11            mov a, b
1733   0D38 4F            mov di, a
1734   0D39 FD 12         mov a, g
1735   0D3B 28            mov b, c
1736   0D3C B0            cmp a, b
1737   0D3D FD 75         slu ; <
1738   0D3F D8            push b
1739   0D40 28            mov b, c
1740   0D41 FD 71         seq ; ==
1741   0D43 D8            push b
1742   0D44 50            mov a, di
1743   0D45 27            mov b, a
1744   0D46 4E            mov a, si
1745   0D47 B0            cmp a, b
1746   0D48 FD 75         slu ; <
1747   0D4A E4            pop a
1748   0D4B FD 92         and b, a
1749   0D4D E4            pop a
1750   0D4E FD 70         or b, a
1751   0D50               
1752   0D50 FD F1         pop g
1753   0D52 E4            pop a
1754   0D53             ; END RELATIONAL
1755   0D53 C0 00 00      cmp b, 0
1756   0D56 C6 7D 0D      je _if25_else
1757   0D59             _if25_true:
1758   0D59             ;; putchar('-'); 
1759   0D59 26 2D 00      mov b, $2d
1760   0D5C DD            push bl
1761   0D5D 07 37 10      call putchar
1762   0D60 51 01 00      add sp, 1
1763   0D63             ;; num = -num; 
1764   0D63 FA 05 00      lea d, [bp + 5] ; $num
1765   0D66 DA            push d
1766   0D67 FA 05 00      lea d, [bp + 5] ; $num
1767   0D6A 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1768   0D6D FD 39         mov c, b ; And place it into C
1769   0D6F 2A            mov b, [d] ; Lower Word in B
1770   0D70 FD 97         neg b
1771   0D72 E7            pop d
1772   0D73 FD 43         mov [d], b
1773   0D75 28            mov b, c
1774   0D76 FD 44 02 00   mov [d + 2], b
1775   0D7A 0A B4 0D      jmp _if25_exit
1776   0D7D             _if25_else:
1777   0D7D             ;; if (num == 0) { 
1778   0D7D             _if26_cond:
1779   0D7D FA 05 00      lea d, [bp + 5] ; $num
1780   0D80 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1781   0D83 FD 39         mov c, b ; And place it into C
1782   0D85 2A            mov b, [d] ; Lower Word in B
1783   0D86             ; START RELATIONAL
1784   0D86 D7            push a
1785   0D87 FD D8         push g
1786   0D89 11            mov a, b
1787   0D8A FD 7A         mov g, c
1788   0D8C 26 00 00      mov b, $0
1789   0D8F B0            cmp a, b
1790   0D90 FD 71         seq ; ==
1791   0D92 D8            push b
1792   0D93 12            mov a, c
1793   0D94 FD 27         mov b, g
1794   0D96 B0            cmp a, b
1795   0D97 FD 71         seq ; ==
1796   0D99 E4            pop a
1797   0D9A FD A7         sand a, b
1798   0D9C FD F1         pop g
1799   0D9E E4            pop a
1800   0D9F             ; END RELATIONAL
1801   0D9F C0 00 00      cmp b, 0
1802   0DA2 C6 B4 0D      je _if26_exit
1803   0DA5             _if26_true:
1804   0DA5             ;; putchar('0'); 
1805   0DA5 26 30 00      mov b, $30
1806   0DA8 DD            push bl
1807   0DA9 07 37 10      call putchar
1808   0DAC 51 01 00      add sp, 1
1809   0DAF             ;; return; 
1810   0DAF F9            leave
1811   0DB0 09            ret
1812   0DB1 0A B4 0D      jmp _if26_exit
1813   0DB4             _if26_exit:
1814   0DB4             _if25_exit:
1815   0DB4             ;; while (num > 0) { 
1816   0DB4             _while27_cond:
1817   0DB4 FA 05 00      lea d, [bp + 5] ; $num
1818   0DB7 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1819   0DBA FD 39         mov c, b ; And place it into C
1820   0DBC 2A            mov b, [d] ; Lower Word in B
1821   0DBD             ; START RELATIONAL
1822   0DBD D7            push a
1823   0DBE FD D8         push g
1824   0DC0 11            mov a, b
1825   0DC1 FD 7A         mov g, c
1826   0DC3 26 00 00      mov b, $0
1827   0DC6 B0            cmp a, b
1828   0DC7 FD 7F         sgt ; >
1829   0DC9 FD F1         pop g
1830   0DCB E4            pop a
1831   0DCC             ; END RELATIONAL
1832   0DCC C0 00 00      cmp b, 0
1833   0DCF C6 2F 0E      je _while27_exit
1834   0DD2             _while27_block:
1835   0DD2             ;; digits[i] = '0' + (num % 10); 
1836   0DD2 FA F7 FF      lea d, [bp + -9] ; $digits
1837   0DD5 D7            push a
1838   0DD6 DA            push d
1839   0DD7 FA F5 FF      lea d, [bp + -11] ; $i
1840   0DDA 2A            mov b, [d]
1841   0DDB E7            pop d
1842   0DDC 5A            add d, b
1843   0DDD E4            pop a
1844   0DDE DA            push d
1845   0DDF 26 30 00      mov b, $30
1846   0DE2             ; START TERMS
1847   0DE2 D7            push a
1848   0DE3 11            mov a, b
1849   0DE4 FA 05 00      lea d, [bp + 5] ; $num
1850   0DE7 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1851   0DEA FD 39         mov c, b ; And place it into C
1852   0DEC 2A            mov b, [d] ; Lower Word in B
1853   0DED             ; START FACTORS
1854   0DED D7            push a
1855   0DEE 11            mov a, b
1856   0DEF 26 0A 00      mov b, $a
1857   0DF2 AE            div a, b ; 
1858   0DF3 11            mov a, b
1859   0DF4 27            mov b, a
1860   0DF5 E4            pop a
1861   0DF6             ; END FACTORS
1862   0DF6 54            add a, b
1863   0DF7 D7            push a
1864   0DF8 FD 12         mov a, g
1865   0DFA 28            mov b, c
1866   0DFB 5C            adc a, b
1867   0DFC 39            mov c, a
1868   0DFD E5            pop b
1869   0DFE E4            pop a
1870   0DFF             ; END TERMS
1871   0DFF E7            pop d
1872   0E00 FD 3E         mov [d], bl
1873   0E02             ;; num = num / 10; 
1874   0E02 FA 05 00      lea d, [bp + 5] ; $num
1875   0E05 DA            push d
1876   0E06 FA 05 00      lea d, [bp + 5] ; $num
1877   0E09 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1878   0E0C FD 39         mov c, b ; And place it into C
1879   0E0E 2A            mov b, [d] ; Lower Word in B
1880   0E0F             ; START FACTORS
1881   0E0F D7            push a
1882   0E10 11            mov a, b
1883   0E11 26 0A 00      mov b, $a
1884   0E14 AE            div a, b
1885   0E15 27            mov b, a
1886   0E16 E4            pop a
1887   0E17             ; END FACTORS
1888   0E17 E7            pop d
1889   0E18 FD 43         mov [d], b
1890   0E1A 28            mov b, c
1891   0E1B FD 44 02 00   mov [d + 2], b
1892   0E1F             ;; i++; 
1893   0E1F FA F5 FF      lea d, [bp + -11] ; $i
1894   0E22 2A            mov b, [d]
1895   0E23 D8            push b
1896   0E24 FD 77         inc b
1897   0E26 FA F5 FF      lea d, [bp + -11] ; $i
1898   0E29 FD 43         mov [d], b
1899   0E2B E5            pop b
1900   0E2C 0A B4 0D      jmp _while27_cond
1901   0E2F             _while27_exit:
1902   0E2F             ;; while (i > 0) { 
1903   0E2F             _while28_cond:
1904   0E2F FA F5 FF      lea d, [bp + -11] ; $i
1905   0E32 2A            mov b, [d]
1906   0E33             ; START RELATIONAL
1907   0E33 D7            push a
1908   0E34 11            mov a, b
1909   0E35 26 00 00      mov b, $0
1910   0E38 B0            cmp a, b
1911   0E39 FD 7F         sgt ; >
1912   0E3B E4            pop a
1913   0E3C             ; END RELATIONAL
1914   0E3C C0 00 00      cmp b, 0
1915   0E3F C6 68 0E      je _while28_exit
1916   0E42             _while28_block:
1917   0E42             ;; i--; 
1918   0E42 FA F5 FF      lea d, [bp + -11] ; $i
1919   0E45 2A            mov b, [d]
1920   0E46 D8            push b
1921   0E47 FD 7D         dec b
1922   0E49 FA F5 FF      lea d, [bp + -11] ; $i
1923   0E4C FD 43         mov [d], b
1924   0E4E E5            pop b
1925   0E4F             ;; putchar(digits[i]); 
1926   0E4F FA F7 FF      lea d, [bp + -9] ; $digits
1927   0E52 D7            push a
1928   0E53 DA            push d
1929   0E54 FA F5 FF      lea d, [bp + -11] ; $i
1930   0E57 2A            mov b, [d]
1931   0E58 E7            pop d
1932   0E59 5A            add d, b
1933   0E5A E4            pop a
1934   0E5B 32            mov bl, [d]
1935   0E5C A7 00         mov bh, 0
1936   0E5E DD            push bl
1937   0E5F 07 37 10      call putchar
1938   0E62 51 01 00      add sp, 1
1939   0E65 0A 2F 0E      jmp _while28_cond
1940   0E68             _while28_exit:
1941   0E68 F9            leave
1942   0E69 09            ret
1943   0E6A             
1944   0E6A             print_unsigned_long:
1945   0E6A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1946   0E6D             ; $digits 
1947   0E6D             ; $i 
1948   0E6D 52 0C 00      sub sp, 12
1949   0E70             ;; i = 0; 
1950   0E70 FA F5 FF      lea d, [bp + -11] ; $i
1951   0E73 DA            push d
1952   0E74 26 00 00      mov b, $0
1953   0E77 E7            pop d
1954   0E78 FD 43         mov [d], b
1955   0E7A             ;; if(num == 0){ 
1956   0E7A             _if29_cond:
1957   0E7A FA 05 00      lea d, [bp + 5] ; $num
1958   0E7D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1959   0E80 FD 39         mov c, b ; And place it into C
1960   0E82 2A            mov b, [d] ; Lower Word in B
1961   0E83             ; START RELATIONAL
1962   0E83 D7            push a
1963   0E84 FD D8         push g
1964   0E86 11            mov a, b
1965   0E87 FD 7A         mov g, c
1966   0E89 26 00 00      mov b, $0
1967   0E8C B0            cmp a, b
1968   0E8D FD 71         seq ; ==
1969   0E8F D8            push b
1970   0E90 12            mov a, c
1971   0E91 FD 27         mov b, g
1972   0E93 B0            cmp a, b
1973   0E94 FD 71         seq ; ==
1974   0E96 E4            pop a
1975   0E97 FD A7         sand a, b
1976   0E99 FD F1         pop g
1977   0E9B E4            pop a
1978   0E9C             ; END RELATIONAL
1979   0E9C C0 00 00      cmp b, 0
1980   0E9F C6 B1 0E      je _if29_exit
1981   0EA2             _if29_true:
1982   0EA2             ;; putchar('0'); 
1983   0EA2 26 30 00      mov b, $30
1984   0EA5 DD            push bl
1985   0EA6 07 37 10      call putchar
1986   0EA9 51 01 00      add sp, 1
1987   0EAC             ;; return; 
1988   0EAC F9            leave
1989   0EAD 09            ret
1990   0EAE 0A B1 0E      jmp _if29_exit
1991   0EB1             _if29_exit:
1992   0EB1             ;; while (num > 0) { 
1993   0EB1             _while30_cond:
1994   0EB1 FA 05 00      lea d, [bp + 5] ; $num
1995   0EB4 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1996   0EB7 FD 39         mov c, b ; And place it into C
1997   0EB9 2A            mov b, [d] ; Lower Word in B
1998   0EBA             ; START RELATIONAL
1999   0EBA D7            push a
2000   0EBB FD D8         push g
2001   0EBD 11            mov a, b
2002   0EBE FD 7A         mov g, c
2003   0EC0 26 00 00      mov b, $0
2004   0EC3 B0            cmp a, b
2005   0EC4 FD 81         sgu ; > (unsigned)
2006   0EC6 FD F1         pop g
2007   0EC8 E4            pop a
2008   0EC9             ; END RELATIONAL
2009   0EC9 C0 00 00      cmp b, 0
2010   0ECC C6 2C 0F      je _while30_exit
2011   0ECF             _while30_block:
2012   0ECF             ;; digits[i] = '0' + (num % 10); 
2013   0ECF FA F7 FF      lea d, [bp + -9] ; $digits
2014   0ED2 D7            push a
2015   0ED3 DA            push d
2016   0ED4 FA F5 FF      lea d, [bp + -11] ; $i
2017   0ED7 2A            mov b, [d]
2018   0ED8 E7            pop d
2019   0ED9 5A            add d, b
2020   0EDA E4            pop a
2021   0EDB DA            push d
2022   0EDC 26 30 00      mov b, $30
2023   0EDF             ; START TERMS
2024   0EDF D7            push a
2025   0EE0 11            mov a, b
2026   0EE1 FA 05 00      lea d, [bp + 5] ; $num
2027   0EE4 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2028   0EE7 FD 39         mov c, b ; And place it into C
2029   0EE9 2A            mov b, [d] ; Lower Word in B
2030   0EEA             ; START FACTORS
2031   0EEA D7            push a
2032   0EEB 11            mov a, b
2033   0EEC 26 0A 00      mov b, $a
2034   0EEF AE            div a, b ; 
2035   0EF0 11            mov a, b
2036   0EF1 27            mov b, a
2037   0EF2 E4            pop a
2038   0EF3             ; END FACTORS
2039   0EF3 54            add a, b
2040   0EF4 D7            push a
2041   0EF5 FD 12         mov a, g
2042   0EF7 28            mov b, c
2043   0EF8 5C            adc a, b
2044   0EF9 39            mov c, a
2045   0EFA E5            pop b
2046   0EFB E4            pop a
2047   0EFC             ; END TERMS
2048   0EFC E7            pop d
2049   0EFD FD 3E         mov [d], bl
2050   0EFF             ;; num = num / 10; 
2051   0EFF FA 05 00      lea d, [bp + 5] ; $num
2052   0F02 DA            push d
2053   0F03 FA 05 00      lea d, [bp + 5] ; $num
2054   0F06 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2055   0F09 FD 39         mov c, b ; And place it into C
2056   0F0B 2A            mov b, [d] ; Lower Word in B
2057   0F0C             ; START FACTORS
2058   0F0C D7            push a
2059   0F0D 11            mov a, b
2060   0F0E 26 0A 00      mov b, $a
2061   0F11 AE            div a, b
2062   0F12 27            mov b, a
2063   0F13 E4            pop a
2064   0F14             ; END FACTORS
2065   0F14 E7            pop d
2066   0F15 FD 43         mov [d], b
2067   0F17 28            mov b, c
2068   0F18 FD 44 02 00   mov [d + 2], b
2069   0F1C             ;; i++; 
2070   0F1C FA F5 FF      lea d, [bp + -11] ; $i
2071   0F1F 2A            mov b, [d]
2072   0F20 D8            push b
2073   0F21 FD 77         inc b
2074   0F23 FA F5 FF      lea d, [bp + -11] ; $i
2075   0F26 FD 43         mov [d], b
2076   0F28 E5            pop b
2077   0F29 0A B1 0E      jmp _while30_cond
2078   0F2C             _while30_exit:
2079   0F2C             ;; while (i > 0) { 
2080   0F2C             _while31_cond:
2081   0F2C FA F5 FF      lea d, [bp + -11] ; $i
2082   0F2F 2A            mov b, [d]
2083   0F30             ; START RELATIONAL
2084   0F30 D7            push a
2085   0F31 11            mov a, b
2086   0F32 26 00 00      mov b, $0
2087   0F35 B0            cmp a, b
2088   0F36 FD 7F         sgt ; >
2089   0F38 E4            pop a
2090   0F39             ; END RELATIONAL
2091   0F39 C0 00 00      cmp b, 0
2092   0F3C C6 65 0F      je _while31_exit
2093   0F3F             _while31_block:
2094   0F3F             ;; i--; 
2095   0F3F FA F5 FF      lea d, [bp + -11] ; $i
2096   0F42 2A            mov b, [d]
2097   0F43 D8            push b
2098   0F44 FD 7D         dec b
2099   0F46 FA F5 FF      lea d, [bp + -11] ; $i
2100   0F49 FD 43         mov [d], b
2101   0F4B E5            pop b
2102   0F4C             ;; putchar(digits[i]); 
2103   0F4C FA F7 FF      lea d, [bp + -9] ; $digits
2104   0F4F D7            push a
2105   0F50 DA            push d
2106   0F51 FA F5 FF      lea d, [bp + -11] ; $i
2107   0F54 2A            mov b, [d]
2108   0F55 E7            pop d
2109   0F56 5A            add d, b
2110   0F57 E4            pop a
2111   0F58 32            mov bl, [d]
2112   0F59 A7 00         mov bh, 0
2113   0F5B DD            push bl
2114   0F5C 07 37 10      call putchar
2115   0F5F 51 01 00      add sp, 1
2116   0F62 0A 2C 0F      jmp _while31_cond
2117   0F65             _while31_exit:
2118   0F65 F9            leave
2119   0F66 09            ret
2120   0F67             
2121   0F67             print_unsigned:
2122   0F67 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2123   0F6A             ; $digits 
2124   0F6A             ; $i 
2125   0F6A 52 07 00      sub sp, 7
2126   0F6D             ;; i = 0; 
2127   0F6D FA FA FF      lea d, [bp + -6] ; $i
2128   0F70 DA            push d
2129   0F71 26 00 00      mov b, $0
2130   0F74 E7            pop d
2131   0F75 FD 43         mov [d], b
2132   0F77             ;; if(num == 0){ 
2133   0F77             _if32_cond:
2134   0F77 FA 05 00      lea d, [bp + 5] ; $num
2135   0F7A 2A            mov b, [d]
2136   0F7B             ; START RELATIONAL
2137   0F7B D7            push a
2138   0F7C 11            mov a, b
2139   0F7D 26 00 00      mov b, $0
2140   0F80 B0            cmp a, b
2141   0F81 FD 71         seq ; ==
2142   0F83 E4            pop a
2143   0F84             ; END RELATIONAL
2144   0F84 C0 00 00      cmp b, 0
2145   0F87 C6 99 0F      je _if32_exit
2146   0F8A             _if32_true:
2147   0F8A             ;; putchar('0'); 
2148   0F8A 26 30 00      mov b, $30
2149   0F8D DD            push bl
2150   0F8E 07 37 10      call putchar
2151   0F91 51 01 00      add sp, 1
2152   0F94             ;; return; 
2153   0F94 F9            leave
2154   0F95 09            ret
2155   0F96 0A 99 0F      jmp _if32_exit
2156   0F99             _if32_exit:
2157   0F99             ;; while (num > 0) { 
2158   0F99             _while33_cond:
2159   0F99 FA 05 00      lea d, [bp + 5] ; $num
2160   0F9C 2A            mov b, [d]
2161   0F9D             ; START RELATIONAL
2162   0F9D D7            push a
2163   0F9E 11            mov a, b
2164   0F9F 26 00 00      mov b, $0
2165   0FA2 B0            cmp a, b
2166   0FA3 FD 81         sgu ; > (unsigned)
2167   0FA5 E4            pop a
2168   0FA6             ; END RELATIONAL
2169   0FA6 C0 00 00      cmp b, 0
2170   0FA9 C6 F3 0F      je _while33_exit
2171   0FAC             _while33_block:
2172   0FAC             ;; digits[i] = '0' + (num % 10); 
2173   0FAC FA FC FF      lea d, [bp + -4] ; $digits
2174   0FAF D7            push a
2175   0FB0 DA            push d
2176   0FB1 FA FA FF      lea d, [bp + -6] ; $i
2177   0FB4 2A            mov b, [d]
2178   0FB5 E7            pop d
2179   0FB6 5A            add d, b
2180   0FB7 E4            pop a
2181   0FB8 DA            push d
2182   0FB9 26 30 00      mov b, $30
2183   0FBC             ; START TERMS
2184   0FBC D7            push a
2185   0FBD 11            mov a, b
2186   0FBE FA 05 00      lea d, [bp + 5] ; $num
2187   0FC1 2A            mov b, [d]
2188   0FC2             ; START FACTORS
2189   0FC2 D7            push a
2190   0FC3 11            mov a, b
2191   0FC4 26 0A 00      mov b, $a
2192   0FC7 AE            div a, b ; 
2193   0FC8 11            mov a, b
2194   0FC9 27            mov b, a
2195   0FCA E4            pop a
2196   0FCB             ; END FACTORS
2197   0FCB 56            add b, a
2198   0FCC E4            pop a
2199   0FCD             ; END TERMS
2200   0FCD E7            pop d
2201   0FCE FD 3E         mov [d], bl
2202   0FD0             ;; num = num / 10; 
2203   0FD0 FA 05 00      lea d, [bp + 5] ; $num
2204   0FD3 DA            push d
2205   0FD4 FA 05 00      lea d, [bp + 5] ; $num
2206   0FD7 2A            mov b, [d]
2207   0FD8             ; START FACTORS
2208   0FD8 D7            push a
2209   0FD9 11            mov a, b
2210   0FDA 26 0A 00      mov b, $a
2211   0FDD AE            div a, b
2212   0FDE 27            mov b, a
2213   0FDF E4            pop a
2214   0FE0             ; END FACTORS
2215   0FE0 E7            pop d
2216   0FE1 FD 43         mov [d], b
2217   0FE3             ;; i++; 
2218   0FE3 FA FA FF      lea d, [bp + -6] ; $i
2219   0FE6 2A            mov b, [d]
2220   0FE7 D8            push b
2221   0FE8 FD 77         inc b
2222   0FEA FA FA FF      lea d, [bp + -6] ; $i
2223   0FED FD 43         mov [d], b
2224   0FEF E5            pop b
2225   0FF0 0A 99 0F      jmp _while33_cond
2226   0FF3             _while33_exit:
2227   0FF3             ;; while (i > 0) { 
2228   0FF3             _while34_cond:
2229   0FF3 FA FA FF      lea d, [bp + -6] ; $i
2230   0FF6 2A            mov b, [d]
2231   0FF7             ; START RELATIONAL
2232   0FF7 D7            push a
2233   0FF8 11            mov a, b
2234   0FF9 26 00 00      mov b, $0
2235   0FFC B0            cmp a, b
2236   0FFD FD 7F         sgt ; >
2237   0FFF E4            pop a
2238   1000             ; END RELATIONAL
2239   1000 C0 00 00      cmp b, 0
2240   1003 C6 2C 10      je _while34_exit
2241   1006             _while34_block:
2242   1006             ;; i--; 
2243   1006 FA FA FF      lea d, [bp + -6] ; $i
2244   1009 2A            mov b, [d]
2245   100A D8            push b
2246   100B FD 7D         dec b
2247   100D FA FA FF      lea d, [bp + -6] ; $i
2248   1010 FD 43         mov [d], b
2249   1012 E5            pop b
2250   1013             ;; putchar(digits[i]); 
2251   1013 FA FC FF      lea d, [bp + -4] ; $digits
2252   1016 D7            push a
2253   1017 DA            push d
2254   1018 FA FA FF      lea d, [bp + -6] ; $i
2255   101B 2A            mov b, [d]
2256   101C E7            pop d
2257   101D 5A            add d, b
2258   101E E4            pop a
2259   101F 32            mov bl, [d]
2260   1020 A7 00         mov bh, 0
2261   1022 DD            push bl
2262   1023 07 37 10      call putchar
2263   1026 51 01 00      add sp, 1
2264   1029 0A F3 0F      jmp _while34_cond
2265   102C             _while34_exit:
2266   102C F9            leave
2267   102D 09            ret
2268   102E             
2269   102E             date:
2270   102E F8 00 00      enter 0 ; (push bp; mov bp, sp)
2271   1031             
2272   1031             ; --- BEGIN INLINE ASM BLOCK
2273   1031 19 00         mov al, 0 
2274   1033 05 07         syscall sys_datetime
2275   1035             ; --- END INLINE ASM BLOCK
2276   1035             
2277   1035 F9            leave
2278   1036 09            ret
2279   1037             
2280   1037             putchar:
2281   1037 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2282   103A             
2283   103A             ; --- BEGIN INLINE ASM BLOCK
2284   103A FA 05 00      lea d, [bp + 5] ; $c
2285   103D 1E            mov al, [d]
2286   103E 23            mov ah, al
2287   103F 07 18 12      call _putchar
2288   1042             ; --- END INLINE ASM BLOCK
2289   1042             
2290   1042 F9            leave
2291   1043 09            ret
2292   1044             
2293   1044             getchar:
2294   1044 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2295   1047             ; $c 
2296   1047 52 01 00      sub sp, 1
2297   104A             
2298   104A             ; --- BEGIN INLINE ASM BLOCK
2299   104A 07 11 12      call getch
2300   104D 1A            mov al, ah
2301   104E FA 00 00      lea d, [bp + 0] ; $c
2302   1051 3E            mov [d], al
2303   1052             ; --- END INLINE ASM BLOCK
2304   1052             
2305   1052             ;; return c; 
2306   1052 FA 00 00      lea d, [bp + 0] ; $c
2307   1055 32            mov bl, [d]
2308   1056 A7 00         mov bh, 0
2309   1058 F9            leave
2310   1059 09            ret
2311   105A             
2312   105A             scann:
2313   105A F8 00 00      enter 0 ; (push bp; mov bp, sp)
2314   105D             ; $m 
2315   105D 52 02 00      sub sp, 2
2316   1060             
2317   1060             ; --- BEGIN INLINE ASM BLOCK
2318   1060 07 5C 14      call scan_u16d
2319   1063 FA FF FF      lea d, [bp + -1] ; $m
2320   1066 43            mov [d], a
2321   1067             ; --- END INLINE ASM BLOCK
2322   1067             
2323   1067             ;; return m; 
2324   1067 FA FF FF      lea d, [bp + -1] ; $m
2325   106A 2A            mov b, [d]
2326   106B F9            leave
2327   106C 09            ret
2328   106D             
2329   106D             puts:
2330   106D F8 00 00      enter 0 ; (push bp; mov bp, sp)
2331   1070             
2332   1070             ; --- BEGIN INLINE ASM BLOCK
2333   1070 FA 05 00      lea d, [bp + 5] ; $s
2334   1073 15            mov a, [d]
2335   1074 3C            mov d, a
2336   1075 07 62 13      call _puts
2337   1078 10 00 0A      mov a, $0A00
2338   107B 05 03         syscall sys_io
2339   107D             ; --- END INLINE ASM BLOCK
2340   107D             
2341   107D F9            leave
2342   107E 09            ret
2343   107F             
2344   107F             print:
2345   107F F8 00 00      enter 0 ; (push bp; mov bp, sp)
2346   1082             
2347   1082             ; --- BEGIN INLINE ASM BLOCK
2348   1082 FA 05 00      lea d, [bp + 5] ; $s
2349   1085 FD 2A         mov d, [d]
2350   1087 07 62 13      call _puts
2351   108A             ; --- END INLINE ASM BLOCK
2352   108A             
2353   108A F9            leave
2354   108B 09            ret
2355   108C             
2356   108C             loadfile:
2357   108C F8 00 00      enter 0 ; (push bp; mov bp, sp)
2358   108F             
2359   108F             ; --- BEGIN INLINE ASM BLOCK
2360   108F FA 07 00      lea d, [bp + 7] ; $destination
2361   1092 15            mov a, [d]
2362   1093 4F            mov di, a
2363   1094 FA 05 00      lea d, [bp + 5] ; $filename
2364   1097 FD 2A         mov d, [d]
2365   1099 19 14         mov al, 20
2366   109B 05 04         syscall sys_filesystem
2367   109D             ; --- END INLINE ASM BLOCK
2368   109D             
2369   109D F9            leave
2370   109E 09            ret
2371   109F             
2372   109F             create_file:
2373   109F F8 00 00      enter 0 ; (push bp; mov bp, sp)
2374   10A2 F9            leave
2375   10A3 09            ret
2376   10A4             
2377   10A4             delete_file:
2378   10A4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2379   10A7             
2380   10A7             ; --- BEGIN INLINE ASM BLOCK
2381   10A7 FA 05 00      lea d, [bp + 5] ; $filename
2382   10AA 19 0A         mov al, 10
2383   10AC 05 04         syscall sys_filesystem
2384   10AE             ; --- END INLINE ASM BLOCK
2385   10AE             
2386   10AE F9            leave
2387   10AF 09            ret
2388   10B0             
2389   10B0             fopen:
2390   10B0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2391   10B3 F9            leave
2392   10B4 09            ret
2393   10B5             
2394   10B5             fclose:
2395   10B5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2396   10B8 F9            leave
2397   10B9 09            ret
2398   10BA             
2399   10BA             load_hex:
2400   10BA F8 00 00      enter 0 ; (push bp; mov bp, sp)
2401   10BD             ; $temp 
2402   10BD 52 02 00      sub sp, 2
2403   10C0             ;; temp = alloc(32768); 
2404   10C0 FA FF FF      lea d, [bp + -1] ; $temp
2405   10C3 DA            push d
2406   10C4 26 00 80      mov b, $8000
2407   10C7 FD AB         swp b
2408   10C9 D8            push b
2409   10CA 07 A1 07      call alloc
2410   10CD 51 02 00      add sp, 2
2411   10D0 E7            pop d
2412   10D1 FD 43         mov [d], b
2413   10D3             
2414   10D3             ; --- BEGIN INLINE ASM BLOCK
2415   10D3               
2416   10D3               
2417   10D3               
2418   10D3               
2419   10D3               
2420   10D3             _load_hex:
2421   10D3 D7            push a
2422   10D4 D8            push b
2423   10D5 DA            push d
2424   10D6 E2            push si
2425   10D7 E3            push di
2426   10D8 52 00 80      sub sp, $8000      
2427   10DB 38 00 00      mov c, 0
2428   10DE 48            mov a, sp
2429   10DF 77            inc a
2430   10E0 3C            mov d, a          
2431   10E1 07 1F 12      call _gets        
2432   10E4 4D            mov si, a
2433   10E5             __load_hex_loop:
2434   10E5 F6            lodsb             
2435   10E6 B9 00         cmp al, 0         
2436   10E8 C6 F6 10      jz __load_hex_ret
2437   10EB 36            mov bh, al
2438   10EC F6            lodsb
2439   10ED 2F            mov bl, al
2440   10EE 07 D5 11      call _atoi        
2441   10F1 F7            stosb             
2442   10F2 78            inc c
2443   10F3 0A E5 10      jmp __load_hex_loop
2444   10F6             __load_hex_ret:
2445   10F6 51 00 80      add sp, $8000
2446   10F9 F0            pop di
2447   10FA EF            pop si
2448   10FB E7            pop d
2449   10FC E5            pop b
2450   10FD E4            pop a
2451   10FE             ; --- END INLINE ASM BLOCK
2452   10FE             
2453   10FE F9            leave
2454   10FF 09            ret
2455   1100             
2456   1100             getparam:
2457   1100 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2458   1103             ; $data 
2459   1103 52 01 00      sub sp, 1
2460   1106             
2461   1106             ; --- BEGIN INLINE ASM BLOCK
2462   1106 19 04         mov al, 4
2463   1108 FA 05 00      lea d, [bp + 5] ; $address
2464   110B FD 2A         mov d, [d]
2465   110D 05 0C         syscall sys_system
2466   110F FA 00 00      lea d, [bp + 0] ; $data
2467   1112 FD 3E         mov [d], bl
2468   1114             ; --- END INLINE ASM BLOCK
2469   1114             
2470   1114             ;; return data; 
2471   1114 FA 00 00      lea d, [bp + 0] ; $data
2472   1117 32            mov bl, [d]
2473   1118 A7 00         mov bh, 0
2474   111A F9            leave
2475   111B 09            ret
2476   111C             
2477   111C             clear:
2478   111C F8 00 00      enter 0 ; (push bp; mov bp, sp)
2479   111F             ;; print("\033[2J\033[H"); 
2480   111F 26 18 15      mov b, __s3 ; "\033[2J\033[H"
2481   1122 FD AB         swp b
2482   1124 D8            push b
2483   1125 07 7F 10      call print
2484   1128 51 02 00      add sp, 2
2485   112B F9            leave
2486   112C 09            ret
2487   112D             
2488   112D             include_stdio_asm:
2489   112D F8 00 00      enter 0 ; (push bp; mov bp, sp)
2490   1130             
2491   1130             ; --- BEGIN INLINE ASM BLOCK
2492   1130             .include "lib/asm/stdio.asm"
0001+  1130             ;-----------------------------------------------------------------------------
0002+  1130             ; stdio.s
0003+  1130             ;-----------------------------------------------------------------------------
0004+  1130             .include "lib/asm/string.asm"
0001++ 1130             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 1130             ; string.s
0003++ 1130             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 1130             
0005++ 1130             
0006++ 1130             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 1130             ; _strrev
0008++ 1130             ; reverse a string
0009++ 1130             ; D = string address
0010++ 1130             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 1130             ; 01234
0012++ 1130             _strrev:
0013++ 1130 4B          	pusha
0014++ 1131 07 77 11    	call _strlen	; length in C
0015++ 1134 12          	mov a, c
0016++ 1135 AF 01 00    	cmp a, 1
0017++ 1138 D0 52 11    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 113B 7D          	dec a
0019++ 113C FD 4E       	mov si, d	; beginning of string
0020++ 113E FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 1140 59          	add d, a	; end of string
0022++ 1141 12          	mov a, c
0023++ 1142 FD 9B       	shr a		; divide by 2
0024++ 1144 39          	mov c, a	; C now counts the steps
0025++ 1145             _strrev_L0:
0026++ 1145 32          	mov bl, [d]	; save load right-side char into BL
0027++ 1146 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 1147 3E          	mov [d], al	; store left char into right side
0029++ 1148 1B          	mov al, bl
0030++ 1149 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 114A 7E          	dec c
0032++ 114B 7F          	dec d
0033++ 114C C2 00 00    	cmp c, 0
0034++ 114F C7 45 11    	jne _strrev_L0
0035++ 1152             _strrev_end:
0036++ 1152 4C          	popa
0037++ 1153 09          	ret
0038++ 1154             	
0039++ 1154             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 1154             ; _strchr
0041++ 1154             ; search string in D for char in AL
0042++ 1154             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 1154             _strchr:
0044++ 1154             _strchr_L0:
0045++ 1154 32          	mov bl, [d]
0046++ 1155 C1 00       	cmp bl, 0
0047++ 1157 C6 62 11    	je _strchr_end
0048++ 115A BA          	cmp al, bl
0049++ 115B C6 62 11    	je _strchr_end
0050++ 115E 79          	inc d
0051++ 115F 0A 54 11    	jmp _strchr_L0
0052++ 1162             _strchr_end:
0053++ 1162 1B          	mov al, bl
0054++ 1163 09          	ret
0055++ 1164             
0056++ 1164             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 1164             ; _strstr
0058++ 1164             ; find sub-string
0059++ 1164             ; str1 in SI
0060++ 1164             ; str2 in DI
0061++ 1164             ; SI points to end of source string
0062++ 1164             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 1164             _strstr:
0064++ 1164 DB          	push al
0065++ 1165 DA          	push d
0066++ 1166 E3          	push di
0067++ 1167             _strstr_loop:
0068++ 1167 F3          	cmpsb					; compare a byte of the strings
0069++ 1168 C7 73 11    	jne _strstr_ret
0070++ 116B FC 00 00    	lea d, [di + 0]
0071++ 116E BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1170 C7 67 11    	jne _strstr_loop				; equal chars but not at end
0073++ 1173             _strstr_ret:
0074++ 1173 F0          	pop di
0075++ 1174 E7          	pop d
0076++ 1175 E8          	pop al
0077++ 1176 09          	ret
0078++ 1177             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1177             ; length of null terminated string
0080++ 1177             ; result in C
0081++ 1177             ; pointer in D
0082++ 1177             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1177             _strlen:
0084++ 1177 DA          	push d
0085++ 1178 38 00 00    	mov c, 0
0086++ 117B             _strlen_L1:
0087++ 117B BD 00       	cmp byte [d], 0
0088++ 117D C6 85 11    	je _strlen_ret
0089++ 1180 79          	inc d
0090++ 1181 78          	inc c
0091++ 1182 0A 7B 11    	jmp _strlen_L1
0092++ 1185             _strlen_ret:
0093++ 1185 E7          	pop d
0094++ 1186 09          	ret
0095++ 1187             
0096++ 1187             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1187             ; STRCMP
0098++ 1187             ; compare two strings
0099++ 1187             ; str1 in SI
0100++ 1187             ; str2 in DI
0101++ 1187             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 1187             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1187             _strcmp:
0104++ 1187 DB          	push al
0105++ 1188 DA          	push d
0106++ 1189 E3          	push di
0107++ 118A E2          	push si
0108++ 118B             _strcmp_loop:
0109++ 118B F3          	cmpsb					; compare a byte of the strings
0110++ 118C C7 97 11    	jne _strcmp_ret
0111++ 118F FB FF FF    	lea d, [si +- 1]
0112++ 1192 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1194 C7 8B 11    	jne _strcmp_loop				; equal chars but not at end
0114++ 1197             _strcmp_ret:
0115++ 1197 EF          	pop si
0116++ 1198 F0          	pop di
0117++ 1199 E7          	pop d
0118++ 119A E8          	pop al
0119++ 119B 09          	ret
0120++ 119C             
0121++ 119C             
0122++ 119C             ; STRCPY
0123++ 119C             ; copy null terminated string from SI to DI
0124++ 119C             ; source in SI
0125++ 119C             ; destination in DI
0126++ 119C             _strcpy:
0127++ 119C E2          	push si
0128++ 119D E3          	push di
0129++ 119E DB          	push al
0130++ 119F             _strcpy_L1:
0131++ 119F F6          	lodsb
0132++ 11A0 F7          	stosb
0133++ 11A1 B9 00       	cmp al, 0
0134++ 11A3 C7 9F 11    	jne _strcpy_L1
0135++ 11A6             _strcpy_end:
0136++ 11A6 E8          	pop al
0137++ 11A7 F0          	pop di
0138++ 11A8 EF          	pop si
0139++ 11A9 09          	ret
0140++ 11AA             
0141++ 11AA             ; STRCAT
0142++ 11AA             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 11AA             ; source in SI
0144++ 11AA             ; destination in DI
0145++ 11AA             _strcat:
0146++ 11AA E2          	push si
0147++ 11AB E3          	push di
0148++ 11AC D7          	push a
0149++ 11AD DA          	push d
0150++ 11AE 50          	mov a, di
0151++ 11AF 3C          	mov d, a
0152++ 11B0             _strcat_goto_end_L1:
0153++ 11B0 BD 00       	cmp byte[d], 0
0154++ 11B2 C6 B9 11    	je _strcat_start
0155++ 11B5 79          	inc d
0156++ 11B6 0A B0 11    	jmp _strcat_goto_end_L1
0157++ 11B9             _strcat_start:
0158++ 11B9 FD 50       	mov di, d
0159++ 11BB             _strcat_L1:
0160++ 11BB F6          	lodsb
0161++ 11BC F7          	stosb
0162++ 11BD B9 00       	cmp al, 0
0163++ 11BF C7 BB 11    	jne _strcat_L1
0164++ 11C2             _strcat_end:
0165++ 11C2 E7          	pop d
0166++ 11C3 E4          	pop a
0167++ 11C4 F0          	pop di
0168++ 11C5 EF          	pop si
0169++ 11C6 09          	ret
0170++ 11C7             
0171++ 11C7             
0005+  11C7             
0006+  11C7             ;-----------------------------------------------------------------------------
0007+  11C7             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0008+  11C7             ; ASCII in BL
0009+  11C7             ; result in AL
0010+  11C7             ; ascii for F = 0100 0110
0011+  11C7             ; ascii for 9 = 0011 1001
0012+  11C7             ;-----------------------------------------------------------------------------
0013+  11C7             hex_ascii_encode:
0014+  11C7 1B            mov al, bl
0015+  11C8 93 40         test al, $40        ; test if letter or number
0016+  11CA C7 D0 11      jnz hex_letter
0017+  11CD 87 0F         and al, $0F        ; get number
0018+  11CF 09            ret
0019+  11D0             hex_letter:
0020+  11D0 87 0F         and al, $0F        ; get letter
0021+  11D2 6A 09         add al, 9
0022+  11D4 09            ret
0023+  11D5             
0024+  11D5             ;-----------------------------------------------------------------------------
0025+  11D5             ; ATOI
0026+  11D5             ; 2 letter hex string in B
0027+  11D5             ; 8bit integer returned in AL
0028+  11D5             ;-----------------------------------------------------------------------------
0029+  11D5             _atoi:
0030+  11D5 D8            push b
0031+  11D6 07 C7 11      call hex_ascii_encode      ; convert BL to 4bit code in AL
0032+  11D9 30            mov bl, bh
0033+  11DA DB            push al          ; save a
0034+  11DB 07 C7 11      call hex_ascii_encode
0035+  11DE EA            pop bl  
0036+  11DF FD 9E 04      shl al, 4
0037+  11E2 8C            or al, bl
0038+  11E3 E5            pop b
0039+  11E4 09            ret  
0040+  11E5             
0041+  11E5             ;-----------------------------------------------------------------------------
0042+  11E5             ; scanf
0043+  11E5             ; no need for explanations!
0044+  11E5             ;-----------------------------------------------------------------------------
0045+  11E5             scanf:
0046+  11E5 09            ret
0047+  11E6             
0048+  11E6             ;-----------------------------------------------------------------------------
0049+  11E6             ; ITOA
0050+  11E6             ; 8bit value in BL
0051+  11E6             ; 2 byte ASCII result in A
0052+  11E6             ;-----------------------------------------------------------------------------
0053+  11E6             _itoa:
0054+  11E6 DA            push d
0055+  11E7 D8            push b
0056+  11E8 A7 00         mov bh, 0
0057+  11EA FD A4 04      shr bl, 4  
0058+  11ED 74            mov d, b
0059+  11EE 1F 96 14      mov al, [d + s_hex_digits]
0060+  11F1 23            mov ah, al
0061+  11F2               
0062+  11F2 E5            pop b
0063+  11F3 D8            push b
0064+  11F4 A7 00         mov bh, 0
0065+  11F6 FD 87 0F      and bl, $0F
0066+  11F9 74            mov d, b
0067+  11FA 1F 96 14      mov al, [d + s_hex_digits]
0068+  11FD E5            pop b
0069+  11FE E7            pop d
0070+  11FF 09            ret
0071+  1200             
0072+  1200             ;-----------------------------------------------------------------------------
0073+  1200             ; HEX STRING TO BINARY
0074+  1200             ; di = destination address
0075+  1200             ; si = source
0076+  1200             ;-----------------------------------------------------------------------------
0077+  1200             _hex_to_int:
0078+  1200             _hex_to_int_L1:
0079+  1200 F6            lodsb          ; load from [SI] to AL
0080+  1201 B9 00         cmp al, 0        ; check if ASCII 0
0081+  1203 C6 10 12      jz _hex_to_int_ret
0082+  1206 36            mov bh, al
0083+  1207 F6            lodsb
0084+  1208 2F            mov bl, al
0085+  1209 07 D5 11      call _atoi        ; convert ASCII byte in B to int (to AL)
0086+  120C F7            stosb          ; store AL to [DI]
0087+  120D 0A 00 12      jmp _hex_to_int_L1
0088+  1210             _hex_to_int_ret:
0089+  1210 09            ret    
0090+  1211             
0091+  1211             ;-----------------------------------------------------------------------------
0092+  1211             ; GETCHAR
0093+  1211             ; char in ah
0094+  1211             ;-----------------------------------------------------------------------------
0095+  1211             getch:
0096+  1211 DB            push al
0097+  1212             getch_retry:
0098+  1212 19 01         mov al, 1
0099+  1214 05 03         syscall sys_io      ; receive in AH
0100+  1216 E8            pop al
0101+  1217 09            ret
0102+  1218             
0103+  1218             ;-----------------------------------------------------------------------------
0104+  1218             ; PUTCHAR
0105+  1218             ; char in ah
0106+  1218             ;-----------------------------------------------------------------------------
0107+  1218             _putchar:
0108+  1218 D7            push a
0109+  1219 19 00         mov al, 0
0110+  121B 05 03         syscall sys_io      ; char in AH
0111+  121D E4            pop a
0112+  121E 09            ret
0113+  121F             
0114+  121F             ;-----------------------------------------------------------------------------
0115+  121F             ;; INPUT A STRING
0116+  121F             ;; terminates with null
0117+  121F             ;; pointer in D
0118+  121F             ;-----------------------------------------------------------------------------
0119+  121F             _gets:
0120+  121F D7            push a
0121+  1220 DA            push d
0122+  1221             _gets_loop:
0123+  1221 19 01         mov al, 1
0124+  1223 05 03         syscall sys_io      ; receive in AH
0125+  1225 B9 00         cmp al, 0        ; check error code (AL)
0126+  1227 C6 21 12      je _gets_loop      ; if no char received, retry
0127+  122A             
0128+  122A 76 1B         cmp ah, 27
0129+  122C C6 4D 12      je _gets_ansi_esc
0130+  122F 76 0A         cmp ah, $0A        ; LF
0131+  1231 C6 B8 12      je _gets_end
0132+  1234 76 0D         cmp ah, $0D        ; CR
0133+  1236 C6 B8 12      je _gets_end
0134+  1239 76 5C         cmp ah, $5C        ; '\\'
0135+  123B C6 79 12      je _gets_escape
0136+  123E               
0137+  123E 76 08         cmp ah, $08      ; check for backspace
0138+  1240 C6 49 12      je _gets_backspace
0139+  1243             
0140+  1243 1A            mov al, ah
0141+  1244 3E            mov [d], al
0142+  1245 79            inc d
0143+  1246 0A 21 12      jmp _gets_loop
0144+  1249             _gets_backspace:
0145+  1249 7F            dec d
0146+  124A 0A 21 12      jmp _gets_loop
0147+  124D             _gets_ansi_esc:
0148+  124D 19 01         mov al, 1
0149+  124F 05 03         syscall sys_io        ; receive in AH without echo
0150+  1251 B9 00         cmp al, 0          ; check error code (AL)
0151+  1253 C6 4D 12      je _gets_ansi_esc    ; if no char received, retry
0152+  1256 76 5B         cmp ah, '['
0153+  1258 C7 21 12      jne _gets_loop
0154+  125B             _gets_ansi_esc_2:
0155+  125B 19 01         mov al, 1
0156+  125D 05 03         syscall sys_io          ; receive in AH without echo
0157+  125F B9 00         cmp al, 0            ; check error code (AL)
0158+  1261 C6 5B 12      je _gets_ansi_esc_2  ; if no char received, retry
0159+  1264 76 44         cmp ah, 'D'
0160+  1266 C6 71 12      je _gets_left_arrow
0161+  1269 76 43         cmp ah, 'C'
0162+  126B C6 75 12      je _gets_right_arrow
0163+  126E 0A 21 12      jmp _gets_loop
0164+  1271             _gets_left_arrow:
0165+  1271 7F            dec d
0166+  1272 0A 21 12      jmp _gets_loop
0167+  1275             _gets_right_arrow:
0168+  1275 79            inc d
0169+  1276 0A 21 12      jmp _gets_loop
0170+  1279             _gets_escape:
0171+  1279 19 01         mov al, 1
0172+  127B 05 03         syscall sys_io      ; receive in AH
0173+  127D B9 00         cmp al, 0        ; check error code (AL)
0174+  127F C6 79 12      je _gets_escape      ; if no char received, retry
0175+  1282 76 6E         cmp ah, 'n'
0176+  1284 C6 A3 12      je _gets_LF
0177+  1287 76 72         cmp ah, 'r'
0178+  1289 C6 AA 12      je _gets_CR
0179+  128C 76 30         cmp ah, '0'
0180+  128E C6 B1 12      je _gets_NULL
0181+  1291 76 5C         cmp ah, $5C  ; '\'
0182+  1293 C6 9C 12      je _gets_slash
0183+  1296 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0184+  1297 3E            mov [d], al
0185+  1298 79            inc d
0186+  1299 0A 21 12      jmp _gets_loop
0187+  129C             _gets_slash:
0188+  129C 19 5C         mov al, $5C
0189+  129E 3E            mov [d], al
0190+  129F 79            inc d
0191+  12A0 0A 21 12      jmp _gets_loop
0192+  12A3             _gets_LF:
0193+  12A3 19 0A         mov al, $0A
0194+  12A5 3E            mov [d], al
0195+  12A6 79            inc d
0196+  12A7 0A 21 12      jmp _gets_loop
0197+  12AA             _gets_CR:
0198+  12AA 19 0D         mov al, $0D
0199+  12AC 3E            mov [d], al
0200+  12AD 79            inc d
0201+  12AE 0A 21 12      jmp _gets_loop
0202+  12B1             _gets_NULL:
0203+  12B1 19 00         mov al, $00
0204+  12B3 3E            mov [d], al
0205+  12B4 79            inc d
0206+  12B5 0A 21 12      jmp _gets_loop
0207+  12B8             _gets_end:
0208+  12B8 19 00         mov al, 0
0209+  12BA 3E            mov [d], al        ; terminate string
0210+  12BB E7            pop d
0211+  12BC E4            pop a
0212+  12BD 09            ret
0213+  12BE             
0214+  12BE             ;-----------------------------------------------------------------------------
0215+  12BE             ;; INPUT TEXT
0216+  12BE             ;; terminated with CTRL+D
0217+  12BE             ;; pointer in D
0218+  12BE             ;-----------------------------------------------------------------------------
0219+  12BE             _gettxt:
0220+  12BE D7            push a
0221+  12BF DA            push d
0222+  12C0             _gettxt_loop:
0223+  12C0 19 01         mov al, 1
0224+  12C2 05 03         syscall sys_io      ; receive in AH
0225+  12C4 B9 00         cmp al, 0        ; check error code (AL)
0226+  12C6 C6 C0 12      je _gettxt_loop    ; if no char received, retry
0227+  12C9 76 04         cmp ah, 4      ; EOT
0228+  12CB C6 09 13      je _gettxt_end
0229+  12CE 76 08         cmp ah, $08      ; check for backspace
0230+  12D0 C6 05 13      je _gettxt_backspace
0231+  12D3 76 5C         cmp ah, $5C        ; '\'
0232+  12D5 C6 DE 12      je _gettxt_escape
0233+  12D8 1A            mov al, ah
0234+  12D9 3E            mov [d], al
0235+  12DA 79            inc d
0236+  12DB 0A C0 12      jmp _gettxt_loop
0237+  12DE             _gettxt_escape:
0238+  12DE 19 01         mov al, 1
0239+  12E0 05 03         syscall sys_io      ; receive in AH
0240+  12E2 B9 00         cmp al, 0        ; check error code (AL)
0241+  12E4 C6 DE 12      je _gettxt_escape    ; if no char received, retry
0242+  12E7 76 6E         cmp ah, 'n'
0243+  12E9 C6 F7 12      je _gettxt_LF
0244+  12EC 76 72         cmp ah, 'r'
0245+  12EE C6 FE 12      je _gettxt_CR
0246+  12F1 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0247+  12F2 3E            mov [d], al
0248+  12F3 79            inc d
0249+  12F4 0A C0 12      jmp _gettxt_loop
0250+  12F7             _gettxt_LF:
0251+  12F7 19 0A         mov al, $0A
0252+  12F9 3E            mov [d], al
0253+  12FA 79            inc d
0254+  12FB 0A C0 12      jmp _gettxt_loop
0255+  12FE             _gettxt_CR:
0256+  12FE 19 0D         mov al, $0D
0257+  1300 3E            mov [d], al
0258+  1301 79            inc d
0259+  1302 0A C0 12      jmp _gettxt_loop
0260+  1305             _gettxt_backspace:
0261+  1305 7F            dec d
0262+  1306 0A C0 12      jmp _gettxt_loop
0263+  1309             _gettxt_end:
0264+  1309 19 00         mov al, 0
0265+  130B 3E            mov [d], al        ; terminate string
0266+  130C E7            pop d
0267+  130D E4            pop a
0268+  130E 09            ret
0269+  130F             
0270+  130F             ;-----------------------------------------------------------------------------
0271+  130F             ; PRINT NEW LINE
0272+  130F             ;-----------------------------------------------------------------------------
0273+  130F             printnl:
0274+  130F D7            push a
0275+  1310 10 00 0A      mov a, $0A00
0276+  1313 05 03         syscall sys_io
0277+  1315 10 00 0D      mov a, $0D00
0278+  1318 05 03         syscall sys_io
0279+  131A E4            pop a
0280+  131B 09            ret
0281+  131C             
0282+  131C             ;-----------------------------------------------------------------------------
0283+  131C             ; _strtoint
0284+  131C             ; 4 digit hex string number in d
0285+  131C             ; integer returned in A
0286+  131C             ;-----------------------------------------------------------------------------
0287+  131C             _strtointx:
0288+  131C D8            push b
0289+  131D 32            mov bl, [d]
0290+  131E 37            mov bh, bl
0291+  131F 33 01 00      mov bl, [d + 1]
0292+  1322 07 D5 11      call _atoi        ; convert to int in AL
0293+  1325 23            mov ah, al        ; move to AH
0294+  1326 33 02 00      mov bl, [d + 2]
0295+  1329 37            mov bh, bl
0296+  132A 33 03 00      mov bl, [d + 3]
0297+  132D 07 D5 11      call _atoi        ; convert to int in AL
0298+  1330 E5            pop b
0299+  1331 09            ret
0300+  1332             
0301+  1332             ;-----------------------------------------------------------------------------
0302+  1332             ; _strtoint
0303+  1332             ; 5 digit base10 string number in d
0304+  1332             ; integer returned in A
0305+  1332             ;-----------------------------------------------------------------------------
0306+  1332             _strtoint:
0307+  1332 E2            push si
0308+  1333 D8            push b
0309+  1334 D9            push c
0310+  1335 DA            push d
0311+  1336 07 77 11      call _strlen      ; get string length in C
0312+  1339 7E            dec c
0313+  133A FD 4E         mov si, d
0314+  133C 12            mov a, c
0315+  133D FD 99         shl a
0316+  133F 3B AE 14      mov d, table_power
0317+  1342 59            add d, a
0318+  1343 38 00 00      mov c, 0
0319+  1346             _strtoint_L0:
0320+  1346 F6            lodsb      ; load ASCII to al
0321+  1347 B9 00         cmp al, 0
0322+  1349 C6 5C 13      je _strtoint_end
0323+  134C 6F 30         sub al, $30    ; make into integer
0324+  134E 22 00         mov ah, 0
0325+  1350 2A            mov b, [d]
0326+  1351 AC            mul a, b      ; result in B since it fits in 16bits
0327+  1352 11            mov a, b
0328+  1353 28            mov b, c
0329+  1354 54            add a, b
0330+  1355 39            mov c, a
0331+  1356 63 02 00      sub d, 2
0332+  1359 0A 46 13      jmp _strtoint_L0
0333+  135C             _strtoint_end:
0334+  135C 12            mov a, c
0335+  135D E7            pop d
0336+  135E E6            pop c
0337+  135F E5            pop b
0338+  1360 EF            pop si
0339+  1361 09            ret
0340+  1362             
0341+  1362             ;-----------------------------------------------------------------------------
0342+  1362             ; PRINT NULL TERMINATED STRING
0343+  1362             ; pointer in D
0344+  1362             ;-----------------------------------------------------------------------------
0345+  1362             _puts:
0346+  1362 D7            push a
0347+  1363 DA            push d
0348+  1364             _puts_L1:
0349+  1364 1E            mov al, [d]
0350+  1365 B9 00         cmp al, 0
0351+  1367 C6 73 13      jz _puts_END
0352+  136A 23            mov ah, al
0353+  136B 19 00         mov al, 0
0354+  136D 05 03         syscall sys_io
0355+  136F 79            inc d
0356+  1370 0A 64 13      jmp _puts_L1
0357+  1373             _puts_END:
0358+  1373 E7            pop d
0359+  1374 E4            pop a
0360+  1375 09            ret
0361+  1376             
0362+  1376             ;-----------------------------------------------------------------------------
0363+  1376             ; PRINT N SIZE STRING
0364+  1376             ; pointer in D
0365+  1376             ; size in C
0366+  1376             ;-----------------------------------------------------------------------------
0367+  1376             _putsn:
0368+  1376 DB            push al
0369+  1377 DA            push d
0370+  1378 D9            push c
0371+  1379             _putsn_L0:
0372+  1379 1E            mov al, [d]
0373+  137A 23            mov ah, al
0374+  137B 19 00         mov al, 0
0375+  137D 05 03         syscall sys_io
0376+  137F 79            inc d
0377+  1380 7E            dec c  
0378+  1381 C2 00 00      cmp c, 0
0379+  1384 C7 79 13      jne _putsn_L0
0380+  1387             _putsn_end:
0381+  1387 E6            pop c
0382+  1388 E7            pop d
0383+  1389 E8            pop al
0384+  138A 09            ret
0385+  138B             
0386+  138B             ;-----------------------------------------------------------------------------
0387+  138B             ; print 16bit decimal number
0388+  138B             ; input number in A
0389+  138B             ;-----------------------------------------------------------------------------
0390+  138B             print_u16d:
0391+  138B D7            push a
0392+  138C D8            push b
0393+  138D 26 10 27      mov b, 10000
0394+  1390 AE            div a, b      ; get 10000's coeff.
0395+  1391 07 B3 13      call print_number
0396+  1394 11            mov a, b
0397+  1395 26 E8 03      mov b, 1000
0398+  1398 AE            div a, b      ; get 1000's coeff.
0399+  1399 07 B3 13      call print_number
0400+  139C 11            mov a, b
0401+  139D 26 64 00      mov b, 100
0402+  13A0 AE            div a, b
0403+  13A1 07 B3 13      call print_number
0404+  13A4 11            mov a, b
0405+  13A5 26 0A 00      mov b, 10
0406+  13A8 AE            div a, b
0407+  13A9 07 B3 13      call print_number
0408+  13AC 1B            mov al, bl      ; 1's coeff in bl
0409+  13AD 07 B3 13      call print_number
0410+  13B0 E5            pop b
0411+  13B1 E4            pop a
0412+  13B2 09            ret
0413+  13B3             
0414+  13B3             ;-----------------------------------------------------------------------------
0415+  13B3             ; print AL
0416+  13B3             ;-----------------------------------------------------------------------------
0417+  13B3             print_number:
0418+  13B3 6A 30         add al, $30
0419+  13B5 23            mov ah, al
0420+  13B6 07 18 12      call _putchar
0421+  13B9 09            ret
0422+  13BA             
0423+  13BA             ;-----------------------------------------------------------------------------
0424+  13BA             ; PRINT 16BIT HEX INTEGER
0425+  13BA             ; integer value in reg B
0426+  13BA             ;-----------------------------------------------------------------------------
0427+  13BA             print_u16x:
0428+  13BA D7            push a
0429+  13BB D8            push b
0430+  13BC DD            push bl
0431+  13BD 30            mov bl, bh
0432+  13BE 07 E6 11      call _itoa        ; convert bh to char in A
0433+  13C1 2F            mov bl, al        ; save al
0434+  13C2 19 00         mov al, 0
0435+  13C4 05 03         syscall sys_io        ; display AH
0436+  13C6 24            mov ah, bl        ; retrieve al
0437+  13C7 19 00         mov al, 0
0438+  13C9 05 03         syscall sys_io        ; display AL
0439+  13CB             
0440+  13CB EA            pop bl
0441+  13CC 07 E6 11      call _itoa        ; convert bh to char in A
0442+  13CF 2F            mov bl, al        ; save al
0443+  13D0 19 00         mov al, 0
0444+  13D2 05 03         syscall sys_io        ; display AH
0445+  13D4 24            mov ah, bl        ; retrieve al
0446+  13D5 19 00         mov al, 0
0447+  13D7 05 03         syscall sys_io        ; display AL
0448+  13D9             
0449+  13D9 E5            pop b
0450+  13DA E4            pop a
0451+  13DB 09            ret
0452+  13DC             
0453+  13DC             ;-----------------------------------------------------------------------------
0454+  13DC             ; INPUT 16BIT HEX INTEGER
0455+  13DC             ; read 16bit integer into A
0456+  13DC             ;-----------------------------------------------------------------------------
0457+  13DC             scan_u16x:
0458+  13DC F8 10 00      enter 16
0459+  13DF D8            push b
0460+  13E0 DA            push d
0461+  13E1             
0462+  13E1 FA F1 FF      lea d, [bp + -15]
0463+  13E4 07 1F 12      call _gets        ; get number
0464+  13E7             
0465+  13E7 32            mov bl, [d]
0466+  13E8 37            mov bh, bl
0467+  13E9 33 01 00      mov bl, [d + 1]
0468+  13EC 07 D5 11      call _atoi        ; convert to int in AL
0469+  13EF 23            mov ah, al        ; move to AH
0470+  13F0             
0471+  13F0 33 02 00      mov bl, [d + 2]
0472+  13F3 37            mov bh, bl
0473+  13F4 33 03 00      mov bl, [d + 3]
0474+  13F7 07 D5 11      call _atoi        ; convert to int in AL
0475+  13FA             
0476+  13FA E7            pop d
0477+  13FB E5            pop b
0478+  13FC F9            leave
0479+  13FD 09            ret
0480+  13FE             
0481+  13FE             ;-----------------------------------------------------------------------------
0482+  13FE             ; PRINT 8bit HEX INTEGER
0483+  13FE             ; integer value in reg bl
0484+  13FE             ;-----------------------------------------------------------------------------
0485+  13FE             print_u8x:
0486+  13FE D7            push a
0487+  13FF DD            push bl
0488+  1400             
0489+  1400 07 E6 11      call _itoa        ; convert bl to char in A
0490+  1403 2F            mov bl, al        ; save al
0491+  1404 19 00         mov al, 0
0492+  1406 05 03         syscall sys_io        ; display AH
0493+  1408 24            mov ah, bl        ; retrieve al
0494+  1409 19 00         mov al, 0
0495+  140B 05 03         syscall sys_io        ; display AL
0496+  140D             
0497+  140D EA            pop bl
0498+  140E E4            pop a
0499+  140F 09            ret
0500+  1410             
0501+  1410             ;-----------------------------------------------------------------------------
0502+  1410             ; print 8bit decimal unsigned number
0503+  1410             ; input number in AL
0504+  1410             ;-----------------------------------------------------------------------------
0505+  1410             print_u8d:
0506+  1410 D7            push a
0507+  1411 D8            push b
0508+  1412             
0509+  1412 22 00         mov ah, 0
0510+  1414 26 64 00      mov b, 100
0511+  1417 AE            div a, b
0512+  1418 D8            push b      ; save remainder
0513+  1419 B9 00         cmp al, 0
0514+  141B C6 25 14      je skip100
0515+  141E 6A 30         add al, $30
0516+  1420 23            mov ah, al
0517+  1421 19 00         mov al, 0
0518+  1423 05 03         syscall sys_io  ; print coeff
0519+  1425             skip100:
0520+  1425 E4            pop a
0521+  1426 22 00         mov ah, 0
0522+  1428 26 0A 00      mov b, 10
0523+  142B AE            div a, b
0524+  142C D8            push b      ; save remainder
0525+  142D B9 00         cmp al, 0
0526+  142F C6 39 14      je skip10
0527+  1432 6A 30         add al, $30
0528+  1434 23            mov ah, al
0529+  1435 19 00         mov al, 0
0530+  1437 05 03         syscall sys_io  ; print coeff
0531+  1439             skip10:
0532+  1439 E4            pop a
0533+  143A 1B            mov al, bl
0534+  143B 6A 30         add al, $30
0535+  143D 23            mov ah, al
0536+  143E 19 00         mov al, 0
0537+  1440 05 03         syscall sys_io  ; print coeff
0538+  1442 E5            pop b
0539+  1443 E4            pop a
0540+  1444 09            ret
0541+  1445             
0542+  1445             ;-----------------------------------------------------------------------------
0543+  1445             ; INPUT 8BIT HEX INTEGER
0544+  1445             ; read 8bit integer into AL
0545+  1445             ;-----------------------------------------------------------------------------
0546+  1445             scan_u8x:
0547+  1445 F8 04 00      enter 4
0548+  1448 D8            push b
0549+  1449 DA            push d
0550+  144A             
0551+  144A FA FD FF      lea d, [bp + -3]
0552+  144D 07 1F 12      call _gets        ; get number
0553+  1450             
0554+  1450 32            mov bl, [d]
0555+  1451 37            mov bh, bl
0556+  1452 33 01 00      mov bl, [d + 1]
0557+  1455 07 D5 11      call _atoi        ; convert to int in AL
0558+  1458             
0559+  1458 E7            pop d
0560+  1459 E5            pop b
0561+  145A F9            leave
0562+  145B 09            ret
0563+  145C             
0564+  145C             ;-----------------------------------------------------------------------------
0565+  145C             ; input decimal number
0566+  145C             ; result in A
0567+  145C             ; 655'\0'
0568+  145C             ; low--------high
0569+  145C             ;-----------------------------------------------------------------------------
0570+  145C             scan_u16d:
0571+  145C F8 08 00      enter 8
0572+  145F E2            push si
0573+  1460 D8            push b
0574+  1461 D9            push c
0575+  1462 DA            push d
0576+  1463 FA F9 FF      lea d, [bp +- 7]
0577+  1466 07 1F 12      call _gets
0578+  1469 07 77 11      call _strlen      ; get string length in C
0579+  146C 7E            dec c
0580+  146D FD 4E         mov si, d
0581+  146F 12            mov a, c
0582+  1470 FD 99         shl a
0583+  1472 3B AE 14      mov d, table_power
0584+  1475 59            add d, a
0585+  1476 38 00 00      mov c, 0
0586+  1479             mul_loop:
0587+  1479 F6            lodsb      ; load ASCII to al
0588+  147A B9 00         cmp al, 0
0589+  147C C6 8F 14      je mul_exit
0590+  147F 6F 30         sub al, $30    ; make into integer
0591+  1481 22 00         mov ah, 0
0592+  1483 2A            mov b, [d]
0593+  1484 AC            mul a, b      ; result in B since it fits in 16bits
0594+  1485 11            mov a, b
0595+  1486 28            mov b, c
0596+  1487 54            add a, b
0597+  1488 39            mov c, a
0598+  1489 63 02 00      sub d, 2
0599+  148C 0A 79 14      jmp mul_loop
0600+  148F             mul_exit:
0601+  148F 12            mov a, c
0602+  1490 E7            pop d
0603+  1491 E6            pop c
0604+  1492 E5            pop b
0605+  1493 EF            pop si
0606+  1494 F9            leave
0607+  1495 09            ret
0608+  1496             
0609+  1496 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0609+  149A 34 35 36 37 
0609+  149E 38 39 41 42 
0609+  14A2 43 44 45 46 
0610+  14A6 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0610+  14AA 1B 5B 48 00 
0611+  14AE             
0612+  14AE             table_power:
0613+  14AE 01 00         .dw 1
0614+  14B0 0A 00         .dw 10
0615+  14B2 64 00         .dw 100
0616+  14B4 E8 03         .dw 1000
0617+  14B6 10 27         .dw 100002493   14B8             ; --- END INLINE ASM BLOCK
2494   14B8             
2495   14B8 F9            leave
2496   14B9 09            ret
2497   14BA             ; --- END TEXT BLOCK
2498   14BA             
2499   14BA             ; --- BEGIN DATA BLOCK
2500   14BA 00 00 00 00 _st1_data: .fill 13, 0
2500   14BE 00 00 00 00 
2500   14C2 00 00 00 00 
2500   14C6 00 
2501   14C7 54 65 73 74 __s0: .db "Test %d, Result: %u\n", 0
2501   14CB 20 25 64 2C 
2501   14CF 20 52 65 73 
2501   14D3 75 6C 74 3A 
2501   14D7 20 25 75 0A 
2501   14DB 00 
2502   14DC 55 6E 65 78 __s1: .db "Unexpected format in printf.", 0
2502   14E0 70 65 63 74 
2502   14E4 65 64 20 66 
2502   14E8 6F 72 6D 61 
2502   14EC 74 20 69 6E 
2502   14F0 20 70 72 69 
2502   14F4 6E 74 66 2E 
2502   14F8 00 
2503   14F9 45 72 72 6F __s2: .db "Error: Unknown argument type.\n", 0
2503   14FD 72 3A 20 55 
2503   1501 6E 6B 6E 6F 
2503   1505 77 6E 20 61 
2503   1509 72 67 75 6D 
2503   150D 65 6E 74 20 
2503   1511 74 79 70 65 
2503   1515 2E 0A 00 
2504   1518 1B 5B 32 4A __s3: .db "\033[2J\033[H", 0
2504   151C 1B 5B 48 00 
2505   1520             
2506   1520 22 15       _heap_top: .dw _heap
2507   1522 00          _heap: .db 0
2508   1523             ; --- END DATA BLOCK
2509   1523             
2510   1523             .end
tasm: Number of errors = 0
