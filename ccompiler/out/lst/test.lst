0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT SEGMENT
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; sprintf(s, "Integer: %d, Char: %c, String: %s\n\n",  2341, 'G', "Hello World!"); 
0011   0408 26 B3 20      mov b, _s1 ; "Hello World!"
0012   040B FD AB         swp b
0013   040D D8            push b
0014   040E 26 47 00      mov b, $47
0015   0411 DD            push bl
0016   0412 26 25 09      mov b, $925
0017   0415 FD AB         swp b
0018   0417 D8            push b
0019   0418 26 C0 20      mov b, _s2 ; "Integer: %d, Char: %c, String: %s\n\n"
0020   041B FD AB         swp b
0021   041D D8            push b
0022   041E 3B A1 1F      mov d, _s_data ; $s
0023   0421 2D            mov b, d
0024   0422 FD AB         swp b
0025   0424 D8            push b
0026   0425 07 F3 0C      call sprintf
0027   0428 51 09 00      add sp, 9
0028   042B             ; printf("Final String: %s", s); 
0029   042B 3B A1 1F      mov d, _s_data ; $s
0030   042E 2D            mov b, d
0031   042F FD AB         swp b
0032   0431 D8            push b
0033   0432 26 E4 20      mov b, _s3 ; "Final String: %s"
0034   0435 FD AB         swp b
0035   0437 D8            push b
0036   0438 07 40 08      call printf
0037   043B 51 04 00      add sp, 4
0038   043E 05 0B         syscall sys_terminate_proc
0039   0440             
0040   0440             strcpy:
0041   0440 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0042   0443             ; char *psrc; 
0043   0443 52 02 00      sub sp, 2
0044   0446             ; char *pdest; 
0045   0446 52 02 00      sub sp, 2
0046   0449             ; psrc = src; 
0047   0449 FA FF FF      lea d, [bp + -1] ; $psrc
0048   044C DA            push d
0049   044D FA 07 00      lea d, [bp + 7] ; $src
0050   0450 2A            mov b, [d]
0051   0451 E7            pop d
0052   0452 FD 43         mov [d], b
0053   0454             ; pdest = dest; 
0054   0454 FA FD FF      lea d, [bp + -3] ; $pdest
0055   0457 DA            push d
0056   0458 FA 05 00      lea d, [bp + 5] ; $dest
0057   045B 2A            mov b, [d]
0058   045C E7            pop d
0059   045D FD 43         mov [d], b
0060   045F             ; while(*psrc) *pdest++ = *psrc++; 
0061   045F             _while1_cond:
0062   045F FA FF FF      lea d, [bp + -1] ; $psrc
0063   0462 2A            mov b, [d]
0064   0463 74            mov d, b
0065   0464 32            mov bl, [d]
0066   0465 A7 00         mov bh, 0
0067   0467 C0 00 00      cmp b, 0
0068   046A C6 92 04      je _while1_exit
0069   046D             _while1_block:
0070   046D             ; *pdest++ = *psrc++; 
0071   046D FA FD FF      lea d, [bp + -3] ; $pdest
0072   0470 2A            mov b, [d]
0073   0471 FD 77         inc b
0074   0473 FA FD FF      lea d, [bp + -3] ; $pdest
0075   0476 FD 43         mov [d], b
0076   0478 FD 7D         dec b
0077   047A D8            push b
0078   047B FA FF FF      lea d, [bp + -1] ; $psrc
0079   047E 2A            mov b, [d]
0080   047F FD 77         inc b
0081   0481 FA FF FF      lea d, [bp + -1] ; $psrc
0082   0484 FD 43         mov [d], b
0083   0486 FD 7D         dec b
0084   0488 74            mov d, b
0085   0489 32            mov bl, [d]
0086   048A A7 00         mov bh, 0
0087   048C E7            pop d
0088   048D FD 3E         mov [d], bl
0089   048F 0A 5F 04      jmp _while1_cond
0090   0492             _while1_exit:
0091   0492             ; *pdest = '\0'; 
0092   0492 FA FD FF      lea d, [bp + -3] ; $pdest
0093   0495 2A            mov b, [d]
0094   0496 D8            push b
0095   0497 26 00 00      mov b, $0
0096   049A E7            pop d
0097   049B FD 3E         mov [d], bl
0098   049D F9            leave
0099   049E 09            ret
0100   049F             
0101   049F             strcmp:
0102   049F F8 00 00      enter 0 ; (push bp; mov bp, sp)
0103   04A2             ; while (*s1 && (*s1 == *s2)) { 
0104   04A2             _while2_cond:
0105   04A2 FA 05 00      lea d, [bp + 5] ; $s1
0106   04A5 2A            mov b, [d]
0107   04A6 74            mov d, b
0108   04A7 32            mov bl, [d]
0109   04A8 A7 00         mov bh, 0
0110   04AA             ; --- START LOGICAL AND
0111   04AA D7            push a
0112   04AB 11            mov a, b
0113   04AC FA 05 00      lea d, [bp + 5] ; $s1
0114   04AF 2A            mov b, [d]
0115   04B0 74            mov d, b
0116   04B1 32            mov bl, [d]
0117   04B2 A7 00         mov bh, 0
0118   04B4             ; --- START RELATIONAL
0119   04B4 D7            push a
0120   04B5 11            mov a, b
0121   04B6 FA 07 00      lea d, [bp + 7] ; $s2
0122   04B9 2A            mov b, [d]
0123   04BA 74            mov d, b
0124   04BB 32            mov bl, [d]
0125   04BC A7 00         mov bh, 0
0126   04BE B0            cmp a, b
0127   04BF FD 71         seq ; ==
0128   04C1 E4            pop a
0129   04C2             ; --- END RELATIONAL
0130   04C2 FD A7         sand a, b
0131   04C4 E4            pop a
0132   04C5             ; --- END LOGICAL AND
0133   04C5 C0 00 00      cmp b, 0
0134   04C8 C6 E8 04      je _while2_exit
0135   04CB             _while2_block:
0136   04CB             ; s1++; 
0137   04CB FA 05 00      lea d, [bp + 5] ; $s1
0138   04CE 2A            mov b, [d]
0139   04CF FD 77         inc b
0140   04D1 FA 05 00      lea d, [bp + 5] ; $s1
0141   04D4 FD 43         mov [d], b
0142   04D6 FD 7D         dec b
0143   04D8             ; s2++; 
0144   04D8 FA 07 00      lea d, [bp + 7] ; $s2
0145   04DB 2A            mov b, [d]
0146   04DC FD 77         inc b
0147   04DE FA 07 00      lea d, [bp + 7] ; $s2
0148   04E1 FD 43         mov [d], b
0149   04E3 FD 7D         dec b
0150   04E5 0A A2 04      jmp _while2_cond
0151   04E8             _while2_exit:
0152   04E8             ; return *s1 - *s2; 
0153   04E8 FA 05 00      lea d, [bp + 5] ; $s1
0154   04EB 2A            mov b, [d]
0155   04EC 74            mov d, b
0156   04ED 32            mov bl, [d]
0157   04EE A7 00         mov bh, 0
0158   04F0             ; --- START TERMS
0159   04F0 D7            push a
0160   04F1 11            mov a, b
0161   04F2 FA 07 00      lea d, [bp + 7] ; $s2
0162   04F5 2A            mov b, [d]
0163   04F6 74            mov d, b
0164   04F7 32            mov bl, [d]
0165   04F8 A7 00         mov bh, 0
0166   04FA 60            sub a, b
0167   04FB 27            mov b, a
0168   04FC E4            pop a
0169   04FD             ; --- END TERMS
0170   04FD F9            leave
0171   04FE 09            ret
0172   04FF             
0173   04FF             strncmp:
0174   04FF F8 00 00      enter 0 ; (push bp; mov bp, sp)
0175   0502 F9            leave
0176   0503 09            ret
0177   0504             
0178   0504             strcat:
0179   0504 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0180   0507             ; int dest_len; 
0181   0507 52 02 00      sub sp, 2
0182   050A             ; int i; 
0183   050A 52 02 00      sub sp, 2
0184   050D             ; dest_len = strlen(dest); 
0185   050D FA FF FF      lea d, [bp + -1] ; $dest_len
0186   0510 DA            push d
0187   0511 FA 05 00      lea d, [bp + 5] ; $dest
0188   0514 2A            mov b, [d]
0189   0515 FD AB         swp b
0190   0517 D8            push b
0191   0518 07 BA 05      call strlen
0192   051B 51 02 00      add sp, 2
0193   051E E7            pop d
0194   051F FD 43         mov [d], b
0195   0521             ; for (i = 0; src[i] != 0; i=i+1) { 
0196   0521             _for3_init:
0197   0521 FA FD FF      lea d, [bp + -3] ; $i
0198   0524 DA            push d
0199   0525 26 00 00      mov b, $0
0200   0528 E7            pop d
0201   0529 FD 43         mov [d], b
0202   052B             _for3_cond:
0203   052B FA 07 00      lea d, [bp + 7] ; $src
0204   052E FD 2A         mov d, [d]
0205   0530 D7            push a
0206   0531 DA            push d
0207   0532 FA FD FF      lea d, [bp + -3] ; $i
0208   0535 2A            mov b, [d]
0209   0536 E7            pop d
0210   0537 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0211   053B E4            pop a
0212   053C 32            mov bl, [d]
0213   053D A7 00         mov bh, 0
0214   053F             ; --- START RELATIONAL
0215   053F D7            push a
0216   0540 11            mov a, b
0217   0541 26 00 00      mov b, $0
0218   0544 B0            cmp a, b
0219   0545 FD 72         sneq ; !=
0220   0547 E4            pop a
0221   0548             ; --- END RELATIONAL
0222   0548 C0 00 00      cmp b, 0
0223   054B C6 94 05      je _for3_exit
0224   054E             _for3_block:
0225   054E             ; dest[dest_len + i] = src[i]; 
0226   054E FA 05 00      lea d, [bp + 5] ; $dest
0227   0551 FD 2A         mov d, [d]
0228   0553 D7            push a
0229   0554 DA            push d
0230   0555 FA FF FF      lea d, [bp + -1] ; $dest_len
0231   0558 2A            mov b, [d]
0232   0559             ; --- START TERMS
0233   0559 D7            push a
0234   055A 11            mov a, b
0235   055B FA FD FF      lea d, [bp + -3] ; $i
0236   055E 2A            mov b, [d]
0237   055F 56            add b, a
0238   0560 E4            pop a
0239   0561             ; --- END TERMS
0240   0561 E7            pop d
0241   0562 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0242   0566 E4            pop a
0243   0567 DA            push d
0244   0568 FA 07 00      lea d, [bp + 7] ; $src
0245   056B FD 2A         mov d, [d]
0246   056D D7            push a
0247   056E DA            push d
0248   056F FA FD FF      lea d, [bp + -3] ; $i
0249   0572 2A            mov b, [d]
0250   0573 E7            pop d
0251   0574 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0252   0578 E4            pop a
0253   0579 32            mov bl, [d]
0254   057A A7 00         mov bh, 0
0255   057C E7            pop d
0256   057D FD 3E         mov [d], bl
0257   057F             _for3_update:
0258   057F FA FD FF      lea d, [bp + -3] ; $i
0259   0582 DA            push d
0260   0583 FA FD FF      lea d, [bp + -3] ; $i
0261   0586 2A            mov b, [d]
0262   0587             ; --- START TERMS
0263   0587 D7            push a
0264   0588 11            mov a, b
0265   0589 26 01 00      mov b, $1
0266   058C 56            add b, a
0267   058D E4            pop a
0268   058E             ; --- END TERMS
0269   058E E7            pop d
0270   058F FD 43         mov [d], b
0271   0591 0A 2B 05      jmp _for3_cond
0272   0594             _for3_exit:
0273   0594             ; dest[dest_len + i] = 0; 
0274   0594 FA 05 00      lea d, [bp + 5] ; $dest
0275   0597 FD 2A         mov d, [d]
0276   0599 D7            push a
0277   059A DA            push d
0278   059B FA FF FF      lea d, [bp + -1] ; $dest_len
0279   059E 2A            mov b, [d]
0280   059F             ; --- START TERMS
0281   059F D7            push a
0282   05A0 11            mov a, b
0283   05A1 FA FD FF      lea d, [bp + -3] ; $i
0284   05A4 2A            mov b, [d]
0285   05A5 56            add b, a
0286   05A6 E4            pop a
0287   05A7             ; --- END TERMS
0288   05A7 E7            pop d
0289   05A8 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0290   05AC E4            pop a
0291   05AD DA            push d
0292   05AE 26 00 00      mov b, $0
0293   05B1 E7            pop d
0294   05B2 FD 3E         mov [d], bl
0295   05B4             ; return dest; 
0296   05B4 FA 05 00      lea d, [bp + 5] ; $dest
0297   05B7 2A            mov b, [d]
0298   05B8 F9            leave
0299   05B9 09            ret
0300   05BA             
0301   05BA             strlen:
0302   05BA F8 00 00      enter 0 ; (push bp; mov bp, sp)
0303   05BD             ; int length; 
0304   05BD 52 02 00      sub sp, 2
0305   05C0             ; length = 0; 
0306   05C0 FA FF FF      lea d, [bp + -1] ; $length
0307   05C3 DA            push d
0308   05C4 26 00 00      mov b, $0
0309   05C7 E7            pop d
0310   05C8 FD 43         mov [d], b
0311   05CA             ; while (str[length] != 0) { 
0312   05CA             _while4_cond:
0313   05CA FA 05 00      lea d, [bp + 5] ; $str
0314   05CD FD 2A         mov d, [d]
0315   05CF D7            push a
0316   05D0 DA            push d
0317   05D1 FA FF FF      lea d, [bp + -1] ; $length
0318   05D4 2A            mov b, [d]
0319   05D5 E7            pop d
0320   05D6 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0321   05DA E4            pop a
0322   05DB 32            mov bl, [d]
0323   05DC A7 00         mov bh, 0
0324   05DE             ; --- START RELATIONAL
0325   05DE D7            push a
0326   05DF 11            mov a, b
0327   05E0 26 00 00      mov b, $0
0328   05E3 B0            cmp a, b
0329   05E4 FD 72         sneq ; !=
0330   05E6 E4            pop a
0331   05E7             ; --- END RELATIONAL
0332   05E7 C0 00 00      cmp b, 0
0333   05EA C6 FD 05      je _while4_exit
0334   05ED             _while4_block:
0335   05ED             ; length++; 
0336   05ED FA FF FF      lea d, [bp + -1] ; $length
0337   05F0 2A            mov b, [d]
0338   05F1 FD 77         inc b
0339   05F3 FA FF FF      lea d, [bp + -1] ; $length
0340   05F6 FD 43         mov [d], b
0341   05F8 FD 7D         dec b
0342   05FA 0A CA 05      jmp _while4_cond
0343   05FD             _while4_exit:
0344   05FD             ; return length; 
0345   05FD FA FF FF      lea d, [bp + -1] ; $length
0346   0600 2A            mov b, [d]
0347   0601 F9            leave
0348   0602 09            ret
0349   0603             
0350   0603             exit:
0351   0603 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0352   0606             
0353   0606             ; --- BEGIN INLINE ASM SEGMENT
0354   0606 05 0B         syscall sys_terminate_proc
0355   0608             ; --- END INLINE ASM SEGMENT
0356   0608             
0357   0608 F9            leave
0358   0609 09            ret
0359   060A             
0360   060A             memset:
0361   060A F8 00 00      enter 0 ; (push bp; mov bp, sp)
0362   060D             ; int i; 
0363   060D 52 02 00      sub sp, 2
0364   0610             ; for(i = 0; i < size; i++){ 
0365   0610             _for5_init:
0366   0610 FA FF FF      lea d, [bp + -1] ; $i
0367   0613 DA            push d
0368   0614 26 00 00      mov b, $0
0369   0617 E7            pop d
0370   0618 FD 43         mov [d], b
0371   061A             _for5_cond:
0372   061A FA FF FF      lea d, [bp + -1] ; $i
0373   061D 2A            mov b, [d]
0374   061E             ; --- START RELATIONAL
0375   061E D7            push a
0376   061F 11            mov a, b
0377   0620 FA 08 00      lea d, [bp + 8] ; $size
0378   0623 2A            mov b, [d]
0379   0624 B0            cmp a, b
0380   0625 FD 73         slt ; < (signed)
0381   0627 E4            pop a
0382   0628             ; --- END RELATIONAL
0383   0628 C0 00 00      cmp b, 0
0384   062B C6 54 06      je _for5_exit
0385   062E             _for5_block:
0386   062E             ; *(s+i) = c; 
0387   062E FA 05 00      lea d, [bp + 5] ; $s
0388   0631 2A            mov b, [d]
0389   0632             ; --- START TERMS
0390   0632 D7            push a
0391   0633 11            mov a, b
0392   0634 FA FF FF      lea d, [bp + -1] ; $i
0393   0637 2A            mov b, [d]
0394   0638 56            add b, a
0395   0639 E4            pop a
0396   063A             ; --- END TERMS
0397   063A D8            push b
0398   063B FA 07 00      lea d, [bp + 7] ; $c
0399   063E 32            mov bl, [d]
0400   063F A7 00         mov bh, 0
0401   0641 E7            pop d
0402   0642 FD 3E         mov [d], bl
0403   0644             _for5_update:
0404   0644 FA FF FF      lea d, [bp + -1] ; $i
0405   0647 2A            mov b, [d]
0406   0648 FD 77         inc b
0407   064A FA FF FF      lea d, [bp + -1] ; $i
0408   064D FD 43         mov [d], b
0409   064F FD 7D         dec b
0410   0651 0A 1A 06      jmp _for5_cond
0411   0654             _for5_exit:
0412   0654             ; return s; 
0413   0654 FA 05 00      lea d, [bp + 5] ; $s
0414   0657 2A            mov b, [d]
0415   0658 F9            leave
0416   0659 09            ret
0417   065A             
0418   065A             atoi:
0419   065A F8 00 00      enter 0 ; (push bp; mov bp, sp)
0420   065D             ; int result = 0;  // Initialize result 
0421   065D 52 02 00      sub sp, 2
0422   0660             ; --- START LOCAL VAR INITIALIZATION
0423   0660 FA FF FF      lea d, [bp + -1] ; $result
0424   0663 DA            push d
0425   0664 26 00 00      mov b, $0
0426   0667 E7            pop d
0427   0668 FD 43         mov [d], b
0428   066A             ; --- END LOCAL VAR INITIALIZATION
0429   066A             ; int sign = 1;    // Initialize sign as positive 
0430   066A 52 02 00      sub sp, 2
0431   066D             ; --- START LOCAL VAR INITIALIZATION
0432   066D FA FD FF      lea d, [bp + -3] ; $sign
0433   0670 DA            push d
0434   0671 26 01 00      mov b, $1
0435   0674 E7            pop d
0436   0675 FD 43         mov [d], b
0437   0677             ; --- END LOCAL VAR INITIALIZATION
0438   0677             ; while (*str == ' ') str++; 
0439   0677             _while6_cond:
0440   0677 FA 05 00      lea d, [bp + 5] ; $str
0441   067A 2A            mov b, [d]
0442   067B 74            mov d, b
0443   067C 32            mov bl, [d]
0444   067D A7 00         mov bh, 0
0445   067F             ; --- START RELATIONAL
0446   067F D7            push a
0447   0680 11            mov a, b
0448   0681 26 20 00      mov b, $20
0449   0684 B0            cmp a, b
0450   0685 FD 71         seq ; ==
0451   0687 E4            pop a
0452   0688             ; --- END RELATIONAL
0453   0688 C0 00 00      cmp b, 0
0454   068B C6 9E 06      je _while6_exit
0455   068E             _while6_block:
0456   068E             ; str++; 
0457   068E FA 05 00      lea d, [bp + 5] ; $str
0458   0691 2A            mov b, [d]
0459   0692 FD 77         inc b
0460   0694 FA 05 00      lea d, [bp + 5] ; $str
0461   0697 FD 43         mov [d], b
0462   0699 FD 7D         dec b
0463   069B 0A 77 06      jmp _while6_cond
0464   069E             _while6_exit:
0465   069E             ; if (*str == '-' || *str == '+') { 
0466   069E             _if7_cond:
0467   069E FA 05 00      lea d, [bp + 5] ; $str
0468   06A1 2A            mov b, [d]
0469   06A2 74            mov d, b
0470   06A3 32            mov bl, [d]
0471   06A4 A7 00         mov bh, 0
0472   06A6             ; --- START RELATIONAL
0473   06A6 D7            push a
0474   06A7 11            mov a, b
0475   06A8 26 2D 00      mov b, $2d
0476   06AB B0            cmp a, b
0477   06AC FD 71         seq ; ==
0478   06AE E4            pop a
0479   06AF             ; --- END RELATIONAL
0480   06AF             ; --- START LOGICAL OR
0481   06AF D7            push a
0482   06B0 11            mov a, b
0483   06B1 FA 05 00      lea d, [bp + 5] ; $str
0484   06B4 2A            mov b, [d]
0485   06B5 74            mov d, b
0486   06B6 32            mov bl, [d]
0487   06B7 A7 00         mov bh, 0
0488   06B9             ; --- START RELATIONAL
0489   06B9 D7            push a
0490   06BA 11            mov a, b
0491   06BB 26 2B 00      mov b, $2b
0492   06BE B0            cmp a, b
0493   06BF FD 71         seq ; ==
0494   06C1 E4            pop a
0495   06C2             ; --- END RELATIONAL
0496   06C2 FD A8         sor a, b ; ||
0497   06C4 E4            pop a
0498   06C5             ; --- END LOGICAL OR
0499   06C5 C0 00 00      cmp b, 0
0500   06C8 C6 01 07      je _if7_exit
0501   06CB             _if7_true:
0502   06CB             ; if (*str == '-') sign = -1; 
0503   06CB             _if8_cond:
0504   06CB FA 05 00      lea d, [bp + 5] ; $str
0505   06CE 2A            mov b, [d]
0506   06CF 74            mov d, b
0507   06D0 32            mov bl, [d]
0508   06D1 A7 00         mov bh, 0
0509   06D3             ; --- START RELATIONAL
0510   06D3 D7            push a
0511   06D4 11            mov a, b
0512   06D5 26 2D 00      mov b, $2d
0513   06D8 B0            cmp a, b
0514   06D9 FD 71         seq ; ==
0515   06DB E4            pop a
0516   06DC             ; --- END RELATIONAL
0517   06DC C0 00 00      cmp b, 0
0518   06DF C6 F1 06      je _if8_exit
0519   06E2             _if8_true:
0520   06E2             ; sign = -1; 
0521   06E2 FA FD FF      lea d, [bp + -3] ; $sign
0522   06E5 DA            push d
0523   06E6 26 01 00      mov b, $1
0524   06E9 FD 97         neg b
0525   06EB E7            pop d
0526   06EC FD 43         mov [d], b
0527   06EE 0A F1 06      jmp _if8_exit
0528   06F1             _if8_exit:
0529   06F1             ; str++; 
0530   06F1 FA 05 00      lea d, [bp + 5] ; $str
0531   06F4 2A            mov b, [d]
0532   06F5 FD 77         inc b
0533   06F7 FA 05 00      lea d, [bp + 5] ; $str
0534   06FA FD 43         mov [d], b
0535   06FC FD 7D         dec b
0536   06FE 0A 01 07      jmp _if7_exit
0537   0701             _if7_exit:
0538   0701             ; while (*str >= '0' && *str <= '9') { 
0539   0701             _while9_cond:
0540   0701 FA 05 00      lea d, [bp + 5] ; $str
0541   0704 2A            mov b, [d]
0542   0705 74            mov d, b
0543   0706 32            mov bl, [d]
0544   0707 A7 00         mov bh, 0
0545   0709             ; --- START RELATIONAL
0546   0709 D7            push a
0547   070A 11            mov a, b
0548   070B 26 30 00      mov b, $30
0549   070E B0            cmp a, b
0550   070F FD 82         sgeu ; >= (unsigned)
0551   0711 E4            pop a
0552   0712             ; --- END RELATIONAL
0553   0712             ; --- START LOGICAL AND
0554   0712 D7            push a
0555   0713 11            mov a, b
0556   0714 FA 05 00      lea d, [bp + 5] ; $str
0557   0717 2A            mov b, [d]
0558   0718 74            mov d, b
0559   0719 32            mov bl, [d]
0560   071A A7 00         mov bh, 0
0561   071C             ; --- START RELATIONAL
0562   071C D7            push a
0563   071D 11            mov a, b
0564   071E 26 39 00      mov b, $39
0565   0721 B0            cmp a, b
0566   0722 FD 76         sleu ; <= (unsigned)
0567   0724 E4            pop a
0568   0725             ; --- END RELATIONAL
0569   0725 FD A7         sand a, b
0570   0727 E4            pop a
0571   0728             ; --- END LOGICAL AND
0572   0728 C0 00 00      cmp b, 0
0573   072B C6 66 07      je _while9_exit
0574   072E             _while9_block:
0575   072E             ; result = result * 10 + (*str - '0'); 
0576   072E FA FF FF      lea d, [bp + -1] ; $result
0577   0731 DA            push d
0578   0732 FA FF FF      lea d, [bp + -1] ; $result
0579   0735 2A            mov b, [d]
0580   0736             ; --- START FACTORS
0581   0736 D7            push a
0582   0737 11            mov a, b
0583   0738 26 0A 00      mov b, $a
0584   073B AC            mul a, b ; *
0585   073C 11            mov a, b
0586   073D 27            mov b, a
0587   073E E4            pop a
0588   073F             ; --- END FACTORS
0589   073F             ; --- START TERMS
0590   073F D7            push a
0591   0740 11            mov a, b
0592   0741 FA 05 00      lea d, [bp + 5] ; $str
0593   0744 2A            mov b, [d]
0594   0745 74            mov d, b
0595   0746 32            mov bl, [d]
0596   0747 A7 00         mov bh, 0
0597   0749             ; --- START TERMS
0598   0749 D7            push a
0599   074A 11            mov a, b
0600   074B 26 30 00      mov b, $30
0601   074E 60            sub a, b
0602   074F 27            mov b, a
0603   0750 E4            pop a
0604   0751             ; --- END TERMS
0605   0751 56            add b, a
0606   0752 E4            pop a
0607   0753             ; --- END TERMS
0608   0753 E7            pop d
0609   0754 FD 43         mov [d], b
0610   0756             ; str++; 
0611   0756 FA 05 00      lea d, [bp + 5] ; $str
0612   0759 2A            mov b, [d]
0613   075A FD 77         inc b
0614   075C FA 05 00      lea d, [bp + 5] ; $str
0615   075F FD 43         mov [d], b
0616   0761 FD 7D         dec b
0617   0763 0A 01 07      jmp _while9_cond
0618   0766             _while9_exit:
0619   0766             ; return sign * result; 
0620   0766 FA FD FF      lea d, [bp + -3] ; $sign
0621   0769 2A            mov b, [d]
0622   076A             ; --- START FACTORS
0623   076A D7            push a
0624   076B 11            mov a, b
0625   076C FA FF FF      lea d, [bp + -1] ; $result
0626   076F 2A            mov b, [d]
0627   0770 AC            mul a, b ; *
0628   0771 11            mov a, b
0629   0772 27            mov b, a
0630   0773 E4            pop a
0631   0774             ; --- END FACTORS
0632   0774 F9            leave
0633   0775 09            ret
0634   0776             
0635   0776             rand:
0636   0776 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0637   0779             ; int  sec; 
0638   0779 52 02 00      sub sp, 2
0639   077C             
0640   077C             ; --- BEGIN INLINE ASM SEGMENT
0641   077C 19 00         mov al, 0
0642   077E 05 01         syscall sys_rtc					
0643   0780 1A            mov al, ah
0644   0781 FA FF FF      lea d, [bp + -1] ; $sec
0645   0784 1E            mov al, [d]
0646   0785 22 00         mov ah, 0
0647   0787             ; --- END INLINE ASM SEGMENT
0648   0787             
0649   0787             ; return sec; 
0650   0787 FA FF FF      lea d, [bp + -1] ; $sec
0651   078A 2A            mov b, [d]
0652   078B F9            leave
0653   078C 09            ret
0654   078D             
0655   078D             alloc:
0656   078D F8 00 00      enter 0 ; (push bp; mov bp, sp)
0657   0790             ; heap_top = heap_top + bytes; 
0658   0790 3B 39 21      mov d, _heap_top ; $heap_top
0659   0793 DA            push d
0660   0794 3B 39 21      mov d, _heap_top ; $heap_top
0661   0797 2A            mov b, [d]
0662   0798             ; --- START TERMS
0663   0798 D7            push a
0664   0799 11            mov a, b
0665   079A FA 05 00      lea d, [bp + 5] ; $bytes
0666   079D 2A            mov b, [d]
0667   079E 56            add b, a
0668   079F E4            pop a
0669   07A0             ; --- END TERMS
0670   07A0 E7            pop d
0671   07A1 FD 43         mov [d], b
0672   07A3             ; return heap_top - bytes; 
0673   07A3 3B 39 21      mov d, _heap_top ; $heap_top
0674   07A6 2A            mov b, [d]
0675   07A7             ; --- START TERMS
0676   07A7 D7            push a
0677   07A8 11            mov a, b
0678   07A9 FA 05 00      lea d, [bp + 5] ; $bytes
0679   07AC 2A            mov b, [d]
0680   07AD 60            sub a, b
0681   07AE 27            mov b, a
0682   07AF E4            pop a
0683   07B0             ; --- END TERMS
0684   07B0 F9            leave
0685   07B1 09            ret
0686   07B2             
0687   07B2             free:
0688   07B2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0689   07B5             ; return heap_top = heap_top - bytes; 
0690   07B5 3B 39 21      mov d, _heap_top ; $heap_top
0691   07B8 DA            push d
0692   07B9 3B 39 21      mov d, _heap_top ; $heap_top
0693   07BC 2A            mov b, [d]
0694   07BD             ; --- START TERMS
0695   07BD D7            push a
0696   07BE 11            mov a, b
0697   07BF FA 05 00      lea d, [bp + 5] ; $bytes
0698   07C2 2A            mov b, [d]
0699   07C3 60            sub a, b
0700   07C4 27            mov b, a
0701   07C5 E4            pop a
0702   07C6             ; --- END TERMS
0703   07C6 E7            pop d
0704   07C7 FD 43         mov [d], b
0705   07C9 F9            leave
0706   07CA 09            ret
0707   07CB             
0708   07CB             fopen:
0709   07CB F8 00 00      enter 0 ; (push bp; mov bp, sp)
0710   07CE             ; FILE *fp; 
0711   07CE 52 02 00      sub sp, 2
0712   07D1             ; static int max_handle = 0; 
0713   07D1 52 02 00      sub sp, 2
0714   07D4             ; fp = alloc(sizeof(FILE)); 
0715   07D4 FA FF FF      lea d, [bp + -1] ; $fp
0716   07D7 DA            push d
0717   07D8 26 04 01      mov b, 260
0718   07DB FD AB         swp b
0719   07DD D8            push b
0720   07DE 07 8D 07      call alloc
0721   07E1 51 02 00      add sp, 2
0722   07E4 E7            pop d
0723   07E5 FD 43         mov [d], b
0724   07E7             ; strcpy(fp->filename, filename); 
0725   07E7 FA 05 00      lea d, [bp + 5] ; $filename
0726   07EA 2A            mov b, [d]
0727   07EB FD AB         swp b
0728   07ED D8            push b
0729   07EE FA FF FF      lea d, [bp + -1] ; $fp
0730   07F1 FD 2A         mov d, [d]
0731   07F3 58 02 00      add d, 2
0732   07F6 2D            mov b, d
0733   07F7 FD AB         swp b
0734   07F9 D8            push b
0735   07FA 07 40 04      call strcpy
0736   07FD 51 04 00      add sp, 4
0737   0800             ; fp->handle = max_handle; 
0738   0800 FA FF FF      lea d, [bp + -1] ; $fp
0739   0803 FD 2A         mov d, [d]
0740   0805 58 00 00      add d, 0
0741   0808 DA            push d
0742   0809 3B AB 20      mov d, st_fopen_max_handle ; static max_handle
0743   080C 2A            mov b, [d]
0744   080D E7            pop d
0745   080E FD 43         mov [d], b
0746   0810             ; fp->mode = mode; 
0747   0810 FA FF FF      lea d, [bp + -1] ; $fp
0748   0813 FD 2A         mov d, [d]
0749   0815 58 02 01      add d, 258
0750   0818 DA            push d
0751   0819 FA 07 00      lea d, [bp + 7] ; $mode
0752   081C 32            mov bl, [d]
0753   081D A7 00         mov bh, 0
0754   081F E7            pop d
0755   0820 FD 3E         mov [d], bl
0756   0822             ; fp->loc = 0; 
0757   0822 FA FF FF      lea d, [bp + -1] ; $fp
0758   0825 FD 2A         mov d, [d]
0759   0827 58 03 01      add d, 259
0760   082A DA            push d
0761   082B 26 00 00      mov b, $0
0762   082E E7            pop d
0763   082F FD 3E         mov [d], bl
0764   0831             ; max_handle++; 
0765   0831 3B AB 20      mov d, st_fopen_max_handle ; static max_handle
0766   0834 2A            mov b, [d]
0767   0835 FD 77         inc b
0768   0837 3B AB 20      mov d, st_fopen_max_handle ; static max_handle
0769   083A FD 43         mov [d], b
0770   083C FD 7D         dec b
0771   083E F9            leave
0772   083F 09            ret
0773   0840             
0774   0840             printf:
0775   0840 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0776   0843             ; char *p, *format_p; 
0777   0843 52 02 00      sub sp, 2
0778   0846 52 02 00      sub sp, 2
0779   0849             ; format_p = format; 
0780   0849 FA FD FF      lea d, [bp + -3] ; $format_p
0781   084C DA            push d
0782   084D FA 05 00      lea d, [bp + 5] ; $format
0783   0850 2A            mov b, [d]
0784   0851 E7            pop d
0785   0852 FD 43         mov [d], b
0786   0854             ; p = &format + 2; 
0787   0854 FA FF FF      lea d, [bp + -1] ; $p
0788   0857 DA            push d
0789   0858 FA 05 00      lea d, [bp + 5] ; $format
0790   085B 2D            mov b, d
0791   085C             ; --- START TERMS
0792   085C D7            push a
0793   085D 11            mov a, b
0794   085E 26 02 00      mov b, $2
0795   0861 56            add b, a
0796   0862 E4            pop a
0797   0863             ; --- END TERMS
0798   0863 E7            pop d
0799   0864 FD 43         mov [d], b
0800   0866             ; for(;;){ 
0801   0866             _for10_init:
0802   0866             _for10_cond:
0803   0866             _for10_block:
0804   0866             ; if(!*format_p) break; 
0805   0866             _if11_cond:
0806   0866 FA FD FF      lea d, [bp + -3] ; $format_p
0807   0869 2A            mov b, [d]
0808   086A 74            mov d, b
0809   086B 32            mov bl, [d]
0810   086C A7 00         mov bh, 0
0811   086E C0 00 00      cmp b, 0
0812   0871 FD 71         seq ; !
0813   0873 C0 00 00      cmp b, 0
0814   0876 C6 7F 08      je _if11_else
0815   0879             _if11_true:
0816   0879             ; break; 
0817   0879 0A A6 0A      jmp _for10_exit ; for break
0818   087C 0A A3 0A      jmp _if11_exit
0819   087F             _if11_else:
0820   087F             ; if(*format_p == '%'){ 
0821   087F             _if12_cond:
0822   087F FA FD FF      lea d, [bp + -3] ; $format_p
0823   0882 2A            mov b, [d]
0824   0883 74            mov d, b
0825   0884 32            mov bl, [d]
0826   0885 A7 00         mov bh, 0
0827   0887             ; --- START RELATIONAL
0828   0887 D7            push a
0829   0888 11            mov a, b
0830   0889 26 25 00      mov b, $25
0831   088C B0            cmp a, b
0832   088D FD 71         seq ; ==
0833   088F E4            pop a
0834   0890             ; --- END RELATIONAL
0835   0890 C0 00 00      cmp b, 0
0836   0893 C6 87 0A      je _if12_else
0837   0896             _if12_true:
0838   0896             ; format_p++; 
0839   0896 FA FD FF      lea d, [bp + -3] ; $format_p
0840   0899 2A            mov b, [d]
0841   089A FD 77         inc b
0842   089C FA FD FF      lea d, [bp + -3] ; $format_p
0843   089F FD 43         mov [d], b
0844   08A1 FD 7D         dec b
0845   08A3             ; switch(*format_p){ 
0846   08A3             _switch13_expr:
0847   08A3 FA FD FF      lea d, [bp + -3] ; $format_p
0848   08A6 2A            mov b, [d]
0849   08A7 74            mov d, b
0850   08A8 32            mov bl, [d]
0851   08A9 A7 00         mov bh, 0
0852   08AB             _switch13_comparisons:
0853   08AB C1 6C         cmp bl, $6c
0854   08AD C6 D9 08      je _switch13_case0
0855   08B0 C1 4C         cmp bl, $4c
0856   08B2 C6 D9 08      je _switch13_case1
0857   08B5 C1 64         cmp bl, $64
0858   08B7 C6 C7 09      je _switch13_case2
0859   08BA C1 69         cmp bl, $69
0860   08BC C6 C7 09      je _switch13_case3
0861   08BF C1 75         cmp bl, $75
0862   08C1 C6 EB 09      je _switch13_case4
0863   08C4 C1 78         cmp bl, $78
0864   08C6 C6 0F 0A      je _switch13_case5
0865   08C9 C1 63         cmp bl, $63
0866   08CB C6 2D 0A      je _switch13_case6
0867   08CE C1 73         cmp bl, $73
0868   08D0 C6 4C 0A      je _switch13_case7
0869   08D3 0A 6B 0A      jmp _switch13_default
0870   08D6 0A 77 0A      jmp _switch13_exit
0871   08D9             _switch13_case0:
0872   08D9             _switch13_case1:
0873   08D9             ; format_p++; 
0874   08D9 FA FD FF      lea d, [bp + -3] ; $format_p
0875   08DC 2A            mov b, [d]
0876   08DD FD 77         inc b
0877   08DF FA FD FF      lea d, [bp + -3] ; $format_p
0878   08E2 FD 43         mov [d], b
0879   08E4 FD 7D         dec b
0880   08E6             ; if(*format_p == 'd' || *format_p == 'i') 
0881   08E6             _if14_cond:
0882   08E6 FA FD FF      lea d, [bp + -3] ; $format_p
0883   08E9 2A            mov b, [d]
0884   08EA 74            mov d, b
0885   08EB 32            mov bl, [d]
0886   08EC A7 00         mov bh, 0
0887   08EE             ; --- START RELATIONAL
0888   08EE D7            push a
0889   08EF 11            mov a, b
0890   08F0 26 64 00      mov b, $64
0891   08F3 B0            cmp a, b
0892   08F4 FD 71         seq ; ==
0893   08F6 E4            pop a
0894   08F7             ; --- END RELATIONAL
0895   08F7             ; --- START LOGICAL OR
0896   08F7 D7            push a
0897   08F8 11            mov a, b
0898   08F9 FA FD FF      lea d, [bp + -3] ; $format_p
0899   08FC 2A            mov b, [d]
0900   08FD 74            mov d, b
0901   08FE 32            mov bl, [d]
0902   08FF A7 00         mov bh, 0
0903   0901             ; --- START RELATIONAL
0904   0901 D7            push a
0905   0902 11            mov a, b
0906   0903 26 69 00      mov b, $69
0907   0906 B0            cmp a, b
0908   0907 FD 71         seq ; ==
0909   0909 E4            pop a
0910   090A             ; --- END RELATIONAL
0911   090A FD A8         sor a, b ; ||
0912   090C E4            pop a
0913   090D             ; --- END LOGICAL OR
0914   090D C0 00 00      cmp b, 0
0915   0910 C6 35 09      je _if14_else
0916   0913             _if14_true:
0917   0913             ; print_signed_long(*(long *)p); 
0918   0913 FA FF FF      lea d, [bp + -1] ; $p
0919   0916 2A            mov b, [d]
0920   0917 AB            snex b
0921   0918 FD 39         mov c, b
0922   091A 74            mov d, b
0923   091B 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0924   091E FD 39         mov c, b ; And place it into C
0925   0920 2A            mov b, [d] ; Lower Word in B
0926   0921 FD 79         mov g, b
0927   0923 28            mov b, c
0928   0924 FD AB         swp b
0929   0926 D8            push b
0930   0927 FD 27         mov b, g
0931   0929 FD AB         swp b
0932   092B D8            push b
0933   092C 07 97 12      call print_signed_long
0934   092F 51 04 00      add sp, 4
0935   0932 0A B2 09      jmp _if14_exit
0936   0935             _if14_else:
0937   0935             ; if(*format_p == 'u') 
0938   0935             _if15_cond:
0939   0935 FA FD FF      lea d, [bp + -3] ; $format_p
0940   0938 2A            mov b, [d]
0941   0939 74            mov d, b
0942   093A 32            mov bl, [d]
0943   093B A7 00         mov bh, 0
0944   093D             ; --- START RELATIONAL
0945   093D D7            push a
0946   093E 11            mov a, b
0947   093F 26 75 00      mov b, $75
0948   0942 B0            cmp a, b
0949   0943 FD 71         seq ; ==
0950   0945 E4            pop a
0951   0946             ; --- END RELATIONAL
0952   0946 C0 00 00      cmp b, 0
0953   0949 C6 70 09      je _if15_else
0954   094C             _if15_true:
0955   094C             ; print_unsigned_long(*(unsigned long *)p); 
0956   094C FA FF FF      lea d, [bp + -1] ; $p
0957   094F 2A            mov b, [d]
0958   0950 A7 00         mov bh, 0
0959   0952 38 00 00      mov c, 0
0960   0955 74            mov d, b
0961   0956 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0962   0959 FD 39         mov c, b ; And place it into C
0963   095B 2A            mov b, [d] ; Lower Word in B
0964   095C FD 79         mov g, b
0965   095E 28            mov b, c
0966   095F FD AB         swp b
0967   0961 D8            push b
0968   0962 FD 27         mov b, g
0969   0964 FD AB         swp b
0970   0966 D8            push b
0971   0967 07 D7 15      call print_unsigned_long
0972   096A 51 04 00      add sp, 4
0973   096D 0A B2 09      jmp _if15_exit
0974   0970             _if15_else:
0975   0970             ; if(*format_p == 'x') 
0976   0970             _if16_cond:
0977   0970 FA FD FF      lea d, [bp + -3] ; $format_p
0978   0973 2A            mov b, [d]
0979   0974 74            mov d, b
0980   0975 32            mov bl, [d]
0981   0976 A7 00         mov bh, 0
0982   0978             ; --- START RELATIONAL
0983   0978 D7            push a
0984   0979 11            mov a, b
0985   097A 26 78 00      mov b, $78
0986   097D B0            cmp a, b
0987   097E FD 71         seq ; ==
0988   0980 E4            pop a
0989   0981             ; --- END RELATIONAL
0990   0981 C0 00 00      cmp b, 0
0991   0984 C6 A6 09      je _if16_else
0992   0987             _if16_true:
0993   0987             ; printx32(*(long int *)p); 
0994   0987 FA FF FF      lea d, [bp + -1] ; $p
0995   098A 2A            mov b, [d]
0996   098B 74            mov d, b
0997   098C 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0998   098F FD 39         mov c, b ; And place it into C
0999   0991 2A            mov b, [d] ; Lower Word in B
1000   0992 FD 79         mov g, b
1001   0994 28            mov b, c
1002   0995 FD AB         swp b
1003   0997 D8            push b
1004   0998 FD 27         mov b, g
1005   099A FD AB         swp b
1006   099C D8            push b
1007   099D 07 0C 10      call printx32
1008   09A0 51 04 00      add sp, 4
1009   09A3 0A B2 09      jmp _if16_exit
1010   09A6             _if16_else:
1011   09A6             ; err("Unexpected format in printf."); 
1012   09A6 26 F5 20      mov b, _s4 ; "Unexpected format in printf."
1013   09A9 FD AB         swp b
1014   09AB D8            push b
1015   09AC 07 FA 0F      call err
1016   09AF 51 02 00      add sp, 2
1017   09B2             _if16_exit:
1018   09B2             _if15_exit:
1019   09B2             _if14_exit:
1020   09B2             ; p = p + 4; 
1021   09B2 FA FF FF      lea d, [bp + -1] ; $p
1022   09B5 DA            push d
1023   09B6 FA FF FF      lea d, [bp + -1] ; $p
1024   09B9 2A            mov b, [d]
1025   09BA             ; --- START TERMS
1026   09BA D7            push a
1027   09BB 11            mov a, b
1028   09BC 26 04 00      mov b, $4
1029   09BF 56            add b, a
1030   09C0 E4            pop a
1031   09C1             ; --- END TERMS
1032   09C1 E7            pop d
1033   09C2 FD 43         mov [d], b
1034   09C4             ; break; 
1035   09C4 0A 77 0A      jmp _switch13_exit ; case break
1036   09C7             _switch13_case2:
1037   09C7             _switch13_case3:
1038   09C7             ; print_signed(*(int*)p); 
1039   09C7 FA FF FF      lea d, [bp + -1] ; $p
1040   09CA 2A            mov b, [d]
1041   09CB 74            mov d, b
1042   09CC 2A            mov b, [d]
1043   09CD FD AB         swp b
1044   09CF D8            push b
1045   09D0 07 A0 11      call print_signed
1046   09D3 51 02 00      add sp, 2
1047   09D6             ; p = p + 2; 
1048   09D6 FA FF FF      lea d, [bp + -1] ; $p
1049   09D9 DA            push d
1050   09DA FA FF FF      lea d, [bp + -1] ; $p
1051   09DD 2A            mov b, [d]
1052   09DE             ; --- START TERMS
1053   09DE D7            push a
1054   09DF 11            mov a, b
1055   09E0 26 02 00      mov b, $2
1056   09E3 56            add b, a
1057   09E4 E4            pop a
1058   09E5             ; --- END TERMS
1059   09E5 E7            pop d
1060   09E6 FD 43         mov [d], b
1061   09E8             ; break; 
1062   09E8 0A 77 0A      jmp _switch13_exit ; case break
1063   09EB             _switch13_case4:
1064   09EB             ; print_unsigned(*(unsigned int*)p); 
1065   09EB FA FF FF      lea d, [bp + -1] ; $p
1066   09EE 2A            mov b, [d]
1067   09EF 74            mov d, b
1068   09F0 2A            mov b, [d]
1069   09F1 FD AB         swp b
1070   09F3 D8            push b
1071   09F4 07 DC 18      call print_unsigned
1072   09F7 51 02 00      add sp, 2
1073   09FA             ; p = p + 2; 
1074   09FA FA FF FF      lea d, [bp + -1] ; $p
1075   09FD DA            push d
1076   09FE FA FF FF      lea d, [bp + -1] ; $p
1077   0A01 2A            mov b, [d]
1078   0A02             ; --- START TERMS
1079   0A02 D7            push a
1080   0A03 11            mov a, b
1081   0A04 26 02 00      mov b, $2
1082   0A07 56            add b, a
1083   0A08 E4            pop a
1084   0A09             ; --- END TERMS
1085   0A09 E7            pop d
1086   0A0A FD 43         mov [d], b
1087   0A0C             ; break; 
1088   0A0C 0A 77 0A      jmp _switch13_exit ; case break
1089   0A0F             _switch13_case5:
1090   0A0F             
1091   0A0F             ; --- BEGIN INLINE ASM SEGMENT
1092   0A0F FA FF FF      lea d, [bp + -1] ; $p
1093   0A12 FD 2A         mov d, [d]
1094   0A14 2A            mov b, [d]
1095   0A15 07 A1 1E      call print_u16x
1096   0A18             ; --- END INLINE ASM SEGMENT
1097   0A18             
1098   0A18             ; p = p + 2; 
1099   0A18 FA FF FF      lea d, [bp + -1] ; $p
1100   0A1B DA            push d
1101   0A1C FA FF FF      lea d, [bp + -1] ; $p
1102   0A1F 2A            mov b, [d]
1103   0A20             ; --- START TERMS
1104   0A20 D7            push a
1105   0A21 11            mov a, b
1106   0A22 26 02 00      mov b, $2
1107   0A25 56            add b, a
1108   0A26 E4            pop a
1109   0A27             ; --- END TERMS
1110   0A27 E7            pop d
1111   0A28 FD 43         mov [d], b
1112   0A2A             ; break; 
1113   0A2A 0A 77 0A      jmp _switch13_exit ; case break
1114   0A2D             _switch13_case6:
1115   0A2D             
1116   0A2D             ; --- BEGIN INLINE ASM SEGMENT
1117   0A2D FA FF FF      lea d, [bp + -1] ; $p
1118   0A30 FD 2A         mov d, [d]
1119   0A32 1E            mov al, [d]
1120   0A33 23            mov ah, al
1121   0A34 07 FF 1C      call _putchar
1122   0A37             ; --- END INLINE ASM SEGMENT
1123   0A37             
1124   0A37             ; p = p + 1; 
1125   0A37 FA FF FF      lea d, [bp + -1] ; $p
1126   0A3A DA            push d
1127   0A3B FA FF FF      lea d, [bp + -1] ; $p
1128   0A3E 2A            mov b, [d]
1129   0A3F             ; --- START TERMS
1130   0A3F D7            push a
1131   0A40 11            mov a, b
1132   0A41 26 01 00      mov b, $1
1133   0A44 56            add b, a
1134   0A45 E4            pop a
1135   0A46             ; --- END TERMS
1136   0A46 E7            pop d
1137   0A47 FD 43         mov [d], b
1138   0A49             ; break; 
1139   0A49 0A 77 0A      jmp _switch13_exit ; case break
1140   0A4C             _switch13_case7:
1141   0A4C             
1142   0A4C             ; --- BEGIN INLINE ASM SEGMENT
1143   0A4C FA FF FF      lea d, [bp + -1] ; $p
1144   0A4F FD 2A         mov d, [d]
1145   0A51 FD 2A         mov d, [d]
1146   0A53 07 49 1E      call _puts
1147   0A56             ; --- END INLINE ASM SEGMENT
1148   0A56             
1149   0A56             ; p = p + 2; 
1150   0A56 FA FF FF      lea d, [bp + -1] ; $p
1151   0A59 DA            push d
1152   0A5A FA FF FF      lea d, [bp + -1] ; $p
1153   0A5D 2A            mov b, [d]
1154   0A5E             ; --- START TERMS
1155   0A5E D7            push a
1156   0A5F 11            mov a, b
1157   0A60 26 02 00      mov b, $2
1158   0A63 56            add b, a
1159   0A64 E4            pop a
1160   0A65             ; --- END TERMS
1161   0A65 E7            pop d
1162   0A66 FD 43         mov [d], b
1163   0A68             ; break; 
1164   0A68 0A 77 0A      jmp _switch13_exit ; case break
1165   0A6B             _switch13_default:
1166   0A6B             ; print("Error: Unknown argument type.\n"); 
1167   0A6B 26 12 21      mov b, _s5 ; "Error: Unknown argument type.\n"
1168   0A6E FD AB         swp b
1169   0A70 D8            push b
1170   0A71 07 50 1B      call print
1171   0A74 51 02 00      add sp, 2
1172   0A77             _switch13_exit:
1173   0A77             ; format_p++; 
1174   0A77 FA FD FF      lea d, [bp + -3] ; $format_p
1175   0A7A 2A            mov b, [d]
1176   0A7B FD 77         inc b
1177   0A7D FA FD FF      lea d, [bp + -3] ; $format_p
1178   0A80 FD 43         mov [d], b
1179   0A82 FD 7D         dec b
1180   0A84 0A A3 0A      jmp _if12_exit
1181   0A87             _if12_else:
1182   0A87             ; putchar(*format_p); 
1183   0A87 FA FD FF      lea d, [bp + -3] ; $format_p
1184   0A8A 2A            mov b, [d]
1185   0A8B 74            mov d, b
1186   0A8C 32            mov bl, [d]
1187   0A8D A7 00         mov bh, 0
1188   0A8F DD            push bl
1189   0A90 07 08 1B      call putchar
1190   0A93 51 01 00      add sp, 1
1191   0A96             ; format_p++; 
1192   0A96 FA FD FF      lea d, [bp + -3] ; $format_p
1193   0A99 2A            mov b, [d]
1194   0A9A FD 77         inc b
1195   0A9C FA FD FF      lea d, [bp + -3] ; $format_p
1196   0A9F FD 43         mov [d], b
1197   0AA1 FD 7D         dec b
1198   0AA3             _if12_exit:
1199   0AA3             _if11_exit:
1200   0AA3             _for10_update:
1201   0AA3 0A 66 08      jmp _for10_cond
1202   0AA6             _for10_exit:
1203   0AA6 F9            leave
1204   0AA7 09            ret
1205   0AA8             
1206   0AA8             scanf:
1207   0AA8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1208   0AAB             ; char *p, *format_p; 
1209   0AAB 52 02 00      sub sp, 2
1210   0AAE 52 02 00      sub sp, 2
1211   0AB1             ; char c; 
1212   0AB1 52 01 00      sub sp, 1
1213   0AB4             ; int i; 
1214   0AB4 52 02 00      sub sp, 2
1215   0AB7             ; char input_string[  512                    ]; 
1216   0AB7 52 00 02      sub sp, 512
1217   0ABA             ; format_p = format; 
1218   0ABA FA FD FF      lea d, [bp + -3] ; $format_p
1219   0ABD DA            push d
1220   0ABE FA 05 00      lea d, [bp + 5] ; $format
1221   0AC1 2A            mov b, [d]
1222   0AC2 E7            pop d
1223   0AC3 FD 43         mov [d], b
1224   0AC5             ; p = &format + 2; 
1225   0AC5 FA FF FF      lea d, [bp + -1] ; $p
1226   0AC8 DA            push d
1227   0AC9 FA 05 00      lea d, [bp + 5] ; $format
1228   0ACC 2D            mov b, d
1229   0ACD             ; --- START TERMS
1230   0ACD D7            push a
1231   0ACE 11            mov a, b
1232   0ACF 26 02 00      mov b, $2
1233   0AD2 56            add b, a
1234   0AD3 E4            pop a
1235   0AD4             ; --- END TERMS
1236   0AD4 E7            pop d
1237   0AD5 FD 43         mov [d], b
1238   0AD7             ; for(;;){ 
1239   0AD7             _for17_init:
1240   0AD7             _for17_cond:
1241   0AD7             _for17_block:
1242   0AD7             ; if(!*format_p) break; 
1243   0AD7             _if18_cond:
1244   0AD7 FA FD FF      lea d, [bp + -3] ; $format_p
1245   0ADA 2A            mov b, [d]
1246   0ADB 74            mov d, b
1247   0ADC 32            mov bl, [d]
1248   0ADD A7 00         mov bh, 0
1249   0ADF C0 00 00      cmp b, 0
1250   0AE2 FD 71         seq ; !
1251   0AE4 C0 00 00      cmp b, 0
1252   0AE7 C6 F0 0A      je _if18_else
1253   0AEA             _if18_true:
1254   0AEA             ; break; 
1255   0AEA 0A F1 0C      jmp _for17_exit ; for break
1256   0AED 0A EE 0C      jmp _if18_exit
1257   0AF0             _if18_else:
1258   0AF0             ; if(*format_p == '%'){ 
1259   0AF0             _if19_cond:
1260   0AF0 FA FD FF      lea d, [bp + -3] ; $format_p
1261   0AF3 2A            mov b, [d]
1262   0AF4 74            mov d, b
1263   0AF5 32            mov bl, [d]
1264   0AF6 A7 00         mov bh, 0
1265   0AF8             ; --- START RELATIONAL
1266   0AF8 D7            push a
1267   0AF9 11            mov a, b
1268   0AFA 26 25 00      mov b, $25
1269   0AFD B0            cmp a, b
1270   0AFE FD 71         seq ; ==
1271   0B00 E4            pop a
1272   0B01             ; --- END RELATIONAL
1273   0B01 C0 00 00      cmp b, 0
1274   0B04 C6 D2 0C      je _if19_else
1275   0B07             _if19_true:
1276   0B07             ; format_p++; 
1277   0B07 FA FD FF      lea d, [bp + -3] ; $format_p
1278   0B0A 2A            mov b, [d]
1279   0B0B FD 77         inc b
1280   0B0D FA FD FF      lea d, [bp + -3] ; $format_p
1281   0B10 FD 43         mov [d], b
1282   0B12 FD 7D         dec b
1283   0B14             ; switch(*format_p){ 
1284   0B14             _switch20_expr:
1285   0B14 FA FD FF      lea d, [bp + -3] ; $format_p
1286   0B17 2A            mov b, [d]
1287   0B18 74            mov d, b
1288   0B19 32            mov bl, [d]
1289   0B1A A7 00         mov bh, 0
1290   0B1C             _switch20_comparisons:
1291   0B1C C1 6C         cmp bl, $6c
1292   0B1E C6 4A 0B      je _switch20_case0
1293   0B21 C1 4C         cmp bl, $4c
1294   0B23 C6 4A 0B      je _switch20_case1
1295   0B26 C1 64         cmp bl, $64
1296   0B28 C6 DC 0B      je _switch20_case2
1297   0B2B C1 69         cmp bl, $69
1298   0B2D C6 DC 0B      je _switch20_case3
1299   0B30 C1 75         cmp bl, $75
1300   0B32 C6 09 0C      je _switch20_case4
1301   0B35 C1 78         cmp bl, $78
1302   0B37 C6 36 0C      je _switch20_case5
1303   0B3A C1 63         cmp bl, $63
1304   0B3C C6 4B 0C      je _switch20_case6
1305   0B3F C1 73         cmp bl, $73
1306   0B41 C6 7E 0C      je _switch20_case7
1307   0B44 0A B6 0C      jmp _switch20_default
1308   0B47 0A C2 0C      jmp _switch20_exit
1309   0B4A             _switch20_case0:
1310   0B4A             _switch20_case1:
1311   0B4A             ; format_p++; 
1312   0B4A FA FD FF      lea d, [bp + -3] ; $format_p
1313   0B4D 2A            mov b, [d]
1314   0B4E FD 77         inc b
1315   0B50 FA FD FF      lea d, [bp + -3] ; $format_p
1316   0B53 FD 43         mov [d], b
1317   0B55 FD 7D         dec b
1318   0B57             ; if(*format_p == 'd' || *format_p == 'i'); 
1319   0B57             _if21_cond:
1320   0B57 FA FD FF      lea d, [bp + -3] ; $format_p
1321   0B5A 2A            mov b, [d]
1322   0B5B 74            mov d, b
1323   0B5C 32            mov bl, [d]
1324   0B5D A7 00         mov bh, 0
1325   0B5F             ; --- START RELATIONAL
1326   0B5F D7            push a
1327   0B60 11            mov a, b
1328   0B61 26 64 00      mov b, $64
1329   0B64 B0            cmp a, b
1330   0B65 FD 71         seq ; ==
1331   0B67 E4            pop a
1332   0B68             ; --- END RELATIONAL
1333   0B68             ; --- START LOGICAL OR
1334   0B68 D7            push a
1335   0B69 11            mov a, b
1336   0B6A FA FD FF      lea d, [bp + -3] ; $format_p
1337   0B6D 2A            mov b, [d]
1338   0B6E 74            mov d, b
1339   0B6F 32            mov bl, [d]
1340   0B70 A7 00         mov bh, 0
1341   0B72             ; --- START RELATIONAL
1342   0B72 D7            push a
1343   0B73 11            mov a, b
1344   0B74 26 69 00      mov b, $69
1345   0B77 B0            cmp a, b
1346   0B78 FD 71         seq ; ==
1347   0B7A E4            pop a
1348   0B7B             ; --- END RELATIONAL
1349   0B7B FD A8         sor a, b ; ||
1350   0B7D E4            pop a
1351   0B7E             ; --- END LOGICAL OR
1352   0B7E C0 00 00      cmp b, 0
1353   0B81 C6 87 0B      je _if21_else
1354   0B84             _if21_true:
1355   0B84             ; ; 
1356   0B84 0A C7 0B      jmp _if21_exit
1357   0B87             _if21_else:
1358   0B87             ; if(*format_p == 'u'); 
1359   0B87             _if22_cond:
1360   0B87 FA FD FF      lea d, [bp + -3] ; $format_p
1361   0B8A 2A            mov b, [d]
1362   0B8B 74            mov d, b
1363   0B8C 32            mov bl, [d]
1364   0B8D A7 00         mov bh, 0
1365   0B8F             ; --- START RELATIONAL
1366   0B8F D7            push a
1367   0B90 11            mov a, b
1368   0B91 26 75 00      mov b, $75
1369   0B94 B0            cmp a, b
1370   0B95 FD 71         seq ; ==
1371   0B97 E4            pop a
1372   0B98             ; --- END RELATIONAL
1373   0B98 C0 00 00      cmp b, 0
1374   0B9B C6 A1 0B      je _if22_else
1375   0B9E             _if22_true:
1376   0B9E             ; ; 
1377   0B9E 0A C7 0B      jmp _if22_exit
1378   0BA1             _if22_else:
1379   0BA1             ; if(*format_p == 'x'); 
1380   0BA1             _if23_cond:
1381   0BA1 FA FD FF      lea d, [bp + -3] ; $format_p
1382   0BA4 2A            mov b, [d]
1383   0BA5 74            mov d, b
1384   0BA6 32            mov bl, [d]
1385   0BA7 A7 00         mov bh, 0
1386   0BA9             ; --- START RELATIONAL
1387   0BA9 D7            push a
1388   0BAA 11            mov a, b
1389   0BAB 26 78 00      mov b, $78
1390   0BAE B0            cmp a, b
1391   0BAF FD 71         seq ; ==
1392   0BB1 E4            pop a
1393   0BB2             ; --- END RELATIONAL
1394   0BB2 C0 00 00      cmp b, 0
1395   0BB5 C6 BB 0B      je _if23_else
1396   0BB8             _if23_true:
1397   0BB8             ; ; 
1398   0BB8 0A C7 0B      jmp _if23_exit
1399   0BBB             _if23_else:
1400   0BBB             ; err("Unexpected format in printf."); 
1401   0BBB 26 F5 20      mov b, _s4 ; "Unexpected format in printf."
1402   0BBE FD AB         swp b
1403   0BC0 D8            push b
1404   0BC1 07 FA 0F      call err
1405   0BC4 51 02 00      add sp, 2
1406   0BC7             _if23_exit:
1407   0BC7             _if22_exit:
1408   0BC7             _if21_exit:
1409   0BC7             ; p = p + 4; 
1410   0BC7 FA FF FF      lea d, [bp + -1] ; $p
1411   0BCA DA            push d
1412   0BCB FA FF FF      lea d, [bp + -1] ; $p
1413   0BCE 2A            mov b, [d]
1414   0BCF             ; --- START TERMS
1415   0BCF D7            push a
1416   0BD0 11            mov a, b
1417   0BD1 26 04 00      mov b, $4
1418   0BD4 56            add b, a
1419   0BD5 E4            pop a
1420   0BD6             ; --- END TERMS
1421   0BD6 E7            pop d
1422   0BD7 FD 43         mov [d], b
1423   0BD9             ; break; 
1424   0BD9 0A C2 0C      jmp _switch20_exit ; case break
1425   0BDC             _switch20_case2:
1426   0BDC             _switch20_case3:
1427   0BDC             ; i = scann(); 
1428   0BDC FA FA FF      lea d, [bp + -6] ; $i
1429   0BDF DA            push d
1430   0BE0 07 2B 1B      call scann
1431   0BE3 E7            pop d
1432   0BE4 FD 43         mov [d], b
1433   0BE6             ; **(int **)p = i; 
1434   0BE6 FA FF FF      lea d, [bp + -1] ; $p
1435   0BE9 2A            mov b, [d]
1436   0BEA 74            mov d, b
1437   0BEB 2A            mov b, [d]
1438   0BEC D8            push b
1439   0BED FA FA FF      lea d, [bp + -6] ; $i
1440   0BF0 2A            mov b, [d]
1441   0BF1 E7            pop d
1442   0BF2 FD 43         mov [d], b
1443   0BF4             ; p = p + 2; 
1444   0BF4 FA FF FF      lea d, [bp + -1] ; $p
1445   0BF7 DA            push d
1446   0BF8 FA FF FF      lea d, [bp + -1] ; $p
1447   0BFB 2A            mov b, [d]
1448   0BFC             ; --- START TERMS
1449   0BFC D7            push a
1450   0BFD 11            mov a, b
1451   0BFE 26 02 00      mov b, $2
1452   0C01 56            add b, a
1453   0C02 E4            pop a
1454   0C03             ; --- END TERMS
1455   0C03 E7            pop d
1456   0C04 FD 43         mov [d], b
1457   0C06             ; break; 
1458   0C06 0A C2 0C      jmp _switch20_exit ; case break
1459   0C09             _switch20_case4:
1460   0C09             ; i = scann(); 
1461   0C09 FA FA FF      lea d, [bp + -6] ; $i
1462   0C0C DA            push d
1463   0C0D 07 2B 1B      call scann
1464   0C10 E7            pop d
1465   0C11 FD 43         mov [d], b
1466   0C13             ; **(int **)p = i; 
1467   0C13 FA FF FF      lea d, [bp + -1] ; $p
1468   0C16 2A            mov b, [d]
1469   0C17 74            mov d, b
1470   0C18 2A            mov b, [d]
1471   0C19 D8            push b
1472   0C1A FA FA FF      lea d, [bp + -6] ; $i
1473   0C1D 2A            mov b, [d]
1474   0C1E E7            pop d
1475   0C1F FD 43         mov [d], b
1476   0C21             ; p = p + 2; 
1477   0C21 FA FF FF      lea d, [bp + -1] ; $p
1478   0C24 DA            push d
1479   0C25 FA FF FF      lea d, [bp + -1] ; $p
1480   0C28 2A            mov b, [d]
1481   0C29             ; --- START TERMS
1482   0C29 D7            push a
1483   0C2A 11            mov a, b
1484   0C2B 26 02 00      mov b, $2
1485   0C2E 56            add b, a
1486   0C2F E4            pop a
1487   0C30             ; --- END TERMS
1488   0C30 E7            pop d
1489   0C31 FD 43         mov [d], b
1490   0C33             ; break; 
1491   0C33 0A C2 0C      jmp _switch20_exit ; case break
1492   0C36             _switch20_case5:
1493   0C36             ; p = p + 2; 
1494   0C36 FA FF FF      lea d, [bp + -1] ; $p
1495   0C39 DA            push d
1496   0C3A FA FF FF      lea d, [bp + -1] ; $p
1497   0C3D 2A            mov b, [d]
1498   0C3E             ; --- START TERMS
1499   0C3E D7            push a
1500   0C3F 11            mov a, b
1501   0C40 26 02 00      mov b, $2
1502   0C43 56            add b, a
1503   0C44 E4            pop a
1504   0C45             ; --- END TERMS
1505   0C45 E7            pop d
1506   0C46 FD 43         mov [d], b
1507   0C48             ; break; 
1508   0C48 0A C2 0C      jmp _switch20_exit ; case break
1509   0C4B             _switch20_case6:
1510   0C4B             ; c = getchar(); 
1511   0C4B FA FC FF      lea d, [bp + -4] ; $c
1512   0C4E DA            push d
1513   0C4F 07 15 1B      call getchar
1514   0C52 E7            pop d
1515   0C53 FD 3E         mov [d], bl
1516   0C55             ; **(char **)p = *(char *)c; 
1517   0C55 FA FF FF      lea d, [bp + -1] ; $p
1518   0C58 2A            mov b, [d]
1519   0C59 74            mov d, b
1520   0C5A 2A            mov b, [d]
1521   0C5B D8            push b
1522   0C5C FA FC FF      lea d, [bp + -4] ; $c
1523   0C5F 32            mov bl, [d]
1524   0C60 A7 00         mov bh, 0
1525   0C62 74            mov d, b
1526   0C63 32            mov bl, [d]
1527   0C64 A7 00         mov bh, 0
1528   0C66 E7            pop d
1529   0C67 FD 43         mov [d], b
1530   0C69             ; p = p + 1; 
1531   0C69 FA FF FF      lea d, [bp + -1] ; $p
1532   0C6C DA            push d
1533   0C6D FA FF FF      lea d, [bp + -1] ; $p
1534   0C70 2A            mov b, [d]
1535   0C71             ; --- START TERMS
1536   0C71 D7            push a
1537   0C72 11            mov a, b
1538   0C73 26 01 00      mov b, $1
1539   0C76 56            add b, a
1540   0C77 E4            pop a
1541   0C78             ; --- END TERMS
1542   0C78 E7            pop d
1543   0C79 FD 43         mov [d], b
1544   0C7B             ; break; 
1545   0C7B 0A C2 0C      jmp _switch20_exit ; case break
1546   0C7E             _switch20_case7:
1547   0C7E             ; gets(input_string); 
1548   0C7E FA FA FD      lea d, [bp + -518] ; $input_string
1549   0C81 2D            mov b, d
1550   0C82 FD AB         swp b
1551   0C84 D8            push b
1552   0C85 07 86 11      call gets
1553   0C88 51 02 00      add sp, 2
1554   0C8B             ; strcpy(*(char **)p, input_string); 
1555   0C8B FA FA FD      lea d, [bp + -518] ; $input_string
1556   0C8E 2D            mov b, d
1557   0C8F FD AB         swp b
1558   0C91 D8            push b
1559   0C92 FA FF FF      lea d, [bp + -1] ; $p
1560   0C95 2A            mov b, [d]
1561   0C96 74            mov d, b
1562   0C97 2A            mov b, [d]
1563   0C98 FD AB         swp b
1564   0C9A D8            push b
1565   0C9B 07 40 04      call strcpy
1566   0C9E 51 04 00      add sp, 4
1567   0CA1             ; p = p + 2; 
1568   0CA1 FA FF FF      lea d, [bp + -1] ; $p
1569   0CA4 DA            push d
1570   0CA5 FA FF FF      lea d, [bp + -1] ; $p
1571   0CA8 2A            mov b, [d]
1572   0CA9             ; --- START TERMS
1573   0CA9 D7            push a
1574   0CAA 11            mov a, b
1575   0CAB 26 02 00      mov b, $2
1576   0CAE 56            add b, a
1577   0CAF E4            pop a
1578   0CB0             ; --- END TERMS
1579   0CB0 E7            pop d
1580   0CB1 FD 43         mov [d], b
1581   0CB3             ; break; 
1582   0CB3 0A C2 0C      jmp _switch20_exit ; case break
1583   0CB6             _switch20_default:
1584   0CB6             ; print("Error: Unknown argument type.\n"); 
1585   0CB6 26 12 21      mov b, _s5 ; "Error: Unknown argument type.\n"
1586   0CB9 FD AB         swp b
1587   0CBB D8            push b
1588   0CBC 07 50 1B      call print
1589   0CBF 51 02 00      add sp, 2
1590   0CC2             _switch20_exit:
1591   0CC2             ; format_p++; 
1592   0CC2 FA FD FF      lea d, [bp + -3] ; $format_p
1593   0CC5 2A            mov b, [d]
1594   0CC6 FD 77         inc b
1595   0CC8 FA FD FF      lea d, [bp + -3] ; $format_p
1596   0CCB FD 43         mov [d], b
1597   0CCD FD 7D         dec b
1598   0CCF 0A EE 0C      jmp _if19_exit
1599   0CD2             _if19_else:
1600   0CD2             ; putchar(*format_p); 
1601   0CD2 FA FD FF      lea d, [bp + -3] ; $format_p
1602   0CD5 2A            mov b, [d]
1603   0CD6 74            mov d, b
1604   0CD7 32            mov bl, [d]
1605   0CD8 A7 00         mov bh, 0
1606   0CDA DD            push bl
1607   0CDB 07 08 1B      call putchar
1608   0CDE 51 01 00      add sp, 1
1609   0CE1             ; format_p++; 
1610   0CE1 FA FD FF      lea d, [bp + -3] ; $format_p
1611   0CE4 2A            mov b, [d]
1612   0CE5 FD 77         inc b
1613   0CE7 FA FD FF      lea d, [bp + -3] ; $format_p
1614   0CEA FD 43         mov [d], b
1615   0CEC FD 7D         dec b
1616   0CEE             _if19_exit:
1617   0CEE             _if18_exit:
1618   0CEE             _for17_update:
1619   0CEE 0A D7 0A      jmp _for17_cond
1620   0CF1             _for17_exit:
1621   0CF1 F9            leave
1622   0CF2 09            ret
1623   0CF3             
1624   0CF3             sprintf:
1625   0CF3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1626   0CF6             ; char *p, *format_p; 
1627   0CF6 52 02 00      sub sp, 2
1628   0CF9 52 02 00      sub sp, 2
1629   0CFC             ; char *sp; 
1630   0CFC 52 02 00      sub sp, 2
1631   0CFF             ; sp = dest; 
1632   0CFF FA FB FF      lea d, [bp + -5] ; $sp
1633   0D02 DA            push d
1634   0D03 FA 05 00      lea d, [bp + 5] ; $dest
1635   0D06 2A            mov b, [d]
1636   0D07 E7            pop d
1637   0D08 FD 43         mov [d], b
1638   0D0A             ; format_p = format; 
1639   0D0A FA FD FF      lea d, [bp + -3] ; $format_p
1640   0D0D DA            push d
1641   0D0E FA 07 00      lea d, [bp + 7] ; $format
1642   0D11 2A            mov b, [d]
1643   0D12 E7            pop d
1644   0D13 FD 43         mov [d], b
1645   0D15             ; p = &format + 2; 
1646   0D15 FA FF FF      lea d, [bp + -1] ; $p
1647   0D18 DA            push d
1648   0D19 FA 07 00      lea d, [bp + 7] ; $format
1649   0D1C 2D            mov b, d
1650   0D1D             ; --- START TERMS
1651   0D1D D7            push a
1652   0D1E 11            mov a, b
1653   0D1F 26 02 00      mov b, $2
1654   0D22 56            add b, a
1655   0D23 E4            pop a
1656   0D24             ; --- END TERMS
1657   0D24 E7            pop d
1658   0D25 FD 43         mov [d], b
1659   0D27             ; for(;;){ 
1660   0D27             _for24_init:
1661   0D27             _for24_cond:
1662   0D27             _for24_block:
1663   0D27             ; if(!*format_p) break; 
1664   0D27             _if25_cond:
1665   0D27 FA FD FF      lea d, [bp + -3] ; $format_p
1666   0D2A 2A            mov b, [d]
1667   0D2B 74            mov d, b
1668   0D2C 32            mov bl, [d]
1669   0D2D A7 00         mov bh, 0
1670   0D2F C0 00 00      cmp b, 0
1671   0D32 FD 71         seq ; !
1672   0D34 C0 00 00      cmp b, 0
1673   0D37 C6 40 0D      je _if25_else
1674   0D3A             _if25_true:
1675   0D3A             ; break; 
1676   0D3A 0A E0 0F      jmp _for24_exit ; for break
1677   0D3D 0A DD 0F      jmp _if25_exit
1678   0D40             _if25_else:
1679   0D40             ; if(*format_p == '%'){ 
1680   0D40             _if26_cond:
1681   0D40 FA FD FF      lea d, [bp + -3] ; $format_p
1682   0D43 2A            mov b, [d]
1683   0D44 74            mov d, b
1684   0D45 32            mov bl, [d]
1685   0D46 A7 00         mov bh, 0
1686   0D48             ; --- START RELATIONAL
1687   0D48 D7            push a
1688   0D49 11            mov a, b
1689   0D4A 26 25 00      mov b, $25
1690   0D4D B0            cmp a, b
1691   0D4E FD 71         seq ; ==
1692   0D50 E4            pop a
1693   0D51             ; --- END RELATIONAL
1694   0D51 C0 00 00      cmp b, 0
1695   0D54 C6 BB 0F      je _if26_else
1696   0D57             _if26_true:
1697   0D57             ; format_p++; 
1698   0D57 FA FD FF      lea d, [bp + -3] ; $format_p
1699   0D5A 2A            mov b, [d]
1700   0D5B FD 77         inc b
1701   0D5D FA FD FF      lea d, [bp + -3] ; $format_p
1702   0D60 FD 43         mov [d], b
1703   0D62 FD 7D         dec b
1704   0D64             ; switch(*format_p){ 
1705   0D64             _switch27_expr:
1706   0D64 FA FD FF      lea d, [bp + -3] ; $format_p
1707   0D67 2A            mov b, [d]
1708   0D68 74            mov d, b
1709   0D69 32            mov bl, [d]
1710   0D6A A7 00         mov bh, 0
1711   0D6C             _switch27_comparisons:
1712   0D6C C1 6C         cmp bl, $6c
1713   0D6E C6 9A 0D      je _switch27_case0
1714   0D71 C1 4C         cmp bl, $4c
1715   0D73 C6 9A 0D      je _switch27_case1
1716   0D76 C1 64         cmp bl, $64
1717   0D78 C6 88 0E      je _switch27_case2
1718   0D7B C1 69         cmp bl, $69
1719   0D7D C6 88 0E      je _switch27_case3
1720   0D80 C1 75         cmp bl, $75
1721   0D82 C6 C2 0E      je _switch27_case4
1722   0D85 C1 78         cmp bl, $78
1723   0D87 C6 FC 0E      je _switch27_case5
1724   0D8A C1 63         cmp bl, $63
1725   0D8C C6 1A 0F      je _switch27_case6
1726   0D8F C1 73         cmp bl, $73
1727   0D91 C6 48 0F      je _switch27_case7
1728   0D94 0A 9F 0F      jmp _switch27_default
1729   0D97 0A AB 0F      jmp _switch27_exit
1730   0D9A             _switch27_case0:
1731   0D9A             _switch27_case1:
1732   0D9A             ; format_p++; 
1733   0D9A FA FD FF      lea d, [bp + -3] ; $format_p
1734   0D9D 2A            mov b, [d]
1735   0D9E FD 77         inc b
1736   0DA0 FA FD FF      lea d, [bp + -3] ; $format_p
1737   0DA3 FD 43         mov [d], b
1738   0DA5 FD 7D         dec b
1739   0DA7             ; if(*format_p == 'd' || *format_p == 'i') 
1740   0DA7             _if28_cond:
1741   0DA7 FA FD FF      lea d, [bp + -3] ; $format_p
1742   0DAA 2A            mov b, [d]
1743   0DAB 74            mov d, b
1744   0DAC 32            mov bl, [d]
1745   0DAD A7 00         mov bh, 0
1746   0DAF             ; --- START RELATIONAL
1747   0DAF D7            push a
1748   0DB0 11            mov a, b
1749   0DB1 26 64 00      mov b, $64
1750   0DB4 B0            cmp a, b
1751   0DB5 FD 71         seq ; ==
1752   0DB7 E4            pop a
1753   0DB8             ; --- END RELATIONAL
1754   0DB8             ; --- START LOGICAL OR
1755   0DB8 D7            push a
1756   0DB9 11            mov a, b
1757   0DBA FA FD FF      lea d, [bp + -3] ; $format_p
1758   0DBD 2A            mov b, [d]
1759   0DBE 74            mov d, b
1760   0DBF 32            mov bl, [d]
1761   0DC0 A7 00         mov bh, 0
1762   0DC2             ; --- START RELATIONAL
1763   0DC2 D7            push a
1764   0DC3 11            mov a, b
1765   0DC4 26 69 00      mov b, $69
1766   0DC7 B0            cmp a, b
1767   0DC8 FD 71         seq ; ==
1768   0DCA E4            pop a
1769   0DCB             ; --- END RELATIONAL
1770   0DCB FD A8         sor a, b ; ||
1771   0DCD E4            pop a
1772   0DCE             ; --- END LOGICAL OR
1773   0DCE C0 00 00      cmp b, 0
1774   0DD1 C6 F6 0D      je _if28_else
1775   0DD4             _if28_true:
1776   0DD4             ; print_signed_long(*(long *)p); 
1777   0DD4 FA FF FF      lea d, [bp + -1] ; $p
1778   0DD7 2A            mov b, [d]
1779   0DD8 AB            snex b
1780   0DD9 FD 39         mov c, b
1781   0DDB 74            mov d, b
1782   0DDC 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1783   0DDF FD 39         mov c, b ; And place it into C
1784   0DE1 2A            mov b, [d] ; Lower Word in B
1785   0DE2 FD 79         mov g, b
1786   0DE4 28            mov b, c
1787   0DE5 FD AB         swp b
1788   0DE7 D8            push b
1789   0DE8 FD 27         mov b, g
1790   0DEA FD AB         swp b
1791   0DEC D8            push b
1792   0DED 07 97 12      call print_signed_long
1793   0DF0 51 04 00      add sp, 4
1794   0DF3 0A 73 0E      jmp _if28_exit
1795   0DF6             _if28_else:
1796   0DF6             ; if(*format_p == 'u') 
1797   0DF6             _if29_cond:
1798   0DF6 FA FD FF      lea d, [bp + -3] ; $format_p
1799   0DF9 2A            mov b, [d]
1800   0DFA 74            mov d, b
1801   0DFB 32            mov bl, [d]
1802   0DFC A7 00         mov bh, 0
1803   0DFE             ; --- START RELATIONAL
1804   0DFE D7            push a
1805   0DFF 11            mov a, b
1806   0E00 26 75 00      mov b, $75
1807   0E03 B0            cmp a, b
1808   0E04 FD 71         seq ; ==
1809   0E06 E4            pop a
1810   0E07             ; --- END RELATIONAL
1811   0E07 C0 00 00      cmp b, 0
1812   0E0A C6 31 0E      je _if29_else
1813   0E0D             _if29_true:
1814   0E0D             ; print_unsigned_long(*(unsigned long *)p); 
1815   0E0D FA FF FF      lea d, [bp + -1] ; $p
1816   0E10 2A            mov b, [d]
1817   0E11 A7 00         mov bh, 0
1818   0E13 38 00 00      mov c, 0
1819   0E16 74            mov d, b
1820   0E17 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1821   0E1A FD 39         mov c, b ; And place it into C
1822   0E1C 2A            mov b, [d] ; Lower Word in B
1823   0E1D FD 79         mov g, b
1824   0E1F 28            mov b, c
1825   0E20 FD AB         swp b
1826   0E22 D8            push b
1827   0E23 FD 27         mov b, g
1828   0E25 FD AB         swp b
1829   0E27 D8            push b
1830   0E28 07 D7 15      call print_unsigned_long
1831   0E2B 51 04 00      add sp, 4
1832   0E2E 0A 73 0E      jmp _if29_exit
1833   0E31             _if29_else:
1834   0E31             ; if(*format_p == 'x') 
1835   0E31             _if30_cond:
1836   0E31 FA FD FF      lea d, [bp + -3] ; $format_p
1837   0E34 2A            mov b, [d]
1838   0E35 74            mov d, b
1839   0E36 32            mov bl, [d]
1840   0E37 A7 00         mov bh, 0
1841   0E39             ; --- START RELATIONAL
1842   0E39 D7            push a
1843   0E3A 11            mov a, b
1844   0E3B 26 78 00      mov b, $78
1845   0E3E B0            cmp a, b
1846   0E3F FD 71         seq ; ==
1847   0E41 E4            pop a
1848   0E42             ; --- END RELATIONAL
1849   0E42 C0 00 00      cmp b, 0
1850   0E45 C6 67 0E      je _if30_else
1851   0E48             _if30_true:
1852   0E48             ; printx32(*(long int *)p); 
1853   0E48 FA FF FF      lea d, [bp + -1] ; $p
1854   0E4B 2A            mov b, [d]
1855   0E4C 74            mov d, b
1856   0E4D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1857   0E50 FD 39         mov c, b ; And place it into C
1858   0E52 2A            mov b, [d] ; Lower Word in B
1859   0E53 FD 79         mov g, b
1860   0E55 28            mov b, c
1861   0E56 FD AB         swp b
1862   0E58 D8            push b
1863   0E59 FD 27         mov b, g
1864   0E5B FD AB         swp b
1865   0E5D D8            push b
1866   0E5E 07 0C 10      call printx32
1867   0E61 51 04 00      add sp, 4
1868   0E64 0A 73 0E      jmp _if30_exit
1869   0E67             _if30_else:
1870   0E67             ; err("Unexpected format in printf."); 
1871   0E67 26 F5 20      mov b, _s4 ; "Unexpected format in printf."
1872   0E6A FD AB         swp b
1873   0E6C D8            push b
1874   0E6D 07 FA 0F      call err
1875   0E70 51 02 00      add sp, 2
1876   0E73             _if30_exit:
1877   0E73             _if29_exit:
1878   0E73             _if28_exit:
1879   0E73             ; p = p + 4; 
1880   0E73 FA FF FF      lea d, [bp + -1] ; $p
1881   0E76 DA            push d
1882   0E77 FA FF FF      lea d, [bp + -1] ; $p
1883   0E7A 2A            mov b, [d]
1884   0E7B             ; --- START TERMS
1885   0E7B D7            push a
1886   0E7C 11            mov a, b
1887   0E7D 26 04 00      mov b, $4
1888   0E80 56            add b, a
1889   0E81 E4            pop a
1890   0E82             ; --- END TERMS
1891   0E82 E7            pop d
1892   0E83 FD 43         mov [d], b
1893   0E85             ; break; 
1894   0E85 0A AB 0F      jmp _switch27_exit ; case break
1895   0E88             _switch27_case2:
1896   0E88             _switch27_case3:
1897   0E88             ; sp = sp + sprint_signed(sp, *(int*)p); 
1898   0E88 FA FB FF      lea d, [bp + -5] ; $sp
1899   0E8B DA            push d
1900   0E8C FA FB FF      lea d, [bp + -5] ; $sp
1901   0E8F 2A            mov b, [d]
1902   0E90             ; --- START TERMS
1903   0E90 D7            push a
1904   0E91 11            mov a, b
1905   0E92 FA FF FF      lea d, [bp + -1] ; $p
1906   0E95 2A            mov b, [d]
1907   0E96 74            mov d, b
1908   0E97 2A            mov b, [d]
1909   0E98 FD AB         swp b
1910   0E9A D8            push b
1911   0E9B FA FB FF      lea d, [bp + -5] ; $sp
1912   0E9E 2A            mov b, [d]
1913   0E9F FD AB         swp b
1914   0EA1 D8            push b
1915   0EA2 07 A6 19      call sprint_signed
1916   0EA5 51 04 00      add sp, 4
1917   0EA8 56            add b, a
1918   0EA9 E4            pop a
1919   0EAA             ; --- END TERMS
1920   0EAA E7            pop d
1921   0EAB FD 43         mov [d], b
1922   0EAD             ; p = p + 2; 
1923   0EAD FA FF FF      lea d, [bp + -1] ; $p
1924   0EB0 DA            push d
1925   0EB1 FA FF FF      lea d, [bp + -1] ; $p
1926   0EB4 2A            mov b, [d]
1927   0EB5             ; --- START TERMS
1928   0EB5 D7            push a
1929   0EB6 11            mov a, b
1930   0EB7 26 02 00      mov b, $2
1931   0EBA 56            add b, a
1932   0EBB E4            pop a
1933   0EBC             ; --- END TERMS
1934   0EBC E7            pop d
1935   0EBD FD 43         mov [d], b
1936   0EBF             ; break; 
1937   0EBF 0A AB 0F      jmp _switch27_exit ; case break
1938   0EC2             _switch27_case4:
1939   0EC2             ; sp = sp + sprint_unsigned(sp, *(unsigned int*)p); 
1940   0EC2 FA FB FF      lea d, [bp + -5] ; $sp
1941   0EC5 DA            push d
1942   0EC6 FA FB FF      lea d, [bp + -5] ; $sp
1943   0EC9 2A            mov b, [d]
1944   0ECA             ; --- START TERMS
1945   0ECA D7            push a
1946   0ECB 11            mov a, b
1947   0ECC FA FF FF      lea d, [bp + -1] ; $p
1948   0ECF 2A            mov b, [d]
1949   0ED0 74            mov d, b
1950   0ED1 2A            mov b, [d]
1951   0ED2 FD AB         swp b
1952   0ED4 D8            push b
1953   0ED5 FA FB FF      lea d, [bp + -5] ; $sp
1954   0ED8 2A            mov b, [d]
1955   0ED9 FD AB         swp b
1956   0EDB D8            push b
1957   0EDC 07 D2 17      call sprint_unsigned
1958   0EDF 51 04 00      add sp, 4
1959   0EE2 56            add b, a
1960   0EE3 E4            pop a
1961   0EE4             ; --- END TERMS
1962   0EE4 E7            pop d
1963   0EE5 FD 43         mov [d], b
1964   0EE7             ; p = p + 2; 
1965   0EE7 FA FF FF      lea d, [bp + -1] ; $p
1966   0EEA DA            push d
1967   0EEB FA FF FF      lea d, [bp + -1] ; $p
1968   0EEE 2A            mov b, [d]
1969   0EEF             ; --- START TERMS
1970   0EEF D7            push a
1971   0EF0 11            mov a, b
1972   0EF1 26 02 00      mov b, $2
1973   0EF4 56            add b, a
1974   0EF5 E4            pop a
1975   0EF6             ; --- END TERMS
1976   0EF6 E7            pop d
1977   0EF7 FD 43         mov [d], b
1978   0EF9             ; break; 
1979   0EF9 0A AB 0F      jmp _switch27_exit ; case break
1980   0EFC             _switch27_case5:
1981   0EFC             
1982   0EFC             ; --- BEGIN INLINE ASM SEGMENT
1983   0EFC FA FF FF      lea d, [bp + -1] ; $p
1984   0EFF FD 2A         mov d, [d]
1985   0F01 2A            mov b, [d]
1986   0F02 07 A1 1E      call print_u16x
1987   0F05             ; --- END INLINE ASM SEGMENT
1988   0F05             
1989   0F05             ; p = p + 2; 
1990   0F05 FA FF FF      lea d, [bp + -1] ; $p
1991   0F08 DA            push d
1992   0F09 FA FF FF      lea d, [bp + -1] ; $p
1993   0F0C 2A            mov b, [d]
1994   0F0D             ; --- START TERMS
1995   0F0D D7            push a
1996   0F0E 11            mov a, b
1997   0F0F 26 02 00      mov b, $2
1998   0F12 56            add b, a
1999   0F13 E4            pop a
2000   0F14             ; --- END TERMS
2001   0F14 E7            pop d
2002   0F15 FD 43         mov [d], b
2003   0F17             ; break; 
2004   0F17 0A AB 0F      jmp _switch27_exit ; case break
2005   0F1A             _switch27_case6:
2006   0F1A             ; *sp++ = *(char *)p; 
2007   0F1A FA FB FF      lea d, [bp + -5] ; $sp
2008   0F1D 2A            mov b, [d]
2009   0F1E FD 77         inc b
2010   0F20 FA FB FF      lea d, [bp + -5] ; $sp
2011   0F23 FD 43         mov [d], b
2012   0F25 FD 7D         dec b
2013   0F27 D8            push b
2014   0F28 FA FF FF      lea d, [bp + -1] ; $p
2015   0F2B 2A            mov b, [d]
2016   0F2C 74            mov d, b
2017   0F2D 32            mov bl, [d]
2018   0F2E A7 00         mov bh, 0
2019   0F30 E7            pop d
2020   0F31 FD 3E         mov [d], bl
2021   0F33             ; p = p + 1; 
2022   0F33 FA FF FF      lea d, [bp + -1] ; $p
2023   0F36 DA            push d
2024   0F37 FA FF FF      lea d, [bp + -1] ; $p
2025   0F3A 2A            mov b, [d]
2026   0F3B             ; --- START TERMS
2027   0F3B D7            push a
2028   0F3C 11            mov a, b
2029   0F3D 26 01 00      mov b, $1
2030   0F40 56            add b, a
2031   0F41 E4            pop a
2032   0F42             ; --- END TERMS
2033   0F42 E7            pop d
2034   0F43 FD 43         mov [d], b
2035   0F45             ; break; 
2036   0F45 0A AB 0F      jmp _switch27_exit ; case break
2037   0F48             _switch27_case7:
2038   0F48             ; int len = strlen(*(char **)p); 
2039   0F48 52 02 00      sub sp, 2
2040   0F4B             ; --- START LOCAL VAR INITIALIZATION
2041   0F4B FA F9 FF      lea d, [bp + -7] ; $len
2042   0F4E DA            push d
2043   0F4F FA FF FF      lea d, [bp + -1] ; $p
2044   0F52 2A            mov b, [d]
2045   0F53 74            mov d, b
2046   0F54 2A            mov b, [d]
2047   0F55 FD AB         swp b
2048   0F57 D8            push b
2049   0F58 07 BA 05      call strlen
2050   0F5B 51 02 00      add sp, 2
2051   0F5E E7            pop d
2052   0F5F FD 43         mov [d], b
2053   0F61             ; --- END LOCAL VAR INITIALIZATION
2054   0F61             ; strcpy(sp, *(char **)p); 
2055   0F61 FA FF FF      lea d, [bp + -1] ; $p
2056   0F64 2A            mov b, [d]
2057   0F65 74            mov d, b
2058   0F66 2A            mov b, [d]
2059   0F67 FD AB         swp b
2060   0F69 D8            push b
2061   0F6A FA FB FF      lea d, [bp + -5] ; $sp
2062   0F6D 2A            mov b, [d]
2063   0F6E FD AB         swp b
2064   0F70 D8            push b
2065   0F71 07 40 04      call strcpy
2066   0F74 51 04 00      add sp, 4
2067   0F77             ; sp = sp + len; 
2068   0F77 FA FB FF      lea d, [bp + -5] ; $sp
2069   0F7A DA            push d
2070   0F7B FA FB FF      lea d, [bp + -5] ; $sp
2071   0F7E 2A            mov b, [d]
2072   0F7F             ; --- START TERMS
2073   0F7F D7            push a
2074   0F80 11            mov a, b
2075   0F81 FA F9 FF      lea d, [bp + -7] ; $len
2076   0F84 2A            mov b, [d]
2077   0F85 56            add b, a
2078   0F86 E4            pop a
2079   0F87             ; --- END TERMS
2080   0F87 E7            pop d
2081   0F88 FD 43         mov [d], b
2082   0F8A             ; p = p + 2; 
2083   0F8A FA FF FF      lea d, [bp + -1] ; $p
2084   0F8D DA            push d
2085   0F8E FA FF FF      lea d, [bp + -1] ; $p
2086   0F91 2A            mov b, [d]
2087   0F92             ; --- START TERMS
2088   0F92 D7            push a
2089   0F93 11            mov a, b
2090   0F94 26 02 00      mov b, $2
2091   0F97 56            add b, a
2092   0F98 E4            pop a
2093   0F99             ; --- END TERMS
2094   0F99 E7            pop d
2095   0F9A FD 43         mov [d], b
2096   0F9C             ; break; 
2097   0F9C 0A AB 0F      jmp _switch27_exit ; case break
2098   0F9F             _switch27_default:
2099   0F9F             ; print("Error: Unknown argument type.\n"); 
2100   0F9F 26 12 21      mov b, _s5 ; "Error: Unknown argument type.\n"
2101   0FA2 FD AB         swp b
2102   0FA4 D8            push b
2103   0FA5 07 50 1B      call print
2104   0FA8 51 02 00      add sp, 2
2105   0FAB             _switch27_exit:
2106   0FAB             ; format_p++; 
2107   0FAB FA FD FF      lea d, [bp + -3] ; $format_p
2108   0FAE 2A            mov b, [d]
2109   0FAF FD 77         inc b
2110   0FB1 FA FD FF      lea d, [bp + -3] ; $format_p
2111   0FB4 FD 43         mov [d], b
2112   0FB6 FD 7D         dec b
2113   0FB8 0A DD 0F      jmp _if26_exit
2114   0FBB             _if26_else:
2115   0FBB             ; *sp++ = *format_p++; 
2116   0FBB FA FB FF      lea d, [bp + -5] ; $sp
2117   0FBE 2A            mov b, [d]
2118   0FBF FD 77         inc b
2119   0FC1 FA FB FF      lea d, [bp + -5] ; $sp
2120   0FC4 FD 43         mov [d], b
2121   0FC6 FD 7D         dec b
2122   0FC8 D8            push b
2123   0FC9 FA FD FF      lea d, [bp + -3] ; $format_p
2124   0FCC 2A            mov b, [d]
2125   0FCD FD 77         inc b
2126   0FCF FA FD FF      lea d, [bp + -3] ; $format_p
2127   0FD2 FD 43         mov [d], b
2128   0FD4 FD 7D         dec b
2129   0FD6 74            mov d, b
2130   0FD7 32            mov bl, [d]
2131   0FD8 A7 00         mov bh, 0
2132   0FDA E7            pop d
2133   0FDB FD 3E         mov [d], bl
2134   0FDD             _if26_exit:
2135   0FDD             _if25_exit:
2136   0FDD             _for24_update:
2137   0FDD 0A 27 0D      jmp _for24_cond
2138   0FE0             _for24_exit:
2139   0FE0             ; *sp = '\0'; 
2140   0FE0 FA FB FF      lea d, [bp + -5] ; $sp
2141   0FE3 2A            mov b, [d]
2142   0FE4 D8            push b
2143   0FE5 26 00 00      mov b, $0
2144   0FE8 E7            pop d
2145   0FE9 FD 3E         mov [d], bl
2146   0FEB             ; return sp - dest; // return total number of chars written 
2147   0FEB FA FB FF      lea d, [bp + -5] ; $sp
2148   0FEE 2A            mov b, [d]
2149   0FEF             ; --- START TERMS
2150   0FEF D7            push a
2151   0FF0 11            mov a, b
2152   0FF1 FA 05 00      lea d, [bp + 5] ; $dest
2153   0FF4 2A            mov b, [d]
2154   0FF5 60            sub a, b
2155   0FF6 27            mov b, a
2156   0FF7 E4            pop a
2157   0FF8             ; --- END TERMS
2158   0FF8 F9            leave
2159   0FF9 09            ret
2160   0FFA             
2161   0FFA             err:
2162   0FFA F8 00 00      enter 0 ; (push bp; mov bp, sp)
2163   0FFD             ; print(e); 
2164   0FFD FA 05 00      lea d, [bp + 5] ; $e
2165   1000 2A            mov b, [d]
2166   1001 FD AB         swp b
2167   1003 D8            push b
2168   1004 07 50 1B      call print
2169   1007 51 02 00      add sp, 2
2170   100A F9            leave
2171   100B 09            ret
2172   100C             
2173   100C             printx32:
2174   100C F8 00 00      enter 0 ; (push bp; mov bp, sp)
2175   100F             
2176   100F             ; --- BEGIN INLINE ASM SEGMENT
2177   100F FA 05 00      lea d, [bp + 5] ; $hex
2178   1012 2B 02 00      mov b, [d+2]
2179   1015 07 A1 1E      call print_u16x
2180   1018 2A            mov b, [d]
2181   1019 07 A1 1E      call print_u16x
2182   101C             ; --- END INLINE ASM SEGMENT
2183   101C             
2184   101C F9            leave
2185   101D 09            ret
2186   101E             
2187   101E             printx16:
2188   101E F8 00 00      enter 0 ; (push bp; mov bp, sp)
2189   1021             
2190   1021             ; --- BEGIN INLINE ASM SEGMENT
2191   1021 FA 05 00      lea d, [bp + 5] ; $hex
2192   1024 2A            mov b, [d]
2193   1025 07 A1 1E      call print_u16x
2194   1028             ; --- END INLINE ASM SEGMENT
2195   1028             
2196   1028 F9            leave
2197   1029 09            ret
2198   102A             
2199   102A             printx8:
2200   102A F8 00 00      enter 0 ; (push bp; mov bp, sp)
2201   102D             
2202   102D             ; --- BEGIN INLINE ASM SEGMENT
2203   102D FA 05 00      lea d, [bp + 5] ; $hex
2204   1030 32            mov bl, [d]
2205   1031 07 E5 1E      call print_u8x
2206   1034             ; --- END INLINE ASM SEGMENT
2207   1034             
2208   1034 F9            leave
2209   1035 09            ret
2210   1036             
2211   1036             hex_str_to_int:
2212   1036 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2213   1039             ; int value = 0; 
2214   1039 52 02 00      sub sp, 2
2215   103C             ; --- START LOCAL VAR INITIALIZATION
2216   103C FA FF FF      lea d, [bp + -1] ; $value
2217   103F DA            push d
2218   1040 26 00 00      mov b, $0
2219   1043 E7            pop d
2220   1044 FD 43         mov [d], b
2221   1046             ; --- END LOCAL VAR INITIALIZATION
2222   1046             ; int i; 
2223   1046 52 02 00      sub sp, 2
2224   1049             ; char hex_char; 
2225   1049 52 01 00      sub sp, 1
2226   104C             ; int len; 
2227   104C 52 02 00      sub sp, 2
2228   104F             ; len = strlen(hex_string); 
2229   104F FA FA FF      lea d, [bp + -6] ; $len
2230   1052 DA            push d
2231   1053 FA 05 00      lea d, [bp + 5] ; $hex_string
2232   1056 2A            mov b, [d]
2233   1057 FD AB         swp b
2234   1059 D8            push b
2235   105A 07 BA 05      call strlen
2236   105D 51 02 00      add sp, 2
2237   1060 E7            pop d
2238   1061 FD 43         mov [d], b
2239   1063             ; for (i = 0; i < len; i++) { 
2240   1063             _for31_init:
2241   1063 FA FD FF      lea d, [bp + -3] ; $i
2242   1066 DA            push d
2243   1067 26 00 00      mov b, $0
2244   106A E7            pop d
2245   106B FD 43         mov [d], b
2246   106D             _for31_cond:
2247   106D FA FD FF      lea d, [bp + -3] ; $i
2248   1070 2A            mov b, [d]
2249   1071             ; --- START RELATIONAL
2250   1071 D7            push a
2251   1072 11            mov a, b
2252   1073 FA FA FF      lea d, [bp + -6] ; $len
2253   1076 2A            mov b, [d]
2254   1077 B0            cmp a, b
2255   1078 FD 73         slt ; < (signed)
2256   107A E4            pop a
2257   107B             ; --- END RELATIONAL
2258   107B C0 00 00      cmp b, 0
2259   107E C6 80 11      je _for31_exit
2260   1081             _for31_block:
2261   1081             ; hex_char = hex_string[i]; 
2262   1081 FA FC FF      lea d, [bp + -4] ; $hex_char
2263   1084 DA            push d
2264   1085 FA 05 00      lea d, [bp + 5] ; $hex_string
2265   1088 FD 2A         mov d, [d]
2266   108A D7            push a
2267   108B DA            push d
2268   108C FA FD FF      lea d, [bp + -3] ; $i
2269   108F 2A            mov b, [d]
2270   1090 E7            pop d
2271   1091 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
2272   1095 E4            pop a
2273   1096 32            mov bl, [d]
2274   1097 A7 00         mov bh, 0
2275   1099 E7            pop d
2276   109A FD 3E         mov [d], bl
2277   109C             ; if (hex_char >= 'a' && hex_char <= 'f')  
2278   109C             _if32_cond:
2279   109C FA FC FF      lea d, [bp + -4] ; $hex_char
2280   109F 32            mov bl, [d]
2281   10A0 A7 00         mov bh, 0
2282   10A2             ; --- START RELATIONAL
2283   10A2 D7            push a
2284   10A3 11            mov a, b
2285   10A4 26 61 00      mov b, $61
2286   10A7 B0            cmp a, b
2287   10A8 FD 80         sge ; >=
2288   10AA E4            pop a
2289   10AB             ; --- END RELATIONAL
2290   10AB             ; --- START LOGICAL AND
2291   10AB D7            push a
2292   10AC 11            mov a, b
2293   10AD FA FC FF      lea d, [bp + -4] ; $hex_char
2294   10B0 32            mov bl, [d]
2295   10B1 A7 00         mov bh, 0
2296   10B3             ; --- START RELATIONAL
2297   10B3 D7            push a
2298   10B4 11            mov a, b
2299   10B5 26 66 00      mov b, $66
2300   10B8 B0            cmp a, b
2301   10B9 FD 74         sle ; <= (signed)
2302   10BB E4            pop a
2303   10BC             ; --- END RELATIONAL
2304   10BC FD A7         sand a, b
2305   10BE E4            pop a
2306   10BF             ; --- END LOGICAL AND
2307   10BF C0 00 00      cmp b, 0
2308   10C2 C6 F3 10      je _if32_else
2309   10C5             _if32_true:
2310   10C5             ; value = (value * 16) + (hex_char - 'a' + 10); 
2311   10C5 FA FF FF      lea d, [bp + -1] ; $value
2312   10C8 DA            push d
2313   10C9 FA FF FF      lea d, [bp + -1] ; $value
2314   10CC 2A            mov b, [d]
2315   10CD             ; --- START FACTORS
2316   10CD D7            push a
2317   10CE 11            mov a, b
2318   10CF 26 10 00      mov b, $10
2319   10D2 AC            mul a, b ; *
2320   10D3 11            mov a, b
2321   10D4 27            mov b, a
2322   10D5 E4            pop a
2323   10D6             ; --- END FACTORS
2324   10D6             ; --- START TERMS
2325   10D6 D7            push a
2326   10D7 11            mov a, b
2327   10D8 FA FC FF      lea d, [bp + -4] ; $hex_char
2328   10DB 32            mov bl, [d]
2329   10DC A7 00         mov bh, 0
2330   10DE             ; --- START TERMS
2331   10DE D7            push a
2332   10DF 11            mov a, b
2333   10E0 26 61 00      mov b, $61
2334   10E3 60            sub a, b
2335   10E4 27            mov b, a
2336   10E5 11            mov a, b
2337   10E6 26 0A 00      mov b, $a
2338   10E9 56            add b, a
2339   10EA E4            pop a
2340   10EB             ; --- END TERMS
2341   10EB 56            add b, a
2342   10EC E4            pop a
2343   10ED             ; --- END TERMS
2344   10ED E7            pop d
2345   10EE FD 43         mov [d], b
2346   10F0 0A 70 11      jmp _if32_exit
2347   10F3             _if32_else:
2348   10F3             ; if (hex_char >= 'A' && hex_char <= 'F')  
2349   10F3             _if33_cond:
2350   10F3 FA FC FF      lea d, [bp + -4] ; $hex_char
2351   10F6 32            mov bl, [d]
2352   10F7 A7 00         mov bh, 0
2353   10F9             ; --- START RELATIONAL
2354   10F9 D7            push a
2355   10FA 11            mov a, b
2356   10FB 26 41 00      mov b, $41
2357   10FE B0            cmp a, b
2358   10FF FD 80         sge ; >=
2359   1101 E4            pop a
2360   1102             ; --- END RELATIONAL
2361   1102             ; --- START LOGICAL AND
2362   1102 D7            push a
2363   1103 11            mov a, b
2364   1104 FA FC FF      lea d, [bp + -4] ; $hex_char
2365   1107 32            mov bl, [d]
2366   1108 A7 00         mov bh, 0
2367   110A             ; --- START RELATIONAL
2368   110A D7            push a
2369   110B 11            mov a, b
2370   110C 26 46 00      mov b, $46
2371   110F B0            cmp a, b
2372   1110 FD 74         sle ; <= (signed)
2373   1112 E4            pop a
2374   1113             ; --- END RELATIONAL
2375   1113 FD A7         sand a, b
2376   1115 E4            pop a
2377   1116             ; --- END LOGICAL AND
2378   1116 C0 00 00      cmp b, 0
2379   1119 C6 4A 11      je _if33_else
2380   111C             _if33_true:
2381   111C             ; value = (value * 16) + (hex_char - 'A' + 10); 
2382   111C FA FF FF      lea d, [bp + -1] ; $value
2383   111F DA            push d
2384   1120 FA FF FF      lea d, [bp + -1] ; $value
2385   1123 2A            mov b, [d]
2386   1124             ; --- START FACTORS
2387   1124 D7            push a
2388   1125 11            mov a, b
2389   1126 26 10 00      mov b, $10
2390   1129 AC            mul a, b ; *
2391   112A 11            mov a, b
2392   112B 27            mov b, a
2393   112C E4            pop a
2394   112D             ; --- END FACTORS
2395   112D             ; --- START TERMS
2396   112D D7            push a
2397   112E 11            mov a, b
2398   112F FA FC FF      lea d, [bp + -4] ; $hex_char
2399   1132 32            mov bl, [d]
2400   1133 A7 00         mov bh, 0
2401   1135             ; --- START TERMS
2402   1135 D7            push a
2403   1136 11            mov a, b
2404   1137 26 41 00      mov b, $41
2405   113A 60            sub a, b
2406   113B 27            mov b, a
2407   113C 11            mov a, b
2408   113D 26 0A 00      mov b, $a
2409   1140 56            add b, a
2410   1141 E4            pop a
2411   1142             ; --- END TERMS
2412   1142 56            add b, a
2413   1143 E4            pop a
2414   1144             ; --- END TERMS
2415   1144 E7            pop d
2416   1145 FD 43         mov [d], b
2417   1147 0A 70 11      jmp _if33_exit
2418   114A             _if33_else:
2419   114A             ; value = (value * 16) + (hex_char - '0'); 
2420   114A FA FF FF      lea d, [bp + -1] ; $value
2421   114D DA            push d
2422   114E FA FF FF      lea d, [bp + -1] ; $value
2423   1151 2A            mov b, [d]
2424   1152             ; --- START FACTORS
2425   1152 D7            push a
2426   1153 11            mov a, b
2427   1154 26 10 00      mov b, $10
2428   1157 AC            mul a, b ; *
2429   1158 11            mov a, b
2430   1159 27            mov b, a
2431   115A E4            pop a
2432   115B             ; --- END FACTORS
2433   115B             ; --- START TERMS
2434   115B D7            push a
2435   115C 11            mov a, b
2436   115D FA FC FF      lea d, [bp + -4] ; $hex_char
2437   1160 32            mov bl, [d]
2438   1161 A7 00         mov bh, 0
2439   1163             ; --- START TERMS
2440   1163 D7            push a
2441   1164 11            mov a, b
2442   1165 26 30 00      mov b, $30
2443   1168 60            sub a, b
2444   1169 27            mov b, a
2445   116A E4            pop a
2446   116B             ; --- END TERMS
2447   116B 56            add b, a
2448   116C E4            pop a
2449   116D             ; --- END TERMS
2450   116D E7            pop d
2451   116E FD 43         mov [d], b
2452   1170             _if33_exit:
2453   1170             _if32_exit:
2454   1170             _for31_update:
2455   1170 FA FD FF      lea d, [bp + -3] ; $i
2456   1173 2A            mov b, [d]
2457   1174 FD 77         inc b
2458   1176 FA FD FF      lea d, [bp + -3] ; $i
2459   1179 FD 43         mov [d], b
2460   117B FD 7D         dec b
2461   117D 0A 6D 10      jmp _for31_cond
2462   1180             _for31_exit:
2463   1180             ; return value; 
2464   1180 FA FF FF      lea d, [bp + -1] ; $value
2465   1183 2A            mov b, [d]
2466   1184 F9            leave
2467   1185 09            ret
2468   1186             
2469   1186             gets:
2470   1186 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2471   1189             
2472   1189             ; --- BEGIN INLINE ASM SEGMENT
2473   1189 FA 05 00      lea d, [bp + 5] ; $s
2474   118C 15            mov a, [d]
2475   118D 3C            mov d, a
2476   118E 07 06 1D      call _gets
2477   1191             ; --- END INLINE ASM SEGMENT
2478   1191             
2479   1191             ; return strlen(s); 
2480   1191 FA 05 00      lea d, [bp + 5] ; $s
2481   1194 2A            mov b, [d]
2482   1195 FD AB         swp b
2483   1197 D8            push b
2484   1198 07 BA 05      call strlen
2485   119B 51 02 00      add sp, 2
2486   119E F9            leave
2487   119F 09            ret
2488   11A0             
2489   11A0             print_signed:
2490   11A0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2491   11A3             ; char digits[5]; 
2492   11A3 52 05 00      sub sp, 5
2493   11A6             ; int i = 0; 
2494   11A6 52 02 00      sub sp, 2
2495   11A9             ; --- START LOCAL VAR INITIALIZATION
2496   11A9 FA FA FF      lea d, [bp + -6] ; $i
2497   11AC DA            push d
2498   11AD 26 00 00      mov b, $0
2499   11B0 E7            pop d
2500   11B1 FD 43         mov [d], b
2501   11B3             ; --- END LOCAL VAR INITIALIZATION
2502   11B3             ; if (num < 0) { 
2503   11B3             _if34_cond:
2504   11B3 FA 05 00      lea d, [bp + 5] ; $num
2505   11B6 2A            mov b, [d]
2506   11B7             ; --- START RELATIONAL
2507   11B7 D7            push a
2508   11B8 11            mov a, b
2509   11B9 26 00 00      mov b, $0
2510   11BC B0            cmp a, b
2511   11BD FD 73         slt ; < (signed)
2512   11BF E4            pop a
2513   11C0             ; --- END RELATIONAL
2514   11C0 C0 00 00      cmp b, 0
2515   11C3 C6 E0 11      je _if34_else
2516   11C6             _if34_true:
2517   11C6             ; putchar('-'); 
2518   11C6 26 2D 00      mov b, $2d
2519   11C9 DD            push bl
2520   11CA 07 08 1B      call putchar
2521   11CD 51 01 00      add sp, 1
2522   11D0             ; num = -num; 
2523   11D0 FA 05 00      lea d, [bp + 5] ; $num
2524   11D3 DA            push d
2525   11D4 FA 05 00      lea d, [bp + 5] ; $num
2526   11D7 2A            mov b, [d]
2527   11D8 FD 97         neg b
2528   11DA E7            pop d
2529   11DB FD 43         mov [d], b
2530   11DD 0A 02 12      jmp _if34_exit
2531   11E0             _if34_else:
2532   11E0             ; if (num == 0) { 
2533   11E0             _if35_cond:
2534   11E0 FA 05 00      lea d, [bp + 5] ; $num
2535   11E3 2A            mov b, [d]
2536   11E4             ; --- START RELATIONAL
2537   11E4 D7            push a
2538   11E5 11            mov a, b
2539   11E6 26 00 00      mov b, $0
2540   11E9 B0            cmp a, b
2541   11EA FD 71         seq ; ==
2542   11EC E4            pop a
2543   11ED             ; --- END RELATIONAL
2544   11ED C0 00 00      cmp b, 0
2545   11F0 C6 02 12      je _if35_exit
2546   11F3             _if35_true:
2547   11F3             ; putchar('0'); 
2548   11F3 26 30 00      mov b, $30
2549   11F6 DD            push bl
2550   11F7 07 08 1B      call putchar
2551   11FA 51 01 00      add sp, 1
2552   11FD             ; return; 
2553   11FD F9            leave
2554   11FE 09            ret
2555   11FF 0A 02 12      jmp _if35_exit
2556   1202             _if35_exit:
2557   1202             _if34_exit:
2558   1202             ; while (num > 0) { 
2559   1202             _while36_cond:
2560   1202 FA 05 00      lea d, [bp + 5] ; $num
2561   1205 2A            mov b, [d]
2562   1206             ; --- START RELATIONAL
2563   1206 D7            push a
2564   1207 11            mov a, b
2565   1208 26 00 00      mov b, $0
2566   120B B0            cmp a, b
2567   120C FD 7F         sgt ; >
2568   120E E4            pop a
2569   120F             ; --- END RELATIONAL
2570   120F C0 00 00      cmp b, 0
2571   1212 C6 5C 12      je _while36_exit
2572   1215             _while36_block:
2573   1215             ; digits[i] = '0' + (num % 10); 
2574   1215 FA FC FF      lea d, [bp + -4] ; $digits
2575   1218 D7            push a
2576   1219 DA            push d
2577   121A FA FA FF      lea d, [bp + -6] ; $i
2578   121D 2A            mov b, [d]
2579   121E E7            pop d
2580   121F 5A            add d, b
2581   1220 E4            pop a
2582   1221 DA            push d
2583   1222 26 30 00      mov b, $30
2584   1225             ; --- START TERMS
2585   1225 D7            push a
2586   1226 11            mov a, b
2587   1227 FA 05 00      lea d, [bp + 5] ; $num
2588   122A 2A            mov b, [d]
2589   122B             ; --- START FACTORS
2590   122B D7            push a
2591   122C 11            mov a, b
2592   122D 26 0A 00      mov b, $a
2593   1230 AE            div a, b ; 
2594   1231 11            mov a, b
2595   1232 27            mov b, a
2596   1233 E4            pop a
2597   1234             ; --- END FACTORS
2598   1234 56            add b, a
2599   1235 E4            pop a
2600   1236             ; --- END TERMS
2601   1236 E7            pop d
2602   1237 FD 3E         mov [d], bl
2603   1239             ; num = num / 10; 
2604   1239 FA 05 00      lea d, [bp + 5] ; $num
2605   123C DA            push d
2606   123D FA 05 00      lea d, [bp + 5] ; $num
2607   1240 2A            mov b, [d]
2608   1241             ; --- START FACTORS
2609   1241 D7            push a
2610   1242 11            mov a, b
2611   1243 26 0A 00      mov b, $a
2612   1246 AE            div a, b
2613   1247 27            mov b, a
2614   1248 E4            pop a
2615   1249             ; --- END FACTORS
2616   1249 E7            pop d
2617   124A FD 43         mov [d], b
2618   124C             ; i++; 
2619   124C FA FA FF      lea d, [bp + -6] ; $i
2620   124F 2A            mov b, [d]
2621   1250 FD 77         inc b
2622   1252 FA FA FF      lea d, [bp + -6] ; $i
2623   1255 FD 43         mov [d], b
2624   1257 FD 7D         dec b
2625   1259 0A 02 12      jmp _while36_cond
2626   125C             _while36_exit:
2627   125C             ; while (i > 0) { 
2628   125C             _while37_cond:
2629   125C FA FA FF      lea d, [bp + -6] ; $i
2630   125F 2A            mov b, [d]
2631   1260             ; --- START RELATIONAL
2632   1260 D7            push a
2633   1261 11            mov a, b
2634   1262 26 00 00      mov b, $0
2635   1265 B0            cmp a, b
2636   1266 FD 7F         sgt ; >
2637   1268 E4            pop a
2638   1269             ; --- END RELATIONAL
2639   1269 C0 00 00      cmp b, 0
2640   126C C6 95 12      je _while37_exit
2641   126F             _while37_block:
2642   126F             ; i--; 
2643   126F FA FA FF      lea d, [bp + -6] ; $i
2644   1272 2A            mov b, [d]
2645   1273 FD 7D         dec b
2646   1275 FA FA FF      lea d, [bp + -6] ; $i
2647   1278 FD 43         mov [d], b
2648   127A FD 77         inc b
2649   127C             ; putchar(digits[i]); 
2650   127C FA FC FF      lea d, [bp + -4] ; $digits
2651   127F D7            push a
2652   1280 DA            push d
2653   1281 FA FA FF      lea d, [bp + -6] ; $i
2654   1284 2A            mov b, [d]
2655   1285 E7            pop d
2656   1286 5A            add d, b
2657   1287 E4            pop a
2658   1288 32            mov bl, [d]
2659   1289 A7 00         mov bh, 0
2660   128B DD            push bl
2661   128C 07 08 1B      call putchar
2662   128F 51 01 00      add sp, 1
2663   1292 0A 5C 12      jmp _while37_cond
2664   1295             _while37_exit:
2665   1295 F9            leave
2666   1296 09            ret
2667   1297             
2668   1297             print_signed_long:
2669   1297 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2670   129A             ; char digits[10]; 
2671   129A 52 0A 00      sub sp, 10
2672   129D             ; int i = 0; 
2673   129D 52 02 00      sub sp, 2
2674   12A0             ; --- START LOCAL VAR INITIALIZATION
2675   12A0 FA F5 FF      lea d, [bp + -11] ; $i
2676   12A3 DA            push d
2677   12A4 26 00 00      mov b, $0
2678   12A7 E7            pop d
2679   12A8 FD 43         mov [d], b
2680   12AA             ; --- END LOCAL VAR INITIALIZATION
2681   12AA             ; if (num < 0) { 
2682   12AA             _if38_cond:
2683   12AA FA 05 00      lea d, [bp + 5] ; $num
2684   12AD 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2685   12B0 FD 39         mov c, b ; And place it into C
2686   12B2 2A            mov b, [d] ; Lower Word in B
2687   12B3             ; --- START RELATIONAL
2688   12B3 D7            push a
2689   12B4 FD D8         push g
2690   12B6 11            mov a, b
2691   12B7 FD 7A         mov g, c
2692   12B9 26 00 00      mov b, $0
2693   12BC 38 00 00      mov c, 0
2694   12BF FD AF 00 00   cmp32 ga, cb
2694   12C3 00 00 00 00 
2694   12C7 00 00 00 00 
2694   12CB 00 00 00 00 
2694   12CF 00 00 00 00 
2694   12D3 00 00 00 00 
2694   12D7 00 00 00 00 
2694   12DB 00 00 00 00 
2694   12DF 00 00 00 00 
2694   12E3 00 00 00 00 
2694   12E7 00 00 00 00 
2694   12EB 00 00 00 00 
2694   12EF 00 00 00 00 
2694   12F3 00 00 00 00 
2694   12F7 00 00 00 00 
2694   12FB 00 00 00 00 
2694   12FF 00 00 00 00 
2694   1303 00 00 00 00 
2694   1307 00 00 00 00 
2694   130B 00 00 00 00 
2694   130F 00 00 00 00 
2694   1313 00 00 00 00 
2694   1317 00 00 00 00 
2694   131B 00 00 00 00 
2694   131F 00 00 00 00 
2694   1323 00 00 00 00 
2694   1327 00 00 00 00 
2694   132B 00 00 00 00 
2694   132F 00 00 00 00 
2694   1333 00 00 00 00 
2694   1337 00 00 00 00 
2694   133B 00 00 00 00 
2694   133F 00 00 00 00 
2694   1343 00 00 00 00 
2694   1347 00 00 00 00 
2694   134B 00 00 00 00 
2694   134F 00 00 00 00 
2694   1353 00 00 00 00 
2694   1357 00 00 00 00 
2694   135B 00 00 00 00 
2694   135F 00 00 00 00 
2694   1363 00 00 00 00 
2694   1367 00 00 00 00 
2694   136B 00 00 00 00 
2694   136F 00 00 00 00 
2694   1373 00 00 00 00 
2694   1377 00 00 00 00 
2694   137B 00 00 00 00 
2694   137F 00 00 00 00 
2694   1383 00 00 00 00 
2694   1387 00 00 00 00 
2694   138B 00 00 00 00 
2694   138F 00 00 00 00 
2694   1393 00 00 00 00 
2694   1397 00 00 00 00 
2694   139B 00 00 00 00 
2694   139F 00 00 00 00 
2694   13A3 00 00 00 00 
2694   13A7 00 00 00 00 
2694   13AB 00 00 00 00 
2694   13AF 00 00 00 00 
2694   13B3 00 00 00 00 
2694   13B7 00 00 00 00 
2694   13BB 00 00 00 00 
2694   13BF 00 
2695   13C0 FD 73         slt ; <
2696   13C2 FD F1         pop g
2697   13C4 E4            pop a
2698   13C5             ; --- END RELATIONAL
2699   13C5 C0 00 00      cmp b, 0
2700   13C8 C6 EF 13      je _if38_else
2701   13CB             _if38_true:
2702   13CB             ; putchar('-'); 
2703   13CB 26 2D 00      mov b, $2d
2704   13CE DD            push bl
2705   13CF 07 08 1B      call putchar
2706   13D2 51 01 00      add sp, 1
2707   13D5             ; num = -num; 
2708   13D5 FA 05 00      lea d, [bp + 5] ; $num
2709   13D8 DA            push d
2710   13D9 FA 05 00      lea d, [bp + 5] ; $num
2711   13DC 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2712   13DF FD 39         mov c, b ; And place it into C
2713   13E1 2A            mov b, [d] ; Lower Word in B
2714   13E2 FD 97         neg b
2715   13E4 E7            pop d
2716   13E5 FD 43         mov [d], b
2717   13E7 28            mov b, c
2718   13E8 FD 44 02 00   mov [d + 2], b
2719   13EC 0A 1F 15      jmp _if38_exit
2720   13EF             _if38_else:
2721   13EF             ; if (num == 0) { 
2722   13EF             _if39_cond:
2723   13EF FA 05 00      lea d, [bp + 5] ; $num
2724   13F2 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2725   13F5 FD 39         mov c, b ; And place it into C
2726   13F7 2A            mov b, [d] ; Lower Word in B
2727   13F8             ; --- START RELATIONAL
2728   13F8 D7            push a
2729   13F9 FD D8         push g
2730   13FB 11            mov a, b
2731   13FC FD 7A         mov g, c
2732   13FE 26 00 00      mov b, $0
2733   1401 38 00 00      mov c, 0
2734   1404 FD AF 00 00   cmp32 ga, cb
2734   1408 00 00 00 00 
2734   140C 00 00 00 00 
2734   1410 00 00 00 00 
2734   1414 00 00 00 00 
2734   1418 00 00 00 00 
2734   141C 00 00 00 00 
2734   1420 00 00 00 00 
2734   1424 00 00 00 00 
2734   1428 00 00 00 00 
2734   142C 00 00 00 00 
2734   1430 00 00 00 00 
2734   1434 00 00 00 00 
2734   1438 00 00 00 00 
2734   143C 00 00 00 00 
2734   1440 00 00 00 00 
2734   1444 00 00 00 00 
2734   1448 00 00 00 00 
2734   144C 00 00 00 00 
2734   1450 00 00 00 00 
2734   1454 00 00 00 00 
2734   1458 00 00 00 00 
2734   145C 00 00 00 00 
2734   1460 00 00 00 00 
2734   1464 00 00 00 00 
2734   1468 00 00 00 00 
2734   146C 00 00 00 00 
2734   1470 00 00 00 00 
2734   1474 00 00 00 00 
2734   1478 00 00 00 00 
2734   147C 00 00 00 00 
2734   1480 00 00 00 00 
2734   1484 00 00 00 00 
2734   1488 00 00 00 00 
2734   148C 00 00 00 00 
2734   1490 00 00 00 00 
2734   1494 00 00 00 00 
2734   1498 00 00 00 00 
2734   149C 00 00 00 00 
2734   14A0 00 00 00 00 
2734   14A4 00 00 00 00 
2734   14A8 00 00 00 00 
2734   14AC 00 00 00 00 
2734   14B0 00 00 00 00 
2734   14B4 00 00 00 00 
2734   14B8 00 00 00 00 
2734   14BC 00 00 00 00 
2734   14C0 00 00 00 00 
2734   14C4 00 00 00 00 
2734   14C8 00 00 00 00 
2734   14CC 00 00 00 00 
2734   14D0 00 00 00 00 
2734   14D4 00 00 00 00 
2734   14D8 00 00 00 00 
2734   14DC 00 00 00 00 
2734   14E0 00 00 00 00 
2734   14E4 00 00 00 00 
2734   14E8 00 00 00 00 
2734   14EC 00 00 00 00 
2734   14F0 00 00 00 00 
2734   14F4 00 00 00 00 
2734   14F8 00 00 00 00 
2734   14FC 00 00 00 00 
2734   1500 00 00 00 00 
2734   1504 00 
2735   1505 FD 71         seq ; ==
2736   1507 FD F1         pop g
2737   1509 E4            pop a
2738   150A             ; --- END RELATIONAL
2739   150A C0 00 00      cmp b, 0
2740   150D C6 1F 15      je _if39_exit
2741   1510             _if39_true:
2742   1510             ; putchar('0'); 
2743   1510 26 30 00      mov b, $30
2744   1513 DD            push bl
2745   1514 07 08 1B      call putchar
2746   1517 51 01 00      add sp, 1
2747   151A             ; return; 
2748   151A F9            leave
2749   151B 09            ret
2750   151C 0A 1F 15      jmp _if39_exit
2751   151F             _if39_exit:
2752   151F             _if38_exit:
2753   151F             ; while (num > 0) { 
2754   151F             _while40_cond:
2755   151F FA 05 00      lea d, [bp + 5] ; $num
2756   1522 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2757   1525 FD 39         mov c, b ; And place it into C
2758   1527 2A            mov b, [d] ; Lower Word in B
2759   1528             ; --- START RELATIONAL
2760   1528 D7            push a
2761   1529 FD D8         push g
2762   152B 11            mov a, b
2763   152C FD 7A         mov g, c
2764   152E 26 00 00      mov b, $0
2765   1531 38 00 00      mov c, 0
2766   1534 FD 7F         sgt
2767   1536 FD F1         pop g
2768   1538 E4            pop a
2769   1539             ; --- END RELATIONAL
2770   1539 C0 00 00      cmp b, 0
2771   153C C6 9C 15      je _while40_exit
2772   153F             _while40_block:
2773   153F             ; digits[i] = '0' + (num % 10); 
2774   153F FA F7 FF      lea d, [bp + -9] ; $digits
2775   1542 D7            push a
2776   1543 DA            push d
2777   1544 FA F5 FF      lea d, [bp + -11] ; $i
2778   1547 2A            mov b, [d]
2779   1548 E7            pop d
2780   1549 5A            add d, b
2781   154A E4            pop a
2782   154B DA            push d
2783   154C 26 30 00      mov b, $30
2784   154F             ; --- START TERMS
2785   154F D7            push a
2786   1550 11            mov a, b
2787   1551 FA 05 00      lea d, [bp + 5] ; $num
2788   1554 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2789   1557 FD 39         mov c, b ; And place it into C
2790   1559 2A            mov b, [d] ; Lower Word in B
2791   155A             ; --- START FACTORS
2792   155A D7            push a
2793   155B 11            mov a, b
2794   155C 26 0A 00      mov b, $a
2795   155F AE            div a, b ; 
2796   1560 11            mov a, b
2797   1561 27            mov b, a
2798   1562 E4            pop a
2799   1563             ; --- END FACTORS
2800   1563 54            add a, b
2801   1564 D7            push a
2802   1565 FD 12         mov a, g
2803   1567 28            mov b, c
2804   1568 5C            adc a, b
2805   1569 39            mov c, a
2806   156A E5            pop b
2807   156B E4            pop a
2808   156C             ; --- END TERMS
2809   156C E7            pop d
2810   156D FD 3E         mov [d], bl
2811   156F             ; num = num / 10; 
2812   156F FA 05 00      lea d, [bp + 5] ; $num
2813   1572 DA            push d
2814   1573 FA 05 00      lea d, [bp + 5] ; $num
2815   1576 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2816   1579 FD 39         mov c, b ; And place it into C
2817   157B 2A            mov b, [d] ; Lower Word in B
2818   157C             ; --- START FACTORS
2819   157C D7            push a
2820   157D 11            mov a, b
2821   157E 26 0A 00      mov b, $a
2822   1581 AE            div a, b
2823   1582 27            mov b, a
2824   1583 E4            pop a
2825   1584             ; --- END FACTORS
2826   1584 E7            pop d
2827   1585 FD 43         mov [d], b
2828   1587 28            mov b, c
2829   1588 FD 44 02 00   mov [d + 2], b
2830   158C             ; i++; 
2831   158C FA F5 FF      lea d, [bp + -11] ; $i
2832   158F 2A            mov b, [d]
2833   1590 FD 77         inc b
2834   1592 FA F5 FF      lea d, [bp + -11] ; $i
2835   1595 FD 43         mov [d], b
2836   1597 FD 7D         dec b
2837   1599 0A 1F 15      jmp _while40_cond
2838   159C             _while40_exit:
2839   159C             ; while (i > 0) { 
2840   159C             _while41_cond:
2841   159C FA F5 FF      lea d, [bp + -11] ; $i
2842   159F 2A            mov b, [d]
2843   15A0             ; --- START RELATIONAL
2844   15A0 D7            push a
2845   15A1 11            mov a, b
2846   15A2 26 00 00      mov b, $0
2847   15A5 B0            cmp a, b
2848   15A6 FD 7F         sgt ; >
2849   15A8 E4            pop a
2850   15A9             ; --- END RELATIONAL
2851   15A9 C0 00 00      cmp b, 0
2852   15AC C6 D5 15      je _while41_exit
2853   15AF             _while41_block:
2854   15AF             ; i--; 
2855   15AF FA F5 FF      lea d, [bp + -11] ; $i
2856   15B2 2A            mov b, [d]
2857   15B3 FD 7D         dec b
2858   15B5 FA F5 FF      lea d, [bp + -11] ; $i
2859   15B8 FD 43         mov [d], b
2860   15BA FD 77         inc b
2861   15BC             ; putchar(digits[i]); 
2862   15BC FA F7 FF      lea d, [bp + -9] ; $digits
2863   15BF D7            push a
2864   15C0 DA            push d
2865   15C1 FA F5 FF      lea d, [bp + -11] ; $i
2866   15C4 2A            mov b, [d]
2867   15C5 E7            pop d
2868   15C6 5A            add d, b
2869   15C7 E4            pop a
2870   15C8 32            mov bl, [d]
2871   15C9 A7 00         mov bh, 0
2872   15CB DD            push bl
2873   15CC 07 08 1B      call putchar
2874   15CF 51 01 00      add sp, 1
2875   15D2 0A 9C 15      jmp _while41_cond
2876   15D5             _while41_exit:
2877   15D5 F9            leave
2878   15D6 09            ret
2879   15D7             
2880   15D7             print_unsigned_long:
2881   15D7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2882   15DA             ; char digits[10]; 
2883   15DA 52 0A 00      sub sp, 10
2884   15DD             ; int i; 
2885   15DD 52 02 00      sub sp, 2
2886   15E0             ; i = 0; 
2887   15E0 FA F5 FF      lea d, [bp + -11] ; $i
2888   15E3 DA            push d
2889   15E4 26 00 00      mov b, $0
2890   15E7 E7            pop d
2891   15E8 FD 43         mov [d], b
2892   15EA             ; if(num == 0){ 
2893   15EA             _if42_cond:
2894   15EA FA 05 00      lea d, [bp + 5] ; $num
2895   15ED 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2896   15F0 FD 39         mov c, b ; And place it into C
2897   15F2 2A            mov b, [d] ; Lower Word in B
2898   15F3             ; --- START RELATIONAL
2899   15F3 D7            push a
2900   15F4 FD D8         push g
2901   15F6 11            mov a, b
2902   15F7 FD 7A         mov g, c
2903   15F9 26 00 00      mov b, $0
2904   15FC 38 00 00      mov c, 0
2905   15FF FD AF 00 00   cmp32 ga, cb
2905   1603 00 00 00 00 
2905   1607 00 00 00 00 
2905   160B 00 00 00 00 
2905   160F 00 00 00 00 
2905   1613 00 00 00 00 
2905   1617 00 00 00 00 
2905   161B 00 00 00 00 
2905   161F 00 00 00 00 
2905   1623 00 00 00 00 
2905   1627 00 00 00 00 
2905   162B 00 00 00 00 
2905   162F 00 00 00 00 
2905   1633 00 00 00 00 
2905   1637 00 00 00 00 
2905   163B 00 00 00 00 
2905   163F 00 00 00 00 
2905   1643 00 00 00 00 
2905   1647 00 00 00 00 
2905   164B 00 00 00 00 
2905   164F 00 00 00 00 
2905   1653 00 00 00 00 
2905   1657 00 00 00 00 
2905   165B 00 00 00 00 
2905   165F 00 00 00 00 
2905   1663 00 00 00 00 
2905   1667 00 00 00 00 
2905   166B 00 00 00 00 
2905   166F 00 00 00 00 
2905   1673 00 00 00 00 
2905   1677 00 00 00 00 
2905   167B 00 00 00 00 
2905   167F 00 00 00 00 
2905   1683 00 00 00 00 
2905   1687 00 00 00 00 
2905   168B 00 00 00 00 
2905   168F 00 00 00 00 
2905   1693 00 00 00 00 
2905   1697 00 00 00 00 
2905   169B 00 00 00 00 
2905   169F 00 00 00 00 
2905   16A3 00 00 00 00 
2905   16A7 00 00 00 00 
2905   16AB 00 00 00 00 
2905   16AF 00 00 00 00 
2905   16B3 00 00 00 00 
2905   16B7 00 00 00 00 
2905   16BB 00 00 00 00 
2905   16BF 00 00 00 00 
2905   16C3 00 00 00 00 
2905   16C7 00 00 00 00 
2905   16CB 00 00 00 00 
2905   16CF 00 00 00 00 
2905   16D3 00 00 00 00 
2905   16D7 00 00 00 00 
2905   16DB 00 00 00 00 
2905   16DF 00 00 00 00 
2905   16E3 00 00 00 00 
2905   16E7 00 00 00 00 
2905   16EB 00 00 00 00 
2905   16EF 00 00 00 00 
2905   16F3 00 00 00 00 
2905   16F7 00 00 00 00 
2905   16FB 00 00 00 00 
2905   16FF 00 
2906   1700 FD 71         seq ; ==
2907   1702 FD F1         pop g
2908   1704 E4            pop a
2909   1705             ; --- END RELATIONAL
2910   1705 C0 00 00      cmp b, 0
2911   1708 C6 1A 17      je _if42_exit
2912   170B             _if42_true:
2913   170B             ; putchar('0'); 
2914   170B 26 30 00      mov b, $30
2915   170E DD            push bl
2916   170F 07 08 1B      call putchar
2917   1712 51 01 00      add sp, 1
2918   1715             ; return; 
2919   1715 F9            leave
2920   1716 09            ret
2921   1717 0A 1A 17      jmp _if42_exit
2922   171A             _if42_exit:
2923   171A             ; while (num > 0) { 
2924   171A             _while43_cond:
2925   171A FA 05 00      lea d, [bp + 5] ; $num
2926   171D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2927   1720 FD 39         mov c, b ; And place it into C
2928   1722 2A            mov b, [d] ; Lower Word in B
2929   1723             ; --- START RELATIONAL
2930   1723 D7            push a
2931   1724 FD D8         push g
2932   1726 11            mov a, b
2933   1727 FD 7A         mov g, c
2934   1729 26 00 00      mov b, $0
2935   172C 38 00 00      mov c, 0
2936   172F FD 81         sgu
2937   1731 FD F1         pop g
2938   1733 E4            pop a
2939   1734             ; --- END RELATIONAL
2940   1734 C0 00 00      cmp b, 0
2941   1737 C6 97 17      je _while43_exit
2942   173A             _while43_block:
2943   173A             ; digits[i] = '0' + (num % 10); 
2944   173A FA F7 FF      lea d, [bp + -9] ; $digits
2945   173D D7            push a
2946   173E DA            push d
2947   173F FA F5 FF      lea d, [bp + -11] ; $i
2948   1742 2A            mov b, [d]
2949   1743 E7            pop d
2950   1744 5A            add d, b
2951   1745 E4            pop a
2952   1746 DA            push d
2953   1747 26 30 00      mov b, $30
2954   174A             ; --- START TERMS
2955   174A D7            push a
2956   174B 11            mov a, b
2957   174C FA 05 00      lea d, [bp + 5] ; $num
2958   174F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2959   1752 FD 39         mov c, b ; And place it into C
2960   1754 2A            mov b, [d] ; Lower Word in B
2961   1755             ; --- START FACTORS
2962   1755 D7            push a
2963   1756 11            mov a, b
2964   1757 26 0A 00      mov b, $a
2965   175A AE            div a, b ; 
2966   175B 11            mov a, b
2967   175C 27            mov b, a
2968   175D E4            pop a
2969   175E             ; --- END FACTORS
2970   175E 54            add a, b
2971   175F D7            push a
2972   1760 FD 12         mov a, g
2973   1762 28            mov b, c
2974   1763 5C            adc a, b
2975   1764 39            mov c, a
2976   1765 E5            pop b
2977   1766 E4            pop a
2978   1767             ; --- END TERMS
2979   1767 E7            pop d
2980   1768 FD 3E         mov [d], bl
2981   176A             ; num = num / 10; 
2982   176A FA 05 00      lea d, [bp + 5] ; $num
2983   176D DA            push d
2984   176E FA 05 00      lea d, [bp + 5] ; $num
2985   1771 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2986   1774 FD 39         mov c, b ; And place it into C
2987   1776 2A            mov b, [d] ; Lower Word in B
2988   1777             ; --- START FACTORS
2989   1777 D7            push a
2990   1778 11            mov a, b
2991   1779 26 0A 00      mov b, $a
2992   177C AE            div a, b
2993   177D 27            mov b, a
2994   177E E4            pop a
2995   177F             ; --- END FACTORS
2996   177F E7            pop d
2997   1780 FD 43         mov [d], b
2998   1782 28            mov b, c
2999   1783 FD 44 02 00   mov [d + 2], b
3000   1787             ; i++; 
3001   1787 FA F5 FF      lea d, [bp + -11] ; $i
3002   178A 2A            mov b, [d]
3003   178B FD 77         inc b
3004   178D FA F5 FF      lea d, [bp + -11] ; $i
3005   1790 FD 43         mov [d], b
3006   1792 FD 7D         dec b
3007   1794 0A 1A 17      jmp _while43_cond
3008   1797             _while43_exit:
3009   1797             ; while (i > 0) { 
3010   1797             _while44_cond:
3011   1797 FA F5 FF      lea d, [bp + -11] ; $i
3012   179A 2A            mov b, [d]
3013   179B             ; --- START RELATIONAL
3014   179B D7            push a
3015   179C 11            mov a, b
3016   179D 26 00 00      mov b, $0
3017   17A0 B0            cmp a, b
3018   17A1 FD 7F         sgt ; >
3019   17A3 E4            pop a
3020   17A4             ; --- END RELATIONAL
3021   17A4 C0 00 00      cmp b, 0
3022   17A7 C6 D0 17      je _while44_exit
3023   17AA             _while44_block:
3024   17AA             ; i--; 
3025   17AA FA F5 FF      lea d, [bp + -11] ; $i
3026   17AD 2A            mov b, [d]
3027   17AE FD 7D         dec b
3028   17B0 FA F5 FF      lea d, [bp + -11] ; $i
3029   17B3 FD 43         mov [d], b
3030   17B5 FD 77         inc b
3031   17B7             ; putchar(digits[i]); 
3032   17B7 FA F7 FF      lea d, [bp + -9] ; $digits
3033   17BA D7            push a
3034   17BB DA            push d
3035   17BC FA F5 FF      lea d, [bp + -11] ; $i
3036   17BF 2A            mov b, [d]
3037   17C0 E7            pop d
3038   17C1 5A            add d, b
3039   17C2 E4            pop a
3040   17C3 32            mov bl, [d]
3041   17C4 A7 00         mov bh, 0
3042   17C6 DD            push bl
3043   17C7 07 08 1B      call putchar
3044   17CA 51 01 00      add sp, 1
3045   17CD 0A 97 17      jmp _while44_cond
3046   17D0             _while44_exit:
3047   17D0 F9            leave
3048   17D1 09            ret
3049   17D2             
3050   17D2             sprint_unsigned:
3051   17D2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3052   17D5             ; char digits[5]; 
3053   17D5 52 05 00      sub sp, 5
3054   17D8             ; int i; 
3055   17D8 52 02 00      sub sp, 2
3056   17DB             ; int len = 0; 
3057   17DB 52 02 00      sub sp, 2
3058   17DE             ; --- START LOCAL VAR INITIALIZATION
3059   17DE FA F8 FF      lea d, [bp + -8] ; $len
3060   17E1 DA            push d
3061   17E2 26 00 00      mov b, $0
3062   17E5 E7            pop d
3063   17E6 FD 43         mov [d], b
3064   17E8             ; --- END LOCAL VAR INITIALIZATION
3065   17E8             ; i = 0; 
3066   17E8 FA FA FF      lea d, [bp + -6] ; $i
3067   17EB DA            push d
3068   17EC 26 00 00      mov b, $0
3069   17EF E7            pop d
3070   17F0 FD 43         mov [d], b
3071   17F2             ; if(num == 0){ 
3072   17F2             _if45_cond:
3073   17F2 FA 07 00      lea d, [bp + 7] ; $num
3074   17F5 2A            mov b, [d]
3075   17F6             ; --- START RELATIONAL
3076   17F6 D7            push a
3077   17F7 11            mov a, b
3078   17F8 26 00 00      mov b, $0
3079   17FB B0            cmp a, b
3080   17FC FD 71         seq ; ==
3081   17FE E4            pop a
3082   17FF             ; --- END RELATIONAL
3083   17FF C0 00 00      cmp b, 0
3084   1802 C6 21 18      je _if45_exit
3085   1805             _if45_true:
3086   1805             ; *dest++ = '0'; 
3087   1805 FA 05 00      lea d, [bp + 5] ; $dest
3088   1808 2A            mov b, [d]
3089   1809 FD 77         inc b
3090   180B FA 05 00      lea d, [bp + 5] ; $dest
3091   180E FD 43         mov [d], b
3092   1810 FD 7D         dec b
3093   1812 D8            push b
3094   1813 26 30 00      mov b, $30
3095   1816 E7            pop d
3096   1817 FD 3E         mov [d], bl
3097   1819             ; return 1; 
3098   1819 26 01 00      mov b, $1
3099   181C F9            leave
3100   181D 09            ret
3101   181E 0A 21 18      jmp _if45_exit
3102   1821             _if45_exit:
3103   1821             ; while (num > 0) { 
3104   1821             _while46_cond:
3105   1821 FA 07 00      lea d, [bp + 7] ; $num
3106   1824 2A            mov b, [d]
3107   1825             ; --- START RELATIONAL
3108   1825 D7            push a
3109   1826 11            mov a, b
3110   1827 26 00 00      mov b, $0
3111   182A B0            cmp a, b
3112   182B FD 81         sgu ; > (unsigned)
3113   182D E4            pop a
3114   182E             ; --- END RELATIONAL
3115   182E C0 00 00      cmp b, 0
3116   1831 C6 7B 18      je _while46_exit
3117   1834             _while46_block:
3118   1834             ; digits[i] = '0' + (num % 10); 
3119   1834 FA FC FF      lea d, [bp + -4] ; $digits
3120   1837 D7            push a
3121   1838 DA            push d
3122   1839 FA FA FF      lea d, [bp + -6] ; $i
3123   183C 2A            mov b, [d]
3124   183D E7            pop d
3125   183E 5A            add d, b
3126   183F E4            pop a
3127   1840 DA            push d
3128   1841 26 30 00      mov b, $30
3129   1844             ; --- START TERMS
3130   1844 D7            push a
3131   1845 11            mov a, b
3132   1846 FA 07 00      lea d, [bp + 7] ; $num
3133   1849 2A            mov b, [d]
3134   184A             ; --- START FACTORS
3135   184A D7            push a
3136   184B 11            mov a, b
3137   184C 26 0A 00      mov b, $a
3138   184F AE            div a, b ; 
3139   1850 11            mov a, b
3140   1851 27            mov b, a
3141   1852 E4            pop a
3142   1853             ; --- END FACTORS
3143   1853 56            add b, a
3144   1854 E4            pop a
3145   1855             ; --- END TERMS
3146   1855 E7            pop d
3147   1856 FD 3E         mov [d], bl
3148   1858             ; num = num / 10; 
3149   1858 FA 07 00      lea d, [bp + 7] ; $num
3150   185B DA            push d
3151   185C FA 07 00      lea d, [bp + 7] ; $num
3152   185F 2A            mov b, [d]
3153   1860             ; --- START FACTORS
3154   1860 D7            push a
3155   1861 11            mov a, b
3156   1862 26 0A 00      mov b, $a
3157   1865 AE            div a, b
3158   1866 27            mov b, a
3159   1867 E4            pop a
3160   1868             ; --- END FACTORS
3161   1868 E7            pop d
3162   1869 FD 43         mov [d], b
3163   186B             ; i++; 
3164   186B FA FA FF      lea d, [bp + -6] ; $i
3165   186E 2A            mov b, [d]
3166   186F FD 77         inc b
3167   1871 FA FA FF      lea d, [bp + -6] ; $i
3168   1874 FD 43         mov [d], b
3169   1876 FD 7D         dec b
3170   1878 0A 21 18      jmp _while46_cond
3171   187B             _while46_exit:
3172   187B             ; while (i > 0) { 
3173   187B             _while47_cond:
3174   187B FA FA FF      lea d, [bp + -6] ; $i
3175   187E 2A            mov b, [d]
3176   187F             ; --- START RELATIONAL
3177   187F D7            push a
3178   1880 11            mov a, b
3179   1881 26 00 00      mov b, $0
3180   1884 B0            cmp a, b
3181   1885 FD 7F         sgt ; >
3182   1887 E4            pop a
3183   1888             ; --- END RELATIONAL
3184   1888 C0 00 00      cmp b, 0
3185   188B C6 CB 18      je _while47_exit
3186   188E             _while47_block:
3187   188E             ; i--; 
3188   188E FA FA FF      lea d, [bp + -6] ; $i
3189   1891 2A            mov b, [d]
3190   1892 FD 7D         dec b
3191   1894 FA FA FF      lea d, [bp + -6] ; $i
3192   1897 FD 43         mov [d], b
3193   1899 FD 77         inc b
3194   189B             ; *dest++ = digits[i]; 
3195   189B FA 05 00      lea d, [bp + 5] ; $dest
3196   189E 2A            mov b, [d]
3197   189F FD 77         inc b
3198   18A1 FA 05 00      lea d, [bp + 5] ; $dest
3199   18A4 FD 43         mov [d], b
3200   18A6 FD 7D         dec b
3201   18A8 D8            push b
3202   18A9 FA FC FF      lea d, [bp + -4] ; $digits
3203   18AC D7            push a
3204   18AD DA            push d
3205   18AE FA FA FF      lea d, [bp + -6] ; $i
3206   18B1 2A            mov b, [d]
3207   18B2 E7            pop d
3208   18B3 5A            add d, b
3209   18B4 E4            pop a
3210   18B5 32            mov bl, [d]
3211   18B6 A7 00         mov bh, 0
3212   18B8 E7            pop d
3213   18B9 FD 3E         mov [d], bl
3214   18BB             ; len++; 
3215   18BB FA F8 FF      lea d, [bp + -8] ; $len
3216   18BE 2A            mov b, [d]
3217   18BF FD 77         inc b
3218   18C1 FA F8 FF      lea d, [bp + -8] ; $len
3219   18C4 FD 43         mov [d], b
3220   18C6 FD 7D         dec b
3221   18C8 0A 7B 18      jmp _while47_cond
3222   18CB             _while47_exit:
3223   18CB             ; *dest = '\0'; 
3224   18CB FA 05 00      lea d, [bp + 5] ; $dest
3225   18CE 2A            mov b, [d]
3226   18CF D8            push b
3227   18D0 26 00 00      mov b, $0
3228   18D3 E7            pop d
3229   18D4 FD 3E         mov [d], bl
3230   18D6             ; return len; 
3231   18D6 FA F8 FF      lea d, [bp + -8] ; $len
3232   18D9 2A            mov b, [d]
3233   18DA F9            leave
3234   18DB 09            ret
3235   18DC             
3236   18DC             print_unsigned:
3237   18DC F8 00 00      enter 0 ; (push bp; mov bp, sp)
3238   18DF             ; char digits[5]; 
3239   18DF 52 05 00      sub sp, 5
3240   18E2             ; int i; 
3241   18E2 52 02 00      sub sp, 2
3242   18E5             ; i = 0; 
3243   18E5 FA FA FF      lea d, [bp + -6] ; $i
3244   18E8 DA            push d
3245   18E9 26 00 00      mov b, $0
3246   18EC E7            pop d
3247   18ED FD 43         mov [d], b
3248   18EF             ; if(num == 0){ 
3249   18EF             _if48_cond:
3250   18EF FA 05 00      lea d, [bp + 5] ; $num
3251   18F2 2A            mov b, [d]
3252   18F3             ; --- START RELATIONAL
3253   18F3 D7            push a
3254   18F4 11            mov a, b
3255   18F5 26 00 00      mov b, $0
3256   18F8 B0            cmp a, b
3257   18F9 FD 71         seq ; ==
3258   18FB E4            pop a
3259   18FC             ; --- END RELATIONAL
3260   18FC C0 00 00      cmp b, 0
3261   18FF C6 11 19      je _if48_exit
3262   1902             _if48_true:
3263   1902             ; putchar('0'); 
3264   1902 26 30 00      mov b, $30
3265   1905 DD            push bl
3266   1906 07 08 1B      call putchar
3267   1909 51 01 00      add sp, 1
3268   190C             ; return; 
3269   190C F9            leave
3270   190D 09            ret
3271   190E 0A 11 19      jmp _if48_exit
3272   1911             _if48_exit:
3273   1911             ; while (num > 0) { 
3274   1911             _while49_cond:
3275   1911 FA 05 00      lea d, [bp + 5] ; $num
3276   1914 2A            mov b, [d]
3277   1915             ; --- START RELATIONAL
3278   1915 D7            push a
3279   1916 11            mov a, b
3280   1917 26 00 00      mov b, $0
3281   191A B0            cmp a, b
3282   191B FD 81         sgu ; > (unsigned)
3283   191D E4            pop a
3284   191E             ; --- END RELATIONAL
3285   191E C0 00 00      cmp b, 0
3286   1921 C6 6B 19      je _while49_exit
3287   1924             _while49_block:
3288   1924             ; digits[i] = '0' + (num % 10); 
3289   1924 FA FC FF      lea d, [bp + -4] ; $digits
3290   1927 D7            push a
3291   1928 DA            push d
3292   1929 FA FA FF      lea d, [bp + -6] ; $i
3293   192C 2A            mov b, [d]
3294   192D E7            pop d
3295   192E 5A            add d, b
3296   192F E4            pop a
3297   1930 DA            push d
3298   1931 26 30 00      mov b, $30
3299   1934             ; --- START TERMS
3300   1934 D7            push a
3301   1935 11            mov a, b
3302   1936 FA 05 00      lea d, [bp + 5] ; $num
3303   1939 2A            mov b, [d]
3304   193A             ; --- START FACTORS
3305   193A D7            push a
3306   193B 11            mov a, b
3307   193C 26 0A 00      mov b, $a
3308   193F AE            div a, b ; 
3309   1940 11            mov a, b
3310   1941 27            mov b, a
3311   1942 E4            pop a
3312   1943             ; --- END FACTORS
3313   1943 56            add b, a
3314   1944 E4            pop a
3315   1945             ; --- END TERMS
3316   1945 E7            pop d
3317   1946 FD 3E         mov [d], bl
3318   1948             ; num = num / 10; 
3319   1948 FA 05 00      lea d, [bp + 5] ; $num
3320   194B DA            push d
3321   194C FA 05 00      lea d, [bp + 5] ; $num
3322   194F 2A            mov b, [d]
3323   1950             ; --- START FACTORS
3324   1950 D7            push a
3325   1951 11            mov a, b
3326   1952 26 0A 00      mov b, $a
3327   1955 AE            div a, b
3328   1956 27            mov b, a
3329   1957 E4            pop a
3330   1958             ; --- END FACTORS
3331   1958 E7            pop d
3332   1959 FD 43         mov [d], b
3333   195B             ; i++; 
3334   195B FA FA FF      lea d, [bp + -6] ; $i
3335   195E 2A            mov b, [d]
3336   195F FD 77         inc b
3337   1961 FA FA FF      lea d, [bp + -6] ; $i
3338   1964 FD 43         mov [d], b
3339   1966 FD 7D         dec b
3340   1968 0A 11 19      jmp _while49_cond
3341   196B             _while49_exit:
3342   196B             ; while (i > 0) { 
3343   196B             _while50_cond:
3344   196B FA FA FF      lea d, [bp + -6] ; $i
3345   196E 2A            mov b, [d]
3346   196F             ; --- START RELATIONAL
3347   196F D7            push a
3348   1970 11            mov a, b
3349   1971 26 00 00      mov b, $0
3350   1974 B0            cmp a, b
3351   1975 FD 7F         sgt ; >
3352   1977 E4            pop a
3353   1978             ; --- END RELATIONAL
3354   1978 C0 00 00      cmp b, 0
3355   197B C6 A4 19      je _while50_exit
3356   197E             _while50_block:
3357   197E             ; i--; 
3358   197E FA FA FF      lea d, [bp + -6] ; $i
3359   1981 2A            mov b, [d]
3360   1982 FD 7D         dec b
3361   1984 FA FA FF      lea d, [bp + -6] ; $i
3362   1987 FD 43         mov [d], b
3363   1989 FD 77         inc b
3364   198B             ; putchar(digits[i]); 
3365   198B FA FC FF      lea d, [bp + -4] ; $digits
3366   198E D7            push a
3367   198F DA            push d
3368   1990 FA FA FF      lea d, [bp + -6] ; $i
3369   1993 2A            mov b, [d]
3370   1994 E7            pop d
3371   1995 5A            add d, b
3372   1996 E4            pop a
3373   1997 32            mov bl, [d]
3374   1998 A7 00         mov bh, 0
3375   199A DD            push bl
3376   199B 07 08 1B      call putchar
3377   199E 51 01 00      add sp, 1
3378   19A1 0A 6B 19      jmp _while50_cond
3379   19A4             _while50_exit:
3380   19A4 F9            leave
3381   19A5 09            ret
3382   19A6             
3383   19A6             sprint_signed:
3384   19A6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3385   19A9             ; char digits[5]; 
3386   19A9 52 05 00      sub sp, 5
3387   19AC             ; int i = 0; 
3388   19AC 52 02 00      sub sp, 2
3389   19AF             ; --- START LOCAL VAR INITIALIZATION
3390   19AF FA FA FF      lea d, [bp + -6] ; $i
3391   19B2 DA            push d
3392   19B3 26 00 00      mov b, $0
3393   19B6 E7            pop d
3394   19B7 FD 43         mov [d], b
3395   19B9             ; --- END LOCAL VAR INITIALIZATION
3396   19B9             ; int len = 0; 
3397   19B9 52 02 00      sub sp, 2
3398   19BC             ; --- START LOCAL VAR INITIALIZATION
3399   19BC FA F8 FF      lea d, [bp + -8] ; $len
3400   19BF DA            push d
3401   19C0 26 00 00      mov b, $0
3402   19C3 E7            pop d
3403   19C4 FD 43         mov [d], b
3404   19C6             ; --- END LOCAL VAR INITIALIZATION
3405   19C6             ; if (num < 0) { 
3406   19C6             _if51_cond:
3407   19C6 FA 07 00      lea d, [bp + 7] ; $num
3408   19C9 2A            mov b, [d]
3409   19CA             ; --- START RELATIONAL
3410   19CA D7            push a
3411   19CB 11            mov a, b
3412   19CC 26 00 00      mov b, $0
3413   19CF B0            cmp a, b
3414   19D0 FD 73         slt ; < (signed)
3415   19D2 E4            pop a
3416   19D3             ; --- END RELATIONAL
3417   19D3 C0 00 00      cmp b, 0
3418   19D6 C6 0A 1A      je _if51_else
3419   19D9             _if51_true:
3420   19D9             ; *dest++ = '-'; 
3421   19D9 FA 05 00      lea d, [bp + 5] ; $dest
3422   19DC 2A            mov b, [d]
3423   19DD FD 77         inc b
3424   19DF FA 05 00      lea d, [bp + 5] ; $dest
3425   19E2 FD 43         mov [d], b
3426   19E4 FD 7D         dec b
3427   19E6 D8            push b
3428   19E7 26 2D 00      mov b, $2d
3429   19EA E7            pop d
3430   19EB FD 3E         mov [d], bl
3431   19ED             ; num = -num; 
3432   19ED FA 07 00      lea d, [bp + 7] ; $num
3433   19F0 DA            push d
3434   19F1 FA 07 00      lea d, [bp + 7] ; $num
3435   19F4 2A            mov b, [d]
3436   19F5 FD 97         neg b
3437   19F7 E7            pop d
3438   19F8 FD 43         mov [d], b
3439   19FA             ; len++; 
3440   19FA FA F8 FF      lea d, [bp + -8] ; $len
3441   19FD 2A            mov b, [d]
3442   19FE FD 77         inc b
3443   1A00 FA F8 FF      lea d, [bp + -8] ; $len
3444   1A03 FD 43         mov [d], b
3445   1A05 FD 7D         dec b
3446   1A07 0A 44 1A      jmp _if51_exit
3447   1A0A             _if51_else:
3448   1A0A             ; if (num == 0) { 
3449   1A0A             _if52_cond:
3450   1A0A FA 07 00      lea d, [bp + 7] ; $num
3451   1A0D 2A            mov b, [d]
3452   1A0E             ; --- START RELATIONAL
3453   1A0E D7            push a
3454   1A0F 11            mov a, b
3455   1A10 26 00 00      mov b, $0
3456   1A13 B0            cmp a, b
3457   1A14 FD 71         seq ; ==
3458   1A16 E4            pop a
3459   1A17             ; --- END RELATIONAL
3460   1A17 C0 00 00      cmp b, 0
3461   1A1A C6 44 1A      je _if52_exit
3462   1A1D             _if52_true:
3463   1A1D             ; *dest++ = '0'; 
3464   1A1D FA 05 00      lea d, [bp + 5] ; $dest
3465   1A20 2A            mov b, [d]
3466   1A21 FD 77         inc b
3467   1A23 FA 05 00      lea d, [bp + 5] ; $dest
3468   1A26 FD 43         mov [d], b
3469   1A28 FD 7D         dec b
3470   1A2A D8            push b
3471   1A2B 26 30 00      mov b, $30
3472   1A2E E7            pop d
3473   1A2F FD 3E         mov [d], bl
3474   1A31             ; *dest = '\0'; 
3475   1A31 FA 05 00      lea d, [bp + 5] ; $dest
3476   1A34 2A            mov b, [d]
3477   1A35 D8            push b
3478   1A36 26 00 00      mov b, $0
3479   1A39 E7            pop d
3480   1A3A FD 3E         mov [d], bl
3481   1A3C             ; return 1; 
3482   1A3C 26 01 00      mov b, $1
3483   1A3F F9            leave
3484   1A40 09            ret
3485   1A41 0A 44 1A      jmp _if52_exit
3486   1A44             _if52_exit:
3487   1A44             _if51_exit:
3488   1A44             ; while (num > 0) { 
3489   1A44             _while53_cond:
3490   1A44 FA 07 00      lea d, [bp + 7] ; $num
3491   1A47 2A            mov b, [d]
3492   1A48             ; --- START RELATIONAL
3493   1A48 D7            push a
3494   1A49 11            mov a, b
3495   1A4A 26 00 00      mov b, $0
3496   1A4D B0            cmp a, b
3497   1A4E FD 7F         sgt ; >
3498   1A50 E4            pop a
3499   1A51             ; --- END RELATIONAL
3500   1A51 C0 00 00      cmp b, 0
3501   1A54 C6 9E 1A      je _while53_exit
3502   1A57             _while53_block:
3503   1A57             ; digits[i] = '0' + (num % 10); 
3504   1A57 FA FC FF      lea d, [bp + -4] ; $digits
3505   1A5A D7            push a
3506   1A5B DA            push d
3507   1A5C FA FA FF      lea d, [bp + -6] ; $i
3508   1A5F 2A            mov b, [d]
3509   1A60 E7            pop d
3510   1A61 5A            add d, b
3511   1A62 E4            pop a
3512   1A63 DA            push d
3513   1A64 26 30 00      mov b, $30
3514   1A67             ; --- START TERMS
3515   1A67 D7            push a
3516   1A68 11            mov a, b
3517   1A69 FA 07 00      lea d, [bp + 7] ; $num
3518   1A6C 2A            mov b, [d]
3519   1A6D             ; --- START FACTORS
3520   1A6D D7            push a
3521   1A6E 11            mov a, b
3522   1A6F 26 0A 00      mov b, $a
3523   1A72 AE            div a, b ; 
3524   1A73 11            mov a, b
3525   1A74 27            mov b, a
3526   1A75 E4            pop a
3527   1A76             ; --- END FACTORS
3528   1A76 56            add b, a
3529   1A77 E4            pop a
3530   1A78             ; --- END TERMS
3531   1A78 E7            pop d
3532   1A79 FD 3E         mov [d], bl
3533   1A7B             ; num = num / 10; 
3534   1A7B FA 07 00      lea d, [bp + 7] ; $num
3535   1A7E DA            push d
3536   1A7F FA 07 00      lea d, [bp + 7] ; $num
3537   1A82 2A            mov b, [d]
3538   1A83             ; --- START FACTORS
3539   1A83 D7            push a
3540   1A84 11            mov a, b
3541   1A85 26 0A 00      mov b, $a
3542   1A88 AE            div a, b
3543   1A89 27            mov b, a
3544   1A8A E4            pop a
3545   1A8B             ; --- END FACTORS
3546   1A8B E7            pop d
3547   1A8C FD 43         mov [d], b
3548   1A8E             ; i++; 
3549   1A8E FA FA FF      lea d, [bp + -6] ; $i
3550   1A91 2A            mov b, [d]
3551   1A92 FD 77         inc b
3552   1A94 FA FA FF      lea d, [bp + -6] ; $i
3553   1A97 FD 43         mov [d], b
3554   1A99 FD 7D         dec b
3555   1A9B 0A 44 1A      jmp _while53_cond
3556   1A9E             _while53_exit:
3557   1A9E             ; while (i > 0) { 
3558   1A9E             _while54_cond:
3559   1A9E FA FA FF      lea d, [bp + -6] ; $i
3560   1AA1 2A            mov b, [d]
3561   1AA2             ; --- START RELATIONAL
3562   1AA2 D7            push a
3563   1AA3 11            mov a, b
3564   1AA4 26 00 00      mov b, $0
3565   1AA7 B0            cmp a, b
3566   1AA8 FD 7F         sgt ; >
3567   1AAA E4            pop a
3568   1AAB             ; --- END RELATIONAL
3569   1AAB C0 00 00      cmp b, 0
3570   1AAE C6 EE 1A      je _while54_exit
3571   1AB1             _while54_block:
3572   1AB1             ; i--; 
3573   1AB1 FA FA FF      lea d, [bp + -6] ; $i
3574   1AB4 2A            mov b, [d]
3575   1AB5 FD 7D         dec b
3576   1AB7 FA FA FF      lea d, [bp + -6] ; $i
3577   1ABA FD 43         mov [d], b
3578   1ABC FD 77         inc b
3579   1ABE             ; *dest++ = digits[i]; 
3580   1ABE FA 05 00      lea d, [bp + 5] ; $dest
3581   1AC1 2A            mov b, [d]
3582   1AC2 FD 77         inc b
3583   1AC4 FA 05 00      lea d, [bp + 5] ; $dest
3584   1AC7 FD 43         mov [d], b
3585   1AC9 FD 7D         dec b
3586   1ACB D8            push b
3587   1ACC FA FC FF      lea d, [bp + -4] ; $digits
3588   1ACF D7            push a
3589   1AD0 DA            push d
3590   1AD1 FA FA FF      lea d, [bp + -6] ; $i
3591   1AD4 2A            mov b, [d]
3592   1AD5 E7            pop d
3593   1AD6 5A            add d, b
3594   1AD7 E4            pop a
3595   1AD8 32            mov bl, [d]
3596   1AD9 A7 00         mov bh, 0
3597   1ADB E7            pop d
3598   1ADC FD 3E         mov [d], bl
3599   1ADE             ; len++; 
3600   1ADE FA F8 FF      lea d, [bp + -8] ; $len
3601   1AE1 2A            mov b, [d]
3602   1AE2 FD 77         inc b
3603   1AE4 FA F8 FF      lea d, [bp + -8] ; $len
3604   1AE7 FD 43         mov [d], b
3605   1AE9 FD 7D         dec b
3606   1AEB 0A 9E 1A      jmp _while54_cond
3607   1AEE             _while54_exit:
3608   1AEE             ; *dest = '\0'; 
3609   1AEE FA 05 00      lea d, [bp + 5] ; $dest
3610   1AF1 2A            mov b, [d]
3611   1AF2 D8            push b
3612   1AF3 26 00 00      mov b, $0
3613   1AF6 E7            pop d
3614   1AF7 FD 3E         mov [d], bl
3615   1AF9             ; return len; 
3616   1AF9 FA F8 FF      lea d, [bp + -8] ; $len
3617   1AFC 2A            mov b, [d]
3618   1AFD F9            leave
3619   1AFE 09            ret
3620   1AFF             
3621   1AFF             date:
3622   1AFF F8 00 00      enter 0 ; (push bp; mov bp, sp)
3623   1B02             
3624   1B02             ; --- BEGIN INLINE ASM SEGMENT
3625   1B02 19 00         mov al, 0 
3626   1B04 05 07         syscall sys_datetime
3627   1B06             ; --- END INLINE ASM SEGMENT
3628   1B06             
3629   1B06 F9            leave
3630   1B07 09            ret
3631   1B08             
3632   1B08             putchar:
3633   1B08 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3634   1B0B             
3635   1B0B             ; --- BEGIN INLINE ASM SEGMENT
3636   1B0B FA 05 00      lea d, [bp + 5] ; $c
3637   1B0E 1E            mov al, [d]
3638   1B0F 23            mov ah, al
3639   1B10 07 FF 1C      call _putchar
3640   1B13             ; --- END INLINE ASM SEGMENT
3641   1B13             
3642   1B13 F9            leave
3643   1B14 09            ret
3644   1B15             
3645   1B15             getchar:
3646   1B15 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3647   1B18             ; char c; 
3648   1B18 52 01 00      sub sp, 1
3649   1B1B             
3650   1B1B             ; --- BEGIN INLINE ASM SEGMENT
3651   1B1B 07 F8 1C      call getch
3652   1B1E 1A            mov al, ah
3653   1B1F FA 00 00      lea d, [bp + 0] ; $c
3654   1B22 3E            mov [d], al
3655   1B23             ; --- END INLINE ASM SEGMENT
3656   1B23             
3657   1B23             ; return c; 
3658   1B23 FA 00 00      lea d, [bp + 0] ; $c
3659   1B26 32            mov bl, [d]
3660   1B27 A7 00         mov bh, 0
3661   1B29 F9            leave
3662   1B2A 09            ret
3663   1B2B             
3664   1B2B             scann:
3665   1B2B F8 00 00      enter 0 ; (push bp; mov bp, sp)
3666   1B2E             ; int m; 
3667   1B2E 52 02 00      sub sp, 2
3668   1B31             
3669   1B31             ; --- BEGIN INLINE ASM SEGMENT
3670   1B31 07 43 1F      call scan_u16d
3671   1B34 FA FF FF      lea d, [bp + -1] ; $m
3672   1B37 43            mov [d], a
3673   1B38             ; --- END INLINE ASM SEGMENT
3674   1B38             
3675   1B38             ; return m; 
3676   1B38 FA FF FF      lea d, [bp + -1] ; $m
3677   1B3B 2A            mov b, [d]
3678   1B3C F9            leave
3679   1B3D 09            ret
3680   1B3E             
3681   1B3E             puts:
3682   1B3E F8 00 00      enter 0 ; (push bp; mov bp, sp)
3683   1B41             
3684   1B41             ; --- BEGIN INLINE ASM SEGMENT
3685   1B41 FA 05 00      lea d, [bp + 5] ; $s
3686   1B44 15            mov a, [d]
3687   1B45 3C            mov d, a
3688   1B46 07 49 1E      call _puts
3689   1B49 10 00 0A      mov a, $0A00
3690   1B4C 05 03         syscall sys_io
3691   1B4E             ; --- END INLINE ASM SEGMENT
3692   1B4E             
3693   1B4E F9            leave
3694   1B4F 09            ret
3695   1B50             
3696   1B50             print:
3697   1B50 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3698   1B53             
3699   1B53             ; --- BEGIN INLINE ASM SEGMENT
3700   1B53 FA 05 00      lea d, [bp + 5] ; $s
3701   1B56 FD 2A         mov d, [d]
3702   1B58 07 49 1E      call _puts
3703   1B5B             ; --- END INLINE ASM SEGMENT
3704   1B5B             
3705   1B5B F9            leave
3706   1B5C 09            ret
3707   1B5D             
3708   1B5D             getparam:
3709   1B5D F8 00 00      enter 0 ; (push bp; mov bp, sp)
3710   1B60             ; char data; 
3711   1B60 52 01 00      sub sp, 1
3712   1B63             
3713   1B63             ; --- BEGIN INLINE ASM SEGMENT
3714   1B63 19 04         mov al, 4
3715   1B65 FA 05 00      lea d, [bp + 5] ; $address
3716   1B68 FD 2A         mov d, [d]
3717   1B6A 05 0C         syscall sys_system
3718   1B6C FA 00 00      lea d, [bp + 0] ; $data
3719   1B6F FD 3E         mov [d], bl
3720   1B71             ; --- END INLINE ASM SEGMENT
3721   1B71             
3722   1B71             ; return data; 
3723   1B71 FA 00 00      lea d, [bp + 0] ; $data
3724   1B74 32            mov bl, [d]
3725   1B75 A7 00         mov bh, 0
3726   1B77 F9            leave
3727   1B78 09            ret
3728   1B79             
3729   1B79             clear:
3730   1B79 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3731   1B7C             ; print("\033[2J\033[H"); 
3732   1B7C 26 31 21      mov b, _s6 ; "\033[2J\033[H"
3733   1B7F FD AB         swp b
3734   1B81 D8            push b
3735   1B82 07 50 1B      call print
3736   1B85 51 02 00      add sp, 2
3737   1B88 F9            leave
3738   1B89 09            ret
3739   1B8A             
3740   1B8A             abs:
3741   1B8A F8 00 00      enter 0 ; (push bp; mov bp, sp)
3742   1B8D             ; return i < 0 ? -i : i; 
3743   1B8D             _ternary55_cond:
3744   1B8D FA 05 00      lea d, [bp + 5] ; $i
3745   1B90 2A            mov b, [d]
3746   1B91             ; --- START RELATIONAL
3747   1B91 D7            push a
3748   1B92 11            mov a, b
3749   1B93 26 00 00      mov b, $0
3750   1B96 B0            cmp a, b
3751   1B97 FD 73         slt ; < (signed)
3752   1B99 E4            pop a
3753   1B9A             ; --- END RELATIONAL
3754   1B9A C0 00 00      cmp b, 0
3755   1B9D C6 A9 1B      je _ternary55_false
3756   1BA0             _ternary55_true:
3757   1BA0 FA 05 00      lea d, [bp + 5] ; $i
3758   1BA3 2A            mov b, [d]
3759   1BA4 FD 97         neg b
3760   1BA6 0A AD 1B      jmp _ternary55_exit
3761   1BA9             _ternary55_false:
3762   1BA9 FA 05 00      lea d, [bp + 5] ; $i
3763   1BAC 2A            mov b, [d]
3764   1BAD             _ternary55_exit:
3765   1BAD F9            leave
3766   1BAE 09            ret
3767   1BAF             
3768   1BAF             loadfile:
3769   1BAF F8 00 00      enter 0 ; (push bp; mov bp, sp)
3770   1BB2             
3771   1BB2             ; --- BEGIN INLINE ASM SEGMENT
3772   1BB2 FA 07 00      lea d, [bp + 7] ; $destination
3773   1BB5 15            mov a, [d]
3774   1BB6 4F            mov di, a
3775   1BB7 FA 05 00      lea d, [bp + 5] ; $filename
3776   1BBA FD 2A         mov d, [d]
3777   1BBC 19 14         mov al, 20
3778   1BBE 05 04         syscall sys_filesystem
3779   1BC0             ; --- END INLINE ASM SEGMENT
3780   1BC0             
3781   1BC0 F9            leave
3782   1BC1 09            ret
3783   1BC2             
3784   1BC2             create_file:
3785   1BC2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3786   1BC5 F9            leave
3787   1BC6 09            ret
3788   1BC7             
3789   1BC7             delete_file:
3790   1BC7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3791   1BCA             
3792   1BCA             ; --- BEGIN INLINE ASM SEGMENT
3793   1BCA FA 05 00      lea d, [bp + 5] ; $filename
3794   1BCD 19 0A         mov al, 10
3795   1BCF 05 04         syscall sys_filesystem
3796   1BD1             ; --- END INLINE ASM SEGMENT
3797   1BD1             
3798   1BD1 F9            leave
3799   1BD2 09            ret
3800   1BD3             
3801   1BD3             load_hex:
3802   1BD3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3803   1BD6             ; char *temp; 
3804   1BD6 52 02 00      sub sp, 2
3805   1BD9             ; temp = alloc(32768); 
3806   1BD9 FA FF FF      lea d, [bp + -1] ; $temp
3807   1BDC DA            push d
3808   1BDD 26 00 80      mov b, $8000
3809   1BE0 FD AB         swp b
3810   1BE2 D8            push b
3811   1BE3 07 8D 07      call alloc
3812   1BE6 51 02 00      add sp, 2
3813   1BE9 E7            pop d
3814   1BEA FD 43         mov [d], b
3815   1BEC             
3816   1BEC             ; --- BEGIN INLINE ASM SEGMENT
3817   1BEC               
3818   1BEC               
3819   1BEC               
3820   1BEC             _load_hex:
3821   1BEC FA 05 00      lea d, [bp + 5] ; $destination
3822   1BEF FD 2A         mov d, [d]
3823   1BF1 FD 50         mov di, d
3824   1BF3 FA FF FF      lea d, [bp + -1] ; $temp
3825   1BF6 FD 2A         mov d, [d]
3826   1BF8 38 00 00      mov c, 0
3827   1BFB 48            mov a, sp
3828   1BFC 77            inc a
3829   1BFD 3C            mov d, a          
3830   1BFE 07 06 1D      call _gets        
3831   1C01 4D            mov si, a
3832   1C02             __load_hex_loop:
3833   1C02 F6            lodsb             
3834   1C03 B9 00         cmp al, 0         
3835   1C05 C6 13 1C      jz __load_hex_ret
3836   1C08 36            mov bh, al
3837   1C09 F6            lodsb
3838   1C0A 2F            mov bl, al
3839   1C0B 07 BD 1C      call _atoi        
3840   1C0E F7            stosb             
3841   1C0F 78            inc c
3842   1C10 0A 02 1C      jmp __load_hex_loop
3843   1C13             __load_hex_ret:
3844   1C13             ; --- END INLINE ASM SEGMENT
3845   1C13             
3846   1C13 F9            leave
3847   1C14 09            ret
3848   1C15             
3849   1C15             include_stdio_asm:
3850   1C15 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3851   1C18             
3852   1C18             ; --- BEGIN INLINE ASM SEGMENT
3853   1C18             .include "lib/asm/stdio.asm"
0001+  1C18             ;-----------------------------------------------------------------------------
0002+  1C18             ; stdio.s
0003+  1C18             ;-----------------------------------------------------------------------------
0004+  1C18             .include "lib/asm/string.asm"
0001++ 1C18             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 1C18             ; string.s
0003++ 1C18             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 1C18             
0005++ 1C18             
0006++ 1C18             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 1C18             ; _strrev
0008++ 1C18             ; reverse a string
0009++ 1C18             ; D = string address
0010++ 1C18             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 1C18             ; 01234
0012++ 1C18             _strrev:
0013++ 1C18 4B          	pusha
0014++ 1C19 07 5F 1C    	call _strlen	; length in C
0015++ 1C1C 12          	mov a, c
0016++ 1C1D AF 01 00    	cmp a, 1
0017++ 1C20 D0 3A 1C    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 1C23 7D          	dec a
0019++ 1C24 FD 4E       	mov si, d	; beginning of string
0020++ 1C26 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 1C28 59          	add d, a	; end of string
0022++ 1C29 12          	mov a, c
0023++ 1C2A FD 9B       	shr a		; divide by 2
0024++ 1C2C 39          	mov c, a	; C now counts the steps
0025++ 1C2D             _strrev_L0:
0026++ 1C2D 32          	mov bl, [d]	; save load right-side char into BL
0027++ 1C2E F6          	lodsb		; load left-side char into AL; increase SI
0028++ 1C2F 3E          	mov [d], al	; store left char into right side
0029++ 1C30 1B          	mov al, bl
0030++ 1C31 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 1C32 7E          	dec c
0032++ 1C33 7F          	dec d
0033++ 1C34 C2 00 00    	cmp c, 0
0034++ 1C37 C7 2D 1C    	jne _strrev_L0
0035++ 1C3A             _strrev_end:
0036++ 1C3A 4C          	popa
0037++ 1C3B 09          	ret
0038++ 1C3C             	
0039++ 1C3C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 1C3C             ; _strchr
0041++ 1C3C             ; search string in D for char in AL
0042++ 1C3C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 1C3C             _strchr:
0044++ 1C3C             _strchr_L0:
0045++ 1C3C 32          	mov bl, [d]
0046++ 1C3D C1 00       	cmp bl, 0
0047++ 1C3F C6 4A 1C    	je _strchr_end
0048++ 1C42 BA          	cmp al, bl
0049++ 1C43 C6 4A 1C    	je _strchr_end
0050++ 1C46 79          	inc d
0051++ 1C47 0A 3C 1C    	jmp _strchr_L0
0052++ 1C4A             _strchr_end:
0053++ 1C4A 1B          	mov al, bl
0054++ 1C4B 09          	ret
0055++ 1C4C             
0056++ 1C4C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 1C4C             ; _strstr
0058++ 1C4C             ; find sub-string
0059++ 1C4C             ; str1 in SI
0060++ 1C4C             ; str2 in DI
0061++ 1C4C             ; SI points to end of source string
0062++ 1C4C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 1C4C             _strstr:
0064++ 1C4C DB          	push al
0065++ 1C4D DA          	push d
0066++ 1C4E E3          	push di
0067++ 1C4F             _strstr_loop:
0068++ 1C4F F3          	cmpsb					; compare a byte of the strings
0069++ 1C50 C7 5B 1C    	jne _strstr_ret
0070++ 1C53 FC 00 00    	lea d, [di + 0]
0071++ 1C56 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1C58 C7 4F 1C    	jne _strstr_loop				; equal chars but not at end
0073++ 1C5B             _strstr_ret:
0074++ 1C5B F0          	pop di
0075++ 1C5C E7          	pop d
0076++ 1C5D E8          	pop al
0077++ 1C5E 09          	ret
0078++ 1C5F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1C5F             ; length of null terminated string
0080++ 1C5F             ; result in C
0081++ 1C5F             ; pointer in D
0082++ 1C5F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1C5F             _strlen:
0084++ 1C5F DA          	push d
0085++ 1C60 38 00 00    	mov c, 0
0086++ 1C63             _strlen_L1:
0087++ 1C63 BD 00       	cmp byte [d], 0
0088++ 1C65 C6 6D 1C    	je _strlen_ret
0089++ 1C68 79          	inc d
0090++ 1C69 78          	inc c
0091++ 1C6A 0A 63 1C    	jmp _strlen_L1
0092++ 1C6D             _strlen_ret:
0093++ 1C6D E7          	pop d
0094++ 1C6E 09          	ret
0095++ 1C6F             
0096++ 1C6F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1C6F             ; STRCMP
0098++ 1C6F             ; compare two strings
0099++ 1C6F             ; str1 in SI
0100++ 1C6F             ; str2 in DI
0101++ 1C6F             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 1C6F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1C6F             _strcmp:
0104++ 1C6F DB          	push al
0105++ 1C70 DA          	push d
0106++ 1C71 E3          	push di
0107++ 1C72 E2          	push si
0108++ 1C73             _strcmp_loop:
0109++ 1C73 F3          	cmpsb					; compare a byte of the strings
0110++ 1C74 C7 7F 1C    	jne _strcmp_ret
0111++ 1C77 FB FF FF    	lea d, [si +- 1]
0112++ 1C7A BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1C7C C7 73 1C    	jne _strcmp_loop				; equal chars but not at end
0114++ 1C7F             _strcmp_ret:
0115++ 1C7F EF          	pop si
0116++ 1C80 F0          	pop di
0117++ 1C81 E7          	pop d
0118++ 1C82 E8          	pop al
0119++ 1C83 09          	ret
0120++ 1C84             
0121++ 1C84             
0122++ 1C84             ; STRCPY
0123++ 1C84             ; copy null terminated string from SI to DI
0124++ 1C84             ; source in SI
0125++ 1C84             ; destination in DI
0126++ 1C84             _strcpy:
0127++ 1C84 E2          	push si
0128++ 1C85 E3          	push di
0129++ 1C86 DB          	push al
0130++ 1C87             _strcpy_L1:
0131++ 1C87 F6          	lodsb
0132++ 1C88 F7          	stosb
0133++ 1C89 B9 00       	cmp al, 0
0134++ 1C8B C7 87 1C    	jne _strcpy_L1
0135++ 1C8E             _strcpy_end:
0136++ 1C8E E8          	pop al
0137++ 1C8F F0          	pop di
0138++ 1C90 EF          	pop si
0139++ 1C91 09          	ret
0140++ 1C92             
0141++ 1C92             ; STRCAT
0142++ 1C92             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 1C92             ; source in SI
0144++ 1C92             ; destination in DI
0145++ 1C92             _strcat:
0146++ 1C92 E2          	push si
0147++ 1C93 E3          	push di
0148++ 1C94 D7          	push a
0149++ 1C95 DA          	push d
0150++ 1C96 50          	mov a, di
0151++ 1C97 3C          	mov d, a
0152++ 1C98             _strcat_goto_end_L1:
0153++ 1C98 BD 00       	cmp byte[d], 0
0154++ 1C9A C6 A1 1C    	je _strcat_start
0155++ 1C9D 79          	inc d
0156++ 1C9E 0A 98 1C    	jmp _strcat_goto_end_L1
0157++ 1CA1             _strcat_start:
0158++ 1CA1 FD 50       	mov di, d
0159++ 1CA3             _strcat_L1:
0160++ 1CA3 F6          	lodsb
0161++ 1CA4 F7          	stosb
0162++ 1CA5 B9 00       	cmp al, 0
0163++ 1CA7 C7 A3 1C    	jne _strcat_L1
0164++ 1CAA             _strcat_end:
0165++ 1CAA E7          	pop d
0166++ 1CAB E4          	pop a
0167++ 1CAC F0          	pop di
0168++ 1CAD EF          	pop si
0169++ 1CAE 09          	ret
0170++ 1CAF             
0171++ 1CAF             
0005+  1CAF             
0006+  1CAF             ;-----------------------------------------------------------------------------
0007+  1CAF             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0008+  1CAF             ; ASCII in BL
0009+  1CAF             ; result in AL
0010+  1CAF             ; ascii for F = 0100 0110
0011+  1CAF             ; ascii for 9 = 0011 1001
0012+  1CAF             ;-----------------------------------------------------------------------------
0013+  1CAF             hex_ascii_encode:
0014+  1CAF 1B            mov al, bl
0015+  1CB0 93 40         test al, $40        ; test if letter or number
0016+  1CB2 C7 B8 1C      jnz hex_letter
0017+  1CB5 87 0F         and al, $0F        ; get number
0018+  1CB7 09            ret
0019+  1CB8             hex_letter:
0020+  1CB8 87 0F         and al, $0F        ; get letter
0021+  1CBA 6A 09         add al, 9
0022+  1CBC 09            ret
0023+  1CBD             
0024+  1CBD             ;-----------------------------------------------------------------------------
0025+  1CBD             ; ATOI
0026+  1CBD             ; 2 letter hex string in B
0027+  1CBD             ; 8bit integer returned in AL
0028+  1CBD             ;-----------------------------------------------------------------------------
0029+  1CBD             _atoi:
0030+  1CBD D8            push b
0031+  1CBE 07 AF 1C      call hex_ascii_encode      ; convert BL to 4bit code in AL
0032+  1CC1 30            mov bl, bh
0033+  1CC2 DB            push al          ; save a
0034+  1CC3 07 AF 1C      call hex_ascii_encode
0035+  1CC6 EA            pop bl  
0036+  1CC7 FD 9E 04      shl al, 4
0037+  1CCA 8C            or al, bl
0038+  1CCB E5            pop b
0039+  1CCC 09            ret  
0040+  1CCD             
0041+  1CCD             
0042+  1CCD             ;-----------------------------------------------------------------------------
0043+  1CCD             ; ITOA
0044+  1CCD             ; 8bit value in BL
0045+  1CCD             ; 2 byte ASCII result in A
0046+  1CCD             ;-----------------------------------------------------------------------------
0047+  1CCD             _itoa:
0048+  1CCD DA            push d
0049+  1CCE D8            push b
0050+  1CCF A7 00         mov bh, 0
0051+  1CD1 FD A4 04      shr bl, 4  
0052+  1CD4 74            mov d, b
0053+  1CD5 1F 7D 1F      mov al, [d + s_hex_digits]
0054+  1CD8 23            mov ah, al
0055+  1CD9               
0056+  1CD9 E5            pop b
0057+  1CDA D8            push b
0058+  1CDB A7 00         mov bh, 0
0059+  1CDD FD 87 0F      and bl, $0F
0060+  1CE0 74            mov d, b
0061+  1CE1 1F 7D 1F      mov al, [d + s_hex_digits]
0062+  1CE4 E5            pop b
0063+  1CE5 E7            pop d
0064+  1CE6 09            ret
0065+  1CE7             
0066+  1CE7             ;-----------------------------------------------------------------------------
0067+  1CE7             ; HEX STRING TO BINARY
0068+  1CE7             ; di = destination address
0069+  1CE7             ; si = source
0070+  1CE7             ;-----------------------------------------------------------------------------
0071+  1CE7             _hex_to_int:
0072+  1CE7             _hex_to_int_L1:
0073+  1CE7 F6            lodsb          ; load from [SI] to AL
0074+  1CE8 B9 00         cmp al, 0        ; check if ASCII 0
0075+  1CEA C6 F7 1C      jz _hex_to_int_ret
0076+  1CED 36            mov bh, al
0077+  1CEE F6            lodsb
0078+  1CEF 2F            mov bl, al
0079+  1CF0 07 BD 1C      call _atoi        ; convert ASCII byte in B to int (to AL)
0080+  1CF3 F7            stosb          ; store AL to [DI]
0081+  1CF4 0A E7 1C      jmp _hex_to_int_L1
0082+  1CF7             _hex_to_int_ret:
0083+  1CF7 09            ret    
0084+  1CF8             
0085+  1CF8             ;-----------------------------------------------------------------------------
0086+  1CF8             ; GETCHAR
0087+  1CF8             ; char in ah
0088+  1CF8             ;-----------------------------------------------------------------------------
0089+  1CF8             getch:
0090+  1CF8 DB            push al
0091+  1CF9             getch_retry:
0092+  1CF9 19 01         mov al, 1
0093+  1CFB 05 03         syscall sys_io      ; receive in AH
0094+  1CFD E8            pop al
0095+  1CFE 09            ret
0096+  1CFF             
0097+  1CFF             ;-----------------------------------------------------------------------------
0098+  1CFF             ; PUTCHAR
0099+  1CFF             ; char in ah
0100+  1CFF             ;-----------------------------------------------------------------------------
0101+  1CFF             _putchar:
0102+  1CFF D7            push a
0103+  1D00 19 00         mov al, 0
0104+  1D02 05 03         syscall sys_io      ; char in AH
0105+  1D04 E4            pop a
0106+  1D05 09            ret
0107+  1D06             
0108+  1D06             ;-----------------------------------------------------------------------------
0109+  1D06             ;; INPUT A STRING
0110+  1D06             ;; terminates with null
0111+  1D06             ;; pointer in D
0112+  1D06             ;-----------------------------------------------------------------------------
0113+  1D06             _gets:
0114+  1D06 D7            push a
0115+  1D07 DA            push d
0116+  1D08             _gets_loop:
0117+  1D08 19 01         mov al, 1
0118+  1D0A 05 03         syscall sys_io      ; receive in AH
0119+  1D0C B9 00         cmp al, 0        ; check error code (AL)
0120+  1D0E C6 08 1D      je _gets_loop      ; if no char received, retry
0121+  1D11             
0122+  1D11 76 1B         cmp ah, 27
0123+  1D13 C6 34 1D      je _gets_ansi_esc
0124+  1D16 76 0A         cmp ah, $0A        ; LF
0125+  1D18 C6 9F 1D      je _gets_end
0126+  1D1B 76 0D         cmp ah, $0D        ; CR
0127+  1D1D C6 9F 1D      je _gets_end
0128+  1D20 76 5C         cmp ah, $5C        ; '\\'
0129+  1D22 C6 60 1D      je _gets_escape
0130+  1D25               
0131+  1D25 76 08         cmp ah, $08      ; check for backspace
0132+  1D27 C6 30 1D      je _gets_backspace
0133+  1D2A             
0134+  1D2A 1A            mov al, ah
0135+  1D2B 3E            mov [d], al
0136+  1D2C 79            inc d
0137+  1D2D 0A 08 1D      jmp _gets_loop
0138+  1D30             _gets_backspace:
0139+  1D30 7F            dec d
0140+  1D31 0A 08 1D      jmp _gets_loop
0141+  1D34             _gets_ansi_esc:
0142+  1D34 19 01         mov al, 1
0143+  1D36 05 03         syscall sys_io        ; receive in AH without echo
0144+  1D38 B9 00         cmp al, 0          ; check error code (AL)
0145+  1D3A C6 34 1D      je _gets_ansi_esc    ; if no char received, retry
0146+  1D3D 76 5B         cmp ah, '['
0147+  1D3F C7 08 1D      jne _gets_loop
0148+  1D42             _gets_ansi_esc_2:
0149+  1D42 19 01         mov al, 1
0150+  1D44 05 03         syscall sys_io          ; receive in AH without echo
0151+  1D46 B9 00         cmp al, 0            ; check error code (AL)
0152+  1D48 C6 42 1D      je _gets_ansi_esc_2  ; if no char received, retry
0153+  1D4B 76 44         cmp ah, 'D'
0154+  1D4D C6 58 1D      je _gets_left_arrow
0155+  1D50 76 43         cmp ah, 'C'
0156+  1D52 C6 5C 1D      je _gets_right_arrow
0157+  1D55 0A 08 1D      jmp _gets_loop
0158+  1D58             _gets_left_arrow:
0159+  1D58 7F            dec d
0160+  1D59 0A 08 1D      jmp _gets_loop
0161+  1D5C             _gets_right_arrow:
0162+  1D5C 79            inc d
0163+  1D5D 0A 08 1D      jmp _gets_loop
0164+  1D60             _gets_escape:
0165+  1D60 19 01         mov al, 1
0166+  1D62 05 03         syscall sys_io      ; receive in AH
0167+  1D64 B9 00         cmp al, 0        ; check error code (AL)
0168+  1D66 C6 60 1D      je _gets_escape      ; if no char received, retry
0169+  1D69 76 6E         cmp ah, 'n'
0170+  1D6B C6 8A 1D      je _gets_LF
0171+  1D6E 76 72         cmp ah, 'r'
0172+  1D70 C6 91 1D      je _gets_CR
0173+  1D73 76 30         cmp ah, '0'
0174+  1D75 C6 98 1D      je _gets_NULL
0175+  1D78 76 5C         cmp ah, $5C  ; '\'
0176+  1D7A C6 83 1D      je _gets_slash
0177+  1D7D 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0178+  1D7E 3E            mov [d], al
0179+  1D7F 79            inc d
0180+  1D80 0A 08 1D      jmp _gets_loop
0181+  1D83             _gets_slash:
0182+  1D83 19 5C         mov al, $5C
0183+  1D85 3E            mov [d], al
0184+  1D86 79            inc d
0185+  1D87 0A 08 1D      jmp _gets_loop
0186+  1D8A             _gets_LF:
0187+  1D8A 19 0A         mov al, $0A
0188+  1D8C 3E            mov [d], al
0189+  1D8D 79            inc d
0190+  1D8E 0A 08 1D      jmp _gets_loop
0191+  1D91             _gets_CR:
0192+  1D91 19 0D         mov al, $0D
0193+  1D93 3E            mov [d], al
0194+  1D94 79            inc d
0195+  1D95 0A 08 1D      jmp _gets_loop
0196+  1D98             _gets_NULL:
0197+  1D98 19 00         mov al, $00
0198+  1D9A 3E            mov [d], al
0199+  1D9B 79            inc d
0200+  1D9C 0A 08 1D      jmp _gets_loop
0201+  1D9F             _gets_end:
0202+  1D9F 19 00         mov al, 0
0203+  1DA1 3E            mov [d], al        ; terminate string
0204+  1DA2 E7            pop d
0205+  1DA3 E4            pop a
0206+  1DA4 09            ret
0207+  1DA5             
0208+  1DA5             ;-----------------------------------------------------------------------------
0209+  1DA5             ;; INPUT TEXT
0210+  1DA5             ;; terminated with CTRL+D
0211+  1DA5             ;; pointer in D
0212+  1DA5             ;-----------------------------------------------------------------------------
0213+  1DA5             _gettxt:
0214+  1DA5 D7            push a
0215+  1DA6 DA            push d
0216+  1DA7             _gettxt_loop:
0217+  1DA7 19 01         mov al, 1
0218+  1DA9 05 03         syscall sys_io      ; receive in AH
0219+  1DAB B9 00         cmp al, 0        ; check error code (AL)
0220+  1DAD C6 A7 1D      je _gettxt_loop    ; if no char received, retry
0221+  1DB0 76 04         cmp ah, 4      ; EOT
0222+  1DB2 C6 F0 1D      je _gettxt_end
0223+  1DB5 76 08         cmp ah, $08      ; check for backspace
0224+  1DB7 C6 EC 1D      je _gettxt_backspace
0225+  1DBA 76 5C         cmp ah, $5C        ; '\'
0226+  1DBC C6 C5 1D      je _gettxt_escape
0227+  1DBF 1A            mov al, ah
0228+  1DC0 3E            mov [d], al
0229+  1DC1 79            inc d
0230+  1DC2 0A A7 1D      jmp _gettxt_loop
0231+  1DC5             _gettxt_escape:
0232+  1DC5 19 01         mov al, 1
0233+  1DC7 05 03         syscall sys_io      ; receive in AH
0234+  1DC9 B9 00         cmp al, 0        ; check error code (AL)
0235+  1DCB C6 C5 1D      je _gettxt_escape    ; if no char received, retry
0236+  1DCE 76 6E         cmp ah, 'n'
0237+  1DD0 C6 DE 1D      je _gettxt_LF
0238+  1DD3 76 72         cmp ah, 'r'
0239+  1DD5 C6 E5 1D      je _gettxt_CR
0240+  1DD8 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0241+  1DD9 3E            mov [d], al
0242+  1DDA 79            inc d
0243+  1DDB 0A A7 1D      jmp _gettxt_loop
0244+  1DDE             _gettxt_LF:
0245+  1DDE 19 0A         mov al, $0A
0246+  1DE0 3E            mov [d], al
0247+  1DE1 79            inc d
0248+  1DE2 0A A7 1D      jmp _gettxt_loop
0249+  1DE5             _gettxt_CR:
0250+  1DE5 19 0D         mov al, $0D
0251+  1DE7 3E            mov [d], al
0252+  1DE8 79            inc d
0253+  1DE9 0A A7 1D      jmp _gettxt_loop
0254+  1DEC             _gettxt_backspace:
0255+  1DEC 7F            dec d
0256+  1DED 0A A7 1D      jmp _gettxt_loop
0257+  1DF0             _gettxt_end:
0258+  1DF0 19 00         mov al, 0
0259+  1DF2 3E            mov [d], al        ; terminate string
0260+  1DF3 E7            pop d
0261+  1DF4 E4            pop a
0262+  1DF5 09            ret
0263+  1DF6             
0264+  1DF6             ;-----------------------------------------------------------------------------
0265+  1DF6             ; PRINT NEW LINE
0266+  1DF6             ;-----------------------------------------------------------------------------
0267+  1DF6             printnl:
0268+  1DF6 D7            push a
0269+  1DF7 10 00 0A      mov a, $0A00
0270+  1DFA 05 03         syscall sys_io
0271+  1DFC 10 00 0D      mov a, $0D00
0272+  1DFF 05 03         syscall sys_io
0273+  1E01 E4            pop a
0274+  1E02 09            ret
0275+  1E03             
0276+  1E03             ;-----------------------------------------------------------------------------
0277+  1E03             ; _strtoint
0278+  1E03             ; 4 digit hex string number in d
0279+  1E03             ; integer returned in A
0280+  1E03             ;-----------------------------------------------------------------------------
0281+  1E03             _strtointx:
0282+  1E03 D8            push b
0283+  1E04 32            mov bl, [d]
0284+  1E05 37            mov bh, bl
0285+  1E06 33 01 00      mov bl, [d + 1]
0286+  1E09 07 BD 1C      call _atoi        ; convert to int in AL
0287+  1E0C 23            mov ah, al        ; move to AH
0288+  1E0D 33 02 00      mov bl, [d + 2]
0289+  1E10 37            mov bh, bl
0290+  1E11 33 03 00      mov bl, [d + 3]
0291+  1E14 07 BD 1C      call _atoi        ; convert to int in AL
0292+  1E17 E5            pop b
0293+  1E18 09            ret
0294+  1E19             
0295+  1E19             ;-----------------------------------------------------------------------------
0296+  1E19             ; _strtoint
0297+  1E19             ; 5 digit base10 string number in d
0298+  1E19             ; integer returned in A
0299+  1E19             ;-----------------------------------------------------------------------------
0300+  1E19             _strtoint:
0301+  1E19 E2            push si
0302+  1E1A D8            push b
0303+  1E1B D9            push c
0304+  1E1C DA            push d
0305+  1E1D 07 5F 1C      call _strlen      ; get string length in C
0306+  1E20 7E            dec c
0307+  1E21 FD 4E         mov si, d
0308+  1E23 12            mov a, c
0309+  1E24 FD 99         shl a
0310+  1E26 3B 95 1F      mov d, table_power
0311+  1E29 59            add d, a
0312+  1E2A 38 00 00      mov c, 0
0313+  1E2D             _strtoint_L0:
0314+  1E2D F6            lodsb      ; load ASCII to al
0315+  1E2E B9 00         cmp al, 0
0316+  1E30 C6 43 1E      je _strtoint_end
0317+  1E33 6F 30         sub al, $30    ; make into integer
0318+  1E35 22 00         mov ah, 0
0319+  1E37 2A            mov b, [d]
0320+  1E38 AC            mul a, b      ; result in B since it fits in 16bits
0321+  1E39 11            mov a, b
0322+  1E3A 28            mov b, c
0323+  1E3B 54            add a, b
0324+  1E3C 39            mov c, a
0325+  1E3D 63 02 00      sub d, 2
0326+  1E40 0A 2D 1E      jmp _strtoint_L0
0327+  1E43             _strtoint_end:
0328+  1E43 12            mov a, c
0329+  1E44 E7            pop d
0330+  1E45 E6            pop c
0331+  1E46 E5            pop b
0332+  1E47 EF            pop si
0333+  1E48 09            ret
0334+  1E49             
0335+  1E49             ;-----------------------------------------------------------------------------
0336+  1E49             ; PRINT NULL TERMINATED STRING
0337+  1E49             ; pointer in D
0338+  1E49             ;-----------------------------------------------------------------------------
0339+  1E49             _puts:
0340+  1E49 D7            push a
0341+  1E4A DA            push d
0342+  1E4B             _puts_L1:
0343+  1E4B 1E            mov al, [d]
0344+  1E4C B9 00         cmp al, 0
0345+  1E4E C6 5A 1E      jz _puts_END
0346+  1E51 23            mov ah, al
0347+  1E52 19 00         mov al, 0
0348+  1E54 05 03         syscall sys_io
0349+  1E56 79            inc d
0350+  1E57 0A 4B 1E      jmp _puts_L1
0351+  1E5A             _puts_END:
0352+  1E5A E7            pop d
0353+  1E5B E4            pop a
0354+  1E5C 09            ret
0355+  1E5D             
0356+  1E5D             ;-----------------------------------------------------------------------------
0357+  1E5D             ; PRINT N SIZE STRING
0358+  1E5D             ; pointer in D
0359+  1E5D             ; size in C
0360+  1E5D             ;-----------------------------------------------------------------------------
0361+  1E5D             _putsn:
0362+  1E5D DB            push al
0363+  1E5E DA            push d
0364+  1E5F D9            push c
0365+  1E60             _putsn_L0:
0366+  1E60 1E            mov al, [d]
0367+  1E61 23            mov ah, al
0368+  1E62 19 00         mov al, 0
0369+  1E64 05 03         syscall sys_io
0370+  1E66 79            inc d
0371+  1E67 7E            dec c  
0372+  1E68 C2 00 00      cmp c, 0
0373+  1E6B C7 60 1E      jne _putsn_L0
0374+  1E6E             _putsn_end:
0375+  1E6E E6            pop c
0376+  1E6F E7            pop d
0377+  1E70 E8            pop al
0378+  1E71 09            ret
0379+  1E72             
0380+  1E72             ;-----------------------------------------------------------------------------
0381+  1E72             ; print 16bit decimal number
0382+  1E72             ; input number in A
0383+  1E72             ;-----------------------------------------------------------------------------
0384+  1E72             print_u16d:
0385+  1E72 D7            push a
0386+  1E73 D8            push b
0387+  1E74 26 10 27      mov b, 10000
0388+  1E77 AE            div a, b      ; get 10000's coeff.
0389+  1E78 07 9A 1E      call print_number
0390+  1E7B 11            mov a, b
0391+  1E7C 26 E8 03      mov b, 1000
0392+  1E7F AE            div a, b      ; get 1000's coeff.
0393+  1E80 07 9A 1E      call print_number
0394+  1E83 11            mov a, b
0395+  1E84 26 64 00      mov b, 100
0396+  1E87 AE            div a, b
0397+  1E88 07 9A 1E      call print_number
0398+  1E8B 11            mov a, b
0399+  1E8C 26 0A 00      mov b, 10
0400+  1E8F AE            div a, b
0401+  1E90 07 9A 1E      call print_number
0402+  1E93 1B            mov al, bl      ; 1's coeff in bl
0403+  1E94 07 9A 1E      call print_number
0404+  1E97 E5            pop b
0405+  1E98 E4            pop a
0406+  1E99 09            ret
0407+  1E9A             
0408+  1E9A             ;-----------------------------------------------------------------------------
0409+  1E9A             ; print AL
0410+  1E9A             ;-----------------------------------------------------------------------------
0411+  1E9A             print_number:
0412+  1E9A 6A 30         add al, $30
0413+  1E9C 23            mov ah, al
0414+  1E9D 07 FF 1C      call _putchar
0415+  1EA0 09            ret
0416+  1EA1             
0417+  1EA1             ;-----------------------------------------------------------------------------
0418+  1EA1             ; PRINT 16BIT HEX INTEGER
0419+  1EA1             ; integer value in reg B
0420+  1EA1             ;-----------------------------------------------------------------------------
0421+  1EA1             print_u16x:
0422+  1EA1 D7            push a
0423+  1EA2 D8            push b
0424+  1EA3 DD            push bl
0425+  1EA4 30            mov bl, bh
0426+  1EA5 07 CD 1C      call _itoa        ; convert bh to char in A
0427+  1EA8 2F            mov bl, al        ; save al
0428+  1EA9 19 00         mov al, 0
0429+  1EAB 05 03         syscall sys_io        ; display AH
0430+  1EAD 24            mov ah, bl        ; retrieve al
0431+  1EAE 19 00         mov al, 0
0432+  1EB0 05 03         syscall sys_io        ; display AL
0433+  1EB2             
0434+  1EB2 EA            pop bl
0435+  1EB3 07 CD 1C      call _itoa        ; convert bh to char in A
0436+  1EB6 2F            mov bl, al        ; save al
0437+  1EB7 19 00         mov al, 0
0438+  1EB9 05 03         syscall sys_io        ; display AH
0439+  1EBB 24            mov ah, bl        ; retrieve al
0440+  1EBC 19 00         mov al, 0
0441+  1EBE 05 03         syscall sys_io        ; display AL
0442+  1EC0             
0443+  1EC0 E5            pop b
0444+  1EC1 E4            pop a
0445+  1EC2 09            ret
0446+  1EC3             
0447+  1EC3             ;-----------------------------------------------------------------------------
0448+  1EC3             ; INPUT 16BIT HEX INTEGER
0449+  1EC3             ; read 16bit integer into A
0450+  1EC3             ;-----------------------------------------------------------------------------
0451+  1EC3             scan_u16x:
0452+  1EC3 F8 10 00      enter 16
0453+  1EC6 D8            push b
0454+  1EC7 DA            push d
0455+  1EC8             
0456+  1EC8 FA F1 FF      lea d, [bp + -15]
0457+  1ECB 07 06 1D      call _gets        ; get number
0458+  1ECE             
0459+  1ECE 32            mov bl, [d]
0460+  1ECF 37            mov bh, bl
0461+  1ED0 33 01 00      mov bl, [d + 1]
0462+  1ED3 07 BD 1C      call _atoi        ; convert to int in AL
0463+  1ED6 23            mov ah, al        ; move to AH
0464+  1ED7             
0465+  1ED7 33 02 00      mov bl, [d + 2]
0466+  1EDA 37            mov bh, bl
0467+  1EDB 33 03 00      mov bl, [d + 3]
0468+  1EDE 07 BD 1C      call _atoi        ; convert to int in AL
0469+  1EE1             
0470+  1EE1 E7            pop d
0471+  1EE2 E5            pop b
0472+  1EE3 F9            leave
0473+  1EE4 09            ret
0474+  1EE5             
0475+  1EE5             ;-----------------------------------------------------------------------------
0476+  1EE5             ; PRINT 8bit HEX INTEGER
0477+  1EE5             ; integer value in reg bl
0478+  1EE5             ;-----------------------------------------------------------------------------
0479+  1EE5             print_u8x:
0480+  1EE5 D7            push a
0481+  1EE6 DD            push bl
0482+  1EE7             
0483+  1EE7 07 CD 1C      call _itoa        ; convert bl to char in A
0484+  1EEA 2F            mov bl, al        ; save al
0485+  1EEB 19 00         mov al, 0
0486+  1EED 05 03         syscall sys_io        ; display AH
0487+  1EEF 24            mov ah, bl        ; retrieve al
0488+  1EF0 19 00         mov al, 0
0489+  1EF2 05 03         syscall sys_io        ; display AL
0490+  1EF4             
0491+  1EF4 EA            pop bl
0492+  1EF5 E4            pop a
0493+  1EF6 09            ret
0494+  1EF7             
0495+  1EF7             ;-----------------------------------------------------------------------------
0496+  1EF7             ; print 8bit decimal unsigned number
0497+  1EF7             ; input number in AL
0498+  1EF7             ;-----------------------------------------------------------------------------
0499+  1EF7             print_u8d:
0500+  1EF7 D7            push a
0501+  1EF8 D8            push b
0502+  1EF9             
0503+  1EF9 22 00         mov ah, 0
0504+  1EFB 26 64 00      mov b, 100
0505+  1EFE AE            div a, b
0506+  1EFF D8            push b      ; save remainder
0507+  1F00 B9 00         cmp al, 0
0508+  1F02 C6 0C 1F      je skip100
0509+  1F05 6A 30         add al, $30
0510+  1F07 23            mov ah, al
0511+  1F08 19 00         mov al, 0
0512+  1F0A 05 03         syscall sys_io  ; print coeff
0513+  1F0C             skip100:
0514+  1F0C E4            pop a
0515+  1F0D 22 00         mov ah, 0
0516+  1F0F 26 0A 00      mov b, 10
0517+  1F12 AE            div a, b
0518+  1F13 D8            push b      ; save remainder
0519+  1F14 B9 00         cmp al, 0
0520+  1F16 C6 20 1F      je skip10
0521+  1F19 6A 30         add al, $30
0522+  1F1B 23            mov ah, al
0523+  1F1C 19 00         mov al, 0
0524+  1F1E 05 03         syscall sys_io  ; print coeff
0525+  1F20             skip10:
0526+  1F20 E4            pop a
0527+  1F21 1B            mov al, bl
0528+  1F22 6A 30         add al, $30
0529+  1F24 23            mov ah, al
0530+  1F25 19 00         mov al, 0
0531+  1F27 05 03         syscall sys_io  ; print coeff
0532+  1F29 E5            pop b
0533+  1F2A E4            pop a
0534+  1F2B 09            ret
0535+  1F2C             
0536+  1F2C             ;-----------------------------------------------------------------------------
0537+  1F2C             ; INPUT 8BIT HEX INTEGER
0538+  1F2C             ; read 8bit integer into AL
0539+  1F2C             ;-----------------------------------------------------------------------------
0540+  1F2C             scan_u8x:
0541+  1F2C F8 04 00      enter 4
0542+  1F2F D8            push b
0543+  1F30 DA            push d
0544+  1F31             
0545+  1F31 FA FD FF      lea d, [bp + -3]
0546+  1F34 07 06 1D      call _gets        ; get number
0547+  1F37             
0548+  1F37 32            mov bl, [d]
0549+  1F38 37            mov bh, bl
0550+  1F39 33 01 00      mov bl, [d + 1]
0551+  1F3C 07 BD 1C      call _atoi        ; convert to int in AL
0552+  1F3F             
0553+  1F3F E7            pop d
0554+  1F40 E5            pop b
0555+  1F41 F9            leave
0556+  1F42 09            ret
0557+  1F43             
0558+  1F43             ;-----------------------------------------------------------------------------
0559+  1F43             ; input decimal number
0560+  1F43             ; result in A
0561+  1F43             ; 655'\0'
0562+  1F43             ; low--------high
0563+  1F43             ;-----------------------------------------------------------------------------
0564+  1F43             scan_u16d:
0565+  1F43 F8 08 00      enter 8
0566+  1F46 E2            push si
0567+  1F47 D8            push b
0568+  1F48 D9            push c
0569+  1F49 DA            push d
0570+  1F4A FA F9 FF      lea d, [bp +- 7]
0571+  1F4D 07 06 1D      call _gets
0572+  1F50 07 5F 1C      call _strlen      ; get string length in C
0573+  1F53 7E            dec c
0574+  1F54 FD 4E         mov si, d
0575+  1F56 12            mov a, c
0576+  1F57 FD 99         shl a
0577+  1F59 3B 95 1F      mov d, table_power
0578+  1F5C 59            add d, a
0579+  1F5D 38 00 00      mov c, 0
0580+  1F60             mul_loop:
0581+  1F60 F6            lodsb      ; load ASCII to al
0582+  1F61 B9 00         cmp al, 0
0583+  1F63 C6 76 1F      je mul_exit
0584+  1F66 6F 30         sub al, $30    ; make into integer
0585+  1F68 22 00         mov ah, 0
0586+  1F6A 2A            mov b, [d]
0587+  1F6B AC            mul a, b      ; result in B since it fits in 16bits
0588+  1F6C 11            mov a, b
0589+  1F6D 28            mov b, c
0590+  1F6E 54            add a, b
0591+  1F6F 39            mov c, a
0592+  1F70 63 02 00      sub d, 2
0593+  1F73 0A 60 1F      jmp mul_loop
0594+  1F76             mul_exit:
0595+  1F76 12            mov a, c
0596+  1F77 E7            pop d
0597+  1F78 E6            pop c
0598+  1F79 E5            pop b
0599+  1F7A EF            pop si
0600+  1F7B F9            leave
0601+  1F7C 09            ret
0602+  1F7D             
0603+  1F7D 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0603+  1F81 34 35 36 37 
0603+  1F85 38 39 41 42 
0603+  1F89 43 44 45 46 
0604+  1F8D 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0604+  1F91 1B 5B 48 00 
0605+  1F95             
0606+  1F95             table_power:
0607+  1F95 01 00         .dw 1
0608+  1F97 0A 00         .dw 10
0609+  1F99 64 00         .dw 100
0610+  1F9B E8 03         .dw 1000
0611+  1F9D 10 27         .dw 100003854   1F9F             ; --- END INLINE ASM SEGMENT
3855   1F9F             
3856   1F9F F9            leave
3857   1FA0 09            ret
3858   1FA1             ; --- END TEXT SEGMENT
3859   1FA1             
3860   1FA1             ; --- BEGIN DATA SEGMENT
3861   1FA1 00 00 00 00 _s_data: .fill 256, 0
3861   1FA5 00 00 00 00 
3861   1FA9 00 00 00 00 
3861   1FAD 00 00 00 00 
3861   1FB1 00 00 00 00 
3861   1FB5 00 00 00 00 
3861   1FB9 00 00 00 00 
3861   1FBD 00 00 00 00 
3861   1FC1 00 00 00 00 
3861   1FC5 00 00 00 00 
3861   1FC9 00 00 00 00 
3861   1FCD 00 00 00 00 
3861   1FD1 00 00 00 00 
3861   1FD5 00 00 00 00 
3861   1FD9 00 00 00 00 
3861   1FDD 00 00 00 00 
3861   1FE1 00 00 00 00 
3861   1FE5 00 00 00 00 
3861   1FE9 00 00 00 00 
3861   1FED 00 00 00 00 
3861   1FF1 00 00 00 00 
3861   1FF5 00 00 00 00 
3861   1FF9 00 00 00 00 
3861   1FFD 00 00 00 00 
3861   2001 00 00 00 00 
3861   2005 00 00 00 00 
3861   2009 00 00 00 00 
3861   200D 00 00 00 00 
3861   2011 00 00 00 00 
3861   2015 00 00 00 00 
3861   2019 00 00 00 00 
3861   201D 00 00 00 00 
3861   2021 00 00 00 00 
3861   2025 00 00 00 00 
3861   2029 00 00 00 00 
3861   202D 00 00 00 00 
3861   2031 00 00 00 00 
3861   2035 00 00 00 00 
3861   2039 00 00 00 00 
3861   203D 00 00 00 00 
3861   2041 00 00 00 00 
3861   2045 00 00 00 00 
3861   2049 00 00 00 00 
3861   204D 00 00 00 00 
3861   2051 00 00 00 00 
3861   2055 00 00 00 00 
3861   2059 00 00 00 00 
3861   205D 00 00 00 00 
3861   2061 00 00 00 00 
3861   2065 00 00 00 00 
3861   2069 00 00 00 00 
3861   206D 00 00 00 00 
3861   2071 00 00 00 00 
3861   2075 00 00 00 00 
3861   2079 00 00 00 00 
3861   207D 00 00 00 00 
3861   2081 00 00 00 00 
3861   2085 00 00 00 00 
3861   2089 00 00 00 00 
3861   208D 00 00 00 00 
3861   2091 00 00 00 00 
3861   2095 00 00 00 00 
3861   2099 00 00 00 00 
3861   209D 00 00 00 00 
3862   20A1             _ss_data: 
3863   20A1 AD          .db _s0, 
3864   20A2 00 00 00 00 .fill 9, 0
3864   20A6 00 00 00 00 
3864   20AA 00 
3865   20AB 00 00       st_fopen_max_handle: .dw 0
3866   20AD 48 65 6C 6C _s0: .db "Hello", 0
3866   20B1 6F 00 
3867   20B3 48 65 6C 6C _s1: .db "Hello World!", 0
3867   20B7 6F 20 57 6F 
3867   20BB 72 6C 64 21 
3867   20BF 00 
3868   20C0 49 6E 74 65 _s2: .db "Integer: %d, Char: %c, String: %s\n\n", 0
3868   20C4 67 65 72 3A 
3868   20C8 20 25 64 2C 
3868   20CC 20 43 68 61 
3868   20D0 72 3A 20 25 
3868   20D4 63 2C 20 53 
3868   20D8 74 72 69 6E 
3868   20DC 67 3A 20 25 
3868   20E0 73 0A 0A 00 
3869   20E4 46 69 6E 61 _s3: .db "Final String: %s", 0
3869   20E8 6C 20 53 74 
3869   20EC 72 69 6E 67 
3869   20F0 3A 20 25 73 
3869   20F4 00 
3870   20F5 55 6E 65 78 _s4: .db "Unexpected format in printf.", 0
3870   20F9 70 65 63 74 
3870   20FD 65 64 20 66 
3870   2101 6F 72 6D 61 
3870   2105 74 20 69 6E 
3870   2109 20 70 72 69 
3870   210D 6E 74 66 2E 
3870   2111 00 
3871   2112 45 72 72 6F _s5: .db "Error: Unknown argument type.\n", 0
3871   2116 72 3A 20 55 
3871   211A 6E 6B 6E 6F 
3871   211E 77 6E 20 61 
3871   2122 72 67 75 6D 
3871   2126 65 6E 74 20 
3871   212A 74 79 70 65 
3871   212E 2E 0A 00 
3872   2131 1B 5B 32 4A _s6: .db "\033[2J\033[H", 0
3872   2135 1B 5B 48 00 
3873   2139             
3874   2139 3B 21       _heap_top: .dw _heap
3875   213B 00          _heap: .db 0
3876   213C             ; --- END DATA SEGMENT
3877   213C             
3878   213C             .end
tasm: Number of errors = 0
