0001   0000             ; --- FILENAME: test
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; $ii 
0011   0408 52 02 00      sub sp, 2
0012   040B 05 0B         syscall sys_terminate_proc
0013   040D             
0014   040D             strcpy:
0015   040D F8 00 00      enter 0 ; (push bp; mov bp, sp)
0016   0410             ; $psrc 
0017   0410             ; $pdest 
0018   0410 52 04 00      sub sp, 4
0019   0413             ;; psrc = src; 
0020   0413 FA FF FF      lea d, [bp + -1] ; $psrc
0021   0416 DA            push d
0022   0417 FA 07 00      lea d, [bp + 7] ; $src
0023   041A 2A            mov b, [d]
0024   041B E7            pop d
0025   041C FD 43         mov [d], b
0026   041E             ;; pdest = dest; 
0027   041E FA FD FF      lea d, [bp + -3] ; $pdest
0028   0421 DA            push d
0029   0422 FA 05 00      lea d, [bp + 5] ; $dest
0030   0425 2A            mov b, [d]
0031   0426 E7            pop d
0032   0427 FD 43         mov [d], b
0033   0429             ;; while(*psrc) *pdest++ = *psrc++; 
0034   0429             _while1_cond:
0035   0429 FA FF FF      lea d, [bp + -1] ; $psrc
0036   042C 2A            mov b, [d]
0037   042D 74            mov d, b
0038   042E 32            mov bl, [d]
0039   042F A7 00         mov bh, 0
0040   0431 C0 00 00      cmp b, 0
0041   0434 C6 5C 04      je _while1_exit
0042   0437             _while1_block:
0043   0437             ;; *pdest++ = *psrc++; 
0044   0437 FA FD FF      lea d, [bp + -3] ; $pdest
0045   043A 2A            mov b, [d]
0046   043B D8            push b
0047   043C FD 77         inc b
0048   043E FA FD FF      lea d, [bp + -3] ; $pdest
0049   0441 FD 43         mov [d], b
0050   0443 E5            pop b
0051   0444 D8            push b
0052   0445 FA FF FF      lea d, [bp + -1] ; $psrc
0053   0448 2A            mov b, [d]
0054   0449 D8            push b
0055   044A FD 77         inc b
0056   044C FA FF FF      lea d, [bp + -1] ; $psrc
0057   044F FD 43         mov [d], b
0058   0451 E5            pop b
0059   0452 74            mov d, b
0060   0453 32            mov bl, [d]
0061   0454 A7 00         mov bh, 0
0062   0456 E7            pop d
0063   0457 FD 3E         mov [d], bl
0064   0459 0A 29 04      jmp _while1_cond
0065   045C             _while1_exit:
0066   045C             ;; *pdest = '\0'; 
0067   045C FA FD FF      lea d, [bp + -3] ; $pdest
0068   045F 2A            mov b, [d]
0069   0460 D8            push b
0070   0461 26 00 00      mov b, $0
0071   0464 E7            pop d
0072   0465 FD 3E         mov [d], bl
0073   0467 F9            leave
0074   0468 09            ret
0075   0469             
0076   0469             strcmp:
0077   0469 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0078   046C             ;; while (*s1 && (*s1 == *s2)) { 
0079   046C             _while2_cond:
0080   046C FA 05 00      lea d, [bp + 5] ; $s1
0081   046F 2A            mov b, [d]
0082   0470 74            mov d, b
0083   0471 32            mov bl, [d]
0084   0472 A7 00         mov bh, 0
0085   0474 D7            push a
0086   0475 11            mov a, b
0087   0476 FA 05 00      lea d, [bp + 5] ; $s1
0088   0479 2A            mov b, [d]
0089   047A 74            mov d, b
0090   047B 32            mov bl, [d]
0091   047C A7 00         mov bh, 0
0092   047E             ; START RELATIONAL
0093   047E D7            push a
0094   047F 11            mov a, b
0095   0480 FA 07 00      lea d, [bp + 7] ; $s2
0096   0483 2A            mov b, [d]
0097   0484 74            mov d, b
0098   0485 32            mov bl, [d]
0099   0486 A7 00         mov bh, 0
0100   0488 B0            cmp a, b
0101   0489 FD 71         seq ; ==
0102   048B E4            pop a
0103   048C             ; END RELATIONAL
0104   048C FD A7         sand a, b ; &&
0105   048E E4            pop a
0106   048F C0 00 00      cmp b, 0
0107   0492 C6 B2 04      je _while2_exit
0108   0495             _while2_block:
0109   0495             ;; s1++; 
0110   0495 FA 05 00      lea d, [bp + 5] ; $s1
0111   0498 2A            mov b, [d]
0112   0499 D8            push b
0113   049A FD 77         inc b
0114   049C FA 05 00      lea d, [bp + 5] ; $s1
0115   049F FD 43         mov [d], b
0116   04A1 E5            pop b
0117   04A2             ;; s2++; 
0118   04A2 FA 07 00      lea d, [bp + 7] ; $s2
0119   04A5 2A            mov b, [d]
0120   04A6 D8            push b
0121   04A7 FD 77         inc b
0122   04A9 FA 07 00      lea d, [bp + 7] ; $s2
0123   04AC FD 43         mov [d], b
0124   04AE E5            pop b
0125   04AF 0A 6C 04      jmp _while2_cond
0126   04B2             _while2_exit:
0127   04B2             ;; return *s1 - *s2; 
0128   04B2 FA 05 00      lea d, [bp + 5] ; $s1
0129   04B5 2A            mov b, [d]
0130   04B6 74            mov d, b
0131   04B7 32            mov bl, [d]
0132   04B8 A7 00         mov bh, 0
0133   04BA             ; START TERMS
0134   04BA D7            push a
0135   04BB 11            mov a, b
0136   04BC FA 07 00      lea d, [bp + 7] ; $s2
0137   04BF 2A            mov b, [d]
0138   04C0 74            mov d, b
0139   04C1 32            mov bl, [d]
0140   04C2 A7 00         mov bh, 0
0141   04C4 60            sub a, b
0142   04C5 27            mov b, a
0143   04C6 E4            pop a
0144   04C7             ; END TERMS
0145   04C7 F9            leave
0146   04C8 09            ret
0147   04C9             
0148   04C9             strcat:
0149   04C9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0150   04CC             ; $dest_len 
0151   04CC             ; $i 
0152   04CC 52 04 00      sub sp, 4
0153   04CF             ;; dest_len = strlen(dest); 
0154   04CF FA FF FF      lea d, [bp + -1] ; $dest_len
0155   04D2 DA            push d
0156   04D3 FA 05 00      lea d, [bp + 5] ; $dest
0157   04D6 2A            mov b, [d]
0158   04D7 FD AB         swp b
0159   04D9 D8            push b
0160   04DA 07 7F 05      call strlen
0161   04DD 51 02 00      add sp, 2
0162   04E0 E7            pop d
0163   04E1 FD 43         mov [d], b
0164   04E3             ;; for (i = 0; src[i] != 0; i=i+1) { 
0165   04E3             _for3_init:
0166   04E3 FA FD FF      lea d, [bp + -3] ; $i
0167   04E6 DA            push d
0168   04E7 26 00 00      mov b, $0
0169   04EA E7            pop d
0170   04EB FD 43         mov [d], b
0171   04ED             _for3_cond:
0172   04ED FA 07 00      lea d, [bp + 7] ; $src
0173   04F0 FD 2A         mov d, [d]
0174   04F2 D7            push a
0175   04F3 DA            push d
0176   04F4 FA FD FF      lea d, [bp + -3] ; $i
0177   04F7 2A            mov b, [d]
0178   04F8 E7            pop d
0179   04F9 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0180   04FD E4            pop a
0181   04FE 32            mov bl, [d]
0182   04FF A7 00         mov bh, 0
0183   0501             ; START RELATIONAL
0184   0501 D7            push a
0185   0502 11            mov a, b
0186   0503 26 00 00      mov b, $0
0187   0506 B0            cmp a, b
0188   0507 FD 72         sneq ; !=
0189   0509 E4            pop a
0190   050A             ; END RELATIONAL
0191   050A C0 00 00      cmp b, 0
0192   050D C6 58 05      je _for3_exit
0193   0510             _for3_block:
0194   0510             ;; dest[dest_len + i] = src[i]; 
0195   0510 FA 05 00      lea d, [bp + 5] ; $dest
0196   0513 FD 2A         mov d, [d]
0197   0515 D7            push a
0198   0516 DA            push d
0199   0517 FA FF FF      lea d, [bp + -1] ; $dest_len
0200   051A 2A            mov b, [d]
0201   051B             ; START TERMS
0202   051B D7            push a
0203   051C 11            mov a, b
0204   051D FA FD FF      lea d, [bp + -3] ; $i
0205   0520 2A            mov b, [d]
0206   0521 54            add a, b
0207   0522 27            mov b, a
0208   0523 E4            pop a
0209   0524             ; END TERMS
0210   0524 E7            pop d
0211   0525 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0212   0529 E4            pop a
0213   052A DA            push d
0214   052B FA 07 00      lea d, [bp + 7] ; $src
0215   052E FD 2A         mov d, [d]
0216   0530 D7            push a
0217   0531 DA            push d
0218   0532 FA FD FF      lea d, [bp + -3] ; $i
0219   0535 2A            mov b, [d]
0220   0536 E7            pop d
0221   0537 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0222   053B E4            pop a
0223   053C 32            mov bl, [d]
0224   053D A7 00         mov bh, 0
0225   053F E7            pop d
0226   0540 FD 3E         mov [d], bl
0227   0542             _for3_update:
0228   0542 FA FD FF      lea d, [bp + -3] ; $i
0229   0545 DA            push d
0230   0546 FA FD FF      lea d, [bp + -3] ; $i
0231   0549 2A            mov b, [d]
0232   054A             ; START TERMS
0233   054A D7            push a
0234   054B 11            mov a, b
0235   054C 26 01 00      mov b, $1
0236   054F 54            add a, b
0237   0550 27            mov b, a
0238   0551 E4            pop a
0239   0552             ; END TERMS
0240   0552 E7            pop d
0241   0553 FD 43         mov [d], b
0242   0555 0A ED 04      jmp _for3_cond
0243   0558             _for3_exit:
0244   0558             ;; dest[dest_len + i] = 0; 
0245   0558 FA 05 00      lea d, [bp + 5] ; $dest
0246   055B FD 2A         mov d, [d]
0247   055D D7            push a
0248   055E DA            push d
0249   055F FA FF FF      lea d, [bp + -1] ; $dest_len
0250   0562 2A            mov b, [d]
0251   0563             ; START TERMS
0252   0563 D7            push a
0253   0564 11            mov a, b
0254   0565 FA FD FF      lea d, [bp + -3] ; $i
0255   0568 2A            mov b, [d]
0256   0569 54            add a, b
0257   056A 27            mov b, a
0258   056B E4            pop a
0259   056C             ; END TERMS
0260   056C E7            pop d
0261   056D FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0262   0571 E4            pop a
0263   0572 DA            push d
0264   0573 26 00 00      mov b, $0
0265   0576 E7            pop d
0266   0577 FD 3E         mov [d], bl
0267   0579             ;; return dest; 
0268   0579 FA 05 00      lea d, [bp + 5] ; $dest
0269   057C 2A            mov b, [d]
0270   057D F9            leave
0271   057E 09            ret
0272   057F             
0273   057F             strlen:
0274   057F F8 00 00      enter 0 ; (push bp; mov bp, sp)
0275   0582             ; $length 
0276   0582 52 02 00      sub sp, 2
0277   0585             ;; length = 0; 
0278   0585 FA FF FF      lea d, [bp + -1] ; $length
0279   0588 DA            push d
0280   0589 26 00 00      mov b, $0
0281   058C E7            pop d
0282   058D FD 43         mov [d], b
0283   058F             ;; while (str[length] != 0) { 
0284   058F             _while4_cond:
0285   058F FA 05 00      lea d, [bp + 5] ; $str
0286   0592 FD 2A         mov d, [d]
0287   0594 D7            push a
0288   0595 DA            push d
0289   0596 FA FF FF      lea d, [bp + -1] ; $length
0290   0599 2A            mov b, [d]
0291   059A E7            pop d
0292   059B FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0293   059F E4            pop a
0294   05A0 32            mov bl, [d]
0295   05A1 A7 00         mov bh, 0
0296   05A3             ; START RELATIONAL
0297   05A3 D7            push a
0298   05A4 11            mov a, b
0299   05A5 26 00 00      mov b, $0
0300   05A8 B0            cmp a, b
0301   05A9 FD 72         sneq ; !=
0302   05AB E4            pop a
0303   05AC             ; END RELATIONAL
0304   05AC C0 00 00      cmp b, 0
0305   05AF C6 C2 05      je _while4_exit
0306   05B2             _while4_block:
0307   05B2             ;; length++; 
0308   05B2 FA FF FF      lea d, [bp + -1] ; $length
0309   05B5 2A            mov b, [d]
0310   05B6 D8            push b
0311   05B7 FD 77         inc b
0312   05B9 FA FF FF      lea d, [bp + -1] ; $length
0313   05BC FD 43         mov [d], b
0314   05BE E5            pop b
0315   05BF 0A 8F 05      jmp _while4_cond
0316   05C2             _while4_exit:
0317   05C2             ;; return length; 
0318   05C2 FA FF FF      lea d, [bp + -1] ; $length
0319   05C5 2A            mov b, [d]
0320   05C6 F9            leave
0321   05C7 09            ret
0322   05C8             
0323   05C8             va_start:
0324   05C8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0325   05CB             ;; argp->current_arg = first_fixed_param + sizeof(first_fixed_param); 
0326   05CB FA 05 00      lea d, [bp + 5] ; $argp
0327   05CE FD 2A         mov d, [d]
0328   05D0 58 00 00      add d, 0
0329   05D3 DA            push d
0330   05D4 FA 07 00      lea d, [bp + 7] ; $first_fixed_param
0331   05D7 2A            mov b, [d]
0332   05D8             ; START TERMS
0333   05D8 D7            push a
0334   05D9 11            mov a, b
0335   05DA 26 02 00      mov b, 2
0336   05DD 54            add a, b
0337   05DE 27            mov b, a
0338   05DF E4            pop a
0339   05E0             ; END TERMS
0340   05E0 E7            pop d
0341   05E1 FD 43         mov [d], b
0342   05E3 F9            leave
0343   05E4 09            ret
0344   05E5             
0345   05E5             va_arg:
0346   05E5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0347   05E8             ; $p 
0348   05E8 52 02 00      sub sp, 2
0349   05EB             ;; p = argp->current_arg; 
0350   05EB FA FF FF      lea d, [bp + -1] ; $p
0351   05EE DA            push d
0352   05EF FA 05 00      lea d, [bp + 5] ; $argp
0353   05F2 FD 2A         mov d, [d]
0354   05F4 58 00 00      add d, 0
0355   05F7 2A            mov b, [d]
0356   05F8 E7            pop d
0357   05F9 FD 43         mov [d], b
0358   05FB             ;; argp->current_arg = argp->current_arg + size; 
0359   05FB FA 05 00      lea d, [bp + 5] ; $argp
0360   05FE FD 2A         mov d, [d]
0361   0600 58 00 00      add d, 0
0362   0603 DA            push d
0363   0604 FA 05 00      lea d, [bp + 5] ; $argp
0364   0607 FD 2A         mov d, [d]
0365   0609 58 00 00      add d, 0
0366   060C 2A            mov b, [d]
0367   060D             ; START TERMS
0368   060D D7            push a
0369   060E 11            mov a, b
0370   060F FA 07 00      lea d, [bp + 7] ; $size
0371   0612 2A            mov b, [d]
0372   0613 54            add a, b
0373   0614 27            mov b, a
0374   0615 E4            pop a
0375   0616             ; END TERMS
0376   0616 E7            pop d
0377   0617 FD 43         mov [d], b
0378   0619             ;; return p; 
0379   0619 FA FF FF      lea d, [bp + -1] ; $p
0380   061C 2A            mov b, [d]
0381   061D F9            leave
0382   061E 09            ret
0383   061F             
0384   061F             va_end:
0385   061F F8 00 00      enter 0 ; (push bp; mov bp, sp)
0386   0622             ;; argp->current_arg =   0   ; 
0387   0622 FA 05 00      lea d, [bp + 5] ; $argp
0388   0625 FD 2A         mov d, [d]
0389   0627 58 00 00      add d, 0
0390   062A DA            push d
0391   062B 26 00 00      mov b, $0
0392   062E E7            pop d
0393   062F FD 43         mov [d], b
0394   0631 F9            leave
0395   0632 09            ret
0396   0633             
0397   0633             printf:
0398   0633 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0399   0636             ; $p 
0400   0636             ; $fp 
0401   0636             ; $i 
0402   0636 52 06 00      sub sp, 6
0403   0639             ;; fp = format; 
0404   0639 FA FD FF      lea d, [bp + -3] ; $fp
0405   063C DA            push d
0406   063D FA 05 00      lea d, [bp + 5] ; $format
0407   0640 2A            mov b, [d]
0408   0641 E7            pop d
0409   0642 FD 43         mov [d], b
0410   0644             ;; p = &format + 2; 
0411   0644 FA FF FF      lea d, [bp + -1] ; $p
0412   0647 DA            push d
0413   0648 FA 05 00      lea d, [bp + 5] ; $format
0414   064B 2D            mov b, d
0415   064C             ; START TERMS
0416   064C D7            push a
0417   064D 11            mov a, b
0418   064E 26 02 00      mov b, $2
0419   0651 54            add a, b
0420   0652 27            mov b, a
0421   0653 E4            pop a
0422   0654             ; END TERMS
0423   0654 E7            pop d
0424   0655 FD 43         mov [d], b
0425   0657             ;; for(;;){ 
0426   0657             _for5_init:
0427   0657             _for5_cond:
0428   0657             _for5_block:
0429   0657             ;; if(!*fp) break; 
0430   0657             _if6_cond:
0431   0657 FA FD FF      lea d, [bp + -3] ; $fp
0432   065A 2A            mov b, [d]
0433   065B 74            mov d, b
0434   065C 32            mov bl, [d]
0435   065D A7 00         mov bh, 0
0436   065F C0 00 00      cmp b, 0
0437   0662 FD 71         seq ; !
0438   0664 C0 00 00      cmp b, 0
0439   0667 C6 70 06      je _if6_else
0440   066A             _if6_true:
0441   066A             ;; break; 
0442   066A 0A 7C 08      jmp _for5_exit ; for break
0443   066D 0A 79 08      jmp _if6_exit
0444   0670             _if6_else:
0445   0670             ;; if(*fp == '%'){ 
0446   0670             _if7_cond:
0447   0670 FA FD FF      lea d, [bp + -3] ; $fp
0448   0673 2A            mov b, [d]
0449   0674 74            mov d, b
0450   0675 32            mov bl, [d]
0451   0676 A7 00         mov bh, 0
0452   0678             ; START RELATIONAL
0453   0678 D7            push a
0454   0679 11            mov a, b
0455   067A 26 25 00      mov b, $25
0456   067D B0            cmp a, b
0457   067E FD 71         seq ; ==
0458   0680 E4            pop a
0459   0681             ; END RELATIONAL
0460   0681 C0 00 00      cmp b, 0
0461   0684 C6 5D 08      je _if7_else
0462   0687             _if7_true:
0463   0687             ;; fp++; 
0464   0687 FA FD FF      lea d, [bp + -3] ; $fp
0465   068A 2A            mov b, [d]
0466   068B D8            push b
0467   068C FD 77         inc b
0468   068E FA FD FF      lea d, [bp + -3] ; $fp
0469   0691 FD 43         mov [d], b
0470   0693 E5            pop b
0471   0694             ;; switch(*fp){ 
0472   0694             _switch8_expr:
0473   0694 FA FD FF      lea d, [bp + -3] ; $fp
0474   0697 2A            mov b, [d]
0475   0698 74            mov d, b
0476   0699 32            mov bl, [d]
0477   069A A7 00         mov bh, 0
0478   069C             _switch8_comparisons:
0479   069C C1 6C         cmp bl, $6c
0480   069E C6 CA 06      je _switch8_case0
0481   06A1 C1 4C         cmp bl, $4c
0482   06A3 C6 CA 06      je _switch8_case1
0483   06A6 C1 64         cmp bl, $64
0484   06A8 C6 98 07      je _switch8_case2
0485   06AB C1 69         cmp bl, $69
0486   06AD C6 98 07      je _switch8_case3
0487   06B0 C1 75         cmp bl, $75
0488   06B2 C6 BD 07      je _switch8_case4
0489   06B5 C1 78         cmp bl, $78
0490   06B7 C6 E2 07      je _switch8_case5
0491   06BA C1 63         cmp bl, $63
0492   06BC C6 01 08      je _switch8_case6
0493   06BF C1 73         cmp bl, $73
0494   06C1 C6 21 08      je _switch8_case7
0495   06C4 0A 41 08      jmp _switch8_default
0496   06C7 0A 4D 08      jmp _switch8_exit
0497   06CA             _switch8_case0:
0498   06CA             _switch8_case1:
0499   06CA             ;; fp++; 
0500   06CA FA FD FF      lea d, [bp + -3] ; $fp
0501   06CD 2A            mov b, [d]
0502   06CE D8            push b
0503   06CF FD 77         inc b
0504   06D1 FA FD FF      lea d, [bp + -3] ; $fp
0505   06D4 FD 43         mov [d], b
0506   06D6 E5            pop b
0507   06D7             ;; if(*fp == 'd' || *fp == 'i') 
0508   06D7             _if9_cond:
0509   06D7 FA FD FF      lea d, [bp + -3] ; $fp
0510   06DA 2A            mov b, [d]
0511   06DB 74            mov d, b
0512   06DC 32            mov bl, [d]
0513   06DD A7 00         mov bh, 0
0514   06DF             ; START RELATIONAL
0515   06DF D7            push a
0516   06E0 11            mov a, b
0517   06E1 26 64 00      mov b, $64
0518   06E4 B0            cmp a, b
0519   06E5 FD 71         seq ; ==
0520   06E7 E4            pop a
0521   06E8             ; END RELATIONAL
0522   06E8 D7            push a
0523   06E9 11            mov a, b
0524   06EA FA FD FF      lea d, [bp + -3] ; $fp
0525   06ED 2A            mov b, [d]
0526   06EE 74            mov d, b
0527   06EF 32            mov bl, [d]
0528   06F0 A7 00         mov bh, 0
0529   06F2             ; START RELATIONAL
0530   06F2 D7            push a
0531   06F3 11            mov a, b
0532   06F4 26 69 00      mov b, $69
0533   06F7 B0            cmp a, b
0534   06F8 FD 71         seq ; ==
0535   06FA E4            pop a
0536   06FB             ; END RELATIONAL
0537   06FB FD A8         sor a, b ; ||
0538   06FD E4            pop a
0539   06FE C0 00 00      cmp b, 0
0540   0701 C6 18 07      je _if9_else
0541   0704             _if9_true:
0542   0704             ;; print_signed_long(*(long *)p); 
0543   0704 FD 79         mov g, b
0544   0706 28            mov b, c
0545   0707 FD AB         swp b
0546   0709 D8            push b
0547   070A FD 27         mov b, g
0548   070C FD AB         swp b
0549   070E D8            push b
0550   070F 07 3C 0B      call print_signed_long
0551   0712 51 04 00      add sp, 4
0552   0715 0A 82 07      jmp _if9_exit
0553   0718             _if9_else:
0554   0718             ;; if(*fp == 'u') 
0555   0718             _if10_cond:
0556   0718 FA FD FF      lea d, [bp + -3] ; $fp
0557   071B 2A            mov b, [d]
0558   071C 74            mov d, b
0559   071D 32            mov bl, [d]
0560   071E A7 00         mov bh, 0
0561   0720             ; START RELATIONAL
0562   0720 D7            push a
0563   0721 11            mov a, b
0564   0722 26 75 00      mov b, $75
0565   0725 B0            cmp a, b
0566   0726 FD 71         seq ; ==
0567   0728 E4            pop a
0568   0729             ; END RELATIONAL
0569   0729 C0 00 00      cmp b, 0
0570   072C C6 43 07      je _if10_else
0571   072F             _if10_true:
0572   072F             ;; print_unsigned_long(*(unsigned long *)p); 
0573   072F FD 79         mov g, b
0574   0731 28            mov b, c
0575   0732 FD AB         swp b
0576   0734 D8            push b
0577   0735 FD 27         mov b, g
0578   0737 FD AB         swp b
0579   0739 D8            push b
0580   073A 07 8F 0C      call print_unsigned_long
0581   073D 51 04 00      add sp, 4
0582   0740 0A 82 07      jmp _if10_exit
0583   0743             _if10_else:
0584   0743             ;; if(*fp == 'x') 
0585   0743             _if11_cond:
0586   0743 FA FD FF      lea d, [bp + -3] ; $fp
0587   0746 2A            mov b, [d]
0588   0747 74            mov d, b
0589   0748 32            mov bl, [d]
0590   0749 A7 00         mov bh, 0
0591   074B             ; START RELATIONAL
0592   074B D7            push a
0593   074C 11            mov a, b
0594   074D 26 78 00      mov b, $78
0595   0750 B0            cmp a, b
0596   0751 FD 71         seq ; ==
0597   0753 E4            pop a
0598   0754             ; END RELATIONAL
0599   0754 C0 00 00      cmp b, 0
0600   0757 C6 79 07      je _if11_else
0601   075A             _if11_true:
0602   075A             ;; printx32(*(long int *)p); 
0603   075A FA FF FF      lea d, [bp + -1] ; $p
0604   075D 2A            mov b, [d]
0605   075E 74            mov d, b
0606   075F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0607   0762 FD 39         mov c, b ; And place it into C
0608   0764 2A            mov b, [d] ; Lower Word in B
0609   0765 FD 79         mov g, b
0610   0767 28            mov b, c
0611   0768 FD AB         swp b
0612   076A D8            push b
0613   076B FD 27         mov b, g
0614   076D FD AB         swp b
0615   076F D8            push b
0616   0770 07 93 08      call printx32
0617   0773 51 04 00      add sp, 4
0618   0776 0A 82 07      jmp _if11_exit
0619   0779             _if11_else:
0620   0779             ;; err("Unexpected format in printf."); 
0621   0779 26 0C 18      mov b, __s0 ; "Unexpected format in printf."
0622   077C FD AB         swp b
0623   077E D8            push b
0624   077F 07 7E 08      call err
0625   0782             _if11_exit:
0626   0782             _if10_exit:
0627   0782             _if9_exit:
0628   0782             ;; p = p + 4; 
0629   0782 FA FF FF      lea d, [bp + -1] ; $p
0630   0785 DA            push d
0631   0786 FA FF FF      lea d, [bp + -1] ; $p
0632   0789 2A            mov b, [d]
0633   078A             ; START TERMS
0634   078A D7            push a
0635   078B 11            mov a, b
0636   078C 26 04 00      mov b, $4
0637   078F 54            add a, b
0638   0790 27            mov b, a
0639   0791 E4            pop a
0640   0792             ; END TERMS
0641   0792 E7            pop d
0642   0793 FD 43         mov [d], b
0643   0795             ;; break; 
0644   0795 0A 4D 08      jmp _switch8_exit ; case break
0645   0798             _switch8_case2:
0646   0798             _switch8_case3:
0647   0798             ;; print_signed(*(int*)p); 
0648   0798 FA FF FF      lea d, [bp + -1] ; $p
0649   079B 2A            mov b, [d]
0650   079C 74            mov d, b
0651   079D 2A            mov b, [d]
0652   079E FD AB         swp b
0653   07A0 D8            push b
0654   07A1 07 34 0A      call print_signed
0655   07A4 51 02 00      add sp, 2
0656   07A7             ;; p = p + 2; 
0657   07A7 FA FF FF      lea d, [bp + -1] ; $p
0658   07AA DA            push d
0659   07AB FA FF FF      lea d, [bp + -1] ; $p
0660   07AE 2A            mov b, [d]
0661   07AF             ; START TERMS
0662   07AF D7            push a
0663   07B0 11            mov a, b
0664   07B1 26 02 00      mov b, $2
0665   07B4 54            add a, b
0666   07B5 27            mov b, a
0667   07B6 E4            pop a
0668   07B7             ; END TERMS
0669   07B7 E7            pop d
0670   07B8 FD 43         mov [d], b
0671   07BA             ;; break; 
0672   07BA 0A 4D 08      jmp _switch8_exit ; case break
0673   07BD             _switch8_case4:
0674   07BD             ;; print_unsigned(*(unsigned int*)p); 
0675   07BD FA FF FF      lea d, [bp + -1] ; $p
0676   07C0 2A            mov b, [d]
0677   07C1 74            mov d, b
0678   07C2 2A            mov b, [d]
0679   07C3 FD AB         swp b
0680   07C5 D8            push b
0681   07C6 07 8D 0D      call print_unsigned
0682   07C9 51 02 00      add sp, 2
0683   07CC             ;; p = p + 2; 
0684   07CC FA FF FF      lea d, [bp + -1] ; $p
0685   07CF DA            push d
0686   07D0 FA FF FF      lea d, [bp + -1] ; $p
0687   07D3 2A            mov b, [d]
0688   07D4             ; START TERMS
0689   07D4 D7            push a
0690   07D5 11            mov a, b
0691   07D6 26 02 00      mov b, $2
0692   07D9 54            add a, b
0693   07DA 27            mov b, a
0694   07DB E4            pop a
0695   07DC             ; END TERMS
0696   07DC E7            pop d
0697   07DD FD 43         mov [d], b
0698   07DF             ;; break; 
0699   07DF 0A 4D 08      jmp _switch8_exit ; case break
0700   07E2             _switch8_case5:
0701   07E2             
0702   07E2             ; --- BEGIN INLINE ASM BLOCK
0703   07E2 FA FF FF      lea d, [bp + -1] ; $p
0704   07E5 FD 2A         mov d, [d]
0705   07E7 2A            mov b, [d]
0706   07E8 07 E1 11      call print_u16x
0707   07EB             ; --- END INLINE ASM BLOCK
0708   07EB             
0709   07EB             ;; p = p + 2; 
0710   07EB FA FF FF      lea d, [bp + -1] ; $p
0711   07EE DA            push d
0712   07EF FA FF FF      lea d, [bp + -1] ; $p
0713   07F2 2A            mov b, [d]
0714   07F3             ; START TERMS
0715   07F3 D7            push a
0716   07F4 11            mov a, b
0717   07F5 26 02 00      mov b, $2
0718   07F8 54            add a, b
0719   07F9 27            mov b, a
0720   07FA E4            pop a
0721   07FB             ; END TERMS
0722   07FB E7            pop d
0723   07FC FD 43         mov [d], b
0724   07FE             ;; break; 
0725   07FE 0A 4D 08      jmp _switch8_exit ; case break
0726   0801             _switch8_case6:
0727   0801             
0728   0801             ; --- BEGIN INLINE ASM BLOCK
0729   0801 FA FF FF      lea d, [bp + -1] ; $p
0730   0804 FD 2A         mov d, [d]
0731   0806 1E            mov al, [d]
0732   0807 23            mov ah, al
0733   0808 07 3F 10      call _putchar
0734   080B             ; --- END INLINE ASM BLOCK
0735   080B             
0736   080B             ;; p = p + 2; 
0737   080B FA FF FF      lea d, [bp + -1] ; $p
0738   080E DA            push d
0739   080F FA FF FF      lea d, [bp + -1] ; $p
0740   0812 2A            mov b, [d]
0741   0813             ; START TERMS
0742   0813 D7            push a
0743   0814 11            mov a, b
0744   0815 26 02 00      mov b, $2
0745   0818 54            add a, b
0746   0819 27            mov b, a
0747   081A E4            pop a
0748   081B             ; END TERMS
0749   081B E7            pop d
0750   081C FD 43         mov [d], b
0751   081E             ;; break; 
0752   081E 0A 4D 08      jmp _switch8_exit ; case break
0753   0821             _switch8_case7:
0754   0821             
0755   0821             ; --- BEGIN INLINE ASM BLOCK
0756   0821 FA FF FF      lea d, [bp + -1] ; $p
0757   0824 FD 2A         mov d, [d]
0758   0826 FD 2A         mov d, [d]
0759   0828 07 89 11      call _puts
0760   082B             ; --- END INLINE ASM BLOCK
0761   082B             
0762   082B             ;; p = p + 2; 
0763   082B FA FF FF      lea d, [bp + -1] ; $p
0764   082E DA            push d
0765   082F FA FF FF      lea d, [bp + -1] ; $p
0766   0832 2A            mov b, [d]
0767   0833             ; START TERMS
0768   0833 D7            push a
0769   0834 11            mov a, b
0770   0835 26 02 00      mov b, $2
0771   0838 54            add a, b
0772   0839 27            mov b, a
0773   083A E4            pop a
0774   083B             ; END TERMS
0775   083B E7            pop d
0776   083C FD 43         mov [d], b
0777   083E             ;; break; 
0778   083E 0A 4D 08      jmp _switch8_exit ; case break
0779   0841             _switch8_default:
0780   0841             ;; print("Error: Unknown argument type.\n"); 
0781   0841 26 29 18      mov b, __s1 ; "Error: Unknown argument type.\n"
0782   0844 FD AB         swp b
0783   0846 D8            push b
0784   0847 07 A6 0E      call print
0785   084A 51 02 00      add sp, 2
0786   084D             _switch8_exit:
0787   084D             ;; fp++; 
0788   084D FA FD FF      lea d, [bp + -3] ; $fp
0789   0850 2A            mov b, [d]
0790   0851 D8            push b
0791   0852 FD 77         inc b
0792   0854 FA FD FF      lea d, [bp + -3] ; $fp
0793   0857 FD 43         mov [d], b
0794   0859 E5            pop b
0795   085A 0A 79 08      jmp _if7_exit
0796   085D             _if7_else:
0797   085D             ;; putchar(*fp); 
0798   085D FA FD FF      lea d, [bp + -3] ; $fp
0799   0860 2A            mov b, [d]
0800   0861 74            mov d, b
0801   0862 32            mov bl, [d]
0802   0863 A7 00         mov bh, 0
0803   0865 DD            push bl
0804   0866 07 5E 0E      call putchar
0805   0869 51 01 00      add sp, 1
0806   086C             ;; fp++; 
0807   086C FA FD FF      lea d, [bp + -3] ; $fp
0808   086F 2A            mov b, [d]
0809   0870 D8            push b
0810   0871 FD 77         inc b
0811   0873 FA FD FF      lea d, [bp + -3] ; $fp
0812   0876 FD 43         mov [d], b
0813   0878 E5            pop b
0814   0879             _if7_exit:
0815   0879             _if6_exit:
0816   0879             _for5_update:
0817   0879 0A 57 06      jmp _for5_cond
0818   087C             _for5_exit:
0819   087C F9            leave
0820   087D 09            ret
0821   087E             
0822   087E             err:
0823   087E F8 00 00      enter 0 ; (push bp; mov bp, sp)
0824   0881             ;; print(e); 
0825   0881 FA 05 00      lea d, [bp + 5] ; $e
0826   0884 2A            mov b, [d]
0827   0885 FD AB         swp b
0828   0887 D8            push b
0829   0888 07 A6 0E      call print
0830   088B 51 02 00      add sp, 2
0831   088E             ;; exit(); 
0832   088E 07 E1 12      call exit
0833   0891 F9            leave
0834   0892 09            ret
0835   0893             
0836   0893             printx32:
0837   0893 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0838   0896             
0839   0896             ; --- BEGIN INLINE ASM BLOCK
0840   0896 FA 05 00      lea d, [bp + 5] ; $hex
0841   0899 2B 02 00      mov b, [d+2]
0842   089C 07 E1 11      call print_u16x
0843   089F 2A            mov b, [d]
0844   08A0 07 E1 11      call print_u16x
0845   08A3             ; --- END INLINE ASM BLOCK
0846   08A3             
0847   08A3 F9            leave
0848   08A4 09            ret
0849   08A5             
0850   08A5             printx16:
0851   08A5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0852   08A8             
0853   08A8             ; --- BEGIN INLINE ASM BLOCK
0854   08A8 FA 05 00      lea d, [bp + 5] ; $hex
0855   08AB 2A            mov b, [d]
0856   08AC 07 E1 11      call print_u16x
0857   08AF             ; --- END INLINE ASM BLOCK
0858   08AF             
0859   08AF F9            leave
0860   08B0 09            ret
0861   08B1             
0862   08B1             printx8:
0863   08B1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0864   08B4             
0865   08B4             ; --- BEGIN INLINE ASM BLOCK
0866   08B4 FA 05 00      lea d, [bp + 5] ; $hex
0867   08B7 32            mov bl, [d]
0868   08B8 07 25 12      call print_u8x
0869   08BB             ; --- END INLINE ASM BLOCK
0870   08BB             
0871   08BB F9            leave
0872   08BC 09            ret
0873   08BD             
0874   08BD             hex_to_int:
0875   08BD F8 00 00      enter 0 ; (push bp; mov bp, sp)
0876   08C0             ; $value 
0877   08C0 10 00 00      mov a, $0
0878   08C3 45 FF FF      mov [bp + -1], a
0879   08C6             ; $i 
0880   08C6             ; $hex_char 
0881   08C6             ; $len 
0882   08C6 52 07 00      sub sp, 7
0883   08C9             ;; len = strlen(hex_string); 
0884   08C9 FA FA FF      lea d, [bp + -6] ; $len
0885   08CC DA            push d
0886   08CD FA 05 00      lea d, [bp + 5] ; $hex_string
0887   08D0 2A            mov b, [d]
0888   08D1 FD AB         swp b
0889   08D3 D8            push b
0890   08D4 07 7F 05      call strlen
0891   08D7 51 02 00      add sp, 2
0892   08DA E7            pop d
0893   08DB FD 43         mov [d], b
0894   08DD             ;; for (i = 0; i < len; i++) { 
0895   08DD             _for12_init:
0896   08DD FA FD FF      lea d, [bp + -3] ; $i
0897   08E0 DA            push d
0898   08E1 26 00 00      mov b, $0
0899   08E4 E7            pop d
0900   08E5 FD 43         mov [d], b
0901   08E7             _for12_cond:
0902   08E7 FA FD FF      lea d, [bp + -3] ; $i
0903   08EA 2A            mov b, [d]
0904   08EB             ; START RELATIONAL
0905   08EB D7            push a
0906   08EC 11            mov a, b
0907   08ED FA FA FF      lea d, [bp + -6] ; $len
0908   08F0 2A            mov b, [d]
0909   08F1 4D            mov si, a
0910   08F2 11            mov a, b
0911   08F3 4F            mov di, a
0912   08F4 FD 12         mov a, g
0913   08F6 28            mov b, c
0914   08F7 B0            cmp a, b
0915   08F8 FD 75         slu ; <
0916   08FA D8            push b
0917   08FB 28            mov b, c
0918   08FC FD 71         seq ; ==
0919   08FE D8            push b
0920   08FF 50            mov a, di
0921   0900 27            mov b, a
0922   0901 4E            mov a, si
0923   0902 B0            cmp a, b
0924   0903 FD 75         slu ; <
0925   0905 E4            pop a
0926   0906 FD 92         and b, a
0927   0908 E4            pop a
0928   0909 FD 70         or b, a
0929   090B               
0930   090B E4            pop a
0931   090C             ; END RELATIONAL
0932   090C C0 00 00      cmp b, 0
0933   090F C6 14 0A      je _for12_exit
0934   0912             _for12_block:
0935   0912             ;; hex_char = hex_string[i]; 
0936   0912 FA FC FF      lea d, [bp + -4] ; $hex_char
0937   0915 DA            push d
0938   0916 FA 05 00      lea d, [bp + 5] ; $hex_string
0939   0919 FD 2A         mov d, [d]
0940   091B D7            push a
0941   091C DA            push d
0942   091D FA FD FF      lea d, [bp + -3] ; $i
0943   0920 2A            mov b, [d]
0944   0921 E7            pop d
0945   0922 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0946   0926 E4            pop a
0947   0927 32            mov bl, [d]
0948   0928 A7 00         mov bh, 0
0949   092A E7            pop d
0950   092B FD 3E         mov [d], bl
0951   092D             ;; if (hex_char >= 'a' && hex_char <= 'f')  
0952   092D             _if13_cond:
0953   092D FA FC FF      lea d, [bp + -4] ; $hex_char
0954   0930 32            mov bl, [d]
0955   0931 A7 00         mov bh, 0
0956   0933             ; START RELATIONAL
0957   0933 D7            push a
0958   0934 11            mov a, b
0959   0935 26 61 00      mov b, $61
0960   0938 B0            cmp a, b
0961   0939 FD 80         sge ; >=
0962   093B E4            pop a
0963   093C             ; END RELATIONAL
0964   093C D7            push a
0965   093D 11            mov a, b
0966   093E FA FC FF      lea d, [bp + -4] ; $hex_char
0967   0941 32            mov bl, [d]
0968   0942 A7 00         mov bh, 0
0969   0944             ; START RELATIONAL
0970   0944 D7            push a
0971   0945 11            mov a, b
0972   0946 26 66 00      mov b, $66
0973   0949 B0            cmp a, b
0974   094A FD 74         sle ; <=
0975   094C E4            pop a
0976   094D             ; END RELATIONAL
0977   094D FD A7         sand a, b ; &&
0978   094F E4            pop a
0979   0950 C0 00 00      cmp b, 0
0980   0953 C6 85 09      je _if13_else
0981   0956             _if13_true:
0982   0956             ;; value = (value * 16) + (hex_char - 'a' + 10); 
0983   0956 FA FF FF      lea d, [bp + -1] ; $value
0984   0959 DA            push d
0985   095A FA FF FF      lea d, [bp + -1] ; $value
0986   095D 2A            mov b, [d]
0987   095E             ; START FACTORS
0988   095E D7            push a
0989   095F 11            mov a, b
0990   0960 26 10 00      mov b, $10
0991   0963 AC            mul a, b ; *
0992   0964 11            mov a, b
0993   0965 27            mov b, a
0994   0966 E4            pop a
0995   0967             ; END FACTORS
0996   0967             ; START TERMS
0997   0967 D7            push a
0998   0968 11            mov a, b
0999   0969 FA FC FF      lea d, [bp + -4] ; $hex_char
1000   096C 32            mov bl, [d]
1001   096D A7 00         mov bh, 0
1002   096F             ; START TERMS
1003   096F D7            push a
1004   0970 11            mov a, b
1005   0971 26 61 00      mov b, $61
1006   0974 60            sub a, b
1007   0975 11            mov a, b
1008   0976 26 0A 00      mov b, $a
1009   0979 54            add a, b
1010   097A 27            mov b, a
1011   097B E4            pop a
1012   097C             ; END TERMS
1013   097C 54            add a, b
1014   097D 27            mov b, a
1015   097E E4            pop a
1016   097F             ; END TERMS
1017   097F E7            pop d
1018   0980 FD 43         mov [d], b
1019   0982 0A 04 0A      jmp _if13_exit
1020   0985             _if13_else:
1021   0985             ;; if (hex_char >= 'A' && hex_char <= 'F')  
1022   0985             _if14_cond:
1023   0985 FA FC FF      lea d, [bp + -4] ; $hex_char
1024   0988 32            mov bl, [d]
1025   0989 A7 00         mov bh, 0
1026   098B             ; START RELATIONAL
1027   098B D7            push a
1028   098C 11            mov a, b
1029   098D 26 41 00      mov b, $41
1030   0990 B0            cmp a, b
1031   0991 FD 80         sge ; >=
1032   0993 E4            pop a
1033   0994             ; END RELATIONAL
1034   0994 D7            push a
1035   0995 11            mov a, b
1036   0996 FA FC FF      lea d, [bp + -4] ; $hex_char
1037   0999 32            mov bl, [d]
1038   099A A7 00         mov bh, 0
1039   099C             ; START RELATIONAL
1040   099C D7            push a
1041   099D 11            mov a, b
1042   099E 26 46 00      mov b, $46
1043   09A1 B0            cmp a, b
1044   09A2 FD 74         sle ; <=
1045   09A4 E4            pop a
1046   09A5             ; END RELATIONAL
1047   09A5 FD A7         sand a, b ; &&
1048   09A7 E4            pop a
1049   09A8 C0 00 00      cmp b, 0
1050   09AB C6 DD 09      je _if14_else
1051   09AE             _if14_true:
1052   09AE             ;; value = (value * 16) + (hex_char - 'A' + 10); 
1053   09AE FA FF FF      lea d, [bp + -1] ; $value
1054   09B1 DA            push d
1055   09B2 FA FF FF      lea d, [bp + -1] ; $value
1056   09B5 2A            mov b, [d]
1057   09B6             ; START FACTORS
1058   09B6 D7            push a
1059   09B7 11            mov a, b
1060   09B8 26 10 00      mov b, $10
1061   09BB AC            mul a, b ; *
1062   09BC 11            mov a, b
1063   09BD 27            mov b, a
1064   09BE E4            pop a
1065   09BF             ; END FACTORS
1066   09BF             ; START TERMS
1067   09BF D7            push a
1068   09C0 11            mov a, b
1069   09C1 FA FC FF      lea d, [bp + -4] ; $hex_char
1070   09C4 32            mov bl, [d]
1071   09C5 A7 00         mov bh, 0
1072   09C7             ; START TERMS
1073   09C7 D7            push a
1074   09C8 11            mov a, b
1075   09C9 26 41 00      mov b, $41
1076   09CC 60            sub a, b
1077   09CD 11            mov a, b
1078   09CE 26 0A 00      mov b, $a
1079   09D1 54            add a, b
1080   09D2 27            mov b, a
1081   09D3 E4            pop a
1082   09D4             ; END TERMS
1083   09D4 54            add a, b
1084   09D5 27            mov b, a
1085   09D6 E4            pop a
1086   09D7             ; END TERMS
1087   09D7 E7            pop d
1088   09D8 FD 43         mov [d], b
1089   09DA 0A 04 0A      jmp _if14_exit
1090   09DD             _if14_else:
1091   09DD             ;; value = (value * 16) + (hex_char - '0'); 
1092   09DD FA FF FF      lea d, [bp + -1] ; $value
1093   09E0 DA            push d
1094   09E1 FA FF FF      lea d, [bp + -1] ; $value
1095   09E4 2A            mov b, [d]
1096   09E5             ; START FACTORS
1097   09E5 D7            push a
1098   09E6 11            mov a, b
1099   09E7 26 10 00      mov b, $10
1100   09EA AC            mul a, b ; *
1101   09EB 11            mov a, b
1102   09EC 27            mov b, a
1103   09ED E4            pop a
1104   09EE             ; END FACTORS
1105   09EE             ; START TERMS
1106   09EE D7            push a
1107   09EF 11            mov a, b
1108   09F0 FA FC FF      lea d, [bp + -4] ; $hex_char
1109   09F3 32            mov bl, [d]
1110   09F4 A7 00         mov bh, 0
1111   09F6             ; START TERMS
1112   09F6 D7            push a
1113   09F7 11            mov a, b
1114   09F8 26 30 00      mov b, $30
1115   09FB 60            sub a, b
1116   09FC 27            mov b, a
1117   09FD E4            pop a
1118   09FE             ; END TERMS
1119   09FE 54            add a, b
1120   09FF 27            mov b, a
1121   0A00 E4            pop a
1122   0A01             ; END TERMS
1123   0A01 E7            pop d
1124   0A02 FD 43         mov [d], b
1125   0A04             _if14_exit:
1126   0A04             _if13_exit:
1127   0A04             _for12_update:
1128   0A04 FA FD FF      lea d, [bp + -3] ; $i
1129   0A07 2A            mov b, [d]
1130   0A08 D8            push b
1131   0A09 FD 77         inc b
1132   0A0B FA FD FF      lea d, [bp + -3] ; $i
1133   0A0E FD 43         mov [d], b
1134   0A10 E5            pop b
1135   0A11 0A E7 08      jmp _for12_cond
1136   0A14             _for12_exit:
1137   0A14             ;; return value; 
1138   0A14 FA FF FF      lea d, [bp + -1] ; $value
1139   0A17 2A            mov b, [d]
1140   0A18 F9            leave
1141   0A19 09            ret
1142   0A1A             
1143   0A1A             gets:
1144   0A1A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1145   0A1D             
1146   0A1D             ; --- BEGIN INLINE ASM BLOCK
1147   0A1D FA 05 00      lea d, [bp + 5] ; $s
1148   0A20 15            mov a, [d]
1149   0A21 3C            mov d, a
1150   0A22 07 46 10      call _gets
1151   0A25             ; --- END INLINE ASM BLOCK
1152   0A25             
1153   0A25             ;; return strlen(s); 
1154   0A25 FA 05 00      lea d, [bp + 5] ; $s
1155   0A28 2A            mov b, [d]
1156   0A29 FD AB         swp b
1157   0A2B D8            push b
1158   0A2C 07 7F 05      call strlen
1159   0A2F 51 02 00      add sp, 2
1160   0A32 F9            leave
1161   0A33 09            ret
1162   0A34             
1163   0A34             print_signed:
1164   0A34 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1165   0A37             ; $digits 
1166   0A37             ; $i 
1167   0A37 10 00 00      mov a, $0
1168   0A3A 45 FA FF      mov [bp + -6], a
1169   0A3D 52 07 00      sub sp, 7
1170   0A40             ;; if (num < 0) { 
1171   0A40             _if15_cond:
1172   0A40 FA 05 00      lea d, [bp + 5] ; $num
1173   0A43 2A            mov b, [d]
1174   0A44             ; START RELATIONAL
1175   0A44 D7            push a
1176   0A45 11            mov a, b
1177   0A46 26 00 00      mov b, $0
1178   0A49 4D            mov si, a
1179   0A4A 11            mov a, b
1180   0A4B 4F            mov di, a
1181   0A4C FD 12         mov a, g
1182   0A4E 28            mov b, c
1183   0A4F B0            cmp a, b
1184   0A50 FD 75         slu ; <
1185   0A52 D8            push b
1186   0A53 28            mov b, c
1187   0A54 FD 71         seq ; ==
1188   0A56 D8            push b
1189   0A57 50            mov a, di
1190   0A58 27            mov b, a
1191   0A59 4E            mov a, si
1192   0A5A B0            cmp a, b
1193   0A5B FD 75         slu ; <
1194   0A5D E4            pop a
1195   0A5E FD 92         and b, a
1196   0A60 E4            pop a
1197   0A61 FD 70         or b, a
1198   0A63               
1199   0A63 E4            pop a
1200   0A64             ; END RELATIONAL
1201   0A64 C0 00 00      cmp b, 0
1202   0A67 C6 84 0A      je _if15_else
1203   0A6A             _if15_true:
1204   0A6A             ;; putchar('-'); 
1205   0A6A 26 2D 00      mov b, $2d
1206   0A6D DD            push bl
1207   0A6E 07 5E 0E      call putchar
1208   0A71 51 01 00      add sp, 1
1209   0A74             ;; num = -num; 
1210   0A74 FA 05 00      lea d, [bp + 5] ; $num
1211   0A77 DA            push d
1212   0A78 FA 05 00      lea d, [bp + 5] ; $num
1213   0A7B 2A            mov b, [d]
1214   0A7C FD 97         neg b
1215   0A7E E7            pop d
1216   0A7F FD 43         mov [d], b
1217   0A81 0A A6 0A      jmp _if15_exit
1218   0A84             _if15_else:
1219   0A84             ;; if (num == 0) { 
1220   0A84             _if16_cond:
1221   0A84 FA 05 00      lea d, [bp + 5] ; $num
1222   0A87 2A            mov b, [d]
1223   0A88             ; START RELATIONAL
1224   0A88 D7            push a
1225   0A89 11            mov a, b
1226   0A8A 26 00 00      mov b, $0
1227   0A8D B0            cmp a, b
1228   0A8E FD 71         seq ; ==
1229   0A90 E4            pop a
1230   0A91             ; END RELATIONAL
1231   0A91 C0 00 00      cmp b, 0
1232   0A94 C6 A6 0A      je _if16_exit
1233   0A97             _if16_true:
1234   0A97             ;; putchar('0'); 
1235   0A97 26 30 00      mov b, $30
1236   0A9A DD            push bl
1237   0A9B 07 5E 0E      call putchar
1238   0A9E 51 01 00      add sp, 1
1239   0AA1             ;; return; 
1240   0AA1 F9            leave
1241   0AA2 09            ret
1242   0AA3 0A A6 0A      jmp _if16_exit
1243   0AA6             _if16_exit:
1244   0AA6             _if15_exit:
1245   0AA6             ;; while (num > 0) { 
1246   0AA6             _while17_cond:
1247   0AA6 FA 05 00      lea d, [bp + 5] ; $num
1248   0AA9 2A            mov b, [d]
1249   0AAA             ; START RELATIONAL
1250   0AAA D7            push a
1251   0AAB 11            mov a, b
1252   0AAC 26 00 00      mov b, $0
1253   0AAF B0            cmp a, b
1254   0AB0 FD 7F         sgt ; >
1255   0AB2 E4            pop a
1256   0AB3             ; END RELATIONAL
1257   0AB3 C0 00 00      cmp b, 0
1258   0AB6 C6 01 0B      je _while17_exit
1259   0AB9             _while17_block:
1260   0AB9             ;; digits[i] = '0' + (num % 10); 
1261   0AB9 FA FC FF      lea d, [bp + -4] ; $digits
1262   0ABC D7            push a
1263   0ABD DA            push d
1264   0ABE FA FA FF      lea d, [bp + -6] ; $i
1265   0AC1 2A            mov b, [d]
1266   0AC2 E7            pop d
1267   0AC3 5A            add d, b
1268   0AC4 E4            pop a
1269   0AC5 DA            push d
1270   0AC6 26 30 00      mov b, $30
1271   0AC9             ; START TERMS
1272   0AC9 D7            push a
1273   0ACA 11            mov a, b
1274   0ACB FA 05 00      lea d, [bp + 5] ; $num
1275   0ACE 2A            mov b, [d]
1276   0ACF             ; START FACTORS
1277   0ACF D7            push a
1278   0AD0 11            mov a, b
1279   0AD1 26 0A 00      mov b, $a
1280   0AD4 AE            div a, b ; 
1281   0AD5 11            mov a, b
1282   0AD6 27            mov b, a
1283   0AD7 E4            pop a
1284   0AD8             ; END FACTORS
1285   0AD8 54            add a, b
1286   0AD9 27            mov b, a
1287   0ADA E4            pop a
1288   0ADB             ; END TERMS
1289   0ADB E7            pop d
1290   0ADC FD 3E         mov [d], bl
1291   0ADE             ;; num = num / 10; 
1292   0ADE FA 05 00      lea d, [bp + 5] ; $num
1293   0AE1 DA            push d
1294   0AE2 FA 05 00      lea d, [bp + 5] ; $num
1295   0AE5 2A            mov b, [d]
1296   0AE6             ; START FACTORS
1297   0AE6 D7            push a
1298   0AE7 11            mov a, b
1299   0AE8 26 0A 00      mov b, $a
1300   0AEB AE            div a, b
1301   0AEC 27            mov b, a
1302   0AED E4            pop a
1303   0AEE             ; END FACTORS
1304   0AEE E7            pop d
1305   0AEF FD 43         mov [d], b
1306   0AF1             ;; i++; 
1307   0AF1 FA FA FF      lea d, [bp + -6] ; $i
1308   0AF4 2A            mov b, [d]
1309   0AF5 D8            push b
1310   0AF6 FD 77         inc b
1311   0AF8 FA FA FF      lea d, [bp + -6] ; $i
1312   0AFB FD 43         mov [d], b
1313   0AFD E5            pop b
1314   0AFE 0A A6 0A      jmp _while17_cond
1315   0B01             _while17_exit:
1316   0B01             ;; while (i > 0) { 
1317   0B01             _while18_cond:
1318   0B01 FA FA FF      lea d, [bp + -6] ; $i
1319   0B04 2A            mov b, [d]
1320   0B05             ; START RELATIONAL
1321   0B05 D7            push a
1322   0B06 11            mov a, b
1323   0B07 26 00 00      mov b, $0
1324   0B0A B0            cmp a, b
1325   0B0B FD 7F         sgt ; >
1326   0B0D E4            pop a
1327   0B0E             ; END RELATIONAL
1328   0B0E C0 00 00      cmp b, 0
1329   0B11 C6 3A 0B      je _while18_exit
1330   0B14             _while18_block:
1331   0B14             ;; i--; 
1332   0B14 FA FA FF      lea d, [bp + -6] ; $i
1333   0B17 2A            mov b, [d]
1334   0B18 D8            push b
1335   0B19 FD 7D         dec b
1336   0B1B FA FA FF      lea d, [bp + -6] ; $i
1337   0B1E FD 43         mov [d], b
1338   0B20 E5            pop b
1339   0B21             ;; putchar(digits[i]); 
1340   0B21 FA FC FF      lea d, [bp + -4] ; $digits
1341   0B24 D7            push a
1342   0B25 DA            push d
1343   0B26 FA FA FF      lea d, [bp + -6] ; $i
1344   0B29 2A            mov b, [d]
1345   0B2A E7            pop d
1346   0B2B 5A            add d, b
1347   0B2C E4            pop a
1348   0B2D 32            mov bl, [d]
1349   0B2E A7 00         mov bh, 0
1350   0B30 DD            push bl
1351   0B31 07 5E 0E      call putchar
1352   0B34 51 01 00      add sp, 1
1353   0B37 0A 01 0B      jmp _while18_cond
1354   0B3A             _while18_exit:
1355   0B3A F9            leave
1356   0B3B 09            ret
1357   0B3C             
1358   0B3C             print_signed_long:
1359   0B3C F8 00 00      enter 0 ; (push bp; mov bp, sp)
1360   0B3F             ; $digits 
1361   0B3F             ; $i 
1362   0B3F 10 00 00      mov a, $0
1363   0B42 45 F5 FF      mov [bp + -11], a
1364   0B45 52 0C 00      sub sp, 12
1365   0B48             ;; if (num < 0) { 
1366   0B48             _if19_cond:
1367   0B48 FA 05 00      lea d, [bp + 5] ; $num
1368   0B4B 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1369   0B4E FD 39         mov c, b ; And place it into C
1370   0B50 2A            mov b, [d] ; Lower Word in B
1371   0B51             ; START RELATIONAL
1372   0B51 D7            push a
1373   0B52 FD D8         push g
1374   0B54 11            mov a, b
1375   0B55 FD 7A         mov g, c
1376   0B57 26 00 00      mov b, $0
1377   0B5A 4D            mov si, a
1378   0B5B 11            mov a, b
1379   0B5C 4F            mov di, a
1380   0B5D FD 12         mov a, g
1381   0B5F 28            mov b, c
1382   0B60 B0            cmp a, b
1383   0B61 FD 75         slu ; <
1384   0B63 D8            push b
1385   0B64 28            mov b, c
1386   0B65 FD 71         seq ; ==
1387   0B67 D8            push b
1388   0B68 50            mov a, di
1389   0B69 27            mov b, a
1390   0B6A 4E            mov a, si
1391   0B6B B0            cmp a, b
1392   0B6C FD 75         slu ; <
1393   0B6E E4            pop a
1394   0B6F FD 92         and b, a
1395   0B71 E4            pop a
1396   0B72 FD 70         or b, a
1397   0B74               
1398   0B74 FD F1         pop g
1399   0B76 E4            pop a
1400   0B77             ; END RELATIONAL
1401   0B77 C0 00 00      cmp b, 0
1402   0B7A C6 A1 0B      je _if19_else
1403   0B7D             _if19_true:
1404   0B7D             ;; putchar('-'); 
1405   0B7D 26 2D 00      mov b, $2d
1406   0B80 DD            push bl
1407   0B81 07 5E 0E      call putchar
1408   0B84 51 01 00      add sp, 1
1409   0B87             ;; num = -num; 
1410   0B87 FA 05 00      lea d, [bp + 5] ; $num
1411   0B8A DA            push d
1412   0B8B FA 05 00      lea d, [bp + 5] ; $num
1413   0B8E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1414   0B91 FD 39         mov c, b ; And place it into C
1415   0B93 2A            mov b, [d] ; Lower Word in B
1416   0B94 FD 97         neg b
1417   0B96 E7            pop d
1418   0B97 FD 43         mov [d], b
1419   0B99 28            mov b, c
1420   0B9A FD 44 02 00   mov [d + 2], b
1421   0B9E 0A D8 0B      jmp _if19_exit
1422   0BA1             _if19_else:
1423   0BA1             ;; if (num == 0) { 
1424   0BA1             _if20_cond:
1425   0BA1 FA 05 00      lea d, [bp + 5] ; $num
1426   0BA4 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1427   0BA7 FD 39         mov c, b ; And place it into C
1428   0BA9 2A            mov b, [d] ; Lower Word in B
1429   0BAA             ; START RELATIONAL
1430   0BAA D7            push a
1431   0BAB FD D8         push g
1432   0BAD 11            mov a, b
1433   0BAE FD 7A         mov g, c
1434   0BB0 26 00 00      mov b, $0
1435   0BB3 B0            cmp a, b
1436   0BB4 FD 71         seq ; ==
1437   0BB6 D8            push b
1438   0BB7 12            mov a, c
1439   0BB8 FD 27         mov b, g
1440   0BBA B0            cmp a, b
1441   0BBB FD 71         seq ; ==
1442   0BBD E4            pop a
1443   0BBE FD A7         sand a, b
1444   0BC0 FD F1         pop g
1445   0BC2 E4            pop a
1446   0BC3             ; END RELATIONAL
1447   0BC3 C0 00 00      cmp b, 0
1448   0BC6 C6 D8 0B      je _if20_exit
1449   0BC9             _if20_true:
1450   0BC9             ;; putchar('0'); 
1451   0BC9 26 30 00      mov b, $30
1452   0BCC DD            push bl
1453   0BCD 07 5E 0E      call putchar
1454   0BD0 51 01 00      add sp, 1
1455   0BD3             ;; return; 
1456   0BD3 F9            leave
1457   0BD4 09            ret
1458   0BD5 0A D8 0B      jmp _if20_exit
1459   0BD8             _if20_exit:
1460   0BD8             _if19_exit:
1461   0BD8             ;; while (num > 0) { 
1462   0BD8             _while21_cond:
1463   0BD8 FA 05 00      lea d, [bp + 5] ; $num
1464   0BDB 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1465   0BDE FD 39         mov c, b ; And place it into C
1466   0BE0 2A            mov b, [d] ; Lower Word in B
1467   0BE1             ; START RELATIONAL
1468   0BE1 D7            push a
1469   0BE2 FD D8         push g
1470   0BE4 11            mov a, b
1471   0BE5 FD 7A         mov g, c
1472   0BE7 26 00 00      mov b, $0
1473   0BEA B0            cmp a, b
1474   0BEB FD 7F         sgt ; >
1475   0BED FD F1         pop g
1476   0BEF E4            pop a
1477   0BF0             ; END RELATIONAL
1478   0BF0 C0 00 00      cmp b, 0
1479   0BF3 C6 54 0C      je _while21_exit
1480   0BF6             _while21_block:
1481   0BF6             ;; digits[i] = '0' + (num % 10); 
1482   0BF6 FA F7 FF      lea d, [bp + -9] ; $digits
1483   0BF9 D7            push a
1484   0BFA DA            push d
1485   0BFB FA F5 FF      lea d, [bp + -11] ; $i
1486   0BFE 2A            mov b, [d]
1487   0BFF E7            pop d
1488   0C00 5A            add d, b
1489   0C01 E4            pop a
1490   0C02 DA            push d
1491   0C03 26 30 00      mov b, $30
1492   0C06             ; START TERMS
1493   0C06 D7            push a
1494   0C07 11            mov a, b
1495   0C08 FA 05 00      lea d, [bp + 5] ; $num
1496   0C0B 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1497   0C0E FD 39         mov c, b ; And place it into C
1498   0C10 2A            mov b, [d] ; Lower Word in B
1499   0C11             ; START FACTORS
1500   0C11 D7            push a
1501   0C12 11            mov a, b
1502   0C13 26 0A 00      mov b, $a
1503   0C16 AE            div a, b ; 
1504   0C17 11            mov a, b
1505   0C18 27            mov b, a
1506   0C19 E4            pop a
1507   0C1A             ; END FACTORS
1508   0C1A 54            add a, b
1509   0C1B D7            push a
1510   0C1C FD 12         mov a, g
1511   0C1E 28            mov b, c
1512   0C1F 5C            adc a, b
1513   0C20 39            mov c, a
1514   0C21 E5            pop b
1515   0C22 27            mov b, a
1516   0C23 E4            pop a
1517   0C24             ; END TERMS
1518   0C24 E7            pop d
1519   0C25 FD 3E         mov [d], bl
1520   0C27             ;; num = num / 10; 
1521   0C27 FA 05 00      lea d, [bp + 5] ; $num
1522   0C2A DA            push d
1523   0C2B FA 05 00      lea d, [bp + 5] ; $num
1524   0C2E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1525   0C31 FD 39         mov c, b ; And place it into C
1526   0C33 2A            mov b, [d] ; Lower Word in B
1527   0C34             ; START FACTORS
1528   0C34 D7            push a
1529   0C35 11            mov a, b
1530   0C36 26 0A 00      mov b, $a
1531   0C39 AE            div a, b
1532   0C3A 27            mov b, a
1533   0C3B E4            pop a
1534   0C3C             ; END FACTORS
1535   0C3C E7            pop d
1536   0C3D FD 43         mov [d], b
1537   0C3F 28            mov b, c
1538   0C40 FD 44 02 00   mov [d + 2], b
1539   0C44             ;; i++; 
1540   0C44 FA F5 FF      lea d, [bp + -11] ; $i
1541   0C47 2A            mov b, [d]
1542   0C48 D8            push b
1543   0C49 FD 77         inc b
1544   0C4B FA F5 FF      lea d, [bp + -11] ; $i
1545   0C4E FD 43         mov [d], b
1546   0C50 E5            pop b
1547   0C51 0A D8 0B      jmp _while21_cond
1548   0C54             _while21_exit:
1549   0C54             ;; while (i > 0) { 
1550   0C54             _while22_cond:
1551   0C54 FA F5 FF      lea d, [bp + -11] ; $i
1552   0C57 2A            mov b, [d]
1553   0C58             ; START RELATIONAL
1554   0C58 D7            push a
1555   0C59 11            mov a, b
1556   0C5A 26 00 00      mov b, $0
1557   0C5D B0            cmp a, b
1558   0C5E FD 7F         sgt ; >
1559   0C60 E4            pop a
1560   0C61             ; END RELATIONAL
1561   0C61 C0 00 00      cmp b, 0
1562   0C64 C6 8D 0C      je _while22_exit
1563   0C67             _while22_block:
1564   0C67             ;; i--; 
1565   0C67 FA F5 FF      lea d, [bp + -11] ; $i
1566   0C6A 2A            mov b, [d]
1567   0C6B D8            push b
1568   0C6C FD 7D         dec b
1569   0C6E FA F5 FF      lea d, [bp + -11] ; $i
1570   0C71 FD 43         mov [d], b
1571   0C73 E5            pop b
1572   0C74             ;; putchar(digits[i]); 
1573   0C74 FA F7 FF      lea d, [bp + -9] ; $digits
1574   0C77 D7            push a
1575   0C78 DA            push d
1576   0C79 FA F5 FF      lea d, [bp + -11] ; $i
1577   0C7C 2A            mov b, [d]
1578   0C7D E7            pop d
1579   0C7E 5A            add d, b
1580   0C7F E4            pop a
1581   0C80 32            mov bl, [d]
1582   0C81 A7 00         mov bh, 0
1583   0C83 DD            push bl
1584   0C84 07 5E 0E      call putchar
1585   0C87 51 01 00      add sp, 1
1586   0C8A 0A 54 0C      jmp _while22_cond
1587   0C8D             _while22_exit:
1588   0C8D F9            leave
1589   0C8E 09            ret
1590   0C8F             
1591   0C8F             print_unsigned_long:
1592   0C8F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1593   0C92             ; $digits 
1594   0C92             ; $i 
1595   0C92 52 0C 00      sub sp, 12
1596   0C95             ;; i = 0; 
1597   0C95 FA F5 FF      lea d, [bp + -11] ; $i
1598   0C98 DA            push d
1599   0C99 26 00 00      mov b, $0
1600   0C9C E7            pop d
1601   0C9D FD 43         mov [d], b
1602   0C9F             ;; if(num == 0){ 
1603   0C9F             _if23_cond:
1604   0C9F FA 05 00      lea d, [bp + 5] ; $num
1605   0CA2 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1606   0CA5 FD 39         mov c, b ; And place it into C
1607   0CA7 2A            mov b, [d] ; Lower Word in B
1608   0CA8             ; START RELATIONAL
1609   0CA8 D7            push a
1610   0CA9 FD D8         push g
1611   0CAB 11            mov a, b
1612   0CAC FD 7A         mov g, c
1613   0CAE 26 00 00      mov b, $0
1614   0CB1 B0            cmp a, b
1615   0CB2 FD 71         seq ; ==
1616   0CB4 D8            push b
1617   0CB5 12            mov a, c
1618   0CB6 FD 27         mov b, g
1619   0CB8 B0            cmp a, b
1620   0CB9 FD 71         seq ; ==
1621   0CBB E4            pop a
1622   0CBC FD A7         sand a, b
1623   0CBE FD F1         pop g
1624   0CC0 E4            pop a
1625   0CC1             ; END RELATIONAL
1626   0CC1 C0 00 00      cmp b, 0
1627   0CC4 C6 D6 0C      je _if23_exit
1628   0CC7             _if23_true:
1629   0CC7             ;; putchar('0'); 
1630   0CC7 26 30 00      mov b, $30
1631   0CCA DD            push bl
1632   0CCB 07 5E 0E      call putchar
1633   0CCE 51 01 00      add sp, 1
1634   0CD1             ;; return; 
1635   0CD1 F9            leave
1636   0CD2 09            ret
1637   0CD3 0A D6 0C      jmp _if23_exit
1638   0CD6             _if23_exit:
1639   0CD6             ;; while (num > 0) { 
1640   0CD6             _while24_cond:
1641   0CD6 FA 05 00      lea d, [bp + 5] ; $num
1642   0CD9 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1643   0CDC FD 39         mov c, b ; And place it into C
1644   0CDE 2A            mov b, [d] ; Lower Word in B
1645   0CDF             ; START RELATIONAL
1646   0CDF D7            push a
1647   0CE0 FD D8         push g
1648   0CE2 11            mov a, b
1649   0CE3 FD 7A         mov g, c
1650   0CE5 26 00 00      mov b, $0
1651   0CE8 B0            cmp a, b
1652   0CE9 FD 81         sgu ; > (unsigned)
1653   0CEB FD F1         pop g
1654   0CED E4            pop a
1655   0CEE             ; END RELATIONAL
1656   0CEE C0 00 00      cmp b, 0
1657   0CF1 C6 52 0D      je _while24_exit
1658   0CF4             _while24_block:
1659   0CF4             ;; digits[i] = '0' + (num % 10); 
1660   0CF4 FA F7 FF      lea d, [bp + -9] ; $digits
1661   0CF7 D7            push a
1662   0CF8 DA            push d
1663   0CF9 FA F5 FF      lea d, [bp + -11] ; $i
1664   0CFC 2A            mov b, [d]
1665   0CFD E7            pop d
1666   0CFE 5A            add d, b
1667   0CFF E4            pop a
1668   0D00 DA            push d
1669   0D01 26 30 00      mov b, $30
1670   0D04             ; START TERMS
1671   0D04 D7            push a
1672   0D05 11            mov a, b
1673   0D06 FA 05 00      lea d, [bp + 5] ; $num
1674   0D09 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1675   0D0C FD 39         mov c, b ; And place it into C
1676   0D0E 2A            mov b, [d] ; Lower Word in B
1677   0D0F             ; START FACTORS
1678   0D0F D7            push a
1679   0D10 11            mov a, b
1680   0D11 26 0A 00      mov b, $a
1681   0D14 AE            div a, b ; 
1682   0D15 11            mov a, b
1683   0D16 27            mov b, a
1684   0D17 E4            pop a
1685   0D18             ; END FACTORS
1686   0D18 54            add a, b
1687   0D19 D7            push a
1688   0D1A FD 12         mov a, g
1689   0D1C 28            mov b, c
1690   0D1D 5C            adc a, b
1691   0D1E 39            mov c, a
1692   0D1F E5            pop b
1693   0D20 27            mov b, a
1694   0D21 E4            pop a
1695   0D22             ; END TERMS
1696   0D22 E7            pop d
1697   0D23 FD 3E         mov [d], bl
1698   0D25             ;; num = num / 10; 
1699   0D25 FA 05 00      lea d, [bp + 5] ; $num
1700   0D28 DA            push d
1701   0D29 FA 05 00      lea d, [bp + 5] ; $num
1702   0D2C 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1703   0D2F FD 39         mov c, b ; And place it into C
1704   0D31 2A            mov b, [d] ; Lower Word in B
1705   0D32             ; START FACTORS
1706   0D32 D7            push a
1707   0D33 11            mov a, b
1708   0D34 26 0A 00      mov b, $a
1709   0D37 AE            div a, b
1710   0D38 27            mov b, a
1711   0D39 E4            pop a
1712   0D3A             ; END FACTORS
1713   0D3A E7            pop d
1714   0D3B FD 43         mov [d], b
1715   0D3D 28            mov b, c
1716   0D3E FD 44 02 00   mov [d + 2], b
1717   0D42             ;; i++; 
1718   0D42 FA F5 FF      lea d, [bp + -11] ; $i
1719   0D45 2A            mov b, [d]
1720   0D46 D8            push b
1721   0D47 FD 77         inc b
1722   0D49 FA F5 FF      lea d, [bp + -11] ; $i
1723   0D4C FD 43         mov [d], b
1724   0D4E E5            pop b
1725   0D4F 0A D6 0C      jmp _while24_cond
1726   0D52             _while24_exit:
1727   0D52             ;; while (i > 0) { 
1728   0D52             _while25_cond:
1729   0D52 FA F5 FF      lea d, [bp + -11] ; $i
1730   0D55 2A            mov b, [d]
1731   0D56             ; START RELATIONAL
1732   0D56 D7            push a
1733   0D57 11            mov a, b
1734   0D58 26 00 00      mov b, $0
1735   0D5B B0            cmp a, b
1736   0D5C FD 7F         sgt ; >
1737   0D5E E4            pop a
1738   0D5F             ; END RELATIONAL
1739   0D5F C0 00 00      cmp b, 0
1740   0D62 C6 8B 0D      je _while25_exit
1741   0D65             _while25_block:
1742   0D65             ;; i--; 
1743   0D65 FA F5 FF      lea d, [bp + -11] ; $i
1744   0D68 2A            mov b, [d]
1745   0D69 D8            push b
1746   0D6A FD 7D         dec b
1747   0D6C FA F5 FF      lea d, [bp + -11] ; $i
1748   0D6F FD 43         mov [d], b
1749   0D71 E5            pop b
1750   0D72             ;; putchar(digits[i]); 
1751   0D72 FA F7 FF      lea d, [bp + -9] ; $digits
1752   0D75 D7            push a
1753   0D76 DA            push d
1754   0D77 FA F5 FF      lea d, [bp + -11] ; $i
1755   0D7A 2A            mov b, [d]
1756   0D7B E7            pop d
1757   0D7C 5A            add d, b
1758   0D7D E4            pop a
1759   0D7E 32            mov bl, [d]
1760   0D7F A7 00         mov bh, 0
1761   0D81 DD            push bl
1762   0D82 07 5E 0E      call putchar
1763   0D85 51 01 00      add sp, 1
1764   0D88 0A 52 0D      jmp _while25_cond
1765   0D8B             _while25_exit:
1766   0D8B F9            leave
1767   0D8C 09            ret
1768   0D8D             
1769   0D8D             print_unsigned:
1770   0D8D F8 00 00      enter 0 ; (push bp; mov bp, sp)
1771   0D90             ; $digits 
1772   0D90             ; $i 
1773   0D90 52 07 00      sub sp, 7
1774   0D93             ;; i = 0; 
1775   0D93 FA FA FF      lea d, [bp + -6] ; $i
1776   0D96 DA            push d
1777   0D97 26 00 00      mov b, $0
1778   0D9A E7            pop d
1779   0D9B FD 43         mov [d], b
1780   0D9D             ;; if(num == 0){ 
1781   0D9D             _if26_cond:
1782   0D9D FA 05 00      lea d, [bp + 5] ; $num
1783   0DA0 2A            mov b, [d]
1784   0DA1             ; START RELATIONAL
1785   0DA1 D7            push a
1786   0DA2 11            mov a, b
1787   0DA3 26 00 00      mov b, $0
1788   0DA6 B0            cmp a, b
1789   0DA7 FD 71         seq ; ==
1790   0DA9 E4            pop a
1791   0DAA             ; END RELATIONAL
1792   0DAA C0 00 00      cmp b, 0
1793   0DAD C6 BF 0D      je _if26_exit
1794   0DB0             _if26_true:
1795   0DB0             ;; putchar('0'); 
1796   0DB0 26 30 00      mov b, $30
1797   0DB3 DD            push bl
1798   0DB4 07 5E 0E      call putchar
1799   0DB7 51 01 00      add sp, 1
1800   0DBA             ;; return; 
1801   0DBA F9            leave
1802   0DBB 09            ret
1803   0DBC 0A BF 0D      jmp _if26_exit
1804   0DBF             _if26_exit:
1805   0DBF             ;; while (num > 0) { 
1806   0DBF             _while27_cond:
1807   0DBF FA 05 00      lea d, [bp + 5] ; $num
1808   0DC2 2A            mov b, [d]
1809   0DC3             ; START RELATIONAL
1810   0DC3 D7            push a
1811   0DC4 11            mov a, b
1812   0DC5 26 00 00      mov b, $0
1813   0DC8 B0            cmp a, b
1814   0DC9 FD 81         sgu ; > (unsigned)
1815   0DCB E4            pop a
1816   0DCC             ; END RELATIONAL
1817   0DCC C0 00 00      cmp b, 0
1818   0DCF C6 1A 0E      je _while27_exit
1819   0DD2             _while27_block:
1820   0DD2             ;; digits[i] = '0' + (num % 10); 
1821   0DD2 FA FC FF      lea d, [bp + -4] ; $digits
1822   0DD5 D7            push a
1823   0DD6 DA            push d
1824   0DD7 FA FA FF      lea d, [bp + -6] ; $i
1825   0DDA 2A            mov b, [d]
1826   0DDB E7            pop d
1827   0DDC 5A            add d, b
1828   0DDD E4            pop a
1829   0DDE DA            push d
1830   0DDF 26 30 00      mov b, $30
1831   0DE2             ; START TERMS
1832   0DE2 D7            push a
1833   0DE3 11            mov a, b
1834   0DE4 FA 05 00      lea d, [bp + 5] ; $num
1835   0DE7 2A            mov b, [d]
1836   0DE8             ; START FACTORS
1837   0DE8 D7            push a
1838   0DE9 11            mov a, b
1839   0DEA 26 0A 00      mov b, $a
1840   0DED AE            div a, b ; 
1841   0DEE 11            mov a, b
1842   0DEF 27            mov b, a
1843   0DF0 E4            pop a
1844   0DF1             ; END FACTORS
1845   0DF1 54            add a, b
1846   0DF2 27            mov b, a
1847   0DF3 E4            pop a
1848   0DF4             ; END TERMS
1849   0DF4 E7            pop d
1850   0DF5 FD 3E         mov [d], bl
1851   0DF7             ;; num = num / 10; 
1852   0DF7 FA 05 00      lea d, [bp + 5] ; $num
1853   0DFA DA            push d
1854   0DFB FA 05 00      lea d, [bp + 5] ; $num
1855   0DFE 2A            mov b, [d]
1856   0DFF             ; START FACTORS
1857   0DFF D7            push a
1858   0E00 11            mov a, b
1859   0E01 26 0A 00      mov b, $a
1860   0E04 AE            div a, b
1861   0E05 27            mov b, a
1862   0E06 E4            pop a
1863   0E07             ; END FACTORS
1864   0E07 E7            pop d
1865   0E08 FD 43         mov [d], b
1866   0E0A             ;; i++; 
1867   0E0A FA FA FF      lea d, [bp + -6] ; $i
1868   0E0D 2A            mov b, [d]
1869   0E0E D8            push b
1870   0E0F FD 77         inc b
1871   0E11 FA FA FF      lea d, [bp + -6] ; $i
1872   0E14 FD 43         mov [d], b
1873   0E16 E5            pop b
1874   0E17 0A BF 0D      jmp _while27_cond
1875   0E1A             _while27_exit:
1876   0E1A             ;; while (i > 0) { 
1877   0E1A             _while28_cond:
1878   0E1A FA FA FF      lea d, [bp + -6] ; $i
1879   0E1D 2A            mov b, [d]
1880   0E1E             ; START RELATIONAL
1881   0E1E D7            push a
1882   0E1F 11            mov a, b
1883   0E20 26 00 00      mov b, $0
1884   0E23 B0            cmp a, b
1885   0E24 FD 7F         sgt ; >
1886   0E26 E4            pop a
1887   0E27             ; END RELATIONAL
1888   0E27 C0 00 00      cmp b, 0
1889   0E2A C6 53 0E      je _while28_exit
1890   0E2D             _while28_block:
1891   0E2D             ;; i--; 
1892   0E2D FA FA FF      lea d, [bp + -6] ; $i
1893   0E30 2A            mov b, [d]
1894   0E31 D8            push b
1895   0E32 FD 7D         dec b
1896   0E34 FA FA FF      lea d, [bp + -6] ; $i
1897   0E37 FD 43         mov [d], b
1898   0E39 E5            pop b
1899   0E3A             ;; putchar(digits[i]); 
1900   0E3A FA FC FF      lea d, [bp + -4] ; $digits
1901   0E3D D7            push a
1902   0E3E DA            push d
1903   0E3F FA FA FF      lea d, [bp + -6] ; $i
1904   0E42 2A            mov b, [d]
1905   0E43 E7            pop d
1906   0E44 5A            add d, b
1907   0E45 E4            pop a
1908   0E46 32            mov bl, [d]
1909   0E47 A7 00         mov bh, 0
1910   0E49 DD            push bl
1911   0E4A 07 5E 0E      call putchar
1912   0E4D 51 01 00      add sp, 1
1913   0E50 0A 1A 0E      jmp _while28_cond
1914   0E53             _while28_exit:
1915   0E53 F9            leave
1916   0E54 09            ret
1917   0E55             
1918   0E55             date:
1919   0E55 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1920   0E58             
1921   0E58             ; --- BEGIN INLINE ASM BLOCK
1922   0E58 19 00         mov al, 0 
1923   0E5A 05 07         syscall sys_datetime
1924   0E5C             ; --- END INLINE ASM BLOCK
1925   0E5C             
1926   0E5C F9            leave
1927   0E5D 09            ret
1928   0E5E             
1929   0E5E             putchar:
1930   0E5E F8 00 00      enter 0 ; (push bp; mov bp, sp)
1931   0E61             
1932   0E61             ; --- BEGIN INLINE ASM BLOCK
1933   0E61 FA 05 00      lea d, [bp + 5] ; $c
1934   0E64 1E            mov al, [d]
1935   0E65 23            mov ah, al
1936   0E66 07 3F 10      call _putchar
1937   0E69             ; --- END INLINE ASM BLOCK
1938   0E69             
1939   0E69 F9            leave
1940   0E6A 09            ret
1941   0E6B             
1942   0E6B             getchar:
1943   0E6B F8 00 00      enter 0 ; (push bp; mov bp, sp)
1944   0E6E             ; $c 
1945   0E6E 52 01 00      sub sp, 1
1946   0E71             
1947   0E71             ; --- BEGIN INLINE ASM BLOCK
1948   0E71 07 38 10      call getch
1949   0E74 1A            mov al, ah
1950   0E75 FA 00 00      lea d, [bp + 0] ; $c
1951   0E78 3E            mov [d], al
1952   0E79             ; --- END INLINE ASM BLOCK
1953   0E79             
1954   0E79             ;; return c; 
1955   0E79 FA 00 00      lea d, [bp + 0] ; $c
1956   0E7C 32            mov bl, [d]
1957   0E7D A7 00         mov bh, 0
1958   0E7F F9            leave
1959   0E80 09            ret
1960   0E81             
1961   0E81             scann:
1962   0E81 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1963   0E84             ; $m 
1964   0E84 52 02 00      sub sp, 2
1965   0E87             
1966   0E87             ; --- BEGIN INLINE ASM BLOCK
1967   0E87 07 83 12      call scan_u16d
1968   0E8A FA FF FF      lea d, [bp + -1] ; $m
1969   0E8D 43            mov [d], a
1970   0E8E             ; --- END INLINE ASM BLOCK
1971   0E8E             
1972   0E8E             ;; return m; 
1973   0E8E FA FF FF      lea d, [bp + -1] ; $m
1974   0E91 2A            mov b, [d]
1975   0E92 F9            leave
1976   0E93 09            ret
1977   0E94             
1978   0E94             puts:
1979   0E94 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1980   0E97             
1981   0E97             ; --- BEGIN INLINE ASM BLOCK
1982   0E97 FA 05 00      lea d, [bp + 5] ; $s
1983   0E9A 15            mov a, [d]
1984   0E9B 3C            mov d, a
1985   0E9C 07 89 11      call _puts
1986   0E9F 10 00 0A      mov a, $0A00
1987   0EA2 05 03         syscall sys_io
1988   0EA4             ; --- END INLINE ASM BLOCK
1989   0EA4             
1990   0EA4 F9            leave
1991   0EA5 09            ret
1992   0EA6             
1993   0EA6             print:
1994   0EA6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1995   0EA9             
1996   0EA9             ; --- BEGIN INLINE ASM BLOCK
1997   0EA9 FA 05 00      lea d, [bp + 5] ; $s
1998   0EAC FD 2A         mov d, [d]
1999   0EAE 07 89 11      call _puts
2000   0EB1             ; --- END INLINE ASM BLOCK
2001   0EB1             
2002   0EB1 F9            leave
2003   0EB2 09            ret
2004   0EB3             
2005   0EB3             loadfile:
2006   0EB3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2007   0EB6             
2008   0EB6             ; --- BEGIN INLINE ASM BLOCK
2009   0EB6 FA 07 00      lea d, [bp + 7] ; $destination
2010   0EB9 15            mov a, [d]
2011   0EBA 4F            mov di, a
2012   0EBB FA 05 00      lea d, [bp + 5] ; $filename
2013   0EBE FD 2A         mov d, [d]
2014   0EC0 19 14         mov al, 20
2015   0EC2 05 04         syscall sys_filesystem
2016   0EC4             ; --- END INLINE ASM BLOCK
2017   0EC4             
2018   0EC4 F9            leave
2019   0EC5 09            ret
2020   0EC6             
2021   0EC6             create_file:
2022   0EC6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2023   0EC9 F9            leave
2024   0ECA 09            ret
2025   0ECB             
2026   0ECB             delete_file:
2027   0ECB F8 00 00      enter 0 ; (push bp; mov bp, sp)
2028   0ECE             
2029   0ECE             ; --- BEGIN INLINE ASM BLOCK
2030   0ECE FA 05 00      lea d, [bp + 5] ; $filename
2031   0ED1 19 0A         mov al, 10
2032   0ED3 05 04         syscall sys_filesystem
2033   0ED5             ; --- END INLINE ASM BLOCK
2034   0ED5             
2035   0ED5 F9            leave
2036   0ED6 09            ret
2037   0ED7             
2038   0ED7             fopen:
2039   0ED7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2040   0EDA F9            leave
2041   0EDB 09            ret
2042   0EDC             
2043   0EDC             fclose:
2044   0EDC F8 00 00      enter 0 ; (push bp; mov bp, sp)
2045   0EDF F9            leave
2046   0EE0 09            ret
2047   0EE1             
2048   0EE1             load_hex:
2049   0EE1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2050   0EE4             ; $temp 
2051   0EE4 52 02 00      sub sp, 2
2052   0EE7             ;; temp = alloc(32768); 
2053   0EE7 FA FF FF      lea d, [bp + -1] ; $temp
2054   0EEA DA            push d
2055   0EEB 26 00 80      mov b, $8000
2056   0EEE FD AB         swp b
2057   0EF0 D8            push b
2058   0EF1 07 23 14      call alloc
2059   0EF4 51 02 00      add sp, 2
2060   0EF7 E7            pop d
2061   0EF8 FD 43         mov [d], b
2062   0EFA             
2063   0EFA             ; --- BEGIN INLINE ASM BLOCK
2064   0EFA               
2065   0EFA               
2066   0EFA               
2067   0EFA               
2068   0EFA               
2069   0EFA             _load_hex:
2070   0EFA D7            push a
2071   0EFB D8            push b
2072   0EFC DA            push d
2073   0EFD E2            push si
2074   0EFE E3            push di
2075   0EFF 52 00 80      sub sp, $8000      
2076   0F02 38 00 00      mov c, 0
2077   0F05 48            mov a, sp
2078   0F06 77            inc a
2079   0F07 3C            mov d, a          
2080   0F08 07 46 10      call _gets        
2081   0F0B 4D            mov si, a
2082   0F0C             __load_hex_loop:
2083   0F0C F6            lodsb             
2084   0F0D B9 00         cmp al, 0         
2085   0F0F C6 1D 0F      jz __load_hex_ret
2086   0F12 36            mov bh, al
2087   0F13 F6            lodsb
2088   0F14 2F            mov bl, al
2089   0F15 07 FC 0F      call _atoi        
2090   0F18 F7            stosb             
2091   0F19 78            inc c
2092   0F1A 0A 0C 0F      jmp __load_hex_loop
2093   0F1D             __load_hex_ret:
2094   0F1D 51 00 80      add sp, $8000
2095   0F20 F0            pop di
2096   0F21 EF            pop si
2097   0F22 E7            pop d
2098   0F23 E5            pop b
2099   0F24 E4            pop a
2100   0F25             ; --- END INLINE ASM BLOCK
2101   0F25             
2102   0F25 F9            leave
2103   0F26 09            ret
2104   0F27             
2105   0F27             getparam:
2106   0F27 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2107   0F2A             ; $data 
2108   0F2A 52 01 00      sub sp, 1
2109   0F2D             
2110   0F2D             ; --- BEGIN INLINE ASM BLOCK
2111   0F2D 19 04         mov al, 4
2112   0F2F FA 05 00      lea d, [bp + 5] ; $address
2113   0F32 FD 2A         mov d, [d]
2114   0F34 05 0C         syscall sys_system
2115   0F36 FA 00 00      lea d, [bp + 0] ; $data
2116   0F39 FD 3E         mov [d], bl
2117   0F3B             ; --- END INLINE ASM BLOCK
2118   0F3B             
2119   0F3B             ;; return data; 
2120   0F3B FA 00 00      lea d, [bp + 0] ; $data
2121   0F3E 32            mov bl, [d]
2122   0F3F A7 00         mov bh, 0
2123   0F41 F9            leave
2124   0F42 09            ret
2125   0F43             
2126   0F43             clear:
2127   0F43 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2128   0F46             ;; print("\033[2J\033[H"); 
2129   0F46 26 48 18      mov b, __s2 ; "\033[2J\033[H"
2130   0F49 FD AB         swp b
2131   0F4B D8            push b
2132   0F4C 07 A6 0E      call print
2133   0F4F 51 02 00      add sp, 2
2134   0F52 F9            leave
2135   0F53 09            ret
2136   0F54             
2137   0F54             include_stdio_asm:
2138   0F54 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2139   0F57             
2140   0F57             ; --- BEGIN INLINE ASM BLOCK
2141   0F57             .include "lib/asm/stdio.asm"
0001+  0F57             ;-----------------------------------------------------------------------------
0002+  0F57             ; stdio.s
0003+  0F57             ;-----------------------------------------------------------------------------
0004+  0F57             .include "lib/asm/string.asm"
0001++ 0F57             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0F57             ; string.s
0003++ 0F57             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0F57             
0005++ 0F57             
0006++ 0F57             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0F57             ; _strrev
0008++ 0F57             ; reverse a string
0009++ 0F57             ; D = string address
0010++ 0F57             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0F57             ; 01234
0012++ 0F57             _strrev:
0013++ 0F57 4B          	pusha
0014++ 0F58 07 9E 0F    	call _strlen	; length in C
0015++ 0F5B 12          	mov a, c
0016++ 0F5C AF 01 00    	cmp a, 1
0017++ 0F5F D0 79 0F    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 0F62 7D          	dec a
0019++ 0F63 FD 4E       	mov si, d	; beginning of string
0020++ 0F65 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0F67 59          	add d, a	; end of string
0022++ 0F68 12          	mov a, c
0023++ 0F69 FD 9B       	shr a		; divide by 2
0024++ 0F6B 39          	mov c, a	; C now counts the steps
0025++ 0F6C             _strrev_L0:
0026++ 0F6C 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0F6D F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0F6E 3E          	mov [d], al	; store left char into right side
0029++ 0F6F 1B          	mov al, bl
0030++ 0F70 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0F71 7E          	dec c
0032++ 0F72 7F          	dec d
0033++ 0F73 C2 00 00    	cmp c, 0
0034++ 0F76 C7 6C 0F    	jne _strrev_L0
0035++ 0F79             _strrev_end:
0036++ 0F79 4C          	popa
0037++ 0F7A 09          	ret
0038++ 0F7B             	
0039++ 0F7B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0F7B             ; _strchr
0041++ 0F7B             ; search string in D for char in AL
0042++ 0F7B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0F7B             _strchr:
0044++ 0F7B             _strchr_L0:
0045++ 0F7B 32          	mov bl, [d]
0046++ 0F7C C1 00       	cmp bl, 0
0047++ 0F7E C6 89 0F    	je _strchr_end
0048++ 0F81 BA          	cmp al, bl
0049++ 0F82 C6 89 0F    	je _strchr_end
0050++ 0F85 79          	inc d
0051++ 0F86 0A 7B 0F    	jmp _strchr_L0
0052++ 0F89             _strchr_end:
0053++ 0F89 1B          	mov al, bl
0054++ 0F8A 09          	ret
0055++ 0F8B             
0056++ 0F8B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0F8B             ; _strstr
0058++ 0F8B             ; find sub-string
0059++ 0F8B             ; str1 in SI
0060++ 0F8B             ; str2 in DI
0061++ 0F8B             ; SI points to end of source string
0062++ 0F8B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0F8B             _strstr:
0064++ 0F8B DB          	push al
0065++ 0F8C DA          	push d
0066++ 0F8D E3          	push di
0067++ 0F8E             _strstr_loop:
0068++ 0F8E F3          	cmpsb					; compare a byte of the strings
0069++ 0F8F C7 9A 0F    	jne _strstr_ret
0070++ 0F92 FC 00 00    	lea d, [di + 0]
0071++ 0F95 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0F97 C7 8E 0F    	jne _strstr_loop				; equal chars but not at end
0073++ 0F9A             _strstr_ret:
0074++ 0F9A F0          	pop di
0075++ 0F9B E7          	pop d
0076++ 0F9C E8          	pop al
0077++ 0F9D 09          	ret
0078++ 0F9E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0F9E             ; length of null terminated string
0080++ 0F9E             ; result in C
0081++ 0F9E             ; pointer in D
0082++ 0F9E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0F9E             _strlen:
0084++ 0F9E DA          	push d
0085++ 0F9F 38 00 00    	mov c, 0
0086++ 0FA2             _strlen_L1:
0087++ 0FA2 BD 00       	cmp byte [d], 0
0088++ 0FA4 C6 AC 0F    	je _strlen_ret
0089++ 0FA7 79          	inc d
0090++ 0FA8 78          	inc c
0091++ 0FA9 0A A2 0F    	jmp _strlen_L1
0092++ 0FAC             _strlen_ret:
0093++ 0FAC E7          	pop d
0094++ 0FAD 09          	ret
0095++ 0FAE             
0096++ 0FAE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0FAE             ; STRCMP
0098++ 0FAE             ; compare two strings
0099++ 0FAE             ; str1 in SI
0100++ 0FAE             ; str2 in DI
0101++ 0FAE             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0FAE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0FAE             _strcmp:
0104++ 0FAE DB          	push al
0105++ 0FAF DA          	push d
0106++ 0FB0 E3          	push di
0107++ 0FB1 E2          	push si
0108++ 0FB2             _strcmp_loop:
0109++ 0FB2 F3          	cmpsb					; compare a byte of the strings
0110++ 0FB3 C7 BE 0F    	jne _strcmp_ret
0111++ 0FB6 FB FF FF    	lea d, [si +- 1]
0112++ 0FB9 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0FBB C7 B2 0F    	jne _strcmp_loop				; equal chars but not at end
0114++ 0FBE             _strcmp_ret:
0115++ 0FBE EF          	pop si
0116++ 0FBF F0          	pop di
0117++ 0FC0 E7          	pop d
0118++ 0FC1 E8          	pop al
0119++ 0FC2 09          	ret
0120++ 0FC3             
0121++ 0FC3             
0122++ 0FC3             ; STRCPY
0123++ 0FC3             ; copy null terminated string from SI to DI
0124++ 0FC3             ; source in SI
0125++ 0FC3             ; destination in DI
0126++ 0FC3             _strcpy:
0127++ 0FC3 E2          	push si
0128++ 0FC4 E3          	push di
0129++ 0FC5 DB          	push al
0130++ 0FC6             _strcpy_L1:
0131++ 0FC6 F6          	lodsb
0132++ 0FC7 F7          	stosb
0133++ 0FC8 B9 00       	cmp al, 0
0134++ 0FCA C7 C6 0F    	jne _strcpy_L1
0135++ 0FCD             _strcpy_end:
0136++ 0FCD E8          	pop al
0137++ 0FCE F0          	pop di
0138++ 0FCF EF          	pop si
0139++ 0FD0 09          	ret
0140++ 0FD1             
0141++ 0FD1             ; STRCAT
0142++ 0FD1             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0FD1             ; source in SI
0144++ 0FD1             ; destination in DI
0145++ 0FD1             _strcat:
0146++ 0FD1 E2          	push si
0147++ 0FD2 E3          	push di
0148++ 0FD3 D7          	push a
0149++ 0FD4 DA          	push d
0150++ 0FD5 50          	mov a, di
0151++ 0FD6 3C          	mov d, a
0152++ 0FD7             _strcat_goto_end_L1:
0153++ 0FD7 BD 00       	cmp byte[d], 0
0154++ 0FD9 C6 E0 0F    	je _strcat_start
0155++ 0FDC 79          	inc d
0156++ 0FDD 0A D7 0F    	jmp _strcat_goto_end_L1
0157++ 0FE0             _strcat_start:
0158++ 0FE0 FD 50       	mov di, d
0159++ 0FE2             _strcat_L1:
0160++ 0FE2 F6          	lodsb
0161++ 0FE3 F7          	stosb
0162++ 0FE4 B9 00       	cmp al, 0
0163++ 0FE6 C7 E2 0F    	jne _strcat_L1
0164++ 0FE9             _strcat_end:
0165++ 0FE9 E7          	pop d
0166++ 0FEA E4          	pop a
0167++ 0FEB F0          	pop di
0168++ 0FEC EF          	pop si
0169++ 0FED 09          	ret
0170++ 0FEE             
0171++ 0FEE             
0005+  0FEE             
0006+  0FEE             ;-----------------------------------------------------------------------------
0007+  0FEE             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0008+  0FEE             ; ASCII in BL
0009+  0FEE             ; result in AL
0010+  0FEE             ; ascii for F = 0100 0110
0011+  0FEE             ; ascii for 9 = 0011 1001
0012+  0FEE             ;-----------------------------------------------------------------------------
0013+  0FEE             hex_ascii_encode:
0014+  0FEE 1B            mov al, bl
0015+  0FEF 93 40         test al, $40        ; test if letter or number
0016+  0FF1 C7 F7 0F      jnz hex_letter
0017+  0FF4 87 0F         and al, $0F        ; get number
0018+  0FF6 09            ret
0019+  0FF7             hex_letter:
0020+  0FF7 87 0F         and al, $0F        ; get letter
0021+  0FF9 6A 09         add al, 9
0022+  0FFB 09            ret
0023+  0FFC             
0024+  0FFC             ;-----------------------------------------------------------------------------
0025+  0FFC             ; ATOI
0026+  0FFC             ; 2 letter hex string in B
0027+  0FFC             ; 8bit integer returned in AL
0028+  0FFC             ;-----------------------------------------------------------------------------
0029+  0FFC             _atoi:
0030+  0FFC D8            push b
0031+  0FFD 07 EE 0F      call hex_ascii_encode      ; convert BL to 4bit code in AL
0032+  1000 30            mov bl, bh
0033+  1001 DB            push al          ; save a
0034+  1002 07 EE 0F      call hex_ascii_encode
0035+  1005 EA            pop bl  
0036+  1006 FD 9E 04      shl al, 4
0037+  1009 8C            or al, bl
0038+  100A E5            pop b
0039+  100B 09            ret  
0040+  100C             
0041+  100C             ;-----------------------------------------------------------------------------
0042+  100C             ; scanf
0043+  100C             ; no need for explanations!
0044+  100C             ;-----------------------------------------------------------------------------
0045+  100C             scanf:
0046+  100C 09            ret
0047+  100D             
0048+  100D             ;-----------------------------------------------------------------------------
0049+  100D             ; ITOA
0050+  100D             ; 8bit value in BL
0051+  100D             ; 2 byte ASCII result in A
0052+  100D             ;-----------------------------------------------------------------------------
0053+  100D             _itoa:
0054+  100D DA            push d
0055+  100E D8            push b
0056+  100F A7 00         mov bh, 0
0057+  1011 FD A4 04      shr bl, 4  
0058+  1014 74            mov d, b
0059+  1015 1F BD 12      mov al, [d + s_hex_digits]
0060+  1018 23            mov ah, al
0061+  1019               
0062+  1019 E5            pop b
0063+  101A D8            push b
0064+  101B A7 00         mov bh, 0
0065+  101D FD 87 0F      and bl, $0F
0066+  1020 74            mov d, b
0067+  1021 1F BD 12      mov al, [d + s_hex_digits]
0068+  1024 E5            pop b
0069+  1025 E7            pop d
0070+  1026 09            ret
0071+  1027             
0072+  1027             ;-----------------------------------------------------------------------------
0073+  1027             ; HEX STRING TO BINARY
0074+  1027             ; di = destination address
0075+  1027             ; si = source
0076+  1027             ;-----------------------------------------------------------------------------
0077+  1027             _hex_to_int:
0078+  1027             _hex_to_int_L1:
0079+  1027 F6            lodsb          ; load from [SI] to AL
0080+  1028 B9 00         cmp al, 0        ; check if ASCII 0
0081+  102A C6 37 10      jz _hex_to_int_ret
0082+  102D 36            mov bh, al
0083+  102E F6            lodsb
0084+  102F 2F            mov bl, al
0085+  1030 07 FC 0F      call _atoi        ; convert ASCII byte in B to int (to AL)
0086+  1033 F7            stosb          ; store AL to [DI]
0087+  1034 0A 27 10      jmp _hex_to_int_L1
0088+  1037             _hex_to_int_ret:
0089+  1037 09            ret    
0090+  1038             
0091+  1038             ;-----------------------------------------------------------------------------
0092+  1038             ; GETCHAR
0093+  1038             ; char in ah
0094+  1038             ;-----------------------------------------------------------------------------
0095+  1038             getch:
0096+  1038 DB            push al
0097+  1039             getch_retry:
0098+  1039 19 01         mov al, 1
0099+  103B 05 03         syscall sys_io      ; receive in AH
0100+  103D E8            pop al
0101+  103E 09            ret
0102+  103F             
0103+  103F             ;-----------------------------------------------------------------------------
0104+  103F             ; PUTCHAR
0105+  103F             ; char in ah
0106+  103F             ;-----------------------------------------------------------------------------
0107+  103F             _putchar:
0108+  103F D7            push a
0109+  1040 19 00         mov al, 0
0110+  1042 05 03         syscall sys_io      ; char in AH
0111+  1044 E4            pop a
0112+  1045 09            ret
0113+  1046             
0114+  1046             ;-----------------------------------------------------------------------------
0115+  1046             ;; INPUT A STRING
0116+  1046             ;; terminates with null
0117+  1046             ;; pointer in D
0118+  1046             ;-----------------------------------------------------------------------------
0119+  1046             _gets:
0120+  1046 D7            push a
0121+  1047 DA            push d
0122+  1048             _gets_loop:
0123+  1048 19 01         mov al, 1
0124+  104A 05 03         syscall sys_io      ; receive in AH
0125+  104C B9 00         cmp al, 0        ; check error code (AL)
0126+  104E C6 48 10      je _gets_loop      ; if no char received, retry
0127+  1051             
0128+  1051 76 1B         cmp ah, 27
0129+  1053 C6 74 10      je _gets_ansi_esc
0130+  1056 76 0A         cmp ah, $0A        ; LF
0131+  1058 C6 DF 10      je _gets_end
0132+  105B 76 0D         cmp ah, $0D        ; CR
0133+  105D C6 DF 10      je _gets_end
0134+  1060 76 5C         cmp ah, $5C        ; '\\'
0135+  1062 C6 A0 10      je _gets_escape
0136+  1065               
0137+  1065 76 08         cmp ah, $08      ; check for backspace
0138+  1067 C6 70 10      je _gets_backspace
0139+  106A             
0140+  106A 1A            mov al, ah
0141+  106B 3E            mov [d], al
0142+  106C 79            inc d
0143+  106D 0A 48 10      jmp _gets_loop
0144+  1070             _gets_backspace:
0145+  1070 7F            dec d
0146+  1071 0A 48 10      jmp _gets_loop
0147+  1074             _gets_ansi_esc:
0148+  1074 19 01         mov al, 1
0149+  1076 05 03         syscall sys_io        ; receive in AH without echo
0150+  1078 B9 00         cmp al, 0          ; check error code (AL)
0151+  107A C6 74 10      je _gets_ansi_esc    ; if no char received, retry
0152+  107D 76 5B         cmp ah, '['
0153+  107F C7 48 10      jne _gets_loop
0154+  1082             _gets_ansi_esc_2:
0155+  1082 19 01         mov al, 1
0156+  1084 05 03         syscall sys_io          ; receive in AH without echo
0157+  1086 B9 00         cmp al, 0            ; check error code (AL)
0158+  1088 C6 82 10      je _gets_ansi_esc_2  ; if no char received, retry
0159+  108B 76 44         cmp ah, 'D'
0160+  108D C6 98 10      je _gets_left_arrow
0161+  1090 76 43         cmp ah, 'C'
0162+  1092 C6 9C 10      je _gets_right_arrow
0163+  1095 0A 48 10      jmp _gets_loop
0164+  1098             _gets_left_arrow:
0165+  1098 7F            dec d
0166+  1099 0A 48 10      jmp _gets_loop
0167+  109C             _gets_right_arrow:
0168+  109C 79            inc d
0169+  109D 0A 48 10      jmp _gets_loop
0170+  10A0             _gets_escape:
0171+  10A0 19 01         mov al, 1
0172+  10A2 05 03         syscall sys_io      ; receive in AH
0173+  10A4 B9 00         cmp al, 0        ; check error code (AL)
0174+  10A6 C6 A0 10      je _gets_escape      ; if no char received, retry
0175+  10A9 76 6E         cmp ah, 'n'
0176+  10AB C6 CA 10      je _gets_LF
0177+  10AE 76 72         cmp ah, 'r'
0178+  10B0 C6 D1 10      je _gets_CR
0179+  10B3 76 30         cmp ah, '0'
0180+  10B5 C6 D8 10      je _gets_NULL
0181+  10B8 76 5C         cmp ah, $5C  ; '\'
0182+  10BA C6 C3 10      je _gets_slash
0183+  10BD 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0184+  10BE 3E            mov [d], al
0185+  10BF 79            inc d
0186+  10C0 0A 48 10      jmp _gets_loop
0187+  10C3             _gets_slash:
0188+  10C3 19 5C         mov al, $5C
0189+  10C5 3E            mov [d], al
0190+  10C6 79            inc d
0191+  10C7 0A 48 10      jmp _gets_loop
0192+  10CA             _gets_LF:
0193+  10CA 19 0A         mov al, $0A
0194+  10CC 3E            mov [d], al
0195+  10CD 79            inc d
0196+  10CE 0A 48 10      jmp _gets_loop
0197+  10D1             _gets_CR:
0198+  10D1 19 0D         mov al, $0D
0199+  10D3 3E            mov [d], al
0200+  10D4 79            inc d
0201+  10D5 0A 48 10      jmp _gets_loop
0202+  10D8             _gets_NULL:
0203+  10D8 19 00         mov al, $00
0204+  10DA 3E            mov [d], al
0205+  10DB 79            inc d
0206+  10DC 0A 48 10      jmp _gets_loop
0207+  10DF             _gets_end:
0208+  10DF 19 00         mov al, 0
0209+  10E1 3E            mov [d], al        ; terminate string
0210+  10E2 E7            pop d
0211+  10E3 E4            pop a
0212+  10E4 09            ret
0213+  10E5             
0214+  10E5             ;-----------------------------------------------------------------------------
0215+  10E5             ;; INPUT TEXT
0216+  10E5             ;; terminated with CTRL+D
0217+  10E5             ;; pointer in D
0218+  10E5             ;-----------------------------------------------------------------------------
0219+  10E5             _gettxt:
0220+  10E5 D7            push a
0221+  10E6 DA            push d
0222+  10E7             _gettxt_loop:
0223+  10E7 19 01         mov al, 1
0224+  10E9 05 03         syscall sys_io      ; receive in AH
0225+  10EB B9 00         cmp al, 0        ; check error code (AL)
0226+  10ED C6 E7 10      je _gettxt_loop    ; if no char received, retry
0227+  10F0 76 04         cmp ah, 4      ; EOT
0228+  10F2 C6 30 11      je _gettxt_end
0229+  10F5 76 08         cmp ah, $08      ; check for backspace
0230+  10F7 C6 2C 11      je _gettxt_backspace
0231+  10FA 76 5C         cmp ah, $5C        ; '\'
0232+  10FC C6 05 11      je _gettxt_escape
0233+  10FF 1A            mov al, ah
0234+  1100 3E            mov [d], al
0235+  1101 79            inc d
0236+  1102 0A E7 10      jmp _gettxt_loop
0237+  1105             _gettxt_escape:
0238+  1105 19 01         mov al, 1
0239+  1107 05 03         syscall sys_io      ; receive in AH
0240+  1109 B9 00         cmp al, 0        ; check error code (AL)
0241+  110B C6 05 11      je _gettxt_escape    ; if no char received, retry
0242+  110E 76 6E         cmp ah, 'n'
0243+  1110 C6 1E 11      je _gettxt_LF
0244+  1113 76 72         cmp ah, 'r'
0245+  1115 C6 25 11      je _gettxt_CR
0246+  1118 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0247+  1119 3E            mov [d], al
0248+  111A 79            inc d
0249+  111B 0A E7 10      jmp _gettxt_loop
0250+  111E             _gettxt_LF:
0251+  111E 19 0A         mov al, $0A
0252+  1120 3E            mov [d], al
0253+  1121 79            inc d
0254+  1122 0A E7 10      jmp _gettxt_loop
0255+  1125             _gettxt_CR:
0256+  1125 19 0D         mov al, $0D
0257+  1127 3E            mov [d], al
0258+  1128 79            inc d
0259+  1129 0A E7 10      jmp _gettxt_loop
0260+  112C             _gettxt_backspace:
0261+  112C 7F            dec d
0262+  112D 0A E7 10      jmp _gettxt_loop
0263+  1130             _gettxt_end:
0264+  1130 19 00         mov al, 0
0265+  1132 3E            mov [d], al        ; terminate string
0266+  1133 E7            pop d
0267+  1134 E4            pop a
0268+  1135 09            ret
0269+  1136             
0270+  1136             ;-----------------------------------------------------------------------------
0271+  1136             ; PRINT NEW LINE
0272+  1136             ;-----------------------------------------------------------------------------
0273+  1136             printnl:
0274+  1136 D7            push a
0275+  1137 10 00 0A      mov a, $0A00
0276+  113A 05 03         syscall sys_io
0277+  113C 10 00 0D      mov a, $0D00
0278+  113F 05 03         syscall sys_io
0279+  1141 E4            pop a
0280+  1142 09            ret
0281+  1143             
0282+  1143             ;-----------------------------------------------------------------------------
0283+  1143             ; _strtoint
0284+  1143             ; 4 digit hex string number in d
0285+  1143             ; integer returned in A
0286+  1143             ;-----------------------------------------------------------------------------
0287+  1143             _strtointx:
0288+  1143 D8            push b
0289+  1144 32            mov bl, [d]
0290+  1145 37            mov bh, bl
0291+  1146 33 01 00      mov bl, [d + 1]
0292+  1149 07 FC 0F      call _atoi        ; convert to int in AL
0293+  114C 23            mov ah, al        ; move to AH
0294+  114D 33 02 00      mov bl, [d + 2]
0295+  1150 37            mov bh, bl
0296+  1151 33 03 00      mov bl, [d + 3]
0297+  1154 07 FC 0F      call _atoi        ; convert to int in AL
0298+  1157 E5            pop b
0299+  1158 09            ret
0300+  1159             
0301+  1159             ;-----------------------------------------------------------------------------
0302+  1159             ; _strtoint
0303+  1159             ; 5 digit base10 string number in d
0304+  1159             ; integer returned in A
0305+  1159             ;-----------------------------------------------------------------------------
0306+  1159             _strtoint:
0307+  1159 E2            push si
0308+  115A D8            push b
0309+  115B D9            push c
0310+  115C DA            push d
0311+  115D 07 9E 0F      call _strlen      ; get string length in C
0312+  1160 7E            dec c
0313+  1161 FD 4E         mov si, d
0314+  1163 12            mov a, c
0315+  1164 FD 99         shl a
0316+  1166 3B D5 12      mov d, table_power
0317+  1169 59            add d, a
0318+  116A 38 00 00      mov c, 0
0319+  116D             _strtoint_L0:
0320+  116D F6            lodsb      ; load ASCII to al
0321+  116E B9 00         cmp al, 0
0322+  1170 C6 83 11      je _strtoint_end
0323+  1173 6F 30         sub al, $30    ; make into integer
0324+  1175 22 00         mov ah, 0
0325+  1177 2A            mov b, [d]
0326+  1178 AC            mul a, b      ; result in B since it fits in 16bits
0327+  1179 11            mov a, b
0328+  117A 28            mov b, c
0329+  117B 54            add a, b
0330+  117C 39            mov c, a
0331+  117D 63 02 00      sub d, 2
0332+  1180 0A 6D 11      jmp _strtoint_L0
0333+  1183             _strtoint_end:
0334+  1183 12            mov a, c
0335+  1184 E7            pop d
0336+  1185 E6            pop c
0337+  1186 E5            pop b
0338+  1187 EF            pop si
0339+  1188 09            ret
0340+  1189             
0341+  1189             ;-----------------------------------------------------------------------------
0342+  1189             ; PRINT NULL TERMINATED STRING
0343+  1189             ; pointer in D
0344+  1189             ;-----------------------------------------------------------------------------
0345+  1189             _puts:
0346+  1189 D7            push a
0347+  118A DA            push d
0348+  118B             _puts_L1:
0349+  118B 1E            mov al, [d]
0350+  118C B9 00         cmp al, 0
0351+  118E C6 9A 11      jz _puts_END
0352+  1191 23            mov ah, al
0353+  1192 19 00         mov al, 0
0354+  1194 05 03         syscall sys_io
0355+  1196 79            inc d
0356+  1197 0A 8B 11      jmp _puts_L1
0357+  119A             _puts_END:
0358+  119A E7            pop d
0359+  119B E4            pop a
0360+  119C 09            ret
0361+  119D             
0362+  119D             ;-----------------------------------------------------------------------------
0363+  119D             ; PRINT N SIZE STRING
0364+  119D             ; pointer in D
0365+  119D             ; size in C
0366+  119D             ;-----------------------------------------------------------------------------
0367+  119D             _putsn:
0368+  119D DB            push al
0369+  119E DA            push d
0370+  119F D9            push c
0371+  11A0             _putsn_L0:
0372+  11A0 1E            mov al, [d]
0373+  11A1 23            mov ah, al
0374+  11A2 19 00         mov al, 0
0375+  11A4 05 03         syscall sys_io
0376+  11A6 79            inc d
0377+  11A7 7E            dec c  
0378+  11A8 C2 00 00      cmp c, 0
0379+  11AB C7 A0 11      jne _putsn_L0
0380+  11AE             _putsn_end:
0381+  11AE E6            pop c
0382+  11AF E7            pop d
0383+  11B0 E8            pop al
0384+  11B1 09            ret
0385+  11B2             
0386+  11B2             ;-----------------------------------------------------------------------------
0387+  11B2             ; print 16bit decimal number
0388+  11B2             ; input number in A
0389+  11B2             ;-----------------------------------------------------------------------------
0390+  11B2             print_u16d:
0391+  11B2 D7            push a
0392+  11B3 D8            push b
0393+  11B4 26 10 27      mov b, 10000
0394+  11B7 AE            div a, b      ; get 10000's coeff.
0395+  11B8 07 DA 11      call print_number
0396+  11BB 11            mov a, b
0397+  11BC 26 E8 03      mov b, 1000
0398+  11BF AE            div a, b      ; get 1000's coeff.
0399+  11C0 07 DA 11      call print_number
0400+  11C3 11            mov a, b
0401+  11C4 26 64 00      mov b, 100
0402+  11C7 AE            div a, b
0403+  11C8 07 DA 11      call print_number
0404+  11CB 11            mov a, b
0405+  11CC 26 0A 00      mov b, 10
0406+  11CF AE            div a, b
0407+  11D0 07 DA 11      call print_number
0408+  11D3 1B            mov al, bl      ; 1's coeff in bl
0409+  11D4 07 DA 11      call print_number
0410+  11D7 E5            pop b
0411+  11D8 E4            pop a
0412+  11D9 09            ret
0413+  11DA             
0414+  11DA             ;-----------------------------------------------------------------------------
0415+  11DA             ; print AL
0416+  11DA             ;-----------------------------------------------------------------------------
0417+  11DA             print_number:
0418+  11DA 6A 30         add al, $30
0419+  11DC 23            mov ah, al
0420+  11DD 07 3F 10      call _putchar
0421+  11E0 09            ret
0422+  11E1             
0423+  11E1             ;-----------------------------------------------------------------------------
0424+  11E1             ; PRINT 16BIT HEX INTEGER
0425+  11E1             ; integer value in reg B
0426+  11E1             ;-----------------------------------------------------------------------------
0427+  11E1             print_u16x:
0428+  11E1 D7            push a
0429+  11E2 D8            push b
0430+  11E3 DD            push bl
0431+  11E4 30            mov bl, bh
0432+  11E5 07 0D 10      call _itoa        ; convert bh to char in A
0433+  11E8 2F            mov bl, al        ; save al
0434+  11E9 19 00         mov al, 0
0435+  11EB 05 03         syscall sys_io        ; display AH
0436+  11ED 24            mov ah, bl        ; retrieve al
0437+  11EE 19 00         mov al, 0
0438+  11F0 05 03         syscall sys_io        ; display AL
0439+  11F2             
0440+  11F2 EA            pop bl
0441+  11F3 07 0D 10      call _itoa        ; convert bh to char in A
0442+  11F6 2F            mov bl, al        ; save al
0443+  11F7 19 00         mov al, 0
0444+  11F9 05 03         syscall sys_io        ; display AH
0445+  11FB 24            mov ah, bl        ; retrieve al
0446+  11FC 19 00         mov al, 0
0447+  11FE 05 03         syscall sys_io        ; display AL
0448+  1200             
0449+  1200 E5            pop b
0450+  1201 E4            pop a
0451+  1202 09            ret
0452+  1203             
0453+  1203             ;-----------------------------------------------------------------------------
0454+  1203             ; INPUT 16BIT HEX INTEGER
0455+  1203             ; read 16bit integer into A
0456+  1203             ;-----------------------------------------------------------------------------
0457+  1203             scan_u16x:
0458+  1203 F8 10 00      enter 16
0459+  1206 D8            push b
0460+  1207 DA            push d
0461+  1208             
0462+  1208 FA F1 FF      lea d, [bp + -15]
0463+  120B 07 46 10      call _gets        ; get number
0464+  120E             
0465+  120E 32            mov bl, [d]
0466+  120F 37            mov bh, bl
0467+  1210 33 01 00      mov bl, [d + 1]
0468+  1213 07 FC 0F      call _atoi        ; convert to int in AL
0469+  1216 23            mov ah, al        ; move to AH
0470+  1217             
0471+  1217 33 02 00      mov bl, [d + 2]
0472+  121A 37            mov bh, bl
0473+  121B 33 03 00      mov bl, [d + 3]
0474+  121E 07 FC 0F      call _atoi        ; convert to int in AL
0475+  1221             
0476+  1221 E7            pop d
0477+  1222 E5            pop b
0478+  1223 F9            leave
0479+  1224 09            ret
0480+  1225             
0481+  1225             ;-----------------------------------------------------------------------------
0482+  1225             ; PRINT 8bit HEX INTEGER
0483+  1225             ; integer value in reg bl
0484+  1225             ;-----------------------------------------------------------------------------
0485+  1225             print_u8x:
0486+  1225 D7            push a
0487+  1226 DD            push bl
0488+  1227             
0489+  1227 07 0D 10      call _itoa        ; convert bl to char in A
0490+  122A 2F            mov bl, al        ; save al
0491+  122B 19 00         mov al, 0
0492+  122D 05 03         syscall sys_io        ; display AH
0493+  122F 24            mov ah, bl        ; retrieve al
0494+  1230 19 00         mov al, 0
0495+  1232 05 03         syscall sys_io        ; display AL
0496+  1234             
0497+  1234 EA            pop bl
0498+  1235 E4            pop a
0499+  1236 09            ret
0500+  1237             
0501+  1237             ;-----------------------------------------------------------------------------
0502+  1237             ; print 8bit decimal unsigned number
0503+  1237             ; input number in AL
0504+  1237             ;-----------------------------------------------------------------------------
0505+  1237             print_u8d:
0506+  1237 D7            push a
0507+  1238 D8            push b
0508+  1239             
0509+  1239 22 00         mov ah, 0
0510+  123B 26 64 00      mov b, 100
0511+  123E AE            div a, b
0512+  123F D8            push b      ; save remainder
0513+  1240 B9 00         cmp al, 0
0514+  1242 C6 4C 12      je skip100
0515+  1245 6A 30         add al, $30
0516+  1247 23            mov ah, al
0517+  1248 19 00         mov al, 0
0518+  124A 05 03         syscall sys_io  ; print coeff
0519+  124C             skip100:
0520+  124C E4            pop a
0521+  124D 22 00         mov ah, 0
0522+  124F 26 0A 00      mov b, 10
0523+  1252 AE            div a, b
0524+  1253 D8            push b      ; save remainder
0525+  1254 B9 00         cmp al, 0
0526+  1256 C6 60 12      je skip10
0527+  1259 6A 30         add al, $30
0528+  125B 23            mov ah, al
0529+  125C 19 00         mov al, 0
0530+  125E 05 03         syscall sys_io  ; print coeff
0531+  1260             skip10:
0532+  1260 E4            pop a
0533+  1261 1B            mov al, bl
0534+  1262 6A 30         add al, $30
0535+  1264 23            mov ah, al
0536+  1265 19 00         mov al, 0
0537+  1267 05 03         syscall sys_io  ; print coeff
0538+  1269 E5            pop b
0539+  126A E4            pop a
0540+  126B 09            ret
0541+  126C             
0542+  126C             ;-----------------------------------------------------------------------------
0543+  126C             ; INPUT 8BIT HEX INTEGER
0544+  126C             ; read 8bit integer into AL
0545+  126C             ;-----------------------------------------------------------------------------
0546+  126C             scan_u8x:
0547+  126C F8 04 00      enter 4
0548+  126F D8            push b
0549+  1270 DA            push d
0550+  1271             
0551+  1271 FA FD FF      lea d, [bp + -3]
0552+  1274 07 46 10      call _gets        ; get number
0553+  1277             
0554+  1277 32            mov bl, [d]
0555+  1278 37            mov bh, bl
0556+  1279 33 01 00      mov bl, [d + 1]
0557+  127C 07 FC 0F      call _atoi        ; convert to int in AL
0558+  127F             
0559+  127F E7            pop d
0560+  1280 E5            pop b
0561+  1281 F9            leave
0562+  1282 09            ret
0563+  1283             
0564+  1283             ;-----------------------------------------------------------------------------
0565+  1283             ; input decimal number
0566+  1283             ; result in A
0567+  1283             ; 655'\0'
0568+  1283             ; low--------high
0569+  1283             ;-----------------------------------------------------------------------------
0570+  1283             scan_u16d:
0571+  1283 F8 08 00      enter 8
0572+  1286 E2            push si
0573+  1287 D8            push b
0574+  1288 D9            push c
0575+  1289 DA            push d
0576+  128A FA F9 FF      lea d, [bp +- 7]
0577+  128D 07 46 10      call _gets
0578+  1290 07 9E 0F      call _strlen      ; get string length in C
0579+  1293 7E            dec c
0580+  1294 FD 4E         mov si, d
0581+  1296 12            mov a, c
0582+  1297 FD 99         shl a
0583+  1299 3B D5 12      mov d, table_power
0584+  129C 59            add d, a
0585+  129D 38 00 00      mov c, 0
0586+  12A0             mul_loop:
0587+  12A0 F6            lodsb      ; load ASCII to al
0588+  12A1 B9 00         cmp al, 0
0589+  12A3 C6 B6 12      je mul_exit
0590+  12A6 6F 30         sub al, $30    ; make into integer
0591+  12A8 22 00         mov ah, 0
0592+  12AA 2A            mov b, [d]
0593+  12AB AC            mul a, b      ; result in B since it fits in 16bits
0594+  12AC 11            mov a, b
0595+  12AD 28            mov b, c
0596+  12AE 54            add a, b
0597+  12AF 39            mov c, a
0598+  12B0 63 02 00      sub d, 2
0599+  12B3 0A A0 12      jmp mul_loop
0600+  12B6             mul_exit:
0601+  12B6 12            mov a, c
0602+  12B7 E7            pop d
0603+  12B8 E6            pop c
0604+  12B9 E5            pop b
0605+  12BA EF            pop si
0606+  12BB F9            leave
0607+  12BC 09            ret
0608+  12BD             
0609+  12BD 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0609+  12C1 34 35 36 37 
0609+  12C5 38 39 41 42 
0609+  12C9 43 44 45 46 
0610+  12CD 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0610+  12D1 1B 5B 48 00 
0611+  12D5             
0612+  12D5             table_power:
0613+  12D5 01 00         .dw 1
0614+  12D7 0A 00         .dw 10
0615+  12D9 64 00         .dw 100
0616+  12DB E8 03         .dw 1000
0617+  12DD 10 27         .dw 100002142   12DF             ; --- END INLINE ASM BLOCK
2143   12DF             
2144   12DF F9            leave
2145   12E0 09            ret
2146   12E1             
2147   12E1             exit:
2148   12E1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2149   12E4             
2150   12E4             ; --- BEGIN INLINE ASM BLOCK
2151   12E4 05 0B         syscall sys_terminate_proc
2152   12E6             ; --- END INLINE ASM BLOCK
2153   12E6             
2154   12E6 F9            leave
2155   12E7 09            ret
2156   12E8             
2157   12E8             atoi:
2158   12E8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2159   12EB             ; $result 
2160   12EB 10 00 00      mov a, $0
2161   12EE 45 FF FF      mov [bp + -1], a
2162   12F1             ; $sign 
2163   12F1 10 01 00      mov a, $1
2164   12F4 45 FD FF      mov [bp + -3], a
2165   12F7 52 04 00      sub sp, 4
2166   12FA             ;; while (*str == ' ') str++; 
2167   12FA             _while29_cond:
2168   12FA FA 05 00      lea d, [bp + 5] ; $str
2169   12FD 2A            mov b, [d]
2170   12FE 74            mov d, b
2171   12FF 32            mov bl, [d]
2172   1300 A7 00         mov bh, 0
2173   1302             ; START RELATIONAL
2174   1302 D7            push a
2175   1303 11            mov a, b
2176   1304 26 20 00      mov b, $20
2177   1307 B0            cmp a, b
2178   1308 FD 71         seq ; ==
2179   130A E4            pop a
2180   130B             ; END RELATIONAL
2181   130B C0 00 00      cmp b, 0
2182   130E C6 21 13      je _while29_exit
2183   1311             _while29_block:
2184   1311             ;; str++; 
2185   1311 FA 05 00      lea d, [bp + 5] ; $str
2186   1314 2A            mov b, [d]
2187   1315 D8            push b
2188   1316 FD 77         inc b
2189   1318 FA 05 00      lea d, [bp + 5] ; $str
2190   131B FD 43         mov [d], b
2191   131D E5            pop b
2192   131E 0A FA 12      jmp _while29_cond
2193   1321             _while29_exit:
2194   1321             ;; if (*str == '-' || *str == '+') { 
2195   1321             _if30_cond:
2196   1321 FA 05 00      lea d, [bp + 5] ; $str
2197   1324 2A            mov b, [d]
2198   1325 74            mov d, b
2199   1326 32            mov bl, [d]
2200   1327 A7 00         mov bh, 0
2201   1329             ; START RELATIONAL
2202   1329 D7            push a
2203   132A 11            mov a, b
2204   132B 26 2D 00      mov b, $2d
2205   132E B0            cmp a, b
2206   132F FD 71         seq ; ==
2207   1331 E4            pop a
2208   1332             ; END RELATIONAL
2209   1332 D7            push a
2210   1333 11            mov a, b
2211   1334 FA 05 00      lea d, [bp + 5] ; $str
2212   1337 2A            mov b, [d]
2213   1338 74            mov d, b
2214   1339 32            mov bl, [d]
2215   133A A7 00         mov bh, 0
2216   133C             ; START RELATIONAL
2217   133C D7            push a
2218   133D 11            mov a, b
2219   133E 26 2B 00      mov b, $2b
2220   1341 B0            cmp a, b
2221   1342 FD 71         seq ; ==
2222   1344 E4            pop a
2223   1345             ; END RELATIONAL
2224   1345 FD A8         sor a, b ; ||
2225   1347 E4            pop a
2226   1348 C0 00 00      cmp b, 0
2227   134B C6 82 13      je _if30_exit
2228   134E             _if30_true:
2229   134E             ;; if (*str == '-') sign = -1; 
2230   134E             _if31_cond:
2231   134E FA 05 00      lea d, [bp + 5] ; $str
2232   1351 2A            mov b, [d]
2233   1352 74            mov d, b
2234   1353 32            mov bl, [d]
2235   1354 A7 00         mov bh, 0
2236   1356             ; START RELATIONAL
2237   1356 D7            push a
2238   1357 11            mov a, b
2239   1358 26 2D 00      mov b, $2d
2240   135B B0            cmp a, b
2241   135C FD 71         seq ; ==
2242   135E E4            pop a
2243   135F             ; END RELATIONAL
2244   135F C0 00 00      cmp b, 0
2245   1362 C6 72 13      je _if31_exit
2246   1365             _if31_true:
2247   1365             ;; sign = -1; 
2248   1365 FA FD FF      lea d, [bp + -3] ; $sign
2249   1368 DA            push d
2250   1369 26 FF FF      mov b, $ffffffff
2251   136C E7            pop d
2252   136D FD 43         mov [d], b
2253   136F 0A 72 13      jmp _if31_exit
2254   1372             _if31_exit:
2255   1372             ;; str++; 
2256   1372 FA 05 00      lea d, [bp + 5] ; $str
2257   1375 2A            mov b, [d]
2258   1376 D8            push b
2259   1377 FD 77         inc b
2260   1379 FA 05 00      lea d, [bp + 5] ; $str
2261   137C FD 43         mov [d], b
2262   137E E5            pop b
2263   137F 0A 82 13      jmp _if30_exit
2264   1382             _if30_exit:
2265   1382             ;; while (*str >= '0' && *str <= '9') { 
2266   1382             _while32_cond:
2267   1382 FA 05 00      lea d, [bp + 5] ; $str
2268   1385 2A            mov b, [d]
2269   1386 74            mov d, b
2270   1387 32            mov bl, [d]
2271   1388 A7 00         mov bh, 0
2272   138A             ; START RELATIONAL
2273   138A D7            push a
2274   138B 11            mov a, b
2275   138C 26 30 00      mov b, $30
2276   138F B0            cmp a, b
2277   1390 FD 82         sgeu ; >= (unsigned)
2278   1392 E4            pop a
2279   1393             ; END RELATIONAL
2280   1393 D7            push a
2281   1394 11            mov a, b
2282   1395 FA 05 00      lea d, [bp + 5] ; $str
2283   1398 2A            mov b, [d]
2284   1399 74            mov d, b
2285   139A 32            mov bl, [d]
2286   139B A7 00         mov bh, 0
2287   139D             ; START RELATIONAL
2288   139D D7            push a
2289   139E 11            mov a, b
2290   139F 26 39 00      mov b, $39
2291   13A2 B0            cmp a, b
2292   13A3 FD 76         sleu ; <= (unsigned)
2293   13A5 E4            pop a
2294   13A6             ; END RELATIONAL
2295   13A6 FD A7         sand a, b ; &&
2296   13A8 E4            pop a
2297   13A9 C0 00 00      cmp b, 0
2298   13AC C6 E8 13      je _while32_exit
2299   13AF             _while32_block:
2300   13AF             ;; result = result * 10 + (*str - '0'); 
2301   13AF FA FF FF      lea d, [bp + -1] ; $result
2302   13B2 DA            push d
2303   13B3 FA FF FF      lea d, [bp + -1] ; $result
2304   13B6 2A            mov b, [d]
2305   13B7             ; START FACTORS
2306   13B7 D7            push a
2307   13B8 11            mov a, b
2308   13B9 26 0A 00      mov b, $a
2309   13BC AC            mul a, b ; *
2310   13BD 11            mov a, b
2311   13BE 27            mov b, a
2312   13BF E4            pop a
2313   13C0             ; END FACTORS
2314   13C0             ; START TERMS
2315   13C0 D7            push a
2316   13C1 11            mov a, b
2317   13C2 FA 05 00      lea d, [bp + 5] ; $str
2318   13C5 2A            mov b, [d]
2319   13C6 74            mov d, b
2320   13C7 32            mov bl, [d]
2321   13C8 A7 00         mov bh, 0
2322   13CA             ; START TERMS
2323   13CA D7            push a
2324   13CB 11            mov a, b
2325   13CC 26 30 00      mov b, $30
2326   13CF 60            sub a, b
2327   13D0 27            mov b, a
2328   13D1 E4            pop a
2329   13D2             ; END TERMS
2330   13D2 54            add a, b
2331   13D3 27            mov b, a
2332   13D4 E4            pop a
2333   13D5             ; END TERMS
2334   13D5 E7            pop d
2335   13D6 FD 43         mov [d], b
2336   13D8             ;; str++; 
2337   13D8 FA 05 00      lea d, [bp + 5] ; $str
2338   13DB 2A            mov b, [d]
2339   13DC D8            push b
2340   13DD FD 77         inc b
2341   13DF FA 05 00      lea d, [bp + 5] ; $str
2342   13E2 FD 43         mov [d], b
2343   13E4 E5            pop b
2344   13E5 0A 82 13      jmp _while32_cond
2345   13E8             _while32_exit:
2346   13E8             ;; return sign * result; 
2347   13E8 FA FD FF      lea d, [bp + -3] ; $sign
2348   13EB 2A            mov b, [d]
2349   13EC             ; START FACTORS
2350   13EC D7            push a
2351   13ED 11            mov a, b
2352   13EE FA FF FF      lea d, [bp + -1] ; $result
2353   13F1 2A            mov b, [d]
2354   13F2 AC            mul a, b ; *
2355   13F3 11            mov a, b
2356   13F4 27            mov b, a
2357   13F5 E4            pop a
2358   13F6             ; END FACTORS
2359   13F6 F9            leave
2360   13F7 09            ret
2361   13F8             
2362   13F8             rand:
2363   13F8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2364   13FB             ; $sec 
2365   13FB 52 02 00      sub sp, 2
2366   13FE             
2367   13FE             ; --- BEGIN INLINE ASM BLOCK
2368   13FE 19 00         mov al, 0
2369   1400 05 01         syscall sys_rtc					
2370   1402 1A            mov al, ah
2371   1403 FA FF FF      lea d, [bp + -1] ; $sec
2372   1406 1E            mov al, [d]
2373   1407 22 00         mov ah, 0
2374   1409             ; --- END INLINE ASM BLOCK
2375   1409             
2376   1409             ;; return sec; 
2377   1409 FA FF FF      lea d, [bp + -1] ; $sec
2378   140C 2A            mov b, [d]
2379   140D F9            leave
2380   140E 09            ret
2381   140F             
2382   140F             srand:
2383   140F F8 00 00      enter 0 ; (push bp; mov bp, sp)
2384   1412 F9            leave
2385   1413 09            ret
2386   1414             
2387   1414             malloc:
2388   1414 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2389   1417 F9            leave
2390   1418 09            ret
2391   1419             
2392   1419             calloc:
2393   1419 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2394   141C F9            leave
2395   141D 09            ret
2396   141E             
2397   141E             realloc:
2398   141E F8 00 00      enter 0 ; (push bp; mov bp, sp)
2399   1421 F9            leave
2400   1422 09            ret
2401   1423             
2402   1423             alloc:
2403   1423 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2404   1426             ;; heap_top = heap_top + bytes; 
2405   1426 3B 50 18      mov d, _heap_top ; $heap_top
2406   1429 DA            push d
2407   142A 3B 50 18      mov d, _heap_top ; $heap_top
2408   142D 2A            mov b, [d]
2409   142E             ; START TERMS
2410   142E D7            push a
2411   142F 11            mov a, b
2412   1430 FA 05 00      lea d, [bp + 5] ; $bytes
2413   1433 2A            mov b, [d]
2414   1434 54            add a, b
2415   1435 27            mov b, a
2416   1436 E4            pop a
2417   1437             ; END TERMS
2418   1437 E7            pop d
2419   1438 FD 43         mov [d], b
2420   143A             ;; return heap_top - bytes; 
2421   143A 3B 50 18      mov d, _heap_top ; $heap_top
2422   143D 2A            mov b, [d]
2423   143E             ; START TERMS
2424   143E D7            push a
2425   143F 11            mov a, b
2426   1440 FA 05 00      lea d, [bp + 5] ; $bytes
2427   1443 2A            mov b, [d]
2428   1444 60            sub a, b
2429   1445 27            mov b, a
2430   1446 E4            pop a
2431   1447             ; END TERMS
2432   1447 F9            leave
2433   1448 09            ret
2434   1449             
2435   1449             free:
2436   1449 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2437   144C             ;; return heap_top = heap_top - bytes; 
2438   144C 3B 50 18      mov d, _heap_top ; $heap_top
2439   144F DA            push d
2440   1450 3B 50 18      mov d, _heap_top ; $heap_top
2441   1453 2A            mov b, [d]
2442   1454             ; START TERMS
2443   1454 D7            push a
2444   1455 11            mov a, b
2445   1456 FA 05 00      lea d, [bp + 5] ; $bytes
2446   1459 2A            mov b, [d]
2447   145A 60            sub a, b
2448   145B 27            mov b, a
2449   145C E4            pop a
2450   145D             ; END TERMS
2451   145D E7            pop d
2452   145E FD 43         mov [d], b
2453   1460 F9            leave
2454   1461 09            ret
2455   1462             
2456   1462             include_ctype_lib:
2457   1462 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2458   1465             
2459   1465             ; --- BEGIN INLINE ASM BLOCK
2460   1465             .include "lib/asm/ctype.asm"
0001+  1465             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  1465             ; ctype.s
0003+  1465             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  1465             
0005+  1465             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  1465             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  1465             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  1465             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  1465             ;; characters are supported.
0010+  1465             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  1465             ;; _isalnum 
0012+  1465             ;; _isalpha 
0013+  1465             ;; islower 
0014+  1465             ;; isupper 
0015+  1465             ;; _isdigit 
0016+  1465             ;; isxdigit
0017+  1465             ;; iscntrl 
0018+  1465             ;; isgraph 
0019+  1465             ;; _isspace 
0020+  1465             ;; isblank 
0021+  1465             ;; isprint 
0022+  1465             ;; ispunct 
0023+  1465             ;; tolower 
0024+  1465             ;; toupper
0025+  1465             
0026+  1465             
0027+  1465             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  1465             ;; IS ALPHANUMERIC
0029+  1465             ;; sets ZF according with result
0030+  1465             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  1465             _isalnum:
0032+  1465 07 82 14    	call _isalpha
0033+  1468 C6 6E 14    	je _isalnum_exit
0034+  146B 07 6F 14    	call _isdigit
0035+  146E             _isalnum_exit:
0036+  146E 09          	ret	
0037+  146F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  146F             ;; IS DIGIT
0039+  146F             ;; sets ZF according with result
0040+  146F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  146F             _isdigit:
0042+  146F DB          	push al
0043+  1470 B9 30       	cmp al, '0'
0044+  1472 C8 7E 14    	jlu _isdigit_false
0045+  1475 B9 39       	cmp al, '9'
0046+  1477 D1 7E 14    	jgu _isdigit_false
0047+  147A 87 00       	and al, 0	; set ZF
0048+  147C E8          	pop al
0049+  147D 09          	ret
0050+  147E             _isdigit_false:
0051+  147E 8B 01       	or al, 1	; clear ZF
0052+  1480 E8          	pop al
0053+  1481 09          	ret	
0054+  1482             	
0055+  1482             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  1482             ;; IS ALPHA
0057+  1482             ;; sets ZF according with result
0058+  1482             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  1482             _isalpha:
0060+  1482 DB          	push al
0061+  1483 B9 5F       	cmp al, '_'
0062+  1485 C6 A5 14    	je _isalpha_true
0063+  1488 B9 2E       	cmp al, '.'
0064+  148A C6 A5 14    	je _isalpha_true
0065+  148D B9 41       	cmp al, 'A'
0066+  148F C8 A1 14    	jlu _isalpha_false
0067+  1492 B9 7A       	cmp al, 'z'
0068+  1494 D1 A1 14    	jgu _isalpha_false
0069+  1497 B9 5A       	cmp al, 'Z'
0070+  1499 D0 A5 14    	jleu _isalpha_true
0071+  149C B9 61       	cmp al, 'a'
0072+  149E C9 A5 14    	jgeu _isalpha_true
0073+  14A1             _isalpha_false:
0074+  14A1 8B 01       	or al, 1	; clear ZF
0075+  14A3 E8          	pop al
0076+  14A4 09          	ret
0077+  14A5             _isalpha_true:
0078+  14A5 87 00       	and al, 0	; set ZF
0079+  14A7 E8          	pop al
0080+  14A8 09          	ret
0081+  14A9             
0082+  14A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  14A9             ;; IS PATH-ALPHA
0084+  14A9             ;; sets ZF according with result
0085+  14A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  14A9             ispath:
0087+  14A9 DB          	push al
0088+  14AA 07 6F 14    	call _isdigit
0089+  14AD C6 D7 14    	je ispath_true
0090+  14B0 B9 5F       	cmp al, '_'
0091+  14B2 C6 D7 14    	je ispath_true
0092+  14B5 B9 2F       	cmp al, '/'
0093+  14B7 C6 D7 14    	je ispath_true
0094+  14BA B9 2E       	cmp al, '.'
0095+  14BC C6 D7 14    	je ispath_true
0096+  14BF B9 41       	cmp al, 'A'
0097+  14C1 C8 D3 14    	jlu ispath_false
0098+  14C4 B9 7A       	cmp al, 'z'
0099+  14C6 D1 D3 14    	jgu ispath_false
0100+  14C9 B9 5A       	cmp al, 'Z'
0101+  14CB D0 D7 14    	jleu ispath_true
0102+  14CE B9 61       	cmp al, 'a'
0103+  14D0 C9 D7 14    	jgeu ispath_true
0104+  14D3             ispath_false:
0105+  14D3 8B 01       	or al, 1	; clear ZF
0106+  14D5 E8          	pop al
0107+  14D6 09          	ret
0108+  14D7             ispath_true:
0109+  14D7 87 00       	and al, 0	; set ZF
0110+  14D9 E8          	pop al
0111+  14DA 09          	ret
0112+  14DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  14DB             ;; IS SPACE
0114+  14DB             ;; sets ZF according with result
0115+  14DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  14DB             _isspace:
0117+  14DB B9 20       	cmp al, $20		; ' '
0118+  14DD C6 F1 14    	je _isspace_exit
0119+  14E0 B9 09       	cmp al, $09		; '\t'
0120+  14E2 C6 F1 14    	je _isspace_exit
0121+  14E5 B9 0A       	cmp al, $0A		; '\n'
0122+  14E7 C6 F1 14    	je _isspace_exit
0123+  14EA B9 0D       	cmp al, $0D		; '\r'
0124+  14EC C6 F1 14    	je _isspace_exit
0125+  14EF B9 0B       	cmp al, $0B		; '\v'
0126+  14F1             _isspace_exit:
0127+  14F1 09          	ret	
0128+  14F2             
0129+  14F2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  14F2             ; TO LOWER
0131+  14F2             ; input in AL
0132+  14F2             ; output in AL
0133+  14F2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  14F2             _to_lower:
0135+  14F2 B9 5A       	cmp al, 'Z'
0136+  14F4 D1 F9 14    	jgu _to_lower_ret
0137+  14F7 6A 20       	add al, $20				; convert to lower case
0138+  14F9             _to_lower_ret:
0139+  14F9 09          	ret
0140+  14FA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  14FA             ; TO UPPER
0142+  14FA             ; input in AL
0143+  14FA             ; output in AL
0144+  14FA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  14FA             _to_upper:
0146+  14FA B9 61       	cmp al, 'a'
0147+  14FC C8 01 15    	jlu _to_upper_ret
0148+  14FF 6F 20       	sub al, $20			; convert to upper case
0149+  1501             _to_upper_ret:
0150+  1501 09          	ret
0151+  1502             
2461   1502             ; --- END INLINE ASM BLOCK
2462   1502             
2463   1502 F9            leave
2464   1503 09            ret
2465   1504             
2466   1504             is_space:
2467   1504 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2468   1507             ;; return c == ' ' || c == '\t' || c == '\n' || c == '\r'; 
2469   1507 FA 05 00      lea d, [bp + 5] ; $c
2470   150A 32            mov bl, [d]
2471   150B A7 00         mov bh, 0
2472   150D             ; START RELATIONAL
2473   150D D7            push a
2474   150E 11            mov a, b
2475   150F 26 20 00      mov b, $20
2476   1512 B0            cmp a, b
2477   1513 FD 71         seq ; ==
2478   1515 E4            pop a
2479   1516             ; END RELATIONAL
2480   1516 D7            push a
2481   1517 11            mov a, b
2482   1518 FA 05 00      lea d, [bp + 5] ; $c
2483   151B 32            mov bl, [d]
2484   151C A7 00         mov bh, 0
2485   151E             ; START RELATIONAL
2486   151E D7            push a
2487   151F 11            mov a, b
2488   1520 26 09 00      mov b, $9
2489   1523 B0            cmp a, b
2490   1524 FD 71         seq ; ==
2491   1526 E4            pop a
2492   1527             ; END RELATIONAL
2493   1527 FD A8         sor a, b ; ||
2494   1529 11            mov a, b
2495   152A FA 05 00      lea d, [bp + 5] ; $c
2496   152D 32            mov bl, [d]
2497   152E A7 00         mov bh, 0
2498   1530             ; START RELATIONAL
2499   1530 D7            push a
2500   1531 11            mov a, b
2501   1532 26 0A 00      mov b, $a
2502   1535 B0            cmp a, b
2503   1536 FD 71         seq ; ==
2504   1538 E4            pop a
2505   1539             ; END RELATIONAL
2506   1539 FD A8         sor a, b ; ||
2507   153B 11            mov a, b
2508   153C FA 05 00      lea d, [bp + 5] ; $c
2509   153F 32            mov bl, [d]
2510   1540 A7 00         mov bh, 0
2511   1542             ; START RELATIONAL
2512   1542 D7            push a
2513   1543 11            mov a, b
2514   1544 26 0D 00      mov b, $d
2515   1547 B0            cmp a, b
2516   1548 FD 71         seq ; ==
2517   154A E4            pop a
2518   154B             ; END RELATIONAL
2519   154B FD A8         sor a, b ; ||
2520   154D E4            pop a
2521   154E F9            leave
2522   154F 09            ret
2523   1550             
2524   1550             is_digit:
2525   1550 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2526   1553             ;; return c >= '0' && c <= '9'; 
2527   1553 FA 05 00      lea d, [bp + 5] ; $c
2528   1556 32            mov bl, [d]
2529   1557 A7 00         mov bh, 0
2530   1559             ; START RELATIONAL
2531   1559 D7            push a
2532   155A 11            mov a, b
2533   155B 26 30 00      mov b, $30
2534   155E B0            cmp a, b
2535   155F FD 80         sge ; >=
2536   1561 E4            pop a
2537   1562             ; END RELATIONAL
2538   1562 D7            push a
2539   1563 11            mov a, b
2540   1564 FA 05 00      lea d, [bp + 5] ; $c
2541   1567 32            mov bl, [d]
2542   1568 A7 00         mov bh, 0
2543   156A             ; START RELATIONAL
2544   156A D7            push a
2545   156B 11            mov a, b
2546   156C 26 39 00      mov b, $39
2547   156F B0            cmp a, b
2548   1570 FD 74         sle ; <=
2549   1572 E4            pop a
2550   1573             ; END RELATIONAL
2551   1573 FD A7         sand a, b ; &&
2552   1575 E4            pop a
2553   1576 F9            leave
2554   1577 09            ret
2555   1578             
2556   1578             is_alpha:
2557   1578 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2558   157B             ;; return(c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c == '_'); 
2559   157B FA 05 00      lea d, [bp + 5] ; $c
2560   157E 32            mov bl, [d]
2561   157F A7 00         mov bh, 0
2562   1581             ; START RELATIONAL
2563   1581 D7            push a
2564   1582 11            mov a, b
2565   1583 26 61 00      mov b, $61
2566   1586 B0            cmp a, b
2567   1587 FD 80         sge ; >=
2568   1589 E4            pop a
2569   158A             ; END RELATIONAL
2570   158A D7            push a
2571   158B 11            mov a, b
2572   158C FA 05 00      lea d, [bp + 5] ; $c
2573   158F 32            mov bl, [d]
2574   1590 A7 00         mov bh, 0
2575   1592             ; START RELATIONAL
2576   1592 D7            push a
2577   1593 11            mov a, b
2578   1594 26 7A 00      mov b, $7a
2579   1597 B0            cmp a, b
2580   1598 FD 74         sle ; <=
2581   159A E4            pop a
2582   159B             ; END RELATIONAL
2583   159B FD A7         sand a, b ; &&
2584   159D E4            pop a
2585   159E D7            push a
2586   159F 11            mov a, b
2587   15A0 FA 05 00      lea d, [bp + 5] ; $c
2588   15A3 32            mov bl, [d]
2589   15A4 A7 00         mov bh, 0
2590   15A6             ; START RELATIONAL
2591   15A6 D7            push a
2592   15A7 11            mov a, b
2593   15A8 26 41 00      mov b, $41
2594   15AB B0            cmp a, b
2595   15AC FD 80         sge ; >=
2596   15AE E4            pop a
2597   15AF             ; END RELATIONAL
2598   15AF D7            push a
2599   15B0 11            mov a, b
2600   15B1 FA 05 00      lea d, [bp + 5] ; $c
2601   15B4 32            mov bl, [d]
2602   15B5 A7 00         mov bh, 0
2603   15B7             ; START RELATIONAL
2604   15B7 D7            push a
2605   15B8 11            mov a, b
2606   15B9 26 5A 00      mov b, $5a
2607   15BC B0            cmp a, b
2608   15BD FD 74         sle ; <=
2609   15BF E4            pop a
2610   15C0             ; END RELATIONAL
2611   15C0 FD A7         sand a, b ; &&
2612   15C2 E4            pop a
2613   15C3 FD A8         sor a, b ; ||
2614   15C5 11            mov a, b
2615   15C6 FA 05 00      lea d, [bp + 5] ; $c
2616   15C9 32            mov bl, [d]
2617   15CA A7 00         mov bh, 0
2618   15CC             ; START RELATIONAL
2619   15CC D7            push a
2620   15CD 11            mov a, b
2621   15CE 26 5F 00      mov b, $5f
2622   15D1 B0            cmp a, b
2623   15D2 FD 71         seq ; ==
2624   15D4 E4            pop a
2625   15D5             ; END RELATIONAL
2626   15D5 FD A8         sor a, b ; ||
2627   15D7 E4            pop a
2628   15D8 F9            leave
2629   15D9 09            ret
2630   15DA             
2631   15DA             toupper:
2632   15DA F8 00 00      enter 0 ; (push bp; mov bp, sp)
2633   15DD             ;; if (ch >= 'a' && ch <= 'z') { 
2634   15DD             _if33_cond:
2635   15DD FA 05 00      lea d, [bp + 5] ; $ch
2636   15E0 32            mov bl, [d]
2637   15E1 A7 00         mov bh, 0
2638   15E3             ; START RELATIONAL
2639   15E3 D7            push a
2640   15E4 11            mov a, b
2641   15E5 26 61 00      mov b, $61
2642   15E8 B0            cmp a, b
2643   15E9 FD 80         sge ; >=
2644   15EB E4            pop a
2645   15EC             ; END RELATIONAL
2646   15EC D7            push a
2647   15ED 11            mov a, b
2648   15EE FA 05 00      lea d, [bp + 5] ; $ch
2649   15F1 32            mov bl, [d]
2650   15F2 A7 00         mov bh, 0
2651   15F4             ; START RELATIONAL
2652   15F4 D7            push a
2653   15F5 11            mov a, b
2654   15F6 26 7A 00      mov b, $7a
2655   15F9 B0            cmp a, b
2656   15FA FD 74         sle ; <=
2657   15FC E4            pop a
2658   15FD             ; END RELATIONAL
2659   15FD FD A7         sand a, b ; &&
2660   15FF E4            pop a
2661   1600 C0 00 00      cmp b, 0
2662   1603 C6 1E 16      je _if33_else
2663   1606             _if33_true:
2664   1606             ;; return ch - 'a' + 'A'; 
2665   1606 FA 05 00      lea d, [bp + 5] ; $ch
2666   1609 32            mov bl, [d]
2667   160A A7 00         mov bh, 0
2668   160C             ; START TERMS
2669   160C D7            push a
2670   160D 11            mov a, b
2671   160E 26 61 00      mov b, $61
2672   1611 60            sub a, b
2673   1612 11            mov a, b
2674   1613 26 41 00      mov b, $41
2675   1616 54            add a, b
2676   1617 27            mov b, a
2677   1618 E4            pop a
2678   1619             ; END TERMS
2679   1619 F9            leave
2680   161A 09            ret
2681   161B 0A 26 16      jmp _if33_exit
2682   161E             _if33_else:
2683   161E             ;; return ch; 
2684   161E FA 05 00      lea d, [bp + 5] ; $ch
2685   1621 32            mov bl, [d]
2686   1622 A7 00         mov bh, 0
2687   1624 F9            leave
2688   1625 09            ret
2689   1626             _if33_exit:
2690   1626 F9            leave
2691   1627 09            ret
2692   1628             
2693   1628             is_delimiter:
2694   1628 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2695   162B             ;; if( 
2696   162B             _if34_cond:
2697   162B FA 05 00      lea d, [bp + 5] ; $c
2698   162E 32            mov bl, [d]
2699   162F A7 00         mov bh, 0
2700   1631             ; START RELATIONAL
2701   1631 D7            push a
2702   1632 11            mov a, b
2703   1633 26 40 00      mov b, $40
2704   1636 B0            cmp a, b
2705   1637 FD 71         seq ; ==
2706   1639 E4            pop a
2707   163A             ; END RELATIONAL
2708   163A D7            push a
2709   163B 11            mov a, b
2710   163C FA 05 00      lea d, [bp + 5] ; $c
2711   163F 32            mov bl, [d]
2712   1640 A7 00         mov bh, 0
2713   1642             ; START RELATIONAL
2714   1642 D7            push a
2715   1643 11            mov a, b
2716   1644 26 23 00      mov b, $23
2717   1647 B0            cmp a, b
2718   1648 FD 71         seq ; ==
2719   164A E4            pop a
2720   164B             ; END RELATIONAL
2721   164B FD A8         sor a, b ; ||
2722   164D 11            mov a, b
2723   164E FA 05 00      lea d, [bp + 5] ; $c
2724   1651 32            mov bl, [d]
2725   1652 A7 00         mov bh, 0
2726   1654             ; START RELATIONAL
2727   1654 D7            push a
2728   1655 11            mov a, b
2729   1656 26 24 00      mov b, $24
2730   1659 B0            cmp a, b
2731   165A FD 71         seq ; ==
2732   165C E4            pop a
2733   165D             ; END RELATIONAL
2734   165D FD A8         sor a, b ; ||
2735   165F 11            mov a, b
2736   1660 FA 05 00      lea d, [bp + 5] ; $c
2737   1663 32            mov bl, [d]
2738   1664 A7 00         mov bh, 0
2739   1666             ; START RELATIONAL
2740   1666 D7            push a
2741   1667 11            mov a, b
2742   1668 26 2B 00      mov b, $2b
2743   166B B0            cmp a, b
2744   166C FD 71         seq ; ==
2745   166E E4            pop a
2746   166F             ; END RELATIONAL
2747   166F FD A8         sor a, b ; ||
2748   1671 11            mov a, b
2749   1672 FA 05 00      lea d, [bp + 5] ; $c
2750   1675 32            mov bl, [d]
2751   1676 A7 00         mov bh, 0
2752   1678             ; START RELATIONAL
2753   1678 D7            push a
2754   1679 11            mov a, b
2755   167A 26 2D 00      mov b, $2d
2756   167D B0            cmp a, b
2757   167E FD 71         seq ; ==
2758   1680 E4            pop a
2759   1681             ; END RELATIONAL
2760   1681 FD A8         sor a, b ; ||
2761   1683 11            mov a, b
2762   1684 FA 05 00      lea d, [bp + 5] ; $c
2763   1687 32            mov bl, [d]
2764   1688 A7 00         mov bh, 0
2765   168A             ; START RELATIONAL
2766   168A D7            push a
2767   168B 11            mov a, b
2768   168C 26 2A 00      mov b, $2a
2769   168F B0            cmp a, b
2770   1690 FD 71         seq ; ==
2771   1692 E4            pop a
2772   1693             ; END RELATIONAL
2773   1693 FD A8         sor a, b ; ||
2774   1695 11            mov a, b
2775   1696 FA 05 00      lea d, [bp + 5] ; $c
2776   1699 32            mov bl, [d]
2777   169A A7 00         mov bh, 0
2778   169C             ; START RELATIONAL
2779   169C D7            push a
2780   169D 11            mov a, b
2781   169E 26 2F 00      mov b, $2f
2782   16A1 B0            cmp a, b
2783   16A2 FD 71         seq ; ==
2784   16A4 E4            pop a
2785   16A5             ; END RELATIONAL
2786   16A5 FD A8         sor a, b ; ||
2787   16A7 11            mov a, b
2788   16A8 FA 05 00      lea d, [bp + 5] ; $c
2789   16AB 32            mov bl, [d]
2790   16AC A7 00         mov bh, 0
2791   16AE             ; START RELATIONAL
2792   16AE D7            push a
2793   16AF 11            mov a, b
2794   16B0 26 25 00      mov b, $25
2795   16B3 B0            cmp a, b
2796   16B4 FD 71         seq ; ==
2797   16B6 E4            pop a
2798   16B7             ; END RELATIONAL
2799   16B7 FD A8         sor a, b ; ||
2800   16B9 11            mov a, b
2801   16BA FA 05 00      lea d, [bp + 5] ; $c
2802   16BD 32            mov bl, [d]
2803   16BE A7 00         mov bh, 0
2804   16C0             ; START RELATIONAL
2805   16C0 D7            push a
2806   16C1 11            mov a, b
2807   16C2 26 5B 00      mov b, $5b
2808   16C5 B0            cmp a, b
2809   16C6 FD 71         seq ; ==
2810   16C8 E4            pop a
2811   16C9             ; END RELATIONAL
2812   16C9 FD A8         sor a, b ; ||
2813   16CB 11            mov a, b
2814   16CC FA 05 00      lea d, [bp + 5] ; $c
2815   16CF 32            mov bl, [d]
2816   16D0 A7 00         mov bh, 0
2817   16D2             ; START RELATIONAL
2818   16D2 D7            push a
2819   16D3 11            mov a, b
2820   16D4 26 5D 00      mov b, $5d
2821   16D7 B0            cmp a, b
2822   16D8 FD 71         seq ; ==
2823   16DA E4            pop a
2824   16DB             ; END RELATIONAL
2825   16DB FD A8         sor a, b ; ||
2826   16DD 11            mov a, b
2827   16DE FA 05 00      lea d, [bp + 5] ; $c
2828   16E1 32            mov bl, [d]
2829   16E2 A7 00         mov bh, 0
2830   16E4             ; START RELATIONAL
2831   16E4 D7            push a
2832   16E5 11            mov a, b
2833   16E6 26 28 00      mov b, $28
2834   16E9 B0            cmp a, b
2835   16EA FD 71         seq ; ==
2836   16EC E4            pop a
2837   16ED             ; END RELATIONAL
2838   16ED FD A8         sor a, b ; ||
2839   16EF 11            mov a, b
2840   16F0 FA 05 00      lea d, [bp + 5] ; $c
2841   16F3 32            mov bl, [d]
2842   16F4 A7 00         mov bh, 0
2843   16F6             ; START RELATIONAL
2844   16F6 D7            push a
2845   16F7 11            mov a, b
2846   16F8 26 29 00      mov b, $29
2847   16FB B0            cmp a, b
2848   16FC FD 71         seq ; ==
2849   16FE E4            pop a
2850   16FF             ; END RELATIONAL
2851   16FF FD A8         sor a, b ; ||
2852   1701 11            mov a, b
2853   1702 FA 05 00      lea d, [bp + 5] ; $c
2854   1705 32            mov bl, [d]
2855   1706 A7 00         mov bh, 0
2856   1708             ; START RELATIONAL
2857   1708 D7            push a
2858   1709 11            mov a, b
2859   170A 26 7B 00      mov b, $7b
2860   170D B0            cmp a, b
2861   170E FD 71         seq ; ==
2862   1710 E4            pop a
2863   1711             ; END RELATIONAL
2864   1711 FD A8         sor a, b ; ||
2865   1713 11            mov a, b
2866   1714 FA 05 00      lea d, [bp + 5] ; $c
2867   1717 32            mov bl, [d]
2868   1718 A7 00         mov bh, 0
2869   171A             ; START RELATIONAL
2870   171A D7            push a
2871   171B 11            mov a, b
2872   171C 26 7D 00      mov b, $7d
2873   171F B0            cmp a, b
2874   1720 FD 71         seq ; ==
2875   1722 E4            pop a
2876   1723             ; END RELATIONAL
2877   1723 FD A8         sor a, b ; ||
2878   1725 11            mov a, b
2879   1726 FA 05 00      lea d, [bp + 5] ; $c
2880   1729 32            mov bl, [d]
2881   172A A7 00         mov bh, 0
2882   172C             ; START RELATIONAL
2883   172C D7            push a
2884   172D 11            mov a, b
2885   172E 26 3A 00      mov b, $3a
2886   1731 B0            cmp a, b
2887   1732 FD 71         seq ; ==
2888   1734 E4            pop a
2889   1735             ; END RELATIONAL
2890   1735 FD A8         sor a, b ; ||
2891   1737 11            mov a, b
2892   1738 FA 05 00      lea d, [bp + 5] ; $c
2893   173B 32            mov bl, [d]
2894   173C A7 00         mov bh, 0
2895   173E             ; START RELATIONAL
2896   173E D7            push a
2897   173F 11            mov a, b
2898   1740 26 3B 00      mov b, $3b
2899   1743 B0            cmp a, b
2900   1744 FD 71         seq ; ==
2901   1746 E4            pop a
2902   1747             ; END RELATIONAL
2903   1747 FD A8         sor a, b ; ||
2904   1749 11            mov a, b
2905   174A FA 05 00      lea d, [bp + 5] ; $c
2906   174D 32            mov bl, [d]
2907   174E A7 00         mov bh, 0
2908   1750             ; START RELATIONAL
2909   1750 D7            push a
2910   1751 11            mov a, b
2911   1752 26 3C 00      mov b, $3c
2912   1755 B0            cmp a, b
2913   1756 FD 71         seq ; ==
2914   1758 E4            pop a
2915   1759             ; END RELATIONAL
2916   1759 FD A8         sor a, b ; ||
2917   175B 11            mov a, b
2918   175C FA 05 00      lea d, [bp + 5] ; $c
2919   175F 32            mov bl, [d]
2920   1760 A7 00         mov bh, 0
2921   1762             ; START RELATIONAL
2922   1762 D7            push a
2923   1763 11            mov a, b
2924   1764 26 3E 00      mov b, $3e
2925   1767 B0            cmp a, b
2926   1768 FD 71         seq ; ==
2927   176A E4            pop a
2928   176B             ; END RELATIONAL
2929   176B FD A8         sor a, b ; ||
2930   176D 11            mov a, b
2931   176E FA 05 00      lea d, [bp + 5] ; $c
2932   1771 32            mov bl, [d]
2933   1772 A7 00         mov bh, 0
2934   1774             ; START RELATIONAL
2935   1774 D7            push a
2936   1775 11            mov a, b
2937   1776 26 3D 00      mov b, $3d
2938   1779 B0            cmp a, b
2939   177A FD 71         seq ; ==
2940   177C E4            pop a
2941   177D             ; END RELATIONAL
2942   177D FD A8         sor a, b ; ||
2943   177F 11            mov a, b
2944   1780 FA 05 00      lea d, [bp + 5] ; $c
2945   1783 32            mov bl, [d]
2946   1784 A7 00         mov bh, 0
2947   1786             ; START RELATIONAL
2948   1786 D7            push a
2949   1787 11            mov a, b
2950   1788 26 21 00      mov b, $21
2951   178B B0            cmp a, b
2952   178C FD 71         seq ; ==
2953   178E E4            pop a
2954   178F             ; END RELATIONAL
2955   178F FD A8         sor a, b ; ||
2956   1791 11            mov a, b
2957   1792 FA 05 00      lea d, [bp + 5] ; $c
2958   1795 32            mov bl, [d]
2959   1796 A7 00         mov bh, 0
2960   1798             ; START RELATIONAL
2961   1798 D7            push a
2962   1799 11            mov a, b
2963   179A 26 5E 00      mov b, $5e
2964   179D B0            cmp a, b
2965   179E FD 71         seq ; ==
2966   17A0 E4            pop a
2967   17A1             ; END RELATIONAL
2968   17A1 FD A8         sor a, b ; ||
2969   17A3 11            mov a, b
2970   17A4 FA 05 00      lea d, [bp + 5] ; $c
2971   17A7 32            mov bl, [d]
2972   17A8 A7 00         mov bh, 0
2973   17AA             ; START RELATIONAL
2974   17AA D7            push a
2975   17AB 11            mov a, b
2976   17AC 26 26 00      mov b, $26
2977   17AF B0            cmp a, b
2978   17B0 FD 71         seq ; ==
2979   17B2 E4            pop a
2980   17B3             ; END RELATIONAL
2981   17B3 FD A8         sor a, b ; ||
2982   17B5 11            mov a, b
2983   17B6 FA 05 00      lea d, [bp + 5] ; $c
2984   17B9 32            mov bl, [d]
2985   17BA A7 00         mov bh, 0
2986   17BC             ; START RELATIONAL
2987   17BC D7            push a
2988   17BD 11            mov a, b
2989   17BE 26 7C 00      mov b, $7c
2990   17C1 B0            cmp a, b
2991   17C2 FD 71         seq ; ==
2992   17C4 E4            pop a
2993   17C5             ; END RELATIONAL
2994   17C5 FD A8         sor a, b ; ||
2995   17C7 11            mov a, b
2996   17C8 FA 05 00      lea d, [bp + 5] ; $c
2997   17CB 32            mov bl, [d]
2998   17CC A7 00         mov bh, 0
2999   17CE             ; START RELATIONAL
3000   17CE D7            push a
3001   17CF 11            mov a, b
3002   17D0 26 7E 00      mov b, $7e
3003   17D3 B0            cmp a, b
3004   17D4 FD 71         seq ; ==
3005   17D6 E4            pop a
3006   17D7             ; END RELATIONAL
3007   17D7 FD A8         sor a, b ; ||
3008   17D9 11            mov a, b
3009   17DA FA 05 00      lea d, [bp + 5] ; $c
3010   17DD 32            mov bl, [d]
3011   17DE A7 00         mov bh, 0
3012   17E0             ; START RELATIONAL
3013   17E0 D7            push a
3014   17E1 11            mov a, b
3015   17E2 26 2E 00      mov b, $2e
3016   17E5 B0            cmp a, b
3017   17E6 FD 71         seq ; ==
3018   17E8 E4            pop a
3019   17E9             ; END RELATIONAL
3020   17E9 FD A8         sor a, b ; ||
3021   17EB E4            pop a
3022   17EC C0 00 00      cmp b, 0
3023   17EF C6 FA 17      je _if34_else
3024   17F2             _if34_true:
3025   17F2             ;; return 1; 
3026   17F2 26 01 00      mov b, $1
3027   17F5 F9            leave
3028   17F6 09            ret
3029   17F7 0A FF 17      jmp _if34_exit
3030   17FA             _if34_else:
3031   17FA             ;; return 0; 
3032   17FA 26 00 00      mov b, $0
3033   17FD F9            leave
3034   17FE 09            ret
3035   17FF             _if34_exit:
3036   17FF F9            leave
3037   1800 09            ret
3038   1801             ; --- END TEXT BLOCK
3039   1801             
3040   1801             ; --- BEGIN DATA BLOCK
3041   1801 00 00       _a: .fill 2, 0
3042   1803 00 00       _g: .fill 2, 0
3043   1805 00 00       _e: .fill 2, 0
3044   1807 00          _b: .fill 1, 0
3045   1808 00          _starbases: .fill 1, 0
3046   1809 00          _base_y: .fill 1, 0
3047   180A 00          _base_x: .fill 1, 0
3048   180B 00          _starbases_left: .fill 1, 0
3049   180C 55 6E 65 78 __s0: .db "Unexpected format in printf.", 0
3049   1810 70 65 63 74 
3049   1814 65 64 20 66 
3049   1818 6F 72 6D 61 
3049   181C 74 20 69 6E 
3049   1820 20 70 72 69 
3049   1824 6E 74 66 2E 
3049   1828 00 
3050   1829 45 72 72 6F __s1: .db "Error: Unknown argument type.\n", 0
3050   182D 72 3A 20 55 
3050   1831 6E 6B 6E 6F 
3050   1835 77 6E 20 61 
3050   1839 72 67 75 6D 
3050   183D 65 6E 74 20 
3050   1841 74 79 70 65 
3050   1845 2E 0A 00 
3051   1848 1B 5B 32 4A __s2: .db "\033[2J\033[H", 0
3051   184C 1B 5B 48 00 
3052   1850             
3053   1850 52 18       _heap_top: .dw _heap
3054   1852 00          _heap: .db 0
3055   1853             ; --- END DATA BLOCK
3056   1853             
3057   1853             .end
tasm: Number of errors = 0
