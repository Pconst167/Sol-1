0001   0000             ; --- FILENAME: test
0002   0000             .include "lib/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; $a 
0011   0408             ; $b 
0012   0408             ; $c 
0013   0408             ; $d 
0014   0408 52 08 00      sub sp, 8
0015   040B             ;; a = 5; b = 6; c = 7; d = 8; 
0016   040B FA FF FF      lea d, [bp + -1] ; $a
0017   040E DA            push d
0018   040F 26 05 00      mov b, $5
0019   0412 E7            pop d
0020   0413 FD 43         mov [d], b
0021   0415             ;; b = 6; c = 7; d = 8; 
0022   0415 FA FD FF      lea d, [bp + -3] ; $b
0023   0418 DA            push d
0024   0419 26 06 00      mov b, $6
0025   041C E7            pop d
0026   041D FD 43         mov [d], b
0027   041F             ;; c = 7; d = 8; 
0028   041F FA FB FF      lea d, [bp + -5] ; $c
0029   0422 DA            push d
0030   0423 26 07 00      mov b, $7
0031   0426 E7            pop d
0032   0427 FD 43         mov [d], b
0033   0429             ;; d = 8; 
0034   0429 FA F9 FF      lea d, [bp + -7] ; $d
0035   042C DA            push d
0036   042D 26 08 00      mov b, $8
0037   0430 E7            pop d
0038   0431 FD 43         mov [d], b
0039   0433             ;; printf("a: %d, b: %d, c: %d, d: %d\n",a,b,c,d); 
0040   0433 FA F9 FF      lea d, [bp + -7] ; $d
0041   0436 2A            mov b, [d]
0042   0437 FD AB         swp b
0043   0439 D8            push b
0044   043A FA FB FF      lea d, [bp + -5] ; $c
0045   043D 2A            mov b, [d]
0046   043E FD AB         swp b
0047   0440 D8            push b
0048   0441 FA FD FF      lea d, [bp + -3] ; $b
0049   0444 2A            mov b, [d]
0050   0445 FD AB         swp b
0051   0447 D8            push b
0052   0448 FA FF FF      lea d, [bp + -1] ; $a
0053   044B 2A            mov b, [d]
0054   044C FD AB         swp b
0055   044E D8            push b
0056   044F 26 DD 11      mov b, __s0 ; "a: %d, b: %d, c: %d, d: %d\n"
0057   0452 FD AB         swp b
0058   0454 D8            push b
0059   0455 07 6C 06      call printf
0060   0458 51 0A 00      add sp, 10
0061   045B             ;; f(1,2,3,4); 
0062   045B 26 04 00      mov b, $4
0063   045E FD AB         swp b
0064   0460 D8            push b
0065   0461 26 03 00      mov b, $3
0066   0464 FD AB         swp b
0067   0466 D8            push b
0068   0467 26 02 00      mov b, $2
0069   046A FD AB         swp b
0070   046C D8            push b
0071   046D 26 01 00      mov b, $1
0072   0470 FD AB         swp b
0073   0472 D8            push b
0074   0473 07 85 11      call f
0075   0476 51 08 00      add sp, 8
0076   0479             ;; printf("a: %d, b: %d, c: %d, d: %d\n",a,b,c,d); 
0077   0479 FA F9 FF      lea d, [bp + -7] ; $d
0078   047C 2A            mov b, [d]
0079   047D FD AB         swp b
0080   047F D8            push b
0081   0480 FA FB FF      lea d, [bp + -5] ; $c
0082   0483 2A            mov b, [d]
0083   0484 FD AB         swp b
0084   0486 D8            push b
0085   0487 FA FD FF      lea d, [bp + -3] ; $b
0086   048A 2A            mov b, [d]
0087   048B FD AB         swp b
0088   048D D8            push b
0089   048E FA FF FF      lea d, [bp + -1] ; $a
0090   0491 2A            mov b, [d]
0091   0492 FD AB         swp b
0092   0494 D8            push b
0093   0495 26 DD 11      mov b, __s0 ; "a: %d, b: %d, c: %d, d: %d\n"
0094   0498 FD AB         swp b
0095   049A D8            push b
0096   049B 07 6C 06      call printf
0097   049E 51 0A 00      add sp, 10
0098   04A1             ;; return 0; 
0099   04A1 26 00 00      mov b, $0
0100   04A4 F9            leave
0101   04A5 05 0B         syscall sys_terminate_proc
0102   04A7             
0103   04A7             strcpy:
0104   04A7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0105   04AA             ; $psrc 
0106   04AA             ; $pdest 
0107   04AA 52 04 00      sub sp, 4
0108   04AD             ;; psrc = src; 
0109   04AD FA FF FF      lea d, [bp + -1] ; $psrc
0110   04B0 DA            push d
0111   04B1 FA 07 00      lea d, [bp + 7] ; $src
0112   04B4 2A            mov b, [d]
0113   04B5 E7            pop d
0114   04B6 FD 43         mov [d], b
0115   04B8             ;; pdest = dest; 
0116   04B8 FA FD FF      lea d, [bp + -3] ; $pdest
0117   04BB DA            push d
0118   04BC FA 05 00      lea d, [bp + 5] ; $dest
0119   04BF 2A            mov b, [d]
0120   04C0 E7            pop d
0121   04C1 FD 43         mov [d], b
0122   04C3             ;; while(*psrc) *pdest++ = *psrc++; 
0123   04C3             _while1_cond:
0124   04C3 FA FF FF      lea d, [bp + -1] ; $psrc
0125   04C6 2A            mov b, [d]
0126   04C7 74            mov d, b
0127   04C8 32            mov bl, [d]
0128   04C9 A7 00         mov bh, 0
0129   04CB C0 00 00      cmp b, 0
0130   04CE C6 FA 04      je _while1_exit
0131   04D1             _while1_block:
0132   04D1             ;; *pdest++ = *psrc++; 
0133   04D1 FA FD FF      lea d, [bp + -3] ; $pdest
0134   04D4 2A            mov b, [d]
0135   04D5 FD 79         mov g, b
0136   04D7 FD 77         inc b
0137   04D9 FA FD FF      lea d, [bp + -3] ; $pdest
0138   04DC FD 43         mov [d], b
0139   04DE FD 27         mov b, g
0140   04E0 D8            push b
0141   04E1 FA FF FF      lea d, [bp + -1] ; $psrc
0142   04E4 2A            mov b, [d]
0143   04E5 FD 79         mov g, b
0144   04E7 FD 77         inc b
0145   04E9 FA FF FF      lea d, [bp + -1] ; $psrc
0146   04EC FD 43         mov [d], b
0147   04EE FD 27         mov b, g
0148   04F0 74            mov d, b
0149   04F1 32            mov bl, [d]
0150   04F2 A7 00         mov bh, 0
0151   04F4 E7            pop d
0152   04F5 FD 3E         mov [d], bl
0153   04F7 0A C3 04      jmp _while1_cond
0154   04FA             _while1_exit:
0155   04FA             ;; *pdest = '\0'; 
0156   04FA FA FD FF      lea d, [bp + -3] ; $pdest
0157   04FD 2A            mov b, [d]
0158   04FE D8            push b
0159   04FF 26 00 00      mov b, $0
0160   0502 E7            pop d
0161   0503 FD 3E         mov [d], bl
0162   0505 F9            leave
0163   0506 09            ret
0164   0507             
0165   0507             strcmp:
0166   0507 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0167   050A             ;; while (*s1 && (*s1 == *s2)) { 
0168   050A             _while2_cond:
0169   050A FA 05 00      lea d, [bp + 5] ; $s1
0170   050D 2A            mov b, [d]
0171   050E 74            mov d, b
0172   050F 32            mov bl, [d]
0173   0510 A7 00         mov bh, 0
0174   0512 D7            push a
0175   0513 11            mov a, b
0176   0514 FA 05 00      lea d, [bp + 5] ; $s1
0177   0517 2A            mov b, [d]
0178   0518 74            mov d, b
0179   0519 32            mov bl, [d]
0180   051A A7 00         mov bh, 0
0181   051C             ; START RELATIONAL
0182   051C D7            push a
0183   051D 11            mov a, b
0184   051E FA 07 00      lea d, [bp + 7] ; $s2
0185   0521 2A            mov b, [d]
0186   0522 74            mov d, b
0187   0523 32            mov bl, [d]
0188   0524 A7 00         mov bh, 0
0189   0526 B0            cmp a, b
0190   0527 FD 71         seq ; ==
0191   0529 E4            pop a
0192   052A             ; END RELATIONAL
0193   052A FD A7         sand a, b ; &&
0194   052C E4            pop a
0195   052D C0 00 00      cmp b, 0
0196   0530 C6 54 05      je _while2_exit
0197   0533             _while2_block:
0198   0533             ;; s1++; 
0199   0533 FA 05 00      lea d, [bp + 5] ; $s1
0200   0536 2A            mov b, [d]
0201   0537 FD 79         mov g, b
0202   0539 FD 77         inc b
0203   053B FA 05 00      lea d, [bp + 5] ; $s1
0204   053E FD 43         mov [d], b
0205   0540 FD 27         mov b, g
0206   0542             ;; s2++; 
0207   0542 FA 07 00      lea d, [bp + 7] ; $s2
0208   0545 2A            mov b, [d]
0209   0546 FD 79         mov g, b
0210   0548 FD 77         inc b
0211   054A FA 07 00      lea d, [bp + 7] ; $s2
0212   054D FD 43         mov [d], b
0213   054F FD 27         mov b, g
0214   0551 0A 0A 05      jmp _while2_cond
0215   0554             _while2_exit:
0216   0554             ;; return *s1 - *s2; 
0217   0554 FA 05 00      lea d, [bp + 5] ; $s1
0218   0557 2A            mov b, [d]
0219   0558 74            mov d, b
0220   0559 32            mov bl, [d]
0221   055A A7 00         mov bh, 0
0222   055C             ; START TERMS
0223   055C D7            push a
0224   055D 11            mov a, b
0225   055E FA 07 00      lea d, [bp + 7] ; $s2
0226   0561 2A            mov b, [d]
0227   0562 74            mov d, b
0228   0563 32            mov bl, [d]
0229   0564 A7 00         mov bh, 0
0230   0566 60            sub a, b
0231   0567 27            mov b, a
0232   0568 E4            pop a
0233   0569             ; END TERMS
0234   0569 F9            leave
0235   056A 09            ret
0236   056B             
0237   056B             strcat:
0238   056B F8 00 00      enter 0 ; (push bp; mov bp, sp)
0239   056E             ; $dest_len 
0240   056E             ; $i 
0241   056E 52 04 00      sub sp, 4
0242   0571             ;; dest_len = strlen(dest); 
0243   0571 FA FF FF      lea d, [bp + -1] ; $dest_len
0244   0574 DA            push d
0245   0575 FA 05 00      lea d, [bp + 5] ; $dest
0246   0578 2A            mov b, [d]
0247   0579 FD AB         swp b
0248   057B D8            push b
0249   057C 07 21 06      call strlen
0250   057F 51 02 00      add sp, 2
0251   0582 E7            pop d
0252   0583 FD 43         mov [d], b
0253   0585             ;; for (i = 0; src[i] != 0; i=i+1) { 
0254   0585             _for3_init:
0255   0585 FA FD FF      lea d, [bp + -3] ; $i
0256   0588 DA            push d
0257   0589 26 00 00      mov b, $0
0258   058C E7            pop d
0259   058D FD 43         mov [d], b
0260   058F             _for3_cond:
0261   058F FA 07 00      lea d, [bp + 7] ; $src
0262   0592 FD 2A         mov d, [d]
0263   0594 D7            push a
0264   0595 DA            push d
0265   0596 FA FD FF      lea d, [bp + -3] ; $i
0266   0599 2A            mov b, [d]
0267   059A E7            pop d
0268   059B FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0269   059F E4            pop a
0270   05A0 32            mov bl, [d]
0271   05A1 A7 00         mov bh, 0
0272   05A3             ; START RELATIONAL
0273   05A3 D7            push a
0274   05A4 11            mov a, b
0275   05A5 26 00 00      mov b, $0
0276   05A8 B0            cmp a, b
0277   05A9 FD 72         sneq ; !=
0278   05AB E4            pop a
0279   05AC             ; END RELATIONAL
0280   05AC C0 00 00      cmp b, 0
0281   05AF C6 FA 05      je _for3_exit
0282   05B2             _for3_block:
0283   05B2             ;; dest[dest_len + i] = src[i]; 
0284   05B2 FA 05 00      lea d, [bp + 5] ; $dest
0285   05B5 FD 2A         mov d, [d]
0286   05B7 D7            push a
0287   05B8 DA            push d
0288   05B9 FA FF FF      lea d, [bp + -1] ; $dest_len
0289   05BC 2A            mov b, [d]
0290   05BD             ; START TERMS
0291   05BD D7            push a
0292   05BE 11            mov a, b
0293   05BF FA FD FF      lea d, [bp + -3] ; $i
0294   05C2 2A            mov b, [d]
0295   05C3 54            add a, b
0296   05C4 27            mov b, a
0297   05C5 E4            pop a
0298   05C6             ; END TERMS
0299   05C6 E7            pop d
0300   05C7 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0301   05CB E4            pop a
0302   05CC DA            push d
0303   05CD FA 07 00      lea d, [bp + 7] ; $src
0304   05D0 FD 2A         mov d, [d]
0305   05D2 D7            push a
0306   05D3 DA            push d
0307   05D4 FA FD FF      lea d, [bp + -3] ; $i
0308   05D7 2A            mov b, [d]
0309   05D8 E7            pop d
0310   05D9 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0311   05DD E4            pop a
0312   05DE 32            mov bl, [d]
0313   05DF A7 00         mov bh, 0
0314   05E1 E7            pop d
0315   05E2 FD 3E         mov [d], bl
0316   05E4             _for3_update:
0317   05E4 FA FD FF      lea d, [bp + -3] ; $i
0318   05E7 DA            push d
0319   05E8 FA FD FF      lea d, [bp + -3] ; $i
0320   05EB 2A            mov b, [d]
0321   05EC             ; START TERMS
0322   05EC D7            push a
0323   05ED 11            mov a, b
0324   05EE 26 01 00      mov b, $1
0325   05F1 54            add a, b
0326   05F2 27            mov b, a
0327   05F3 E4            pop a
0328   05F4             ; END TERMS
0329   05F4 E7            pop d
0330   05F5 FD 43         mov [d], b
0331   05F7 0A 8F 05      jmp _for3_cond
0332   05FA             _for3_exit:
0333   05FA             ;; dest[dest_len + i] = 0; 
0334   05FA FA 05 00      lea d, [bp + 5] ; $dest
0335   05FD FD 2A         mov d, [d]
0336   05FF D7            push a
0337   0600 DA            push d
0338   0601 FA FF FF      lea d, [bp + -1] ; $dest_len
0339   0604 2A            mov b, [d]
0340   0605             ; START TERMS
0341   0605 D7            push a
0342   0606 11            mov a, b
0343   0607 FA FD FF      lea d, [bp + -3] ; $i
0344   060A 2A            mov b, [d]
0345   060B 54            add a, b
0346   060C 27            mov b, a
0347   060D E4            pop a
0348   060E             ; END TERMS
0349   060E E7            pop d
0350   060F FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0351   0613 E4            pop a
0352   0614 DA            push d
0353   0615 26 00 00      mov b, $0
0354   0618 E7            pop d
0355   0619 FD 3E         mov [d], bl
0356   061B             ;; return dest; 
0357   061B FA 05 00      lea d, [bp + 5] ; $dest
0358   061E 2A            mov b, [d]
0359   061F F9            leave
0360   0620 09            ret
0361   0621             
0362   0621             strlen:
0363   0621 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0364   0624             ; $length 
0365   0624 52 02 00      sub sp, 2
0366   0627             ;; length = 0; 
0367   0627 FA FF FF      lea d, [bp + -1] ; $length
0368   062A DA            push d
0369   062B 26 00 00      mov b, $0
0370   062E E7            pop d
0371   062F FD 43         mov [d], b
0372   0631             ;; while (str[length] != 0) { 
0373   0631             _while4_cond:
0374   0631 FA 05 00      lea d, [bp + 5] ; $str
0375   0634 FD 2A         mov d, [d]
0376   0636 D7            push a
0377   0637 DA            push d
0378   0638 FA FF FF      lea d, [bp + -1] ; $length
0379   063B 2A            mov b, [d]
0380   063C E7            pop d
0381   063D FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0382   0641 E4            pop a
0383   0642 32            mov bl, [d]
0384   0643 A7 00         mov bh, 0
0385   0645             ; START RELATIONAL
0386   0645 D7            push a
0387   0646 11            mov a, b
0388   0647 26 00 00      mov b, $0
0389   064A B0            cmp a, b
0390   064B FD 72         sneq ; !=
0391   064D E4            pop a
0392   064E             ; END RELATIONAL
0393   064E C0 00 00      cmp b, 0
0394   0651 C6 66 06      je _while4_exit
0395   0654             _while4_block:
0396   0654             ;; length++; 
0397   0654 FA FF FF      lea d, [bp + -1] ; $length
0398   0657 2A            mov b, [d]
0399   0658 FD 79         mov g, b
0400   065A FD 77         inc b
0401   065C FA FF FF      lea d, [bp + -1] ; $length
0402   065F FD 43         mov [d], b
0403   0661 FD 27         mov b, g
0404   0663 0A 31 06      jmp _while4_cond
0405   0666             _while4_exit:
0406   0666             ;; return length; 
0407   0666 FA FF FF      lea d, [bp + -1] ; $length
0408   0669 2A            mov b, [d]
0409   066A F9            leave
0410   066B 09            ret
0411   066C             
0412   066C             printf:
0413   066C F8 00 00      enter 0 ; (push bp; mov bp, sp)
0414   066F             ; $p 
0415   066F             ; $fp 
0416   066F             ; $i 
0417   066F 52 06 00      sub sp, 6
0418   0672             ;; fp = format; 
0419   0672 FA FD FF      lea d, [bp + -3] ; $fp
0420   0675 DA            push d
0421   0676 FA 05 00      lea d, [bp + 5] ; $format
0422   0679 2A            mov b, [d]
0423   067A E7            pop d
0424   067B FD 43         mov [d], b
0425   067D             ;; p = &format + 2; 
0426   067D FA FF FF      lea d, [bp + -1] ; $p
0427   0680 DA            push d
0428   0681 FA 05 00      lea d, [bp + 5] ; $format
0429   0684 2D            mov b, d
0430   0685             ; START TERMS
0431   0685 D7            push a
0432   0686 11            mov a, b
0433   0687 26 02 00      mov b, $2
0434   068A 54            add a, b
0435   068B 27            mov b, a
0436   068C E4            pop a
0437   068D             ; END TERMS
0438   068D E7            pop d
0439   068E FD 43         mov [d], b
0440   0690             ;; for(;;){ 
0441   0690             _for5_init:
0442   0690             _for5_cond:
0443   0690             _for5_block:
0444   0690             ;; if(!*fp) break; 
0445   0690             _if6_cond:
0446   0690 FA FD FF      lea d, [bp + -3] ; $fp
0447   0693 2A            mov b, [d]
0448   0694 74            mov d, b
0449   0695 32            mov bl, [d]
0450   0696 A7 00         mov bh, 0
0451   0698 C0 00 00      cmp b, 0
0452   069B FD 71         seq ; !
0453   069D C0 00 00      cmp b, 0
0454   06A0 C6 A9 06      je _if6_else
0455   06A3             _if6_true:
0456   06A3             ;; break; 
0457   06A3 0A F3 07      jmp _for5_exit ; for break
0458   06A6 0A F0 07      jmp _if6_exit
0459   06A9             _if6_else:
0460   06A9             ;; if(*fp == '%'){ 
0461   06A9             _if7_cond:
0462   06A9 FA FD FF      lea d, [bp + -3] ; $fp
0463   06AC 2A            mov b, [d]
0464   06AD 74            mov d, b
0465   06AE 32            mov bl, [d]
0466   06AF A7 00         mov bh, 0
0467   06B1             ; START RELATIONAL
0468   06B1 D7            push a
0469   06B2 11            mov a, b
0470   06B3 26 25 00      mov b, $25
0471   06B6 B0            cmp a, b
0472   06B7 FD 71         seq ; ==
0473   06B9 E4            pop a
0474   06BA             ; END RELATIONAL
0475   06BA C0 00 00      cmp b, 0
0476   06BD C6 D2 07      je _if7_else
0477   06C0             _if7_true:
0478   06C0             ;; fp++; 
0479   06C0 FA FD FF      lea d, [bp + -3] ; $fp
0480   06C3 2A            mov b, [d]
0481   06C4 FD 79         mov g, b
0482   06C6 FD 77         inc b
0483   06C8 FA FD FF      lea d, [bp + -3] ; $fp
0484   06CB FD 43         mov [d], b
0485   06CD FD 27         mov b, g
0486   06CF             ;; switch(*fp){ 
0487   06CF             _switch8_expr:
0488   06CF FA FD FF      lea d, [bp + -3] ; $fp
0489   06D2 2A            mov b, [d]
0490   06D3 74            mov d, b
0491   06D4 32            mov bl, [d]
0492   06D5 A7 00         mov bh, 0
0493   06D7             _switch8_comparisons:
0494   06D7 C1 64         cmp bl, $64
0495   06D9 C6 FB 06      je _switch8_case0
0496   06DC C1 69         cmp bl, $69
0497   06DE C6 FB 06      je _switch8_case1
0498   06E1 C1 75         cmp bl, $75
0499   06E3 C6 20 07      je _switch8_case2
0500   06E6 C1 78         cmp bl, $78
0501   06E8 C6 45 07      je _switch8_case3
0502   06EB C1 63         cmp bl, $63
0503   06ED C6 6A 07      je _switch8_case4
0504   06F0 C1 73         cmp bl, $73
0505   06F2 C6 8F 07      je _switch8_case5
0506   06F5 0A B4 07      jmp _switch8_default
0507   06F8 0A C0 07      jmp _switch8_exit
0508   06FB             _switch8_case0:
0509   06FB             _switch8_case1:
0510   06FB             ;; prints(*(int*)p); 
0511   06FB FA FF FF      lea d, [bp + -1] ; $p
0512   06FE 2A            mov b, [d]
0513   06FF 74            mov d, b
0514   0700 2A            mov b, [d]
0515   0701 FD AB         swp b
0516   0703 D8            push b
0517   0704 07 85 0A      call prints
0518   0707 51 02 00      add sp, 2
0519   070A             ;; p = p + 2; 
0520   070A FA FF FF      lea d, [bp + -1] ; $p
0521   070D DA            push d
0522   070E FA FF FF      lea d, [bp + -1] ; $p
0523   0711 2A            mov b, [d]
0524   0712             ; START TERMS
0525   0712 D7            push a
0526   0713 11            mov a, b
0527   0714 26 02 00      mov b, $2
0528   0717 54            add a, b
0529   0718 27            mov b, a
0530   0719 E4            pop a
0531   071A             ; END TERMS
0532   071A E7            pop d
0533   071B FD 43         mov [d], b
0534   071D             ;; break; 
0535   071D 0A C0 07      jmp _switch8_exit ; case break
0536   0720             _switch8_case2:
0537   0720             ;; printu(*(unsigned int*)p); 
0538   0720 FA FF FF      lea d, [bp + -1] ; $p
0539   0723 2A            mov b, [d]
0540   0724 74            mov d, b
0541   0725 2A            mov b, [d]
0542   0726 FD AB         swp b
0543   0728 D8            push b
0544   0729 07 7A 0B      call printu
0545   072C 51 02 00      add sp, 2
0546   072F             ;; p = p + 2; 
0547   072F FA FF FF      lea d, [bp + -1] ; $p
0548   0732 DA            push d
0549   0733 FA FF FF      lea d, [bp + -1] ; $p
0550   0736 2A            mov b, [d]
0551   0737             ; START TERMS
0552   0737 D7            push a
0553   0738 11            mov a, b
0554   0739 26 02 00      mov b, $2
0555   073C 54            add a, b
0556   073D 27            mov b, a
0557   073E E4            pop a
0558   073F             ; END TERMS
0559   073F E7            pop d
0560   0740 FD 43         mov [d], b
0561   0742             ;; break; 
0562   0742 0A C0 07      jmp _switch8_exit ; case break
0563   0745             _switch8_case3:
0564   0745             ;; printx16(*(unsigned int*)p); 
0565   0745 FA FF FF      lea d, [bp + -1] ; $p
0566   0748 2A            mov b, [d]
0567   0749 74            mov d, b
0568   074A 2A            mov b, [d]
0569   074B FD AB         swp b
0570   074D D8            push b
0571   074E 07 F5 07      call printx16
0572   0751 51 02 00      add sp, 2
0573   0754             ;; p = p + 2; 
0574   0754 FA FF FF      lea d, [bp + -1] ; $p
0575   0757 DA            push d
0576   0758 FA FF FF      lea d, [bp + -1] ; $p
0577   075B 2A            mov b, [d]
0578   075C             ; START TERMS
0579   075C D7            push a
0580   075D 11            mov a, b
0581   075E 26 02 00      mov b, $2
0582   0761 54            add a, b
0583   0762 27            mov b, a
0584   0763 E4            pop a
0585   0764             ; END TERMS
0586   0764 E7            pop d
0587   0765 FD 43         mov [d], b
0588   0767             ;; break; 
0589   0767 0A C0 07      jmp _switch8_exit ; case break
0590   076A             _switch8_case4:
0591   076A             ;; putchar(*(char*)p); 
0592   076A FA FF FF      lea d, [bp + -1] ; $p
0593   076D 2A            mov b, [d]
0594   076E 74            mov d, b
0595   076F 32            mov bl, [d]
0596   0770 A7 00         mov bh, 0
0597   0772 DD            push bl
0598   0773 07 66 0C      call putchar
0599   0776 51 01 00      add sp, 1
0600   0779             ;; p = p + 2; 
0601   0779 FA FF FF      lea d, [bp + -1] ; $p
0602   077C DA            push d
0603   077D FA FF FF      lea d, [bp + -1] ; $p
0604   0780 2A            mov b, [d]
0605   0781             ; START TERMS
0606   0781 D7            push a
0607   0782 11            mov a, b
0608   0783 26 02 00      mov b, $2
0609   0786 54            add a, b
0610   0787 27            mov b, a
0611   0788 E4            pop a
0612   0789             ; END TERMS
0613   0789 E7            pop d
0614   078A FD 43         mov [d], b
0615   078C             ;; break; 
0616   078C 0A C0 07      jmp _switch8_exit ; case break
0617   078F             _switch8_case5:
0618   078F             ;; print(*(char**)p); 
0619   078F FA FF FF      lea d, [bp + -1] ; $p
0620   0792 2A            mov b, [d]
0621   0793 74            mov d, b
0622   0794 2A            mov b, [d]
0623   0795 FD AB         swp b
0624   0797 D8            push b
0625   0798 07 AE 0C      call print
0626   079B 51 02 00      add sp, 2
0627   079E             ;; p = p + 2; 
0628   079E FA FF FF      lea d, [bp + -1] ; $p
0629   07A1 DA            push d
0630   07A2 FA FF FF      lea d, [bp + -1] ; $p
0631   07A5 2A            mov b, [d]
0632   07A6             ; START TERMS
0633   07A6 D7            push a
0634   07A7 11            mov a, b
0635   07A8 26 02 00      mov b, $2
0636   07AB 54            add a, b
0637   07AC 27            mov b, a
0638   07AD E4            pop a
0639   07AE             ; END TERMS
0640   07AE E7            pop d
0641   07AF FD 43         mov [d], b
0642   07B1             ;; break; 
0643   07B1 0A C0 07      jmp _switch8_exit ; case break
0644   07B4             _switch8_default:
0645   07B4             ;; print("Error: Unknown argument type.\n"); 
0646   07B4 26 F9 11      mov b, __s1 ; "Error: Unknown argument type.\n"
0647   07B7 FD AB         swp b
0648   07B9 D8            push b
0649   07BA 07 AE 0C      call print
0650   07BD 51 02 00      add sp, 2
0651   07C0             _switch8_exit:
0652   07C0             ;; fp++; 
0653   07C0 FA FD FF      lea d, [bp + -3] ; $fp
0654   07C3 2A            mov b, [d]
0655   07C4 FD 79         mov g, b
0656   07C6 FD 77         inc b
0657   07C8 FA FD FF      lea d, [bp + -3] ; $fp
0658   07CB FD 43         mov [d], b
0659   07CD FD 27         mov b, g
0660   07CF 0A F0 07      jmp _if7_exit
0661   07D2             _if7_else:
0662   07D2             ;; putchar(*fp); 
0663   07D2 FA FD FF      lea d, [bp + -3] ; $fp
0664   07D5 2A            mov b, [d]
0665   07D6 74            mov d, b
0666   07D7 32            mov bl, [d]
0667   07D8 A7 00         mov bh, 0
0668   07DA DD            push bl
0669   07DB 07 66 0C      call putchar
0670   07DE 51 01 00      add sp, 1
0671   07E1             ;; fp++; 
0672   07E1 FA FD FF      lea d, [bp + -3] ; $fp
0673   07E4 2A            mov b, [d]
0674   07E5 FD 79         mov g, b
0675   07E7 FD 77         inc b
0676   07E9 FA FD FF      lea d, [bp + -3] ; $fp
0677   07EC FD 43         mov [d], b
0678   07EE FD 27         mov b, g
0679   07F0             _if7_exit:
0680   07F0             _if6_exit:
0681   07F0             _for5_update:
0682   07F0 0A 90 06      jmp _for5_cond
0683   07F3             _for5_exit:
0684   07F3 F9            leave
0685   07F4 09            ret
0686   07F5             
0687   07F5             printx16:
0688   07F5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0689   07F8             
0690   07F8             ; --- BEGIN INLINE ASM BLOCK
0691   07F8 FA 05 00      lea d, [bp + 5] ; $hex
0692   07FB 2A            mov b, [d]
0693   07FC 07 85 10      call print_u16x
0694   07FF             ; --- END INLINE ASM BLOCK
0695   07FF             
0696   07FF F9            leave
0697   0800 09            ret
0698   0801             
0699   0801             printx8:
0700   0801 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0701   0804             
0702   0804             ; --- BEGIN INLINE ASM BLOCK
0703   0804 FA 05 00      lea d, [bp + 5] ; $hex
0704   0807 32            mov bl, [d]
0705   0808 07 C9 10      call print_u8x
0706   080B             ; --- END INLINE ASM BLOCK
0707   080B             
0708   080B F9            leave
0709   080C 09            ret
0710   080D             
0711   080D             hex_to_int:
0712   080D F8 00 00      enter 0 ; (push bp; mov bp, sp)
0713   0810             ; $value 
0714   0810 10 00 00      mov a, $0
0715   0813 45 FF FF      mov [bp + -1], a
0716   0816             ; $i 
0717   0816             ; $hex_char 
0718   0816             ; $len 
0719   0816 52 07 00      sub sp, 7
0720   0819             ;; len = strlen(hex_string); 
0721   0819 FA FA FF      lea d, [bp + -6] ; $len
0722   081C DA            push d
0723   081D FA 05 00      lea d, [bp + 5] ; $hex_string
0724   0820 2A            mov b, [d]
0725   0821 FD AB         swp b
0726   0823 D8            push b
0727   0824 07 21 06      call strlen
0728   0827 51 02 00      add sp, 2
0729   082A E7            pop d
0730   082B FD 43         mov [d], b
0731   082D             ;; for (i = 0; i < len; i++) { 
0732   082D             _for9_init:
0733   082D FA FD FF      lea d, [bp + -3] ; $i
0734   0830 DA            push d
0735   0831 26 00 00      mov b, $0
0736   0834 E7            pop d
0737   0835 FD 43         mov [d], b
0738   0837             _for9_cond:
0739   0837 FA FD FF      lea d, [bp + -3] ; $i
0740   083A 2A            mov b, [d]
0741   083B             ; START RELATIONAL
0742   083B D7            push a
0743   083C 11            mov a, b
0744   083D FA FA FF      lea d, [bp + -6] ; $len
0745   0840 2A            mov b, [d]
0746   0841 B0            cmp a, b
0747   0842 FD 73         slt ; < 
0748   0844 E4            pop a
0749   0845             ; END RELATIONAL
0750   0845 C0 00 00      cmp b, 0
0751   0848 C6 4D 09      je _for9_exit
0752   084B             _for9_block:
0753   084B             ;; hex_char = hex_string[i]; 
0754   084B FA FC FF      lea d, [bp + -4] ; $hex_char
0755   084E DA            push d
0756   084F FA 05 00      lea d, [bp + 5] ; $hex_string
0757   0852 FD 2A         mov d, [d]
0758   0854 D7            push a
0759   0855 DA            push d
0760   0856 FA FD FF      lea d, [bp + -3] ; $i
0761   0859 2A            mov b, [d]
0762   085A E7            pop d
0763   085B FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0764   085F E4            pop a
0765   0860 32            mov bl, [d]
0766   0861 A7 00         mov bh, 0
0767   0863 E7            pop d
0768   0864 FD 3E         mov [d], bl
0769   0866             ;; if (hex_char >= 'a' && hex_char <= 'f')  
0770   0866             _if10_cond:
0771   0866 FA FC FF      lea d, [bp + -4] ; $hex_char
0772   0869 32            mov bl, [d]
0773   086A A7 00         mov bh, 0
0774   086C             ; START RELATIONAL
0775   086C D7            push a
0776   086D 11            mov a, b
0777   086E 26 61 00      mov b, $61
0778   0871 B0            cmp a, b
0779   0872 FD 80         sge ; >=
0780   0874 E4            pop a
0781   0875             ; END RELATIONAL
0782   0875 D7            push a
0783   0876 11            mov a, b
0784   0877 FA FC FF      lea d, [bp + -4] ; $hex_char
0785   087A 32            mov bl, [d]
0786   087B A7 00         mov bh, 0
0787   087D             ; START RELATIONAL
0788   087D D7            push a
0789   087E 11            mov a, b
0790   087F 26 66 00      mov b, $66
0791   0882 B0            cmp a, b
0792   0883 FD 74         sle ; <=
0793   0885 E4            pop a
0794   0886             ; END RELATIONAL
0795   0886 FD A7         sand a, b ; &&
0796   0888 E4            pop a
0797   0889 C0 00 00      cmp b, 0
0798   088C C6 BD 08      je _if10_else
0799   088F             _if10_true:
0800   088F             ;; value = (value * 16) + (hex_char - 'a' + 10); 
0801   088F FA FF FF      lea d, [bp + -1] ; $value
0802   0892 DA            push d
0803   0893 FA FF FF      lea d, [bp + -1] ; $value
0804   0896 2A            mov b, [d]
0805   0897             ; START FACTORS
0806   0897 D7            push a
0807   0898 11            mov a, b
0808   0899 26 10 00      mov b, $10
0809   089C AC            mul a, b ; *
0810   089D 11            mov a, b
0811   089E 27            mov b, a
0812   089F E4            pop a
0813   08A0             ; END FACTORS
0814   08A0             ; START TERMS
0815   08A0 D7            push a
0816   08A1 11            mov a, b
0817   08A2 FA FC FF      lea d, [bp + -4] ; $hex_char
0818   08A5 32            mov bl, [d]
0819   08A6 A7 00         mov bh, 0
0820   08A8             ; START TERMS
0821   08A8 D7            push a
0822   08A9 11            mov a, b
0823   08AA 26 61 00      mov b, $61
0824   08AD 60            sub a, b
0825   08AE 26 0A 00      mov b, $a
0826   08B1 54            add a, b
0827   08B2 27            mov b, a
0828   08B3 E4            pop a
0829   08B4             ; END TERMS
0830   08B4 54            add a, b
0831   08B5 27            mov b, a
0832   08B6 E4            pop a
0833   08B7             ; END TERMS
0834   08B7 E7            pop d
0835   08B8 FD 43         mov [d], b
0836   08BA 0A 3B 09      jmp _if10_exit
0837   08BD             _if10_else:
0838   08BD             ;; if (hex_char >= 'A' && hex_char <= 'F')  
0839   08BD             _if11_cond:
0840   08BD FA FC FF      lea d, [bp + -4] ; $hex_char
0841   08C0 32            mov bl, [d]
0842   08C1 A7 00         mov bh, 0
0843   08C3             ; START RELATIONAL
0844   08C3 D7            push a
0845   08C4 11            mov a, b
0846   08C5 26 41 00      mov b, $41
0847   08C8 B0            cmp a, b
0848   08C9 FD 80         sge ; >=
0849   08CB E4            pop a
0850   08CC             ; END RELATIONAL
0851   08CC D7            push a
0852   08CD 11            mov a, b
0853   08CE FA FC FF      lea d, [bp + -4] ; $hex_char
0854   08D1 32            mov bl, [d]
0855   08D2 A7 00         mov bh, 0
0856   08D4             ; START RELATIONAL
0857   08D4 D7            push a
0858   08D5 11            mov a, b
0859   08D6 26 46 00      mov b, $46
0860   08D9 B0            cmp a, b
0861   08DA FD 74         sle ; <=
0862   08DC E4            pop a
0863   08DD             ; END RELATIONAL
0864   08DD FD A7         sand a, b ; &&
0865   08DF E4            pop a
0866   08E0 C0 00 00      cmp b, 0
0867   08E3 C6 14 09      je _if11_else
0868   08E6             _if11_true:
0869   08E6             ;; value = (value * 16) + (hex_char - 'A' + 10); 
0870   08E6 FA FF FF      lea d, [bp + -1] ; $value
0871   08E9 DA            push d
0872   08EA FA FF FF      lea d, [bp + -1] ; $value
0873   08ED 2A            mov b, [d]
0874   08EE             ; START FACTORS
0875   08EE D7            push a
0876   08EF 11            mov a, b
0877   08F0 26 10 00      mov b, $10
0878   08F3 AC            mul a, b ; *
0879   08F4 11            mov a, b
0880   08F5 27            mov b, a
0881   08F6 E4            pop a
0882   08F7             ; END FACTORS
0883   08F7             ; START TERMS
0884   08F7 D7            push a
0885   08F8 11            mov a, b
0886   08F9 FA FC FF      lea d, [bp + -4] ; $hex_char
0887   08FC 32            mov bl, [d]
0888   08FD A7 00         mov bh, 0
0889   08FF             ; START TERMS
0890   08FF D7            push a
0891   0900 11            mov a, b
0892   0901 26 41 00      mov b, $41
0893   0904 60            sub a, b
0894   0905 26 0A 00      mov b, $a
0895   0908 54            add a, b
0896   0909 27            mov b, a
0897   090A E4            pop a
0898   090B             ; END TERMS
0899   090B 54            add a, b
0900   090C 27            mov b, a
0901   090D E4            pop a
0902   090E             ; END TERMS
0903   090E E7            pop d
0904   090F FD 43         mov [d], b
0905   0911 0A 3B 09      jmp _if11_exit
0906   0914             _if11_else:
0907   0914             ;; value = (value * 16) + (hex_char - '0'); 
0908   0914 FA FF FF      lea d, [bp + -1] ; $value
0909   0917 DA            push d
0910   0918 FA FF FF      lea d, [bp + -1] ; $value
0911   091B 2A            mov b, [d]
0912   091C             ; START FACTORS
0913   091C D7            push a
0914   091D 11            mov a, b
0915   091E 26 10 00      mov b, $10
0916   0921 AC            mul a, b ; *
0917   0922 11            mov a, b
0918   0923 27            mov b, a
0919   0924 E4            pop a
0920   0925             ; END FACTORS
0921   0925             ; START TERMS
0922   0925 D7            push a
0923   0926 11            mov a, b
0924   0927 FA FC FF      lea d, [bp + -4] ; $hex_char
0925   092A 32            mov bl, [d]
0926   092B A7 00         mov bh, 0
0927   092D             ; START TERMS
0928   092D D7            push a
0929   092E 11            mov a, b
0930   092F 26 30 00      mov b, $30
0931   0932 60            sub a, b
0932   0933 27            mov b, a
0933   0934 E4            pop a
0934   0935             ; END TERMS
0935   0935 54            add a, b
0936   0936 27            mov b, a
0937   0937 E4            pop a
0938   0938             ; END TERMS
0939   0938 E7            pop d
0940   0939 FD 43         mov [d], b
0941   093B             _if11_exit:
0942   093B             _if10_exit:
0943   093B             _for9_update:
0944   093B FA FD FF      lea d, [bp + -3] ; $i
0945   093E 2A            mov b, [d]
0946   093F FD 79         mov g, b
0947   0941 FD 77         inc b
0948   0943 FA FD FF      lea d, [bp + -3] ; $i
0949   0946 FD 43         mov [d], b
0950   0948 FD 27         mov b, g
0951   094A 0A 37 08      jmp _for9_cond
0952   094D             _for9_exit:
0953   094D             ;; return value; 
0954   094D FA FF FF      lea d, [bp + -1] ; $value
0955   0950 2A            mov b, [d]
0956   0951 F9            leave
0957   0952 09            ret
0958   0953             
0959   0953             atoi:
0960   0953 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0961   0956             ; $result 
0962   0956 10 00 00      mov a, $0
0963   0959 45 FF FF      mov [bp + -1], a
0964   095C             ; $sign 
0965   095C 10 01 00      mov a, $1
0966   095F 45 FD FF      mov [bp + -3], a
0967   0962 52 04 00      sub sp, 4
0968   0965             ;; while (*str == ' ') str++; 
0969   0965             _while12_cond:
0970   0965 FA 05 00      lea d, [bp + 5] ; $str
0971   0968 2A            mov b, [d]
0972   0969 74            mov d, b
0973   096A 32            mov bl, [d]
0974   096B A7 00         mov bh, 0
0975   096D             ; START RELATIONAL
0976   096D D7            push a
0977   096E 11            mov a, b
0978   096F 26 20 00      mov b, $20
0979   0972 B0            cmp a, b
0980   0973 FD 71         seq ; ==
0981   0975 E4            pop a
0982   0976             ; END RELATIONAL
0983   0976 C0 00 00      cmp b, 0
0984   0979 C6 8E 09      je _while12_exit
0985   097C             _while12_block:
0986   097C             ;; str++; 
0987   097C FA 05 00      lea d, [bp + 5] ; $str
0988   097F 2A            mov b, [d]
0989   0980 FD 79         mov g, b
0990   0982 FD 77         inc b
0991   0984 FA 05 00      lea d, [bp + 5] ; $str
0992   0987 FD 43         mov [d], b
0993   0989 FD 27         mov b, g
0994   098B 0A 65 09      jmp _while12_cond
0995   098E             _while12_exit:
0996   098E             ;; if (*str == '-' || *str == '+') { 
0997   098E             _if13_cond:
0998   098E FA 05 00      lea d, [bp + 5] ; $str
0999   0991 2A            mov b, [d]
1000   0992 74            mov d, b
1001   0993 32            mov bl, [d]
1002   0994 A7 00         mov bh, 0
1003   0996             ; START RELATIONAL
1004   0996 D7            push a
1005   0997 11            mov a, b
1006   0998 26 2D 00      mov b, $2d
1007   099B B0            cmp a, b
1008   099C FD 71         seq ; ==
1009   099E E4            pop a
1010   099F             ; END RELATIONAL
1011   099F D7            push a
1012   09A0 11            mov a, b
1013   09A1 FA 05 00      lea d, [bp + 5] ; $str
1014   09A4 2A            mov b, [d]
1015   09A5 74            mov d, b
1016   09A6 32            mov bl, [d]
1017   09A7 A7 00         mov bh, 0
1018   09A9             ; START RELATIONAL
1019   09A9 D7            push a
1020   09AA 11            mov a, b
1021   09AB 26 2B 00      mov b, $2b
1022   09AE B0            cmp a, b
1023   09AF FD 71         seq ; ==
1024   09B1 E4            pop a
1025   09B2             ; END RELATIONAL
1026   09B2 FD A8         sor a, b ; ||
1027   09B4 E4            pop a
1028   09B5 C0 00 00      cmp b, 0
1029   09B8 C6 F3 09      je _if13_exit
1030   09BB             _if13_true:
1031   09BB             ;; if (*str == '-') sign = -1; 
1032   09BB             _if14_cond:
1033   09BB FA 05 00      lea d, [bp + 5] ; $str
1034   09BE 2A            mov b, [d]
1035   09BF 74            mov d, b
1036   09C0 32            mov bl, [d]
1037   09C1 A7 00         mov bh, 0
1038   09C3             ; START RELATIONAL
1039   09C3 D7            push a
1040   09C4 11            mov a, b
1041   09C5 26 2D 00      mov b, $2d
1042   09C8 B0            cmp a, b
1043   09C9 FD 71         seq ; ==
1044   09CB E4            pop a
1045   09CC             ; END RELATIONAL
1046   09CC C0 00 00      cmp b, 0
1047   09CF C6 E1 09      je _if14_exit
1048   09D2             _if14_true:
1049   09D2             ;; sign = -1; 
1050   09D2 FA FD FF      lea d, [bp + -3] ; $sign
1051   09D5 DA            push d
1052   09D6 26 01 00      mov b, $1
1053   09D9 FD 97         neg b
1054   09DB E7            pop d
1055   09DC FD 43         mov [d], b
1056   09DE 0A E1 09      jmp _if14_exit
1057   09E1             _if14_exit:
1058   09E1             ;; str++; 
1059   09E1 FA 05 00      lea d, [bp + 5] ; $str
1060   09E4 2A            mov b, [d]
1061   09E5 FD 79         mov g, b
1062   09E7 FD 77         inc b
1063   09E9 FA 05 00      lea d, [bp + 5] ; $str
1064   09EC FD 43         mov [d], b
1065   09EE FD 27         mov b, g
1066   09F0 0A F3 09      jmp _if13_exit
1067   09F3             _if13_exit:
1068   09F3             ;; while (*str >= '0' && *str <= '9') { 
1069   09F3             _while15_cond:
1070   09F3 FA 05 00      lea d, [bp + 5] ; $str
1071   09F6 2A            mov b, [d]
1072   09F7 74            mov d, b
1073   09F8 32            mov bl, [d]
1074   09F9 A7 00         mov bh, 0
1075   09FB             ; START RELATIONAL
1076   09FB D7            push a
1077   09FC 11            mov a, b
1078   09FD 26 30 00      mov b, $30
1079   0A00 B0            cmp a, b
1080   0A01 FD 80         sge ; >=
1081   0A03 E4            pop a
1082   0A04             ; END RELATIONAL
1083   0A04 D7            push a
1084   0A05 11            mov a, b
1085   0A06 FA 05 00      lea d, [bp + 5] ; $str
1086   0A09 2A            mov b, [d]
1087   0A0A 74            mov d, b
1088   0A0B 32            mov bl, [d]
1089   0A0C A7 00         mov bh, 0
1090   0A0E             ; START RELATIONAL
1091   0A0E D7            push a
1092   0A0F 11            mov a, b
1093   0A10 26 39 00      mov b, $39
1094   0A13 B0            cmp a, b
1095   0A14 FD 74         sle ; <=
1096   0A16 E4            pop a
1097   0A17             ; END RELATIONAL
1098   0A17 FD A7         sand a, b ; &&
1099   0A19 E4            pop a
1100   0A1A C0 00 00      cmp b, 0
1101   0A1D C6 5B 0A      je _while15_exit
1102   0A20             _while15_block:
1103   0A20             ;; result = result * 10 + (*str - '0'); 
1104   0A20 FA FF FF      lea d, [bp + -1] ; $result
1105   0A23 DA            push d
1106   0A24 FA FF FF      lea d, [bp + -1] ; $result
1107   0A27 2A            mov b, [d]
1108   0A28             ; START FACTORS
1109   0A28 D7            push a
1110   0A29 11            mov a, b
1111   0A2A 26 0A 00      mov b, $a
1112   0A2D AC            mul a, b ; *
1113   0A2E 11            mov a, b
1114   0A2F 27            mov b, a
1115   0A30 E4            pop a
1116   0A31             ; END FACTORS
1117   0A31             ; START TERMS
1118   0A31 D7            push a
1119   0A32 11            mov a, b
1120   0A33 FA 05 00      lea d, [bp + 5] ; $str
1121   0A36 2A            mov b, [d]
1122   0A37 74            mov d, b
1123   0A38 32            mov bl, [d]
1124   0A39 A7 00         mov bh, 0
1125   0A3B             ; START TERMS
1126   0A3B D7            push a
1127   0A3C 11            mov a, b
1128   0A3D 26 30 00      mov b, $30
1129   0A40 60            sub a, b
1130   0A41 27            mov b, a
1131   0A42 E4            pop a
1132   0A43             ; END TERMS
1133   0A43 54            add a, b
1134   0A44 27            mov b, a
1135   0A45 E4            pop a
1136   0A46             ; END TERMS
1137   0A46 E7            pop d
1138   0A47 FD 43         mov [d], b
1139   0A49             ;; str++; 
1140   0A49 FA 05 00      lea d, [bp + 5] ; $str
1141   0A4C 2A            mov b, [d]
1142   0A4D FD 79         mov g, b
1143   0A4F FD 77         inc b
1144   0A51 FA 05 00      lea d, [bp + 5] ; $str
1145   0A54 FD 43         mov [d], b
1146   0A56 FD 27         mov b, g
1147   0A58 0A F3 09      jmp _while15_cond
1148   0A5B             _while15_exit:
1149   0A5B             ;; return sign * result; 
1150   0A5B FA FD FF      lea d, [bp + -3] ; $sign
1151   0A5E 2A            mov b, [d]
1152   0A5F             ; START FACTORS
1153   0A5F D7            push a
1154   0A60 11            mov a, b
1155   0A61 FA FF FF      lea d, [bp + -1] ; $result
1156   0A64 2A            mov b, [d]
1157   0A65 AC            mul a, b ; *
1158   0A66 11            mov a, b
1159   0A67 27            mov b, a
1160   0A68 E4            pop a
1161   0A69             ; END FACTORS
1162   0A69 F9            leave
1163   0A6A 09            ret
1164   0A6B             
1165   0A6B             gets:
1166   0A6B F8 00 00      enter 0 ; (push bp; mov bp, sp)
1167   0A6E             
1168   0A6E             ; --- BEGIN INLINE ASM BLOCK
1169   0A6E FA 05 00      lea d, [bp + 5] ; $s
1170   0A71 15            mov a, [d]
1171   0A72 3C            mov d, a
1172   0A73 07 EA 0E      call _gets
1173   0A76             ; --- END INLINE ASM BLOCK
1174   0A76             
1175   0A76             ;; return strlen(s); 
1176   0A76 FA 05 00      lea d, [bp + 5] ; $s
1177   0A79 2A            mov b, [d]
1178   0A7A FD AB         swp b
1179   0A7C D8            push b
1180   0A7D 07 21 06      call strlen
1181   0A80 51 02 00      add sp, 2
1182   0A83 F9            leave
1183   0A84 09            ret
1184   0A85             
1185   0A85             prints:
1186   0A85 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1187   0A88             ; $digits 
1188   0A88             ; $i 
1189   0A88 10 00 00      mov a, $0
1190   0A8B 45 FA FF      mov [bp + -6], a
1191   0A8E 52 07 00      sub sp, 7
1192   0A91             ;; if (num < 0) { 
1193   0A91             _if16_cond:
1194   0A91 FA 05 00      lea d, [bp + 5] ; $num
1195   0A94 2A            mov b, [d]
1196   0A95             ; START RELATIONAL
1197   0A95 D7            push a
1198   0A96 11            mov a, b
1199   0A97 26 00 00      mov b, $0
1200   0A9A B0            cmp a, b
1201   0A9B FD 73         slt ; < 
1202   0A9D E4            pop a
1203   0A9E             ; END RELATIONAL
1204   0A9E C0 00 00      cmp b, 0
1205   0AA1 C6 BE 0A      je _if16_else
1206   0AA4             _if16_true:
1207   0AA4             ;; putchar('-'); 
1208   0AA4 26 2D 00      mov b, $2d
1209   0AA7 DD            push bl
1210   0AA8 07 66 0C      call putchar
1211   0AAB 51 01 00      add sp, 1
1212   0AAE             ;; num = -num; 
1213   0AAE FA 05 00      lea d, [bp + 5] ; $num
1214   0AB1 DA            push d
1215   0AB2 FA 05 00      lea d, [bp + 5] ; $num
1216   0AB5 2A            mov b, [d]
1217   0AB6 FD 97         neg b
1218   0AB8 E7            pop d
1219   0AB9 FD 43         mov [d], b
1220   0ABB 0A E0 0A      jmp _if16_exit
1221   0ABE             _if16_else:
1222   0ABE             ;; if (num == 0) { 
1223   0ABE             _if17_cond:
1224   0ABE FA 05 00      lea d, [bp + 5] ; $num
1225   0AC1 2A            mov b, [d]
1226   0AC2             ; START RELATIONAL
1227   0AC2 D7            push a
1228   0AC3 11            mov a, b
1229   0AC4 26 00 00      mov b, $0
1230   0AC7 B0            cmp a, b
1231   0AC8 FD 71         seq ; ==
1232   0ACA E4            pop a
1233   0ACB             ; END RELATIONAL
1234   0ACB C0 00 00      cmp b, 0
1235   0ACE C6 E0 0A      je _if17_exit
1236   0AD1             _if17_true:
1237   0AD1             ;; putchar('0'); 
1238   0AD1 26 30 00      mov b, $30
1239   0AD4 DD            push bl
1240   0AD5 07 66 0C      call putchar
1241   0AD8 51 01 00      add sp, 1
1242   0ADB             ;; return; 
1243   0ADB F9            leave
1244   0ADC 09            ret
1245   0ADD 0A E0 0A      jmp _if17_exit
1246   0AE0             _if17_exit:
1247   0AE0             _if16_exit:
1248   0AE0             ;; while (num > 0) { 
1249   0AE0             _while18_cond:
1250   0AE0 FA 05 00      lea d, [bp + 5] ; $num
1251   0AE3 2A            mov b, [d]
1252   0AE4             ; START RELATIONAL
1253   0AE4 D7            push a
1254   0AE5 11            mov a, b
1255   0AE6 26 00 00      mov b, $0
1256   0AE9 B0            cmp a, b
1257   0AEA FD 7F         sgt ; >
1258   0AEC E4            pop a
1259   0AED             ; END RELATIONAL
1260   0AED C0 00 00      cmp b, 0
1261   0AF0 C6 3D 0B      je _while18_exit
1262   0AF3             _while18_block:
1263   0AF3             ;; digits[i] = '0' + (num % 10); 
1264   0AF3 FA FC FF      lea d, [bp + -4] ; $digits
1265   0AF6 D7            push a
1266   0AF7 DA            push d
1267   0AF8 FA FA FF      lea d, [bp + -6] ; $i
1268   0AFB 2A            mov b, [d]
1269   0AFC E7            pop d
1270   0AFD 5A            add d, b
1271   0AFE E4            pop a
1272   0AFF DA            push d
1273   0B00 26 30 00      mov b, $30
1274   0B03             ; START TERMS
1275   0B03 D7            push a
1276   0B04 11            mov a, b
1277   0B05 FA 05 00      lea d, [bp + 5] ; $num
1278   0B08 2A            mov b, [d]
1279   0B09             ; START FACTORS
1280   0B09 D7            push a
1281   0B0A 11            mov a, b
1282   0B0B 26 0A 00      mov b, $a
1283   0B0E AE            div a, b ; 
1284   0B0F 11            mov a, b
1285   0B10 27            mov b, a
1286   0B11 E4            pop a
1287   0B12             ; END FACTORS
1288   0B12 54            add a, b
1289   0B13 27            mov b, a
1290   0B14 E4            pop a
1291   0B15             ; END TERMS
1292   0B15 E7            pop d
1293   0B16 FD 3E         mov [d], bl
1294   0B18             ;; num = num / 10; 
1295   0B18 FA 05 00      lea d, [bp + 5] ; $num
1296   0B1B DA            push d
1297   0B1C FA 05 00      lea d, [bp + 5] ; $num
1298   0B1F 2A            mov b, [d]
1299   0B20             ; START FACTORS
1300   0B20 D7            push a
1301   0B21 11            mov a, b
1302   0B22 26 0A 00      mov b, $a
1303   0B25 AE            div a, b
1304   0B26 27            mov b, a
1305   0B27 E4            pop a
1306   0B28             ; END FACTORS
1307   0B28 E7            pop d
1308   0B29 FD 43         mov [d], b
1309   0B2B             ;; i++; 
1310   0B2B FA FA FF      lea d, [bp + -6] ; $i
1311   0B2E 2A            mov b, [d]
1312   0B2F FD 79         mov g, b
1313   0B31 FD 77         inc b
1314   0B33 FA FA FF      lea d, [bp + -6] ; $i
1315   0B36 FD 43         mov [d], b
1316   0B38 FD 27         mov b, g
1317   0B3A 0A E0 0A      jmp _while18_cond
1318   0B3D             _while18_exit:
1319   0B3D             ;; while (i > 0) { 
1320   0B3D             _while19_cond:
1321   0B3D FA FA FF      lea d, [bp + -6] ; $i
1322   0B40 2A            mov b, [d]
1323   0B41             ; START RELATIONAL
1324   0B41 D7            push a
1325   0B42 11            mov a, b
1326   0B43 26 00 00      mov b, $0
1327   0B46 B0            cmp a, b
1328   0B47 FD 7F         sgt ; >
1329   0B49 E4            pop a
1330   0B4A             ; END RELATIONAL
1331   0B4A C0 00 00      cmp b, 0
1332   0B4D C6 78 0B      je _while19_exit
1333   0B50             _while19_block:
1334   0B50             ;; i--; 
1335   0B50 FA FA FF      lea d, [bp + -6] ; $i
1336   0B53 2A            mov b, [d]
1337   0B54 FD 79         mov g, b
1338   0B56 FD 7D         dec b
1339   0B58 FA FA FF      lea d, [bp + -6] ; $i
1340   0B5B FD 43         mov [d], b
1341   0B5D FD 27         mov b, g
1342   0B5F             ;; putchar(digits[i]); 
1343   0B5F FA FC FF      lea d, [bp + -4] ; $digits
1344   0B62 D7            push a
1345   0B63 DA            push d
1346   0B64 FA FA FF      lea d, [bp + -6] ; $i
1347   0B67 2A            mov b, [d]
1348   0B68 E7            pop d
1349   0B69 5A            add d, b
1350   0B6A E4            pop a
1351   0B6B 32            mov bl, [d]
1352   0B6C A7 00         mov bh, 0
1353   0B6E DD            push bl
1354   0B6F 07 66 0C      call putchar
1355   0B72 51 01 00      add sp, 1
1356   0B75 0A 3D 0B      jmp _while19_cond
1357   0B78             _while19_exit:
1358   0B78 F9            leave
1359   0B79 09            ret
1360   0B7A             
1361   0B7A             printu:
1362   0B7A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1363   0B7D             ; $digits 
1364   0B7D             ; $i 
1365   0B7D 52 07 00      sub sp, 7
1366   0B80             ;; i = 0; 
1367   0B80 FA FA FF      lea d, [bp + -6] ; $i
1368   0B83 DA            push d
1369   0B84 26 00 00      mov b, $0
1370   0B87 E7            pop d
1371   0B88 FD 43         mov [d], b
1372   0B8A             ;; if(num == 0){ 
1373   0B8A             _if20_cond:
1374   0B8A FA 05 00      lea d, [bp + 5] ; $num
1375   0B8D 2A            mov b, [d]
1376   0B8E             ; START RELATIONAL
1377   0B8E D7            push a
1378   0B8F 11            mov a, b
1379   0B90 26 00 00      mov b, $0
1380   0B93 B0            cmp a, b
1381   0B94 FD 71         seq ; ==
1382   0B96 E4            pop a
1383   0B97             ; END RELATIONAL
1384   0B97 C0 00 00      cmp b, 0
1385   0B9A C6 AC 0B      je _if20_exit
1386   0B9D             _if20_true:
1387   0B9D             ;; putchar('0'); 
1388   0B9D 26 30 00      mov b, $30
1389   0BA0 DD            push bl
1390   0BA1 07 66 0C      call putchar
1391   0BA4 51 01 00      add sp, 1
1392   0BA7             ;; return; 
1393   0BA7 F9            leave
1394   0BA8 09            ret
1395   0BA9 0A AC 0B      jmp _if20_exit
1396   0BAC             _if20_exit:
1397   0BAC             ;; while (num > 0) { 
1398   0BAC             _while21_cond:
1399   0BAC FA 05 00      lea d, [bp + 5] ; $num
1400   0BAF 2A            mov b, [d]
1401   0BB0             ; START RELATIONAL
1402   0BB0 D7            push a
1403   0BB1 11            mov a, b
1404   0BB2 26 00 00      mov b, $0
1405   0BB5 B0            cmp a, b
1406   0BB6 FD 81         sgu ; > (unsigned)
1407   0BB8 E4            pop a
1408   0BB9             ; END RELATIONAL
1409   0BB9 C0 00 00      cmp b, 0
1410   0BBC C6 09 0C      je _while21_exit
1411   0BBF             _while21_block:
1412   0BBF             ;; digits[i] = '0' + (num % 10); 
1413   0BBF FA FC FF      lea d, [bp + -4] ; $digits
1414   0BC2 D7            push a
1415   0BC3 DA            push d
1416   0BC4 FA FA FF      lea d, [bp + -6] ; $i
1417   0BC7 2A            mov b, [d]
1418   0BC8 E7            pop d
1419   0BC9 5A            add d, b
1420   0BCA E4            pop a
1421   0BCB DA            push d
1422   0BCC 26 30 00      mov b, $30
1423   0BCF             ; START TERMS
1424   0BCF D7            push a
1425   0BD0 11            mov a, b
1426   0BD1 FA 05 00      lea d, [bp + 5] ; $num
1427   0BD4 2A            mov b, [d]
1428   0BD5             ; START FACTORS
1429   0BD5 D7            push a
1430   0BD6 11            mov a, b
1431   0BD7 26 0A 00      mov b, $a
1432   0BDA AE            div a, b ; 
1433   0BDB 11            mov a, b
1434   0BDC 27            mov b, a
1435   0BDD E4            pop a
1436   0BDE             ; END FACTORS
1437   0BDE 54            add a, b
1438   0BDF 27            mov b, a
1439   0BE0 E4            pop a
1440   0BE1             ; END TERMS
1441   0BE1 E7            pop d
1442   0BE2 FD 3E         mov [d], bl
1443   0BE4             ;; num = num / 10; 
1444   0BE4 FA 05 00      lea d, [bp + 5] ; $num
1445   0BE7 DA            push d
1446   0BE8 FA 05 00      lea d, [bp + 5] ; $num
1447   0BEB 2A            mov b, [d]
1448   0BEC             ; START FACTORS
1449   0BEC D7            push a
1450   0BED 11            mov a, b
1451   0BEE 26 0A 00      mov b, $a
1452   0BF1 AE            div a, b
1453   0BF2 27            mov b, a
1454   0BF3 E4            pop a
1455   0BF4             ; END FACTORS
1456   0BF4 E7            pop d
1457   0BF5 FD 43         mov [d], b
1458   0BF7             ;; i++; 
1459   0BF7 FA FA FF      lea d, [bp + -6] ; $i
1460   0BFA 2A            mov b, [d]
1461   0BFB FD 79         mov g, b
1462   0BFD FD 77         inc b
1463   0BFF FA FA FF      lea d, [bp + -6] ; $i
1464   0C02 FD 43         mov [d], b
1465   0C04 FD 27         mov b, g
1466   0C06 0A AC 0B      jmp _while21_cond
1467   0C09             _while21_exit:
1468   0C09             ;; while (i > 0) { 
1469   0C09             _while22_cond:
1470   0C09 FA FA FF      lea d, [bp + -6] ; $i
1471   0C0C 2A            mov b, [d]
1472   0C0D             ; START RELATIONAL
1473   0C0D D7            push a
1474   0C0E 11            mov a, b
1475   0C0F 26 00 00      mov b, $0
1476   0C12 B0            cmp a, b
1477   0C13 FD 7F         sgt ; >
1478   0C15 E4            pop a
1479   0C16             ; END RELATIONAL
1480   0C16 C0 00 00      cmp b, 0
1481   0C19 C6 44 0C      je _while22_exit
1482   0C1C             _while22_block:
1483   0C1C             ;; i--; 
1484   0C1C FA FA FF      lea d, [bp + -6] ; $i
1485   0C1F 2A            mov b, [d]
1486   0C20 FD 79         mov g, b
1487   0C22 FD 7D         dec b
1488   0C24 FA FA FF      lea d, [bp + -6] ; $i
1489   0C27 FD 43         mov [d], b
1490   0C29 FD 27         mov b, g
1491   0C2B             ;; putchar(digits[i]); 
1492   0C2B FA FC FF      lea d, [bp + -4] ; $digits
1493   0C2E D7            push a
1494   0C2F DA            push d
1495   0C30 FA FA FF      lea d, [bp + -6] ; $i
1496   0C33 2A            mov b, [d]
1497   0C34 E7            pop d
1498   0C35 5A            add d, b
1499   0C36 E4            pop a
1500   0C37 32            mov bl, [d]
1501   0C38 A7 00         mov bh, 0
1502   0C3A DD            push bl
1503   0C3B 07 66 0C      call putchar
1504   0C3E 51 01 00      add sp, 1
1505   0C41 0A 09 0C      jmp _while22_cond
1506   0C44             _while22_exit:
1507   0C44 F9            leave
1508   0C45 09            ret
1509   0C46             
1510   0C46             rand:
1511   0C46 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1512   0C49             ; $sec 
1513   0C49 52 01 00      sub sp, 1
1514   0C4C             
1515   0C4C             ; --- BEGIN INLINE ASM BLOCK
1516   0C4C 19 00         mov al, 0
1517   0C4E 05 01         syscall sys_rtc					
1518   0C50 1A            mov al, ah
1519   0C51 FA 00 00      lea d, [bp + 0] ; $sec
1520   0C54 1E            mov al, [d]
1521   0C55             ; --- END INLINE ASM BLOCK
1522   0C55             
1523   0C55             ;; return sec; 
1524   0C55 FA 00 00      lea d, [bp + 0] ; $sec
1525   0C58 32            mov bl, [d]
1526   0C59 A7 00         mov bh, 0
1527   0C5B F9            leave
1528   0C5C 09            ret
1529   0C5D             
1530   0C5D             date:
1531   0C5D F8 00 00      enter 0 ; (push bp; mov bp, sp)
1532   0C60             
1533   0C60             ; --- BEGIN INLINE ASM BLOCK
1534   0C60 19 00         mov al, 0 
1535   0C62 05 07         syscall sys_datetime
1536   0C64             ; --- END INLINE ASM BLOCK
1537   0C64             
1538   0C64 F9            leave
1539   0C65 09            ret
1540   0C66             
1541   0C66             putchar:
1542   0C66 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1543   0C69             
1544   0C69             ; --- BEGIN INLINE ASM BLOCK
1545   0C69 FA 05 00      lea d, [bp + 5] ; $c
1546   0C6C 1E            mov al, [d]
1547   0C6D 23            mov ah, al
1548   0C6E 07 E3 0E      call _putchar
1549   0C71             ; --- END INLINE ASM BLOCK
1550   0C71             
1551   0C71 F9            leave
1552   0C72 09            ret
1553   0C73             
1554   0C73             getchar:
1555   0C73 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1556   0C76             ; $c 
1557   0C76 52 01 00      sub sp, 1
1558   0C79             
1559   0C79             ; --- BEGIN INLINE ASM BLOCK
1560   0C79 07 DC 0E      call getch
1561   0C7C 1A            mov al, ah
1562   0C7D FA 00 00      lea d, [bp + 0] ; $c
1563   0C80 3E            mov [d], al
1564   0C81             ; --- END INLINE ASM BLOCK
1565   0C81             
1566   0C81             ;; return c; 
1567   0C81 FA 00 00      lea d, [bp + 0] ; $c
1568   0C84 32            mov bl, [d]
1569   0C85 A7 00         mov bh, 0
1570   0C87 F9            leave
1571   0C88 09            ret
1572   0C89             
1573   0C89             scann:
1574   0C89 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1575   0C8C             ; $m 
1576   0C8C 52 02 00      sub sp, 2
1577   0C8F             
1578   0C8F             ; --- BEGIN INLINE ASM BLOCK
1579   0C8F 07 27 11      call scan_u16d
1580   0C92 FA FF FF      lea d, [bp + -1] ; $m
1581   0C95 43            mov [d], a
1582   0C96             ; --- END INLINE ASM BLOCK
1583   0C96             
1584   0C96             ;; return m; 
1585   0C96 FA FF FF      lea d, [bp + -1] ; $m
1586   0C99 2A            mov b, [d]
1587   0C9A F9            leave
1588   0C9B 09            ret
1589   0C9C             
1590   0C9C             puts:
1591   0C9C F8 00 00      enter 0 ; (push bp; mov bp, sp)
1592   0C9F             
1593   0C9F             ; --- BEGIN INLINE ASM BLOCK
1594   0C9F FA 05 00      lea d, [bp + 5] ; $s
1595   0CA2 15            mov a, [d]
1596   0CA3 3C            mov d, a
1597   0CA4 07 2D 10      call _puts
1598   0CA7 10 00 0A      mov a, $0A00
1599   0CAA 05 03         syscall sys_io
1600   0CAC             ; --- END INLINE ASM BLOCK
1601   0CAC             
1602   0CAC F9            leave
1603   0CAD 09            ret
1604   0CAE             
1605   0CAE             print:
1606   0CAE F8 00 00      enter 0 ; (push bp; mov bp, sp)
1607   0CB1             
1608   0CB1             ; --- BEGIN INLINE ASM BLOCK
1609   0CB1 FA 05 00      lea d, [bp + 5] ; $s
1610   0CB4 FD 2A         mov d, [d]
1611   0CB6 07 2D 10      call _puts
1612   0CB9             ; --- END INLINE ASM BLOCK
1613   0CB9             
1614   0CB9 F9            leave
1615   0CBA 09            ret
1616   0CBB             
1617   0CBB             loadfile:
1618   0CBB F8 00 00      enter 0 ; (push bp; mov bp, sp)
1619   0CBE             
1620   0CBE             ; --- BEGIN INLINE ASM BLOCK
1621   0CBE FA 07 00      lea d, [bp + 7] ; $destination
1622   0CC1 15            mov a, [d]
1623   0CC2 4F            mov di, a
1624   0CC3 FA 05 00      lea d, [bp + 5] ; $filename
1625   0CC6 FD 2A         mov d, [d]
1626   0CC8 19 14         mov al, 20
1627   0CCA 05 04         syscall sys_filesystem
1628   0CCC             ; --- END INLINE ASM BLOCK
1629   0CCC             
1630   0CCC F9            leave
1631   0CCD 09            ret
1632   0CCE             
1633   0CCE             create_file:
1634   0CCE F8 00 00      enter 0 ; (push bp; mov bp, sp)
1635   0CD1 F9            leave
1636   0CD2 09            ret
1637   0CD3             
1638   0CD3             delete_file:
1639   0CD3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1640   0CD6             
1641   0CD6             ; --- BEGIN INLINE ASM BLOCK
1642   0CD6 FA 05 00      lea d, [bp + 5] ; $filename
1643   0CD9 19 0A         mov al, 10
1644   0CDB 05 04         syscall sys_filesystem
1645   0CDD             ; --- END INLINE ASM BLOCK
1646   0CDD             
1647   0CDD F9            leave
1648   0CDE 09            ret
1649   0CDF             
1650   0CDF             fopen:
1651   0CDF F8 00 00      enter 0 ; (push bp; mov bp, sp)
1652   0CE2 F9            leave
1653   0CE3 09            ret
1654   0CE4             
1655   0CE4             fclose:
1656   0CE4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1657   0CE7 F9            leave
1658   0CE8 09            ret
1659   0CE9             
1660   0CE9             alloc:
1661   0CE9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1662   0CEC             ;; heap_top = heap_top + bytes; 
1663   0CEC 3B 22 12      mov d, _heap_top ; $heap_top
1664   0CEF DA            push d
1665   0CF0 3B 22 12      mov d, _heap_top ; $heap_top
1666   0CF3 2A            mov b, [d]
1667   0CF4             ; START TERMS
1668   0CF4 D7            push a
1669   0CF5 11            mov a, b
1670   0CF6 FA 05 00      lea d, [bp + 5] ; $bytes
1671   0CF9 2A            mov b, [d]
1672   0CFA 54            add a, b
1673   0CFB 27            mov b, a
1674   0CFC E4            pop a
1675   0CFD             ; END TERMS
1676   0CFD E7            pop d
1677   0CFE FD 43         mov [d], b
1678   0D00             ;; return heap_top - bytes; 
1679   0D00 3B 22 12      mov d, _heap_top ; $heap_top
1680   0D03 2A            mov b, [d]
1681   0D04             ; START TERMS
1682   0D04 D7            push a
1683   0D05 11            mov a, b
1684   0D06 FA 05 00      lea d, [bp + 5] ; $bytes
1685   0D09 2A            mov b, [d]
1686   0D0A 60            sub a, b
1687   0D0B 27            mov b, a
1688   0D0C E4            pop a
1689   0D0D             ; END TERMS
1690   0D0D F9            leave
1691   0D0E 09            ret
1692   0D0F             
1693   0D0F             free:
1694   0D0F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1695   0D12             ;; return heap_top = heap_top - bytes; 
1696   0D12 3B 22 12      mov d, _heap_top ; $heap_top
1697   0D15 DA            push d
1698   0D16 3B 22 12      mov d, _heap_top ; $heap_top
1699   0D19 2A            mov b, [d]
1700   0D1A             ; START TERMS
1701   0D1A D7            push a
1702   0D1B 11            mov a, b
1703   0D1C FA 05 00      lea d, [bp + 5] ; $bytes
1704   0D1F 2A            mov b, [d]
1705   0D20 60            sub a, b
1706   0D21 27            mov b, a
1707   0D22 E4            pop a
1708   0D23             ; END TERMS
1709   0D23 E7            pop d
1710   0D24 FD 43         mov [d], b
1711   0D26 F9            leave
1712   0D27 09            ret
1713   0D28             
1714   0D28             exit:
1715   0D28 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1716   0D2B             
1717   0D2B             ; --- BEGIN INLINE ASM BLOCK
1718   0D2B 05 0B         syscall sys_terminate_proc
1719   0D2D             ; --- END INLINE ASM BLOCK
1720   0D2D             
1721   0D2D F9            leave
1722   0D2E 09            ret
1723   0D2F             
1724   0D2F             load_hex:
1725   0D2F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1726   0D32             ; $temp 
1727   0D32 52 02 00      sub sp, 2
1728   0D35             ;; temp = alloc(32768); 
1729   0D35 FA FF FF      lea d, [bp + -1] ; $temp
1730   0D38 DA            push d
1731   0D39 26 00 80      mov b, $8000
1732   0D3C FD AB         swp b
1733   0D3E D8            push b
1734   0D3F 07 E9 0C      call alloc
1735   0D42 51 02 00      add sp, 2
1736   0D45 E7            pop d
1737   0D46 FD 43         mov [d], b
1738   0D48             
1739   0D48             ; --- BEGIN INLINE ASM BLOCK
1740   0D48               
1741   0D48               
1742   0D48               
1743   0D48               
1744   0D48               
1745   0D48             _load_hex:
1746   0D48 D7            push a
1747   0D49 D8            push b
1748   0D4A DA            push d
1749   0D4B E2            push si
1750   0D4C E3            push di
1751   0D4D 52 00 80      sub sp, $8000      
1752   0D50 38 00 00      mov c, 0
1753   0D53 48            mov a, sp
1754   0D54 77            inc a
1755   0D55 3C            mov d, a          
1756   0D56 07 EA 0E      call _gets        
1757   0D59 4D            mov si, a
1758   0D5A             __load_hex_loop:
1759   0D5A F6            lodsb             
1760   0D5B B9 00         cmp al, 0         
1761   0D5D C6 6B 0D      jz __load_hex_ret
1762   0D60 36            mov bh, al
1763   0D61 F6            lodsb
1764   0D62 2F            mov bl, al
1765   0D63 07 A0 0E      call _atoi        
1766   0D66 F7            stosb             
1767   0D67 78            inc c
1768   0D68 0A 5A 0D      jmp __load_hex_loop
1769   0D6B             __load_hex_ret:
1770   0D6B 51 00 80      add sp, $8000
1771   0D6E F0            pop di
1772   0D6F EF            pop si
1773   0D70 E7            pop d
1774   0D71 E5            pop b
1775   0D72 E4            pop a
1776   0D73             ; --- END INLINE ASM BLOCK
1777   0D73             
1778   0D73 F9            leave
1779   0D74 09            ret
1780   0D75             
1781   0D75             getparam:
1782   0D75 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1783   0D78             ; $data 
1784   0D78 52 01 00      sub sp, 1
1785   0D7B             
1786   0D7B             ; --- BEGIN INLINE ASM BLOCK
1787   0D7B 19 04         mov al, 4
1788   0D7D FA 05 00      lea d, [bp + 5] ; $address
1789   0D80 FD 2A         mov d, [d]
1790   0D82 05 0C         syscall sys_system
1791   0D84 FA 00 00      lea d, [bp + 0] ; $data
1792   0D87 FD 3E         mov [d], bl
1793   0D89             ; --- END INLINE ASM BLOCK
1794   0D89             
1795   0D89             ;; return data; 
1796   0D89 FA 00 00      lea d, [bp + 0] ; $data
1797   0D8C 32            mov bl, [d]
1798   0D8D A7 00         mov bh, 0
1799   0D8F F9            leave
1800   0D90 09            ret
1801   0D91             
1802   0D91             clear:
1803   0D91 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1804   0D94             ;; print("\033[2J\033[H"); 
1805   0D94 26 18 12      mov b, __s2 ; "\033[2J\033[H"
1806   0D97 FD AB         swp b
1807   0D99 D8            push b
1808   0D9A 07 AE 0C      call print
1809   0D9D 51 02 00      add sp, 2
1810   0DA0 F9            leave
1811   0DA1 09            ret
1812   0DA2             
1813   0DA2             printun:
1814   0DA2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1815   0DA5             ;; print(prompt); 
1816   0DA5 FA 05 00      lea d, [bp + 5] ; $prompt
1817   0DA8 2A            mov b, [d]
1818   0DA9 FD AB         swp b
1819   0DAB D8            push b
1820   0DAC 07 AE 0C      call print
1821   0DAF 51 02 00      add sp, 2
1822   0DB2             ;; printu(n); 
1823   0DB2 FA 07 00      lea d, [bp + 7] ; $n
1824   0DB5 2A            mov b, [d]
1825   0DB6 FD AB         swp b
1826   0DB8 D8            push b
1827   0DB9 07 7A 0B      call printu
1828   0DBC 51 02 00      add sp, 2
1829   0DBF             ;; print("\n"); 
1830   0DBF 26 20 12      mov b, __s3 ; "\n"
1831   0DC2 FD AB         swp b
1832   0DC4 D8            push b
1833   0DC5 07 AE 0C      call print
1834   0DC8 51 02 00      add sp, 2
1835   0DCB F9            leave
1836   0DCC 09            ret
1837   0DCD             
1838   0DCD             printsn:
1839   0DCD F8 00 00      enter 0 ; (push bp; mov bp, sp)
1840   0DD0             ;; print(prompt); 
1841   0DD0 FA 05 00      lea d, [bp + 5] ; $prompt
1842   0DD3 2A            mov b, [d]
1843   0DD4 FD AB         swp b
1844   0DD6 D8            push b
1845   0DD7 07 AE 0C      call print
1846   0DDA 51 02 00      add sp, 2
1847   0DDD             ;; prints(n); 
1848   0DDD FA 07 00      lea d, [bp + 7] ; $n
1849   0DE0 2A            mov b, [d]
1850   0DE1 FD AB         swp b
1851   0DE3 D8            push b
1852   0DE4 07 85 0A      call prints
1853   0DE7 51 02 00      add sp, 2
1854   0DEA             ;; print("\n"); 
1855   0DEA 26 20 12      mov b, __s3 ; "\n"
1856   0DED FD AB         swp b
1857   0DEF D8            push b
1858   0DF0 07 AE 0C      call print
1859   0DF3 51 02 00      add sp, 2
1860   0DF6 F9            leave
1861   0DF7 09            ret
1862   0DF8             
1863   0DF8             include_stdio_asm:
1864   0DF8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1865   0DFB             
1866   0DFB             ; --- BEGIN INLINE ASM BLOCK
1867   0DFB             .include "lib/stdio.asm"
0001+  0DFB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0DFB             ; stdio.s
0003+  0DFB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0DFB             .include "lib/string.asm"
0001++ 0DFB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0DFB             ; string.s
0003++ 0DFB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0DFB             
0005++ 0DFB             
0006++ 0DFB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0DFB             ; _strrev
0008++ 0DFB             ; reverse a string
0009++ 0DFB             ; D = string address
0010++ 0DFB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0DFB             ; 01234
0012++ 0DFB             _strrev:
0013++ 0DFB 4B          	pusha
0014++ 0DFC 07 42 0E    	call _strlen	; length in C
0015++ 0DFF 12          	mov a, c
0016++ 0E00 AF 01 00    	cmp a, 1
0017++ 0E03 D0 1D 0E    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 0E06 7D          	dec a
0019++ 0E07 FD 4E       	mov si, d	; beginning of string
0020++ 0E09 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0E0B 59          	add d, a	; end of string
0022++ 0E0C 12          	mov a, c
0023++ 0E0D FD 9B       	shr a		; divide by 2
0024++ 0E0F 39          	mov c, a	; C now counts the steps
0025++ 0E10             _strrev_L0:
0026++ 0E10 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0E11 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0E12 3E          	mov [d], al	; store left char into right side
0029++ 0E13 1B          	mov al, bl
0030++ 0E14 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0E15 7E          	dec c
0032++ 0E16 7F          	dec d
0033++ 0E17 C2 00 00    	cmp c, 0
0034++ 0E1A C7 10 0E    	jne _strrev_L0
0035++ 0E1D             _strrev_end:
0036++ 0E1D 4C          	popa
0037++ 0E1E 09          	ret
0038++ 0E1F             	
0039++ 0E1F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0E1F             ; _strchr
0041++ 0E1F             ; search string in D for char in AL
0042++ 0E1F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0E1F             _strchr:
0044++ 0E1F             _strchr_L0:
0045++ 0E1F 32          	mov bl, [d]
0046++ 0E20 C1 00       	cmp bl, 0
0047++ 0E22 C6 2D 0E    	je _strchr_end
0048++ 0E25 BA          	cmp al, bl
0049++ 0E26 C6 2D 0E    	je _strchr_end
0050++ 0E29 79          	inc d
0051++ 0E2A 0A 1F 0E    	jmp _strchr_L0
0052++ 0E2D             _strchr_end:
0053++ 0E2D 1B          	mov al, bl
0054++ 0E2E 09          	ret
0055++ 0E2F             
0056++ 0E2F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0E2F             ; _strstr
0058++ 0E2F             ; find sub-string
0059++ 0E2F             ; str1 in SI
0060++ 0E2F             ; str2 in DI
0061++ 0E2F             ; SI points to end of source string
0062++ 0E2F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0E2F             _strstr:
0064++ 0E2F DB          	push al
0065++ 0E30 DA          	push d
0066++ 0E31 E3          	push di
0067++ 0E32             _strstr_loop:
0068++ 0E32 F3          	cmpsb					; compare a byte of the strings
0069++ 0E33 C7 3E 0E    	jne _strstr_ret
0070++ 0E36 FC 00 00    	lea d, [di + 0]
0071++ 0E39 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0E3B C7 32 0E    	jne _strstr_loop				; equal chars but not at end
0073++ 0E3E             _strstr_ret:
0074++ 0E3E F0          	pop di
0075++ 0E3F E7          	pop d
0076++ 0E40 E8          	pop al
0077++ 0E41 09          	ret
0078++ 0E42             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0E42             ; length of null terminated string
0080++ 0E42             ; result in C
0081++ 0E42             ; pointer in D
0082++ 0E42             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0E42             _strlen:
0084++ 0E42 DA          	push d
0085++ 0E43 38 00 00    	mov c, 0
0086++ 0E46             _strlen_L1:
0087++ 0E46 BD 00       	cmp byte [d], 0
0088++ 0E48 C6 50 0E    	je _strlen_ret
0089++ 0E4B 79          	inc d
0090++ 0E4C 78          	inc c
0091++ 0E4D 0A 46 0E    	jmp _strlen_L1
0092++ 0E50             _strlen_ret:
0093++ 0E50 E7          	pop d
0094++ 0E51 09          	ret
0095++ 0E52             
0096++ 0E52             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0E52             ; STRCMP
0098++ 0E52             ; compare two strings
0099++ 0E52             ; str1 in SI
0100++ 0E52             ; str2 in DI
0101++ 0E52             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0E52             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0E52             _strcmp:
0104++ 0E52 DB          	push al
0105++ 0E53 DA          	push d
0106++ 0E54 E3          	push di
0107++ 0E55 E2          	push si
0108++ 0E56             _strcmp_loop:
0109++ 0E56 F3          	cmpsb					; compare a byte of the strings
0110++ 0E57 C7 62 0E    	jne _strcmp_ret
0111++ 0E5A FB FF FF    	lea d, [si +- 1]
0112++ 0E5D BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0E5F C7 56 0E    	jne _strcmp_loop				; equal chars but not at end
0114++ 0E62             _strcmp_ret:
0115++ 0E62 EF          	pop si
0116++ 0E63 F0          	pop di
0117++ 0E64 E7          	pop d
0118++ 0E65 E8          	pop al
0119++ 0E66 09          	ret
0120++ 0E67             
0121++ 0E67             
0122++ 0E67             ; STRCPY
0123++ 0E67             ; copy null terminated string from SI to DI
0124++ 0E67             ; source in SI
0125++ 0E67             ; destination in DI
0126++ 0E67             _strcpy:
0127++ 0E67 E2          	push si
0128++ 0E68 E3          	push di
0129++ 0E69 DB          	push al
0130++ 0E6A             _strcpy_L1:
0131++ 0E6A F6          	lodsb
0132++ 0E6B F7          	stosb
0133++ 0E6C B9 00       	cmp al, 0
0134++ 0E6E C7 6A 0E    	jne _strcpy_L1
0135++ 0E71             _strcpy_end:
0136++ 0E71 E8          	pop al
0137++ 0E72 F0          	pop di
0138++ 0E73 EF          	pop si
0139++ 0E74 09          	ret
0140++ 0E75             
0141++ 0E75             ; STRCAT
0142++ 0E75             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0E75             ; source in SI
0144++ 0E75             ; destination in DI
0145++ 0E75             _strcat:
0146++ 0E75 E2          	push si
0147++ 0E76 E3          	push di
0148++ 0E77 D7          	push a
0149++ 0E78 DA          	push d
0150++ 0E79 50          	mov a, di
0151++ 0E7A 3C          	mov d, a
0152++ 0E7B             _strcat_goto_end_L1:
0153++ 0E7B BD 00       	cmp byte[d], 0
0154++ 0E7D C6 84 0E    	je _strcat_start
0155++ 0E80 79          	inc d
0156++ 0E81 0A 7B 0E    	jmp _strcat_goto_end_L1
0157++ 0E84             _strcat_start:
0158++ 0E84 FD 50       	mov di, d
0159++ 0E86             _strcat_L1:
0160++ 0E86 F6          	lodsb
0161++ 0E87 F7          	stosb
0162++ 0E88 B9 00       	cmp al, 0
0163++ 0E8A C7 86 0E    	jne _strcat_L1
0164++ 0E8D             _strcat_end:
0165++ 0E8D E7          	pop d
0166++ 0E8E E4          	pop a
0167++ 0E8F F0          	pop di
0168++ 0E90 EF          	pop si
0169++ 0E91 09          	ret
0170++ 0E92             
0171++ 0E92             
0005+  0E92             
0006+  0E92             
0007+  0E92             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  0E92             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  0E92             ; ASCII in BL
0010+  0E92             ; result in AL
0011+  0E92             ; ascii for F = 0100 0110
0012+  0E92             ; ascii for 9 = 0011 1001
0013+  0E92             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  0E92             hex_ascii_encode:
0015+  0E92 1B            mov al, bl
0016+  0E93 93 40         test al, $40        ; test if letter or number
0017+  0E95 C7 9B 0E      jnz hex_letter
0018+  0E98 87 0F         and al, $0F        ; get number
0019+  0E9A 09            ret
0020+  0E9B             hex_letter:
0021+  0E9B 87 0F         and al, $0F        ; get letter
0022+  0E9D 6A 09         add al, 9
0023+  0E9F 09            ret
0024+  0EA0             
0025+  0EA0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0EA0             ; ATOI
0027+  0EA0             ; 2 letter hex string in B
0028+  0EA0             ; 8bit integer returned in AL
0029+  0EA0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  0EA0             _atoi:
0031+  0EA0 D8            push b
0032+  0EA1 07 92 0E      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  0EA4 30            mov bl, bh
0034+  0EA5 DB            push al          ; save a
0035+  0EA6 07 92 0E      call hex_ascii_encode
0036+  0EA9 EA            pop bl  
0037+  0EAA FD 9E 04      shl al, 4
0038+  0EAD 8C            or al, bl
0039+  0EAE E5            pop b
0040+  0EAF 09            ret  
0041+  0EB0             
0042+  0EB0             
0043+  0EB0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  0EB0             ; scanf
0045+  0EB0             ; no need for explanations!
0046+  0EB0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  0EB0             scanf:
0048+  0EB0 09            ret
0049+  0EB1             
0050+  0EB1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0EB1             ; ITOA
0052+  0EB1             ; 8bit value in BL
0053+  0EB1             ; 2 byte ASCII result in A
0054+  0EB1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0EB1             _itoa:
0056+  0EB1 DA            push d
0057+  0EB2 D8            push b
0058+  0EB3 A7 00         mov bh, 0
0059+  0EB5 FD A4 04      shr bl, 4  
0060+  0EB8 74            mov d, b
0061+  0EB9 1F 61 11      mov al, [d + s_hex_digits]
0062+  0EBC 23            mov ah, al
0063+  0EBD               
0064+  0EBD E5            pop b
0065+  0EBE D8            push b
0066+  0EBF A7 00         mov bh, 0
0067+  0EC1 FD 87 0F      and bl, $0F
0068+  0EC4 74            mov d, b
0069+  0EC5 1F 61 11      mov al, [d + s_hex_digits]
0070+  0EC8 E5            pop b
0071+  0EC9 E7            pop d
0072+  0ECA 09            ret
0073+  0ECB             
0074+  0ECB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  0ECB             ; HEX STRING TO BINARY
0076+  0ECB             ; di = destination address
0077+  0ECB             ; si = source
0078+  0ECB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  0ECB             _hex_to_int:
0080+  0ECB             _hex_to_int_L1:
0081+  0ECB F6            lodsb          ; load from [SI] to AL
0082+  0ECC B9 00         cmp al, 0        ; check if ASCII 0
0083+  0ECE C6 DB 0E      jz _hex_to_int_ret
0084+  0ED1 36            mov bh, al
0085+  0ED2 F6            lodsb
0086+  0ED3 2F            mov bl, al
0087+  0ED4 07 A0 0E      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  0ED7 F7            stosb          ; store AL to [DI]
0089+  0ED8 0A CB 0E      jmp _hex_to_int_L1
0090+  0EDB             _hex_to_int_ret:
0091+  0EDB 09            ret    
0092+  0EDC             
0093+  0EDC             
0094+  0EDC             
0095+  0EDC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  0EDC             ; GETCHAR
0097+  0EDC             ; char in ah
0098+  0EDC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  0EDC             getch:
0100+  0EDC DB            push al
0101+  0EDD             getch_retry:
0102+  0EDD 19 01         mov al, 1
0103+  0EDF 05 03         syscall sys_io      ; receive in AH
0104+  0EE1 E8            pop al
0105+  0EE2 09            ret
0106+  0EE3             
0107+  0EE3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  0EE3             ; PUTCHAR
0109+  0EE3             ; char in ah
0110+  0EE3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0EE3             _putchar:
0112+  0EE3 D7            push a
0113+  0EE4 19 00         mov al, 0
0114+  0EE6 05 03         syscall sys_io      ; char in AH
0115+  0EE8 E4            pop a
0116+  0EE9 09            ret
0117+  0EEA             
0118+  0EEA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  0EEA             ;; INPUT A STRING
0120+  0EEA             ;; terminates with null
0121+  0EEA             ;; pointer in D
0122+  0EEA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  0EEA             _gets:
0124+  0EEA D7            push a
0125+  0EEB DA            push d
0126+  0EEC             _gets_loop:
0127+  0EEC 19 01         mov al, 1
0128+  0EEE 05 03         syscall sys_io      ; receive in AH
0129+  0EF0 B9 00         cmp al, 0        ; check error code (AL)
0130+  0EF2 C6 EC 0E      je _gets_loop      ; if no char received, retry
0131+  0EF5             
0132+  0EF5 76 1B         cmp ah, 27
0133+  0EF7 C6 18 0F      je _gets_ansi_esc
0134+  0EFA 76 0A         cmp ah, $0A        ; LF
0135+  0EFC C6 83 0F      je _gets_end
0136+  0EFF 76 0D         cmp ah, $0D        ; CR
0137+  0F01 C6 83 0F      je _gets_end
0138+  0F04 76 5C         cmp ah, $5C        ; '\\'
0139+  0F06 C6 44 0F      je _gets_escape
0140+  0F09               
0141+  0F09 76 08         cmp ah, $08      ; check for backspace
0142+  0F0B C6 14 0F      je _gets_backspace
0143+  0F0E             
0144+  0F0E 1A            mov al, ah
0145+  0F0F 3E            mov [d], al
0146+  0F10 79            inc d
0147+  0F11 0A EC 0E      jmp _gets_loop
0148+  0F14             _gets_backspace:
0149+  0F14 7F            dec d
0150+  0F15 0A EC 0E      jmp _gets_loop
0151+  0F18             _gets_ansi_esc:
0152+  0F18 19 01         mov al, 1
0153+  0F1A 05 03         syscall sys_io        ; receive in AH without echo
0154+  0F1C B9 00         cmp al, 0          ; check error code (AL)
0155+  0F1E C6 18 0F      je _gets_ansi_esc    ; if no char received, retry
0156+  0F21 76 5B         cmp ah, '['
0157+  0F23 C7 EC 0E      jne _gets_loop
0158+  0F26             _gets_ansi_esc_2:
0159+  0F26 19 01         mov al, 1
0160+  0F28 05 03         syscall sys_io          ; receive in AH without echo
0161+  0F2A B9 00         cmp al, 0            ; check error code (AL)
0162+  0F2C C6 26 0F      je _gets_ansi_esc_2  ; if no char received, retry
0163+  0F2F 76 44         cmp ah, 'D'
0164+  0F31 C6 3C 0F      je _gets_left_arrow
0165+  0F34 76 43         cmp ah, 'C'
0166+  0F36 C6 40 0F      je _gets_right_arrow
0167+  0F39 0A EC 0E      jmp _gets_loop
0168+  0F3C             _gets_left_arrow:
0169+  0F3C 7F            dec d
0170+  0F3D 0A EC 0E      jmp _gets_loop
0171+  0F40             _gets_right_arrow:
0172+  0F40 79            inc d
0173+  0F41 0A EC 0E      jmp _gets_loop
0174+  0F44             _gets_escape:
0175+  0F44 19 01         mov al, 1
0176+  0F46 05 03         syscall sys_io      ; receive in AH
0177+  0F48 B9 00         cmp al, 0        ; check error code (AL)
0178+  0F4A C6 44 0F      je _gets_escape      ; if no char received, retry
0179+  0F4D 76 6E         cmp ah, 'n'
0180+  0F4F C6 6E 0F      je _gets_LF
0181+  0F52 76 72         cmp ah, 'r'
0182+  0F54 C6 75 0F      je _gets_CR
0183+  0F57 76 30         cmp ah, '0'
0184+  0F59 C6 7C 0F      je _gets_NULL
0185+  0F5C 76 5C         cmp ah, $5C  ; '\'
0186+  0F5E C6 67 0F      je _gets_slash
0187+  0F61 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0188+  0F62 3E            mov [d], al
0189+  0F63 79            inc d
0190+  0F64 0A EC 0E      jmp _gets_loop
0191+  0F67             _gets_slash:
0192+  0F67 19 5C         mov al, $5C
0193+  0F69 3E            mov [d], al
0194+  0F6A 79            inc d
0195+  0F6B 0A EC 0E      jmp _gets_loop
0196+  0F6E             _gets_LF:
0197+  0F6E 19 0A         mov al, $0A
0198+  0F70 3E            mov [d], al
0199+  0F71 79            inc d
0200+  0F72 0A EC 0E      jmp _gets_loop
0201+  0F75             _gets_CR:
0202+  0F75 19 0D         mov al, $0D
0203+  0F77 3E            mov [d], al
0204+  0F78 79            inc d
0205+  0F79 0A EC 0E      jmp _gets_loop
0206+  0F7C             _gets_NULL:
0207+  0F7C 19 00         mov al, $00
0208+  0F7E 3E            mov [d], al
0209+  0F7F 79            inc d
0210+  0F80 0A EC 0E      jmp _gets_loop
0211+  0F83             _gets_end:
0212+  0F83 19 00         mov al, 0
0213+  0F85 3E            mov [d], al        ; terminate string
0214+  0F86 E7            pop d
0215+  0F87 E4            pop a
0216+  0F88 09            ret
0217+  0F89             
0218+  0F89             
0219+  0F89             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0220+  0F89             ;; INPUT TEXT
0221+  0F89             ;; terminated with CTRL+D
0222+  0F89             ;; pointer in D
0223+  0F89             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0224+  0F89             _gettxt:
0225+  0F89 D7            push a
0226+  0F8A DA            push d
0227+  0F8B             _gettxt_loop:
0228+  0F8B 19 01         mov al, 1
0229+  0F8D 05 03         syscall sys_io      ; receive in AH
0230+  0F8F B9 00         cmp al, 0        ; check error code (AL)
0231+  0F91 C6 8B 0F      je _gettxt_loop    ; if no char received, retry
0232+  0F94 76 04         cmp ah, 4      ; EOT
0233+  0F96 C6 D4 0F      je _gettxt_end
0234+  0F99 76 08         cmp ah, $08      ; check for backspace
0235+  0F9B C6 D0 0F      je _gettxt_backspace
0236+  0F9E 76 5C         cmp ah, $5C        ; '\'
0237+  0FA0 C6 A9 0F      je _gettxt_escape
0238+  0FA3 1A            mov al, ah
0239+  0FA4 3E            mov [d], al
0240+  0FA5 79            inc d
0241+  0FA6 0A 8B 0F      jmp _gettxt_loop
0242+  0FA9             _gettxt_escape:
0243+  0FA9 19 01         mov al, 1
0244+  0FAB 05 03         syscall sys_io      ; receive in AH
0245+  0FAD B9 00         cmp al, 0        ; check error code (AL)
0246+  0FAF C6 A9 0F      je _gettxt_escape    ; if no char received, retry
0247+  0FB2 76 6E         cmp ah, 'n'
0248+  0FB4 C6 C2 0F      je _gettxt_LF
0249+  0FB7 76 72         cmp ah, 'r'
0250+  0FB9 C6 C9 0F      je _gettxt_CR
0251+  0FBC 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0252+  0FBD 3E            mov [d], al
0253+  0FBE 79            inc d
0254+  0FBF 0A 8B 0F      jmp _gettxt_loop
0255+  0FC2             _gettxt_LF:
0256+  0FC2 19 0A         mov al, $0A
0257+  0FC4 3E            mov [d], al
0258+  0FC5 79            inc d
0259+  0FC6 0A 8B 0F      jmp _gettxt_loop
0260+  0FC9             _gettxt_CR:
0261+  0FC9 19 0D         mov al, $0D
0262+  0FCB 3E            mov [d], al
0263+  0FCC 79            inc d
0264+  0FCD 0A 8B 0F      jmp _gettxt_loop
0265+  0FD0             _gettxt_backspace:
0266+  0FD0 7F            dec d
0267+  0FD1 0A 8B 0F      jmp _gettxt_loop
0268+  0FD4             _gettxt_end:
0269+  0FD4 19 00         mov al, 0
0270+  0FD6 3E            mov [d], al        ; terminate string
0271+  0FD7 E7            pop d
0272+  0FD8 E4            pop a
0273+  0FD9 09            ret
0274+  0FDA             
0275+  0FDA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  0FDA             ; PRINT NEW LINE
0277+  0FDA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0278+  0FDA             printnl:
0279+  0FDA D7            push a
0280+  0FDB 10 00 0A      mov a, $0A00
0281+  0FDE 05 03         syscall sys_io
0282+  0FE0 10 00 0D      mov a, $0D00
0283+  0FE3 05 03         syscall sys_io
0284+  0FE5 E4            pop a
0285+  0FE6 09            ret
0286+  0FE7             
0287+  0FE7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  0FE7             ; _strtoint
0289+  0FE7             ; 4 digit hex string number in d
0290+  0FE7             ; integer returned in A
0291+  0FE7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0292+  0FE7             _strtointx:
0293+  0FE7 D8            push b
0294+  0FE8 32            mov bl, [d]
0295+  0FE9 37            mov bh, bl
0296+  0FEA 33 01 00      mov bl, [d + 1]
0297+  0FED 07 A0 0E      call _atoi        ; convert to int in AL
0298+  0FF0 23            mov ah, al        ; move to AH
0299+  0FF1 33 02 00      mov bl, [d + 2]
0300+  0FF4 37            mov bh, bl
0301+  0FF5 33 03 00      mov bl, [d + 3]
0302+  0FF8 07 A0 0E      call _atoi        ; convert to int in AL
0303+  0FFB E5            pop b
0304+  0FFC 09            ret
0305+  0FFD             
0306+  0FFD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0307+  0FFD             ; _strtoint
0308+  0FFD             ; 5 digit base10 string number in d
0309+  0FFD             ; integer returned in A
0310+  0FFD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0311+  0FFD             _strtoint:
0312+  0FFD E2            push si
0313+  0FFE D8            push b
0314+  0FFF D9            push c
0315+  1000 DA            push d
0316+  1001 07 42 0E      call _strlen      ; get string length in C
0317+  1004 7E            dec c
0318+  1005 FD 4E         mov si, d
0319+  1007 12            mov a, c
0320+  1008 FD 99         shl a
0321+  100A 3B 79 11      mov d, table_power
0322+  100D 59            add d, a
0323+  100E 38 00 00      mov c, 0
0324+  1011             _strtoint_L0:
0325+  1011 F6            lodsb      ; load ASCII to al
0326+  1012 B9 00         cmp al, 0
0327+  1014 C6 27 10      je _strtoint_end
0328+  1017 6F 30         sub al, $30    ; make into integer
0329+  1019 22 00         mov ah, 0
0330+  101B 2A            mov b, [d]
0331+  101C AC            mul a, b      ; result in B since it fits in 16bits
0332+  101D 11            mov a, b
0333+  101E 28            mov b, c
0334+  101F 54            add a, b
0335+  1020 39            mov c, a
0336+  1021 63 02 00      sub d, 2
0337+  1024 0A 11 10      jmp _strtoint_L0
0338+  1027             _strtoint_end:
0339+  1027 12            mov a, c
0340+  1028 E7            pop d
0341+  1029 E6            pop c
0342+  102A E5            pop b
0343+  102B EF            pop si
0344+  102C 09            ret
0345+  102D             
0346+  102D             
0347+  102D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0348+  102D             ; PRINT NULL TERMINATED STRING
0349+  102D             ; pointer in D
0350+  102D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0351+  102D             _puts:
0352+  102D D7            push a
0353+  102E DA            push d
0354+  102F             _puts_L1:
0355+  102F 1E            mov al, [d]
0356+  1030 B9 00         cmp al, 0
0357+  1032 C6 3E 10      jz _puts_END
0358+  1035 23            mov ah, al
0359+  1036 19 00         mov al, 0
0360+  1038 05 03         syscall sys_io
0361+  103A 79            inc d
0362+  103B 0A 2F 10      jmp _puts_L1
0363+  103E             _puts_END:
0364+  103E E7            pop d
0365+  103F E4            pop a
0366+  1040 09            ret
0367+  1041             
0368+  1041             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0369+  1041             ; PRINT N SIZE STRING
0370+  1041             ; pointer in D
0371+  1041             ; size in C
0372+  1041             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0373+  1041             _putsn:
0374+  1041 DB            push al
0375+  1042 DA            push d
0376+  1043 D9            push c
0377+  1044             _putsn_L0:
0378+  1044 1E            mov al, [d]
0379+  1045 23            mov ah, al
0380+  1046 19 00         mov al, 0
0381+  1048 05 03         syscall sys_io
0382+  104A 79            inc d
0383+  104B 7E            dec c  
0384+  104C C2 00 00      cmp c, 0
0385+  104F C7 44 10      jne _putsn_L0
0386+  1052             _putsn_end:
0387+  1052 E6            pop c
0388+  1053 E7            pop d
0389+  1054 E8            pop al
0390+  1055 09            ret
0391+  1056             
0392+  1056             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0393+  1056             ; print 16bit decimal number
0394+  1056             ; input number in A
0395+  1056             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0396+  1056             print_u16d:
0397+  1056 D7            push a
0398+  1057 D8            push b
0399+  1058 26 10 27      mov b, 10000
0400+  105B AE            div a, b      ; get 10000's coeff.
0401+  105C 07 7E 10      call print_number
0402+  105F 11            mov a, b
0403+  1060 26 E8 03      mov b, 1000
0404+  1063 AE            div a, b      ; get 1000's coeff.
0405+  1064 07 7E 10      call print_number
0406+  1067 11            mov a, b
0407+  1068 26 64 00      mov b, 100
0408+  106B AE            div a, b
0409+  106C 07 7E 10      call print_number
0410+  106F 11            mov a, b
0411+  1070 26 0A 00      mov b, 10
0412+  1073 AE            div a, b
0413+  1074 07 7E 10      call print_number
0414+  1077 1B            mov al, bl      ; 1's coeff in bl
0415+  1078 07 7E 10      call print_number
0416+  107B E5            pop b
0417+  107C E4            pop a
0418+  107D 09            ret
0419+  107E             
0420+  107E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0421+  107E             ; print AL
0422+  107E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0423+  107E             print_number:
0424+  107E 6A 30         add al, $30
0425+  1080 23            mov ah, al
0426+  1081 07 E3 0E      call _putchar
0427+  1084 09            ret
0428+  1085             
0429+  1085             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0430+  1085             ; PRINT 16BIT HEX INTEGER
0431+  1085             ; integer value in reg B
0432+  1085             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  1085             print_u16x:
0434+  1085 D7            push a
0435+  1086 D8            push b
0436+  1087 DD            push bl
0437+  1088 30            mov bl, bh
0438+  1089 07 B1 0E      call _itoa        ; convert bh to char in A
0439+  108C 2F            mov bl, al        ; save al
0440+  108D 19 00         mov al, 0
0441+  108F 05 03         syscall sys_io        ; display AH
0442+  1091 24            mov ah, bl        ; retrieve al
0443+  1092 19 00         mov al, 0
0444+  1094 05 03         syscall sys_io        ; display AL
0445+  1096             
0446+  1096 EA            pop bl
0447+  1097 07 B1 0E      call _itoa        ; convert bh to char in A
0448+  109A 2F            mov bl, al        ; save al
0449+  109B 19 00         mov al, 0
0450+  109D 05 03         syscall sys_io        ; display AH
0451+  109F 24            mov ah, bl        ; retrieve al
0452+  10A0 19 00         mov al, 0
0453+  10A2 05 03         syscall sys_io        ; display AL
0454+  10A4             
0455+  10A4 E5            pop b
0456+  10A5 E4            pop a
0457+  10A6 09            ret
0458+  10A7             
0459+  10A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0460+  10A7             ; INPUT 16BIT HEX INTEGER
0461+  10A7             ; read 16bit integer into A
0462+  10A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0463+  10A7             scan_u16x:
0464+  10A7 F8 10 00      enter 16
0465+  10AA D8            push b
0466+  10AB DA            push d
0467+  10AC             
0468+  10AC FA F1 FF      lea d, [bp + -15]
0469+  10AF 07 EA 0E      call _gets        ; get number
0470+  10B2             
0471+  10B2 32            mov bl, [d]
0472+  10B3 37            mov bh, bl
0473+  10B4 33 01 00      mov bl, [d + 1]
0474+  10B7 07 A0 0E      call _atoi        ; convert to int in AL
0475+  10BA 23            mov ah, al        ; move to AH
0476+  10BB             
0477+  10BB 33 02 00      mov bl, [d + 2]
0478+  10BE 37            mov bh, bl
0479+  10BF 33 03 00      mov bl, [d + 3]
0480+  10C2 07 A0 0E      call _atoi        ; convert to int in AL
0481+  10C5             
0482+  10C5 E7            pop d
0483+  10C6 E5            pop b
0484+  10C7 F9            leave
0485+  10C8 09            ret
0486+  10C9             
0487+  10C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0488+  10C9             ; PRINT 8bit HEX INTEGER
0489+  10C9             ; integer value in reg bl
0490+  10C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0491+  10C9             print_u8x:
0492+  10C9 D7            push a
0493+  10CA DD            push bl
0494+  10CB             
0495+  10CB 07 B1 0E      call _itoa        ; convert bl to char in A
0496+  10CE 2F            mov bl, al        ; save al
0497+  10CF 19 00         mov al, 0
0498+  10D1 05 03         syscall sys_io        ; display AH
0499+  10D3 24            mov ah, bl        ; retrieve al
0500+  10D4 19 00         mov al, 0
0501+  10D6 05 03         syscall sys_io        ; display AL
0502+  10D8             
0503+  10D8 EA            pop bl
0504+  10D9 E4            pop a
0505+  10DA 09            ret
0506+  10DB             
0507+  10DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0508+  10DB             ; print 8bit decimal unsigned number
0509+  10DB             ; input number in AL
0510+  10DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0511+  10DB             print_u8d:
0512+  10DB D7            push a
0513+  10DC D8            push b
0514+  10DD             
0515+  10DD 22 00         mov ah, 0
0516+  10DF 26 64 00      mov b, 100
0517+  10E2 AE            div a, b
0518+  10E3 D8            push b      ; save remainder
0519+  10E4 B9 00         cmp al, 0
0520+  10E6 C6 F0 10      je skip100
0521+  10E9 6A 30         add al, $30
0522+  10EB 23            mov ah, al
0523+  10EC 19 00         mov al, 0
0524+  10EE 05 03         syscall sys_io  ; print coeff
0525+  10F0             skip100:
0526+  10F0 E4            pop a
0527+  10F1 22 00         mov ah, 0
0528+  10F3 26 0A 00      mov b, 10
0529+  10F6 AE            div a, b
0530+  10F7 D8            push b      ; save remainder
0531+  10F8 B9 00         cmp al, 0
0532+  10FA C6 04 11      je skip10
0533+  10FD 6A 30         add al, $30
0534+  10FF 23            mov ah, al
0535+  1100 19 00         mov al, 0
0536+  1102 05 03         syscall sys_io  ; print coeff
0537+  1104             skip10:
0538+  1104 E4            pop a
0539+  1105 1B            mov al, bl
0540+  1106 6A 30         add al, $30
0541+  1108 23            mov ah, al
0542+  1109 19 00         mov al, 0
0543+  110B 05 03         syscall sys_io  ; print coeff
0544+  110D E5            pop b
0545+  110E E4            pop a
0546+  110F 09            ret
0547+  1110             
0548+  1110             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0549+  1110             ; INPUT 8BIT HEX INTEGER
0550+  1110             ; read 8bit integer into AL
0551+  1110             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0552+  1110             scan_u8x:
0553+  1110 F8 04 00      enter 4
0554+  1113 D8            push b
0555+  1114 DA            push d
0556+  1115             
0557+  1115 FA FD FF      lea d, [bp + -3]
0558+  1118 07 EA 0E      call _gets        ; get number
0559+  111B             
0560+  111B 32            mov bl, [d]
0561+  111C 37            mov bh, bl
0562+  111D 33 01 00      mov bl, [d + 1]
0563+  1120 07 A0 0E      call _atoi        ; convert to int in AL
0564+  1123             
0565+  1123 E7            pop d
0566+  1124 E5            pop b
0567+  1125 F9            leave
0568+  1126 09            ret
0569+  1127             
0570+  1127             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  1127             ; input decimal number
0572+  1127             ; result in A
0573+  1127             ; 655'\0'
0574+  1127             ; low--------high
0575+  1127             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0576+  1127             scan_u16d:
0577+  1127 F8 08 00      enter 8
0578+  112A E2            push si
0579+  112B D8            push b
0580+  112C D9            push c
0581+  112D DA            push d
0582+  112E FA F9 FF      lea d, [bp +- 7]
0583+  1131 07 EA 0E      call _gets
0584+  1134 07 42 0E      call _strlen      ; get string length in C
0585+  1137 7E            dec c
0586+  1138 FD 4E         mov si, d
0587+  113A 12            mov a, c
0588+  113B FD 99         shl a
0589+  113D 3B 79 11      mov d, table_power
0590+  1140 59            add d, a
0591+  1141 38 00 00      mov c, 0
0592+  1144             mul_loop:
0593+  1144 F6            lodsb      ; load ASCII to al
0594+  1145 B9 00         cmp al, 0
0595+  1147 C6 5A 11      je mul_exit
0596+  114A 6F 30         sub al, $30    ; make into integer
0597+  114C 22 00         mov ah, 0
0598+  114E 2A            mov b, [d]
0599+  114F AC            mul a, b      ; result in B since it fits in 16bits
0600+  1150 11            mov a, b
0601+  1151 28            mov b, c
0602+  1152 54            add a, b
0603+  1153 39            mov c, a
0604+  1154 63 02 00      sub d, 2
0605+  1157 0A 44 11      jmp mul_loop
0606+  115A             mul_exit:
0607+  115A 12            mov a, c
0608+  115B E7            pop d
0609+  115C E6            pop c
0610+  115D E5            pop b
0611+  115E EF            pop si
0612+  115F F9            leave
0613+  1160 09            ret
0614+  1161             
0615+  1161             
0616+  1161 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0616+  1165 34 35 36 37 
0616+  1169 38 39 41 42 
0616+  116D 43 44 45 46 
0617+  1171 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0617+  1175 1B 5B 48 00 
0618+  1179             
0619+  1179             table_power:
0620+  1179 01 00         .dw 1
0621+  117B 0A 00         .dw 10
0622+  117D 64 00         .dw 100
0623+  117F E8 03         .dw 1000
0624+  1181 10 27         .dw 100001868   1183             ; --- END INLINE ASM BLOCK
1869   1183             
1870   1183 F9            leave
1871   1184 09            ret
1872   1185             
1873   1185             f:
1874   1185 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1875   1188             ; $aaa 
1876   1188             ; $bbb 
1877   1188             ; $ccc 
1878   1188             ; $ddd 
1879   1188 52 08 00      sub sp, 8
1880   118B             ;; aa = 11; bb = 22; cc = 33; dd = 44; 
1881   118B FA 05 00      lea d, [bp + 5] ; $aa
1882   118E DA            push d
1883   118F 26 0B 00      mov b, $b
1884   1192 E7            pop d
1885   1193 FD 43         mov [d], b
1886   1195             ;; bb = 22; cc = 33; dd = 44; 
1887   1195 FA 07 00      lea d, [bp + 7] ; $bb
1888   1198 DA            push d
1889   1199 26 16 00      mov b, $16
1890   119C E7            pop d
1891   119D FD 43         mov [d], b
1892   119F             ;; cc = 33; dd = 44; 
1893   119F FA 09 00      lea d, [bp + 9] ; $cc
1894   11A2 DA            push d
1895   11A3 26 21 00      mov b, $21
1896   11A6 E7            pop d
1897   11A7 FD 43         mov [d], b
1898   11A9             ;; dd = 44; 
1899   11A9 FA 0B 00      lea d, [bp + 11] ; $dd
1900   11AC DA            push d
1901   11AD 26 2C 00      mov b, $2c
1902   11B0 E7            pop d
1903   11B1 FD 43         mov [d], b
1904   11B3             ;; aaa = 0; bbb = 9; ccc = 8; ddd = 7; 
1905   11B3 FA FF FF      lea d, [bp + -1] ; $aaa
1906   11B6 DA            push d
1907   11B7 26 00 00      mov b, $0
1908   11BA E7            pop d
1909   11BB FD 43         mov [d], b
1910   11BD             ;; bbb = 9; ccc = 8; ddd = 7; 
1911   11BD FA FD FF      lea d, [bp + -3] ; $bbb
1912   11C0 DA            push d
1913   11C1 26 09 00      mov b, $9
1914   11C4 E7            pop d
1915   11C5 FD 43         mov [d], b
1916   11C7             ;; ccc = 8; ddd = 7; 
1917   11C7 FA FB FF      lea d, [bp + -5] ; $ccc
1918   11CA DA            push d
1919   11CB 26 08 00      mov b, $8
1920   11CE E7            pop d
1921   11CF FD 43         mov [d], b
1922   11D1             ;; ddd = 7; 
1923   11D1 FA F9 FF      lea d, [bp + -7] ; $ddd
1924   11D4 DA            push d
1925   11D5 26 07 00      mov b, $7
1926   11D8 E7            pop d
1927   11D9 FD 43         mov [d], b
1928   11DB F9            leave
1929   11DC 09            ret
1930   11DD             ; --- END TEXT BLOCK
1931   11DD             
1932   11DD             ; --- BEGIN DATA BLOCK
1933   11DD 61 3A 20 25 __s0: .db "a: %d, b: %d, c: %d, d: %d\n", 0
1933   11E1 64 2C 20 62 
1933   11E5 3A 20 25 64 
1933   11E9 2C 20 63 3A 
1933   11ED 20 25 64 2C 
1933   11F1 20 64 3A 20 
1933   11F5 25 64 0A 00 
1934   11F9 45 72 72 6F __s1: .db "Error: Unknown argument type.\n", 0
1934   11FD 72 3A 20 55 
1934   1201 6E 6B 6E 6F 
1934   1205 77 6E 20 61 
1934   1209 72 67 75 6D 
1934   120D 65 6E 74 20 
1934   1211 74 79 70 65 
1934   1215 2E 0A 00 
1935   1218 1B 5B 32 4A __s2: .db "\033[2J\033[H", 0
1935   121C 1B 5B 48 00 
1936   1220 0A 00       __s3: .db "\n", 0
1937   1222             
1938   1222 24 12       _heap_top: .dw _heap
1939   1224 00          _heap: .db 0
1940   1225             ; --- END DATA BLOCK
1941   1225             
1942   1225             .end
tasm: Number of errors = 0
