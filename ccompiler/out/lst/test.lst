0001   0000             ; --- FILENAME: test
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ;; printx16(4294967295L != 4294967294L); 
0011   0408 26 FF FF      mov b, $ffff
0012   040B 38 FF FF      mov c, $ffff
0013   040E             ; START RELATIONAL
0014   040E D7            push a
0015   040F FD D8         push g
0016   0411 11            mov a, b
0017   0412 FD 7A         mov g, c
0018   0414 26 FE FF      mov b, $fffe
0019   0417 38 FF FF      mov c, $ffff
0020   041A B0            cmp a, b
0021   041B FD 72         sneq ; !=
0022   041D D8            push b
0023   041E 12            mov a, c
0024   041F FD 27         mov b, g
0025   0421 B0            cmp a, b
0026   0422 FD 72         sneq ; !=
0027   0424 E4            pop a
0028   0425 FD A8         sor a, b
0029   0427 FD F1         pop g
0030   0429 E4            pop a
0031   042A             ; END RELATIONAL
0032   042A FD AB         swp b
0033   042C D8            push b
0034   042D 07 35 04      call printx16
0035   0430 51 02 00      add sp, 2
0036   0433 05 0B         syscall sys_terminate_proc
0037   0435             
0038   0435             printx16:
0039   0435 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0040   0438             
0041   0438             ; --- BEGIN INLINE ASM BLOCK
0042   0438 FA 05 00      lea d, [bp + 5] ; $hex
0043   043B 2A            mov b, [d]
0044   043C 07 DB 06      call print_u16x
0045   043F             ; --- END INLINE ASM BLOCK
0046   043F             
0047   043F F9            leave
0048   0440 09            ret
0049   0441             
0050   0441             putchar:
0051   0441 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0052   0444             
0053   0444             ; --- BEGIN INLINE ASM BLOCK
0054   0444 FA 05 00      lea d, [bp + 5] ; $c
0055   0447 1E            mov al, [d]
0056   0448 23            mov ah, al
0057   0449 07 39 05      call _putchar
0058   044C             ; --- END INLINE ASM BLOCK
0059   044C             
0060   044C F9            leave
0061   044D 09            ret
0062   044E             
0063   044E             include_stdio_asm:
0064   044E F8 00 00      enter 0 ; (push bp; mov bp, sp)
0065   0451             
0066   0451             ; --- BEGIN INLINE ASM BLOCK
0067   0451             .include "lib/asm/stdio.asm"
0001+  0451             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0451             ; stdio.s
0003+  0451             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0451             .include "lib/asm/string.asm"
0001++ 0451             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0451             ; string.s
0003++ 0451             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0451             
0005++ 0451             
0006++ 0451             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0451             ; _strrev
0008++ 0451             ; reverse a string
0009++ 0451             ; D = string address
0010++ 0451             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0451             ; 01234
0012++ 0451             _strrev:
0013++ 0451 4B          	pusha
0014++ 0452 07 98 04    	call _strlen	; length in C
0015++ 0455 12          	mov a, c
0016++ 0456 AF 01 00    	cmp a, 1
0017++ 0459 D0 73 04    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 045C 7D          	dec a
0019++ 045D FD 4E       	mov si, d	; beginning of string
0020++ 045F FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0461 59          	add d, a	; end of string
0022++ 0462 12          	mov a, c
0023++ 0463 FD 9B       	shr a		; divide by 2
0024++ 0465 39          	mov c, a	; C now counts the steps
0025++ 0466             _strrev_L0:
0026++ 0466 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0467 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0468 3E          	mov [d], al	; store left char into right side
0029++ 0469 1B          	mov al, bl
0030++ 046A F7          	stosb		; store right-side char into left-side; increase DI
0031++ 046B 7E          	dec c
0032++ 046C 7F          	dec d
0033++ 046D C2 00 00    	cmp c, 0
0034++ 0470 C7 66 04    	jne _strrev_L0
0035++ 0473             _strrev_end:
0036++ 0473 4C          	popa
0037++ 0474 09          	ret
0038++ 0475             	
0039++ 0475             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0475             ; _strchr
0041++ 0475             ; search string in D for char in AL
0042++ 0475             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0475             _strchr:
0044++ 0475             _strchr_L0:
0045++ 0475 32          	mov bl, [d]
0046++ 0476 C1 00       	cmp bl, 0
0047++ 0478 C6 83 04    	je _strchr_end
0048++ 047B BA          	cmp al, bl
0049++ 047C C6 83 04    	je _strchr_end
0050++ 047F 79          	inc d
0051++ 0480 0A 75 04    	jmp _strchr_L0
0052++ 0483             _strchr_end:
0053++ 0483 1B          	mov al, bl
0054++ 0484 09          	ret
0055++ 0485             
0056++ 0485             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0485             ; _strstr
0058++ 0485             ; find sub-string
0059++ 0485             ; str1 in SI
0060++ 0485             ; str2 in DI
0061++ 0485             ; SI points to end of source string
0062++ 0485             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0485             _strstr:
0064++ 0485 DB          	push al
0065++ 0486 DA          	push d
0066++ 0487 E3          	push di
0067++ 0488             _strstr_loop:
0068++ 0488 F3          	cmpsb					; compare a byte of the strings
0069++ 0489 C7 94 04    	jne _strstr_ret
0070++ 048C FC 00 00    	lea d, [di + 0]
0071++ 048F BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0491 C7 88 04    	jne _strstr_loop				; equal chars but not at end
0073++ 0494             _strstr_ret:
0074++ 0494 F0          	pop di
0075++ 0495 E7          	pop d
0076++ 0496 E8          	pop al
0077++ 0497 09          	ret
0078++ 0498             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0498             ; length of null terminated string
0080++ 0498             ; result in C
0081++ 0498             ; pointer in D
0082++ 0498             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0498             _strlen:
0084++ 0498 DA          	push d
0085++ 0499 38 00 00    	mov c, 0
0086++ 049C             _strlen_L1:
0087++ 049C BD 00       	cmp byte [d], 0
0088++ 049E C6 A6 04    	je _strlen_ret
0089++ 04A1 79          	inc d
0090++ 04A2 78          	inc c
0091++ 04A3 0A 9C 04    	jmp _strlen_L1
0092++ 04A6             _strlen_ret:
0093++ 04A6 E7          	pop d
0094++ 04A7 09          	ret
0095++ 04A8             
0096++ 04A8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 04A8             ; STRCMP
0098++ 04A8             ; compare two strings
0099++ 04A8             ; str1 in SI
0100++ 04A8             ; str2 in DI
0101++ 04A8             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 04A8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 04A8             _strcmp:
0104++ 04A8 DB          	push al
0105++ 04A9 DA          	push d
0106++ 04AA E3          	push di
0107++ 04AB E2          	push si
0108++ 04AC             _strcmp_loop:
0109++ 04AC F3          	cmpsb					; compare a byte of the strings
0110++ 04AD C7 B8 04    	jne _strcmp_ret
0111++ 04B0 FB FF FF    	lea d, [si +- 1]
0112++ 04B3 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 04B5 C7 AC 04    	jne _strcmp_loop				; equal chars but not at end
0114++ 04B8             _strcmp_ret:
0115++ 04B8 EF          	pop si
0116++ 04B9 F0          	pop di
0117++ 04BA E7          	pop d
0118++ 04BB E8          	pop al
0119++ 04BC 09          	ret
0120++ 04BD             
0121++ 04BD             
0122++ 04BD             ; STRCPY
0123++ 04BD             ; copy null terminated string from SI to DI
0124++ 04BD             ; source in SI
0125++ 04BD             ; destination in DI
0126++ 04BD             _strcpy:
0127++ 04BD E2          	push si
0128++ 04BE E3          	push di
0129++ 04BF DB          	push al
0130++ 04C0             _strcpy_L1:
0131++ 04C0 F6          	lodsb
0132++ 04C1 F7          	stosb
0133++ 04C2 B9 00       	cmp al, 0
0134++ 04C4 C7 C0 04    	jne _strcpy_L1
0135++ 04C7             _strcpy_end:
0136++ 04C7 E8          	pop al
0137++ 04C8 F0          	pop di
0138++ 04C9 EF          	pop si
0139++ 04CA 09          	ret
0140++ 04CB             
0141++ 04CB             ; STRCAT
0142++ 04CB             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 04CB             ; source in SI
0144++ 04CB             ; destination in DI
0145++ 04CB             _strcat:
0146++ 04CB E2          	push si
0147++ 04CC E3          	push di
0148++ 04CD D7          	push a
0149++ 04CE DA          	push d
0150++ 04CF 50          	mov a, di
0151++ 04D0 3C          	mov d, a
0152++ 04D1             _strcat_goto_end_L1:
0153++ 04D1 BD 00       	cmp byte[d], 0
0154++ 04D3 C6 DA 04    	je _strcat_start
0155++ 04D6 79          	inc d
0156++ 04D7 0A D1 04    	jmp _strcat_goto_end_L1
0157++ 04DA             _strcat_start:
0158++ 04DA FD 50       	mov di, d
0159++ 04DC             _strcat_L1:
0160++ 04DC F6          	lodsb
0161++ 04DD F7          	stosb
0162++ 04DE B9 00       	cmp al, 0
0163++ 04E0 C7 DC 04    	jne _strcat_L1
0164++ 04E3             _strcat_end:
0165++ 04E3 E7          	pop d
0166++ 04E4 E4          	pop a
0167++ 04E5 F0          	pop di
0168++ 04E6 EF          	pop si
0169++ 04E7 09          	ret
0170++ 04E8             
0171++ 04E8             
0005+  04E8             
0006+  04E8             
0007+  04E8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  04E8             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  04E8             ; ASCII in BL
0010+  04E8             ; result in AL
0011+  04E8             ; ascii for F = 0100 0110
0012+  04E8             ; ascii for 9 = 0011 1001
0013+  04E8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  04E8             hex_ascii_encode:
0015+  04E8 1B            mov al, bl
0016+  04E9 93 40         test al, $40        ; test if letter or number
0017+  04EB C7 F1 04      jnz hex_letter
0018+  04EE 87 0F         and al, $0F        ; get number
0019+  04F0 09            ret
0020+  04F1             hex_letter:
0021+  04F1 87 0F         and al, $0F        ; get letter
0022+  04F3 6A 09         add al, 9
0023+  04F5 09            ret
0024+  04F6             
0025+  04F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  04F6             ; ATOI
0027+  04F6             ; 2 letter hex string in B
0028+  04F6             ; 8bit integer returned in AL
0029+  04F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  04F6             _atoi:
0031+  04F6 D8            push b
0032+  04F7 07 E8 04      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  04FA 30            mov bl, bh
0034+  04FB DB            push al          ; save a
0035+  04FC 07 E8 04      call hex_ascii_encode
0036+  04FF EA            pop bl  
0037+  0500 FD 9E 04      shl al, 4
0038+  0503 8C            or al, bl
0039+  0504 E5            pop b
0040+  0505 09            ret  
0041+  0506             
0042+  0506             
0043+  0506             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  0506             ; scanf
0045+  0506             ; no need for explanations!
0046+  0506             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  0506             scanf:
0048+  0506 09            ret
0049+  0507             
0050+  0507             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0507             ; ITOA
0052+  0507             ; 8bit value in BL
0053+  0507             ; 2 byte ASCII result in A
0054+  0507             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0507             _itoa:
0056+  0507 DA            push d
0057+  0508 D8            push b
0058+  0509 A7 00         mov bh, 0
0059+  050B FD A4 04      shr bl, 4  
0060+  050E 74            mov d, b
0061+  050F 1F B7 07      mov al, [d + s_hex_digits]
0062+  0512 23            mov ah, al
0063+  0513               
0064+  0513 E5            pop b
0065+  0514 D8            push b
0066+  0515 A7 00         mov bh, 0
0067+  0517 FD 87 0F      and bl, $0F
0068+  051A 74            mov d, b
0069+  051B 1F B7 07      mov al, [d + s_hex_digits]
0070+  051E E5            pop b
0071+  051F E7            pop d
0072+  0520 09            ret
0073+  0521             
0074+  0521             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  0521             ; HEX STRING TO BINARY
0076+  0521             ; di = destination address
0077+  0521             ; si = source
0078+  0521             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  0521             _hex_to_int:
0080+  0521             _hex_to_int_L1:
0081+  0521 F6            lodsb          ; load from [SI] to AL
0082+  0522 B9 00         cmp al, 0        ; check if ASCII 0
0083+  0524 C6 31 05      jz _hex_to_int_ret
0084+  0527 36            mov bh, al
0085+  0528 F6            lodsb
0086+  0529 2F            mov bl, al
0087+  052A 07 F6 04      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  052D F7            stosb          ; store AL to [DI]
0089+  052E 0A 21 05      jmp _hex_to_int_L1
0090+  0531             _hex_to_int_ret:
0091+  0531 09            ret    
0092+  0532             
0093+  0532             
0094+  0532             
0095+  0532             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  0532             ; GETCHAR
0097+  0532             ; char in ah
0098+  0532             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  0532             getch:
0100+  0532 DB            push al
0101+  0533             getch_retry:
0102+  0533 19 01         mov al, 1
0103+  0535 05 03         syscall sys_io      ; receive in AH
0104+  0537 E8            pop al
0105+  0538 09            ret
0106+  0539             
0107+  0539             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  0539             ; PUTCHAR
0109+  0539             ; char in ah
0110+  0539             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0539             _putchar:
0112+  0539 D7            push a
0113+  053A 19 00         mov al, 0
0114+  053C 05 03         syscall sys_io      ; char in AH
0115+  053E E4            pop a
0116+  053F 09            ret
0117+  0540             
0118+  0540             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  0540             ;; INPUT A STRING
0120+  0540             ;; terminates with null
0121+  0540             ;; pointer in D
0122+  0540             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  0540             _gets:
0124+  0540 D7            push a
0125+  0541 DA            push d
0126+  0542             _gets_loop:
0127+  0542 19 01         mov al, 1
0128+  0544 05 03         syscall sys_io      ; receive in AH
0129+  0546 B9 00         cmp al, 0        ; check error code (AL)
0130+  0548 C6 42 05      je _gets_loop      ; if no char received, retry
0131+  054B             
0132+  054B 76 1B         cmp ah, 27
0133+  054D C6 6E 05      je _gets_ansi_esc
0134+  0550 76 0A         cmp ah, $0A        ; LF
0135+  0552 C6 D9 05      je _gets_end
0136+  0555 76 0D         cmp ah, $0D        ; CR
0137+  0557 C6 D9 05      je _gets_end
0138+  055A 76 5C         cmp ah, $5C        ; '\\'
0139+  055C C6 9A 05      je _gets_escape
0140+  055F               
0141+  055F 76 08         cmp ah, $08      ; check for backspace
0142+  0561 C6 6A 05      je _gets_backspace
0143+  0564             
0144+  0564 1A            mov al, ah
0145+  0565 3E            mov [d], al
0146+  0566 79            inc d
0147+  0567 0A 42 05      jmp _gets_loop
0148+  056A             _gets_backspace:
0149+  056A 7F            dec d
0150+  056B 0A 42 05      jmp _gets_loop
0151+  056E             _gets_ansi_esc:
0152+  056E 19 01         mov al, 1
0153+  0570 05 03         syscall sys_io        ; receive in AH without echo
0154+  0572 B9 00         cmp al, 0          ; check error code (AL)
0155+  0574 C6 6E 05      je _gets_ansi_esc    ; if no char received, retry
0156+  0577 76 5B         cmp ah, '['
0157+  0579 C7 42 05      jne _gets_loop
0158+  057C             _gets_ansi_esc_2:
0159+  057C 19 01         mov al, 1
0160+  057E 05 03         syscall sys_io          ; receive in AH without echo
0161+  0580 B9 00         cmp al, 0            ; check error code (AL)
0162+  0582 C6 7C 05      je _gets_ansi_esc_2  ; if no char received, retry
0163+  0585 76 44         cmp ah, 'D'
0164+  0587 C6 92 05      je _gets_left_arrow
0165+  058A 76 43         cmp ah, 'C'
0166+  058C C6 96 05      je _gets_right_arrow
0167+  058F 0A 42 05      jmp _gets_loop
0168+  0592             _gets_left_arrow:
0169+  0592 7F            dec d
0170+  0593 0A 42 05      jmp _gets_loop
0171+  0596             _gets_right_arrow:
0172+  0596 79            inc d
0173+  0597 0A 42 05      jmp _gets_loop
0174+  059A             _gets_escape:
0175+  059A 19 01         mov al, 1
0176+  059C 05 03         syscall sys_io      ; receive in AH
0177+  059E B9 00         cmp al, 0        ; check error code (AL)
0178+  05A0 C6 9A 05      je _gets_escape      ; if no char received, retry
0179+  05A3 76 6E         cmp ah, 'n'
0180+  05A5 C6 C4 05      je _gets_LF
0181+  05A8 76 72         cmp ah, 'r'
0182+  05AA C6 CB 05      je _gets_CR
0183+  05AD 76 30         cmp ah, '0'
0184+  05AF C6 D2 05      je _gets_NULL
0185+  05B2 76 5C         cmp ah, $5C  ; '\'
0186+  05B4 C6 BD 05      je _gets_slash
0187+  05B7 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0188+  05B8 3E            mov [d], al
0189+  05B9 79            inc d
0190+  05BA 0A 42 05      jmp _gets_loop
0191+  05BD             _gets_slash:
0192+  05BD 19 5C         mov al, $5C
0193+  05BF 3E            mov [d], al
0194+  05C0 79            inc d
0195+  05C1 0A 42 05      jmp _gets_loop
0196+  05C4             _gets_LF:
0197+  05C4 19 0A         mov al, $0A
0198+  05C6 3E            mov [d], al
0199+  05C7 79            inc d
0200+  05C8 0A 42 05      jmp _gets_loop
0201+  05CB             _gets_CR:
0202+  05CB 19 0D         mov al, $0D
0203+  05CD 3E            mov [d], al
0204+  05CE 79            inc d
0205+  05CF 0A 42 05      jmp _gets_loop
0206+  05D2             _gets_NULL:
0207+  05D2 19 00         mov al, $00
0208+  05D4 3E            mov [d], al
0209+  05D5 79            inc d
0210+  05D6 0A 42 05      jmp _gets_loop
0211+  05D9             _gets_end:
0212+  05D9 19 00         mov al, 0
0213+  05DB 3E            mov [d], al        ; terminate string
0214+  05DC E7            pop d
0215+  05DD E4            pop a
0216+  05DE 09            ret
0217+  05DF             
0218+  05DF             
0219+  05DF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0220+  05DF             ;; INPUT TEXT
0221+  05DF             ;; terminated with CTRL+D
0222+  05DF             ;; pointer in D
0223+  05DF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0224+  05DF             _gettxt:
0225+  05DF D7            push a
0226+  05E0 DA            push d
0227+  05E1             _gettxt_loop:
0228+  05E1 19 01         mov al, 1
0229+  05E3 05 03         syscall sys_io      ; receive in AH
0230+  05E5 B9 00         cmp al, 0        ; check error code (AL)
0231+  05E7 C6 E1 05      je _gettxt_loop    ; if no char received, retry
0232+  05EA 76 04         cmp ah, 4      ; EOT
0233+  05EC C6 2A 06      je _gettxt_end
0234+  05EF 76 08         cmp ah, $08      ; check for backspace
0235+  05F1 C6 26 06      je _gettxt_backspace
0236+  05F4 76 5C         cmp ah, $5C        ; '\'
0237+  05F6 C6 FF 05      je _gettxt_escape
0238+  05F9 1A            mov al, ah
0239+  05FA 3E            mov [d], al
0240+  05FB 79            inc d
0241+  05FC 0A E1 05      jmp _gettxt_loop
0242+  05FF             _gettxt_escape:
0243+  05FF 19 01         mov al, 1
0244+  0601 05 03         syscall sys_io      ; receive in AH
0245+  0603 B9 00         cmp al, 0        ; check error code (AL)
0246+  0605 C6 FF 05      je _gettxt_escape    ; if no char received, retry
0247+  0608 76 6E         cmp ah, 'n'
0248+  060A C6 18 06      je _gettxt_LF
0249+  060D 76 72         cmp ah, 'r'
0250+  060F C6 1F 06      je _gettxt_CR
0251+  0612 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0252+  0613 3E            mov [d], al
0253+  0614 79            inc d
0254+  0615 0A E1 05      jmp _gettxt_loop
0255+  0618             _gettxt_LF:
0256+  0618 19 0A         mov al, $0A
0257+  061A 3E            mov [d], al
0258+  061B 79            inc d
0259+  061C 0A E1 05      jmp _gettxt_loop
0260+  061F             _gettxt_CR:
0261+  061F 19 0D         mov al, $0D
0262+  0621 3E            mov [d], al
0263+  0622 79            inc d
0264+  0623 0A E1 05      jmp _gettxt_loop
0265+  0626             _gettxt_backspace:
0266+  0626 7F            dec d
0267+  0627 0A E1 05      jmp _gettxt_loop
0268+  062A             _gettxt_end:
0269+  062A 19 00         mov al, 0
0270+  062C 3E            mov [d], al        ; terminate string
0271+  062D E7            pop d
0272+  062E E4            pop a
0273+  062F 09            ret
0274+  0630             
0275+  0630             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  0630             ; PRINT NEW LINE
0277+  0630             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0278+  0630             printnl:
0279+  0630 D7            push a
0280+  0631 10 00 0A      mov a, $0A00
0281+  0634 05 03         syscall sys_io
0282+  0636 10 00 0D      mov a, $0D00
0283+  0639 05 03         syscall sys_io
0284+  063B E4            pop a
0285+  063C 09            ret
0286+  063D             
0287+  063D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  063D             ; _strtoint
0289+  063D             ; 4 digit hex string number in d
0290+  063D             ; integer returned in A
0291+  063D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0292+  063D             _strtointx:
0293+  063D D8            push b
0294+  063E 32            mov bl, [d]
0295+  063F 37            mov bh, bl
0296+  0640 33 01 00      mov bl, [d + 1]
0297+  0643 07 F6 04      call _atoi        ; convert to int in AL
0298+  0646 23            mov ah, al        ; move to AH
0299+  0647 33 02 00      mov bl, [d + 2]
0300+  064A 37            mov bh, bl
0301+  064B 33 03 00      mov bl, [d + 3]
0302+  064E 07 F6 04      call _atoi        ; convert to int in AL
0303+  0651 E5            pop b
0304+  0652 09            ret
0305+  0653             
0306+  0653             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0307+  0653             ; _strtoint
0308+  0653             ; 5 digit base10 string number in d
0309+  0653             ; integer returned in A
0310+  0653             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0311+  0653             _strtoint:
0312+  0653 E2            push si
0313+  0654 D8            push b
0314+  0655 D9            push c
0315+  0656 DA            push d
0316+  0657 07 98 04      call _strlen      ; get string length in C
0317+  065A 7E            dec c
0318+  065B FD 4E         mov si, d
0319+  065D 12            mov a, c
0320+  065E FD 99         shl a
0321+  0660 3B CF 07      mov d, table_power
0322+  0663 59            add d, a
0323+  0664 38 00 00      mov c, 0
0324+  0667             _strtoint_L0:
0325+  0667 F6            lodsb      ; load ASCII to al
0326+  0668 B9 00         cmp al, 0
0327+  066A C6 7D 06      je _strtoint_end
0328+  066D 6F 30         sub al, $30    ; make into integer
0329+  066F 22 00         mov ah, 0
0330+  0671 2A            mov b, [d]
0331+  0672 AC            mul a, b      ; result in B since it fits in 16bits
0332+  0673 11            mov a, b
0333+  0674 28            mov b, c
0334+  0675 54            add a, b
0335+  0676 39            mov c, a
0336+  0677 63 02 00      sub d, 2
0337+  067A 0A 67 06      jmp _strtoint_L0
0338+  067D             _strtoint_end:
0339+  067D 12            mov a, c
0340+  067E E7            pop d
0341+  067F E6            pop c
0342+  0680 E5            pop b
0343+  0681 EF            pop si
0344+  0682 09            ret
0345+  0683             
0346+  0683             
0347+  0683             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0348+  0683             ; PRINT NULL TERMINATED STRING
0349+  0683             ; pointer in D
0350+  0683             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0351+  0683             _puts:
0352+  0683 D7            push a
0353+  0684 DA            push d
0354+  0685             _puts_L1:
0355+  0685 1E            mov al, [d]
0356+  0686 B9 00         cmp al, 0
0357+  0688 C6 94 06      jz _puts_END
0358+  068B 23            mov ah, al
0359+  068C 19 00         mov al, 0
0360+  068E 05 03         syscall sys_io
0361+  0690 79            inc d
0362+  0691 0A 85 06      jmp _puts_L1
0363+  0694             _puts_END:
0364+  0694 E7            pop d
0365+  0695 E4            pop a
0366+  0696 09            ret
0367+  0697             
0368+  0697             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0369+  0697             ; PRINT N SIZE STRING
0370+  0697             ; pointer in D
0371+  0697             ; size in C
0372+  0697             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0373+  0697             _putsn:
0374+  0697 DB            push al
0375+  0698 DA            push d
0376+  0699 D9            push c
0377+  069A             _putsn_L0:
0378+  069A 1E            mov al, [d]
0379+  069B 23            mov ah, al
0380+  069C 19 00         mov al, 0
0381+  069E 05 03         syscall sys_io
0382+  06A0 79            inc d
0383+  06A1 7E            dec c  
0384+  06A2 C2 00 00      cmp c, 0
0385+  06A5 C7 9A 06      jne _putsn_L0
0386+  06A8             _putsn_end:
0387+  06A8 E6            pop c
0388+  06A9 E7            pop d
0389+  06AA E8            pop al
0390+  06AB 09            ret
0391+  06AC             
0392+  06AC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0393+  06AC             ; print 16bit decimal number
0394+  06AC             ; input number in A
0395+  06AC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0396+  06AC             print_u16d:
0397+  06AC D7            push a
0398+  06AD D8            push b
0399+  06AE 26 10 27      mov b, 10000
0400+  06B1 AE            div a, b      ; get 10000's coeff.
0401+  06B2 07 D4 06      call print_number
0402+  06B5 11            mov a, b
0403+  06B6 26 E8 03      mov b, 1000
0404+  06B9 AE            div a, b      ; get 1000's coeff.
0405+  06BA 07 D4 06      call print_number
0406+  06BD 11            mov a, b
0407+  06BE 26 64 00      mov b, 100
0408+  06C1 AE            div a, b
0409+  06C2 07 D4 06      call print_number
0410+  06C5 11            mov a, b
0411+  06C6 26 0A 00      mov b, 10
0412+  06C9 AE            div a, b
0413+  06CA 07 D4 06      call print_number
0414+  06CD 1B            mov al, bl      ; 1's coeff in bl
0415+  06CE 07 D4 06      call print_number
0416+  06D1 E5            pop b
0417+  06D2 E4            pop a
0418+  06D3 09            ret
0419+  06D4             
0420+  06D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0421+  06D4             ; print AL
0422+  06D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0423+  06D4             print_number:
0424+  06D4 6A 30         add al, $30
0425+  06D6 23            mov ah, al
0426+  06D7 07 39 05      call _putchar
0427+  06DA 09            ret
0428+  06DB             
0429+  06DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0430+  06DB             ; PRINT 16BIT HEX INTEGER
0431+  06DB             ; integer value in reg B
0432+  06DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  06DB             print_u16x:
0434+  06DB D7            push a
0435+  06DC D8            push b
0436+  06DD DD            push bl
0437+  06DE 30            mov bl, bh
0438+  06DF 07 07 05      call _itoa        ; convert bh to char in A
0439+  06E2 2F            mov bl, al        ; save al
0440+  06E3 19 00         mov al, 0
0441+  06E5 05 03         syscall sys_io        ; display AH
0442+  06E7 24            mov ah, bl        ; retrieve al
0443+  06E8 19 00         mov al, 0
0444+  06EA 05 03         syscall sys_io        ; display AL
0445+  06EC             
0446+  06EC EA            pop bl
0447+  06ED 07 07 05      call _itoa        ; convert bh to char in A
0448+  06F0 2F            mov bl, al        ; save al
0449+  06F1 19 00         mov al, 0
0450+  06F3 05 03         syscall sys_io        ; display AH
0451+  06F5 24            mov ah, bl        ; retrieve al
0452+  06F6 19 00         mov al, 0
0453+  06F8 05 03         syscall sys_io        ; display AL
0454+  06FA             
0455+  06FA E5            pop b
0456+  06FB E4            pop a
0457+  06FC 09            ret
0458+  06FD             
0459+  06FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0460+  06FD             ; INPUT 16BIT HEX INTEGER
0461+  06FD             ; read 16bit integer into A
0462+  06FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0463+  06FD             scan_u16x:
0464+  06FD F8 10 00      enter 16
0465+  0700 D8            push b
0466+  0701 DA            push d
0467+  0702             
0468+  0702 FA F1 FF      lea d, [bp + -15]
0469+  0705 07 40 05      call _gets        ; get number
0470+  0708             
0471+  0708 32            mov bl, [d]
0472+  0709 37            mov bh, bl
0473+  070A 33 01 00      mov bl, [d + 1]
0474+  070D 07 F6 04      call _atoi        ; convert to int in AL
0475+  0710 23            mov ah, al        ; move to AH
0476+  0711             
0477+  0711 33 02 00      mov bl, [d + 2]
0478+  0714 37            mov bh, bl
0479+  0715 33 03 00      mov bl, [d + 3]
0480+  0718 07 F6 04      call _atoi        ; convert to int in AL
0481+  071B             
0482+  071B E7            pop d
0483+  071C E5            pop b
0484+  071D F9            leave
0485+  071E 09            ret
0486+  071F             
0487+  071F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0488+  071F             ; PRINT 8bit HEX INTEGER
0489+  071F             ; integer value in reg bl
0490+  071F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0491+  071F             print_u8x:
0492+  071F D7            push a
0493+  0720 DD            push bl
0494+  0721             
0495+  0721 07 07 05      call _itoa        ; convert bl to char in A
0496+  0724 2F            mov bl, al        ; save al
0497+  0725 19 00         mov al, 0
0498+  0727 05 03         syscall sys_io        ; display AH
0499+  0729 24            mov ah, bl        ; retrieve al
0500+  072A 19 00         mov al, 0
0501+  072C 05 03         syscall sys_io        ; display AL
0502+  072E             
0503+  072E EA            pop bl
0504+  072F E4            pop a
0505+  0730 09            ret
0506+  0731             
0507+  0731             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0508+  0731             ; print 8bit decimal unsigned number
0509+  0731             ; input number in AL
0510+  0731             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0511+  0731             print_u8d:
0512+  0731 D7            push a
0513+  0732 D8            push b
0514+  0733             
0515+  0733 22 00         mov ah, 0
0516+  0735 26 64 00      mov b, 100
0517+  0738 AE            div a, b
0518+  0739 D8            push b      ; save remainder
0519+  073A B9 00         cmp al, 0
0520+  073C C6 46 07      je skip100
0521+  073F 6A 30         add al, $30
0522+  0741 23            mov ah, al
0523+  0742 19 00         mov al, 0
0524+  0744 05 03         syscall sys_io  ; print coeff
0525+  0746             skip100:
0526+  0746 E4            pop a
0527+  0747 22 00         mov ah, 0
0528+  0749 26 0A 00      mov b, 10
0529+  074C AE            div a, b
0530+  074D D8            push b      ; save remainder
0531+  074E B9 00         cmp al, 0
0532+  0750 C6 5A 07      je skip10
0533+  0753 6A 30         add al, $30
0534+  0755 23            mov ah, al
0535+  0756 19 00         mov al, 0
0536+  0758 05 03         syscall sys_io  ; print coeff
0537+  075A             skip10:
0538+  075A E4            pop a
0539+  075B 1B            mov al, bl
0540+  075C 6A 30         add al, $30
0541+  075E 23            mov ah, al
0542+  075F 19 00         mov al, 0
0543+  0761 05 03         syscall sys_io  ; print coeff
0544+  0763 E5            pop b
0545+  0764 E4            pop a
0546+  0765 09            ret
0547+  0766             
0548+  0766             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0549+  0766             ; INPUT 8BIT HEX INTEGER
0550+  0766             ; read 8bit integer into AL
0551+  0766             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0552+  0766             scan_u8x:
0553+  0766 F8 04 00      enter 4
0554+  0769 D8            push b
0555+  076A DA            push d
0556+  076B             
0557+  076B FA FD FF      lea d, [bp + -3]
0558+  076E 07 40 05      call _gets        ; get number
0559+  0771             
0560+  0771 32            mov bl, [d]
0561+  0772 37            mov bh, bl
0562+  0773 33 01 00      mov bl, [d + 1]
0563+  0776 07 F6 04      call _atoi        ; convert to int in AL
0564+  0779             
0565+  0779 E7            pop d
0566+  077A E5            pop b
0567+  077B F9            leave
0568+  077C 09            ret
0569+  077D             
0570+  077D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  077D             ; input decimal number
0572+  077D             ; result in A
0573+  077D             ; 655'\0'
0574+  077D             ; low--------high
0575+  077D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0576+  077D             scan_u16d:
0577+  077D F8 08 00      enter 8
0578+  0780 E2            push si
0579+  0781 D8            push b
0580+  0782 D9            push c
0581+  0783 DA            push d
0582+  0784 FA F9 FF      lea d, [bp +- 7]
0583+  0787 07 40 05      call _gets
0584+  078A 07 98 04      call _strlen      ; get string length in C
0585+  078D 7E            dec c
0586+  078E FD 4E         mov si, d
0587+  0790 12            mov a, c
0588+  0791 FD 99         shl a
0589+  0793 3B CF 07      mov d, table_power
0590+  0796 59            add d, a
0591+  0797 38 00 00      mov c, 0
0592+  079A             mul_loop:
0593+  079A F6            lodsb      ; load ASCII to al
0594+  079B B9 00         cmp al, 0
0595+  079D C6 B0 07      je mul_exit
0596+  07A0 6F 30         sub al, $30    ; make into integer
0597+  07A2 22 00         mov ah, 0
0598+  07A4 2A            mov b, [d]
0599+  07A5 AC            mul a, b      ; result in B since it fits in 16bits
0600+  07A6 11            mov a, b
0601+  07A7 28            mov b, c
0602+  07A8 54            add a, b
0603+  07A9 39            mov c, a
0604+  07AA 63 02 00      sub d, 2
0605+  07AD 0A 9A 07      jmp mul_loop
0606+  07B0             mul_exit:
0607+  07B0 12            mov a, c
0608+  07B1 E7            pop d
0609+  07B2 E6            pop c
0610+  07B3 E5            pop b
0611+  07B4 EF            pop si
0612+  07B5 F9            leave
0613+  07B6 09            ret
0614+  07B7             
0615+  07B7             
0616+  07B7 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0616+  07BB 34 35 36 37 
0616+  07BF 38 39 41 42 
0616+  07C3 43 44 45 46 
0617+  07C7 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0617+  07CB 1B 5B 48 00 
0618+  07CF             
0619+  07CF             table_power:
0620+  07CF 01 00         .dw 1
0621+  07D1 0A 00         .dw 10
0622+  07D3 64 00         .dw 100
0623+  07D5 E8 03         .dw 1000
0624+  07D7 10 27         .dw 100000068   07D9             ; --- END INLINE ASM BLOCK
0069   07D9             
0070   07D9 F9            leave
0071   07DA 09            ret
0072   07DB             
0073   07DB             print_signed_long:
0074   07DB F8 00 00      enter 0 ; (push bp; mov bp, sp)
0075   07DE             ; $digits 
0076   07DE             ; $i 
0077   07DE 10 00 00      mov a, $0
0078   07E1 45 F5 FF      mov [bp + -11], a
0079   07E4 52 0C 00      sub sp, 12
0080   07E7             ;; if (num < 0) { 
0081   07E7             _if1_cond:
0082   07E7 FA 05 00      lea d, [bp + 5] ; $num
0083   07EA 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0084   07ED FD 39         mov c, b ; And place it into C
0085   07EF 2A            mov b, [d] ; Lower Word in B
0086   07F0             ; START RELATIONAL
0087   07F0 D7            push a
0088   07F1 FD D8         push g
0089   07F3 11            mov a, b
0090   07F4 FD 7A         mov g, c
0091   07F6 26 00 00      mov b, $0
0092   07F9 B0            cmp a, b
0093   07FA FD 73         slt ; < 
0094   07FC FD F1         pop g
0095   07FE E4            pop a
0096   07FF             ; END RELATIONAL
0097   07FF C0 00 00      cmp b, 0
0098   0802 C6 29 08      je _if1_else
0099   0805             _if1_true:
0100   0805             ;; putchar('-'); 
0101   0805 26 2D 00      mov b, $2d
0102   0808 DD            push bl
0103   0809 07 41 04      call putchar
0104   080C 51 01 00      add sp, 1
0105   080F             ;; num = -num; 
0106   080F FA 05 00      lea d, [bp + 5] ; $num
0107   0812 DA            push d
0108   0813 FA 05 00      lea d, [bp + 5] ; $num
0109   0816 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0110   0819 FD 39         mov c, b ; And place it into C
0111   081B 2A            mov b, [d] ; Lower Word in B
0112   081C FD 97         neg b
0113   081E E7            pop d
0114   081F FD 43         mov [d], b
0115   0821 28            mov b, c
0116   0822 FD 44 02 00   mov [d + 2], b
0117   0826 0A 60 08      jmp _if1_exit
0118   0829             _if1_else:
0119   0829             ;; if (num == 0) { 
0120   0829             _if2_cond:
0121   0829 FA 05 00      lea d, [bp + 5] ; $num
0122   082C 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0123   082F FD 39         mov c, b ; And place it into C
0124   0831 2A            mov b, [d] ; Lower Word in B
0125   0832             ; START RELATIONAL
0126   0832 D7            push a
0127   0833 FD D8         push g
0128   0835 11            mov a, b
0129   0836 FD 7A         mov g, c
0130   0838 26 00 00      mov b, $0
0131   083B B0            cmp a, b
0132   083C FD 71         seq ; ==
0133   083E D8            push b
0134   083F 12            mov a, c
0135   0840 FD 27         mov b, g
0136   0842 B0            cmp a, b
0137   0843 FD 71         seq ; ==
0138   0845 E4            pop a
0139   0846 FD A7         sand a, b
0140   0848 FD F1         pop g
0141   084A E4            pop a
0142   084B             ; END RELATIONAL
0143   084B C0 00 00      cmp b, 0
0144   084E C6 60 08      je _if2_exit
0145   0851             _if2_true:
0146   0851             ;; putchar('0'); 
0147   0851 26 30 00      mov b, $30
0148   0854 DD            push bl
0149   0855 07 41 04      call putchar
0150   0858 51 01 00      add sp, 1
0151   085B             ;; return; 
0152   085B F9            leave
0153   085C 09            ret
0154   085D 0A 60 08      jmp _if2_exit
0155   0860             _if2_exit:
0156   0860             _if1_exit:
0157   0860             ;; while (num > 0) { 
0158   0860             _while3_cond:
0159   0860 FA 05 00      lea d, [bp + 5] ; $num
0160   0863 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0161   0866 FD 39         mov c, b ; And place it into C
0162   0868 2A            mov b, [d] ; Lower Word in B
0163   0869             ; START RELATIONAL
0164   0869 D7            push a
0165   086A FD D8         push g
0166   086C 11            mov a, b
0167   086D FD 7A         mov g, c
0168   086F 26 00 00      mov b, $0
0169   0872 B0            cmp a, b
0170   0873 FD 7F         sgt ; >
0171   0875 FD F1         pop g
0172   0877 E4            pop a
0173   0878             ; END RELATIONAL
0174   0878 C0 00 00      cmp b, 0
0175   087B C6 D5 08      je _while3_exit
0176   087E             _while3_block:
0177   087E             ;; digits[i] = '0' + (num % 10); 
0178   087E FA F7 FF      lea d, [bp + -9] ; $digits
0179   0881 D7            push a
0180   0882 DA            push d
0181   0883 FA F5 FF      lea d, [bp + -11] ; $i
0182   0886 2A            mov b, [d]
0183   0887 E7            pop d
0184   0888 5A            add d, b
0185   0889 E4            pop a
0186   088A DA            push d
0187   088B 26 30 00      mov b, $30
0188   088E             ; START TERMS
0189   088E D7            push a
0190   088F 11            mov a, b
0191   0890 FA 05 00      lea d, [bp + 5] ; $num
0192   0893 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0193   0896 FD 39         mov c, b ; And place it into C
0194   0898 2A            mov b, [d] ; Lower Word in B
0195   0899             ; START FACTORS
0196   0899 D7            push a
0197   089A 11            mov a, b
0198   089B 26 0A 00      mov b, $a
0199   089E AE            div a, b ; 
0200   089F 11            mov a, b
0201   08A0 27            mov b, a
0202   08A1 E4            pop a
0203   08A2             ; END FACTORS
0204   08A2 54            add a, b
0205   08A3 27            mov b, a
0206   08A4 E4            pop a
0207   08A5             ; END TERMS
0208   08A5 E7            pop d
0209   08A6 FD 3E         mov [d], bl
0210   08A8             ;; num = num / 10; 
0211   08A8 FA 05 00      lea d, [bp + 5] ; $num
0212   08AB DA            push d
0213   08AC FA 05 00      lea d, [bp + 5] ; $num
0214   08AF 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0215   08B2 FD 39         mov c, b ; And place it into C
0216   08B4 2A            mov b, [d] ; Lower Word in B
0217   08B5             ; START FACTORS
0218   08B5 D7            push a
0219   08B6 11            mov a, b
0220   08B7 26 0A 00      mov b, $a
0221   08BA AE            div a, b
0222   08BB 27            mov b, a
0223   08BC E4            pop a
0224   08BD             ; END FACTORS
0225   08BD E7            pop d
0226   08BE FD 43         mov [d], b
0227   08C0 28            mov b, c
0228   08C1 FD 44 02 00   mov [d + 2], b
0229   08C5             ;; i++; 
0230   08C5 FA F5 FF      lea d, [bp + -11] ; $i
0231   08C8 2A            mov b, [d]
0232   08C9 D8            push b
0233   08CA FD 77         inc b
0234   08CC FA F5 FF      lea d, [bp + -11] ; $i
0235   08CF FD 43         mov [d], b
0236   08D1 E5            pop b
0237   08D2 0A 60 08      jmp _while3_cond
0238   08D5             _while3_exit:
0239   08D5             ;; while (i > 0) { 
0240   08D5             _while4_cond:
0241   08D5 FA F5 FF      lea d, [bp + -11] ; $i
0242   08D8 2A            mov b, [d]
0243   08D9             ; START RELATIONAL
0244   08D9 D7            push a
0245   08DA 11            mov a, b
0246   08DB 26 00 00      mov b, $0
0247   08DE B0            cmp a, b
0248   08DF FD 7F         sgt ; >
0249   08E1 E4            pop a
0250   08E2             ; END RELATIONAL
0251   08E2 C0 00 00      cmp b, 0
0252   08E5 C6 0E 09      je _while4_exit
0253   08E8             _while4_block:
0254   08E8             ;; i--; 
0255   08E8 FA F5 FF      lea d, [bp + -11] ; $i
0256   08EB 2A            mov b, [d]
0257   08EC D8            push b
0258   08ED FD 7D         dec b
0259   08EF FA F5 FF      lea d, [bp + -11] ; $i
0260   08F2 FD 43         mov [d], b
0261   08F4 E5            pop b
0262   08F5             ;; putchar(digits[i]); 
0263   08F5 FA F7 FF      lea d, [bp + -9] ; $digits
0264   08F8 D7            push a
0265   08F9 DA            push d
0266   08FA FA F5 FF      lea d, [bp + -11] ; $i
0267   08FD 2A            mov b, [d]
0268   08FE E7            pop d
0269   08FF 5A            add d, b
0270   0900 E4            pop a
0271   0901 32            mov bl, [d]
0272   0902 A7 00         mov bh, 0
0273   0904 DD            push bl
0274   0905 07 41 04      call putchar
0275   0908 51 01 00      add sp, 1
0276   090B 0A D5 08      jmp _while4_cond
0277   090E             _while4_exit:
0278   090E F9            leave
0279   090F 09            ret
0280   0910             ; --- END TEXT BLOCK
0281   0910             
0282   0910             ; --- BEGIN DATA BLOCK
0283   0910             
0284   0910 12 09       _heap_top: .dw _heap
0285   0912 00          _heap: .db 0
0286   0913             ; --- END DATA BLOCK
0287   0913             
0288   0913             .end
tasm: Number of errors = 0
