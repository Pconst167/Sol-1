0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT SEGMENT
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; printf("%d", 10 * 5 % 49 == 1); 
0011   0408             ; --- START FUNCTION CALL
0012   0408 FD 2E 0A 00   mov32 cb, $0000000a
0012   040C 00 00 
0013   040E             ; --- START FACTORS
0014   040E D7            push a
0015   040F FD D8         push g
0016   0411 11            mov a, b
0017   0412 FD 7A         mov g, c
0018   0414 FD 2E 05 00   mov32 cb, $00000005
0018   0418 00 00 
0019   041A D7            push a     ; save left operand
0020   041B 8E            xor a, b   ; xor sign bits
0021   041C FD AA         swp a      ; swap bytes
0022   041E 83            mov cl, al ; save result of xor into 'dl'
0023   041F E4            pop a      ; restore left side operator
0024   0420 DF            push cl    ; save result of xor above
0025   0421 FD AA         swp a  
0026   0423 93 80         test al, $80  
0027   0425 FD AA         swp a  
0028   0427 C6 2C 04      jz skip_invert_a_7  
0029   042A FD 95         neg a 
0030   042C             skip_invert_a_7:   
0031   042C FD AB         swp b
0032   042E FD 93 80      test bl, $80  
0033   0431 FD AB         swp b
0034   0433 C6 38 04      jz skip_invert_b_7  
0035   0436 FD 97         neg b 
0036   0438             skip_invert_b_7:   
0037   0438 AC            mul a, b ; *
0038   0439 FD 78         mov g, a
0039   043B 11            mov a, b
0040   043C EA            pop bl
0041   043D FD 93 80      test bl, $80
0042   0440 C6 4D 04      jz _same_signs_7
0043   0443 2F            mov bl, al
0044   0444 95            not a
0045   0445 FD 97         neg b
0046   0447 5B 00 00      adc a, 0
0047   044A FD 78         mov g, a
0048   044C 11            mov a, b
0049   044D             _same_signs_7:
0050   044D FD 2E 31 00   mov32 cb, $00000031
0050   0451 00 00 
0051   0453 FD D8         push g ; save 'g' as the div instruction uses it
0052   0455 AE            div a, b ; %, a: quotient, b: remainder
0053   0456 11            mov a, b
0054   0457 FD F1         pop g
0055   0459 FD 38         mov c, g
0056   045B 27            mov b, a
0057   045C FD F1         pop g
0058   045E E4            pop a
0059   045F             ; --- END FACTORS
0060   045F             ; --- START RELATIONAL
0061   045F D7            push a
0062   0460 FD D8         push g
0063   0462 11            mov a, b
0064   0463 FD 7A         mov g, c
0065   0465 FD 2E 01 00   mov32 cb, $00000001
0065   0469 00 00 
0066   046B FD AF         cmp32 ga, cb
0067   046D FD 71         seq ; ==
0068   046F FD F1         pop g
0069   0471 E4            pop a
0070   0472             ; --- END RELATIONAL
0071   0472 FD AB         swp b
0072   0474 D8            push b
0073   0475 26 94 0D      mov b, _s0 ; "%d"
0074   0478 FD AB         swp b
0075   047A D8            push b
0076   047B 07 83 04      call printf
0077   047E 51 04 00      add sp, 4
0078   0481             ; --- END FUNCTION CALL
0079   0481 05 0B         syscall sys_terminate_proc
0080   0483             
0081   0483             printf:
0082   0483 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0083   0486             ; char *p, *format_p; 
0084   0486 52 02 00      sub sp, 2
0085   0489 52 02 00      sub sp, 2
0086   048C             ; format_p = format; 
0087   048C FA FD FF      lea d, [bp + -3] ; $format_p
0088   048F DA            push d
0089   0490 FA 05 00      lea d, [bp + 5] ; $format
0090   0493 2A            mov b, [d]
0091   0494 38 00 00      mov c, 0
0092   0497 E7            pop d
0093   0498 FD 43         mov [d], b
0094   049A             ; p = &format + 2; 
0095   049A FA FF FF      lea d, [bp + -1] ; $p
0096   049D DA            push d
0097   049E FA 05 00      lea d, [bp + 5] ; $format
0098   04A1 2D            mov b, d
0099   04A2             ; --- START TERMS
0100   04A2 D7            push a
0101   04A3 11            mov a, b
0102   04A4 FD 2E 02 00   mov32 cb, $00000002
0102   04A8 00 00 
0103   04AA 56            add b, a
0104   04AB E4            pop a
0105   04AC             ; --- END TERMS
0106   04AC E7            pop d
0107   04AD FD 43         mov [d], b
0108   04AF             ; for(;;){ 
0109   04AF             _for9_init:
0110   04AF             _for9_cond:
0111   04AF             _for9_block:
0112   04AF             ; if(!*format_p) break; 
0113   04AF             _if10_cond:
0114   04AF FA FD FF      lea d, [bp + -3] ; $format_p
0115   04B2 2A            mov b, [d]
0116   04B3 38 00 00      mov c, 0
0117   04B6 74            mov d, b
0118   04B7 32            mov bl, [d]
0119   04B8 A7 00         mov bh, 0
0120   04BA 38 00 00      mov c, 0
0121   04BD C0 00 00      cmp b, 0
0122   04C0 FD 71         seq ; !
0123   04C2 C0 00 00      cmp b, 0
0124   04C5 C6 CE 04      je _if10_else
0125   04C8             _if10_TRUE:
0126   04C8             ; break; 
0127   04C8 0A 7E 07      jmp _for9_exit ; for break
0128   04CB 0A 7B 07      jmp _if10_exit
0129   04CE             _if10_else:
0130   04CE             ; if(*format_p == '%'){ 
0131   04CE             _if11_cond:
0132   04CE FA FD FF      lea d, [bp + -3] ; $format_p
0133   04D1 2A            mov b, [d]
0134   04D2 38 00 00      mov c, 0
0135   04D5 74            mov d, b
0136   04D6 32            mov bl, [d]
0137   04D7 A7 00         mov bh, 0
0138   04D9 38 00 00      mov c, 0
0139   04DC             ; --- START RELATIONAL
0140   04DC D7            push a
0141   04DD 11            mov a, b
0142   04DE FD 2E 25 00   mov32 cb, $00000025
0142   04E2 00 00 
0143   04E4 B0            cmp a, b
0144   04E5 FD 71         seq ; ==
0145   04E7 E4            pop a
0146   04E8             ; --- END RELATIONAL
0147   04E8 C0 00 00      cmp b, 0
0148   04EB C6 56 07      je _if11_else
0149   04EE             _if11_TRUE:
0150   04EE             ; format_p++; 
0151   04EE FA FD FF      lea d, [bp + -3] ; $format_p
0152   04F1 2A            mov b, [d]
0153   04F2 38 00 00      mov c, 0
0154   04F5 FD 77         inc b
0155   04F7 FA FD FF      lea d, [bp + -3] ; $format_p
0156   04FA FD 43         mov [d], b
0157   04FC FD 7D         dec b
0158   04FE             ; switch(*format_p){ 
0159   04FE             _switch12_expr:
0160   04FE FA FD FF      lea d, [bp + -3] ; $format_p
0161   0501 2A            mov b, [d]
0162   0502 38 00 00      mov c, 0
0163   0505 74            mov d, b
0164   0506 32            mov bl, [d]
0165   0507 A7 00         mov bh, 0
0166   0509 38 00 00      mov c, 0
0167   050C             _switch12_comparisons:
0168   050C C1 6C         cmp bl, $6c
0169   050E C6 3A 05      je _switch12_case0
0170   0511 C1 4C         cmp bl, $4c
0171   0513 C6 3A 05      je _switch12_case1
0172   0516 C1 64         cmp bl, $64
0173   0518 C6 4A 06      je _switch12_case2
0174   051B C1 69         cmp bl, $69
0175   051D C6 4A 06      je _switch12_case3
0176   0520 C1 75         cmp bl, $75
0177   0522 C6 7A 06      je _switch12_case4
0178   0525 C1 78         cmp bl, $78
0179   0527 C6 AA 06      je _switch12_case5
0180   052A C1 63         cmp bl, $63
0181   052C C6 DA 06      je _switch12_case6
0182   052F C1 73         cmp bl, $73
0183   0531 C6 0A 07      je _switch12_case7
0184   0534 0A 37 07      jmp _switch12_default
0185   0537 0A 43 07      jmp _switch12_exit
0186   053A             _switch12_case0:
0187   053A             _switch12_case1:
0188   053A             ; format_p++; 
0189   053A FA FD FF      lea d, [bp + -3] ; $format_p
0190   053D 2A            mov b, [d]
0191   053E 38 00 00      mov c, 0
0192   0541 FD 77         inc b
0193   0543 FA FD FF      lea d, [bp + -3] ; $format_p
0194   0546 FD 43         mov [d], b
0195   0548 FD 7D         dec b
0196   054A             ; if(*format_p == 'd' || *format_p == 'i') 
0197   054A             _if13_cond:
0198   054A FA FD FF      lea d, [bp + -3] ; $format_p
0199   054D 2A            mov b, [d]
0200   054E 38 00 00      mov c, 0
0201   0551 74            mov d, b
0202   0552 32            mov bl, [d]
0203   0553 A7 00         mov bh, 0
0204   0555 38 00 00      mov c, 0
0205   0558             ; --- START RELATIONAL
0206   0558 D7            push a
0207   0559 11            mov a, b
0208   055A FD 2E 64 00   mov32 cb, $00000064
0208   055E 00 00 
0209   0560 B0            cmp a, b
0210   0561 FD 71         seq ; ==
0211   0563 E4            pop a
0212   0564             ; --- END RELATIONAL
0213   0564             ; --- START LOGICAL OR
0214   0564 D7            push a
0215   0565 11            mov a, b
0216   0566 FA FD FF      lea d, [bp + -3] ; $format_p
0217   0569 2A            mov b, [d]
0218   056A 38 00 00      mov c, 0
0219   056D 74            mov d, b
0220   056E 32            mov bl, [d]
0221   056F A7 00         mov bh, 0
0222   0571 38 00 00      mov c, 0
0223   0574             ; --- START RELATIONAL
0224   0574 D7            push a
0225   0575 11            mov a, b
0226   0576 FD 2E 69 00   mov32 cb, $00000069
0226   057A 00 00 
0227   057C B0            cmp a, b
0228   057D FD 71         seq ; ==
0229   057F E4            pop a
0230   0580             ; --- END RELATIONAL
0231   0580 FD A8         sor a, b ; ||
0232   0582 E4            pop a
0233   0583             ; --- END LOGICAL OR
0234   0583 C0 00 00      cmp b, 0
0235   0586 C6 A7 05      je _if13_else
0236   0589             _if13_TRUE:
0237   0589             ; print_signed_long(*(long *)p); 
0238   0589             ; --- START FUNCTION CALL
0239   0589 FA FF FF      lea d, [bp + -1] ; $p
0240   058C 2A            mov b, [d]
0241   058D 38 00 00      mov c, 0
0242   0590 74            mov d, b
0243   0591 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0244   0594 FD 39         mov c, b ; And place it into C
0245   0596 2A            mov b, [d] ; Lower Word in B
0246   0597 12            mov a, c
0247   0598 FD AA         swp a
0248   059A D7            push a
0249   059B FD AB         swp b
0250   059D D8            push b
0251   059E 07 80 07      call print_signed_long
0252   05A1 51 04 00      add sp, 4
0253   05A4             ; --- END FUNCTION CALL
0254   05A4 0A 2F 06      jmp _if13_exit
0255   05A7             _if13_else:
0256   05A7             ; if(*format_p == 'u') 
0257   05A7             _if14_cond:
0258   05A7 FA FD FF      lea d, [bp + -3] ; $format_p
0259   05AA 2A            mov b, [d]
0260   05AB 38 00 00      mov c, 0
0261   05AE 74            mov d, b
0262   05AF 32            mov bl, [d]
0263   05B0 A7 00         mov bh, 0
0264   05B2 38 00 00      mov c, 0
0265   05B5             ; --- START RELATIONAL
0266   05B5 D7            push a
0267   05B6 11            mov a, b
0268   05B7 FD 2E 75 00   mov32 cb, $00000075
0268   05BB 00 00 
0269   05BD B0            cmp a, b
0270   05BE FD 71         seq ; ==
0271   05C0 E4            pop a
0272   05C1             ; --- END RELATIONAL
0273   05C1 C0 00 00      cmp b, 0
0274   05C4 C6 E5 05      je _if14_else
0275   05C7             _if14_TRUE:
0276   05C7             ; print_unsigned_long(*(unsigned long *)p); 
0277   05C7             ; --- START FUNCTION CALL
0278   05C7 FA FF FF      lea d, [bp + -1] ; $p
0279   05CA 2A            mov b, [d]
0280   05CB 38 00 00      mov c, 0
0281   05CE 74            mov d, b
0282   05CF 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0283   05D2 FD 39         mov c, b ; And place it into C
0284   05D4 2A            mov b, [d] ; Lower Word in B
0285   05D5 12            mov a, c
0286   05D6 FD AA         swp a
0287   05D8 D7            push a
0288   05D9 FD AB         swp b
0289   05DB D8            push b
0290   05DC 07 16 09      call print_unsigned_long
0291   05DF 51 04 00      add sp, 4
0292   05E2             ; --- END FUNCTION CALL
0293   05E2 0A 2F 06      jmp _if14_exit
0294   05E5             _if14_else:
0295   05E5             ; if(*format_p == 'x') 
0296   05E5             _if15_cond:
0297   05E5 FA FD FF      lea d, [bp + -3] ; $format_p
0298   05E8 2A            mov b, [d]
0299   05E9 38 00 00      mov c, 0
0300   05EC 74            mov d, b
0301   05ED 32            mov bl, [d]
0302   05EE A7 00         mov bh, 0
0303   05F0 38 00 00      mov c, 0
0304   05F3             ; --- START RELATIONAL
0305   05F3 D7            push a
0306   05F4 11            mov a, b
0307   05F5 FD 2E 78 00   mov32 cb, $00000078
0307   05F9 00 00 
0308   05FB B0            cmp a, b
0309   05FC FD 71         seq ; ==
0310   05FE E4            pop a
0311   05FF             ; --- END RELATIONAL
0312   05FF C0 00 00      cmp b, 0
0313   0602 C6 23 06      je _if15_else
0314   0605             _if15_TRUE:
0315   0605             ; printx32(*(long int *)p); 
0316   0605             ; --- START FUNCTION CALL
0317   0605 FA FF FF      lea d, [bp + -1] ; $p
0318   0608 2A            mov b, [d]
0319   0609 38 00 00      mov c, 0
0320   060C 74            mov d, b
0321   060D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0322   0610 FD 39         mov c, b ; And place it into C
0323   0612 2A            mov b, [d] ; Lower Word in B
0324   0613 12            mov a, c
0325   0614 FD AA         swp a
0326   0616 D7            push a
0327   0617 FD AB         swp b
0328   0619 D8            push b
0329   061A 07 4B 0A      call printx32
0330   061D 51 04 00      add sp, 4
0331   0620             ; --- END FUNCTION CALL
0332   0620 0A 2F 06      jmp _if15_exit
0333   0623             _if15_else:
0334   0623             ; err("Unexpected format in printf."); 
0335   0623             ; --- START FUNCTION CALL
0336   0623 26 97 0D      mov b, _s1 ; "Unexpected format in printf."
0337   0626 FD AB         swp b
0338   0628 D8            push b
0339   0629 07 AB 0A      call err
0340   062C 51 02 00      add sp, 2
0341   062F             ; --- END FUNCTION CALL
0342   062F             _if15_exit:
0343   062F             _if14_exit:
0344   062F             _if13_exit:
0345   062F             ; p = p + 4; 
0346   062F FA FF FF      lea d, [bp + -1] ; $p
0347   0632 DA            push d
0348   0633 FA FF FF      lea d, [bp + -1] ; $p
0349   0636 2A            mov b, [d]
0350   0637 38 00 00      mov c, 0
0351   063A             ; --- START TERMS
0352   063A D7            push a
0353   063B 11            mov a, b
0354   063C FD 2E 04 00   mov32 cb, $00000004
0354   0640 00 00 
0355   0642 56            add b, a
0356   0643 E4            pop a
0357   0644             ; --- END TERMS
0358   0644 E7            pop d
0359   0645 FD 43         mov [d], b
0360   0647             ; break; 
0361   0647 0A 43 07      jmp _switch12_exit ; case break
0362   064A             _switch12_case2:
0363   064A             _switch12_case3:
0364   064A             ; print_signed(*(int*)p); 
0365   064A             ; --- START FUNCTION CALL
0366   064A FA FF FF      lea d, [bp + -1] ; $p
0367   064D 2A            mov b, [d]
0368   064E 38 00 00      mov c, 0
0369   0651 74            mov d, b
0370   0652 2A            mov b, [d]
0371   0653 38 00 00      mov c, 0
0372   0656 FD AB         swp b
0373   0658 D8            push b
0374   0659 07 D9 0A      call print_signed
0375   065C 51 02 00      add sp, 2
0376   065F             ; --- END FUNCTION CALL
0377   065F             ; p = p + 2; 
0378   065F FA FF FF      lea d, [bp + -1] ; $p
0379   0662 DA            push d
0380   0663 FA FF FF      lea d, [bp + -1] ; $p
0381   0666 2A            mov b, [d]
0382   0667 38 00 00      mov c, 0
0383   066A             ; --- START TERMS
0384   066A D7            push a
0385   066B 11            mov a, b
0386   066C FD 2E 02 00   mov32 cb, $00000002
0386   0670 00 00 
0387   0672 56            add b, a
0388   0673 E4            pop a
0389   0674             ; --- END TERMS
0390   0674 E7            pop d
0391   0675 FD 43         mov [d], b
0392   0677             ; break; 
0393   0677 0A 43 07      jmp _switch12_exit ; case break
0394   067A             _switch12_case4:
0395   067A             ; print_unsigned(*(unsigned int*)p); 
0396   067A             ; --- START FUNCTION CALL
0397   067A FA FF FF      lea d, [bp + -1] ; $p
0398   067D 2A            mov b, [d]
0399   067E 38 00 00      mov c, 0
0400   0681 74            mov d, b
0401   0682 2A            mov b, [d]
0402   0683 38 00 00      mov c, 0
0403   0686 FD AB         swp b
0404   0688 D8            push b
0405   0689 07 2A 0C      call print_unsigned
0406   068C 51 02 00      add sp, 2
0407   068F             ; --- END FUNCTION CALL
0408   068F             ; p = p + 2; 
0409   068F FA FF FF      lea d, [bp + -1] ; $p
0410   0692 DA            push d
0411   0693 FA FF FF      lea d, [bp + -1] ; $p
0412   0696 2A            mov b, [d]
0413   0697 38 00 00      mov c, 0
0414   069A             ; --- START TERMS
0415   069A D7            push a
0416   069B 11            mov a, b
0417   069C FD 2E 02 00   mov32 cb, $00000002
0417   06A0 00 00 
0418   06A2 56            add b, a
0419   06A3 E4            pop a
0420   06A4             ; --- END TERMS
0421   06A4 E7            pop d
0422   06A5 FD 43         mov [d], b
0423   06A7             ; break; 
0424   06A7 0A 43 07      jmp _switch12_exit ; case break
0425   06AA             _switch12_case5:
0426   06AA             ; printx16(*(int*)p); 
0427   06AA             ; --- START FUNCTION CALL
0428   06AA FA FF FF      lea d, [bp + -1] ; $p
0429   06AD 2A            mov b, [d]
0430   06AE 38 00 00      mov c, 0
0431   06B1 74            mov d, b
0432   06B2 2A            mov b, [d]
0433   06B3 38 00 00      mov c, 0
0434   06B6 FD AB         swp b
0435   06B8 D8            push b
0436   06B9 07 42 0D      call printx16
0437   06BC 51 02 00      add sp, 2
0438   06BF             ; --- END FUNCTION CALL
0439   06BF             ; p = p + 2; 
0440   06BF FA FF FF      lea d, [bp + -1] ; $p
0441   06C2 DA            push d
0442   06C3 FA FF FF      lea d, [bp + -1] ; $p
0443   06C6 2A            mov b, [d]
0444   06C7 38 00 00      mov c, 0
0445   06CA             ; --- START TERMS
0446   06CA D7            push a
0447   06CB 11            mov a, b
0448   06CC FD 2E 02 00   mov32 cb, $00000002
0448   06D0 00 00 
0449   06D2 56            add b, a
0450   06D3 E4            pop a
0451   06D4             ; --- END TERMS
0452   06D4 E7            pop d
0453   06D5 FD 43         mov [d], b
0454   06D7             ; break; 
0455   06D7 0A 43 07      jmp _switch12_exit ; case break
0456   06DA             _switch12_case6:
0457   06DA             ; putchar(*(char*)p); 
0458   06DA             ; --- START FUNCTION CALL
0459   06DA FA FF FF      lea d, [bp + -1] ; $p
0460   06DD 2A            mov b, [d]
0461   06DE 38 00 00      mov c, 0
0462   06E1 74            mov d, b
0463   06E2 32            mov bl, [d]
0464   06E3 A7 00         mov bh, 0
0465   06E5 38 00 00      mov c, 0
0466   06E8 DD            push bl
0467   06E9 07 08 09      call putchar
0468   06EC 51 01 00      add sp, 1
0469   06EF             ; --- END FUNCTION CALL
0470   06EF             ; p = p + 1; 
0471   06EF FA FF FF      lea d, [bp + -1] ; $p
0472   06F2 DA            push d
0473   06F3 FA FF FF      lea d, [bp + -1] ; $p
0474   06F6 2A            mov b, [d]
0475   06F7 38 00 00      mov c, 0
0476   06FA             ; --- START TERMS
0477   06FA D7            push a
0478   06FB 11            mov a, b
0479   06FC FD 2E 01 00   mov32 cb, $00000001
0479   0700 00 00 
0480   0702 56            add b, a
0481   0703 E4            pop a
0482   0704             ; --- END TERMS
0483   0704 E7            pop d
0484   0705 FD 43         mov [d], b
0485   0707             ; break; 
0486   0707 0A 43 07      jmp _switch12_exit ; case break
0487   070A             _switch12_case7:
0488   070A             ; print(*(char**)p); 
0489   070A             ; --- START FUNCTION CALL
0490   070A FA FF FF      lea d, [bp + -1] ; $p
0491   070D 2A            mov b, [d]
0492   070E 38 00 00      mov c, 0
0493   0711 74            mov d, b
0494   0712 2A            mov b, [d]
0495   0713 FD AB         swp b
0496   0715 D8            push b
0497   0716 07 C0 0A      call print
0498   0719 51 02 00      add sp, 2
0499   071C             ; --- END FUNCTION CALL
0500   071C             ; p = p + 2; 
0501   071C FA FF FF      lea d, [bp + -1] ; $p
0502   071F DA            push d
0503   0720 FA FF FF      lea d, [bp + -1] ; $p
0504   0723 2A            mov b, [d]
0505   0724 38 00 00      mov c, 0
0506   0727             ; --- START TERMS
0507   0727 D7            push a
0508   0728 11            mov a, b
0509   0729 FD 2E 02 00   mov32 cb, $00000002
0509   072D 00 00 
0510   072F 56            add b, a
0511   0730 E4            pop a
0512   0731             ; --- END TERMS
0513   0731 E7            pop d
0514   0732 FD 43         mov [d], b
0515   0734             ; break; 
0516   0734 0A 43 07      jmp _switch12_exit ; case break
0517   0737             _switch12_default:
0518   0737             ; print("Error: Unknown argument type.\n"); 
0519   0737             ; --- START FUNCTION CALL
0520   0737 26 B4 0D      mov b, _s2 ; "Error: Unknown argument type.\n"
0521   073A FD AB         swp b
0522   073C D8            push b
0523   073D 07 C0 0A      call print
0524   0740 51 02 00      add sp, 2
0525   0743             ; --- END FUNCTION CALL
0526   0743             _switch12_exit:
0527   0743             ; format_p++; 
0528   0743 FA FD FF      lea d, [bp + -3] ; $format_p
0529   0746 2A            mov b, [d]
0530   0747 38 00 00      mov c, 0
0531   074A FD 77         inc b
0532   074C FA FD FF      lea d, [bp + -3] ; $format_p
0533   074F FD 43         mov [d], b
0534   0751 FD 7D         dec b
0535   0753 0A 7B 07      jmp _if11_exit
0536   0756             _if11_else:
0537   0756             ; putchar(*format_p); 
0538   0756             ; --- START FUNCTION CALL
0539   0756 FA FD FF      lea d, [bp + -3] ; $format_p
0540   0759 2A            mov b, [d]
0541   075A 38 00 00      mov c, 0
0542   075D 74            mov d, b
0543   075E 32            mov bl, [d]
0544   075F A7 00         mov bh, 0
0545   0761 38 00 00      mov c, 0
0546   0764 DD            push bl
0547   0765 07 08 09      call putchar
0548   0768 51 01 00      add sp, 1
0549   076B             ; --- END FUNCTION CALL
0550   076B             ; format_p++; 
0551   076B FA FD FF      lea d, [bp + -3] ; $format_p
0552   076E 2A            mov b, [d]
0553   076F 38 00 00      mov c, 0
0554   0772 FD 77         inc b
0555   0774 FA FD FF      lea d, [bp + -3] ; $format_p
0556   0777 FD 43         mov [d], b
0557   0779 FD 7D         dec b
0558   077B             _if11_exit:
0559   077B             _if10_exit:
0560   077B             _for9_update:
0561   077B 0A AF 04      jmp _for9_cond
0562   077E             _for9_exit:
0563   077E F9            leave
0564   077F 09            ret
0565   0780             
0566   0780             print_signed_long:
0567   0780 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0568   0783             ; char digits[10]; 
0569   0783 52 0A 00      sub sp, 10
0570   0786             ; int i = 0; 
0571   0786 52 02 00      sub sp, 2
0572   0789             ; --- START LOCAL VAR INITIALIZATION
0573   0789 FA F5 FF      lea d, [bp + -11] ; $i
0574   078C DA            push d
0575   078D FD 2E 00 00   mov32 cb, $00000000
0575   0791 00 00 
0576   0793 E7            pop d
0577   0794 FD 43         mov [d], b
0578   0796             ; --- END LOCAL VAR INITIALIZATION
0579   0796             ; if (num < 0) { 
0580   0796             _if16_cond:
0581   0796 FA 05 00      lea d, [bp + 5] ; $num
0582   0799 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0583   079C FD 39         mov c, b ; And place it into C
0584   079E 2A            mov b, [d] ; Lower Word in B
0585   079F             ; --- START RELATIONAL
0586   079F D7            push a
0587   07A0 FD D8         push g
0588   07A2 11            mov a, b
0589   07A3 FD 7A         mov g, c
0590   07A5 FD 2E 00 00   mov32 cb, $00000000
0590   07A9 00 00 
0591   07AB FD AF         cmp32 ga, cb
0592   07AD FD 73         slt ; <
0593   07AF FD F1         pop g
0594   07B1 E4            pop a
0595   07B2             ; --- END RELATIONAL
0596   07B2 C0 00 00      cmp b, 0
0597   07B5 C6 E9 07      je _if16_else
0598   07B8             _if16_TRUE:
0599   07B8             ; putchar('-'); 
0600   07B8             ; --- START FUNCTION CALL
0601   07B8 FD 2E 2D 00   mov32 cb, $0000002d
0601   07BC 00 00 
0602   07BE DD            push bl
0603   07BF 07 08 09      call putchar
0604   07C2 51 01 00      add sp, 1
0605   07C5             ; --- END FUNCTION CALL
0606   07C5             ; num = -num; 
0607   07C5 FA 05 00      lea d, [bp + 5] ; $num
0608   07C8 DA            push d
0609   07C9 FA 05 00      lea d, [bp + 5] ; $num
0610   07CC 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0611   07CF FD 39         mov c, b ; And place it into C
0612   07D1 2A            mov b, [d] ; Lower Word in B
0613   07D2 12            mov a, c
0614   07D3 95            not a
0615   07D4 97            not b
0616   07D5 55 01 00      add b, 1
0617   07D8 5B 00 00      adc a, 0
0618   07DB 39            mov c, a
0619   07DC E7            pop d
0620   07DD FD 43         mov [d], b
0621   07DF 26 00 00      mov b, 0
0622   07E2 FD 44 02 00   mov [d + 2], b
0623   07E6 0A 1D 08      jmp _if16_exit
0624   07E9             _if16_else:
0625   07E9             ; if (num == 0) { 
0626   07E9             _if17_cond:
0627   07E9 FA 05 00      lea d, [bp + 5] ; $num
0628   07EC 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0629   07EF FD 39         mov c, b ; And place it into C
0630   07F1 2A            mov b, [d] ; Lower Word in B
0631   07F2             ; --- START RELATIONAL
0632   07F2 D7            push a
0633   07F3 FD D8         push g
0634   07F5 11            mov a, b
0635   07F6 FD 7A         mov g, c
0636   07F8 FD 2E 00 00   mov32 cb, $00000000
0636   07FC 00 00 
0637   07FE FD AF         cmp32 ga, cb
0638   0800 FD 71         seq ; ==
0639   0802 FD F1         pop g
0640   0804 E4            pop a
0641   0805             ; --- END RELATIONAL
0642   0805 C0 00 00      cmp b, 0
0643   0808 C6 1D 08      je _if17_exit
0644   080B             _if17_TRUE:
0645   080B             ; putchar('0'); 
0646   080B             ; --- START FUNCTION CALL
0647   080B FD 2E 30 00   mov32 cb, $00000030
0647   080F 00 00 
0648   0811 DD            push bl
0649   0812 07 08 09      call putchar
0650   0815 51 01 00      add sp, 1
0651   0818             ; --- END FUNCTION CALL
0652   0818             ; return; 
0653   0818 F9            leave
0654   0819 09            ret
0655   081A 0A 1D 08      jmp _if17_exit
0656   081D             _if17_exit:
0657   081D             _if16_exit:
0658   081D             ; while (num > 0) { 
0659   081D             _while18_cond:
0660   081D FA 05 00      lea d, [bp + 5] ; $num
0661   0820 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0662   0823 FD 39         mov c, b ; And place it into C
0663   0825 2A            mov b, [d] ; Lower Word in B
0664   0826             ; --- START RELATIONAL
0665   0826 D7            push a
0666   0827 FD D8         push g
0667   0829 11            mov a, b
0668   082A FD 7A         mov g, c
0669   082C FD 2E 00 00   mov32 cb, $00000000
0669   0830 00 00 
0670   0832 FD AF         cmp32 ga, cb
0671   0834 FD 7F         sgt
0672   0836 FD F1         pop g
0673   0838 E4            pop a
0674   0839             ; --- END RELATIONAL
0675   0839 C0 00 00      cmp b, 0
0676   083C C6 BE 08      je _while18_exit
0677   083F             _while18_block:
0678   083F             ; digits[i] = '0' + (num % 10); 
0679   083F FA F7 FF      lea d, [bp + -9] ; $digits
0680   0842 D7            push a
0681   0843 DA            push d
0682   0844 FA F5 FF      lea d, [bp + -11] ; $i
0683   0847 2A            mov b, [d]
0684   0848 38 00 00      mov c, 0
0685   084B E7            pop d
0686   084C 5A            add d, b
0687   084D E4            pop a
0688   084E DA            push d
0689   084F FD 2E 30 00   mov32 cb, $00000030
0689   0853 00 00 
0690   0855             ; --- START TERMS
0691   0855 D7            push a
0692   0856 11            mov a, b
0693   0857 FA 05 00      lea d, [bp + 5] ; $num
0694   085A 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0695   085D FD 39         mov c, b ; And place it into C
0696   085F 2A            mov b, [d] ; Lower Word in B
0697   0860             ; --- START FACTORS
0698   0860 D7            push a
0699   0861 FD D8         push g
0700   0863 11            mov a, b
0701   0864 FD 7A         mov g, c
0702   0866 FD 2E 0A 00   mov32 cb, $0000000a
0702   086A 00 00 
0703   086C FD D8         push g ; save 'g' as the div instruction uses it
0704   086E AE            div a, b ; %, a: quotient, b: remainder
0705   086F 11            mov a, b
0706   0870 FD F1         pop g
0707   0872 FD 38         mov c, g
0708   0874 27            mov b, a
0709   0875 FD F1         pop g
0710   0877 E4            pop a
0711   0878             ; --- END FACTORS
0712   0878 56            add b, a
0713   0879 E4            pop a
0714   087A             ; --- END TERMS
0715   087A E7            pop d
0716   087B FD 3E         mov [d], bl
0717   087D             ; num = num / 10; 
0718   087D FA 05 00      lea d, [bp + 5] ; $num
0719   0880 DA            push d
0720   0881 FA 05 00      lea d, [bp + 5] ; $num
0721   0884 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0722   0887 FD 39         mov c, b ; And place it into C
0723   0889 2A            mov b, [d] ; Lower Word in B
0724   088A             ; --- START FACTORS
0725   088A D7            push a
0726   088B FD D8         push g
0727   088D 11            mov a, b
0728   088E FD 7A         mov g, c
0729   0890 FD 2E 0A 00   mov32 cb, $0000000a
0729   0894 00 00 
0730   0896 FD D8         push g ; save 'g' as the div instruction uses it
0731   0898 AE            div a, b ; /, a: quotient, b: remainder
0732   0899 FD F1         pop g
0733   089B FD 38         mov c, g
0734   089D 27            mov b, a
0735   089E FD F1         pop g
0736   08A0 E4            pop a
0737   08A1             ; --- END FACTORS
0738   08A1 E7            pop d
0739   08A2 FD 43         mov [d], b
0740   08A4 26 00 00      mov b, 0
0741   08A7 FD 44 02 00   mov [d + 2], b
0742   08AB             ; i++; 
0743   08AB FA F5 FF      lea d, [bp + -11] ; $i
0744   08AE 2A            mov b, [d]
0745   08AF 38 00 00      mov c, 0
0746   08B2 11            mov a, b
0747   08B3 FD 77         inc b
0748   08B5 FA F5 FF      lea d, [bp + -11] ; $i
0749   08B8 FD 43         mov [d], b
0750   08BA 27            mov b, a
0751   08BB 0A 1D 08      jmp _while18_cond
0752   08BE             _while18_exit:
0753   08BE             ; while (i > 0) { 
0754   08BE             _while25_cond:
0755   08BE FA F5 FF      lea d, [bp + -11] ; $i
0756   08C1 2A            mov b, [d]
0757   08C2 38 00 00      mov c, 0
0758   08C5             ; --- START RELATIONAL
0759   08C5 D7            push a
0760   08C6 11            mov a, b
0761   08C7 FD 2E 00 00   mov32 cb, $00000000
0761   08CB 00 00 
0762   08CD B0            cmp a, b
0763   08CE FD 7F         sgt ; >
0764   08D0 E4            pop a
0765   08D1             ; --- END RELATIONAL
0766   08D1 C0 00 00      cmp b, 0
0767   08D4 C6 06 09      je _while25_exit
0768   08D7             _while25_block:
0769   08D7             ; i--; 
0770   08D7 FA F5 FF      lea d, [bp + -11] ; $i
0771   08DA 2A            mov b, [d]
0772   08DB 38 00 00      mov c, 0
0773   08DE 11            mov a, b
0774   08DF FD 7D         dec b
0775   08E1 FA F5 FF      lea d, [bp + -11] ; $i
0776   08E4 FD 43         mov [d], b
0777   08E6 27            mov b, a
0778   08E7             ; putchar(digits[i]); 
0779   08E7             ; --- START FUNCTION CALL
0780   08E7 FA F7 FF      lea d, [bp + -9] ; $digits
0781   08EA D7            push a
0782   08EB DA            push d
0783   08EC FA F5 FF      lea d, [bp + -11] ; $i
0784   08EF 2A            mov b, [d]
0785   08F0 38 00 00      mov c, 0
0786   08F3 E7            pop d
0787   08F4 5A            add d, b
0788   08F5 E4            pop a
0789   08F6 32            mov bl, [d]
0790   08F7 A7 00         mov bh, 0
0791   08F9 38 00 00      mov c, 0
0792   08FC DD            push bl
0793   08FD 07 08 09      call putchar
0794   0900 51 01 00      add sp, 1
0795   0903             ; --- END FUNCTION CALL
0796   0903 0A BE 08      jmp _while25_cond
0797   0906             _while25_exit:
0798   0906 F9            leave
0799   0907 09            ret
0800   0908             
0801   0908             putchar:
0802   0908 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0803   090B             ; --- BEGIN INLINE ASM SEGMENT
0804   090B FA 05 00      lea d, [bp + 5] ; $c
0805   090E 1E            mov al, [d]
0806   090F 23            mov ah, al
0807   0910 19 00         mov al, 0
0808   0912 05 03         syscall sys_io      ; char in AH
0809   0914             ; --- END INLINE ASM SEGMENT
0810   0914 F9            leave
0811   0915 09            ret
0812   0916             
0813   0916             print_unsigned_long:
0814   0916 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0815   0919             ; char digits[10]; 
0816   0919 52 0A 00      sub sp, 10
0817   091C             ; int i; 
0818   091C 52 02 00      sub sp, 2
0819   091F             ; i = 0; 
0820   091F FA F5 FF      lea d, [bp + -11] ; $i
0821   0922 DA            push d
0822   0923 FD 2E 00 00   mov32 cb, $00000000
0822   0927 00 00 
0823   0929 E7            pop d
0824   092A FD 43         mov [d], b
0825   092C             ; if(num == 0){ 
0826   092C             _if26_cond:
0827   092C FA 05 00      lea d, [bp + 5] ; $num
0828   092F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0829   0932 FD 39         mov c, b ; And place it into C
0830   0934 2A            mov b, [d] ; Lower Word in B
0831   0935             ; --- START RELATIONAL
0832   0935 D7            push a
0833   0936 FD D8         push g
0834   0938 11            mov a, b
0835   0939 FD 7A         mov g, c
0836   093B FD 2E 00 00   mov32 cb, $00000000
0836   093F 00 00 
0837   0941 FD AF         cmp32 ga, cb
0838   0943 FD 71         seq ; ==
0839   0945 FD F1         pop g
0840   0947 E4            pop a
0841   0948             ; --- END RELATIONAL
0842   0948 C0 00 00      cmp b, 0
0843   094B C6 60 09      je _if26_exit
0844   094E             _if26_TRUE:
0845   094E             ; putchar('0'); 
0846   094E             ; --- START FUNCTION CALL
0847   094E FD 2E 30 00   mov32 cb, $00000030
0847   0952 00 00 
0848   0954 DD            push bl
0849   0955 07 08 09      call putchar
0850   0958 51 01 00      add sp, 1
0851   095B             ; --- END FUNCTION CALL
0852   095B             ; return; 
0853   095B F9            leave
0854   095C 09            ret
0855   095D 0A 60 09      jmp _if26_exit
0856   0960             _if26_exit:
0857   0960             ; while (num > 0) { 
0858   0960             _while27_cond:
0859   0960 FA 05 00      lea d, [bp + 5] ; $num
0860   0963 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0861   0966 FD 39         mov c, b ; And place it into C
0862   0968 2A            mov b, [d] ; Lower Word in B
0863   0969             ; --- START RELATIONAL
0864   0969 D7            push a
0865   096A FD D8         push g
0866   096C 11            mov a, b
0867   096D FD 7A         mov g, c
0868   096F FD 2E 00 00   mov32 cb, $00000000
0868   0973 00 00 
0869   0975 FD AF         cmp32 ga, cb
0870   0977 FD 81         sgu
0871   0979 FD F1         pop g
0872   097B E4            pop a
0873   097C             ; --- END RELATIONAL
0874   097C C0 00 00      cmp b, 0
0875   097F C6 01 0A      je _while27_exit
0876   0982             _while27_block:
0877   0982             ; digits[i] = '0' + (num % 10); 
0878   0982 FA F7 FF      lea d, [bp + -9] ; $digits
0879   0985 D7            push a
0880   0986 DA            push d
0881   0987 FA F5 FF      lea d, [bp + -11] ; $i
0882   098A 2A            mov b, [d]
0883   098B 38 00 00      mov c, 0
0884   098E E7            pop d
0885   098F 5A            add d, b
0886   0990 E4            pop a
0887   0991 DA            push d
0888   0992 FD 2E 30 00   mov32 cb, $00000030
0888   0996 00 00 
0889   0998             ; --- START TERMS
0890   0998 D7            push a
0891   0999 11            mov a, b
0892   099A FA 05 00      lea d, [bp + 5] ; $num
0893   099D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0894   09A0 FD 39         mov c, b ; And place it into C
0895   09A2 2A            mov b, [d] ; Lower Word in B
0896   09A3             ; --- START FACTORS
0897   09A3 D7            push a
0898   09A4 FD D8         push g
0899   09A6 11            mov a, b
0900   09A7 FD 7A         mov g, c
0901   09A9 FD 2E 0A 00   mov32 cb, $0000000a
0901   09AD 00 00 
0902   09AF FD D8         push g ; save 'g' as the div instruction uses it
0903   09B1 AE            div a, b ; %, a: quotient, b: remainder
0904   09B2 11            mov a, b
0905   09B3 FD F1         pop g
0906   09B5 FD 38         mov c, g
0907   09B7 27            mov b, a
0908   09B8 FD F1         pop g
0909   09BA E4            pop a
0910   09BB             ; --- END FACTORS
0911   09BB 56            add b, a
0912   09BC E4            pop a
0913   09BD             ; --- END TERMS
0914   09BD E7            pop d
0915   09BE FD 3E         mov [d], bl
0916   09C0             ; num = num / 10; 
0917   09C0 FA 05 00      lea d, [bp + 5] ; $num
0918   09C3 DA            push d
0919   09C4 FA 05 00      lea d, [bp + 5] ; $num
0920   09C7 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0921   09CA FD 39         mov c, b ; And place it into C
0922   09CC 2A            mov b, [d] ; Lower Word in B
0923   09CD             ; --- START FACTORS
0924   09CD D7            push a
0925   09CE FD D8         push g
0926   09D0 11            mov a, b
0927   09D1 FD 7A         mov g, c
0928   09D3 FD 2E 0A 00   mov32 cb, $0000000a
0928   09D7 00 00 
0929   09D9 FD D8         push g ; save 'g' as the div instruction uses it
0930   09DB AE            div a, b ; /, a: quotient, b: remainder
0931   09DC FD F1         pop g
0932   09DE FD 38         mov c, g
0933   09E0 27            mov b, a
0934   09E1 FD F1         pop g
0935   09E3 E4            pop a
0936   09E4             ; --- END FACTORS
0937   09E4 E7            pop d
0938   09E5 FD 43         mov [d], b
0939   09E7 26 00 00      mov b, 0
0940   09EA FD 44 02 00   mov [d + 2], b
0941   09EE             ; i++; 
0942   09EE FA F5 FF      lea d, [bp + -11] ; $i
0943   09F1 2A            mov b, [d]
0944   09F2 38 00 00      mov c, 0
0945   09F5 11            mov a, b
0946   09F6 FD 77         inc b
0947   09F8 FA F5 FF      lea d, [bp + -11] ; $i
0948   09FB FD 43         mov [d], b
0949   09FD 27            mov b, a
0950   09FE 0A 60 09      jmp _while27_cond
0951   0A01             _while27_exit:
0952   0A01             ; while (i > 0) { 
0953   0A01             _while34_cond:
0954   0A01 FA F5 FF      lea d, [bp + -11] ; $i
0955   0A04 2A            mov b, [d]
0956   0A05 38 00 00      mov c, 0
0957   0A08             ; --- START RELATIONAL
0958   0A08 D7            push a
0959   0A09 11            mov a, b
0960   0A0A FD 2E 00 00   mov32 cb, $00000000
0960   0A0E 00 00 
0961   0A10 B0            cmp a, b
0962   0A11 FD 7F         sgt ; >
0963   0A13 E4            pop a
0964   0A14             ; --- END RELATIONAL
0965   0A14 C0 00 00      cmp b, 0
0966   0A17 C6 49 0A      je _while34_exit
0967   0A1A             _while34_block:
0968   0A1A             ; i--; 
0969   0A1A FA F5 FF      lea d, [bp + -11] ; $i
0970   0A1D 2A            mov b, [d]
0971   0A1E 38 00 00      mov c, 0
0972   0A21 11            mov a, b
0973   0A22 FD 7D         dec b
0974   0A24 FA F5 FF      lea d, [bp + -11] ; $i
0975   0A27 FD 43         mov [d], b
0976   0A29 27            mov b, a
0977   0A2A             ; putchar(digits[i]); 
0978   0A2A             ; --- START FUNCTION CALL
0979   0A2A FA F7 FF      lea d, [bp + -9] ; $digits
0980   0A2D D7            push a
0981   0A2E DA            push d
0982   0A2F FA F5 FF      lea d, [bp + -11] ; $i
0983   0A32 2A            mov b, [d]
0984   0A33 38 00 00      mov c, 0
0985   0A36 E7            pop d
0986   0A37 5A            add d, b
0987   0A38 E4            pop a
0988   0A39 32            mov bl, [d]
0989   0A3A A7 00         mov bh, 0
0990   0A3C 38 00 00      mov c, 0
0991   0A3F DD            push bl
0992   0A40 07 08 09      call putchar
0993   0A43 51 01 00      add sp, 1
0994   0A46             ; --- END FUNCTION CALL
0995   0A46 0A 01 0A      jmp _while34_cond
0996   0A49             _while34_exit:
0997   0A49 F9            leave
0998   0A4A 09            ret
0999   0A4B             
1000   0A4B             printx32:
1001   0A4B F8 00 00      enter 0 ; (push bp; mov bp, sp)
1002   0A4E             ; --- BEGIN INLINE ASM SEGMENT
1003   0A4E FA 05 00      lea d, [bp + 5] ; $hex
1004   0A51 2B 02 00      mov b, [d+2]
1005   0A54 07 5D 0A      call print_u16x_printx32
1006   0A57 2A            mov b, [d]
1007   0A58 07 5D 0A      call print_u16x_printx32
1008   0A5B             ; --- END INLINE ASM SEGMENT
1009   0A5B             ; return; 
1010   0A5B F9            leave
1011   0A5C 09            ret
1012   0A5D             ; --- BEGIN INLINE ASM SEGMENT
1013   0A5D             print_u16x_printx32:
1014   0A5D D7            push a
1015   0A5E D8            push b
1016   0A5F DD            push bl
1017   0A60 30            mov bl, bh
1018   0A61 07 7F 0A      call _itoa_printx32        ; convert bh to char in A
1019   0A64 2F            mov bl, al        ; save al
1020   0A65 19 00         mov al, 0
1021   0A67 05 03         syscall sys_io        ; display AH
1022   0A69 24            mov ah, bl        ; retrieve al
1023   0A6A 19 00         mov al, 0
1024   0A6C 05 03         syscall sys_io        ; display AL
1025   0A6E EA            pop bl
1026   0A6F 07 7F 0A      call _itoa_printx32        ; convert bh to char in A
1027   0A72 2F            mov bl, al        ; save al
1028   0A73 19 00         mov al, 0
1029   0A75 05 03         syscall sys_io        ; display AH
1030   0A77 24            mov ah, bl        ; retrieve al
1031   0A78 19 00         mov al, 0
1032   0A7A 05 03         syscall sys_io        ; display AL
1033   0A7C E5            pop b
1034   0A7D E4            pop a
1035   0A7E 09            ret
1036   0A7F             _itoa_printx32:
1037   0A7F DA            push d
1038   0A80 D8            push b
1039   0A81 A7 00         mov bh, 0
1040   0A83 FD A4 04      shr bl, 4  
1041   0A86 74            mov d, b
1042   0A87 1F 99 0A      mov al, [d + s_hex_digits_printx32]
1043   0A8A 23            mov ah, al
1044   0A8B E5            pop b
1045   0A8C D8            push b
1046   0A8D A7 00         mov bh, 0
1047   0A8F FD 87 0F      and bl, $0F
1048   0A92 74            mov d, b
1049   0A93 1F 99 0A      mov al, [d + s_hex_digits_printx32]
1050   0A96 E5            pop b
1051   0A97 E7            pop d
1052   0A98 09            ret
1053   0A99 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
1053   0A9D 34 35 36 37 
1053   0AA1 38 39 41 42 
1053   0AA5 43 44 45 46 
1054   0AA9             ; --- END INLINE ASM SEGMENT
1055   0AA9 F9            leave
1056   0AAA 09            ret
1057   0AAB             
1058   0AAB             err:
1059   0AAB F8 00 00      enter 0 ; (push bp; mov bp, sp)
1060   0AAE             ; print(e); 
1061   0AAE             ; --- START FUNCTION CALL
1062   0AAE FA 05 00      lea d, [bp + 5] ; $e
1063   0AB1 2A            mov b, [d]
1064   0AB2 38 00 00      mov c, 0
1065   0AB5 FD AB         swp b
1066   0AB7 D8            push b
1067   0AB8 07 C0 0A      call print
1068   0ABB 51 02 00      add sp, 2
1069   0ABE             ; --- END FUNCTION CALL
1070   0ABE F9            leave
1071   0ABF 09            ret
1072   0AC0             
1073   0AC0             print:
1074   0AC0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1075   0AC3             ; --- BEGIN INLINE ASM SEGMENT
1076   0AC3 FA 05 00      lea d, [bp + 5] ; $s
1077   0AC6 FD 2A         mov d, [d]
1078   0AC8             _puts_L1_print:
1079   0AC8 1E            mov al, [d]
1080   0AC9 B9 00         cmp al, 0
1081   0ACB C6 D7 0A      jz _puts_END_print
1082   0ACE 23            mov ah, al
1083   0ACF 19 00         mov al, 0
1084   0AD1 05 03         syscall sys_io
1085   0AD3 79            inc d
1086   0AD4 0A C8 0A      jmp _puts_L1_print
1087   0AD7             _puts_END_print:
1088   0AD7             ; --- END INLINE ASM SEGMENT
1089   0AD7 F9            leave
1090   0AD8 09            ret
1091   0AD9             
1092   0AD9             print_signed:
1093   0AD9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1094   0ADC             ; char digits[5]; 
1095   0ADC 52 05 00      sub sp, 5
1096   0ADF             ; int i = 0; 
1097   0ADF 52 02 00      sub sp, 2
1098   0AE2             ; --- START LOCAL VAR INITIALIZATION
1099   0AE2 FA FA FF      lea d, [bp + -6] ; $i
1100   0AE5 DA            push d
1101   0AE6 FD 2E 00 00   mov32 cb, $00000000
1101   0AEA 00 00 
1102   0AEC E7            pop d
1103   0AED FD 43         mov [d], b
1104   0AEF             ; --- END LOCAL VAR INITIALIZATION
1105   0AEF             ; if (num < 0) { 
1106   0AEF             _if35_cond:
1107   0AEF FA 05 00      lea d, [bp + 5] ; $num
1108   0AF2 2A            mov b, [d]
1109   0AF3 38 00 00      mov c, 0
1110   0AF6             ; --- START RELATIONAL
1111   0AF6 D7            push a
1112   0AF7 11            mov a, b
1113   0AF8 FD 2E 00 00   mov32 cb, $00000000
1113   0AFC 00 00 
1114   0AFE B0            cmp a, b
1115   0AFF FD 73         slt ; < (signed)
1116   0B01 E4            pop a
1117   0B02             ; --- END RELATIONAL
1118   0B02 C0 00 00      cmp b, 0
1119   0B05 C6 28 0B      je _if35_else
1120   0B08             _if35_TRUE:
1121   0B08             ; putchar('-'); 
1122   0B08             ; --- START FUNCTION CALL
1123   0B08 FD 2E 2D 00   mov32 cb, $0000002d
1123   0B0C 00 00 
1124   0B0E DD            push bl
1125   0B0F 07 08 09      call putchar
1126   0B12 51 01 00      add sp, 1
1127   0B15             ; --- END FUNCTION CALL
1128   0B15             ; num = -num; 
1129   0B15 FA 05 00      lea d, [bp + 5] ; $num
1130   0B18 DA            push d
1131   0B19 FA 05 00      lea d, [bp + 5] ; $num
1132   0B1C 2A            mov b, [d]
1133   0B1D 38 00 00      mov c, 0
1134   0B20 FD 97         neg b
1135   0B22 E7            pop d
1136   0B23 FD 43         mov [d], b
1137   0B25 0A 53 0B      jmp _if35_exit
1138   0B28             _if35_else:
1139   0B28             ; if (num == 0) { 
1140   0B28             _if36_cond:
1141   0B28 FA 05 00      lea d, [bp + 5] ; $num
1142   0B2B 2A            mov b, [d]
1143   0B2C 38 00 00      mov c, 0
1144   0B2F             ; --- START RELATIONAL
1145   0B2F D7            push a
1146   0B30 11            mov a, b
1147   0B31 FD 2E 00 00   mov32 cb, $00000000
1147   0B35 00 00 
1148   0B37 B0            cmp a, b
1149   0B38 FD 71         seq ; ==
1150   0B3A E4            pop a
1151   0B3B             ; --- END RELATIONAL
1152   0B3B C0 00 00      cmp b, 0
1153   0B3E C6 53 0B      je _if36_exit
1154   0B41             _if36_TRUE:
1155   0B41             ; putchar('0'); 
1156   0B41             ; --- START FUNCTION CALL
1157   0B41 FD 2E 30 00   mov32 cb, $00000030
1157   0B45 00 00 
1158   0B47 DD            push bl
1159   0B48 07 08 09      call putchar
1160   0B4B 51 01 00      add sp, 1
1161   0B4E             ; --- END FUNCTION CALL
1162   0B4E             ; return; 
1163   0B4E F9            leave
1164   0B4F 09            ret
1165   0B50 0A 53 0B      jmp _if36_exit
1166   0B53             _if36_exit:
1167   0B53             _if35_exit:
1168   0B53             ; while (num > 0) { 
1169   0B53             _while37_cond:
1170   0B53 FA 05 00      lea d, [bp + 5] ; $num
1171   0B56 2A            mov b, [d]
1172   0B57 38 00 00      mov c, 0
1173   0B5A             ; --- START RELATIONAL
1174   0B5A D7            push a
1175   0B5B 11            mov a, b
1176   0B5C FD 2E 00 00   mov32 cb, $00000000
1176   0B60 00 00 
1177   0B62 B0            cmp a, b
1178   0B63 FD 7F         sgt ; >
1179   0B65 E4            pop a
1180   0B66             ; --- END RELATIONAL
1181   0B66 C0 00 00      cmp b, 0
1182   0B69 C6 E0 0B      je _while37_exit
1183   0B6C             _while37_block:
1184   0B6C             ; digits[i] = '0' + (num % 10); 
1185   0B6C FA FC FF      lea d, [bp + -4] ; $digits
1186   0B6F D7            push a
1187   0B70 DA            push d
1188   0B71 FA FA FF      lea d, [bp + -6] ; $i
1189   0B74 2A            mov b, [d]
1190   0B75 38 00 00      mov c, 0
1191   0B78 E7            pop d
1192   0B79 5A            add d, b
1193   0B7A E4            pop a
1194   0B7B DA            push d
1195   0B7C FD 2E 30 00   mov32 cb, $00000030
1195   0B80 00 00 
1196   0B82             ; --- START TERMS
1197   0B82 D7            push a
1198   0B83 11            mov a, b
1199   0B84 FA 05 00      lea d, [bp + 5] ; $num
1200   0B87 2A            mov b, [d]
1201   0B88 38 00 00      mov c, 0
1202   0B8B             ; --- START FACTORS
1203   0B8B D7            push a
1204   0B8C FD D8         push g
1205   0B8E 11            mov a, b
1206   0B8F FD 7A         mov g, c
1207   0B91 FD 2E 0A 00   mov32 cb, $0000000a
1207   0B95 00 00 
1208   0B97 FD D8         push g ; save 'g' as the div instruction uses it
1209   0B99 AE            div a, b ; %, a: quotient, b: remainder
1210   0B9A 11            mov a, b
1211   0B9B FD F1         pop g
1212   0B9D FD 38         mov c, g
1213   0B9F 27            mov b, a
1214   0BA0 FD F1         pop g
1215   0BA2 E4            pop a
1216   0BA3             ; --- END FACTORS
1217   0BA3 56            add b, a
1218   0BA4 E4            pop a
1219   0BA5             ; --- END TERMS
1220   0BA5 E7            pop d
1221   0BA6 FD 3E         mov [d], bl
1222   0BA8             ; num = num / 10; 
1223   0BA8 FA 05 00      lea d, [bp + 5] ; $num
1224   0BAB DA            push d
1225   0BAC FA 05 00      lea d, [bp + 5] ; $num
1226   0BAF 2A            mov b, [d]
1227   0BB0 38 00 00      mov c, 0
1228   0BB3             ; --- START FACTORS
1229   0BB3 D7            push a
1230   0BB4 FD D8         push g
1231   0BB6 11            mov a, b
1232   0BB7 FD 7A         mov g, c
1233   0BB9 FD 2E 0A 00   mov32 cb, $0000000a
1233   0BBD 00 00 
1234   0BBF FD D8         push g ; save 'g' as the div instruction uses it
1235   0BC1 AE            div a, b ; /, a: quotient, b: remainder
1236   0BC2 FD F1         pop g
1237   0BC4 FD 38         mov c, g
1238   0BC6 27            mov b, a
1239   0BC7 FD F1         pop g
1240   0BC9 E4            pop a
1241   0BCA             ; --- END FACTORS
1242   0BCA E7            pop d
1243   0BCB FD 43         mov [d], b
1244   0BCD             ; i++; 
1245   0BCD FA FA FF      lea d, [bp + -6] ; $i
1246   0BD0 2A            mov b, [d]
1247   0BD1 38 00 00      mov c, 0
1248   0BD4 11            mov a, b
1249   0BD5 FD 77         inc b
1250   0BD7 FA FA FF      lea d, [bp + -6] ; $i
1251   0BDA FD 43         mov [d], b
1252   0BDC 27            mov b, a
1253   0BDD 0A 53 0B      jmp _while37_cond
1254   0BE0             _while37_exit:
1255   0BE0             ; while (i > 0) { 
1256   0BE0             _while44_cond:
1257   0BE0 FA FA FF      lea d, [bp + -6] ; $i
1258   0BE3 2A            mov b, [d]
1259   0BE4 38 00 00      mov c, 0
1260   0BE7             ; --- START RELATIONAL
1261   0BE7 D7            push a
1262   0BE8 11            mov a, b
1263   0BE9 FD 2E 00 00   mov32 cb, $00000000
1263   0BED 00 00 
1264   0BEF B0            cmp a, b
1265   0BF0 FD 7F         sgt ; >
1266   0BF2 E4            pop a
1267   0BF3             ; --- END RELATIONAL
1268   0BF3 C0 00 00      cmp b, 0
1269   0BF6 C6 28 0C      je _while44_exit
1270   0BF9             _while44_block:
1271   0BF9             ; i--; 
1272   0BF9 FA FA FF      lea d, [bp + -6] ; $i
1273   0BFC 2A            mov b, [d]
1274   0BFD 38 00 00      mov c, 0
1275   0C00 11            mov a, b
1276   0C01 FD 7D         dec b
1277   0C03 FA FA FF      lea d, [bp + -6] ; $i
1278   0C06 FD 43         mov [d], b
1279   0C08 27            mov b, a
1280   0C09             ; putchar(digits[i]); 
1281   0C09             ; --- START FUNCTION CALL
1282   0C09 FA FC FF      lea d, [bp + -4] ; $digits
1283   0C0C D7            push a
1284   0C0D DA            push d
1285   0C0E FA FA FF      lea d, [bp + -6] ; $i
1286   0C11 2A            mov b, [d]
1287   0C12 38 00 00      mov c, 0
1288   0C15 E7            pop d
1289   0C16 5A            add d, b
1290   0C17 E4            pop a
1291   0C18 32            mov bl, [d]
1292   0C19 A7 00         mov bh, 0
1293   0C1B 38 00 00      mov c, 0
1294   0C1E DD            push bl
1295   0C1F 07 08 09      call putchar
1296   0C22 51 01 00      add sp, 1
1297   0C25             ; --- END FUNCTION CALL
1298   0C25 0A E0 0B      jmp _while44_cond
1299   0C28             _while44_exit:
1300   0C28 F9            leave
1301   0C29 09            ret
1302   0C2A             
1303   0C2A             print_unsigned:
1304   0C2A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1305   0C2D             ; char digits[5]; 
1306   0C2D 52 05 00      sub sp, 5
1307   0C30             ; int i; 
1308   0C30 52 02 00      sub sp, 2
1309   0C33             ; i = 0; 
1310   0C33 FA FA FF      lea d, [bp + -6] ; $i
1311   0C36 DA            push d
1312   0C37 FD 2E 00 00   mov32 cb, $00000000
1312   0C3B 00 00 
1313   0C3D E7            pop d
1314   0C3E FD 43         mov [d], b
1315   0C40             ; if(num == 0){ 
1316   0C40             _if45_cond:
1317   0C40 FA 05 00      lea d, [bp + 5] ; $num
1318   0C43 2A            mov b, [d]
1319   0C44 38 00 00      mov c, 0
1320   0C47             ; --- START RELATIONAL
1321   0C47 D7            push a
1322   0C48 11            mov a, b
1323   0C49 FD 2E 00 00   mov32 cb, $00000000
1323   0C4D 00 00 
1324   0C4F B0            cmp a, b
1325   0C50 FD 71         seq ; ==
1326   0C52 E4            pop a
1327   0C53             ; --- END RELATIONAL
1328   0C53 C0 00 00      cmp b, 0
1329   0C56 C6 6B 0C      je _if45_exit
1330   0C59             _if45_TRUE:
1331   0C59             ; putchar('0'); 
1332   0C59             ; --- START FUNCTION CALL
1333   0C59 FD 2E 30 00   mov32 cb, $00000030
1333   0C5D 00 00 
1334   0C5F DD            push bl
1335   0C60 07 08 09      call putchar
1336   0C63 51 01 00      add sp, 1
1337   0C66             ; --- END FUNCTION CALL
1338   0C66             ; return; 
1339   0C66 F9            leave
1340   0C67 09            ret
1341   0C68 0A 6B 0C      jmp _if45_exit
1342   0C6B             _if45_exit:
1343   0C6B             ; while (num > 0) { 
1344   0C6B             _while46_cond:
1345   0C6B FA 05 00      lea d, [bp + 5] ; $num
1346   0C6E 2A            mov b, [d]
1347   0C6F 38 00 00      mov c, 0
1348   0C72             ; --- START RELATIONAL
1349   0C72 D7            push a
1350   0C73 11            mov a, b
1351   0C74 FD 2E 00 00   mov32 cb, $00000000
1351   0C78 00 00 
1352   0C7A B0            cmp a, b
1353   0C7B FD 81         sgu ; > (unsigned)
1354   0C7D E4            pop a
1355   0C7E             ; --- END RELATIONAL
1356   0C7E C0 00 00      cmp b, 0
1357   0C81 C6 F8 0C      je _while46_exit
1358   0C84             _while46_block:
1359   0C84             ; digits[i] = '0' + (num % 10); 
1360   0C84 FA FC FF      lea d, [bp + -4] ; $digits
1361   0C87 D7            push a
1362   0C88 DA            push d
1363   0C89 FA FA FF      lea d, [bp + -6] ; $i
1364   0C8C 2A            mov b, [d]
1365   0C8D 38 00 00      mov c, 0
1366   0C90 E7            pop d
1367   0C91 5A            add d, b
1368   0C92 E4            pop a
1369   0C93 DA            push d
1370   0C94 FD 2E 30 00   mov32 cb, $00000030
1370   0C98 00 00 
1371   0C9A             ; --- START TERMS
1372   0C9A D7            push a
1373   0C9B 11            mov a, b
1374   0C9C FA 05 00      lea d, [bp + 5] ; $num
1375   0C9F 2A            mov b, [d]
1376   0CA0 38 00 00      mov c, 0
1377   0CA3             ; --- START FACTORS
1378   0CA3 D7            push a
1379   0CA4 FD D8         push g
1380   0CA6 11            mov a, b
1381   0CA7 FD 7A         mov g, c
1382   0CA9 FD 2E 0A 00   mov32 cb, $0000000a
1382   0CAD 00 00 
1383   0CAF FD D8         push g ; save 'g' as the div instruction uses it
1384   0CB1 AE            div a, b ; %, a: quotient, b: remainder
1385   0CB2 11            mov a, b
1386   0CB3 FD F1         pop g
1387   0CB5 FD 38         mov c, g
1388   0CB7 27            mov b, a
1389   0CB8 FD F1         pop g
1390   0CBA E4            pop a
1391   0CBB             ; --- END FACTORS
1392   0CBB 56            add b, a
1393   0CBC E4            pop a
1394   0CBD             ; --- END TERMS
1395   0CBD E7            pop d
1396   0CBE FD 3E         mov [d], bl
1397   0CC0             ; num = num / 10; 
1398   0CC0 FA 05 00      lea d, [bp + 5] ; $num
1399   0CC3 DA            push d
1400   0CC4 FA 05 00      lea d, [bp + 5] ; $num
1401   0CC7 2A            mov b, [d]
1402   0CC8 38 00 00      mov c, 0
1403   0CCB             ; --- START FACTORS
1404   0CCB D7            push a
1405   0CCC FD D8         push g
1406   0CCE 11            mov a, b
1407   0CCF FD 7A         mov g, c
1408   0CD1 FD 2E 0A 00   mov32 cb, $0000000a
1408   0CD5 00 00 
1409   0CD7 FD D8         push g ; save 'g' as the div instruction uses it
1410   0CD9 AE            div a, b ; /, a: quotient, b: remainder
1411   0CDA FD F1         pop g
1412   0CDC FD 38         mov c, g
1413   0CDE 27            mov b, a
1414   0CDF FD F1         pop g
1415   0CE1 E4            pop a
1416   0CE2             ; --- END FACTORS
1417   0CE2 E7            pop d
1418   0CE3 FD 43         mov [d], b
1419   0CE5             ; i++; 
1420   0CE5 FA FA FF      lea d, [bp + -6] ; $i
1421   0CE8 2A            mov b, [d]
1422   0CE9 38 00 00      mov c, 0
1423   0CEC 11            mov a, b
1424   0CED FD 77         inc b
1425   0CEF FA FA FF      lea d, [bp + -6] ; $i
1426   0CF2 FD 43         mov [d], b
1427   0CF4 27            mov b, a
1428   0CF5 0A 6B 0C      jmp _while46_cond
1429   0CF8             _while46_exit:
1430   0CF8             ; while (i > 0) { 
1431   0CF8             _while53_cond:
1432   0CF8 FA FA FF      lea d, [bp + -6] ; $i
1433   0CFB 2A            mov b, [d]
1434   0CFC 38 00 00      mov c, 0
1435   0CFF             ; --- START RELATIONAL
1436   0CFF D7            push a
1437   0D00 11            mov a, b
1438   0D01 FD 2E 00 00   mov32 cb, $00000000
1438   0D05 00 00 
1439   0D07 B0            cmp a, b
1440   0D08 FD 7F         sgt ; >
1441   0D0A E4            pop a
1442   0D0B             ; --- END RELATIONAL
1443   0D0B C0 00 00      cmp b, 0
1444   0D0E C6 40 0D      je _while53_exit
1445   0D11             _while53_block:
1446   0D11             ; i--; 
1447   0D11 FA FA FF      lea d, [bp + -6] ; $i
1448   0D14 2A            mov b, [d]
1449   0D15 38 00 00      mov c, 0
1450   0D18 11            mov a, b
1451   0D19 FD 7D         dec b
1452   0D1B FA FA FF      lea d, [bp + -6] ; $i
1453   0D1E FD 43         mov [d], b
1454   0D20 27            mov b, a
1455   0D21             ; putchar(digits[i]); 
1456   0D21             ; --- START FUNCTION CALL
1457   0D21 FA FC FF      lea d, [bp + -4] ; $digits
1458   0D24 D7            push a
1459   0D25 DA            push d
1460   0D26 FA FA FF      lea d, [bp + -6] ; $i
1461   0D29 2A            mov b, [d]
1462   0D2A 38 00 00      mov c, 0
1463   0D2D E7            pop d
1464   0D2E 5A            add d, b
1465   0D2F E4            pop a
1466   0D30 32            mov bl, [d]
1467   0D31 A7 00         mov bh, 0
1468   0D33 38 00 00      mov c, 0
1469   0D36 DD            push bl
1470   0D37 07 08 09      call putchar
1471   0D3A 51 01 00      add sp, 1
1472   0D3D             ; --- END FUNCTION CALL
1473   0D3D 0A F8 0C      jmp _while53_cond
1474   0D40             _while53_exit:
1475   0D40 F9            leave
1476   0D41 09            ret
1477   0D42             
1478   0D42             printx16:
1479   0D42 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1480   0D45             ; --- BEGIN INLINE ASM SEGMENT
1481   0D45 FA 05 00      lea d, [bp + 5] ; $hex
1482   0D48 2A            mov b, [d]
1483   0D49             print_u16x_printx16:
1484   0D49 DD            push bl
1485   0D4A 30            mov bl, bh
1486   0D4B 07 68 0D      call _itoa_printx16        ; convert bh to char in A
1487   0D4E 2F            mov bl, al        ; save al
1488   0D4F 19 00         mov al, 0
1489   0D51 05 03         syscall sys_io        ; display AH
1490   0D53 24            mov ah, bl        ; retrieve al
1491   0D54 19 00         mov al, 0
1492   0D56 05 03         syscall sys_io        ; display AL
1493   0D58 EA            pop bl
1494   0D59 07 68 0D      call _itoa_printx16        ; convert bh to char in A
1495   0D5C 2F            mov bl, al        ; save al
1496   0D5D 19 00         mov al, 0
1497   0D5F 05 03         syscall sys_io        ; display AH
1498   0D61 24            mov ah, bl        ; retrieve al
1499   0D62 19 00         mov al, 0
1500   0D64 05 03         syscall sys_io        ; display AL
1501   0D66             ; --- END INLINE ASM SEGMENT
1502   0D66             ; return; 
1503   0D66 F9            leave
1504   0D67 09            ret
1505   0D68             ; --- BEGIN INLINE ASM SEGMENT
1506   0D68             _itoa_printx16:
1507   0D68 DA            push d
1508   0D69 D8            push b
1509   0D6A A7 00         mov bh, 0
1510   0D6C FD A4 04      shr bl, 4  
1511   0D6F 74            mov d, b
1512   0D70 1F 82 0D      mov al, [d + s_hex_digits_printx16]
1513   0D73 23            mov ah, al
1514   0D74 E5            pop b
1515   0D75 D8            push b
1516   0D76 A7 00         mov bh, 0
1517   0D78 FD 87 0F      and bl, $0F
1518   0D7B 74            mov d, b
1519   0D7C 1F 82 0D      mov al, [d + s_hex_digits_printx16]
1520   0D7F E5            pop b
1521   0D80 E7            pop d
1522   0D81 09            ret
1523   0D82 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
1523   0D86 34 35 36 37 
1523   0D8A 38 39 41 42 
1523   0D8E 43 44 45 46 
1524   0D92             ; --- END INLINE ASM SEGMENT
1525   0D92 F9            leave
1526   0D93 09            ret
1527   0D94             ; --- END TEXT SEGMENT
1528   0D94             
1529   0D94             ; --- BEGIN DATA SEGMENT
1530   0D94 25 64 00    _s0: .db "%d", 0
1531   0D97 55 6E 65 78 _s1: .db "Unexpected format in printf.", 0
1531   0D9B 70 65 63 74 
1531   0D9F 65 64 20 66 
1531   0DA3 6F 72 6D 61 
1531   0DA7 74 20 69 6E 
1531   0DAB 20 70 72 69 
1531   0DAF 6E 74 66 2E 
1531   0DB3 00 
1532   0DB4 45 72 72 6F _s2: .db "Error: Unknown argument type.\n", 0
1532   0DB8 72 3A 20 55 
1532   0DBC 6E 6B 6E 6F 
1532   0DC0 77 6E 20 61 
1532   0DC4 72 67 75 6D 
1532   0DC8 65 6E 74 20 
1532   0DCC 74 79 70 65 
1532   0DD0 2E 0A 00 
1533   0DD3             
1534   0DD3 D5 0D       _heap_top: .dw _heap
1535   0DD5 00          _heap: .db 0
1536   0DD6             ; --- END DATA SEGMENT
1537   0DD6             
1538   0DD6             .end
tasm: Number of errors = 0
