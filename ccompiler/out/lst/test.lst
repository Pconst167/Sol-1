0001   0000             ; --- FILENAME: test
0002   0000             .include "lib/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; $aa 
0011   0408 52 02 00      sub sp, 2
0012   040B             ;; printf("Char: %c, String: %s, Integer: %d", 'A', "Paulo", 1); 
0013   040B 26 01 00      mov b, $1
0014   040E FD AB         swp b
0015   0410 D8            push b
0016   0411 26 09 11      mov b, __s0 ; "Paulo"
0017   0414 FD AB         swp b
0018   0416 D8            push b
0019   0417 26 41 00      mov b, $41
0020   041A FD AB         swp b
0021   041C D8            push b
0022   041D 26 0F 11      mov b, __s1 ; "Char: %c, String: %s, Integer: %d"
0023   0420 FD AB         swp b
0024   0422 D8            push b
0025   0423 07 F0 05      call printf
0026   0426 51 08 00      add sp, 8
0027   0429 05 0B         syscall sys_terminate_proc
0028   042B             
0029   042B             strcpy:
0030   042B F8 00 00      enter 0 ; (push bp; mov bp, sp)
0031   042E             ; $psrc 
0032   042E             ; $pdest 
0033   042E 52 04 00      sub sp, 4
0034   0431             ;; psrc = src; 
0035   0431 FA FF FF      lea d, [bp + -1] ; $psrc
0036   0434 DA            push d
0037   0435 FA 05 00      lea d, [bp + 5] ; $src
0038   0438 2A            mov b, [d]
0039   0439 E7            pop d
0040   043A FD 43         mov [d], b
0041   043C             ;; pdest = dest; 
0042   043C FA FD FF      lea d, [bp + -3] ; $pdest
0043   043F DA            push d
0044   0440 FA 07 00      lea d, [bp + 7] ; $dest
0045   0443 2A            mov b, [d]
0046   0444 E7            pop d
0047   0445 FD 43         mov [d], b
0048   0447             ;; while(*psrc) *pdest++ = *psrc++; 
0049   0447             _while1_cond:
0050   0447 FA FF FF      lea d, [bp + -1] ; $psrc
0051   044A 2A            mov b, [d]
0052   044B 74            mov d, b
0053   044C 32            mov bl, [d]
0054   044D A7 00         mov bh, 0
0055   044F C0 00 00      cmp b, 0
0056   0452 C6 7E 04      je _while1_exit
0057   0455             _while1_block:
0058   0455             ;; *pdest++ = *psrc++; 
0059   0455 FA FD FF      lea d, [bp + -3] ; $pdest
0060   0458 2A            mov b, [d]
0061   0459 FD 79         mov g, b
0062   045B FD 77         inc b
0063   045D FA FD FF      lea d, [bp + -3] ; $pdest
0064   0460 FD 43         mov [d], b
0065   0462 FD 27         mov b, g
0066   0464 D8            push b
0067   0465 FA FF FF      lea d, [bp + -1] ; $psrc
0068   0468 2A            mov b, [d]
0069   0469 FD 79         mov g, b
0070   046B FD 77         inc b
0071   046D FA FF FF      lea d, [bp + -1] ; $psrc
0072   0470 FD 43         mov [d], b
0073   0472 FD 27         mov b, g
0074   0474 74            mov d, b
0075   0475 32            mov bl, [d]
0076   0476 A7 00         mov bh, 0
0077   0478 E7            pop d
0078   0479 FD 3E         mov [d], bl
0079   047B 0A 47 04      jmp _while1_cond
0080   047E             _while1_exit:
0081   047E             ;; *pdest = '\0'; 
0082   047E FA FD FF      lea d, [bp + -3] ; $pdest
0083   0481 2A            mov b, [d]
0084   0482 D8            push b
0085   0483 26 00 00      mov b, $0
0086   0486 E7            pop d
0087   0487 FD 3E         mov [d], bl
0088   0489 F9            leave
0089   048A 09            ret
0090   048B             
0091   048B             strcmp:
0092   048B F8 00 00      enter 0 ; (push bp; mov bp, sp)
0093   048E             ;; while (*s1 && (*s1 == *s2)) { 
0094   048E             _while2_cond:
0095   048E FA 07 00      lea d, [bp + 7] ; $s1
0096   0491 2A            mov b, [d]
0097   0492 74            mov d, b
0098   0493 32            mov bl, [d]
0099   0494 A7 00         mov bh, 0
0100   0496 D7            push a
0101   0497 11            mov a, b
0102   0498 FA 07 00      lea d, [bp + 7] ; $s1
0103   049B 2A            mov b, [d]
0104   049C 74            mov d, b
0105   049D 32            mov bl, [d]
0106   049E A7 00         mov bh, 0
0107   04A0             ; START RELATIONAL
0108   04A0 D7            push a
0109   04A1 11            mov a, b
0110   04A2 FA 05 00      lea d, [bp + 5] ; $s2
0111   04A5 2A            mov b, [d]
0112   04A6 74            mov d, b
0113   04A7 32            mov bl, [d]
0114   04A8 A7 00         mov bh, 0
0115   04AA B0            cmp a, b
0116   04AB FD 71         seq ; ==
0117   04AD E4            pop a
0118   04AE             ; END RELATIONAL
0119   04AE FD A7         sand a, b ; &&
0120   04B0 E4            pop a
0121   04B1 C0 00 00      cmp b, 0
0122   04B4 C6 D8 04      je _while2_exit
0123   04B7             _while2_block:
0124   04B7             ;; s1++; 
0125   04B7 FA 07 00      lea d, [bp + 7] ; $s1
0126   04BA 2A            mov b, [d]
0127   04BB FD 79         mov g, b
0128   04BD FD 77         inc b
0129   04BF FA 07 00      lea d, [bp + 7] ; $s1
0130   04C2 FD 43         mov [d], b
0131   04C4 FD 27         mov b, g
0132   04C6             ;; s2++; 
0133   04C6 FA 05 00      lea d, [bp + 5] ; $s2
0134   04C9 2A            mov b, [d]
0135   04CA FD 79         mov g, b
0136   04CC FD 77         inc b
0137   04CE FA 05 00      lea d, [bp + 5] ; $s2
0138   04D1 FD 43         mov [d], b
0139   04D3 FD 27         mov b, g
0140   04D5 0A 8E 04      jmp _while2_cond
0141   04D8             _while2_exit:
0142   04D8             ;; return *s1 - *s2; 
0143   04D8 FA 07 00      lea d, [bp + 7] ; $s1
0144   04DB 2A            mov b, [d]
0145   04DC 74            mov d, b
0146   04DD 32            mov bl, [d]
0147   04DE A7 00         mov bh, 0
0148   04E0             ; START TERMS
0149   04E0 D7            push a
0150   04E1 11            mov a, b
0151   04E2 FA 05 00      lea d, [bp + 5] ; $s2
0152   04E5 2A            mov b, [d]
0153   04E6 74            mov d, b
0154   04E7 32            mov bl, [d]
0155   04E8 A7 00         mov bh, 0
0156   04EA 60            sub a, b
0157   04EB 27            mov b, a
0158   04EC E4            pop a
0159   04ED             ; END TERMS
0160   04ED F9            leave
0161   04EE 09            ret
0162   04EF             
0163   04EF             strcat:
0164   04EF F8 00 00      enter 0 ; (push bp; mov bp, sp)
0165   04F2             ; $dest_len 
0166   04F2             ; $i 
0167   04F2 52 04 00      sub sp, 4
0168   04F5             ;; dest_len = strlen(dest); 
0169   04F5 FA FF FF      lea d, [bp + -1] ; $dest_len
0170   04F8 DA            push d
0171   04F9 FA 07 00      lea d, [bp + 7] ; $dest
0172   04FC 2A            mov b, [d]
0173   04FD FD AB         swp b
0174   04FF D8            push b
0175   0500 07 A5 05      call strlen
0176   0503 51 02 00      add sp, 2
0177   0506 E7            pop d
0178   0507 FD 43         mov [d], b
0179   0509             ;; for (i = 0; src[i] != 0; i=i+1) { 
0180   0509             _for3_init:
0181   0509 FA FD FF      lea d, [bp + -3] ; $i
0182   050C DA            push d
0183   050D 26 00 00      mov b, $0
0184   0510 E7            pop d
0185   0511 FD 43         mov [d], b
0186   0513             _for3_cond:
0187   0513 FA 05 00      lea d, [bp + 5] ; $src
0188   0516 FD 2A         mov d, [d]
0189   0518 D7            push a
0190   0519 DA            push d
0191   051A FA FD FF      lea d, [bp + -3] ; $i
0192   051D 2A            mov b, [d]
0193   051E E7            pop d
0194   051F FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0195   0523 E4            pop a
0196   0524 32            mov bl, [d]
0197   0525 A7 00         mov bh, 0
0198   0527             ; START RELATIONAL
0199   0527 D7            push a
0200   0528 11            mov a, b
0201   0529 26 00 00      mov b, $0
0202   052C B0            cmp a, b
0203   052D FD 72         sneq ; !=
0204   052F E4            pop a
0205   0530             ; END RELATIONAL
0206   0530 C0 00 00      cmp b, 0
0207   0533 C6 7E 05      je _for3_exit
0208   0536             _for3_block:
0209   0536             ;; dest[dest_len + i] = src[i]; 
0210   0536 FA 07 00      lea d, [bp + 7] ; $dest
0211   0539 FD 2A         mov d, [d]
0212   053B D7            push a
0213   053C DA            push d
0214   053D FA FF FF      lea d, [bp + -1] ; $dest_len
0215   0540 2A            mov b, [d]
0216   0541             ; START TERMS
0217   0541 D7            push a
0218   0542 11            mov a, b
0219   0543 FA FD FF      lea d, [bp + -3] ; $i
0220   0546 2A            mov b, [d]
0221   0547 54            add a, b
0222   0548 27            mov b, a
0223   0549 E4            pop a
0224   054A             ; END TERMS
0225   054A E7            pop d
0226   054B FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0227   054F E4            pop a
0228   0550 DA            push d
0229   0551 FA 05 00      lea d, [bp + 5] ; $src
0230   0554 FD 2A         mov d, [d]
0231   0556 D7            push a
0232   0557 DA            push d
0233   0558 FA FD FF      lea d, [bp + -3] ; $i
0234   055B 2A            mov b, [d]
0235   055C E7            pop d
0236   055D FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0237   0561 E4            pop a
0238   0562 32            mov bl, [d]
0239   0563 A7 00         mov bh, 0
0240   0565 E7            pop d
0241   0566 FD 3E         mov [d], bl
0242   0568             _for3_update:
0243   0568 FA FD FF      lea d, [bp + -3] ; $i
0244   056B DA            push d
0245   056C FA FD FF      lea d, [bp + -3] ; $i
0246   056F 2A            mov b, [d]
0247   0570             ; START TERMS
0248   0570 D7            push a
0249   0571 11            mov a, b
0250   0572 26 01 00      mov b, $1
0251   0575 54            add a, b
0252   0576 27            mov b, a
0253   0577 E4            pop a
0254   0578             ; END TERMS
0255   0578 E7            pop d
0256   0579 FD 43         mov [d], b
0257   057B 0A 13 05      jmp _for3_cond
0258   057E             _for3_exit:
0259   057E             ;; dest[dest_len + i] = 0; 
0260   057E FA 07 00      lea d, [bp + 7] ; $dest
0261   0581 FD 2A         mov d, [d]
0262   0583 D7            push a
0263   0584 DA            push d
0264   0585 FA FF FF      lea d, [bp + -1] ; $dest_len
0265   0588 2A            mov b, [d]
0266   0589             ; START TERMS
0267   0589 D7            push a
0268   058A 11            mov a, b
0269   058B FA FD FF      lea d, [bp + -3] ; $i
0270   058E 2A            mov b, [d]
0271   058F 54            add a, b
0272   0590 27            mov b, a
0273   0591 E4            pop a
0274   0592             ; END TERMS
0275   0592 E7            pop d
0276   0593 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0277   0597 E4            pop a
0278   0598 DA            push d
0279   0599 26 00 00      mov b, $0
0280   059C E7            pop d
0281   059D FD 3E         mov [d], bl
0282   059F             ;; return dest; 
0283   059F FA 07 00      lea d, [bp + 7] ; $dest
0284   05A2 2A            mov b, [d]
0285   05A3 F9            leave
0286   05A4 09            ret
0287   05A5             
0288   05A5             strlen:
0289   05A5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0290   05A8             ; $length 
0291   05A8 52 02 00      sub sp, 2
0292   05AB             ;; length = 0; 
0293   05AB FA FF FF      lea d, [bp + -1] ; $length
0294   05AE DA            push d
0295   05AF 26 00 00      mov b, $0
0296   05B2 E7            pop d
0297   05B3 FD 43         mov [d], b
0298   05B5             ;; while (str[length] != 0) { 
0299   05B5             _while4_cond:
0300   05B5 FA 05 00      lea d, [bp + 5] ; $str
0301   05B8 FD 2A         mov d, [d]
0302   05BA D7            push a
0303   05BB DA            push d
0304   05BC FA FF FF      lea d, [bp + -1] ; $length
0305   05BF 2A            mov b, [d]
0306   05C0 E7            pop d
0307   05C1 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0308   05C5 E4            pop a
0309   05C6 32            mov bl, [d]
0310   05C7 A7 00         mov bh, 0
0311   05C9             ; START RELATIONAL
0312   05C9 D7            push a
0313   05CA 11            mov a, b
0314   05CB 26 00 00      mov b, $0
0315   05CE B0            cmp a, b
0316   05CF FD 72         sneq ; !=
0317   05D1 E4            pop a
0318   05D2             ; END RELATIONAL
0319   05D2 C0 00 00      cmp b, 0
0320   05D5 C6 EA 05      je _while4_exit
0321   05D8             _while4_block:
0322   05D8             ;; length++; 
0323   05D8 FA FF FF      lea d, [bp + -1] ; $length
0324   05DB 2A            mov b, [d]
0325   05DC FD 79         mov g, b
0326   05DE FD 77         inc b
0327   05E0 FA FF FF      lea d, [bp + -1] ; $length
0328   05E3 FD 43         mov [d], b
0329   05E5 FD 27         mov b, g
0330   05E7 0A B5 05      jmp _while4_cond
0331   05EA             _while4_exit:
0332   05EA             ;; return length; 
0333   05EA FA FF FF      lea d, [bp + -1] ; $length
0334   05ED 2A            mov b, [d]
0335   05EE F9            leave
0336   05EF 09            ret
0337   05F0             
0338   05F0             printf:
0339   05F0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0340   05F3             ; $p 
0341   05F3             ; $fp 
0342   05F3             ; $i 
0343   05F3 52 06 00      sub sp, 6
0344   05F6             ;; fp = format; 
0345   05F6 FA FD FF      lea d, [bp + -3] ; $fp
0346   05F9 DA            push d
0347   05FA FA 05 00      lea d, [bp + 5] ; $format
0348   05FD 2A            mov b, [d]
0349   05FE E7            pop d
0350   05FF FD 43         mov [d], b
0351   0601             ;; p = &format + 2; 
0352   0601 FA FF FF      lea d, [bp + -1] ; $p
0353   0604 DA            push d
0354   0605 FA 05 00      lea d, [bp + 5] ; $format
0355   0608 2D            mov b, d
0356   0609             ; START TERMS
0357   0609 D7            push a
0358   060A 11            mov a, b
0359   060B 26 02 00      mov b, $2
0360   060E 54            add a, b
0361   060F 27            mov b, a
0362   0610 E4            pop a
0363   0611             ; END TERMS
0364   0611 E7            pop d
0365   0612 FD 43         mov [d], b
0366   0614             ;; for(;;){ 
0367   0614             _for5_init:
0368   0614             _for5_cond:
0369   0614             _for5_block:
0370   0614             ;; if(!*fp) break; 
0371   0614             _if6_cond:
0372   0614 FA FD FF      lea d, [bp + -3] ; $fp
0373   0617 2A            mov b, [d]
0374   0618 74            mov d, b
0375   0619 32            mov bl, [d]
0376   061A A7 00         mov bh, 0
0377   061C C0 00 00      cmp b, 0
0378   061F FD 71         seq ; !
0379   0621 C0 00 00      cmp b, 0
0380   0624 C6 2D 06      je _if6_else
0381   0627             _if6_true:
0382   0627             ;; break; 
0383   0627 0A 77 07      jmp _for5_exit ; for break
0384   062A 0A 74 07      jmp _if6_exit
0385   062D             _if6_else:
0386   062D             ;; if(*fp == '%'){ 
0387   062D             _if7_cond:
0388   062D FA FD FF      lea d, [bp + -3] ; $fp
0389   0630 2A            mov b, [d]
0390   0631 74            mov d, b
0391   0632 32            mov bl, [d]
0392   0633 A7 00         mov bh, 0
0393   0635             ; START RELATIONAL
0394   0635 D7            push a
0395   0636 11            mov a, b
0396   0637 26 25 00      mov b, $25
0397   063A B0            cmp a, b
0398   063B FD 71         seq ; ==
0399   063D E4            pop a
0400   063E             ; END RELATIONAL
0401   063E C0 00 00      cmp b, 0
0402   0641 C6 56 07      je _if7_else
0403   0644             _if7_true:
0404   0644             ;; fp++; 
0405   0644 FA FD FF      lea d, [bp + -3] ; $fp
0406   0647 2A            mov b, [d]
0407   0648 FD 79         mov g, b
0408   064A FD 77         inc b
0409   064C FA FD FF      lea d, [bp + -3] ; $fp
0410   064F FD 43         mov [d], b
0411   0651 FD 27         mov b, g
0412   0653             ;; switch(*fp){ 
0413   0653             _switch8_expr:
0414   0653 FA FD FF      lea d, [bp + -3] ; $fp
0415   0656 2A            mov b, [d]
0416   0657 74            mov d, b
0417   0658 32            mov bl, [d]
0418   0659 A7 00         mov bh, 0
0419   065B             _switch8_comparisons:
0420   065B C1 64         cmp bl, $64
0421   065D C6 7F 06      je _switch8_case0
0422   0660 C1 69         cmp bl, $69
0423   0662 C6 7F 06      je _switch8_case1
0424   0665 C1 75         cmp bl, $75
0425   0667 C6 A4 06      je _switch8_case2
0426   066A C1 78         cmp bl, $78
0427   066C C6 C9 06      je _switch8_case3
0428   066F C1 63         cmp bl, $63
0429   0671 C6 EE 06      je _switch8_case4
0430   0674 C1 73         cmp bl, $73
0431   0676 C6 13 07      je _switch8_case5
0432   0679 0A 38 07      jmp _switch8_default
0433   067C 0A 44 07      jmp _switch8_exit
0434   067F             _switch8_case0:
0435   067F             _switch8_case1:
0436   067F             ;; prints(*(int*)p); 
0437   067F FA FF FF      lea d, [bp + -1] ; $p
0438   0682 2A            mov b, [d]
0439   0683 74            mov d, b
0440   0684 2A            mov b, [d]
0441   0685 FD AB         swp b
0442   0687 D8            push b
0443   0688 07 09 0A      call prints
0444   068B 51 02 00      add sp, 2
0445   068E             ;; p = p + 2; 
0446   068E FA FF FF      lea d, [bp + -1] ; $p
0447   0691 DA            push d
0448   0692 FA FF FF      lea d, [bp + -1] ; $p
0449   0695 2A            mov b, [d]
0450   0696             ; START TERMS
0451   0696 D7            push a
0452   0697 11            mov a, b
0453   0698 26 02 00      mov b, $2
0454   069B 54            add a, b
0455   069C 27            mov b, a
0456   069D E4            pop a
0457   069E             ; END TERMS
0458   069E E7            pop d
0459   069F FD 43         mov [d], b
0460   06A1             ;; break; 
0461   06A1 0A 44 07      jmp _switch8_exit ; case break
0462   06A4             _switch8_case2:
0463   06A4             ;; printu(*(unsigned int*)p); 
0464   06A4 FA FF FF      lea d, [bp + -1] ; $p
0465   06A7 2A            mov b, [d]
0466   06A8 74            mov d, b
0467   06A9 2A            mov b, [d]
0468   06AA FD AB         swp b
0469   06AC D8            push b
0470   06AD 07 FE 0A      call printu
0471   06B0 51 02 00      add sp, 2
0472   06B3             ;; p = p + 2; 
0473   06B3 FA FF FF      lea d, [bp + -1] ; $p
0474   06B6 DA            push d
0475   06B7 FA FF FF      lea d, [bp + -1] ; $p
0476   06BA 2A            mov b, [d]
0477   06BB             ; START TERMS
0478   06BB D7            push a
0479   06BC 11            mov a, b
0480   06BD 26 02 00      mov b, $2
0481   06C0 54            add a, b
0482   06C1 27            mov b, a
0483   06C2 E4            pop a
0484   06C3             ; END TERMS
0485   06C3 E7            pop d
0486   06C4 FD 43         mov [d], b
0487   06C6             ;; break; 
0488   06C6 0A 44 07      jmp _switch8_exit ; case break
0489   06C9             _switch8_case3:
0490   06C9             ;; printx16(*(unsigned int*)p); 
0491   06C9 FA FF FF      lea d, [bp + -1] ; $p
0492   06CC 2A            mov b, [d]
0493   06CD 74            mov d, b
0494   06CE 2A            mov b, [d]
0495   06CF FD AB         swp b
0496   06D1 D8            push b
0497   06D2 07 79 07      call printx16
0498   06D5 51 02 00      add sp, 2
0499   06D8             ;; p = p + 2; 
0500   06D8 FA FF FF      lea d, [bp + -1] ; $p
0501   06DB DA            push d
0502   06DC FA FF FF      lea d, [bp + -1] ; $p
0503   06DF 2A            mov b, [d]
0504   06E0             ; START TERMS
0505   06E0 D7            push a
0506   06E1 11            mov a, b
0507   06E2 26 02 00      mov b, $2
0508   06E5 54            add a, b
0509   06E6 27            mov b, a
0510   06E7 E4            pop a
0511   06E8             ; END TERMS
0512   06E8 E7            pop d
0513   06E9 FD 43         mov [d], b
0514   06EB             ;; break; 
0515   06EB 0A 44 07      jmp _switch8_exit ; case break
0516   06EE             _switch8_case4:
0517   06EE             ;; putchar(*(char*)p); 
0518   06EE FA FF FF      lea d, [bp + -1] ; $p
0519   06F1 2A            mov b, [d]
0520   06F2 74            mov d, b
0521   06F3 32            mov bl, [d]
0522   06F4 A7 00         mov bh, 0
0523   06F6 DD            push bl
0524   06F7 07 EA 0B      call putchar
0525   06FA 51 01 00      add sp, 1
0526   06FD             ;; p = p + 2; 
0527   06FD FA FF FF      lea d, [bp + -1] ; $p
0528   0700 DA            push d
0529   0701 FA FF FF      lea d, [bp + -1] ; $p
0530   0704 2A            mov b, [d]
0531   0705             ; START TERMS
0532   0705 D7            push a
0533   0706 11            mov a, b
0534   0707 26 02 00      mov b, $2
0535   070A 54            add a, b
0536   070B 27            mov b, a
0537   070C E4            pop a
0538   070D             ; END TERMS
0539   070D E7            pop d
0540   070E FD 43         mov [d], b
0541   0710             ;; break; 
0542   0710 0A 44 07      jmp _switch8_exit ; case break
0543   0713             _switch8_case5:
0544   0713             ;; print(*(char**)p); 
0545   0713 FA FF FF      lea d, [bp + -1] ; $p
0546   0716 2A            mov b, [d]
0547   0717 74            mov d, b
0548   0718 2A            mov b, [d]
0549   0719 FD AB         swp b
0550   071B D8            push b
0551   071C 07 32 0C      call print
0552   071F 51 02 00      add sp, 2
0553   0722             ;; p = p + 2; 
0554   0722 FA FF FF      lea d, [bp + -1] ; $p
0555   0725 DA            push d
0556   0726 FA FF FF      lea d, [bp + -1] ; $p
0557   0729 2A            mov b, [d]
0558   072A             ; START TERMS
0559   072A D7            push a
0560   072B 11            mov a, b
0561   072C 26 02 00      mov b, $2
0562   072F 54            add a, b
0563   0730 27            mov b, a
0564   0731 E4            pop a
0565   0732             ; END TERMS
0566   0732 E7            pop d
0567   0733 FD 43         mov [d], b
0568   0735             ;; break; 
0569   0735 0A 44 07      jmp _switch8_exit ; case break
0570   0738             _switch8_default:
0571   0738             ;; print("Error: Unknown argument type.\n"); 
0572   0738 26 31 11      mov b, __s2 ; "Error: Unknown argument type.\n"
0573   073B FD AB         swp b
0574   073D D8            push b
0575   073E 07 32 0C      call print
0576   0741 51 02 00      add sp, 2
0577   0744             _switch8_exit:
0578   0744             ;; fp++; 
0579   0744 FA FD FF      lea d, [bp + -3] ; $fp
0580   0747 2A            mov b, [d]
0581   0748 FD 79         mov g, b
0582   074A FD 77         inc b
0583   074C FA FD FF      lea d, [bp + -3] ; $fp
0584   074F FD 43         mov [d], b
0585   0751 FD 27         mov b, g
0586   0753 0A 74 07      jmp _if7_exit
0587   0756             _if7_else:
0588   0756             ;; putchar(*fp); 
0589   0756 FA FD FF      lea d, [bp + -3] ; $fp
0590   0759 2A            mov b, [d]
0591   075A 74            mov d, b
0592   075B 32            mov bl, [d]
0593   075C A7 00         mov bh, 0
0594   075E DD            push bl
0595   075F 07 EA 0B      call putchar
0596   0762 51 01 00      add sp, 1
0597   0765             ;; fp++; 
0598   0765 FA FD FF      lea d, [bp + -3] ; $fp
0599   0768 2A            mov b, [d]
0600   0769 FD 79         mov g, b
0601   076B FD 77         inc b
0602   076D FA FD FF      lea d, [bp + -3] ; $fp
0603   0770 FD 43         mov [d], b
0604   0772 FD 27         mov b, g
0605   0774             _if7_exit:
0606   0774             _if6_exit:
0607   0774             _for5_update:
0608   0774 0A 14 06      jmp _for5_cond
0609   0777             _for5_exit:
0610   0777 F9            leave
0611   0778 09            ret
0612   0779             
0613   0779             printx16:
0614   0779 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0615   077C             
0616   077C             ; --- BEGIN INLINE ASM BLOCK
0617   077C FA 05 00      lea d, [bp + 5] ; $hex
0618   077F 2A            mov b, [d]
0619   0780 07 09 10      call print_u16x
0620   0783             ; --- END INLINE ASM BLOCK
0621   0783             
0622   0783 F9            leave
0623   0784 09            ret
0624   0785             
0625   0785             printx8:
0626   0785 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0627   0788             
0628   0788             ; --- BEGIN INLINE ASM BLOCK
0629   0788 FA 05 00      lea d, [bp + 5] ; $hex
0630   078B 32            mov bl, [d]
0631   078C 07 4D 10      call print_u8x
0632   078F             ; --- END INLINE ASM BLOCK
0633   078F             
0634   078F F9            leave
0635   0790 09            ret
0636   0791             
0637   0791             hex_to_int:
0638   0791 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0639   0794             ; $value 
0640   0794 10 00 00      mov a, $0
0641   0797 45 FF FF      mov [bp + -1], a
0642   079A             ; $i 
0643   079A             ; $hex_char 
0644   079A             ; $len 
0645   079A 52 07 00      sub sp, 7
0646   079D             ;; len = strlen(hex_string); 
0647   079D FA FA FF      lea d, [bp + -6] ; $len
0648   07A0 DA            push d
0649   07A1 FA 05 00      lea d, [bp + 5] ; $hex_string
0650   07A4 2A            mov b, [d]
0651   07A5 FD AB         swp b
0652   07A7 D8            push b
0653   07A8 07 A5 05      call strlen
0654   07AB 51 02 00      add sp, 2
0655   07AE E7            pop d
0656   07AF FD 43         mov [d], b
0657   07B1             ;; for (i = 0; i < len; i++) { 
0658   07B1             _for9_init:
0659   07B1 FA FD FF      lea d, [bp + -3] ; $i
0660   07B4 DA            push d
0661   07B5 26 00 00      mov b, $0
0662   07B8 E7            pop d
0663   07B9 FD 43         mov [d], b
0664   07BB             _for9_cond:
0665   07BB FA FD FF      lea d, [bp + -3] ; $i
0666   07BE 2A            mov b, [d]
0667   07BF             ; START RELATIONAL
0668   07BF D7            push a
0669   07C0 11            mov a, b
0670   07C1 FA FA FF      lea d, [bp + -6] ; $len
0671   07C4 2A            mov b, [d]
0672   07C5 B0            cmp a, b
0673   07C6 FD 73         slt ; < 
0674   07C8 E4            pop a
0675   07C9             ; END RELATIONAL
0676   07C9 C0 00 00      cmp b, 0
0677   07CC C6 D1 08      je _for9_exit
0678   07CF             _for9_block:
0679   07CF             ;; hex_char = hex_string[i]; 
0680   07CF FA FC FF      lea d, [bp + -4] ; $hex_char
0681   07D2 DA            push d
0682   07D3 FA 05 00      lea d, [bp + 5] ; $hex_string
0683   07D6 FD 2A         mov d, [d]
0684   07D8 D7            push a
0685   07D9 DA            push d
0686   07DA FA FD FF      lea d, [bp + -3] ; $i
0687   07DD 2A            mov b, [d]
0688   07DE E7            pop d
0689   07DF FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0690   07E3 E4            pop a
0691   07E4 32            mov bl, [d]
0692   07E5 A7 00         mov bh, 0
0693   07E7 E7            pop d
0694   07E8 FD 3E         mov [d], bl
0695   07EA             ;; if (hex_char >= 'a' && hex_char <= 'f')  
0696   07EA             _if10_cond:
0697   07EA FA FC FF      lea d, [bp + -4] ; $hex_char
0698   07ED 32            mov bl, [d]
0699   07EE A7 00         mov bh, 0
0700   07F0             ; START RELATIONAL
0701   07F0 D7            push a
0702   07F1 11            mov a, b
0703   07F2 26 61 00      mov b, $61
0704   07F5 B0            cmp a, b
0705   07F6 FD 80         sge ; >=
0706   07F8 E4            pop a
0707   07F9             ; END RELATIONAL
0708   07F9 D7            push a
0709   07FA 11            mov a, b
0710   07FB FA FC FF      lea d, [bp + -4] ; $hex_char
0711   07FE 32            mov bl, [d]
0712   07FF A7 00         mov bh, 0
0713   0801             ; START RELATIONAL
0714   0801 D7            push a
0715   0802 11            mov a, b
0716   0803 26 66 00      mov b, $66
0717   0806 B0            cmp a, b
0718   0807 FD 74         sle ; <=
0719   0809 E4            pop a
0720   080A             ; END RELATIONAL
0721   080A FD A7         sand a, b ; &&
0722   080C E4            pop a
0723   080D C0 00 00      cmp b, 0
0724   0810 C6 41 08      je _if10_else
0725   0813             _if10_true:
0726   0813             ;; value = (value * 16) + (hex_char - 'a' + 10); 
0727   0813 FA FF FF      lea d, [bp + -1] ; $value
0728   0816 DA            push d
0729   0817 FA FF FF      lea d, [bp + -1] ; $value
0730   081A 2A            mov b, [d]
0731   081B             ; START FACTORS
0732   081B D7            push a
0733   081C 11            mov a, b
0734   081D 26 10 00      mov b, $10
0735   0820 AC            mul a, b ; *
0736   0821 11            mov a, b
0737   0822 27            mov b, a
0738   0823 E4            pop a
0739   0824             ; END FACTORS
0740   0824             ; START TERMS
0741   0824 D7            push a
0742   0825 11            mov a, b
0743   0826 FA FC FF      lea d, [bp + -4] ; $hex_char
0744   0829 32            mov bl, [d]
0745   082A A7 00         mov bh, 0
0746   082C             ; START TERMS
0747   082C D7            push a
0748   082D 11            mov a, b
0749   082E 26 61 00      mov b, $61
0750   0831 60            sub a, b
0751   0832 26 0A 00      mov b, $a
0752   0835 54            add a, b
0753   0836 27            mov b, a
0754   0837 E4            pop a
0755   0838             ; END TERMS
0756   0838 54            add a, b
0757   0839 27            mov b, a
0758   083A E4            pop a
0759   083B             ; END TERMS
0760   083B E7            pop d
0761   083C FD 43         mov [d], b
0762   083E 0A BF 08      jmp _if10_exit
0763   0841             _if10_else:
0764   0841             ;; if (hex_char >= 'A' && hex_char <= 'F')  
0765   0841             _if11_cond:
0766   0841 FA FC FF      lea d, [bp + -4] ; $hex_char
0767   0844 32            mov bl, [d]
0768   0845 A7 00         mov bh, 0
0769   0847             ; START RELATIONAL
0770   0847 D7            push a
0771   0848 11            mov a, b
0772   0849 26 41 00      mov b, $41
0773   084C B0            cmp a, b
0774   084D FD 80         sge ; >=
0775   084F E4            pop a
0776   0850             ; END RELATIONAL
0777   0850 D7            push a
0778   0851 11            mov a, b
0779   0852 FA FC FF      lea d, [bp + -4] ; $hex_char
0780   0855 32            mov bl, [d]
0781   0856 A7 00         mov bh, 0
0782   0858             ; START RELATIONAL
0783   0858 D7            push a
0784   0859 11            mov a, b
0785   085A 26 46 00      mov b, $46
0786   085D B0            cmp a, b
0787   085E FD 74         sle ; <=
0788   0860 E4            pop a
0789   0861             ; END RELATIONAL
0790   0861 FD A7         sand a, b ; &&
0791   0863 E4            pop a
0792   0864 C0 00 00      cmp b, 0
0793   0867 C6 98 08      je _if11_else
0794   086A             _if11_true:
0795   086A             ;; value = (value * 16) + (hex_char - 'A' + 10); 
0796   086A FA FF FF      lea d, [bp + -1] ; $value
0797   086D DA            push d
0798   086E FA FF FF      lea d, [bp + -1] ; $value
0799   0871 2A            mov b, [d]
0800   0872             ; START FACTORS
0801   0872 D7            push a
0802   0873 11            mov a, b
0803   0874 26 10 00      mov b, $10
0804   0877 AC            mul a, b ; *
0805   0878 11            mov a, b
0806   0879 27            mov b, a
0807   087A E4            pop a
0808   087B             ; END FACTORS
0809   087B             ; START TERMS
0810   087B D7            push a
0811   087C 11            mov a, b
0812   087D FA FC FF      lea d, [bp + -4] ; $hex_char
0813   0880 32            mov bl, [d]
0814   0881 A7 00         mov bh, 0
0815   0883             ; START TERMS
0816   0883 D7            push a
0817   0884 11            mov a, b
0818   0885 26 41 00      mov b, $41
0819   0888 60            sub a, b
0820   0889 26 0A 00      mov b, $a
0821   088C 54            add a, b
0822   088D 27            mov b, a
0823   088E E4            pop a
0824   088F             ; END TERMS
0825   088F 54            add a, b
0826   0890 27            mov b, a
0827   0891 E4            pop a
0828   0892             ; END TERMS
0829   0892 E7            pop d
0830   0893 FD 43         mov [d], b
0831   0895 0A BF 08      jmp _if11_exit
0832   0898             _if11_else:
0833   0898             ;; value = (value * 16) + (hex_char - '0'); 
0834   0898 FA FF FF      lea d, [bp + -1] ; $value
0835   089B DA            push d
0836   089C FA FF FF      lea d, [bp + -1] ; $value
0837   089F 2A            mov b, [d]
0838   08A0             ; START FACTORS
0839   08A0 D7            push a
0840   08A1 11            mov a, b
0841   08A2 26 10 00      mov b, $10
0842   08A5 AC            mul a, b ; *
0843   08A6 11            mov a, b
0844   08A7 27            mov b, a
0845   08A8 E4            pop a
0846   08A9             ; END FACTORS
0847   08A9             ; START TERMS
0848   08A9 D7            push a
0849   08AA 11            mov a, b
0850   08AB FA FC FF      lea d, [bp + -4] ; $hex_char
0851   08AE 32            mov bl, [d]
0852   08AF A7 00         mov bh, 0
0853   08B1             ; START TERMS
0854   08B1 D7            push a
0855   08B2 11            mov a, b
0856   08B3 26 30 00      mov b, $30
0857   08B6 60            sub a, b
0858   08B7 27            mov b, a
0859   08B8 E4            pop a
0860   08B9             ; END TERMS
0861   08B9 54            add a, b
0862   08BA 27            mov b, a
0863   08BB E4            pop a
0864   08BC             ; END TERMS
0865   08BC E7            pop d
0866   08BD FD 43         mov [d], b
0867   08BF             _if11_exit:
0868   08BF             _if10_exit:
0869   08BF             _for9_update:
0870   08BF FA FD FF      lea d, [bp + -3] ; $i
0871   08C2 2A            mov b, [d]
0872   08C3 FD 79         mov g, b
0873   08C5 FD 77         inc b
0874   08C7 FA FD FF      lea d, [bp + -3] ; $i
0875   08CA FD 43         mov [d], b
0876   08CC FD 27         mov b, g
0877   08CE 0A BB 07      jmp _for9_cond
0878   08D1             _for9_exit:
0879   08D1             ;; return value; 
0880   08D1 FA FF FF      lea d, [bp + -1] ; $value
0881   08D4 2A            mov b, [d]
0882   08D5 F9            leave
0883   08D6 09            ret
0884   08D7             
0885   08D7             atoi:
0886   08D7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0887   08DA             ; $result 
0888   08DA 10 00 00      mov a, $0
0889   08DD 45 FF FF      mov [bp + -1], a
0890   08E0             ; $sign 
0891   08E0 10 01 00      mov a, $1
0892   08E3 45 FD FF      mov [bp + -3], a
0893   08E6 52 04 00      sub sp, 4
0894   08E9             ;; while (*str == ' ') str++; 
0895   08E9             _while12_cond:
0896   08E9 FA 05 00      lea d, [bp + 5] ; $str
0897   08EC 2A            mov b, [d]
0898   08ED 74            mov d, b
0899   08EE 32            mov bl, [d]
0900   08EF A7 00         mov bh, 0
0901   08F1             ; START RELATIONAL
0902   08F1 D7            push a
0903   08F2 11            mov a, b
0904   08F3 26 20 00      mov b, $20
0905   08F6 B0            cmp a, b
0906   08F7 FD 71         seq ; ==
0907   08F9 E4            pop a
0908   08FA             ; END RELATIONAL
0909   08FA C0 00 00      cmp b, 0
0910   08FD C6 12 09      je _while12_exit
0911   0900             _while12_block:
0912   0900             ;; str++; 
0913   0900 FA 05 00      lea d, [bp + 5] ; $str
0914   0903 2A            mov b, [d]
0915   0904 FD 79         mov g, b
0916   0906 FD 77         inc b
0917   0908 FA 05 00      lea d, [bp + 5] ; $str
0918   090B FD 43         mov [d], b
0919   090D FD 27         mov b, g
0920   090F 0A E9 08      jmp _while12_cond
0921   0912             _while12_exit:
0922   0912             ;; if (*str == '-' || *str == '+') { 
0923   0912             _if13_cond:
0924   0912 FA 05 00      lea d, [bp + 5] ; $str
0925   0915 2A            mov b, [d]
0926   0916 74            mov d, b
0927   0917 32            mov bl, [d]
0928   0918 A7 00         mov bh, 0
0929   091A             ; START RELATIONAL
0930   091A D7            push a
0931   091B 11            mov a, b
0932   091C 26 2D 00      mov b, $2d
0933   091F B0            cmp a, b
0934   0920 FD 71         seq ; ==
0935   0922 E4            pop a
0936   0923             ; END RELATIONAL
0937   0923 D7            push a
0938   0924 11            mov a, b
0939   0925 FA 05 00      lea d, [bp + 5] ; $str
0940   0928 2A            mov b, [d]
0941   0929 74            mov d, b
0942   092A 32            mov bl, [d]
0943   092B A7 00         mov bh, 0
0944   092D             ; START RELATIONAL
0945   092D D7            push a
0946   092E 11            mov a, b
0947   092F 26 2B 00      mov b, $2b
0948   0932 B0            cmp a, b
0949   0933 FD 71         seq ; ==
0950   0935 E4            pop a
0951   0936             ; END RELATIONAL
0952   0936 FD A8         sor a, b ; ||
0953   0938 E4            pop a
0954   0939 C0 00 00      cmp b, 0
0955   093C C6 77 09      je _if13_exit
0956   093F             _if13_true:
0957   093F             ;; if (*str == '-') sign = -1; 
0958   093F             _if14_cond:
0959   093F FA 05 00      lea d, [bp + 5] ; $str
0960   0942 2A            mov b, [d]
0961   0943 74            mov d, b
0962   0944 32            mov bl, [d]
0963   0945 A7 00         mov bh, 0
0964   0947             ; START RELATIONAL
0965   0947 D7            push a
0966   0948 11            mov a, b
0967   0949 26 2D 00      mov b, $2d
0968   094C B0            cmp a, b
0969   094D FD 71         seq ; ==
0970   094F E4            pop a
0971   0950             ; END RELATIONAL
0972   0950 C0 00 00      cmp b, 0
0973   0953 C6 65 09      je _if14_exit
0974   0956             _if14_true:
0975   0956             ;; sign = -1; 
0976   0956 FA FD FF      lea d, [bp + -3] ; $sign
0977   0959 DA            push d
0978   095A 26 01 00      mov b, $1
0979   095D FD 97         neg b
0980   095F E7            pop d
0981   0960 FD 43         mov [d], b
0982   0962 0A 65 09      jmp _if14_exit
0983   0965             _if14_exit:
0984   0965             ;; str++; 
0985   0965 FA 05 00      lea d, [bp + 5] ; $str
0986   0968 2A            mov b, [d]
0987   0969 FD 79         mov g, b
0988   096B FD 77         inc b
0989   096D FA 05 00      lea d, [bp + 5] ; $str
0990   0970 FD 43         mov [d], b
0991   0972 FD 27         mov b, g
0992   0974 0A 77 09      jmp _if13_exit
0993   0977             _if13_exit:
0994   0977             ;; while (*str >= '0' && *str <= '9') { 
0995   0977             _while15_cond:
0996   0977 FA 05 00      lea d, [bp + 5] ; $str
0997   097A 2A            mov b, [d]
0998   097B 74            mov d, b
0999   097C 32            mov bl, [d]
1000   097D A7 00         mov bh, 0
1001   097F             ; START RELATIONAL
1002   097F D7            push a
1003   0980 11            mov a, b
1004   0981 26 30 00      mov b, $30
1005   0984 B0            cmp a, b
1006   0985 FD 80         sge ; >=
1007   0987 E4            pop a
1008   0988             ; END RELATIONAL
1009   0988 D7            push a
1010   0989 11            mov a, b
1011   098A FA 05 00      lea d, [bp + 5] ; $str
1012   098D 2A            mov b, [d]
1013   098E 74            mov d, b
1014   098F 32            mov bl, [d]
1015   0990 A7 00         mov bh, 0
1016   0992             ; START RELATIONAL
1017   0992 D7            push a
1018   0993 11            mov a, b
1019   0994 26 39 00      mov b, $39
1020   0997 B0            cmp a, b
1021   0998 FD 74         sle ; <=
1022   099A E4            pop a
1023   099B             ; END RELATIONAL
1024   099B FD A7         sand a, b ; &&
1025   099D E4            pop a
1026   099E C0 00 00      cmp b, 0
1027   09A1 C6 DF 09      je _while15_exit
1028   09A4             _while15_block:
1029   09A4             ;; result = result * 10 + (*str - '0'); 
1030   09A4 FA FF FF      lea d, [bp + -1] ; $result
1031   09A7 DA            push d
1032   09A8 FA FF FF      lea d, [bp + -1] ; $result
1033   09AB 2A            mov b, [d]
1034   09AC             ; START FACTORS
1035   09AC D7            push a
1036   09AD 11            mov a, b
1037   09AE 26 0A 00      mov b, $a
1038   09B1 AC            mul a, b ; *
1039   09B2 11            mov a, b
1040   09B3 27            mov b, a
1041   09B4 E4            pop a
1042   09B5             ; END FACTORS
1043   09B5             ; START TERMS
1044   09B5 D7            push a
1045   09B6 11            mov a, b
1046   09B7 FA 05 00      lea d, [bp + 5] ; $str
1047   09BA 2A            mov b, [d]
1048   09BB 74            mov d, b
1049   09BC 32            mov bl, [d]
1050   09BD A7 00         mov bh, 0
1051   09BF             ; START TERMS
1052   09BF D7            push a
1053   09C0 11            mov a, b
1054   09C1 26 30 00      mov b, $30
1055   09C4 60            sub a, b
1056   09C5 27            mov b, a
1057   09C6 E4            pop a
1058   09C7             ; END TERMS
1059   09C7 54            add a, b
1060   09C8 27            mov b, a
1061   09C9 E4            pop a
1062   09CA             ; END TERMS
1063   09CA E7            pop d
1064   09CB FD 43         mov [d], b
1065   09CD             ;; str++; 
1066   09CD FA 05 00      lea d, [bp + 5] ; $str
1067   09D0 2A            mov b, [d]
1068   09D1 FD 79         mov g, b
1069   09D3 FD 77         inc b
1070   09D5 FA 05 00      lea d, [bp + 5] ; $str
1071   09D8 FD 43         mov [d], b
1072   09DA FD 27         mov b, g
1073   09DC 0A 77 09      jmp _while15_cond
1074   09DF             _while15_exit:
1075   09DF             ;; return sign * result; 
1076   09DF FA FD FF      lea d, [bp + -3] ; $sign
1077   09E2 2A            mov b, [d]
1078   09E3             ; START FACTORS
1079   09E3 D7            push a
1080   09E4 11            mov a, b
1081   09E5 FA FF FF      lea d, [bp + -1] ; $result
1082   09E8 2A            mov b, [d]
1083   09E9 AC            mul a, b ; *
1084   09EA 11            mov a, b
1085   09EB 27            mov b, a
1086   09EC E4            pop a
1087   09ED             ; END FACTORS
1088   09ED F9            leave
1089   09EE 09            ret
1090   09EF             
1091   09EF             gets:
1092   09EF F8 00 00      enter 0 ; (push bp; mov bp, sp)
1093   09F2             
1094   09F2             ; --- BEGIN INLINE ASM BLOCK
1095   09F2 FA 05 00      lea d, [bp + 5] ; $s
1096   09F5 15            mov a, [d]
1097   09F6 3C            mov d, a
1098   09F7 07 6E 0E      call _gets
1099   09FA             ; --- END INLINE ASM BLOCK
1100   09FA             
1101   09FA             ;; return strlen(s); 
1102   09FA FA 05 00      lea d, [bp + 5] ; $s
1103   09FD 2A            mov b, [d]
1104   09FE FD AB         swp b
1105   0A00 D8            push b
1106   0A01 07 A5 05      call strlen
1107   0A04 51 02 00      add sp, 2
1108   0A07 F9            leave
1109   0A08 09            ret
1110   0A09             
1111   0A09             prints:
1112   0A09 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1113   0A0C             ; $digits 
1114   0A0C             ; $i 
1115   0A0C 10 00 00      mov a, $0
1116   0A0F 45 FA FF      mov [bp + -6], a
1117   0A12 52 07 00      sub sp, 7
1118   0A15             ;; if (num < 0) { 
1119   0A15             _if16_cond:
1120   0A15 FA 05 00      lea d, [bp + 5] ; $num
1121   0A18 2A            mov b, [d]
1122   0A19             ; START RELATIONAL
1123   0A19 D7            push a
1124   0A1A 11            mov a, b
1125   0A1B 26 00 00      mov b, $0
1126   0A1E B0            cmp a, b
1127   0A1F FD 73         slt ; < 
1128   0A21 E4            pop a
1129   0A22             ; END RELATIONAL
1130   0A22 C0 00 00      cmp b, 0
1131   0A25 C6 42 0A      je _if16_else
1132   0A28             _if16_true:
1133   0A28             ;; putchar('-'); 
1134   0A28 26 2D 00      mov b, $2d
1135   0A2B DD            push bl
1136   0A2C 07 EA 0B      call putchar
1137   0A2F 51 01 00      add sp, 1
1138   0A32             ;; num = -num; 
1139   0A32 FA 05 00      lea d, [bp + 5] ; $num
1140   0A35 DA            push d
1141   0A36 FA 05 00      lea d, [bp + 5] ; $num
1142   0A39 2A            mov b, [d]
1143   0A3A FD 97         neg b
1144   0A3C E7            pop d
1145   0A3D FD 43         mov [d], b
1146   0A3F 0A 64 0A      jmp _if16_exit
1147   0A42             _if16_else:
1148   0A42             ;; if (num == 0) { 
1149   0A42             _if17_cond:
1150   0A42 FA 05 00      lea d, [bp + 5] ; $num
1151   0A45 2A            mov b, [d]
1152   0A46             ; START RELATIONAL
1153   0A46 D7            push a
1154   0A47 11            mov a, b
1155   0A48 26 00 00      mov b, $0
1156   0A4B B0            cmp a, b
1157   0A4C FD 71         seq ; ==
1158   0A4E E4            pop a
1159   0A4F             ; END RELATIONAL
1160   0A4F C0 00 00      cmp b, 0
1161   0A52 C6 64 0A      je _if17_exit
1162   0A55             _if17_true:
1163   0A55             ;; putchar('0'); 
1164   0A55 26 30 00      mov b, $30
1165   0A58 DD            push bl
1166   0A59 07 EA 0B      call putchar
1167   0A5C 51 01 00      add sp, 1
1168   0A5F             ;; return; 
1169   0A5F F9            leave
1170   0A60 09            ret
1171   0A61 0A 64 0A      jmp _if17_exit
1172   0A64             _if17_exit:
1173   0A64             _if16_exit:
1174   0A64             ;; while (num > 0) { 
1175   0A64             _while18_cond:
1176   0A64 FA 05 00      lea d, [bp + 5] ; $num
1177   0A67 2A            mov b, [d]
1178   0A68             ; START RELATIONAL
1179   0A68 D7            push a
1180   0A69 11            mov a, b
1181   0A6A 26 00 00      mov b, $0
1182   0A6D B0            cmp a, b
1183   0A6E FD 7F         sgt ; >
1184   0A70 E4            pop a
1185   0A71             ; END RELATIONAL
1186   0A71 C0 00 00      cmp b, 0
1187   0A74 C6 C1 0A      je _while18_exit
1188   0A77             _while18_block:
1189   0A77             ;; digits[i] = '0' + (num % 10); 
1190   0A77 FA FC FF      lea d, [bp + -4] ; $digits
1191   0A7A D7            push a
1192   0A7B DA            push d
1193   0A7C FA FA FF      lea d, [bp + -6] ; $i
1194   0A7F 2A            mov b, [d]
1195   0A80 E7            pop d
1196   0A81 5A            add d, b
1197   0A82 E4            pop a
1198   0A83 DA            push d
1199   0A84 26 30 00      mov b, $30
1200   0A87             ; START TERMS
1201   0A87 D7            push a
1202   0A88 11            mov a, b
1203   0A89 FA 05 00      lea d, [bp + 5] ; $num
1204   0A8C 2A            mov b, [d]
1205   0A8D             ; START FACTORS
1206   0A8D D7            push a
1207   0A8E 11            mov a, b
1208   0A8F 26 0A 00      mov b, $a
1209   0A92 AE            div a, b ; 
1210   0A93 11            mov a, b
1211   0A94 27            mov b, a
1212   0A95 E4            pop a
1213   0A96             ; END FACTORS
1214   0A96 54            add a, b
1215   0A97 27            mov b, a
1216   0A98 E4            pop a
1217   0A99             ; END TERMS
1218   0A99 E7            pop d
1219   0A9A FD 3E         mov [d], bl
1220   0A9C             ;; num = num / 10; 
1221   0A9C FA 05 00      lea d, [bp + 5] ; $num
1222   0A9F DA            push d
1223   0AA0 FA 05 00      lea d, [bp + 5] ; $num
1224   0AA3 2A            mov b, [d]
1225   0AA4             ; START FACTORS
1226   0AA4 D7            push a
1227   0AA5 11            mov a, b
1228   0AA6 26 0A 00      mov b, $a
1229   0AA9 AE            div a, b
1230   0AAA 27            mov b, a
1231   0AAB E4            pop a
1232   0AAC             ; END FACTORS
1233   0AAC E7            pop d
1234   0AAD FD 43         mov [d], b
1235   0AAF             ;; i++; 
1236   0AAF FA FA FF      lea d, [bp + -6] ; $i
1237   0AB2 2A            mov b, [d]
1238   0AB3 FD 79         mov g, b
1239   0AB5 FD 77         inc b
1240   0AB7 FA FA FF      lea d, [bp + -6] ; $i
1241   0ABA FD 43         mov [d], b
1242   0ABC FD 27         mov b, g
1243   0ABE 0A 64 0A      jmp _while18_cond
1244   0AC1             _while18_exit:
1245   0AC1             ;; while (i > 0) { 
1246   0AC1             _while19_cond:
1247   0AC1 FA FA FF      lea d, [bp + -6] ; $i
1248   0AC4 2A            mov b, [d]
1249   0AC5             ; START RELATIONAL
1250   0AC5 D7            push a
1251   0AC6 11            mov a, b
1252   0AC7 26 00 00      mov b, $0
1253   0ACA B0            cmp a, b
1254   0ACB FD 7F         sgt ; >
1255   0ACD E4            pop a
1256   0ACE             ; END RELATIONAL
1257   0ACE C0 00 00      cmp b, 0
1258   0AD1 C6 FC 0A      je _while19_exit
1259   0AD4             _while19_block:
1260   0AD4             ;; i--; 
1261   0AD4 FA FA FF      lea d, [bp + -6] ; $i
1262   0AD7 2A            mov b, [d]
1263   0AD8 FD 79         mov g, b
1264   0ADA FD 7D         dec b
1265   0ADC FA FA FF      lea d, [bp + -6] ; $i
1266   0ADF FD 43         mov [d], b
1267   0AE1 FD 27         mov b, g
1268   0AE3             ;; putchar(digits[i]); 
1269   0AE3 FA FC FF      lea d, [bp + -4] ; $digits
1270   0AE6 D7            push a
1271   0AE7 DA            push d
1272   0AE8 FA FA FF      lea d, [bp + -6] ; $i
1273   0AEB 2A            mov b, [d]
1274   0AEC E7            pop d
1275   0AED 5A            add d, b
1276   0AEE E4            pop a
1277   0AEF 32            mov bl, [d]
1278   0AF0 A7 00         mov bh, 0
1279   0AF2 DD            push bl
1280   0AF3 07 EA 0B      call putchar
1281   0AF6 51 01 00      add sp, 1
1282   0AF9 0A C1 0A      jmp _while19_cond
1283   0AFC             _while19_exit:
1284   0AFC F9            leave
1285   0AFD 09            ret
1286   0AFE             
1287   0AFE             printu:
1288   0AFE F8 00 00      enter 0 ; (push bp; mov bp, sp)
1289   0B01             ; $digits 
1290   0B01             ; $i 
1291   0B01 52 07 00      sub sp, 7
1292   0B04             ;; i = 0; 
1293   0B04 FA FA FF      lea d, [bp + -6] ; $i
1294   0B07 DA            push d
1295   0B08 26 00 00      mov b, $0
1296   0B0B E7            pop d
1297   0B0C FD 43         mov [d], b
1298   0B0E             ;; if(num == 0){ 
1299   0B0E             _if20_cond:
1300   0B0E FA 05 00      lea d, [bp + 5] ; $num
1301   0B11 2A            mov b, [d]
1302   0B12             ; START RELATIONAL
1303   0B12 D7            push a
1304   0B13 11            mov a, b
1305   0B14 26 00 00      mov b, $0
1306   0B17 B0            cmp a, b
1307   0B18 FD 71         seq ; ==
1308   0B1A E4            pop a
1309   0B1B             ; END RELATIONAL
1310   0B1B C0 00 00      cmp b, 0
1311   0B1E C6 30 0B      je _if20_exit
1312   0B21             _if20_true:
1313   0B21             ;; putchar('0'); 
1314   0B21 26 30 00      mov b, $30
1315   0B24 DD            push bl
1316   0B25 07 EA 0B      call putchar
1317   0B28 51 01 00      add sp, 1
1318   0B2B             ;; return; 
1319   0B2B F9            leave
1320   0B2C 09            ret
1321   0B2D 0A 30 0B      jmp _if20_exit
1322   0B30             _if20_exit:
1323   0B30             ;; while (num > 0) { 
1324   0B30             _while21_cond:
1325   0B30 FA 05 00      lea d, [bp + 5] ; $num
1326   0B33 2A            mov b, [d]
1327   0B34             ; START RELATIONAL
1328   0B34 D7            push a
1329   0B35 11            mov a, b
1330   0B36 26 00 00      mov b, $0
1331   0B39 B0            cmp a, b
1332   0B3A FD 81         sgu ; > (unsigned)
1333   0B3C E4            pop a
1334   0B3D             ; END RELATIONAL
1335   0B3D C0 00 00      cmp b, 0
1336   0B40 C6 8D 0B      je _while21_exit
1337   0B43             _while21_block:
1338   0B43             ;; digits[i] = '0' + (num % 10); 
1339   0B43 FA FC FF      lea d, [bp + -4] ; $digits
1340   0B46 D7            push a
1341   0B47 DA            push d
1342   0B48 FA FA FF      lea d, [bp + -6] ; $i
1343   0B4B 2A            mov b, [d]
1344   0B4C E7            pop d
1345   0B4D 5A            add d, b
1346   0B4E E4            pop a
1347   0B4F DA            push d
1348   0B50 26 30 00      mov b, $30
1349   0B53             ; START TERMS
1350   0B53 D7            push a
1351   0B54 11            mov a, b
1352   0B55 FA 05 00      lea d, [bp + 5] ; $num
1353   0B58 2A            mov b, [d]
1354   0B59             ; START FACTORS
1355   0B59 D7            push a
1356   0B5A 11            mov a, b
1357   0B5B 26 0A 00      mov b, $a
1358   0B5E AE            div a, b ; 
1359   0B5F 11            mov a, b
1360   0B60 27            mov b, a
1361   0B61 E4            pop a
1362   0B62             ; END FACTORS
1363   0B62 54            add a, b
1364   0B63 27            mov b, a
1365   0B64 E4            pop a
1366   0B65             ; END TERMS
1367   0B65 E7            pop d
1368   0B66 FD 3E         mov [d], bl
1369   0B68             ;; num = num / 10; 
1370   0B68 FA 05 00      lea d, [bp + 5] ; $num
1371   0B6B DA            push d
1372   0B6C FA 05 00      lea d, [bp + 5] ; $num
1373   0B6F 2A            mov b, [d]
1374   0B70             ; START FACTORS
1375   0B70 D7            push a
1376   0B71 11            mov a, b
1377   0B72 26 0A 00      mov b, $a
1378   0B75 AE            div a, b
1379   0B76 27            mov b, a
1380   0B77 E4            pop a
1381   0B78             ; END FACTORS
1382   0B78 E7            pop d
1383   0B79 FD 43         mov [d], b
1384   0B7B             ;; i++; 
1385   0B7B FA FA FF      lea d, [bp + -6] ; $i
1386   0B7E 2A            mov b, [d]
1387   0B7F FD 79         mov g, b
1388   0B81 FD 77         inc b
1389   0B83 FA FA FF      lea d, [bp + -6] ; $i
1390   0B86 FD 43         mov [d], b
1391   0B88 FD 27         mov b, g
1392   0B8A 0A 30 0B      jmp _while21_cond
1393   0B8D             _while21_exit:
1394   0B8D             ;; while (i > 0) { 
1395   0B8D             _while22_cond:
1396   0B8D FA FA FF      lea d, [bp + -6] ; $i
1397   0B90 2A            mov b, [d]
1398   0B91             ; START RELATIONAL
1399   0B91 D7            push a
1400   0B92 11            mov a, b
1401   0B93 26 00 00      mov b, $0
1402   0B96 B0            cmp a, b
1403   0B97 FD 7F         sgt ; >
1404   0B99 E4            pop a
1405   0B9A             ; END RELATIONAL
1406   0B9A C0 00 00      cmp b, 0
1407   0B9D C6 C8 0B      je _while22_exit
1408   0BA0             _while22_block:
1409   0BA0             ;; i--; 
1410   0BA0 FA FA FF      lea d, [bp + -6] ; $i
1411   0BA3 2A            mov b, [d]
1412   0BA4 FD 79         mov g, b
1413   0BA6 FD 7D         dec b
1414   0BA8 FA FA FF      lea d, [bp + -6] ; $i
1415   0BAB FD 43         mov [d], b
1416   0BAD FD 27         mov b, g
1417   0BAF             ;; putchar(digits[i]); 
1418   0BAF FA FC FF      lea d, [bp + -4] ; $digits
1419   0BB2 D7            push a
1420   0BB3 DA            push d
1421   0BB4 FA FA FF      lea d, [bp + -6] ; $i
1422   0BB7 2A            mov b, [d]
1423   0BB8 E7            pop d
1424   0BB9 5A            add d, b
1425   0BBA E4            pop a
1426   0BBB 32            mov bl, [d]
1427   0BBC A7 00         mov bh, 0
1428   0BBE DD            push bl
1429   0BBF 07 EA 0B      call putchar
1430   0BC2 51 01 00      add sp, 1
1431   0BC5 0A 8D 0B      jmp _while22_cond
1432   0BC8             _while22_exit:
1433   0BC8 F9            leave
1434   0BC9 09            ret
1435   0BCA             
1436   0BCA             rand:
1437   0BCA F8 00 00      enter 0 ; (push bp; mov bp, sp)
1438   0BCD             ; $sec 
1439   0BCD 52 01 00      sub sp, 1
1440   0BD0             
1441   0BD0             ; --- BEGIN INLINE ASM BLOCK
1442   0BD0 19 00         mov al, 0
1443   0BD2 05 01         syscall sys_rtc					
1444   0BD4 1A            mov al, ah
1445   0BD5 FA 00 00      lea d, [bp + 0] ; $sec
1446   0BD8 1E            mov al, [d]
1447   0BD9             ; --- END INLINE ASM BLOCK
1448   0BD9             
1449   0BD9             ;; return sec; 
1450   0BD9 FA 00 00      lea d, [bp + 0] ; $sec
1451   0BDC 32            mov bl, [d]
1452   0BDD A7 00         mov bh, 0
1453   0BDF F9            leave
1454   0BE0 09            ret
1455   0BE1             
1456   0BE1             date:
1457   0BE1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1458   0BE4             
1459   0BE4             ; --- BEGIN INLINE ASM BLOCK
1460   0BE4 19 00         mov al, 0 
1461   0BE6 05 07         syscall sys_datetime
1462   0BE8             ; --- END INLINE ASM BLOCK
1463   0BE8             
1464   0BE8 F9            leave
1465   0BE9 09            ret
1466   0BEA             
1467   0BEA             putchar:
1468   0BEA F8 00 00      enter 0 ; (push bp; mov bp, sp)
1469   0BED             
1470   0BED             ; --- BEGIN INLINE ASM BLOCK
1471   0BED FA 05 00      lea d, [bp + 5] ; $c
1472   0BF0 1E            mov al, [d]
1473   0BF1 23            mov ah, al
1474   0BF2 07 67 0E      call _putchar
1475   0BF5             ; --- END INLINE ASM BLOCK
1476   0BF5             
1477   0BF5 F9            leave
1478   0BF6 09            ret
1479   0BF7             
1480   0BF7             getchar:
1481   0BF7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1482   0BFA             ; $c 
1483   0BFA 52 01 00      sub sp, 1
1484   0BFD             
1485   0BFD             ; --- BEGIN INLINE ASM BLOCK
1486   0BFD 07 60 0E      call getch
1487   0C00 1A            mov al, ah
1488   0C01 FA 00 00      lea d, [bp + 0] ; $c
1489   0C04 3E            mov [d], al
1490   0C05             ; --- END INLINE ASM BLOCK
1491   0C05             
1492   0C05             ;; return c; 
1493   0C05 FA 00 00      lea d, [bp + 0] ; $c
1494   0C08 32            mov bl, [d]
1495   0C09 A7 00         mov bh, 0
1496   0C0B F9            leave
1497   0C0C 09            ret
1498   0C0D             
1499   0C0D             scann:
1500   0C0D F8 00 00      enter 0 ; (push bp; mov bp, sp)
1501   0C10             ; $m 
1502   0C10 52 02 00      sub sp, 2
1503   0C13             
1504   0C13             ; --- BEGIN INLINE ASM BLOCK
1505   0C13 07 AB 10      call scan_u16d
1506   0C16 FA FF FF      lea d, [bp + -1] ; $m
1507   0C19 43            mov [d], a
1508   0C1A             ; --- END INLINE ASM BLOCK
1509   0C1A             
1510   0C1A             ;; return m; 
1511   0C1A FA FF FF      lea d, [bp + -1] ; $m
1512   0C1D 2A            mov b, [d]
1513   0C1E F9            leave
1514   0C1F 09            ret
1515   0C20             
1516   0C20             puts:
1517   0C20 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1518   0C23             
1519   0C23             ; --- BEGIN INLINE ASM BLOCK
1520   0C23 FA 05 00      lea d, [bp + 5] ; $s
1521   0C26 15            mov a, [d]
1522   0C27 3C            mov d, a
1523   0C28 07 B1 0F      call _puts
1524   0C2B 10 00 0A      mov a, $0A00
1525   0C2E 05 03         syscall sys_io
1526   0C30             ; --- END INLINE ASM BLOCK
1527   0C30             
1528   0C30 F9            leave
1529   0C31 09            ret
1530   0C32             
1531   0C32             print:
1532   0C32 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1533   0C35             
1534   0C35             ; --- BEGIN INLINE ASM BLOCK
1535   0C35 FA 05 00      lea d, [bp + 5] ; $s
1536   0C38 FD 2A         mov d, [d]
1537   0C3A 07 B1 0F      call _puts
1538   0C3D             ; --- END INLINE ASM BLOCK
1539   0C3D             
1540   0C3D F9            leave
1541   0C3E 09            ret
1542   0C3F             
1543   0C3F             loadfile:
1544   0C3F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1545   0C42             
1546   0C42             ; --- BEGIN INLINE ASM BLOCK
1547   0C42 FA 05 00      lea d, [bp + 5] ; $destination
1548   0C45 15            mov a, [d]
1549   0C46 4F            mov di, a
1550   0C47 FA 07 00      lea d, [bp + 7] ; $filename
1551   0C4A FD 2A         mov d, [d]
1552   0C4C 19 14         mov al, 20
1553   0C4E 05 04         syscall sys_filesystem
1554   0C50             ; --- END INLINE ASM BLOCK
1555   0C50             
1556   0C50 F9            leave
1557   0C51 09            ret
1558   0C52             
1559   0C52             create_file:
1560   0C52 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1561   0C55 F9            leave
1562   0C56 09            ret
1563   0C57             
1564   0C57             delete_file:
1565   0C57 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1566   0C5A             
1567   0C5A             ; --- BEGIN INLINE ASM BLOCK
1568   0C5A FA 05 00      lea d, [bp + 5] ; $filename
1569   0C5D 19 0A         mov al, 10
1570   0C5F 05 04         syscall sys_filesystem
1571   0C61             ; --- END INLINE ASM BLOCK
1572   0C61             
1573   0C61 F9            leave
1574   0C62 09            ret
1575   0C63             
1576   0C63             fopen:
1577   0C63 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1578   0C66 F9            leave
1579   0C67 09            ret
1580   0C68             
1581   0C68             fclose:
1582   0C68 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1583   0C6B F9            leave
1584   0C6C 09            ret
1585   0C6D             
1586   0C6D             alloc:
1587   0C6D F8 00 00      enter 0 ; (push bp; mov bp, sp)
1588   0C70             ;; heap_top = heap_top + bytes; 
1589   0C70 3B 5A 11      mov d, _heap_top ; $heap_top
1590   0C73 DA            push d
1591   0C74 3B 5A 11      mov d, _heap_top ; $heap_top
1592   0C77 2A            mov b, [d]
1593   0C78             ; START TERMS
1594   0C78 D7            push a
1595   0C79 11            mov a, b
1596   0C7A FA 05 00      lea d, [bp + 5] ; $bytes
1597   0C7D 2A            mov b, [d]
1598   0C7E 54            add a, b
1599   0C7F 27            mov b, a
1600   0C80 E4            pop a
1601   0C81             ; END TERMS
1602   0C81 E7            pop d
1603   0C82 FD 43         mov [d], b
1604   0C84             ;; return heap_top - bytes; 
1605   0C84 3B 5A 11      mov d, _heap_top ; $heap_top
1606   0C87 2A            mov b, [d]
1607   0C88             ; START TERMS
1608   0C88 D7            push a
1609   0C89 11            mov a, b
1610   0C8A FA 05 00      lea d, [bp + 5] ; $bytes
1611   0C8D 2A            mov b, [d]
1612   0C8E 60            sub a, b
1613   0C8F 27            mov b, a
1614   0C90 E4            pop a
1615   0C91             ; END TERMS
1616   0C91 F9            leave
1617   0C92 09            ret
1618   0C93             
1619   0C93             free:
1620   0C93 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1621   0C96             ;; return heap_top = heap_top - bytes; 
1622   0C96 3B 5A 11      mov d, _heap_top ; $heap_top
1623   0C99 DA            push d
1624   0C9A 3B 5A 11      mov d, _heap_top ; $heap_top
1625   0C9D 2A            mov b, [d]
1626   0C9E             ; START TERMS
1627   0C9E D7            push a
1628   0C9F 11            mov a, b
1629   0CA0 FA 05 00      lea d, [bp + 5] ; $bytes
1630   0CA3 2A            mov b, [d]
1631   0CA4 60            sub a, b
1632   0CA5 27            mov b, a
1633   0CA6 E4            pop a
1634   0CA7             ; END TERMS
1635   0CA7 E7            pop d
1636   0CA8 FD 43         mov [d], b
1637   0CAA F9            leave
1638   0CAB 09            ret
1639   0CAC             
1640   0CAC             exit:
1641   0CAC F8 00 00      enter 0 ; (push bp; mov bp, sp)
1642   0CAF             
1643   0CAF             ; --- BEGIN INLINE ASM BLOCK
1644   0CAF 05 0B         syscall sys_terminate_proc
1645   0CB1             ; --- END INLINE ASM BLOCK
1646   0CB1             
1647   0CB1 F9            leave
1648   0CB2 09            ret
1649   0CB3             
1650   0CB3             load_hex:
1651   0CB3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1652   0CB6             ; $temp 
1653   0CB6 52 02 00      sub sp, 2
1654   0CB9             ;; temp = alloc(32768); 
1655   0CB9 FA FF FF      lea d, [bp + -1] ; $temp
1656   0CBC DA            push d
1657   0CBD 26 00 80      mov b, $8000
1658   0CC0 FD AB         swp b
1659   0CC2 D8            push b
1660   0CC3 07 6D 0C      call alloc
1661   0CC6 51 02 00      add sp, 2
1662   0CC9 E7            pop d
1663   0CCA FD 43         mov [d], b
1664   0CCC             
1665   0CCC             ; --- BEGIN INLINE ASM BLOCK
1666   0CCC               
1667   0CCC               
1668   0CCC               
1669   0CCC               
1670   0CCC               
1671   0CCC             _load_hex:
1672   0CCC D7            push a
1673   0CCD D8            push b
1674   0CCE DA            push d
1675   0CCF E2            push si
1676   0CD0 E3            push di
1677   0CD1 52 00 80      sub sp, $8000      
1678   0CD4 38 00 00      mov c, 0
1679   0CD7 48            mov a, sp
1680   0CD8 77            inc a
1681   0CD9 3C            mov d, a          
1682   0CDA 07 6E 0E      call _gets        
1683   0CDD 4D            mov si, a
1684   0CDE             __load_hex_loop:
1685   0CDE F6            lodsb             
1686   0CDF B9 00         cmp al, 0         
1687   0CE1 C6 EF 0C      jz __load_hex_ret
1688   0CE4 36            mov bh, al
1689   0CE5 F6            lodsb
1690   0CE6 2F            mov bl, al
1691   0CE7 07 24 0E      call _atoi        
1692   0CEA F7            stosb             
1693   0CEB 78            inc c
1694   0CEC 0A DE 0C      jmp __load_hex_loop
1695   0CEF             __load_hex_ret:
1696   0CEF 51 00 80      add sp, $8000
1697   0CF2 F0            pop di
1698   0CF3 EF            pop si
1699   0CF4 E7            pop d
1700   0CF5 E5            pop b
1701   0CF6 E4            pop a
1702   0CF7             ; --- END INLINE ASM BLOCK
1703   0CF7             
1704   0CF7 F9            leave
1705   0CF8 09            ret
1706   0CF9             
1707   0CF9             getparam:
1708   0CF9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1709   0CFC             ; $data 
1710   0CFC 52 01 00      sub sp, 1
1711   0CFF             
1712   0CFF             ; --- BEGIN INLINE ASM BLOCK
1713   0CFF 19 04         mov al, 4
1714   0D01 FA 05 00      lea d, [bp + 5] ; $address
1715   0D04 FD 2A         mov d, [d]
1716   0D06 05 0C         syscall sys_system
1717   0D08 FA 00 00      lea d, [bp + 0] ; $data
1718   0D0B FD 3E         mov [d], bl
1719   0D0D             ; --- END INLINE ASM BLOCK
1720   0D0D             
1721   0D0D             ;; return data; 
1722   0D0D FA 00 00      lea d, [bp + 0] ; $data
1723   0D10 32            mov bl, [d]
1724   0D11 A7 00         mov bh, 0
1725   0D13 F9            leave
1726   0D14 09            ret
1727   0D15             
1728   0D15             clear:
1729   0D15 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1730   0D18             ;; print("\033[2J\033[H"); 
1731   0D18 26 50 11      mov b, __s3 ; "\033[2J\033[H"
1732   0D1B FD AB         swp b
1733   0D1D D8            push b
1734   0D1E 07 32 0C      call print
1735   0D21 51 02 00      add sp, 2
1736   0D24 F9            leave
1737   0D25 09            ret
1738   0D26             
1739   0D26             printun:
1740   0D26 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1741   0D29             ;; print(prompt); 
1742   0D29 FA 07 00      lea d, [bp + 7] ; $prompt
1743   0D2C 2A            mov b, [d]
1744   0D2D FD AB         swp b
1745   0D2F D8            push b
1746   0D30 07 32 0C      call print
1747   0D33 51 02 00      add sp, 2
1748   0D36             ;; printu(n); 
1749   0D36 FA 05 00      lea d, [bp + 5] ; $n
1750   0D39 2A            mov b, [d]
1751   0D3A FD AB         swp b
1752   0D3C D8            push b
1753   0D3D 07 FE 0A      call printu
1754   0D40 51 02 00      add sp, 2
1755   0D43             ;; print("\n"); 
1756   0D43 26 58 11      mov b, __s4 ; "\n"
1757   0D46 FD AB         swp b
1758   0D48 D8            push b
1759   0D49 07 32 0C      call print
1760   0D4C 51 02 00      add sp, 2
1761   0D4F F9            leave
1762   0D50 09            ret
1763   0D51             
1764   0D51             printsn:
1765   0D51 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1766   0D54             ;; print(prompt); 
1767   0D54 FA 07 00      lea d, [bp + 7] ; $prompt
1768   0D57 2A            mov b, [d]
1769   0D58 FD AB         swp b
1770   0D5A D8            push b
1771   0D5B 07 32 0C      call print
1772   0D5E 51 02 00      add sp, 2
1773   0D61             ;; prints(n); 
1774   0D61 FA 05 00      lea d, [bp + 5] ; $n
1775   0D64 2A            mov b, [d]
1776   0D65 FD AB         swp b
1777   0D67 D8            push b
1778   0D68 07 09 0A      call prints
1779   0D6B 51 02 00      add sp, 2
1780   0D6E             ;; print("\n"); 
1781   0D6E 26 58 11      mov b, __s4 ; "\n"
1782   0D71 FD AB         swp b
1783   0D73 D8            push b
1784   0D74 07 32 0C      call print
1785   0D77 51 02 00      add sp, 2
1786   0D7A F9            leave
1787   0D7B 09            ret
1788   0D7C             
1789   0D7C             include_stdio_asm:
1790   0D7C F8 00 00      enter 0 ; (push bp; mov bp, sp)
1791   0D7F             
1792   0D7F             ; --- BEGIN INLINE ASM BLOCK
1793   0D7F             .include "lib/stdio.asm"
0001+  0D7F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0D7F             ; stdio.s
0003+  0D7F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0D7F             .include "lib/string.asm"
0001++ 0D7F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0D7F             ; string.s
0003++ 0D7F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0D7F             
0005++ 0D7F             
0006++ 0D7F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0D7F             ; _strrev
0008++ 0D7F             ; reverse a string
0009++ 0D7F             ; D = string address
0010++ 0D7F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0D7F             ; 01234
0012++ 0D7F             _strrev:
0013++ 0D7F 4B          	pusha
0014++ 0D80 07 C6 0D    	call _strlen	; length in C
0015++ 0D83 12          	mov a, c
0016++ 0D84 AF 01 00    	cmp a, 1
0017++ 0D87 D0 A1 0D    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 0D8A 7D          	dec a
0019++ 0D8B FD 4E       	mov si, d	; beginning of string
0020++ 0D8D FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0D8F 59          	add d, a	; end of string
0022++ 0D90 12          	mov a, c
0023++ 0D91 FD 9B       	shr a		; divide by 2
0024++ 0D93 39          	mov c, a	; C now counts the steps
0025++ 0D94             _strrev_L0:
0026++ 0D94 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0D95 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0D96 3E          	mov [d], al	; store left char into right side
0029++ 0D97 1B          	mov al, bl
0030++ 0D98 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0D99 7E          	dec c
0032++ 0D9A 7F          	dec d
0033++ 0D9B C2 00 00    	cmp c, 0
0034++ 0D9E C7 94 0D    	jne _strrev_L0
0035++ 0DA1             _strrev_end:
0036++ 0DA1 4C          	popa
0037++ 0DA2 09          	ret
0038++ 0DA3             	
0039++ 0DA3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0DA3             ; _strchr
0041++ 0DA3             ; search string in D for char in AL
0042++ 0DA3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0DA3             _strchr:
0044++ 0DA3             _strchr_L0:
0045++ 0DA3 32          	mov bl, [d]
0046++ 0DA4 C1 00       	cmp bl, 0
0047++ 0DA6 C6 B1 0D    	je _strchr_end
0048++ 0DA9 BA          	cmp al, bl
0049++ 0DAA C6 B1 0D    	je _strchr_end
0050++ 0DAD 79          	inc d
0051++ 0DAE 0A A3 0D    	jmp _strchr_L0
0052++ 0DB1             _strchr_end:
0053++ 0DB1 1B          	mov al, bl
0054++ 0DB2 09          	ret
0055++ 0DB3             
0056++ 0DB3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0DB3             ; _strstr
0058++ 0DB3             ; find sub-string
0059++ 0DB3             ; str1 in SI
0060++ 0DB3             ; str2 in DI
0061++ 0DB3             ; SI points to end of source string
0062++ 0DB3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0DB3             _strstr:
0064++ 0DB3 DB          	push al
0065++ 0DB4 DA          	push d
0066++ 0DB5 E3          	push di
0067++ 0DB6             _strstr_loop:
0068++ 0DB6 F3          	cmpsb					; compare a byte of the strings
0069++ 0DB7 C7 C2 0D    	jne _strstr_ret
0070++ 0DBA FC 00 00    	lea d, [di + 0]
0071++ 0DBD BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0DBF C7 B6 0D    	jne _strstr_loop				; equal chars but not at end
0073++ 0DC2             _strstr_ret:
0074++ 0DC2 F0          	pop di
0075++ 0DC3 E7          	pop d
0076++ 0DC4 E8          	pop al
0077++ 0DC5 09          	ret
0078++ 0DC6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0DC6             ; length of null terminated string
0080++ 0DC6             ; result in C
0081++ 0DC6             ; pointer in D
0082++ 0DC6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0DC6             _strlen:
0084++ 0DC6 DA          	push d
0085++ 0DC7 38 00 00    	mov c, 0
0086++ 0DCA             _strlen_L1:
0087++ 0DCA BD 00       	cmp byte [d], 0
0088++ 0DCC C6 D4 0D    	je _strlen_ret
0089++ 0DCF 79          	inc d
0090++ 0DD0 78          	inc c
0091++ 0DD1 0A CA 0D    	jmp _strlen_L1
0092++ 0DD4             _strlen_ret:
0093++ 0DD4 E7          	pop d
0094++ 0DD5 09          	ret
0095++ 0DD6             
0096++ 0DD6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0DD6             ; STRCMP
0098++ 0DD6             ; compare two strings
0099++ 0DD6             ; str1 in SI
0100++ 0DD6             ; str2 in DI
0101++ 0DD6             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0DD6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0DD6             _strcmp:
0104++ 0DD6 DB          	push al
0105++ 0DD7 DA          	push d
0106++ 0DD8 E3          	push di
0107++ 0DD9 E2          	push si
0108++ 0DDA             _strcmp_loop:
0109++ 0DDA F3          	cmpsb					; compare a byte of the strings
0110++ 0DDB C7 E6 0D    	jne _strcmp_ret
0111++ 0DDE FB FF FF    	lea d, [si +- 1]
0112++ 0DE1 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0DE3 C7 DA 0D    	jne _strcmp_loop				; equal chars but not at end
0114++ 0DE6             _strcmp_ret:
0115++ 0DE6 EF          	pop si
0116++ 0DE7 F0          	pop di
0117++ 0DE8 E7          	pop d
0118++ 0DE9 E8          	pop al
0119++ 0DEA 09          	ret
0120++ 0DEB             
0121++ 0DEB             
0122++ 0DEB             ; STRCPY
0123++ 0DEB             ; copy null terminated string from SI to DI
0124++ 0DEB             ; source in SI
0125++ 0DEB             ; destination in DI
0126++ 0DEB             _strcpy:
0127++ 0DEB E2          	push si
0128++ 0DEC E3          	push di
0129++ 0DED DB          	push al
0130++ 0DEE             _strcpy_L1:
0131++ 0DEE F6          	lodsb
0132++ 0DEF F7          	stosb
0133++ 0DF0 B9 00       	cmp al, 0
0134++ 0DF2 C7 EE 0D    	jne _strcpy_L1
0135++ 0DF5             _strcpy_end:
0136++ 0DF5 E8          	pop al
0137++ 0DF6 F0          	pop di
0138++ 0DF7 EF          	pop si
0139++ 0DF8 09          	ret
0140++ 0DF9             
0141++ 0DF9             ; STRCAT
0142++ 0DF9             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0DF9             ; source in SI
0144++ 0DF9             ; destination in DI
0145++ 0DF9             _strcat:
0146++ 0DF9 E2          	push si
0147++ 0DFA E3          	push di
0148++ 0DFB D7          	push a
0149++ 0DFC DA          	push d
0150++ 0DFD 50          	mov a, di
0151++ 0DFE 3C          	mov d, a
0152++ 0DFF             _strcat_goto_end_L1:
0153++ 0DFF BD 00       	cmp byte[d], 0
0154++ 0E01 C6 08 0E    	je _strcat_start
0155++ 0E04 79          	inc d
0156++ 0E05 0A FF 0D    	jmp _strcat_goto_end_L1
0157++ 0E08             _strcat_start:
0158++ 0E08 FD 50       	mov di, d
0159++ 0E0A             _strcat_L1:
0160++ 0E0A F6          	lodsb
0161++ 0E0B F7          	stosb
0162++ 0E0C B9 00       	cmp al, 0
0163++ 0E0E C7 0A 0E    	jne _strcat_L1
0164++ 0E11             _strcat_end:
0165++ 0E11 E7          	pop d
0166++ 0E12 E4          	pop a
0167++ 0E13 F0          	pop di
0168++ 0E14 EF          	pop si
0169++ 0E15 09          	ret
0170++ 0E16             
0171++ 0E16             
0005+  0E16             
0006+  0E16             
0007+  0E16             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  0E16             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  0E16             ; ASCII in BL
0010+  0E16             ; result in AL
0011+  0E16             ; ascii for F = 0100 0110
0012+  0E16             ; ascii for 9 = 0011 1001
0013+  0E16             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  0E16             hex_ascii_encode:
0015+  0E16 1B            mov al, bl
0016+  0E17 93 40         test al, $40        ; test if letter or number
0017+  0E19 C7 1F 0E      jnz hex_letter
0018+  0E1C 87 0F         and al, $0F        ; get number
0019+  0E1E 09            ret
0020+  0E1F             hex_letter:
0021+  0E1F 87 0F         and al, $0F        ; get letter
0022+  0E21 6A 09         add al, 9
0023+  0E23 09            ret
0024+  0E24             
0025+  0E24             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0E24             ; ATOI
0027+  0E24             ; 2 letter hex string in B
0028+  0E24             ; 8bit integer returned in AL
0029+  0E24             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  0E24             _atoi:
0031+  0E24 D8            push b
0032+  0E25 07 16 0E      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  0E28 30            mov bl, bh
0034+  0E29 DB            push al          ; save a
0035+  0E2A 07 16 0E      call hex_ascii_encode
0036+  0E2D EA            pop bl  
0037+  0E2E FD 9E 04      shl al, 4
0038+  0E31 8C            or al, bl
0039+  0E32 E5            pop b
0040+  0E33 09            ret  
0041+  0E34             
0042+  0E34             
0043+  0E34             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  0E34             ; scanf
0045+  0E34             ; no need for explanations!
0046+  0E34             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  0E34             scanf:
0048+  0E34 09            ret
0049+  0E35             
0050+  0E35             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0E35             ; ITOA
0052+  0E35             ; 8bit value in BL
0053+  0E35             ; 2 byte ASCII result in A
0054+  0E35             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0E35             _itoa:
0056+  0E35 DA            push d
0057+  0E36 D8            push b
0058+  0E37 A7 00         mov bh, 0
0059+  0E39 FD A4 04      shr bl, 4  
0060+  0E3C 74            mov d, b
0061+  0E3D 1F E5 10      mov al, [d + s_hex_digits]
0062+  0E40 23            mov ah, al
0063+  0E41               
0064+  0E41 E5            pop b
0065+  0E42 D8            push b
0066+  0E43 A7 00         mov bh, 0
0067+  0E45 FD 87 0F      and bl, $0F
0068+  0E48 74            mov d, b
0069+  0E49 1F E5 10      mov al, [d + s_hex_digits]
0070+  0E4C E5            pop b
0071+  0E4D E7            pop d
0072+  0E4E 09            ret
0073+  0E4F             
0074+  0E4F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  0E4F             ; HEX STRING TO BINARY
0076+  0E4F             ; di = destination address
0077+  0E4F             ; si = source
0078+  0E4F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  0E4F             _hex_to_int:
0080+  0E4F             _hex_to_int_L1:
0081+  0E4F F6            lodsb          ; load from [SI] to AL
0082+  0E50 B9 00         cmp al, 0        ; check if ASCII 0
0083+  0E52 C6 5F 0E      jz _hex_to_int_ret
0084+  0E55 36            mov bh, al
0085+  0E56 F6            lodsb
0086+  0E57 2F            mov bl, al
0087+  0E58 07 24 0E      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  0E5B F7            stosb          ; store AL to [DI]
0089+  0E5C 0A 4F 0E      jmp _hex_to_int_L1
0090+  0E5F             _hex_to_int_ret:
0091+  0E5F 09            ret    
0092+  0E60             
0093+  0E60             
0094+  0E60             
0095+  0E60             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  0E60             ; GETCHAR
0097+  0E60             ; char in ah
0098+  0E60             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  0E60             getch:
0100+  0E60 DB            push al
0101+  0E61             getch_retry:
0102+  0E61 19 01         mov al, 1
0103+  0E63 05 03         syscall sys_io      ; receive in AH
0104+  0E65 E8            pop al
0105+  0E66 09            ret
0106+  0E67             
0107+  0E67             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  0E67             ; PUTCHAR
0109+  0E67             ; char in ah
0110+  0E67             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0E67             _putchar:
0112+  0E67 D7            push a
0113+  0E68 19 00         mov al, 0
0114+  0E6A 05 03         syscall sys_io      ; char in AH
0115+  0E6C E4            pop a
0116+  0E6D 09            ret
0117+  0E6E             
0118+  0E6E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  0E6E             ;; INPUT A STRING
0120+  0E6E             ;; terminates with null
0121+  0E6E             ;; pointer in D
0122+  0E6E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  0E6E             _gets:
0124+  0E6E D7            push a
0125+  0E6F DA            push d
0126+  0E70             _gets_loop:
0127+  0E70 19 01         mov al, 1
0128+  0E72 05 03         syscall sys_io      ; receive in AH
0129+  0E74 B9 00         cmp al, 0        ; check error code (AL)
0130+  0E76 C6 70 0E      je _gets_loop      ; if no char received, retry
0131+  0E79             
0132+  0E79 76 1B         cmp ah, 27
0133+  0E7B C6 9C 0E      je _gets_ansi_esc
0134+  0E7E 76 0A         cmp ah, $0A        ; LF
0135+  0E80 C6 07 0F      je _gets_end
0136+  0E83 76 0D         cmp ah, $0D        ; CR
0137+  0E85 C6 07 0F      je _gets_end
0138+  0E88 76 5C         cmp ah, $5C        ; '\\'
0139+  0E8A C6 C8 0E      je _gets_escape
0140+  0E8D               
0141+  0E8D 76 08         cmp ah, $08      ; check for backspace
0142+  0E8F C6 98 0E      je _gets_backspace
0143+  0E92             
0144+  0E92 1A            mov al, ah
0145+  0E93 3E            mov [d], al
0146+  0E94 79            inc d
0147+  0E95 0A 70 0E      jmp _gets_loop
0148+  0E98             _gets_backspace:
0149+  0E98 7F            dec d
0150+  0E99 0A 70 0E      jmp _gets_loop
0151+  0E9C             _gets_ansi_esc:
0152+  0E9C 19 01         mov al, 1
0153+  0E9E 05 03         syscall sys_io        ; receive in AH without echo
0154+  0EA0 B9 00         cmp al, 0          ; check error code (AL)
0155+  0EA2 C6 9C 0E      je _gets_ansi_esc    ; if no char received, retry
0156+  0EA5 76 5B         cmp ah, '['
0157+  0EA7 C7 70 0E      jne _gets_loop
0158+  0EAA             _gets_ansi_esc_2:
0159+  0EAA 19 01         mov al, 1
0160+  0EAC 05 03         syscall sys_io          ; receive in AH without echo
0161+  0EAE B9 00         cmp al, 0            ; check error code (AL)
0162+  0EB0 C6 AA 0E      je _gets_ansi_esc_2  ; if no char received, retry
0163+  0EB3 76 44         cmp ah, 'D'
0164+  0EB5 C6 C0 0E      je _gets_left_arrow
0165+  0EB8 76 43         cmp ah, 'C'
0166+  0EBA C6 C4 0E      je _gets_right_arrow
0167+  0EBD 0A 70 0E      jmp _gets_loop
0168+  0EC0             _gets_left_arrow:
0169+  0EC0 7F            dec d
0170+  0EC1 0A 70 0E      jmp _gets_loop
0171+  0EC4             _gets_right_arrow:
0172+  0EC4 79            inc d
0173+  0EC5 0A 70 0E      jmp _gets_loop
0174+  0EC8             _gets_escape:
0175+  0EC8 19 01         mov al, 1
0176+  0ECA 05 03         syscall sys_io      ; receive in AH
0177+  0ECC B9 00         cmp al, 0        ; check error code (AL)
0178+  0ECE C6 C8 0E      je _gets_escape      ; if no char received, retry
0179+  0ED1 76 6E         cmp ah, 'n'
0180+  0ED3 C6 F2 0E      je _gets_LF
0181+  0ED6 76 72         cmp ah, 'r'
0182+  0ED8 C6 F9 0E      je _gets_CR
0183+  0EDB 76 30         cmp ah, '0'
0184+  0EDD C6 00 0F      je _gets_NULL
0185+  0EE0 76 5C         cmp ah, $5C  ; '\'
0186+  0EE2 C6 EB 0E      je _gets_slash
0187+  0EE5 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0188+  0EE6 3E            mov [d], al
0189+  0EE7 79            inc d
0190+  0EE8 0A 70 0E      jmp _gets_loop
0191+  0EEB             _gets_slash:
0192+  0EEB 19 5C         mov al, $5C
0193+  0EED 3E            mov [d], al
0194+  0EEE 79            inc d
0195+  0EEF 0A 70 0E      jmp _gets_loop
0196+  0EF2             _gets_LF:
0197+  0EF2 19 0A         mov al, $0A
0198+  0EF4 3E            mov [d], al
0199+  0EF5 79            inc d
0200+  0EF6 0A 70 0E      jmp _gets_loop
0201+  0EF9             _gets_CR:
0202+  0EF9 19 0D         mov al, $0D
0203+  0EFB 3E            mov [d], al
0204+  0EFC 79            inc d
0205+  0EFD 0A 70 0E      jmp _gets_loop
0206+  0F00             _gets_NULL:
0207+  0F00 19 00         mov al, $00
0208+  0F02 3E            mov [d], al
0209+  0F03 79            inc d
0210+  0F04 0A 70 0E      jmp _gets_loop
0211+  0F07             _gets_end:
0212+  0F07 19 00         mov al, 0
0213+  0F09 3E            mov [d], al        ; terminate string
0214+  0F0A E7            pop d
0215+  0F0B E4            pop a
0216+  0F0C 09            ret
0217+  0F0D             
0218+  0F0D             
0219+  0F0D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0220+  0F0D             ;; INPUT TEXT
0221+  0F0D             ;; terminated with CTRL+D
0222+  0F0D             ;; pointer in D
0223+  0F0D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0224+  0F0D             _gettxt:
0225+  0F0D D7            push a
0226+  0F0E DA            push d
0227+  0F0F             _gettxt_loop:
0228+  0F0F 19 01         mov al, 1
0229+  0F11 05 03         syscall sys_io      ; receive in AH
0230+  0F13 B9 00         cmp al, 0        ; check error code (AL)
0231+  0F15 C6 0F 0F      je _gettxt_loop    ; if no char received, retry
0232+  0F18 76 04         cmp ah, 4      ; EOT
0233+  0F1A C6 58 0F      je _gettxt_end
0234+  0F1D 76 08         cmp ah, $08      ; check for backspace
0235+  0F1F C6 54 0F      je _gettxt_backspace
0236+  0F22 76 5C         cmp ah, $5C        ; '\'
0237+  0F24 C6 2D 0F      je _gettxt_escape
0238+  0F27 1A            mov al, ah
0239+  0F28 3E            mov [d], al
0240+  0F29 79            inc d
0241+  0F2A 0A 0F 0F      jmp _gettxt_loop
0242+  0F2D             _gettxt_escape:
0243+  0F2D 19 01         mov al, 1
0244+  0F2F 05 03         syscall sys_io      ; receive in AH
0245+  0F31 B9 00         cmp al, 0        ; check error code (AL)
0246+  0F33 C6 2D 0F      je _gettxt_escape    ; if no char received, retry
0247+  0F36 76 6E         cmp ah, 'n'
0248+  0F38 C6 46 0F      je _gettxt_LF
0249+  0F3B 76 72         cmp ah, 'r'
0250+  0F3D C6 4D 0F      je _gettxt_CR
0251+  0F40 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0252+  0F41 3E            mov [d], al
0253+  0F42 79            inc d
0254+  0F43 0A 0F 0F      jmp _gettxt_loop
0255+  0F46             _gettxt_LF:
0256+  0F46 19 0A         mov al, $0A
0257+  0F48 3E            mov [d], al
0258+  0F49 79            inc d
0259+  0F4A 0A 0F 0F      jmp _gettxt_loop
0260+  0F4D             _gettxt_CR:
0261+  0F4D 19 0D         mov al, $0D
0262+  0F4F 3E            mov [d], al
0263+  0F50 79            inc d
0264+  0F51 0A 0F 0F      jmp _gettxt_loop
0265+  0F54             _gettxt_backspace:
0266+  0F54 7F            dec d
0267+  0F55 0A 0F 0F      jmp _gettxt_loop
0268+  0F58             _gettxt_end:
0269+  0F58 19 00         mov al, 0
0270+  0F5A 3E            mov [d], al        ; terminate string
0271+  0F5B E7            pop d
0272+  0F5C E4            pop a
0273+  0F5D 09            ret
0274+  0F5E             
0275+  0F5E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  0F5E             ; PRINT NEW LINE
0277+  0F5E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0278+  0F5E             printnl:
0279+  0F5E D7            push a
0280+  0F5F 10 00 0A      mov a, $0A00
0281+  0F62 05 03         syscall sys_io
0282+  0F64 10 00 0D      mov a, $0D00
0283+  0F67 05 03         syscall sys_io
0284+  0F69 E4            pop a
0285+  0F6A 09            ret
0286+  0F6B             
0287+  0F6B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  0F6B             ; _strtoint
0289+  0F6B             ; 4 digit hex string number in d
0290+  0F6B             ; integer returned in A
0291+  0F6B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0292+  0F6B             _strtointx:
0293+  0F6B D8            push b
0294+  0F6C 32            mov bl, [d]
0295+  0F6D 37            mov bh, bl
0296+  0F6E 33 01 00      mov bl, [d + 1]
0297+  0F71 07 24 0E      call _atoi        ; convert to int in AL
0298+  0F74 23            mov ah, al        ; move to AH
0299+  0F75 33 02 00      mov bl, [d + 2]
0300+  0F78 37            mov bh, bl
0301+  0F79 33 03 00      mov bl, [d + 3]
0302+  0F7C 07 24 0E      call _atoi        ; convert to int in AL
0303+  0F7F E5            pop b
0304+  0F80 09            ret
0305+  0F81             
0306+  0F81             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0307+  0F81             ; _strtoint
0308+  0F81             ; 5 digit base10 string number in d
0309+  0F81             ; integer returned in A
0310+  0F81             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0311+  0F81             _strtoint:
0312+  0F81 E2            push si
0313+  0F82 D8            push b
0314+  0F83 D9            push c
0315+  0F84 DA            push d
0316+  0F85 07 C6 0D      call _strlen      ; get string length in C
0317+  0F88 7E            dec c
0318+  0F89 FD 4E         mov si, d
0319+  0F8B 12            mov a, c
0320+  0F8C FD 99         shl a
0321+  0F8E 3B FD 10      mov d, table_power
0322+  0F91 59            add d, a
0323+  0F92 38 00 00      mov c, 0
0324+  0F95             _strtoint_L0:
0325+  0F95 F6            lodsb      ; load ASCII to al
0326+  0F96 B9 00         cmp al, 0
0327+  0F98 C6 AB 0F      je _strtoint_end
0328+  0F9B 6F 30         sub al, $30    ; make into integer
0329+  0F9D 22 00         mov ah, 0
0330+  0F9F 2A            mov b, [d]
0331+  0FA0 AC            mul a, b      ; result in B since it fits in 16bits
0332+  0FA1 11            mov a, b
0333+  0FA2 28            mov b, c
0334+  0FA3 54            add a, b
0335+  0FA4 39            mov c, a
0336+  0FA5 63 02 00      sub d, 2
0337+  0FA8 0A 95 0F      jmp _strtoint_L0
0338+  0FAB             _strtoint_end:
0339+  0FAB 12            mov a, c
0340+  0FAC E7            pop d
0341+  0FAD E6            pop c
0342+  0FAE E5            pop b
0343+  0FAF EF            pop si
0344+  0FB0 09            ret
0345+  0FB1             
0346+  0FB1             
0347+  0FB1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0348+  0FB1             ; PRINT NULL TERMINATED STRING
0349+  0FB1             ; pointer in D
0350+  0FB1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0351+  0FB1             _puts:
0352+  0FB1 D7            push a
0353+  0FB2 DA            push d
0354+  0FB3             _puts_L1:
0355+  0FB3 1E            mov al, [d]
0356+  0FB4 B9 00         cmp al, 0
0357+  0FB6 C6 C2 0F      jz _puts_END
0358+  0FB9 23            mov ah, al
0359+  0FBA 19 00         mov al, 0
0360+  0FBC 05 03         syscall sys_io
0361+  0FBE 79            inc d
0362+  0FBF 0A B3 0F      jmp _puts_L1
0363+  0FC2             _puts_END:
0364+  0FC2 E7            pop d
0365+  0FC3 E4            pop a
0366+  0FC4 09            ret
0367+  0FC5             
0368+  0FC5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0369+  0FC5             ; PRINT N SIZE STRING
0370+  0FC5             ; pointer in D
0371+  0FC5             ; size in C
0372+  0FC5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0373+  0FC5             _putsn:
0374+  0FC5 DB            push al
0375+  0FC6 DA            push d
0376+  0FC7 D9            push c
0377+  0FC8             _putsn_L0:
0378+  0FC8 1E            mov al, [d]
0379+  0FC9 23            mov ah, al
0380+  0FCA 19 00         mov al, 0
0381+  0FCC 05 03         syscall sys_io
0382+  0FCE 79            inc d
0383+  0FCF 7E            dec c  
0384+  0FD0 C2 00 00      cmp c, 0
0385+  0FD3 C7 C8 0F      jne _putsn_L0
0386+  0FD6             _putsn_end:
0387+  0FD6 E6            pop c
0388+  0FD7 E7            pop d
0389+  0FD8 E8            pop al
0390+  0FD9 09            ret
0391+  0FDA             
0392+  0FDA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0393+  0FDA             ; print 16bit decimal number
0394+  0FDA             ; input number in A
0395+  0FDA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0396+  0FDA             print_u16d:
0397+  0FDA D7            push a
0398+  0FDB D8            push b
0399+  0FDC 26 10 27      mov b, 10000
0400+  0FDF AE            div a, b      ; get 10000's coeff.
0401+  0FE0 07 02 10      call print_number
0402+  0FE3 11            mov a, b
0403+  0FE4 26 E8 03      mov b, 1000
0404+  0FE7 AE            div a, b      ; get 1000's coeff.
0405+  0FE8 07 02 10      call print_number
0406+  0FEB 11            mov a, b
0407+  0FEC 26 64 00      mov b, 100
0408+  0FEF AE            div a, b
0409+  0FF0 07 02 10      call print_number
0410+  0FF3 11            mov a, b
0411+  0FF4 26 0A 00      mov b, 10
0412+  0FF7 AE            div a, b
0413+  0FF8 07 02 10      call print_number
0414+  0FFB 1B            mov al, bl      ; 1's coeff in bl
0415+  0FFC 07 02 10      call print_number
0416+  0FFF E5            pop b
0417+  1000 E4            pop a
0418+  1001 09            ret
0419+  1002             
0420+  1002             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0421+  1002             ; print AL
0422+  1002             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0423+  1002             print_number:
0424+  1002 6A 30         add al, $30
0425+  1004 23            mov ah, al
0426+  1005 07 67 0E      call _putchar
0427+  1008 09            ret
0428+  1009             
0429+  1009             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0430+  1009             ; PRINT 16BIT HEX INTEGER
0431+  1009             ; integer value in reg B
0432+  1009             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  1009             print_u16x:
0434+  1009 D7            push a
0435+  100A D8            push b
0436+  100B DD            push bl
0437+  100C 30            mov bl, bh
0438+  100D 07 35 0E      call _itoa        ; convert bh to char in A
0439+  1010 2F            mov bl, al        ; save al
0440+  1011 19 00         mov al, 0
0441+  1013 05 03         syscall sys_io        ; display AH
0442+  1015 24            mov ah, bl        ; retrieve al
0443+  1016 19 00         mov al, 0
0444+  1018 05 03         syscall sys_io        ; display AL
0445+  101A             
0446+  101A EA            pop bl
0447+  101B 07 35 0E      call _itoa        ; convert bh to char in A
0448+  101E 2F            mov bl, al        ; save al
0449+  101F 19 00         mov al, 0
0450+  1021 05 03         syscall sys_io        ; display AH
0451+  1023 24            mov ah, bl        ; retrieve al
0452+  1024 19 00         mov al, 0
0453+  1026 05 03         syscall sys_io        ; display AL
0454+  1028             
0455+  1028 E5            pop b
0456+  1029 E4            pop a
0457+  102A 09            ret
0458+  102B             
0459+  102B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0460+  102B             ; INPUT 16BIT HEX INTEGER
0461+  102B             ; read 16bit integer into A
0462+  102B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0463+  102B             scan_u16x:
0464+  102B F8 10 00      enter 16
0465+  102E D8            push b
0466+  102F DA            push d
0467+  1030             
0468+  1030 FA F1 FF      lea d, [bp + -15]
0469+  1033 07 6E 0E      call _gets        ; get number
0470+  1036             
0471+  1036 32            mov bl, [d]
0472+  1037 37            mov bh, bl
0473+  1038 33 01 00      mov bl, [d + 1]
0474+  103B 07 24 0E      call _atoi        ; convert to int in AL
0475+  103E 23            mov ah, al        ; move to AH
0476+  103F             
0477+  103F 33 02 00      mov bl, [d + 2]
0478+  1042 37            mov bh, bl
0479+  1043 33 03 00      mov bl, [d + 3]
0480+  1046 07 24 0E      call _atoi        ; convert to int in AL
0481+  1049             
0482+  1049 E7            pop d
0483+  104A E5            pop b
0484+  104B F9            leave
0485+  104C 09            ret
0486+  104D             
0487+  104D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0488+  104D             ; PRINT 8bit HEX INTEGER
0489+  104D             ; integer value in reg bl
0490+  104D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0491+  104D             print_u8x:
0492+  104D D7            push a
0493+  104E DD            push bl
0494+  104F             
0495+  104F 07 35 0E      call _itoa        ; convert bl to char in A
0496+  1052 2F            mov bl, al        ; save al
0497+  1053 19 00         mov al, 0
0498+  1055 05 03         syscall sys_io        ; display AH
0499+  1057 24            mov ah, bl        ; retrieve al
0500+  1058 19 00         mov al, 0
0501+  105A 05 03         syscall sys_io        ; display AL
0502+  105C             
0503+  105C EA            pop bl
0504+  105D E4            pop a
0505+  105E 09            ret
0506+  105F             
0507+  105F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0508+  105F             ; print 8bit decimal unsigned number
0509+  105F             ; input number in AL
0510+  105F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0511+  105F             print_u8d:
0512+  105F D7            push a
0513+  1060 D8            push b
0514+  1061             
0515+  1061 22 00         mov ah, 0
0516+  1063 26 64 00      mov b, 100
0517+  1066 AE            div a, b
0518+  1067 D8            push b      ; save remainder
0519+  1068 B9 00         cmp al, 0
0520+  106A C6 74 10      je skip100
0521+  106D 6A 30         add al, $30
0522+  106F 23            mov ah, al
0523+  1070 19 00         mov al, 0
0524+  1072 05 03         syscall sys_io  ; print coeff
0525+  1074             skip100:
0526+  1074 E4            pop a
0527+  1075 22 00         mov ah, 0
0528+  1077 26 0A 00      mov b, 10
0529+  107A AE            div a, b
0530+  107B D8            push b      ; save remainder
0531+  107C B9 00         cmp al, 0
0532+  107E C6 88 10      je skip10
0533+  1081 6A 30         add al, $30
0534+  1083 23            mov ah, al
0535+  1084 19 00         mov al, 0
0536+  1086 05 03         syscall sys_io  ; print coeff
0537+  1088             skip10:
0538+  1088 E4            pop a
0539+  1089 1B            mov al, bl
0540+  108A 6A 30         add al, $30
0541+  108C 23            mov ah, al
0542+  108D 19 00         mov al, 0
0543+  108F 05 03         syscall sys_io  ; print coeff
0544+  1091 E5            pop b
0545+  1092 E4            pop a
0546+  1093 09            ret
0547+  1094             
0548+  1094             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0549+  1094             ; INPUT 8BIT HEX INTEGER
0550+  1094             ; read 8bit integer into AL
0551+  1094             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0552+  1094             scan_u8x:
0553+  1094 F8 04 00      enter 4
0554+  1097 D8            push b
0555+  1098 DA            push d
0556+  1099             
0557+  1099 FA FD FF      lea d, [bp + -3]
0558+  109C 07 6E 0E      call _gets        ; get number
0559+  109F             
0560+  109F 32            mov bl, [d]
0561+  10A0 37            mov bh, bl
0562+  10A1 33 01 00      mov bl, [d + 1]
0563+  10A4 07 24 0E      call _atoi        ; convert to int in AL
0564+  10A7             
0565+  10A7 E7            pop d
0566+  10A8 E5            pop b
0567+  10A9 F9            leave
0568+  10AA 09            ret
0569+  10AB             
0570+  10AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  10AB             ; input decimal number
0572+  10AB             ; result in A
0573+  10AB             ; 655'\0'
0574+  10AB             ; low--------high
0575+  10AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0576+  10AB             scan_u16d:
0577+  10AB F8 08 00      enter 8
0578+  10AE E2            push si
0579+  10AF D8            push b
0580+  10B0 D9            push c
0581+  10B1 DA            push d
0582+  10B2 FA F9 FF      lea d, [bp +- 7]
0583+  10B5 07 6E 0E      call _gets
0584+  10B8 07 C6 0D      call _strlen      ; get string length in C
0585+  10BB 7E            dec c
0586+  10BC FD 4E         mov si, d
0587+  10BE 12            mov a, c
0588+  10BF FD 99         shl a
0589+  10C1 3B FD 10      mov d, table_power
0590+  10C4 59            add d, a
0591+  10C5 38 00 00      mov c, 0
0592+  10C8             mul_loop:
0593+  10C8 F6            lodsb      ; load ASCII to al
0594+  10C9 B9 00         cmp al, 0
0595+  10CB C6 DE 10      je mul_exit
0596+  10CE 6F 30         sub al, $30    ; make into integer
0597+  10D0 22 00         mov ah, 0
0598+  10D2 2A            mov b, [d]
0599+  10D3 AC            mul a, b      ; result in B since it fits in 16bits
0600+  10D4 11            mov a, b
0601+  10D5 28            mov b, c
0602+  10D6 54            add a, b
0603+  10D7 39            mov c, a
0604+  10D8 63 02 00      sub d, 2
0605+  10DB 0A C8 10      jmp mul_loop
0606+  10DE             mul_exit:
0607+  10DE 12            mov a, c
0608+  10DF E7            pop d
0609+  10E0 E6            pop c
0610+  10E1 E5            pop b
0611+  10E2 EF            pop si
0612+  10E3 F9            leave
0613+  10E4 09            ret
0614+  10E5             
0615+  10E5             
0616+  10E5 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0616+  10E9 34 35 36 37 
0616+  10ED 38 39 41 42 
0616+  10F1 43 44 45 46 
0617+  10F5 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0617+  10F9 1B 5B 48 00 
0618+  10FD             
0619+  10FD             table_power:
0620+  10FD 01 00         .dw 1
0621+  10FF 0A 00         .dw 10
0622+  1101 64 00         .dw 100
0623+  1103 E8 03         .dw 1000
0624+  1105 10 27         .dw 100001794   1107             ; --- END INLINE ASM BLOCK
1795   1107             
1796   1107 F9            leave
1797   1108 09            ret
1798   1109             ; --- END TEXT BLOCK
1799   1109             
1800   1109             ; --- BEGIN DATA BLOCK
1801   1109 50 61 75 6C __s0: .db "Paulo", 0
1801   110D 6F 00 
1802   110F 43 68 61 72 __s1: .db "Char: %c, String: %s, Integer: %d", 0
1802   1113 3A 20 25 63 
1802   1117 2C 20 53 74 
1802   111B 72 69 6E 67 
1802   111F 3A 20 25 73 
1802   1123 2C 20 49 6E 
1802   1127 74 65 67 65 
1802   112B 72 3A 20 25 
1802   112F 64 00 
1803   1131 45 72 72 6F __s2: .db "Error: Unknown argument type.\n", 0
1803   1135 72 3A 20 55 
1803   1139 6E 6B 6E 6F 
1803   113D 77 6E 20 61 
1803   1141 72 67 75 6D 
1803   1145 65 6E 74 20 
1803   1149 74 79 70 65 
1803   114D 2E 0A 00 
1804   1150 1B 5B 32 4A __s3: .db "\033[2J\033[H", 0
1804   1154 1B 5B 48 00 
1805   1158 0A 00       __s4: .db "\n", 0
1806   115A             
1807   115A 5C 11       _heap_top: .dw _heap
1808   115C 00          _heap: .db 0
1809   115D             ; --- END DATA BLOCK
1810   115D             
1811   115D             .end
tasm: Number of errors = 0
