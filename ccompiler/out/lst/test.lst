0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT SEGMENT
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; if(10 * 5 % 49 == 1) 
0011   0408             _if1_cond:
0012   0408 FD 2E 0A 00   mov32 cb, $0000000a
0012   040C 00 00 
0013   040E             ; --- START FACTORS
0014   040E D7            push a
0015   040F FD D8         push g
0016   0411 11            mov a, b
0017   0412 FD 7A         mov g, c
0018   0414 FD 2E 05 00   mov32 cb, $00000005
0018   0418 00 00 
0019   041A D7            push a     ; save left operand
0020   041B 8E            xor a, b   ; xor sign bits
0021   041C FD AA         swp a      ; swap bytes
0022   041E 83            mov cl, al ; save result of xor into 'dl'
0023   041F E4            pop a      ; restore left side operator
0024   0420 DF            push cl    ; save result of xor above
0025   0421 FD AA         swp a  
0026   0423 93 80         test al, $80  
0027   0425 FD AA         swp a  
0028   0427 C6 2C 04      jz skip_invert_a_4  
0029   042A FD 95         neg a 
0030   042C             skip_invert_a_4:   
0031   042C FD AB         swp b
0032   042E FD 93 80      test bl, $80  
0033   0431 FD AB         swp b
0034   0433 C6 38 04      jz skip_invert_b_4  
0035   0436 FD 97         neg b 
0036   0438             skip_invert_b_4:   
0037   0438 AC            mul a, b ; *
0038   0439 FD 78         mov g, a
0039   043B 11            mov a, b
0040   043C EA            pop bl
0041   043D FD 93 80      test bl, $80
0042   0440 C6 51 04      jz _same_signs_4
0043   0443 27            mov b, a
0044   0444 FD 12         mov a, g
0045   0446 95            not a
0046   0447 97            not b
0047   0448 55 01 00      add b, 1
0048   044B 5B 00 00      adc a, 0
0049   044E FD 78         mov g, a
0050   0450 11            mov a, b
0051   0451             _same_signs_4:
0052   0451 FD 2E 31 00   mov32 cb, $00000031
0052   0455 00 00 
0053   0457 AE            div a, b ; %, a: quotient, b: remainder
0054   0458 11            mov a, b
0055   0459 FD 38         mov c, g
0056   045B 27            mov b, a
0057   045C FD F1         pop g
0058   045E E4            pop a
0059   045F             ; --- END FACTORS
0060   045F             ; --- START RELATIONAL
0061   045F D7            push a
0062   0460 FD D8         push g
0063   0462 11            mov a, b
0064   0463 FD 7A         mov g, c
0065   0465 FD 2E 01 00   mov32 cb, $00000001
0065   0469 00 00 
0066   046B FD AF         cmp32 ga, cb
0067   046D FD 71         seq ; ==
0068   046F FD F1         pop g
0069   0471 E4            pop a
0070   0472             ; --- END RELATIONAL
0071   0472 C0 00 00      cmp b, 0
0072   0475 C6 87 04      je _if1_exit
0073   0478             _if1_TRUE:
0074   0478             ; printf("Okay"); 
0075   0478             ; --- START FUNCTION CALL
0076   0478 26 76 0D      mov b, _s0 ; "Okay"
0077   047B FD AB         swp b
0078   047D D8            push b
0079   047E 07 89 04      call printf
0080   0481 51 02 00      add sp, 2
0081   0484             ; --- END FUNCTION CALL
0082   0484 0A 87 04      jmp _if1_exit
0083   0487             _if1_exit:
0084   0487 05 0B         syscall sys_terminate_proc
0085   0489             
0086   0489             printf:
0087   0489 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0088   048C             ; char *p, *format_p; 
0089   048C 52 02 00      sub sp, 2
0090   048F 52 02 00      sub sp, 2
0091   0492             ; format_p = format; 
0092   0492 FA FD FF      lea d, [bp + -3] ; $format_p
0093   0495 DA            push d
0094   0496 FA 05 00      lea d, [bp + 5] ; $format
0095   0499 2A            mov b, [d]
0096   049A 38 00 00      mov c, 0
0097   049D E7            pop d
0098   049E FD 43         mov [d], b
0099   04A0             ; p = &format + 2; 
0100   04A0 FA FF FF      lea d, [bp + -1] ; $p
0101   04A3 DA            push d
0102   04A4 FA 05 00      lea d, [bp + 5] ; $format
0103   04A7 2D            mov b, d
0104   04A8             ; --- START TERMS
0105   04A8 D7            push a
0106   04A9 11            mov a, b
0107   04AA FD 2E 02 00   mov32 cb, $00000002
0107   04AE 00 00 
0108   04B0 56            add b, a
0109   04B1 E4            pop a
0110   04B2             ; --- END TERMS
0111   04B2 E7            pop d
0112   04B3 FD 43         mov [d], b
0113   04B5             ; for(;;){ 
0114   04B5             _for6_init:
0115   04B5             _for6_cond:
0116   04B5             _for6_block:
0117   04B5             ; if(!*format_p) break; 
0118   04B5             _if7_cond:
0119   04B5 FA FD FF      lea d, [bp + -3] ; $format_p
0120   04B8 2A            mov b, [d]
0121   04B9 38 00 00      mov c, 0
0122   04BC 74            mov d, b
0123   04BD 32            mov bl, [d]
0124   04BE A7 00         mov bh, 0
0125   04C0 38 00 00      mov c, 0
0126   04C3 C0 00 00      cmp b, 0
0127   04C6 FD 71         seq ; !
0128   04C8 C0 00 00      cmp b, 0
0129   04CB C6 D4 04      je _if7_else
0130   04CE             _if7_TRUE:
0131   04CE             ; break; 
0132   04CE 0A 84 07      jmp _for6_exit ; for break
0133   04D1 0A 81 07      jmp _if7_exit
0134   04D4             _if7_else:
0135   04D4             ; if(*format_p == '%'){ 
0136   04D4             _if8_cond:
0137   04D4 FA FD FF      lea d, [bp + -3] ; $format_p
0138   04D7 2A            mov b, [d]
0139   04D8 38 00 00      mov c, 0
0140   04DB 74            mov d, b
0141   04DC 32            mov bl, [d]
0142   04DD A7 00         mov bh, 0
0143   04DF 38 00 00      mov c, 0
0144   04E2             ; --- START RELATIONAL
0145   04E2 D7            push a
0146   04E3 11            mov a, b
0147   04E4 FD 2E 25 00   mov32 cb, $00000025
0147   04E8 00 00 
0148   04EA B0            cmp a, b
0149   04EB FD 71         seq ; ==
0150   04ED E4            pop a
0151   04EE             ; --- END RELATIONAL
0152   04EE C0 00 00      cmp b, 0
0153   04F1 C6 5C 07      je _if8_else
0154   04F4             _if8_TRUE:
0155   04F4             ; format_p++; 
0156   04F4 FA FD FF      lea d, [bp + -3] ; $format_p
0157   04F7 2A            mov b, [d]
0158   04F8 38 00 00      mov c, 0
0159   04FB FD 77         inc b
0160   04FD FA FD FF      lea d, [bp + -3] ; $format_p
0161   0500 FD 43         mov [d], b
0162   0502 FD 7D         dec b
0163   0504             ; switch(*format_p){ 
0164   0504             _switch9_expr:
0165   0504 FA FD FF      lea d, [bp + -3] ; $format_p
0166   0507 2A            mov b, [d]
0167   0508 38 00 00      mov c, 0
0168   050B 74            mov d, b
0169   050C 32            mov bl, [d]
0170   050D A7 00         mov bh, 0
0171   050F 38 00 00      mov c, 0
0172   0512             _switch9_comparisons:
0173   0512 C1 6C         cmp bl, $6c
0174   0514 C6 40 05      je _switch9_case0
0175   0517 C1 4C         cmp bl, $4c
0176   0519 C6 40 05      je _switch9_case1
0177   051C C1 64         cmp bl, $64
0178   051E C6 50 06      je _switch9_case2
0179   0521 C1 69         cmp bl, $69
0180   0523 C6 50 06      je _switch9_case3
0181   0526 C1 75         cmp bl, $75
0182   0528 C6 80 06      je _switch9_case4
0183   052B C1 78         cmp bl, $78
0184   052D C6 B0 06      je _switch9_case5
0185   0530 C1 63         cmp bl, $63
0186   0532 C6 E0 06      je _switch9_case6
0187   0535 C1 73         cmp bl, $73
0188   0537 C6 10 07      je _switch9_case7
0189   053A 0A 3D 07      jmp _switch9_default
0190   053D 0A 49 07      jmp _switch9_exit
0191   0540             _switch9_case0:
0192   0540             _switch9_case1:
0193   0540             ; format_p++; 
0194   0540 FA FD FF      lea d, [bp + -3] ; $format_p
0195   0543 2A            mov b, [d]
0196   0544 38 00 00      mov c, 0
0197   0547 FD 77         inc b
0198   0549 FA FD FF      lea d, [bp + -3] ; $format_p
0199   054C FD 43         mov [d], b
0200   054E FD 7D         dec b
0201   0550             ; if(*format_p == 'd' || *format_p == 'i') 
0202   0550             _if10_cond:
0203   0550 FA FD FF      lea d, [bp + -3] ; $format_p
0204   0553 2A            mov b, [d]
0205   0554 38 00 00      mov c, 0
0206   0557 74            mov d, b
0207   0558 32            mov bl, [d]
0208   0559 A7 00         mov bh, 0
0209   055B 38 00 00      mov c, 0
0210   055E             ; --- START RELATIONAL
0211   055E D7            push a
0212   055F 11            mov a, b
0213   0560 FD 2E 64 00   mov32 cb, $00000064
0213   0564 00 00 
0214   0566 B0            cmp a, b
0215   0567 FD 71         seq ; ==
0216   0569 E4            pop a
0217   056A             ; --- END RELATIONAL
0218   056A             ; --- START LOGICAL OR
0219   056A D7            push a
0220   056B 11            mov a, b
0221   056C FA FD FF      lea d, [bp + -3] ; $format_p
0222   056F 2A            mov b, [d]
0223   0570 38 00 00      mov c, 0
0224   0573 74            mov d, b
0225   0574 32            mov bl, [d]
0226   0575 A7 00         mov bh, 0
0227   0577 38 00 00      mov c, 0
0228   057A             ; --- START RELATIONAL
0229   057A D7            push a
0230   057B 11            mov a, b
0231   057C FD 2E 69 00   mov32 cb, $00000069
0231   0580 00 00 
0232   0582 B0            cmp a, b
0233   0583 FD 71         seq ; ==
0234   0585 E4            pop a
0235   0586             ; --- END RELATIONAL
0236   0586 FD A8         sor a, b ; ||
0237   0588 E4            pop a
0238   0589             ; --- END LOGICAL OR
0239   0589 C0 00 00      cmp b, 0
0240   058C C6 AD 05      je _if10_else
0241   058F             _if10_TRUE:
0242   058F             ; print_signed_long(*(long *)p); 
0243   058F             ; --- START FUNCTION CALL
0244   058F FA FF FF      lea d, [bp + -1] ; $p
0245   0592 2A            mov b, [d]
0246   0593 38 00 00      mov c, 0
0247   0596 74            mov d, b
0248   0597 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0249   059A FD 39         mov c, b ; And place it into C
0250   059C 2A            mov b, [d] ; Lower Word in B
0251   059D 12            mov a, c
0252   059E FD AA         swp a
0253   05A0 D7            push a
0254   05A1 FD AB         swp b
0255   05A3 D8            push b
0256   05A4 07 86 07      call print_signed_long
0257   05A7 51 04 00      add sp, 4
0258   05AA             ; --- END FUNCTION CALL
0259   05AA 0A 35 06      jmp _if10_exit
0260   05AD             _if10_else:
0261   05AD             ; if(*format_p == 'u') 
0262   05AD             _if11_cond:
0263   05AD FA FD FF      lea d, [bp + -3] ; $format_p
0264   05B0 2A            mov b, [d]
0265   05B1 38 00 00      mov c, 0
0266   05B4 74            mov d, b
0267   05B5 32            mov bl, [d]
0268   05B6 A7 00         mov bh, 0
0269   05B8 38 00 00      mov c, 0
0270   05BB             ; --- START RELATIONAL
0271   05BB D7            push a
0272   05BC 11            mov a, b
0273   05BD FD 2E 75 00   mov32 cb, $00000075
0273   05C1 00 00 
0274   05C3 B0            cmp a, b
0275   05C4 FD 71         seq ; ==
0276   05C6 E4            pop a
0277   05C7             ; --- END RELATIONAL
0278   05C7 C0 00 00      cmp b, 0
0279   05CA C6 EB 05      je _if11_else
0280   05CD             _if11_TRUE:
0281   05CD             ; print_unsigned_long(*(unsigned long *)p); 
0282   05CD             ; --- START FUNCTION CALL
0283   05CD FA FF FF      lea d, [bp + -1] ; $p
0284   05D0 2A            mov b, [d]
0285   05D1 38 00 00      mov c, 0
0286   05D4 74            mov d, b
0287   05D5 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0288   05D8 FD 39         mov c, b ; And place it into C
0289   05DA 2A            mov b, [d] ; Lower Word in B
0290   05DB 12            mov a, c
0291   05DC FD AA         swp a
0292   05DE D7            push a
0293   05DF FD AB         swp b
0294   05E1 D8            push b
0295   05E2 07 11 09      call print_unsigned_long
0296   05E5 51 04 00      add sp, 4
0297   05E8             ; --- END FUNCTION CALL
0298   05E8 0A 35 06      jmp _if11_exit
0299   05EB             _if11_else:
0300   05EB             ; if(*format_p == 'x') 
0301   05EB             _if12_cond:
0302   05EB FA FD FF      lea d, [bp + -3] ; $format_p
0303   05EE 2A            mov b, [d]
0304   05EF 38 00 00      mov c, 0
0305   05F2 74            mov d, b
0306   05F3 32            mov bl, [d]
0307   05F4 A7 00         mov bh, 0
0308   05F6 38 00 00      mov c, 0
0309   05F9             ; --- START RELATIONAL
0310   05F9 D7            push a
0311   05FA 11            mov a, b
0312   05FB FD 2E 78 00   mov32 cb, $00000078
0312   05FF 00 00 
0313   0601 B0            cmp a, b
0314   0602 FD 71         seq ; ==
0315   0604 E4            pop a
0316   0605             ; --- END RELATIONAL
0317   0605 C0 00 00      cmp b, 0
0318   0608 C6 29 06      je _if12_else
0319   060B             _if12_TRUE:
0320   060B             ; printx32(*(long int *)p); 
0321   060B             ; --- START FUNCTION CALL
0322   060B FA FF FF      lea d, [bp + -1] ; $p
0323   060E 2A            mov b, [d]
0324   060F 38 00 00      mov c, 0
0325   0612 74            mov d, b
0326   0613 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0327   0616 FD 39         mov c, b ; And place it into C
0328   0618 2A            mov b, [d] ; Lower Word in B
0329   0619 12            mov a, c
0330   061A FD AA         swp a
0331   061C D7            push a
0332   061D FD AB         swp b
0333   061F D8            push b
0334   0620 07 3D 0A      call printx32
0335   0623 51 04 00      add sp, 4
0336   0626             ; --- END FUNCTION CALL
0337   0626 0A 35 06      jmp _if12_exit
0338   0629             _if12_else:
0339   0629             ; err("Unexpected format in printf."); 
0340   0629             ; --- START FUNCTION CALL
0341   0629 26 7B 0D      mov b, _s1 ; "Unexpected format in printf."
0342   062C FD AB         swp b
0343   062E D8            push b
0344   062F 07 9D 0A      call err
0345   0632 51 02 00      add sp, 2
0346   0635             ; --- END FUNCTION CALL
0347   0635             _if12_exit:
0348   0635             _if11_exit:
0349   0635             _if10_exit:
0350   0635             ; p = p + 4; 
0351   0635 FA FF FF      lea d, [bp + -1] ; $p
0352   0638 DA            push d
0353   0639 FA FF FF      lea d, [bp + -1] ; $p
0354   063C 2A            mov b, [d]
0355   063D 38 00 00      mov c, 0
0356   0640             ; --- START TERMS
0357   0640 D7            push a
0358   0641 11            mov a, b
0359   0642 FD 2E 04 00   mov32 cb, $00000004
0359   0646 00 00 
0360   0648 56            add b, a
0361   0649 E4            pop a
0362   064A             ; --- END TERMS
0363   064A E7            pop d
0364   064B FD 43         mov [d], b
0365   064D             ; break; 
0366   064D 0A 49 07      jmp _switch9_exit ; case break
0367   0650             _switch9_case2:
0368   0650             _switch9_case3:
0369   0650             ; print_signed(*(int*)p); 
0370   0650             ; --- START FUNCTION CALL
0371   0650 FA FF FF      lea d, [bp + -1] ; $p
0372   0653 2A            mov b, [d]
0373   0654 38 00 00      mov c, 0
0374   0657 74            mov d, b
0375   0658 2A            mov b, [d]
0376   0659 38 00 00      mov c, 0
0377   065C FD AB         swp b
0378   065E D8            push b
0379   065F 07 CB 0A      call print_signed
0380   0662 51 02 00      add sp, 2
0381   0665             ; --- END FUNCTION CALL
0382   0665             ; p = p + 2; 
0383   0665 FA FF FF      lea d, [bp + -1] ; $p
0384   0668 DA            push d
0385   0669 FA FF FF      lea d, [bp + -1] ; $p
0386   066C 2A            mov b, [d]
0387   066D 38 00 00      mov c, 0
0388   0670             ; --- START TERMS
0389   0670 D7            push a
0390   0671 11            mov a, b
0391   0672 FD 2E 02 00   mov32 cb, $00000002
0391   0676 00 00 
0392   0678 56            add b, a
0393   0679 E4            pop a
0394   067A             ; --- END TERMS
0395   067A E7            pop d
0396   067B FD 43         mov [d], b
0397   067D             ; break; 
0398   067D 0A 49 07      jmp _switch9_exit ; case break
0399   0680             _switch9_case4:
0400   0680             ; print_unsigned(*(unsigned int*)p); 
0401   0680             ; --- START FUNCTION CALL
0402   0680 FA FF FF      lea d, [bp + -1] ; $p
0403   0683 2A            mov b, [d]
0404   0684 38 00 00      mov c, 0
0405   0687 74            mov d, b
0406   0688 2A            mov b, [d]
0407   0689 38 00 00      mov c, 0
0408   068C FD AB         swp b
0409   068E D8            push b
0410   068F 07 14 0C      call print_unsigned
0411   0692 51 02 00      add sp, 2
0412   0695             ; --- END FUNCTION CALL
0413   0695             ; p = p + 2; 
0414   0695 FA FF FF      lea d, [bp + -1] ; $p
0415   0698 DA            push d
0416   0699 FA FF FF      lea d, [bp + -1] ; $p
0417   069C 2A            mov b, [d]
0418   069D 38 00 00      mov c, 0
0419   06A0             ; --- START TERMS
0420   06A0 D7            push a
0421   06A1 11            mov a, b
0422   06A2 FD 2E 02 00   mov32 cb, $00000002
0422   06A6 00 00 
0423   06A8 56            add b, a
0424   06A9 E4            pop a
0425   06AA             ; --- END TERMS
0426   06AA E7            pop d
0427   06AB FD 43         mov [d], b
0428   06AD             ; break; 
0429   06AD 0A 49 07      jmp _switch9_exit ; case break
0430   06B0             _switch9_case5:
0431   06B0             ; printx16(*(int*)p); 
0432   06B0             ; --- START FUNCTION CALL
0433   06B0 FA FF FF      lea d, [bp + -1] ; $p
0434   06B3 2A            mov b, [d]
0435   06B4 38 00 00      mov c, 0
0436   06B7 74            mov d, b
0437   06B8 2A            mov b, [d]
0438   06B9 38 00 00      mov c, 0
0439   06BC FD AB         swp b
0440   06BE D8            push b
0441   06BF 07 24 0D      call printx16
0442   06C2 51 02 00      add sp, 2
0443   06C5             ; --- END FUNCTION CALL
0444   06C5             ; p = p + 2; 
0445   06C5 FA FF FF      lea d, [bp + -1] ; $p
0446   06C8 DA            push d
0447   06C9 FA FF FF      lea d, [bp + -1] ; $p
0448   06CC 2A            mov b, [d]
0449   06CD 38 00 00      mov c, 0
0450   06D0             ; --- START TERMS
0451   06D0 D7            push a
0452   06D1 11            mov a, b
0453   06D2 FD 2E 02 00   mov32 cb, $00000002
0453   06D6 00 00 
0454   06D8 56            add b, a
0455   06D9 E4            pop a
0456   06DA             ; --- END TERMS
0457   06DA E7            pop d
0458   06DB FD 43         mov [d], b
0459   06DD             ; break; 
0460   06DD 0A 49 07      jmp _switch9_exit ; case break
0461   06E0             _switch9_case6:
0462   06E0             ; putchar(*(char*)p); 
0463   06E0             ; --- START FUNCTION CALL
0464   06E0 FA FF FF      lea d, [bp + -1] ; $p
0465   06E3 2A            mov b, [d]
0466   06E4 38 00 00      mov c, 0
0467   06E7 74            mov d, b
0468   06E8 32            mov bl, [d]
0469   06E9 A7 00         mov bh, 0
0470   06EB 38 00 00      mov c, 0
0471   06EE DD            push bl
0472   06EF 07 03 09      call putchar
0473   06F2 51 01 00      add sp, 1
0474   06F5             ; --- END FUNCTION CALL
0475   06F5             ; p = p + 1; 
0476   06F5 FA FF FF      lea d, [bp + -1] ; $p
0477   06F8 DA            push d
0478   06F9 FA FF FF      lea d, [bp + -1] ; $p
0479   06FC 2A            mov b, [d]
0480   06FD 38 00 00      mov c, 0
0481   0700             ; --- START TERMS
0482   0700 D7            push a
0483   0701 11            mov a, b
0484   0702 FD 2E 01 00   mov32 cb, $00000001
0484   0706 00 00 
0485   0708 56            add b, a
0486   0709 E4            pop a
0487   070A             ; --- END TERMS
0488   070A E7            pop d
0489   070B FD 43         mov [d], b
0490   070D             ; break; 
0491   070D 0A 49 07      jmp _switch9_exit ; case break
0492   0710             _switch9_case7:
0493   0710             ; print(*(char**)p); 
0494   0710             ; --- START FUNCTION CALL
0495   0710 FA FF FF      lea d, [bp + -1] ; $p
0496   0713 2A            mov b, [d]
0497   0714 38 00 00      mov c, 0
0498   0717 74            mov d, b
0499   0718 2A            mov b, [d]
0500   0719 FD AB         swp b
0501   071B D8            push b
0502   071C 07 B2 0A      call print
0503   071F 51 02 00      add sp, 2
0504   0722             ; --- END FUNCTION CALL
0505   0722             ; p = p + 2; 
0506   0722 FA FF FF      lea d, [bp + -1] ; $p
0507   0725 DA            push d
0508   0726 FA FF FF      lea d, [bp + -1] ; $p
0509   0729 2A            mov b, [d]
0510   072A 38 00 00      mov c, 0
0511   072D             ; --- START TERMS
0512   072D D7            push a
0513   072E 11            mov a, b
0514   072F FD 2E 02 00   mov32 cb, $00000002
0514   0733 00 00 
0515   0735 56            add b, a
0516   0736 E4            pop a
0517   0737             ; --- END TERMS
0518   0737 E7            pop d
0519   0738 FD 43         mov [d], b
0520   073A             ; break; 
0521   073A 0A 49 07      jmp _switch9_exit ; case break
0522   073D             _switch9_default:
0523   073D             ; print("Error: Unknown argument type.\n"); 
0524   073D             ; --- START FUNCTION CALL
0525   073D 26 98 0D      mov b, _s2 ; "Error: Unknown argument type.\n"
0526   0740 FD AB         swp b
0527   0742 D8            push b
0528   0743 07 B2 0A      call print
0529   0746 51 02 00      add sp, 2
0530   0749             ; --- END FUNCTION CALL
0531   0749             _switch9_exit:
0532   0749             ; format_p++; 
0533   0749 FA FD FF      lea d, [bp + -3] ; $format_p
0534   074C 2A            mov b, [d]
0535   074D 38 00 00      mov c, 0
0536   0750 FD 77         inc b
0537   0752 FA FD FF      lea d, [bp + -3] ; $format_p
0538   0755 FD 43         mov [d], b
0539   0757 FD 7D         dec b
0540   0759 0A 81 07      jmp _if8_exit
0541   075C             _if8_else:
0542   075C             ; putchar(*format_p); 
0543   075C             ; --- START FUNCTION CALL
0544   075C FA FD FF      lea d, [bp + -3] ; $format_p
0545   075F 2A            mov b, [d]
0546   0760 38 00 00      mov c, 0
0547   0763 74            mov d, b
0548   0764 32            mov bl, [d]
0549   0765 A7 00         mov bh, 0
0550   0767 38 00 00      mov c, 0
0551   076A DD            push bl
0552   076B 07 03 09      call putchar
0553   076E 51 01 00      add sp, 1
0554   0771             ; --- END FUNCTION CALL
0555   0771             ; format_p++; 
0556   0771 FA FD FF      lea d, [bp + -3] ; $format_p
0557   0774 2A            mov b, [d]
0558   0775 38 00 00      mov c, 0
0559   0778 FD 77         inc b
0560   077A FA FD FF      lea d, [bp + -3] ; $format_p
0561   077D FD 43         mov [d], b
0562   077F FD 7D         dec b
0563   0781             _if8_exit:
0564   0781             _if7_exit:
0565   0781             _for6_update:
0566   0781 0A B5 04      jmp _for6_cond
0567   0784             _for6_exit:
0568   0784 F9            leave
0569   0785 09            ret
0570   0786             
0571   0786             print_signed_long:
0572   0786 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0573   0789             ; char digits[10]; 
0574   0789 52 0A 00      sub sp, 10
0575   078C             ; int i = 0; 
0576   078C 52 02 00      sub sp, 2
0577   078F             ; --- START LOCAL VAR INITIALIZATION
0578   078F FA F5 FF      lea d, [bp + -11] ; $i
0579   0792 DA            push d
0580   0793 FD 2E 00 00   mov32 cb, $00000000
0580   0797 00 00 
0581   0799 E7            pop d
0582   079A FD 43         mov [d], b
0583   079C             ; --- END LOCAL VAR INITIALIZATION
0584   079C             ; if (num < 0) { 
0585   079C             _if13_cond:
0586   079C FA 05 00      lea d, [bp + 5] ; $num
0587   079F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0588   07A2 FD 39         mov c, b ; And place it into C
0589   07A4 2A            mov b, [d] ; Lower Word in B
0590   07A5             ; --- START RELATIONAL
0591   07A5 D7            push a
0592   07A6 FD D8         push g
0593   07A8 11            mov a, b
0594   07A9 FD 7A         mov g, c
0595   07AB FD 2E 00 00   mov32 cb, $00000000
0595   07AF 00 00 
0596   07B1 FD AF         cmp32 ga, cb
0597   07B3 FD 73         slt ; <
0598   07B5 FD F1         pop g
0599   07B7 E4            pop a
0600   07B8             ; --- END RELATIONAL
0601   07B8 C0 00 00      cmp b, 0
0602   07BB C6 ED 07      je _if13_else
0603   07BE             _if13_TRUE:
0604   07BE             ; putchar('-'); 
0605   07BE             ; --- START FUNCTION CALL
0606   07BE FD 2E 2D 00   mov32 cb, $0000002d
0606   07C2 00 00 
0607   07C4 DD            push bl
0608   07C5 07 03 09      call putchar
0609   07C8 51 01 00      add sp, 1
0610   07CB             ; --- END FUNCTION CALL
0611   07CB             ; num = -num; 
0612   07CB FA 05 00      lea d, [bp + 5] ; $num
0613   07CE DA            push d
0614   07CF FA 05 00      lea d, [bp + 5] ; $num
0615   07D2 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0616   07D5 FD 39         mov c, b ; And place it into C
0617   07D7 2A            mov b, [d] ; Lower Word in B
0618   07D8 12            mov a, c
0619   07D9 95            not a
0620   07DA 97            not b
0621   07DB 55 01 00      add b, 1
0622   07DE 5B 00 00      adc a, 0
0623   07E1 39            mov c, a
0624   07E2 E7            pop d
0625   07E3 FD 43         mov [d], b
0626   07E5 28            mov b, c
0627   07E6 FD 44 02 00   mov [d + 2], b
0628   07EA 0A 21 08      jmp _if13_exit
0629   07ED             _if13_else:
0630   07ED             ; if (num == 0) { 
0631   07ED             _if14_cond:
0632   07ED FA 05 00      lea d, [bp + 5] ; $num
0633   07F0 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0634   07F3 FD 39         mov c, b ; And place it into C
0635   07F5 2A            mov b, [d] ; Lower Word in B
0636   07F6             ; --- START RELATIONAL
0637   07F6 D7            push a
0638   07F7 FD D8         push g
0639   07F9 11            mov a, b
0640   07FA FD 7A         mov g, c
0641   07FC FD 2E 00 00   mov32 cb, $00000000
0641   0800 00 00 
0642   0802 FD AF         cmp32 ga, cb
0643   0804 FD 71         seq ; ==
0644   0806 FD F1         pop g
0645   0808 E4            pop a
0646   0809             ; --- END RELATIONAL
0647   0809 C0 00 00      cmp b, 0
0648   080C C6 21 08      je _if14_exit
0649   080F             _if14_TRUE:
0650   080F             ; putchar('0'); 
0651   080F             ; --- START FUNCTION CALL
0652   080F FD 2E 30 00   mov32 cb, $00000030
0652   0813 00 00 
0653   0815 DD            push bl
0654   0816 07 03 09      call putchar
0655   0819 51 01 00      add sp, 1
0656   081C             ; --- END FUNCTION CALL
0657   081C             ; return; 
0658   081C F9            leave
0659   081D 09            ret
0660   081E 0A 21 08      jmp _if14_exit
0661   0821             _if14_exit:
0662   0821             _if13_exit:
0663   0821             ; while (num > 0) { 
0664   0821             _while15_cond:
0665   0821 FA 05 00      lea d, [bp + 5] ; $num
0666   0824 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0667   0827 FD 39         mov c, b ; And place it into C
0668   0829 2A            mov b, [d] ; Lower Word in B
0669   082A             ; --- START RELATIONAL
0670   082A D7            push a
0671   082B FD D8         push g
0672   082D 11            mov a, b
0673   082E FD 7A         mov g, c
0674   0830 FD 2E 00 00   mov32 cb, $00000000
0674   0834 00 00 
0675   0836 FD AF         cmp32 ga, cb
0676   0838 FD 7F         sgt
0677   083A FD F1         pop g
0678   083C E4            pop a
0679   083D             ; --- END RELATIONAL
0680   083D C0 00 00      cmp b, 0
0681   0840 C6 B9 08      je _while15_exit
0682   0843             _while15_block:
0683   0843             ; digits[i] = '0' + (num % 10); 
0684   0843 FA F7 FF      lea d, [bp + -9] ; $digits
0685   0846 D7            push a
0686   0847 DA            push d
0687   0848 FA F5 FF      lea d, [bp + -11] ; $i
0688   084B 2A            mov b, [d]
0689   084C 38 00 00      mov c, 0
0690   084F E7            pop d
0691   0850 5A            add d, b
0692   0851 E4            pop a
0693   0852 DA            push d
0694   0853 FD 2E 30 00   mov32 cb, $00000030
0694   0857 00 00 
0695   0859             ; --- START TERMS
0696   0859 D7            push a
0697   085A 11            mov a, b
0698   085B FA 05 00      lea d, [bp + 5] ; $num
0699   085E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0700   0861 FD 39         mov c, b ; And place it into C
0701   0863 2A            mov b, [d] ; Lower Word in B
0702   0864             ; --- START FACTORS
0703   0864 D7            push a
0704   0865 FD D8         push g
0705   0867 11            mov a, b
0706   0868 FD 7A         mov g, c
0707   086A FD 2E 0A 00   mov32 cb, $0000000a
0707   086E 00 00 
0708   0870 AE            div a, b ; %, a: quotient, b: remainder
0709   0871 11            mov a, b
0710   0872 FD 38         mov c, g
0711   0874 27            mov b, a
0712   0875 FD F1         pop g
0713   0877 E4            pop a
0714   0878             ; --- END FACTORS
0715   0878 FD 15         add32 cb, ga
0716   087A E4            pop a
0717   087B             ; --- END TERMS
0718   087B E7            pop d
0719   087C FD 3E         mov [d], bl
0720   087E             ; num = num / 10; 
0721   087E FA 05 00      lea d, [bp + 5] ; $num
0722   0881 DA            push d
0723   0882 FA 05 00      lea d, [bp + 5] ; $num
0724   0885 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0725   0888 FD 39         mov c, b ; And place it into C
0726   088A 2A            mov b, [d] ; Lower Word in B
0727   088B             ; --- START FACTORS
0728   088B D7            push a
0729   088C FD D8         push g
0730   088E 11            mov a, b
0731   088F FD 7A         mov g, c
0732   0891 FD 2E 0A 00   mov32 cb, $0000000a
0732   0895 00 00 
0733   0897 AE            div a, b ; /, a: quotient, b: remainder
0734   0898 FD 38         mov c, g
0735   089A 27            mov b, a
0736   089B FD F1         pop g
0737   089D E4            pop a
0738   089E             ; --- END FACTORS
0739   089E E7            pop d
0740   089F FD 43         mov [d], b
0741   08A1 28            mov b, c
0742   08A2 FD 44 02 00   mov [d + 2], b
0743   08A6             ; i++; 
0744   08A6 FA F5 FF      lea d, [bp + -11] ; $i
0745   08A9 2A            mov b, [d]
0746   08AA 38 00 00      mov c, 0
0747   08AD 11            mov a, b
0748   08AE FD 77         inc b
0749   08B0 FA F5 FF      lea d, [bp + -11] ; $i
0750   08B3 FD 43         mov [d], b
0751   08B5 27            mov b, a
0752   08B6 0A 21 08      jmp _while15_cond
0753   08B9             _while15_exit:
0754   08B9             ; while (i > 0) { 
0755   08B9             _while22_cond:
0756   08B9 FA F5 FF      lea d, [bp + -11] ; $i
0757   08BC 2A            mov b, [d]
0758   08BD 38 00 00      mov c, 0
0759   08C0             ; --- START RELATIONAL
0760   08C0 D7            push a
0761   08C1 11            mov a, b
0762   08C2 FD 2E 00 00   mov32 cb, $00000000
0762   08C6 00 00 
0763   08C8 B0            cmp a, b
0764   08C9 FD 7F         sgt ; >
0765   08CB E4            pop a
0766   08CC             ; --- END RELATIONAL
0767   08CC C0 00 00      cmp b, 0
0768   08CF C6 01 09      je _while22_exit
0769   08D2             _while22_block:
0770   08D2             ; i--; 
0771   08D2 FA F5 FF      lea d, [bp + -11] ; $i
0772   08D5 2A            mov b, [d]
0773   08D6 38 00 00      mov c, 0
0774   08D9 11            mov a, b
0775   08DA FD 7D         dec b
0776   08DC FA F5 FF      lea d, [bp + -11] ; $i
0777   08DF FD 43         mov [d], b
0778   08E1 27            mov b, a
0779   08E2             ; putchar(digits[i]); 
0780   08E2             ; --- START FUNCTION CALL
0781   08E2 FA F7 FF      lea d, [bp + -9] ; $digits
0782   08E5 D7            push a
0783   08E6 DA            push d
0784   08E7 FA F5 FF      lea d, [bp + -11] ; $i
0785   08EA 2A            mov b, [d]
0786   08EB 38 00 00      mov c, 0
0787   08EE E7            pop d
0788   08EF 5A            add d, b
0789   08F0 E4            pop a
0790   08F1 32            mov bl, [d]
0791   08F2 A7 00         mov bh, 0
0792   08F4 38 00 00      mov c, 0
0793   08F7 DD            push bl
0794   08F8 07 03 09      call putchar
0795   08FB 51 01 00      add sp, 1
0796   08FE             ; --- END FUNCTION CALL
0797   08FE 0A B9 08      jmp _while22_cond
0798   0901             _while22_exit:
0799   0901 F9            leave
0800   0902 09            ret
0801   0903             
0802   0903             putchar:
0803   0903 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0804   0906             ; --- BEGIN INLINE ASM SEGMENT
0805   0906 FA 05 00      lea d, [bp + 5] ; $c
0806   0909 1E            mov al, [d]
0807   090A 23            mov ah, al
0808   090B 19 00         mov al, 0
0809   090D 05 03         syscall sys_io      ; char in AH
0810   090F             ; --- END INLINE ASM SEGMENT
0811   090F F9            leave
0812   0910 09            ret
0813   0911             
0814   0911             print_unsigned_long:
0815   0911 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0816   0914             ; char digits[10]; 
0817   0914 52 0A 00      sub sp, 10
0818   0917             ; int i; 
0819   0917 52 02 00      sub sp, 2
0820   091A             ; i = 0; 
0821   091A FA F5 FF      lea d, [bp + -11] ; $i
0822   091D DA            push d
0823   091E FD 2E 00 00   mov32 cb, $00000000
0823   0922 00 00 
0824   0924 E7            pop d
0825   0925 FD 43         mov [d], b
0826   0927             ; if(num == 0){ 
0827   0927             _if23_cond:
0828   0927 FA 05 00      lea d, [bp + 5] ; $num
0829   092A 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0830   092D FD 39         mov c, b ; And place it into C
0831   092F 2A            mov b, [d] ; Lower Word in B
0832   0930             ; --- START RELATIONAL
0833   0930 D7            push a
0834   0931 FD D8         push g
0835   0933 11            mov a, b
0836   0934 FD 7A         mov g, c
0837   0936 FD 2E 00 00   mov32 cb, $00000000
0837   093A 00 00 
0838   093C FD AF         cmp32 ga, cb
0839   093E FD 71         seq ; ==
0840   0940 FD F1         pop g
0841   0942 E4            pop a
0842   0943             ; --- END RELATIONAL
0843   0943 C0 00 00      cmp b, 0
0844   0946 C6 5B 09      je _if23_exit
0845   0949             _if23_TRUE:
0846   0949             ; putchar('0'); 
0847   0949             ; --- START FUNCTION CALL
0848   0949 FD 2E 30 00   mov32 cb, $00000030
0848   094D 00 00 
0849   094F DD            push bl
0850   0950 07 03 09      call putchar
0851   0953 51 01 00      add sp, 1
0852   0956             ; --- END FUNCTION CALL
0853   0956             ; return; 
0854   0956 F9            leave
0855   0957 09            ret
0856   0958 0A 5B 09      jmp _if23_exit
0857   095B             _if23_exit:
0858   095B             ; while (num > 0) { 
0859   095B             _while24_cond:
0860   095B FA 05 00      lea d, [bp + 5] ; $num
0861   095E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0862   0961 FD 39         mov c, b ; And place it into C
0863   0963 2A            mov b, [d] ; Lower Word in B
0864   0964             ; --- START RELATIONAL
0865   0964 D7            push a
0866   0965 FD D8         push g
0867   0967 11            mov a, b
0868   0968 FD 7A         mov g, c
0869   096A FD 2E 00 00   mov32 cb, $00000000
0869   096E 00 00 
0870   0970 FD AF         cmp32 ga, cb
0871   0972 FD 81         sgu
0872   0974 FD F1         pop g
0873   0976 E4            pop a
0874   0977             ; --- END RELATIONAL
0875   0977 C0 00 00      cmp b, 0
0876   097A C6 F3 09      je _while24_exit
0877   097D             _while24_block:
0878   097D             ; digits[i] = '0' + (num % 10); 
0879   097D FA F7 FF      lea d, [bp + -9] ; $digits
0880   0980 D7            push a
0881   0981 DA            push d
0882   0982 FA F5 FF      lea d, [bp + -11] ; $i
0883   0985 2A            mov b, [d]
0884   0986 38 00 00      mov c, 0
0885   0989 E7            pop d
0886   098A 5A            add d, b
0887   098B E4            pop a
0888   098C DA            push d
0889   098D FD 2E 30 00   mov32 cb, $00000030
0889   0991 00 00 
0890   0993             ; --- START TERMS
0891   0993 D7            push a
0892   0994 11            mov a, b
0893   0995 FA 05 00      lea d, [bp + 5] ; $num
0894   0998 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0895   099B FD 39         mov c, b ; And place it into C
0896   099D 2A            mov b, [d] ; Lower Word in B
0897   099E             ; --- START FACTORS
0898   099E D7            push a
0899   099F FD D8         push g
0900   09A1 11            mov a, b
0901   09A2 FD 7A         mov g, c
0902   09A4 FD 2E 0A 00   mov32 cb, $0000000a
0902   09A8 00 00 
0903   09AA AE            div a, b ; %, a: quotient, b: remainder
0904   09AB 11            mov a, b
0905   09AC FD 38         mov c, g
0906   09AE 27            mov b, a
0907   09AF FD F1         pop g
0908   09B1 E4            pop a
0909   09B2             ; --- END FACTORS
0910   09B2 FD 15         add32 cb, ga
0911   09B4 E4            pop a
0912   09B5             ; --- END TERMS
0913   09B5 E7            pop d
0914   09B6 FD 3E         mov [d], bl
0915   09B8             ; num = num / 10; 
0916   09B8 FA 05 00      lea d, [bp + 5] ; $num
0917   09BB DA            push d
0918   09BC FA 05 00      lea d, [bp + 5] ; $num
0919   09BF 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0920   09C2 FD 39         mov c, b ; And place it into C
0921   09C4 2A            mov b, [d] ; Lower Word in B
0922   09C5             ; --- START FACTORS
0923   09C5 D7            push a
0924   09C6 FD D8         push g
0925   09C8 11            mov a, b
0926   09C9 FD 7A         mov g, c
0927   09CB FD 2E 0A 00   mov32 cb, $0000000a
0927   09CF 00 00 
0928   09D1 AE            div a, b ; /, a: quotient, b: remainder
0929   09D2 FD 38         mov c, g
0930   09D4 27            mov b, a
0931   09D5 FD F1         pop g
0932   09D7 E4            pop a
0933   09D8             ; --- END FACTORS
0934   09D8 E7            pop d
0935   09D9 FD 43         mov [d], b
0936   09DB 28            mov b, c
0937   09DC FD 44 02 00   mov [d + 2], b
0938   09E0             ; i++; 
0939   09E0 FA F5 FF      lea d, [bp + -11] ; $i
0940   09E3 2A            mov b, [d]
0941   09E4 38 00 00      mov c, 0
0942   09E7 11            mov a, b
0943   09E8 FD 77         inc b
0944   09EA FA F5 FF      lea d, [bp + -11] ; $i
0945   09ED FD 43         mov [d], b
0946   09EF 27            mov b, a
0947   09F0 0A 5B 09      jmp _while24_cond
0948   09F3             _while24_exit:
0949   09F3             ; while (i > 0) { 
0950   09F3             _while31_cond:
0951   09F3 FA F5 FF      lea d, [bp + -11] ; $i
0952   09F6 2A            mov b, [d]
0953   09F7 38 00 00      mov c, 0
0954   09FA             ; --- START RELATIONAL
0955   09FA D7            push a
0956   09FB 11            mov a, b
0957   09FC FD 2E 00 00   mov32 cb, $00000000
0957   0A00 00 00 
0958   0A02 B0            cmp a, b
0959   0A03 FD 7F         sgt ; >
0960   0A05 E4            pop a
0961   0A06             ; --- END RELATIONAL
0962   0A06 C0 00 00      cmp b, 0
0963   0A09 C6 3B 0A      je _while31_exit
0964   0A0C             _while31_block:
0965   0A0C             ; i--; 
0966   0A0C FA F5 FF      lea d, [bp + -11] ; $i
0967   0A0F 2A            mov b, [d]
0968   0A10 38 00 00      mov c, 0
0969   0A13 11            mov a, b
0970   0A14 FD 7D         dec b
0971   0A16 FA F5 FF      lea d, [bp + -11] ; $i
0972   0A19 FD 43         mov [d], b
0973   0A1B 27            mov b, a
0974   0A1C             ; putchar(digits[i]); 
0975   0A1C             ; --- START FUNCTION CALL
0976   0A1C FA F7 FF      lea d, [bp + -9] ; $digits
0977   0A1F D7            push a
0978   0A20 DA            push d
0979   0A21 FA F5 FF      lea d, [bp + -11] ; $i
0980   0A24 2A            mov b, [d]
0981   0A25 38 00 00      mov c, 0
0982   0A28 E7            pop d
0983   0A29 5A            add d, b
0984   0A2A E4            pop a
0985   0A2B 32            mov bl, [d]
0986   0A2C A7 00         mov bh, 0
0987   0A2E 38 00 00      mov c, 0
0988   0A31 DD            push bl
0989   0A32 07 03 09      call putchar
0990   0A35 51 01 00      add sp, 1
0991   0A38             ; --- END FUNCTION CALL
0992   0A38 0A F3 09      jmp _while31_cond
0993   0A3B             _while31_exit:
0994   0A3B F9            leave
0995   0A3C 09            ret
0996   0A3D             
0997   0A3D             printx32:
0998   0A3D F8 00 00      enter 0 ; (push bp; mov bp, sp)
0999   0A40             ; --- BEGIN INLINE ASM SEGMENT
1000   0A40 FA 05 00      lea d, [bp + 5] ; $hex
1001   0A43 2B 02 00      mov b, [d+2]
1002   0A46 07 4F 0A      call print_u16x_printx32
1003   0A49 2A            mov b, [d]
1004   0A4A 07 4F 0A      call print_u16x_printx32
1005   0A4D             ; --- END INLINE ASM SEGMENT
1006   0A4D             ; return; 
1007   0A4D F9            leave
1008   0A4E 09            ret
1009   0A4F             ; --- BEGIN INLINE ASM SEGMENT
1010   0A4F             print_u16x_printx32:
1011   0A4F D7            push a
1012   0A50 D8            push b
1013   0A51 DD            push bl
1014   0A52 30            mov bl, bh
1015   0A53 07 71 0A      call _itoa_printx32        ; convert bh to char in A
1016   0A56 2F            mov bl, al        ; save al
1017   0A57 19 00         mov al, 0
1018   0A59 05 03         syscall sys_io        ; display AH
1019   0A5B 24            mov ah, bl        ; retrieve al
1020   0A5C 19 00         mov al, 0
1021   0A5E 05 03         syscall sys_io        ; display AL
1022   0A60 EA            pop bl
1023   0A61 07 71 0A      call _itoa_printx32        ; convert bh to char in A
1024   0A64 2F            mov bl, al        ; save al
1025   0A65 19 00         mov al, 0
1026   0A67 05 03         syscall sys_io        ; display AH
1027   0A69 24            mov ah, bl        ; retrieve al
1028   0A6A 19 00         mov al, 0
1029   0A6C 05 03         syscall sys_io        ; display AL
1030   0A6E E5            pop b
1031   0A6F E4            pop a
1032   0A70 09            ret
1033   0A71             _itoa_printx32:
1034   0A71 DA            push d
1035   0A72 D8            push b
1036   0A73 A7 00         mov bh, 0
1037   0A75 FD A4 04      shr bl, 4  
1038   0A78 74            mov d, b
1039   0A79 1F 8B 0A      mov al, [d + s_hex_digits_printx32]
1040   0A7C 23            mov ah, al
1041   0A7D E5            pop b
1042   0A7E D8            push b
1043   0A7F A7 00         mov bh, 0
1044   0A81 FD 87 0F      and bl, $0F
1045   0A84 74            mov d, b
1046   0A85 1F 8B 0A      mov al, [d + s_hex_digits_printx32]
1047   0A88 E5            pop b
1048   0A89 E7            pop d
1049   0A8A 09            ret
1050   0A8B 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
1050   0A8F 34 35 36 37 
1050   0A93 38 39 41 42 
1050   0A97 43 44 45 46 
1051   0A9B             ; --- END INLINE ASM SEGMENT
1052   0A9B F9            leave
1053   0A9C 09            ret
1054   0A9D             
1055   0A9D             err:
1056   0A9D F8 00 00      enter 0 ; (push bp; mov bp, sp)
1057   0AA0             ; print(e); 
1058   0AA0             ; --- START FUNCTION CALL
1059   0AA0 FA 05 00      lea d, [bp + 5] ; $e
1060   0AA3 2A            mov b, [d]
1061   0AA4 38 00 00      mov c, 0
1062   0AA7 FD AB         swp b
1063   0AA9 D8            push b
1064   0AAA 07 B2 0A      call print
1065   0AAD 51 02 00      add sp, 2
1066   0AB0             ; --- END FUNCTION CALL
1067   0AB0 F9            leave
1068   0AB1 09            ret
1069   0AB2             
1070   0AB2             print:
1071   0AB2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1072   0AB5             ; --- BEGIN INLINE ASM SEGMENT
1073   0AB5 FA 05 00      lea d, [bp + 5] ; $s
1074   0AB8 FD 2A         mov d, [d]
1075   0ABA             _puts_L1_print:
1076   0ABA 1E            mov al, [d]
1077   0ABB B9 00         cmp al, 0
1078   0ABD C6 C9 0A      jz _puts_END_print
1079   0AC0 23            mov ah, al
1080   0AC1 19 00         mov al, 0
1081   0AC3 05 03         syscall sys_io
1082   0AC5 79            inc d
1083   0AC6 0A BA 0A      jmp _puts_L1_print
1084   0AC9             _puts_END_print:
1085   0AC9             ; --- END INLINE ASM SEGMENT
1086   0AC9 F9            leave
1087   0ACA 09            ret
1088   0ACB             
1089   0ACB             print_signed:
1090   0ACB F8 00 00      enter 0 ; (push bp; mov bp, sp)
1091   0ACE             ; char digits[5]; 
1092   0ACE 52 05 00      sub sp, 5
1093   0AD1             ; int i = 0; 
1094   0AD1 52 02 00      sub sp, 2
1095   0AD4             ; --- START LOCAL VAR INITIALIZATION
1096   0AD4 FA FA FF      lea d, [bp + -6] ; $i
1097   0AD7 DA            push d
1098   0AD8 FD 2E 00 00   mov32 cb, $00000000
1098   0ADC 00 00 
1099   0ADE E7            pop d
1100   0ADF FD 43         mov [d], b
1101   0AE1             ; --- END LOCAL VAR INITIALIZATION
1102   0AE1             ; if (num < 0) { 
1103   0AE1             _if32_cond:
1104   0AE1 FA 05 00      lea d, [bp + 5] ; $num
1105   0AE4 2A            mov b, [d]
1106   0AE5 38 00 00      mov c, 0
1107   0AE8             ; --- START RELATIONAL
1108   0AE8 D7            push a
1109   0AE9 11            mov a, b
1110   0AEA FD 2E 00 00   mov32 cb, $00000000
1110   0AEE 00 00 
1111   0AF0 B0            cmp a, b
1112   0AF1 FD 73         slt ; < (signed)
1113   0AF3 E4            pop a
1114   0AF4             ; --- END RELATIONAL
1115   0AF4 C0 00 00      cmp b, 0
1116   0AF7 C6 1A 0B      je _if32_else
1117   0AFA             _if32_TRUE:
1118   0AFA             ; putchar('-'); 
1119   0AFA             ; --- START FUNCTION CALL
1120   0AFA FD 2E 2D 00   mov32 cb, $0000002d
1120   0AFE 00 00 
1121   0B00 DD            push bl
1122   0B01 07 03 09      call putchar
1123   0B04 51 01 00      add sp, 1
1124   0B07             ; --- END FUNCTION CALL
1125   0B07             ; num = -num; 
1126   0B07 FA 05 00      lea d, [bp + 5] ; $num
1127   0B0A DA            push d
1128   0B0B FA 05 00      lea d, [bp + 5] ; $num
1129   0B0E 2A            mov b, [d]
1130   0B0F 38 00 00      mov c, 0
1131   0B12 FD 97         neg b
1132   0B14 E7            pop d
1133   0B15 FD 43         mov [d], b
1134   0B17 0A 45 0B      jmp _if32_exit
1135   0B1A             _if32_else:
1136   0B1A             ; if (num == 0) { 
1137   0B1A             _if33_cond:
1138   0B1A FA 05 00      lea d, [bp + 5] ; $num
1139   0B1D 2A            mov b, [d]
1140   0B1E 38 00 00      mov c, 0
1141   0B21             ; --- START RELATIONAL
1142   0B21 D7            push a
1143   0B22 11            mov a, b
1144   0B23 FD 2E 00 00   mov32 cb, $00000000
1144   0B27 00 00 
1145   0B29 B0            cmp a, b
1146   0B2A FD 71         seq ; ==
1147   0B2C E4            pop a
1148   0B2D             ; --- END RELATIONAL
1149   0B2D C0 00 00      cmp b, 0
1150   0B30 C6 45 0B      je _if33_exit
1151   0B33             _if33_TRUE:
1152   0B33             ; putchar('0'); 
1153   0B33             ; --- START FUNCTION CALL
1154   0B33 FD 2E 30 00   mov32 cb, $00000030
1154   0B37 00 00 
1155   0B39 DD            push bl
1156   0B3A 07 03 09      call putchar
1157   0B3D 51 01 00      add sp, 1
1158   0B40             ; --- END FUNCTION CALL
1159   0B40             ; return; 
1160   0B40 F9            leave
1161   0B41 09            ret
1162   0B42 0A 45 0B      jmp _if33_exit
1163   0B45             _if33_exit:
1164   0B45             _if32_exit:
1165   0B45             ; while (num > 0) { 
1166   0B45             _while34_cond:
1167   0B45 FA 05 00      lea d, [bp + 5] ; $num
1168   0B48 2A            mov b, [d]
1169   0B49 38 00 00      mov c, 0
1170   0B4C             ; --- START RELATIONAL
1171   0B4C D7            push a
1172   0B4D 11            mov a, b
1173   0B4E FD 2E 00 00   mov32 cb, $00000000
1173   0B52 00 00 
1174   0B54 B0            cmp a, b
1175   0B55 FD 7F         sgt ; >
1176   0B57 E4            pop a
1177   0B58             ; --- END RELATIONAL
1178   0B58 C0 00 00      cmp b, 0
1179   0B5B C6 CA 0B      je _while34_exit
1180   0B5E             _while34_block:
1181   0B5E             ; digits[i] = '0' + (num % 10); 
1182   0B5E FA FC FF      lea d, [bp + -4] ; $digits
1183   0B61 D7            push a
1184   0B62 DA            push d
1185   0B63 FA FA FF      lea d, [bp + -6] ; $i
1186   0B66 2A            mov b, [d]
1187   0B67 38 00 00      mov c, 0
1188   0B6A E7            pop d
1189   0B6B 5A            add d, b
1190   0B6C E4            pop a
1191   0B6D DA            push d
1192   0B6E FD 2E 30 00   mov32 cb, $00000030
1192   0B72 00 00 
1193   0B74             ; --- START TERMS
1194   0B74 D7            push a
1195   0B75 11            mov a, b
1196   0B76 FA 05 00      lea d, [bp + 5] ; $num
1197   0B79 2A            mov b, [d]
1198   0B7A 38 00 00      mov c, 0
1199   0B7D             ; --- START FACTORS
1200   0B7D D7            push a
1201   0B7E FD D8         push g
1202   0B80 11            mov a, b
1203   0B81 FD 7A         mov g, c
1204   0B83 FD 2E 0A 00   mov32 cb, $0000000a
1204   0B87 00 00 
1205   0B89 AE            div a, b ; %, a: quotient, b: remainder
1206   0B8A 11            mov a, b
1207   0B8B FD 38         mov c, g
1208   0B8D 27            mov b, a
1209   0B8E FD F1         pop g
1210   0B90 E4            pop a
1211   0B91             ; --- END FACTORS
1212   0B91 56            add b, a
1213   0B92 E4            pop a
1214   0B93             ; --- END TERMS
1215   0B93 E7            pop d
1216   0B94 FD 3E         mov [d], bl
1217   0B96             ; num = num / 10; 
1218   0B96 FA 05 00      lea d, [bp + 5] ; $num
1219   0B99 DA            push d
1220   0B9A FA 05 00      lea d, [bp + 5] ; $num
1221   0B9D 2A            mov b, [d]
1222   0B9E 38 00 00      mov c, 0
1223   0BA1             ; --- START FACTORS
1224   0BA1 D7            push a
1225   0BA2 FD D8         push g
1226   0BA4 11            mov a, b
1227   0BA5 FD 7A         mov g, c
1228   0BA7 FD 2E 0A 00   mov32 cb, $0000000a
1228   0BAB 00 00 
1229   0BAD AE            div a, b ; /, a: quotient, b: remainder
1230   0BAE FD 38         mov c, g
1231   0BB0 27            mov b, a
1232   0BB1 FD F1         pop g
1233   0BB3 E4            pop a
1234   0BB4             ; --- END FACTORS
1235   0BB4 E7            pop d
1236   0BB5 FD 43         mov [d], b
1237   0BB7             ; i++; 
1238   0BB7 FA FA FF      lea d, [bp + -6] ; $i
1239   0BBA 2A            mov b, [d]
1240   0BBB 38 00 00      mov c, 0
1241   0BBE 11            mov a, b
1242   0BBF FD 77         inc b
1243   0BC1 FA FA FF      lea d, [bp + -6] ; $i
1244   0BC4 FD 43         mov [d], b
1245   0BC6 27            mov b, a
1246   0BC7 0A 45 0B      jmp _while34_cond
1247   0BCA             _while34_exit:
1248   0BCA             ; while (i > 0) { 
1249   0BCA             _while41_cond:
1250   0BCA FA FA FF      lea d, [bp + -6] ; $i
1251   0BCD 2A            mov b, [d]
1252   0BCE 38 00 00      mov c, 0
1253   0BD1             ; --- START RELATIONAL
1254   0BD1 D7            push a
1255   0BD2 11            mov a, b
1256   0BD3 FD 2E 00 00   mov32 cb, $00000000
1256   0BD7 00 00 
1257   0BD9 B0            cmp a, b
1258   0BDA FD 7F         sgt ; >
1259   0BDC E4            pop a
1260   0BDD             ; --- END RELATIONAL
1261   0BDD C0 00 00      cmp b, 0
1262   0BE0 C6 12 0C      je _while41_exit
1263   0BE3             _while41_block:
1264   0BE3             ; i--; 
1265   0BE3 FA FA FF      lea d, [bp + -6] ; $i
1266   0BE6 2A            mov b, [d]
1267   0BE7 38 00 00      mov c, 0
1268   0BEA 11            mov a, b
1269   0BEB FD 7D         dec b
1270   0BED FA FA FF      lea d, [bp + -6] ; $i
1271   0BF0 FD 43         mov [d], b
1272   0BF2 27            mov b, a
1273   0BF3             ; putchar(digits[i]); 
1274   0BF3             ; --- START FUNCTION CALL
1275   0BF3 FA FC FF      lea d, [bp + -4] ; $digits
1276   0BF6 D7            push a
1277   0BF7 DA            push d
1278   0BF8 FA FA FF      lea d, [bp + -6] ; $i
1279   0BFB 2A            mov b, [d]
1280   0BFC 38 00 00      mov c, 0
1281   0BFF E7            pop d
1282   0C00 5A            add d, b
1283   0C01 E4            pop a
1284   0C02 32            mov bl, [d]
1285   0C03 A7 00         mov bh, 0
1286   0C05 38 00 00      mov c, 0
1287   0C08 DD            push bl
1288   0C09 07 03 09      call putchar
1289   0C0C 51 01 00      add sp, 1
1290   0C0F             ; --- END FUNCTION CALL
1291   0C0F 0A CA 0B      jmp _while41_cond
1292   0C12             _while41_exit:
1293   0C12 F9            leave
1294   0C13 09            ret
1295   0C14             
1296   0C14             print_unsigned:
1297   0C14 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1298   0C17             ; char digits[5]; 
1299   0C17 52 05 00      sub sp, 5
1300   0C1A             ; int i; 
1301   0C1A 52 02 00      sub sp, 2
1302   0C1D             ; i = 0; 
1303   0C1D FA FA FF      lea d, [bp + -6] ; $i
1304   0C20 DA            push d
1305   0C21 FD 2E 00 00   mov32 cb, $00000000
1305   0C25 00 00 
1306   0C27 E7            pop d
1307   0C28 FD 43         mov [d], b
1308   0C2A             ; if(num == 0){ 
1309   0C2A             _if42_cond:
1310   0C2A FA 05 00      lea d, [bp + 5] ; $num
1311   0C2D 2A            mov b, [d]
1312   0C2E 38 00 00      mov c, 0
1313   0C31             ; --- START RELATIONAL
1314   0C31 D7            push a
1315   0C32 11            mov a, b
1316   0C33 FD 2E 00 00   mov32 cb, $00000000
1316   0C37 00 00 
1317   0C39 B0            cmp a, b
1318   0C3A FD 71         seq ; ==
1319   0C3C E4            pop a
1320   0C3D             ; --- END RELATIONAL
1321   0C3D C0 00 00      cmp b, 0
1322   0C40 C6 55 0C      je _if42_exit
1323   0C43             _if42_TRUE:
1324   0C43             ; putchar('0'); 
1325   0C43             ; --- START FUNCTION CALL
1326   0C43 FD 2E 30 00   mov32 cb, $00000030
1326   0C47 00 00 
1327   0C49 DD            push bl
1328   0C4A 07 03 09      call putchar
1329   0C4D 51 01 00      add sp, 1
1330   0C50             ; --- END FUNCTION CALL
1331   0C50             ; return; 
1332   0C50 F9            leave
1333   0C51 09            ret
1334   0C52 0A 55 0C      jmp _if42_exit
1335   0C55             _if42_exit:
1336   0C55             ; while (num > 0) { 
1337   0C55             _while43_cond:
1338   0C55 FA 05 00      lea d, [bp + 5] ; $num
1339   0C58 2A            mov b, [d]
1340   0C59 38 00 00      mov c, 0
1341   0C5C             ; --- START RELATIONAL
1342   0C5C D7            push a
1343   0C5D 11            mov a, b
1344   0C5E FD 2E 00 00   mov32 cb, $00000000
1344   0C62 00 00 
1345   0C64 B0            cmp a, b
1346   0C65 FD 81         sgu ; > (unsigned)
1347   0C67 E4            pop a
1348   0C68             ; --- END RELATIONAL
1349   0C68 C0 00 00      cmp b, 0
1350   0C6B C6 DA 0C      je _while43_exit
1351   0C6E             _while43_block:
1352   0C6E             ; digits[i] = '0' + (num % 10); 
1353   0C6E FA FC FF      lea d, [bp + -4] ; $digits
1354   0C71 D7            push a
1355   0C72 DA            push d
1356   0C73 FA FA FF      lea d, [bp + -6] ; $i
1357   0C76 2A            mov b, [d]
1358   0C77 38 00 00      mov c, 0
1359   0C7A E7            pop d
1360   0C7B 5A            add d, b
1361   0C7C E4            pop a
1362   0C7D DA            push d
1363   0C7E FD 2E 30 00   mov32 cb, $00000030
1363   0C82 00 00 
1364   0C84             ; --- START TERMS
1365   0C84 D7            push a
1366   0C85 11            mov a, b
1367   0C86 FA 05 00      lea d, [bp + 5] ; $num
1368   0C89 2A            mov b, [d]
1369   0C8A 38 00 00      mov c, 0
1370   0C8D             ; --- START FACTORS
1371   0C8D D7            push a
1372   0C8E FD D8         push g
1373   0C90 11            mov a, b
1374   0C91 FD 7A         mov g, c
1375   0C93 FD 2E 0A 00   mov32 cb, $0000000a
1375   0C97 00 00 
1376   0C99 AE            div a, b ; %, a: quotient, b: remainder
1377   0C9A 11            mov a, b
1378   0C9B FD 38         mov c, g
1379   0C9D 27            mov b, a
1380   0C9E FD F1         pop g
1381   0CA0 E4            pop a
1382   0CA1             ; --- END FACTORS
1383   0CA1 56            add b, a
1384   0CA2 E4            pop a
1385   0CA3             ; --- END TERMS
1386   0CA3 E7            pop d
1387   0CA4 FD 3E         mov [d], bl
1388   0CA6             ; num = num / 10; 
1389   0CA6 FA 05 00      lea d, [bp + 5] ; $num
1390   0CA9 DA            push d
1391   0CAA FA 05 00      lea d, [bp + 5] ; $num
1392   0CAD 2A            mov b, [d]
1393   0CAE 38 00 00      mov c, 0
1394   0CB1             ; --- START FACTORS
1395   0CB1 D7            push a
1396   0CB2 FD D8         push g
1397   0CB4 11            mov a, b
1398   0CB5 FD 7A         mov g, c
1399   0CB7 FD 2E 0A 00   mov32 cb, $0000000a
1399   0CBB 00 00 
1400   0CBD AE            div a, b ; /, a: quotient, b: remainder
1401   0CBE FD 38         mov c, g
1402   0CC0 27            mov b, a
1403   0CC1 FD F1         pop g
1404   0CC3 E4            pop a
1405   0CC4             ; --- END FACTORS
1406   0CC4 E7            pop d
1407   0CC5 FD 43         mov [d], b
1408   0CC7             ; i++; 
1409   0CC7 FA FA FF      lea d, [bp + -6] ; $i
1410   0CCA 2A            mov b, [d]
1411   0CCB 38 00 00      mov c, 0
1412   0CCE 11            mov a, b
1413   0CCF FD 77         inc b
1414   0CD1 FA FA FF      lea d, [bp + -6] ; $i
1415   0CD4 FD 43         mov [d], b
1416   0CD6 27            mov b, a
1417   0CD7 0A 55 0C      jmp _while43_cond
1418   0CDA             _while43_exit:
1419   0CDA             ; while (i > 0) { 
1420   0CDA             _while50_cond:
1421   0CDA FA FA FF      lea d, [bp + -6] ; $i
1422   0CDD 2A            mov b, [d]
1423   0CDE 38 00 00      mov c, 0
1424   0CE1             ; --- START RELATIONAL
1425   0CE1 D7            push a
1426   0CE2 11            mov a, b
1427   0CE3 FD 2E 00 00   mov32 cb, $00000000
1427   0CE7 00 00 
1428   0CE9 B0            cmp a, b
1429   0CEA FD 7F         sgt ; >
1430   0CEC E4            pop a
1431   0CED             ; --- END RELATIONAL
1432   0CED C0 00 00      cmp b, 0
1433   0CF0 C6 22 0D      je _while50_exit
1434   0CF3             _while50_block:
1435   0CF3             ; i--; 
1436   0CF3 FA FA FF      lea d, [bp + -6] ; $i
1437   0CF6 2A            mov b, [d]
1438   0CF7 38 00 00      mov c, 0
1439   0CFA 11            mov a, b
1440   0CFB FD 7D         dec b
1441   0CFD FA FA FF      lea d, [bp + -6] ; $i
1442   0D00 FD 43         mov [d], b
1443   0D02 27            mov b, a
1444   0D03             ; putchar(digits[i]); 
1445   0D03             ; --- START FUNCTION CALL
1446   0D03 FA FC FF      lea d, [bp + -4] ; $digits
1447   0D06 D7            push a
1448   0D07 DA            push d
1449   0D08 FA FA FF      lea d, [bp + -6] ; $i
1450   0D0B 2A            mov b, [d]
1451   0D0C 38 00 00      mov c, 0
1452   0D0F E7            pop d
1453   0D10 5A            add d, b
1454   0D11 E4            pop a
1455   0D12 32            mov bl, [d]
1456   0D13 A7 00         mov bh, 0
1457   0D15 38 00 00      mov c, 0
1458   0D18 DD            push bl
1459   0D19 07 03 09      call putchar
1460   0D1C 51 01 00      add sp, 1
1461   0D1F             ; --- END FUNCTION CALL
1462   0D1F 0A DA 0C      jmp _while50_cond
1463   0D22             _while50_exit:
1464   0D22 F9            leave
1465   0D23 09            ret
1466   0D24             
1467   0D24             printx16:
1468   0D24 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1469   0D27             ; --- BEGIN INLINE ASM SEGMENT
1470   0D27 FA 05 00      lea d, [bp + 5] ; $hex
1471   0D2A 2A            mov b, [d]
1472   0D2B             print_u16x_printx16:
1473   0D2B DD            push bl
1474   0D2C 30            mov bl, bh
1475   0D2D 07 4A 0D      call _itoa_printx16        ; convert bh to char in A
1476   0D30 2F            mov bl, al        ; save al
1477   0D31 19 00         mov al, 0
1478   0D33 05 03         syscall sys_io        ; display AH
1479   0D35 24            mov ah, bl        ; retrieve al
1480   0D36 19 00         mov al, 0
1481   0D38 05 03         syscall sys_io        ; display AL
1482   0D3A EA            pop bl
1483   0D3B 07 4A 0D      call _itoa_printx16        ; convert bh to char in A
1484   0D3E 2F            mov bl, al        ; save al
1485   0D3F 19 00         mov al, 0
1486   0D41 05 03         syscall sys_io        ; display AH
1487   0D43 24            mov ah, bl        ; retrieve al
1488   0D44 19 00         mov al, 0
1489   0D46 05 03         syscall sys_io        ; display AL
1490   0D48             ; --- END INLINE ASM SEGMENT
1491   0D48             ; return; 
1492   0D48 F9            leave
1493   0D49 09            ret
1494   0D4A             ; --- BEGIN INLINE ASM SEGMENT
1495   0D4A             _itoa_printx16:
1496   0D4A DA            push d
1497   0D4B D8            push b
1498   0D4C A7 00         mov bh, 0
1499   0D4E FD A4 04      shr bl, 4  
1500   0D51 74            mov d, b
1501   0D52 1F 64 0D      mov al, [d + s_hex_digits_printx16]
1502   0D55 23            mov ah, al
1503   0D56 E5            pop b
1504   0D57 D8            push b
1505   0D58 A7 00         mov bh, 0
1506   0D5A FD 87 0F      and bl, $0F
1507   0D5D 74            mov d, b
1508   0D5E 1F 64 0D      mov al, [d + s_hex_digits_printx16]
1509   0D61 E5            pop b
1510   0D62 E7            pop d
1511   0D63 09            ret
1512   0D64 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
1512   0D68 34 35 36 37 
1512   0D6C 38 39 41 42 
1512   0D70 43 44 45 46 
1513   0D74             ; --- END INLINE ASM SEGMENT
1514   0D74 F9            leave
1515   0D75 09            ret
1516   0D76             ; --- END TEXT SEGMENT
1517   0D76             
1518   0D76             ; --- BEGIN DATA SEGMENT
1519   0D76 4F 6B 61 79 _s0: .db "Okay", 0
1519   0D7A 00 
1520   0D7B 55 6E 65 78 _s1: .db "Unexpected format in printf.", 0
1520   0D7F 70 65 63 74 
1520   0D83 65 64 20 66 
1520   0D87 6F 72 6D 61 
1520   0D8B 74 20 69 6E 
1520   0D8F 20 70 72 69 
1520   0D93 6E 74 66 2E 
1520   0D97 00 
1521   0D98 45 72 72 6F _s2: .db "Error: Unknown argument type.\n", 0
1521   0D9C 72 3A 20 55 
1521   0DA0 6E 6B 6E 6F 
1521   0DA4 77 6E 20 61 
1521   0DA8 72 67 75 6D 
1521   0DAC 65 6E 74 20 
1521   0DB0 74 79 70 65 
1521   0DB4 2E 0A 00 
1522   0DB7             
1523   0DB7 B9 0D       _heap_top: .dw _heap
1524   0DB9 00          _heap: .db 0
1525   0DBA             ; --- END DATA SEGMENT
1526   0DBA             
1527   0DBA             .end
tasm: Number of errors = 0
