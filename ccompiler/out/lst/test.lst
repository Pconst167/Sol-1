0001   0000             ; --- FILENAME: test
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT SEGMENT
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; sprintf(s, "Integer: %d, Char: %c, String: %s\n\n",  2341, 'G', "Hello World!"); 
0011   0408 26 F1 1F      mov b, _s1 ; "Hello World!"
0012   040B FD AB         swp b
0013   040D D8            push b
0014   040E 26 47 00      mov b, $47
0015   0411 DD            push bl
0016   0412 26 25 09      mov b, $925
0017   0415 FD AB         swp b
0018   0417 D8            push b
0019   0418 26 FE 1F      mov b, _s2 ; "Integer: %d, Char: %c, String: %s\n\n"
0020   041B FD AB         swp b
0021   041D D8            push b
0022   041E 3B E1 1E      mov d, _s_data ; $s
0023   0421 2D            mov b, d
0024   0422 FD AB         swp b
0025   0424 D8            push b
0026   0425 07 99 0C      call sprintf
0027   0428 51 09 00      add sp, 9
0028   042B             ; printf("Final String: %s", s); 
0029   042B 3B E1 1E      mov d, _s_data ; $s
0030   042E 2D            mov b, d
0031   042F FD AB         swp b
0032   0431 D8            push b
0033   0432 26 22 20      mov b, _s3 ; "Final String: %s"
0034   0435 FD AB         swp b
0035   0437 D8            push b
0036   0438 07 E6 07      call printf
0037   043B 51 04 00      add sp, 4
0038   043E 05 0B         syscall sys_terminate_proc
0039   0440             
0040   0440             strcpy:
0041   0440 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0042   0443             ; char *psrc; 
0043   0443 52 02 00      sub sp, 2
0044   0446             ; char *pdest; 
0045   0446 52 02 00      sub sp, 2
0046   0449             ; psrc = src; 
0047   0449 FA FF FF      lea d, [bp + -1] ; $psrc
0048   044C DA            push d
0049   044D FA 07 00      lea d, [bp + 7] ; $src
0050   0450 2A            mov b, [d]
0051   0451 E7            pop d
0052   0452 FD 43         mov [d], b
0053   0454             ; pdest = dest; 
0054   0454 FA FD FF      lea d, [bp + -3] ; $pdest
0055   0457 DA            push d
0056   0458 FA 05 00      lea d, [bp + 5] ; $dest
0057   045B 2A            mov b, [d]
0058   045C E7            pop d
0059   045D FD 43         mov [d], b
0060   045F             ; while(*psrc) *pdest++ = *psrc++; 
0061   045F             _while1_cond:
0062   045F FA FF FF      lea d, [bp + -1] ; $psrc
0063   0462 2A            mov b, [d]
0064   0463 74            mov d, b
0065   0464 32            mov bl, [d]
0066   0465 A7 00         mov bh, 0
0067   0467 C0 00 00      cmp b, 0
0068   046A C6 92 04      je _while1_exit
0069   046D             _while1_block:
0070   046D             ; *pdest++ = *psrc++; 
0071   046D FA FD FF      lea d, [bp + -3] ; $pdest
0072   0470 2A            mov b, [d]
0073   0471 FD 77         inc b
0074   0473 FA FD FF      lea d, [bp + -3] ; $pdest
0075   0476 FD 43         mov [d], b
0076   0478 FD 7D         dec b
0077   047A D8            push b
0078   047B FA FF FF      lea d, [bp + -1] ; $psrc
0079   047E 2A            mov b, [d]
0080   047F FD 77         inc b
0081   0481 FA FF FF      lea d, [bp + -1] ; $psrc
0082   0484 FD 43         mov [d], b
0083   0486 FD 7D         dec b
0084   0488 74            mov d, b
0085   0489 32            mov bl, [d]
0086   048A A7 00         mov bh, 0
0087   048C E7            pop d
0088   048D FD 3E         mov [d], bl
0089   048F 0A 5F 04      jmp _while1_cond
0090   0492             _while1_exit:
0091   0492             ; *pdest = '\0'; 
0092   0492 FA FD FF      lea d, [bp + -3] ; $pdest
0093   0495 2A            mov b, [d]
0094   0496 D8            push b
0095   0497 26 00 00      mov b, $0
0096   049A E7            pop d
0097   049B FD 3E         mov [d], bl
0098   049D F9            leave
0099   049E 09            ret
0100   049F             
0101   049F             strcmp:
0102   049F F8 00 00      enter 0 ; (push bp; mov bp, sp)
0103   04A2             ; while (*s1 && (*s1 == *s2)) { 
0104   04A2             _while2_cond:
0105   04A2 FA 05 00      lea d, [bp + 5] ; $s1
0106   04A5 2A            mov b, [d]
0107   04A6 74            mov d, b
0108   04A7 32            mov bl, [d]
0109   04A8 A7 00         mov bh, 0
0110   04AA             ; --- START LOGICAL AND
0111   04AA D7            push a
0112   04AB 11            mov a, b
0113   04AC FA 05 00      lea d, [bp + 5] ; $s1
0114   04AF 2A            mov b, [d]
0115   04B0 74            mov d, b
0116   04B1 32            mov bl, [d]
0117   04B2 A7 00         mov bh, 0
0118   04B4             ; --- START RELATIONAL
0119   04B4 D7            push a
0120   04B5 11            mov a, b
0121   04B6 FA 07 00      lea d, [bp + 7] ; $s2
0122   04B9 2A            mov b, [d]
0123   04BA 74            mov d, b
0124   04BB 32            mov bl, [d]
0125   04BC A7 00         mov bh, 0
0126   04BE B0            cmp a, b
0127   04BF FD 71         seq ; ==
0128   04C1 E4            pop a
0129   04C2             ; --- END RELATIONAL
0130   04C2 FD A7         sand a, b
0131   04C4 E4            pop a
0132   04C5             ; --- END LOGICAL AND
0133   04C5 C0 00 00      cmp b, 0
0134   04C8 C6 E8 04      je _while2_exit
0135   04CB             _while2_block:
0136   04CB             ; s1++; 
0137   04CB FA 05 00      lea d, [bp + 5] ; $s1
0138   04CE 2A            mov b, [d]
0139   04CF FD 77         inc b
0140   04D1 FA 05 00      lea d, [bp + 5] ; $s1
0141   04D4 FD 43         mov [d], b
0142   04D6 FD 7D         dec b
0143   04D8             ; s2++; 
0144   04D8 FA 07 00      lea d, [bp + 7] ; $s2
0145   04DB 2A            mov b, [d]
0146   04DC FD 77         inc b
0147   04DE FA 07 00      lea d, [bp + 7] ; $s2
0148   04E1 FD 43         mov [d], b
0149   04E3 FD 7D         dec b
0150   04E5 0A A2 04      jmp _while2_cond
0151   04E8             _while2_exit:
0152   04E8             ; return *s1 - *s2; 
0153   04E8 FA 05 00      lea d, [bp + 5] ; $s1
0154   04EB 2A            mov b, [d]
0155   04EC 74            mov d, b
0156   04ED 32            mov bl, [d]
0157   04EE A7 00         mov bh, 0
0158   04F0             ; --- START TERMS
0159   04F0 D7            push a
0160   04F1 11            mov a, b
0161   04F2 FA 07 00      lea d, [bp + 7] ; $s2
0162   04F5 2A            mov b, [d]
0163   04F6 74            mov d, b
0164   04F7 32            mov bl, [d]
0165   04F8 A7 00         mov bh, 0
0166   04FA 60            sub a, b
0167   04FB 27            mov b, a
0168   04FC E4            pop a
0169   04FD             ; --- END TERMS
0170   04FD F9            leave
0171   04FE 09            ret
0172   04FF             
0173   04FF             strncmp:
0174   04FF F8 00 00      enter 0 ; (push bp; mov bp, sp)
0175   0502 F9            leave
0176   0503 09            ret
0177   0504             
0178   0504             strcat:
0179   0504 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0180   0507             ; int dest_len; 
0181   0507 52 02 00      sub sp, 2
0182   050A             ; int i; 
0183   050A 52 02 00      sub sp, 2
0184   050D             ; dest_len = strlen(dest); 
0185   050D FA FF FF      lea d, [bp + -1] ; $dest_len
0186   0510 DA            push d
0187   0511 FA 05 00      lea d, [bp + 5] ; $dest
0188   0514 2A            mov b, [d]
0189   0515 FD AB         swp b
0190   0517 D8            push b
0191   0518 07 BA 05      call strlen
0192   051B 51 02 00      add sp, 2
0193   051E E7            pop d
0194   051F FD 43         mov [d], b
0195   0521             ; for (i = 0; src[i] != 0; i=i+1) { 
0196   0521             _for3_init:
0197   0521 FA FD FF      lea d, [bp + -3] ; $i
0198   0524 DA            push d
0199   0525 26 00 00      mov b, $0
0200   0528 E7            pop d
0201   0529 FD 43         mov [d], b
0202   052B             _for3_cond:
0203   052B FA 07 00      lea d, [bp + 7] ; $src
0204   052E FD 2A         mov d, [d]
0205   0530 D7            push a
0206   0531 DA            push d
0207   0532 FA FD FF      lea d, [bp + -3] ; $i
0208   0535 2A            mov b, [d]
0209   0536 E7            pop d
0210   0537 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0211   053B E4            pop a
0212   053C 32            mov bl, [d]
0213   053D A7 00         mov bh, 0
0214   053F             ; --- START RELATIONAL
0215   053F D7            push a
0216   0540 11            mov a, b
0217   0541 26 00 00      mov b, $0
0218   0544 B0            cmp a, b
0219   0545 FD 72         sneq ; !=
0220   0547 E4            pop a
0221   0548             ; --- END RELATIONAL
0222   0548 C0 00 00      cmp b, 0
0223   054B C6 94 05      je _for3_exit
0224   054E             _for3_block:
0225   054E             ; dest[dest_len + i] = src[i]; 
0226   054E FA 05 00      lea d, [bp + 5] ; $dest
0227   0551 FD 2A         mov d, [d]
0228   0553 D7            push a
0229   0554 DA            push d
0230   0555 FA FF FF      lea d, [bp + -1] ; $dest_len
0231   0558 2A            mov b, [d]
0232   0559             ; --- START TERMS
0233   0559 D7            push a
0234   055A 11            mov a, b
0235   055B FA FD FF      lea d, [bp + -3] ; $i
0236   055E 2A            mov b, [d]
0237   055F 56            add b, a
0238   0560 E4            pop a
0239   0561             ; --- END TERMS
0240   0561 E7            pop d
0241   0562 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0242   0566 E4            pop a
0243   0567 DA            push d
0244   0568 FA 07 00      lea d, [bp + 7] ; $src
0245   056B FD 2A         mov d, [d]
0246   056D D7            push a
0247   056E DA            push d
0248   056F FA FD FF      lea d, [bp + -3] ; $i
0249   0572 2A            mov b, [d]
0250   0573 E7            pop d
0251   0574 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0252   0578 E4            pop a
0253   0579 32            mov bl, [d]
0254   057A A7 00         mov bh, 0
0255   057C E7            pop d
0256   057D FD 3E         mov [d], bl
0257   057F             _for3_update:
0258   057F FA FD FF      lea d, [bp + -3] ; $i
0259   0582 DA            push d
0260   0583 FA FD FF      lea d, [bp + -3] ; $i
0261   0586 2A            mov b, [d]
0262   0587             ; --- START TERMS
0263   0587 D7            push a
0264   0588 11            mov a, b
0265   0589 26 01 00      mov b, $1
0266   058C 56            add b, a
0267   058D E4            pop a
0268   058E             ; --- END TERMS
0269   058E E7            pop d
0270   058F FD 43         mov [d], b
0271   0591 0A 2B 05      jmp _for3_cond
0272   0594             _for3_exit:
0273   0594             ; dest[dest_len + i] = 0; 
0274   0594 FA 05 00      lea d, [bp + 5] ; $dest
0275   0597 FD 2A         mov d, [d]
0276   0599 D7            push a
0277   059A DA            push d
0278   059B FA FF FF      lea d, [bp + -1] ; $dest_len
0279   059E 2A            mov b, [d]
0280   059F             ; --- START TERMS
0281   059F D7            push a
0282   05A0 11            mov a, b
0283   05A1 FA FD FF      lea d, [bp + -3] ; $i
0284   05A4 2A            mov b, [d]
0285   05A5 56            add b, a
0286   05A6 E4            pop a
0287   05A7             ; --- END TERMS
0288   05A7 E7            pop d
0289   05A8 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0290   05AC E4            pop a
0291   05AD DA            push d
0292   05AE 26 00 00      mov b, $0
0293   05B1 E7            pop d
0294   05B2 FD 3E         mov [d], bl
0295   05B4             ; return dest; 
0296   05B4 FA 05 00      lea d, [bp + 5] ; $dest
0297   05B7 2A            mov b, [d]
0298   05B8 F9            leave
0299   05B9 09            ret
0300   05BA             
0301   05BA             strlen:
0302   05BA F8 00 00      enter 0 ; (push bp; mov bp, sp)
0303   05BD             ; int length; 
0304   05BD 52 02 00      sub sp, 2
0305   05C0             ; length = 0; 
0306   05C0 FA FF FF      lea d, [bp + -1] ; $length
0307   05C3 DA            push d
0308   05C4 26 00 00      mov b, $0
0309   05C7 E7            pop d
0310   05C8 FD 43         mov [d], b
0311   05CA             ; while (str[length] != 0) { 
0312   05CA             _while4_cond:
0313   05CA FA 05 00      lea d, [bp + 5] ; $str
0314   05CD FD 2A         mov d, [d]
0315   05CF D7            push a
0316   05D0 DA            push d
0317   05D1 FA FF FF      lea d, [bp + -1] ; $length
0318   05D4 2A            mov b, [d]
0319   05D5 E7            pop d
0320   05D6 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0321   05DA E4            pop a
0322   05DB 32            mov bl, [d]
0323   05DC A7 00         mov bh, 0
0324   05DE             ; --- START RELATIONAL
0325   05DE D7            push a
0326   05DF 11            mov a, b
0327   05E0 26 00 00      mov b, $0
0328   05E3 B0            cmp a, b
0329   05E4 FD 72         sneq ; !=
0330   05E6 E4            pop a
0331   05E7             ; --- END RELATIONAL
0332   05E7 C0 00 00      cmp b, 0
0333   05EA C6 FD 05      je _while4_exit
0334   05ED             _while4_block:
0335   05ED             ; length++; 
0336   05ED FA FF FF      lea d, [bp + -1] ; $length
0337   05F0 2A            mov b, [d]
0338   05F1 FD 77         inc b
0339   05F3 FA FF FF      lea d, [bp + -1] ; $length
0340   05F6 FD 43         mov [d], b
0341   05F8 FD 7D         dec b
0342   05FA 0A CA 05      jmp _while4_cond
0343   05FD             _while4_exit:
0344   05FD             ; return length; 
0345   05FD FA FF FF      lea d, [bp + -1] ; $length
0346   0600 2A            mov b, [d]
0347   0601 F9            leave
0348   0602 09            ret
0349   0603             
0350   0603             exit:
0351   0603 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0352   0606             
0353   0606             ; --- BEGIN INLINE ASM SEGMENT
0354   0606 05 0B         syscall sys_terminate_proc
0355   0608             ; --- END INLINE ASM SEGMENT
0356   0608             
0357   0608 F9            leave
0358   0609 09            ret
0359   060A             
0360   060A             memset:
0361   060A F8 00 00      enter 0 ; (push bp; mov bp, sp)
0362   060D             ; int i; 
0363   060D 52 02 00      sub sp, 2
0364   0610             ; for(i = 0; i < size; i++){ 
0365   0610             _for5_init:
0366   0610 FA FF FF      lea d, [bp + -1] ; $i
0367   0613 DA            push d
0368   0614 26 00 00      mov b, $0
0369   0617 E7            pop d
0370   0618 FD 43         mov [d], b
0371   061A             _for5_cond:
0372   061A FA FF FF      lea d, [bp + -1] ; $i
0373   061D 2A            mov b, [d]
0374   061E             ; --- START RELATIONAL
0375   061E D7            push a
0376   061F 11            mov a, b
0377   0620 FA 08 00      lea d, [bp + 8] ; $size
0378   0623 2A            mov b, [d]
0379   0624 B0            cmp a, b
0380   0625 FD 73         slt ; < (signed)
0381   0627 E4            pop a
0382   0628             ; --- END RELATIONAL
0383   0628 C0 00 00      cmp b, 0
0384   062B C6 54 06      je _for5_exit
0385   062E             _for5_block:
0386   062E             ; *(s+i) = c; 
0387   062E FA 05 00      lea d, [bp + 5] ; $s
0388   0631 2A            mov b, [d]
0389   0632             ; --- START TERMS
0390   0632 D7            push a
0391   0633 11            mov a, b
0392   0634 FA FF FF      lea d, [bp + -1] ; $i
0393   0637 2A            mov b, [d]
0394   0638 56            add b, a
0395   0639 E4            pop a
0396   063A             ; --- END TERMS
0397   063A D8            push b
0398   063B FA 07 00      lea d, [bp + 7] ; $c
0399   063E 32            mov bl, [d]
0400   063F A7 00         mov bh, 0
0401   0641 E7            pop d
0402   0642 FD 3E         mov [d], bl
0403   0644             _for5_update:
0404   0644 FA FF FF      lea d, [bp + -1] ; $i
0405   0647 2A            mov b, [d]
0406   0648 FD 77         inc b
0407   064A FA FF FF      lea d, [bp + -1] ; $i
0408   064D FD 43         mov [d], b
0409   064F FD 7D         dec b
0410   0651 0A 1A 06      jmp _for5_cond
0411   0654             _for5_exit:
0412   0654             ; return s; 
0413   0654 FA 05 00      lea d, [bp + 5] ; $s
0414   0657 2A            mov b, [d]
0415   0658 F9            leave
0416   0659 09            ret
0417   065A             
0418   065A             atoi:
0419   065A F8 00 00      enter 0 ; (push bp; mov bp, sp)
0420   065D             ; int result = 0;  // Initialize result 
0421   065D 52 02 00      sub sp, 2
0422   0660             ; --- START LOCAL VAR INITIALIZATION
0423   0660 FA FF FF      lea d, [bp + -1] ; $result
0424   0663 DA            push d
0425   0664 26 00 00      mov b, $0
0426   0667 E7            pop d
0427   0668 FD 43         mov [d], b
0428   066A             ; --- END LOCAL VAR INITIALIZATION
0429   066A             ; int sign = 1;    // Initialize sign as positive 
0430   066A 52 02 00      sub sp, 2
0431   066D             ; --- START LOCAL VAR INITIALIZATION
0432   066D FA FD FF      lea d, [bp + -3] ; $sign
0433   0670 DA            push d
0434   0671 26 01 00      mov b, $1
0435   0674 E7            pop d
0436   0675 FD 43         mov [d], b
0437   0677             ; --- END LOCAL VAR INITIALIZATION
0438   0677             ; while (*str == ' ') str++; 
0439   0677             _while6_cond:
0440   0677 FA 05 00      lea d, [bp + 5] ; $str
0441   067A 2A            mov b, [d]
0442   067B 74            mov d, b
0443   067C 32            mov bl, [d]
0444   067D A7 00         mov bh, 0
0445   067F             ; --- START RELATIONAL
0446   067F D7            push a
0447   0680 11            mov a, b
0448   0681 26 20 00      mov b, $20
0449   0684 B0            cmp a, b
0450   0685 FD 71         seq ; ==
0451   0687 E4            pop a
0452   0688             ; --- END RELATIONAL
0453   0688 C0 00 00      cmp b, 0
0454   068B C6 9E 06      je _while6_exit
0455   068E             _while6_block:
0456   068E             ; str++; 
0457   068E FA 05 00      lea d, [bp + 5] ; $str
0458   0691 2A            mov b, [d]
0459   0692 FD 77         inc b
0460   0694 FA 05 00      lea d, [bp + 5] ; $str
0461   0697 FD 43         mov [d], b
0462   0699 FD 7D         dec b
0463   069B 0A 77 06      jmp _while6_cond
0464   069E             _while6_exit:
0465   069E             ; if (*str == '-' || *str == '+') { 
0466   069E             _if7_cond:
0467   069E FA 05 00      lea d, [bp + 5] ; $str
0468   06A1 2A            mov b, [d]
0469   06A2 74            mov d, b
0470   06A3 32            mov bl, [d]
0471   06A4 A7 00         mov bh, 0
0472   06A6             ; --- START RELATIONAL
0473   06A6 D7            push a
0474   06A7 11            mov a, b
0475   06A8 26 2D 00      mov b, $2d
0476   06AB B0            cmp a, b
0477   06AC FD 71         seq ; ==
0478   06AE E4            pop a
0479   06AF             ; --- END RELATIONAL
0480   06AF             ; --- START LOGICAL OR
0481   06AF D7            push a
0482   06B0 11            mov a, b
0483   06B1 FA 05 00      lea d, [bp + 5] ; $str
0484   06B4 2A            mov b, [d]
0485   06B5 74            mov d, b
0486   06B6 32            mov bl, [d]
0487   06B7 A7 00         mov bh, 0
0488   06B9             ; --- START RELATIONAL
0489   06B9 D7            push a
0490   06BA 11            mov a, b
0491   06BB 26 2B 00      mov b, $2b
0492   06BE B0            cmp a, b
0493   06BF FD 71         seq ; ==
0494   06C1 E4            pop a
0495   06C2             ; --- END RELATIONAL
0496   06C2 FD A8         sor a, b ; ||
0497   06C4 E4            pop a
0498   06C5             ; --- END LOGICAL OR
0499   06C5 C0 00 00      cmp b, 0
0500   06C8 C6 01 07      je _if7_exit
0501   06CB             _if7_true:
0502   06CB             ; if (*str == '-') sign = -1; 
0503   06CB             _if8_cond:
0504   06CB FA 05 00      lea d, [bp + 5] ; $str
0505   06CE 2A            mov b, [d]
0506   06CF 74            mov d, b
0507   06D0 32            mov bl, [d]
0508   06D1 A7 00         mov bh, 0
0509   06D3             ; --- START RELATIONAL
0510   06D3 D7            push a
0511   06D4 11            mov a, b
0512   06D5 26 2D 00      mov b, $2d
0513   06D8 B0            cmp a, b
0514   06D9 FD 71         seq ; ==
0515   06DB E4            pop a
0516   06DC             ; --- END RELATIONAL
0517   06DC C0 00 00      cmp b, 0
0518   06DF C6 F1 06      je _if8_exit
0519   06E2             _if8_true:
0520   06E2             ; sign = -1; 
0521   06E2 FA FD FF      lea d, [bp + -3] ; $sign
0522   06E5 DA            push d
0523   06E6 26 01 00      mov b, $1
0524   06E9 FD 97         neg b
0525   06EB E7            pop d
0526   06EC FD 43         mov [d], b
0527   06EE 0A F1 06      jmp _if8_exit
0528   06F1             _if8_exit:
0529   06F1             ; str++; 
0530   06F1 FA 05 00      lea d, [bp + 5] ; $str
0531   06F4 2A            mov b, [d]
0532   06F5 FD 77         inc b
0533   06F7 FA 05 00      lea d, [bp + 5] ; $str
0534   06FA FD 43         mov [d], b
0535   06FC FD 7D         dec b
0536   06FE 0A 01 07      jmp _if7_exit
0537   0701             _if7_exit:
0538   0701             ; while (*str >= '0' && *str <= '9') { 
0539   0701             _while9_cond:
0540   0701 FA 05 00      lea d, [bp + 5] ; $str
0541   0704 2A            mov b, [d]
0542   0705 74            mov d, b
0543   0706 32            mov bl, [d]
0544   0707 A7 00         mov bh, 0
0545   0709             ; --- START RELATIONAL
0546   0709 D7            push a
0547   070A 11            mov a, b
0548   070B 26 30 00      mov b, $30
0549   070E B0            cmp a, b
0550   070F FD 82         sgeu ; >= (unsigned)
0551   0711 E4            pop a
0552   0712             ; --- END RELATIONAL
0553   0712             ; --- START LOGICAL AND
0554   0712 D7            push a
0555   0713 11            mov a, b
0556   0714 FA 05 00      lea d, [bp + 5] ; $str
0557   0717 2A            mov b, [d]
0558   0718 74            mov d, b
0559   0719 32            mov bl, [d]
0560   071A A7 00         mov bh, 0
0561   071C             ; --- START RELATIONAL
0562   071C D7            push a
0563   071D 11            mov a, b
0564   071E 26 39 00      mov b, $39
0565   0721 B0            cmp a, b
0566   0722 FD 76         sleu ; <= (unsigned)
0567   0724 E4            pop a
0568   0725             ; --- END RELATIONAL
0569   0725 FD A7         sand a, b
0570   0727 E4            pop a
0571   0728             ; --- END LOGICAL AND
0572   0728 C0 00 00      cmp b, 0
0573   072B C6 66 07      je _while9_exit
0574   072E             _while9_block:
0575   072E             ; result = result * 10 + (*str - '0'); 
0576   072E FA FF FF      lea d, [bp + -1] ; $result
0577   0731 DA            push d
0578   0732 FA FF FF      lea d, [bp + -1] ; $result
0579   0735 2A            mov b, [d]
0580   0736             ; --- START FACTORS
0581   0736 D7            push a
0582   0737 11            mov a, b
0583   0738 26 0A 00      mov b, $a
0584   073B AC            mul a, b ; *
0585   073C 11            mov a, b
0586   073D 27            mov b, a
0587   073E E4            pop a
0588   073F             ; --- END FACTORS
0589   073F             ; --- START TERMS
0590   073F D7            push a
0591   0740 11            mov a, b
0592   0741 FA 05 00      lea d, [bp + 5] ; $str
0593   0744 2A            mov b, [d]
0594   0745 74            mov d, b
0595   0746 32            mov bl, [d]
0596   0747 A7 00         mov bh, 0
0597   0749             ; --- START TERMS
0598   0749 D7            push a
0599   074A 11            mov a, b
0600   074B 26 30 00      mov b, $30
0601   074E 60            sub a, b
0602   074F 27            mov b, a
0603   0750 E4            pop a
0604   0751             ; --- END TERMS
0605   0751 56            add b, a
0606   0752 E4            pop a
0607   0753             ; --- END TERMS
0608   0753 E7            pop d
0609   0754 FD 43         mov [d], b
0610   0756             ; str++; 
0611   0756 FA 05 00      lea d, [bp + 5] ; $str
0612   0759 2A            mov b, [d]
0613   075A FD 77         inc b
0614   075C FA 05 00      lea d, [bp + 5] ; $str
0615   075F FD 43         mov [d], b
0616   0761 FD 7D         dec b
0617   0763 0A 01 07      jmp _while9_cond
0618   0766             _while9_exit:
0619   0766             ; return sign * result; 
0620   0766 FA FD FF      lea d, [bp + -3] ; $sign
0621   0769 2A            mov b, [d]
0622   076A             ; --- START FACTORS
0623   076A D7            push a
0624   076B 11            mov a, b
0625   076C FA FF FF      lea d, [bp + -1] ; $result
0626   076F 2A            mov b, [d]
0627   0770 AC            mul a, b ; *
0628   0771 11            mov a, b
0629   0772 27            mov b, a
0630   0773 E4            pop a
0631   0774             ; --- END FACTORS
0632   0774 F9            leave
0633   0775 09            ret
0634   0776             
0635   0776             rand:
0636   0776 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0637   0779             ; int  sec; 
0638   0779 52 02 00      sub sp, 2
0639   077C             
0640   077C             ; --- BEGIN INLINE ASM SEGMENT
0641   077C 19 00         mov al, 0
0642   077E 05 01         syscall sys_rtc					
0643   0780 1A            mov al, ah
0644   0781 FA FF FF      lea d, [bp + -1] ; $sec
0645   0784 1E            mov al, [d]
0646   0785 22 00         mov ah, 0
0647   0787             ; --- END INLINE ASM SEGMENT
0648   0787             
0649   0787             ; return sec; 
0650   0787 FA FF FF      lea d, [bp + -1] ; $sec
0651   078A 2A            mov b, [d]
0652   078B F9            leave
0653   078C 09            ret
0654   078D             
0655   078D             alloc:
0656   078D F8 00 00      enter 0 ; (push bp; mov bp, sp)
0657   0790             ; heap_top = heap_top + bytes; 
0658   0790 3B 77 20      mov d, _heap_top ; $heap_top
0659   0793 DA            push d
0660   0794 3B 77 20      mov d, _heap_top ; $heap_top
0661   0797 2A            mov b, [d]
0662   0798             ; --- START TERMS
0663   0798 D7            push a
0664   0799 11            mov a, b
0665   079A FA 05 00      lea d, [bp + 5] ; $bytes
0666   079D 2A            mov b, [d]
0667   079E 56            add b, a
0668   079F E4            pop a
0669   07A0             ; --- END TERMS
0670   07A0 E7            pop d
0671   07A1 FD 43         mov [d], b
0672   07A3             ; return heap_top - bytes; 
0673   07A3 3B 77 20      mov d, _heap_top ; $heap_top
0674   07A6 2A            mov b, [d]
0675   07A7             ; --- START TERMS
0676   07A7 D7            push a
0677   07A8 11            mov a, b
0678   07A9 FA 05 00      lea d, [bp + 5] ; $bytes
0679   07AC 2A            mov b, [d]
0680   07AD 60            sub a, b
0681   07AE 27            mov b, a
0682   07AF E4            pop a
0683   07B0             ; --- END TERMS
0684   07B0 F9            leave
0685   07B1 09            ret
0686   07B2             
0687   07B2             free:
0688   07B2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0689   07B5             ; return heap_top = heap_top - bytes; 
0690   07B5 3B 77 20      mov d, _heap_top ; $heap_top
0691   07B8 DA            push d
0692   07B9 3B 77 20      mov d, _heap_top ; $heap_top
0693   07BC 2A            mov b, [d]
0694   07BD             ; --- START TERMS
0695   07BD D7            push a
0696   07BE 11            mov a, b
0697   07BF FA 05 00      lea d, [bp + 5] ; $bytes
0698   07C2 2A            mov b, [d]
0699   07C3 60            sub a, b
0700   07C4 27            mov b, a
0701   07C5 E4            pop a
0702   07C6             ; --- END TERMS
0703   07C6 E7            pop d
0704   07C7 FD 43         mov [d], b
0705   07C9 F9            leave
0706   07CA 09            ret
0707   07CB             
0708   07CB             fopen:
0709   07CB F8 00 00      enter 0 ; (push bp; mov bp, sp)
0710   07CE             ; FILE *fp; 
0711   07CE 52 02 00      sub sp, 2
0712   07D1             ; fp = alloc(sizeof(int)); 
0713   07D1 FA FF FF      lea d, [bp + -1] ; $fp
0714   07D4 DA            push d
0715   07D5 26 02 00      mov b, 2
0716   07D8 FD AB         swp b
0717   07DA D8            push b
0718   07DB 07 8D 07      call alloc
0719   07DE 51 02 00      add sp, 2
0720   07E1 E7            pop d
0721   07E2 FD 43         mov [d], b
0722   07E4 F9            leave
0723   07E5 09            ret
0724   07E6             
0725   07E6             printf:
0726   07E6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0727   07E9             ; char *p, *format_p; 
0728   07E9 52 02 00      sub sp, 2
0729   07EC 52 02 00      sub sp, 2
0730   07EF             ; format_p = format; 
0731   07EF FA FD FF      lea d, [bp + -3] ; $format_p
0732   07F2 DA            push d
0733   07F3 FA 05 00      lea d, [bp + 5] ; $format
0734   07F6 2A            mov b, [d]
0735   07F7 E7            pop d
0736   07F8 FD 43         mov [d], b
0737   07FA             ; p = &format + 2; 
0738   07FA FA FF FF      lea d, [bp + -1] ; $p
0739   07FD DA            push d
0740   07FE FA 05 00      lea d, [bp + 5] ; $format
0741   0801 2D            mov b, d
0742   0802             ; --- START TERMS
0743   0802 D7            push a
0744   0803 11            mov a, b
0745   0804 26 02 00      mov b, $2
0746   0807 56            add b, a
0747   0808 E4            pop a
0748   0809             ; --- END TERMS
0749   0809 E7            pop d
0750   080A FD 43         mov [d], b
0751   080C             ; for(;;){ 
0752   080C             _for10_init:
0753   080C             _for10_cond:
0754   080C             _for10_block:
0755   080C             ; if(!*format_p) break; 
0756   080C             _if11_cond:
0757   080C FA FD FF      lea d, [bp + -3] ; $format_p
0758   080F 2A            mov b, [d]
0759   0810 74            mov d, b
0760   0811 32            mov bl, [d]
0761   0812 A7 00         mov bh, 0
0762   0814 C0 00 00      cmp b, 0
0763   0817 FD 71         seq ; !
0764   0819 C0 00 00      cmp b, 0
0765   081C C6 25 08      je _if11_else
0766   081F             _if11_true:
0767   081F             ; break; 
0768   081F 0A 4C 0A      jmp _for10_exit ; for break
0769   0822 0A 49 0A      jmp _if11_exit
0770   0825             _if11_else:
0771   0825             ; if(*format_p == '%'){ 
0772   0825             _if12_cond:
0773   0825 FA FD FF      lea d, [bp + -3] ; $format_p
0774   0828 2A            mov b, [d]
0775   0829 74            mov d, b
0776   082A 32            mov bl, [d]
0777   082B A7 00         mov bh, 0
0778   082D             ; --- START RELATIONAL
0779   082D D7            push a
0780   082E 11            mov a, b
0781   082F 26 25 00      mov b, $25
0782   0832 B0            cmp a, b
0783   0833 FD 71         seq ; ==
0784   0835 E4            pop a
0785   0836             ; --- END RELATIONAL
0786   0836 C0 00 00      cmp b, 0
0787   0839 C6 2D 0A      je _if12_else
0788   083C             _if12_true:
0789   083C             ; format_p++; 
0790   083C FA FD FF      lea d, [bp + -3] ; $format_p
0791   083F 2A            mov b, [d]
0792   0840 FD 77         inc b
0793   0842 FA FD FF      lea d, [bp + -3] ; $format_p
0794   0845 FD 43         mov [d], b
0795   0847 FD 7D         dec b
0796   0849             ; switch(*format_p){ 
0797   0849             _switch13_expr:
0798   0849 FA FD FF      lea d, [bp + -3] ; $format_p
0799   084C 2A            mov b, [d]
0800   084D 74            mov d, b
0801   084E 32            mov bl, [d]
0802   084F A7 00         mov bh, 0
0803   0851             _switch13_comparisons:
0804   0851 C1 6C         cmp bl, $6c
0805   0853 C6 7F 08      je _switch13_case0
0806   0856 C1 4C         cmp bl, $4c
0807   0858 C6 7F 08      je _switch13_case1
0808   085B C1 64         cmp bl, $64
0809   085D C6 6D 09      je _switch13_case2
0810   0860 C1 69         cmp bl, $69
0811   0862 C6 6D 09      je _switch13_case3
0812   0865 C1 75         cmp bl, $75
0813   0867 C6 91 09      je _switch13_case4
0814   086A C1 78         cmp bl, $78
0815   086C C6 B5 09      je _switch13_case5
0816   086F C1 63         cmp bl, $63
0817   0871 C6 D3 09      je _switch13_case6
0818   0874 C1 73         cmp bl, $73
0819   0876 C6 F2 09      je _switch13_case7
0820   0879 0A 11 0A      jmp _switch13_default
0821   087C 0A 1D 0A      jmp _switch13_exit
0822   087F             _switch13_case0:
0823   087F             _switch13_case1:
0824   087F             ; format_p++; 
0825   087F FA FD FF      lea d, [bp + -3] ; $format_p
0826   0882 2A            mov b, [d]
0827   0883 FD 77         inc b
0828   0885 FA FD FF      lea d, [bp + -3] ; $format_p
0829   0888 FD 43         mov [d], b
0830   088A FD 7D         dec b
0831   088C             ; if(*format_p == 'd' || *format_p == 'i') 
0832   088C             _if14_cond:
0833   088C FA FD FF      lea d, [bp + -3] ; $format_p
0834   088F 2A            mov b, [d]
0835   0890 74            mov d, b
0836   0891 32            mov bl, [d]
0837   0892 A7 00         mov bh, 0
0838   0894             ; --- START RELATIONAL
0839   0894 D7            push a
0840   0895 11            mov a, b
0841   0896 26 64 00      mov b, $64
0842   0899 B0            cmp a, b
0843   089A FD 71         seq ; ==
0844   089C E4            pop a
0845   089D             ; --- END RELATIONAL
0846   089D             ; --- START LOGICAL OR
0847   089D D7            push a
0848   089E 11            mov a, b
0849   089F FA FD FF      lea d, [bp + -3] ; $format_p
0850   08A2 2A            mov b, [d]
0851   08A3 74            mov d, b
0852   08A4 32            mov bl, [d]
0853   08A5 A7 00         mov bh, 0
0854   08A7             ; --- START RELATIONAL
0855   08A7 D7            push a
0856   08A8 11            mov a, b
0857   08A9 26 69 00      mov b, $69
0858   08AC B0            cmp a, b
0859   08AD FD 71         seq ; ==
0860   08AF E4            pop a
0861   08B0             ; --- END RELATIONAL
0862   08B0 FD A8         sor a, b ; ||
0863   08B2 E4            pop a
0864   08B3             ; --- END LOGICAL OR
0865   08B3 C0 00 00      cmp b, 0
0866   08B6 C6 DB 08      je _if14_else
0867   08B9             _if14_true:
0868   08B9             ; print_signed_long(*(long *)p); 
0869   08B9 FA FF FF      lea d, [bp + -1] ; $p
0870   08BC 2A            mov b, [d]
0871   08BD AB            snex b
0872   08BE FD 39         mov c, b
0873   08C0 74            mov d, b
0874   08C1 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0875   08C4 FD 39         mov c, b ; And place it into C
0876   08C6 2A            mov b, [d] ; Lower Word in B
0877   08C7 FD 79         mov g, b
0878   08C9 28            mov b, c
0879   08CA FD AB         swp b
0880   08CC D8            push b
0881   08CD FD 27         mov b, g
0882   08CF FD AB         swp b
0883   08D1 D8            push b
0884   08D2 07 3D 12      call print_signed_long
0885   08D5 51 04 00      add sp, 4
0886   08D8 0A 58 09      jmp _if14_exit
0887   08DB             _if14_else:
0888   08DB             ; if(*format_p == 'u') 
0889   08DB             _if15_cond:
0890   08DB FA FD FF      lea d, [bp + -3] ; $format_p
0891   08DE 2A            mov b, [d]
0892   08DF 74            mov d, b
0893   08E0 32            mov bl, [d]
0894   08E1 A7 00         mov bh, 0
0895   08E3             ; --- START RELATIONAL
0896   08E3 D7            push a
0897   08E4 11            mov a, b
0898   08E5 26 75 00      mov b, $75
0899   08E8 B0            cmp a, b
0900   08E9 FD 71         seq ; ==
0901   08EB E4            pop a
0902   08EC             ; --- END RELATIONAL
0903   08EC C0 00 00      cmp b, 0
0904   08EF C6 16 09      je _if15_else
0905   08F2             _if15_true:
0906   08F2             ; print_unsigned_long(*(unsigned long *)p); 
0907   08F2 FA FF FF      lea d, [bp + -1] ; $p
0908   08F5 2A            mov b, [d]
0909   08F6 A7 00         mov bh, 0
0910   08F8 38 00 00      mov c, 0
0911   08FB 74            mov d, b
0912   08FC 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0913   08FF FD 39         mov c, b ; And place it into C
0914   0901 2A            mov b, [d] ; Lower Word in B
0915   0902 FD 79         mov g, b
0916   0904 28            mov b, c
0917   0905 FD AB         swp b
0918   0907 D8            push b
0919   0908 FD 27         mov b, g
0920   090A FD AB         swp b
0921   090C D8            push b
0922   090D 07 7D 15      call print_unsigned_long
0923   0910 51 04 00      add sp, 4
0924   0913 0A 58 09      jmp _if15_exit
0925   0916             _if15_else:
0926   0916             ; if(*format_p == 'x') 
0927   0916             _if16_cond:
0928   0916 FA FD FF      lea d, [bp + -3] ; $format_p
0929   0919 2A            mov b, [d]
0930   091A 74            mov d, b
0931   091B 32            mov bl, [d]
0932   091C A7 00         mov bh, 0
0933   091E             ; --- START RELATIONAL
0934   091E D7            push a
0935   091F 11            mov a, b
0936   0920 26 78 00      mov b, $78
0937   0923 B0            cmp a, b
0938   0924 FD 71         seq ; ==
0939   0926 E4            pop a
0940   0927             ; --- END RELATIONAL
0941   0927 C0 00 00      cmp b, 0
0942   092A C6 4C 09      je _if16_else
0943   092D             _if16_true:
0944   092D             ; printx32(*(long int *)p); 
0945   092D FA FF FF      lea d, [bp + -1] ; $p
0946   0930 2A            mov b, [d]
0947   0931 74            mov d, b
0948   0932 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0949   0935 FD 39         mov c, b ; And place it into C
0950   0937 2A            mov b, [d] ; Lower Word in B
0951   0938 FD 79         mov g, b
0952   093A 28            mov b, c
0953   093B FD AB         swp b
0954   093D D8            push b
0955   093E FD 27         mov b, g
0956   0940 FD AB         swp b
0957   0942 D8            push b
0958   0943 07 B2 0F      call printx32
0959   0946 51 04 00      add sp, 4
0960   0949 0A 58 09      jmp _if16_exit
0961   094C             _if16_else:
0962   094C             ; err("Unexpected format in printf."); 
0963   094C 26 33 20      mov b, _s4 ; "Unexpected format in printf."
0964   094F FD AB         swp b
0965   0951 D8            push b
0966   0952 07 A0 0F      call err
0967   0955 51 02 00      add sp, 2
0968   0958             _if16_exit:
0969   0958             _if15_exit:
0970   0958             _if14_exit:
0971   0958             ; p = p + 4; 
0972   0958 FA FF FF      lea d, [bp + -1] ; $p
0973   095B DA            push d
0974   095C FA FF FF      lea d, [bp + -1] ; $p
0975   095F 2A            mov b, [d]
0976   0960             ; --- START TERMS
0977   0960 D7            push a
0978   0961 11            mov a, b
0979   0962 26 04 00      mov b, $4
0980   0965 56            add b, a
0981   0966 E4            pop a
0982   0967             ; --- END TERMS
0983   0967 E7            pop d
0984   0968 FD 43         mov [d], b
0985   096A             ; break; 
0986   096A 0A 1D 0A      jmp _switch13_exit ; case break
0987   096D             _switch13_case2:
0988   096D             _switch13_case3:
0989   096D             ; print_signed(*(int*)p); 
0990   096D FA FF FF      lea d, [bp + -1] ; $p
0991   0970 2A            mov b, [d]
0992   0971 74            mov d, b
0993   0972 2A            mov b, [d]
0994   0973 FD AB         swp b
0995   0975 D8            push b
0996   0976 07 46 11      call print_signed
0997   0979 51 02 00      add sp, 2
0998   097C             ; p = p + 2; 
0999   097C FA FF FF      lea d, [bp + -1] ; $p
1000   097F DA            push d
1001   0980 FA FF FF      lea d, [bp + -1] ; $p
1002   0983 2A            mov b, [d]
1003   0984             ; --- START TERMS
1004   0984 D7            push a
1005   0985 11            mov a, b
1006   0986 26 02 00      mov b, $2
1007   0989 56            add b, a
1008   098A E4            pop a
1009   098B             ; --- END TERMS
1010   098B E7            pop d
1011   098C FD 43         mov [d], b
1012   098E             ; break; 
1013   098E 0A 1D 0A      jmp _switch13_exit ; case break
1014   0991             _switch13_case4:
1015   0991             ; print_unsigned(*(unsigned int*)p); 
1016   0991 FA FF FF      lea d, [bp + -1] ; $p
1017   0994 2A            mov b, [d]
1018   0995 74            mov d, b
1019   0996 2A            mov b, [d]
1020   0997 FD AB         swp b
1021   0999 D8            push b
1022   099A 07 82 18      call print_unsigned
1023   099D 51 02 00      add sp, 2
1024   09A0             ; p = p + 2; 
1025   09A0 FA FF FF      lea d, [bp + -1] ; $p
1026   09A3 DA            push d
1027   09A4 FA FF FF      lea d, [bp + -1] ; $p
1028   09A7 2A            mov b, [d]
1029   09A8             ; --- START TERMS
1030   09A8 D7            push a
1031   09A9 11            mov a, b
1032   09AA 26 02 00      mov b, $2
1033   09AD 56            add b, a
1034   09AE E4            pop a
1035   09AF             ; --- END TERMS
1036   09AF E7            pop d
1037   09B0 FD 43         mov [d], b
1038   09B2             ; break; 
1039   09B2 0A 1D 0A      jmp _switch13_exit ; case break
1040   09B5             _switch13_case5:
1041   09B5             
1042   09B5             ; --- BEGIN INLINE ASM SEGMENT
1043   09B5 FA FF FF      lea d, [bp + -1] ; $p
1044   09B8 FD 2A         mov d, [d]
1045   09BA 2A            mov b, [d]
1046   09BB 07 E1 1D      call print_u16x
1047   09BE             ; --- END INLINE ASM SEGMENT
1048   09BE             
1049   09BE             ; p = p + 2; 
1050   09BE FA FF FF      lea d, [bp + -1] ; $p
1051   09C1 DA            push d
1052   09C2 FA FF FF      lea d, [bp + -1] ; $p
1053   09C5 2A            mov b, [d]
1054   09C6             ; --- START TERMS
1055   09C6 D7            push a
1056   09C7 11            mov a, b
1057   09C8 26 02 00      mov b, $2
1058   09CB 56            add b, a
1059   09CC E4            pop a
1060   09CD             ; --- END TERMS
1061   09CD E7            pop d
1062   09CE FD 43         mov [d], b
1063   09D0             ; break; 
1064   09D0 0A 1D 0A      jmp _switch13_exit ; case break
1065   09D3             _switch13_case6:
1066   09D3             
1067   09D3             ; --- BEGIN INLINE ASM SEGMENT
1068   09D3 FA FF FF      lea d, [bp + -1] ; $p
1069   09D6 FD 2A         mov d, [d]
1070   09D8 1E            mov al, [d]
1071   09D9 23            mov ah, al
1072   09DA 07 3F 1C      call _putchar
1073   09DD             ; --- END INLINE ASM SEGMENT
1074   09DD             
1075   09DD             ; p = p + 1; 
1076   09DD FA FF FF      lea d, [bp + -1] ; $p
1077   09E0 DA            push d
1078   09E1 FA FF FF      lea d, [bp + -1] ; $p
1079   09E4 2A            mov b, [d]
1080   09E5             ; --- START TERMS
1081   09E5 D7            push a
1082   09E6 11            mov a, b
1083   09E7 26 01 00      mov b, $1
1084   09EA 56            add b, a
1085   09EB E4            pop a
1086   09EC             ; --- END TERMS
1087   09EC E7            pop d
1088   09ED FD 43         mov [d], b
1089   09EF             ; break; 
1090   09EF 0A 1D 0A      jmp _switch13_exit ; case break
1091   09F2             _switch13_case7:
1092   09F2             
1093   09F2             ; --- BEGIN INLINE ASM SEGMENT
1094   09F2 FA FF FF      lea d, [bp + -1] ; $p
1095   09F5 FD 2A         mov d, [d]
1096   09F7 FD 2A         mov d, [d]
1097   09F9 07 89 1D      call _puts
1098   09FC             ; --- END INLINE ASM SEGMENT
1099   09FC             
1100   09FC             ; p = p + 2; 
1101   09FC FA FF FF      lea d, [bp + -1] ; $p
1102   09FF DA            push d
1103   0A00 FA FF FF      lea d, [bp + -1] ; $p
1104   0A03 2A            mov b, [d]
1105   0A04             ; --- START TERMS
1106   0A04 D7            push a
1107   0A05 11            mov a, b
1108   0A06 26 02 00      mov b, $2
1109   0A09 56            add b, a
1110   0A0A E4            pop a
1111   0A0B             ; --- END TERMS
1112   0A0B E7            pop d
1113   0A0C FD 43         mov [d], b
1114   0A0E             ; break; 
1115   0A0E 0A 1D 0A      jmp _switch13_exit ; case break
1116   0A11             _switch13_default:
1117   0A11             ; print("Error: Unknown argument type.\n"); 
1118   0A11 26 50 20      mov b, _s5 ; "Error: Unknown argument type.\n"
1119   0A14 FD AB         swp b
1120   0A16 D8            push b
1121   0A17 07 F6 1A      call print
1122   0A1A 51 02 00      add sp, 2
1123   0A1D             _switch13_exit:
1124   0A1D             ; format_p++; 
1125   0A1D FA FD FF      lea d, [bp + -3] ; $format_p
1126   0A20 2A            mov b, [d]
1127   0A21 FD 77         inc b
1128   0A23 FA FD FF      lea d, [bp + -3] ; $format_p
1129   0A26 FD 43         mov [d], b
1130   0A28 FD 7D         dec b
1131   0A2A 0A 49 0A      jmp _if12_exit
1132   0A2D             _if12_else:
1133   0A2D             ; putchar(*format_p); 
1134   0A2D FA FD FF      lea d, [bp + -3] ; $format_p
1135   0A30 2A            mov b, [d]
1136   0A31 74            mov d, b
1137   0A32 32            mov bl, [d]
1138   0A33 A7 00         mov bh, 0
1139   0A35 DD            push bl
1140   0A36 07 AE 1A      call putchar
1141   0A39 51 01 00      add sp, 1
1142   0A3C             ; format_p++; 
1143   0A3C FA FD FF      lea d, [bp + -3] ; $format_p
1144   0A3F 2A            mov b, [d]
1145   0A40 FD 77         inc b
1146   0A42 FA FD FF      lea d, [bp + -3] ; $format_p
1147   0A45 FD 43         mov [d], b
1148   0A47 FD 7D         dec b
1149   0A49             _if12_exit:
1150   0A49             _if11_exit:
1151   0A49             _for10_update:
1152   0A49 0A 0C 08      jmp _for10_cond
1153   0A4C             _for10_exit:
1154   0A4C F9            leave
1155   0A4D 09            ret
1156   0A4E             
1157   0A4E             scanf:
1158   0A4E F8 00 00      enter 0 ; (push bp; mov bp, sp)
1159   0A51             ; char *p, *format_p; 
1160   0A51 52 02 00      sub sp, 2
1161   0A54 52 02 00      sub sp, 2
1162   0A57             ; char c; 
1163   0A57 52 01 00      sub sp, 1
1164   0A5A             ; int i; 
1165   0A5A 52 02 00      sub sp, 2
1166   0A5D             ; char input_string[  512                    ]; 
1167   0A5D 52 00 02      sub sp, 512
1168   0A60             ; format_p = format; 
1169   0A60 FA FD FF      lea d, [bp + -3] ; $format_p
1170   0A63 DA            push d
1171   0A64 FA 05 00      lea d, [bp + 5] ; $format
1172   0A67 2A            mov b, [d]
1173   0A68 E7            pop d
1174   0A69 FD 43         mov [d], b
1175   0A6B             ; p = &format + 2; 
1176   0A6B FA FF FF      lea d, [bp + -1] ; $p
1177   0A6E DA            push d
1178   0A6F FA 05 00      lea d, [bp + 5] ; $format
1179   0A72 2D            mov b, d
1180   0A73             ; --- START TERMS
1181   0A73 D7            push a
1182   0A74 11            mov a, b
1183   0A75 26 02 00      mov b, $2
1184   0A78 56            add b, a
1185   0A79 E4            pop a
1186   0A7A             ; --- END TERMS
1187   0A7A E7            pop d
1188   0A7B FD 43         mov [d], b
1189   0A7D             ; for(;;){ 
1190   0A7D             _for17_init:
1191   0A7D             _for17_cond:
1192   0A7D             _for17_block:
1193   0A7D             ; if(!*format_p) break; 
1194   0A7D             _if18_cond:
1195   0A7D FA FD FF      lea d, [bp + -3] ; $format_p
1196   0A80 2A            mov b, [d]
1197   0A81 74            mov d, b
1198   0A82 32            mov bl, [d]
1199   0A83 A7 00         mov bh, 0
1200   0A85 C0 00 00      cmp b, 0
1201   0A88 FD 71         seq ; !
1202   0A8A C0 00 00      cmp b, 0
1203   0A8D C6 96 0A      je _if18_else
1204   0A90             _if18_true:
1205   0A90             ; break; 
1206   0A90 0A 97 0C      jmp _for17_exit ; for break
1207   0A93 0A 94 0C      jmp _if18_exit
1208   0A96             _if18_else:
1209   0A96             ; if(*format_p == '%'){ 
1210   0A96             _if19_cond:
1211   0A96 FA FD FF      lea d, [bp + -3] ; $format_p
1212   0A99 2A            mov b, [d]
1213   0A9A 74            mov d, b
1214   0A9B 32            mov bl, [d]
1215   0A9C A7 00         mov bh, 0
1216   0A9E             ; --- START RELATIONAL
1217   0A9E D7            push a
1218   0A9F 11            mov a, b
1219   0AA0 26 25 00      mov b, $25
1220   0AA3 B0            cmp a, b
1221   0AA4 FD 71         seq ; ==
1222   0AA6 E4            pop a
1223   0AA7             ; --- END RELATIONAL
1224   0AA7 C0 00 00      cmp b, 0
1225   0AAA C6 78 0C      je _if19_else
1226   0AAD             _if19_true:
1227   0AAD             ; format_p++; 
1228   0AAD FA FD FF      lea d, [bp + -3] ; $format_p
1229   0AB0 2A            mov b, [d]
1230   0AB1 FD 77         inc b
1231   0AB3 FA FD FF      lea d, [bp + -3] ; $format_p
1232   0AB6 FD 43         mov [d], b
1233   0AB8 FD 7D         dec b
1234   0ABA             ; switch(*format_p){ 
1235   0ABA             _switch20_expr:
1236   0ABA FA FD FF      lea d, [bp + -3] ; $format_p
1237   0ABD 2A            mov b, [d]
1238   0ABE 74            mov d, b
1239   0ABF 32            mov bl, [d]
1240   0AC0 A7 00         mov bh, 0
1241   0AC2             _switch20_comparisons:
1242   0AC2 C1 6C         cmp bl, $6c
1243   0AC4 C6 F0 0A      je _switch20_case0
1244   0AC7 C1 4C         cmp bl, $4c
1245   0AC9 C6 F0 0A      je _switch20_case1
1246   0ACC C1 64         cmp bl, $64
1247   0ACE C6 82 0B      je _switch20_case2
1248   0AD1 C1 69         cmp bl, $69
1249   0AD3 C6 82 0B      je _switch20_case3
1250   0AD6 C1 75         cmp bl, $75
1251   0AD8 C6 AF 0B      je _switch20_case4
1252   0ADB C1 78         cmp bl, $78
1253   0ADD C6 DC 0B      je _switch20_case5
1254   0AE0 C1 63         cmp bl, $63
1255   0AE2 C6 F1 0B      je _switch20_case6
1256   0AE5 C1 73         cmp bl, $73
1257   0AE7 C6 24 0C      je _switch20_case7
1258   0AEA 0A 5C 0C      jmp _switch20_default
1259   0AED 0A 68 0C      jmp _switch20_exit
1260   0AF0             _switch20_case0:
1261   0AF0             _switch20_case1:
1262   0AF0             ; format_p++; 
1263   0AF0 FA FD FF      lea d, [bp + -3] ; $format_p
1264   0AF3 2A            mov b, [d]
1265   0AF4 FD 77         inc b
1266   0AF6 FA FD FF      lea d, [bp + -3] ; $format_p
1267   0AF9 FD 43         mov [d], b
1268   0AFB FD 7D         dec b
1269   0AFD             ; if(*format_p == 'd' || *format_p == 'i'); 
1270   0AFD             _if21_cond:
1271   0AFD FA FD FF      lea d, [bp + -3] ; $format_p
1272   0B00 2A            mov b, [d]
1273   0B01 74            mov d, b
1274   0B02 32            mov bl, [d]
1275   0B03 A7 00         mov bh, 0
1276   0B05             ; --- START RELATIONAL
1277   0B05 D7            push a
1278   0B06 11            mov a, b
1279   0B07 26 64 00      mov b, $64
1280   0B0A B0            cmp a, b
1281   0B0B FD 71         seq ; ==
1282   0B0D E4            pop a
1283   0B0E             ; --- END RELATIONAL
1284   0B0E             ; --- START LOGICAL OR
1285   0B0E D7            push a
1286   0B0F 11            mov a, b
1287   0B10 FA FD FF      lea d, [bp + -3] ; $format_p
1288   0B13 2A            mov b, [d]
1289   0B14 74            mov d, b
1290   0B15 32            mov bl, [d]
1291   0B16 A7 00         mov bh, 0
1292   0B18             ; --- START RELATIONAL
1293   0B18 D7            push a
1294   0B19 11            mov a, b
1295   0B1A 26 69 00      mov b, $69
1296   0B1D B0            cmp a, b
1297   0B1E FD 71         seq ; ==
1298   0B20 E4            pop a
1299   0B21             ; --- END RELATIONAL
1300   0B21 FD A8         sor a, b ; ||
1301   0B23 E4            pop a
1302   0B24             ; --- END LOGICAL OR
1303   0B24 C0 00 00      cmp b, 0
1304   0B27 C6 2D 0B      je _if21_else
1305   0B2A             _if21_true:
1306   0B2A             ; ; 
1307   0B2A 0A 6D 0B      jmp _if21_exit
1308   0B2D             _if21_else:
1309   0B2D             ; if(*format_p == 'u'); 
1310   0B2D             _if22_cond:
1311   0B2D FA FD FF      lea d, [bp + -3] ; $format_p
1312   0B30 2A            mov b, [d]
1313   0B31 74            mov d, b
1314   0B32 32            mov bl, [d]
1315   0B33 A7 00         mov bh, 0
1316   0B35             ; --- START RELATIONAL
1317   0B35 D7            push a
1318   0B36 11            mov a, b
1319   0B37 26 75 00      mov b, $75
1320   0B3A B0            cmp a, b
1321   0B3B FD 71         seq ; ==
1322   0B3D E4            pop a
1323   0B3E             ; --- END RELATIONAL
1324   0B3E C0 00 00      cmp b, 0
1325   0B41 C6 47 0B      je _if22_else
1326   0B44             _if22_true:
1327   0B44             ; ; 
1328   0B44 0A 6D 0B      jmp _if22_exit
1329   0B47             _if22_else:
1330   0B47             ; if(*format_p == 'x'); 
1331   0B47             _if23_cond:
1332   0B47 FA FD FF      lea d, [bp + -3] ; $format_p
1333   0B4A 2A            mov b, [d]
1334   0B4B 74            mov d, b
1335   0B4C 32            mov bl, [d]
1336   0B4D A7 00         mov bh, 0
1337   0B4F             ; --- START RELATIONAL
1338   0B4F D7            push a
1339   0B50 11            mov a, b
1340   0B51 26 78 00      mov b, $78
1341   0B54 B0            cmp a, b
1342   0B55 FD 71         seq ; ==
1343   0B57 E4            pop a
1344   0B58             ; --- END RELATIONAL
1345   0B58 C0 00 00      cmp b, 0
1346   0B5B C6 61 0B      je _if23_else
1347   0B5E             _if23_true:
1348   0B5E             ; ; 
1349   0B5E 0A 6D 0B      jmp _if23_exit
1350   0B61             _if23_else:
1351   0B61             ; err("Unexpected format in printf."); 
1352   0B61 26 33 20      mov b, _s4 ; "Unexpected format in printf."
1353   0B64 FD AB         swp b
1354   0B66 D8            push b
1355   0B67 07 A0 0F      call err
1356   0B6A 51 02 00      add sp, 2
1357   0B6D             _if23_exit:
1358   0B6D             _if22_exit:
1359   0B6D             _if21_exit:
1360   0B6D             ; p = p + 4; 
1361   0B6D FA FF FF      lea d, [bp + -1] ; $p
1362   0B70 DA            push d
1363   0B71 FA FF FF      lea d, [bp + -1] ; $p
1364   0B74 2A            mov b, [d]
1365   0B75             ; --- START TERMS
1366   0B75 D7            push a
1367   0B76 11            mov a, b
1368   0B77 26 04 00      mov b, $4
1369   0B7A 56            add b, a
1370   0B7B E4            pop a
1371   0B7C             ; --- END TERMS
1372   0B7C E7            pop d
1373   0B7D FD 43         mov [d], b
1374   0B7F             ; break; 
1375   0B7F 0A 68 0C      jmp _switch20_exit ; case break
1376   0B82             _switch20_case2:
1377   0B82             _switch20_case3:
1378   0B82             ; i = scann(); 
1379   0B82 FA FA FF      lea d, [bp + -6] ; $i
1380   0B85 DA            push d
1381   0B86 07 D1 1A      call scann
1382   0B89 E7            pop d
1383   0B8A FD 43         mov [d], b
1384   0B8C             ; **(int **)p = i; 
1385   0B8C FA FF FF      lea d, [bp + -1] ; $p
1386   0B8F 2A            mov b, [d]
1387   0B90 74            mov d, b
1388   0B91 2A            mov b, [d]
1389   0B92 D8            push b
1390   0B93 FA FA FF      lea d, [bp + -6] ; $i
1391   0B96 2A            mov b, [d]
1392   0B97 E7            pop d
1393   0B98 FD 43         mov [d], b
1394   0B9A             ; p = p + 2; 
1395   0B9A FA FF FF      lea d, [bp + -1] ; $p
1396   0B9D DA            push d
1397   0B9E FA FF FF      lea d, [bp + -1] ; $p
1398   0BA1 2A            mov b, [d]
1399   0BA2             ; --- START TERMS
1400   0BA2 D7            push a
1401   0BA3 11            mov a, b
1402   0BA4 26 02 00      mov b, $2
1403   0BA7 56            add b, a
1404   0BA8 E4            pop a
1405   0BA9             ; --- END TERMS
1406   0BA9 E7            pop d
1407   0BAA FD 43         mov [d], b
1408   0BAC             ; break; 
1409   0BAC 0A 68 0C      jmp _switch20_exit ; case break
1410   0BAF             _switch20_case4:
1411   0BAF             ; i = scann(); 
1412   0BAF FA FA FF      lea d, [bp + -6] ; $i
1413   0BB2 DA            push d
1414   0BB3 07 D1 1A      call scann
1415   0BB6 E7            pop d
1416   0BB7 FD 43         mov [d], b
1417   0BB9             ; **(int **)p = i; 
1418   0BB9 FA FF FF      lea d, [bp + -1] ; $p
1419   0BBC 2A            mov b, [d]
1420   0BBD 74            mov d, b
1421   0BBE 2A            mov b, [d]
1422   0BBF D8            push b
1423   0BC0 FA FA FF      lea d, [bp + -6] ; $i
1424   0BC3 2A            mov b, [d]
1425   0BC4 E7            pop d
1426   0BC5 FD 43         mov [d], b
1427   0BC7             ; p = p + 2; 
1428   0BC7 FA FF FF      lea d, [bp + -1] ; $p
1429   0BCA DA            push d
1430   0BCB FA FF FF      lea d, [bp + -1] ; $p
1431   0BCE 2A            mov b, [d]
1432   0BCF             ; --- START TERMS
1433   0BCF D7            push a
1434   0BD0 11            mov a, b
1435   0BD1 26 02 00      mov b, $2
1436   0BD4 56            add b, a
1437   0BD5 E4            pop a
1438   0BD6             ; --- END TERMS
1439   0BD6 E7            pop d
1440   0BD7 FD 43         mov [d], b
1441   0BD9             ; break; 
1442   0BD9 0A 68 0C      jmp _switch20_exit ; case break
1443   0BDC             _switch20_case5:
1444   0BDC             ; p = p + 2; 
1445   0BDC FA FF FF      lea d, [bp + -1] ; $p
1446   0BDF DA            push d
1447   0BE0 FA FF FF      lea d, [bp + -1] ; $p
1448   0BE3 2A            mov b, [d]
1449   0BE4             ; --- START TERMS
1450   0BE4 D7            push a
1451   0BE5 11            mov a, b
1452   0BE6 26 02 00      mov b, $2
1453   0BE9 56            add b, a
1454   0BEA E4            pop a
1455   0BEB             ; --- END TERMS
1456   0BEB E7            pop d
1457   0BEC FD 43         mov [d], b
1458   0BEE             ; break; 
1459   0BEE 0A 68 0C      jmp _switch20_exit ; case break
1460   0BF1             _switch20_case6:
1461   0BF1             ; c = getchar(); 
1462   0BF1 FA FC FF      lea d, [bp + -4] ; $c
1463   0BF4 DA            push d
1464   0BF5 07 BB 1A      call getchar
1465   0BF8 E7            pop d
1466   0BF9 FD 3E         mov [d], bl
1467   0BFB             ; **(char **)p = *(char *)c; 
1468   0BFB FA FF FF      lea d, [bp + -1] ; $p
1469   0BFE 2A            mov b, [d]
1470   0BFF 74            mov d, b
1471   0C00 2A            mov b, [d]
1472   0C01 D8            push b
1473   0C02 FA FC FF      lea d, [bp + -4] ; $c
1474   0C05 32            mov bl, [d]
1475   0C06 A7 00         mov bh, 0
1476   0C08 74            mov d, b
1477   0C09 32            mov bl, [d]
1478   0C0A A7 00         mov bh, 0
1479   0C0C E7            pop d
1480   0C0D FD 43         mov [d], b
1481   0C0F             ; p = p + 1; 
1482   0C0F FA FF FF      lea d, [bp + -1] ; $p
1483   0C12 DA            push d
1484   0C13 FA FF FF      lea d, [bp + -1] ; $p
1485   0C16 2A            mov b, [d]
1486   0C17             ; --- START TERMS
1487   0C17 D7            push a
1488   0C18 11            mov a, b
1489   0C19 26 01 00      mov b, $1
1490   0C1C 56            add b, a
1491   0C1D E4            pop a
1492   0C1E             ; --- END TERMS
1493   0C1E E7            pop d
1494   0C1F FD 43         mov [d], b
1495   0C21             ; break; 
1496   0C21 0A 68 0C      jmp _switch20_exit ; case break
1497   0C24             _switch20_case7:
1498   0C24             ; gets(input_string); 
1499   0C24 FA FA FD      lea d, [bp + -518] ; $input_string
1500   0C27 2D            mov b, d
1501   0C28 FD AB         swp b
1502   0C2A D8            push b
1503   0C2B 07 2C 11      call gets
1504   0C2E 51 02 00      add sp, 2
1505   0C31             ; strcpy(*(char **)p, input_string); 
1506   0C31 FA FA FD      lea d, [bp + -518] ; $input_string
1507   0C34 2D            mov b, d
1508   0C35 FD AB         swp b
1509   0C37 D8            push b
1510   0C38 FA FF FF      lea d, [bp + -1] ; $p
1511   0C3B 2A            mov b, [d]
1512   0C3C 74            mov d, b
1513   0C3D 2A            mov b, [d]
1514   0C3E FD AB         swp b
1515   0C40 D8            push b
1516   0C41 07 40 04      call strcpy
1517   0C44 51 04 00      add sp, 4
1518   0C47             ; p = p + 2; 
1519   0C47 FA FF FF      lea d, [bp + -1] ; $p
1520   0C4A DA            push d
1521   0C4B FA FF FF      lea d, [bp + -1] ; $p
1522   0C4E 2A            mov b, [d]
1523   0C4F             ; --- START TERMS
1524   0C4F D7            push a
1525   0C50 11            mov a, b
1526   0C51 26 02 00      mov b, $2
1527   0C54 56            add b, a
1528   0C55 E4            pop a
1529   0C56             ; --- END TERMS
1530   0C56 E7            pop d
1531   0C57 FD 43         mov [d], b
1532   0C59             ; break; 
1533   0C59 0A 68 0C      jmp _switch20_exit ; case break
1534   0C5C             _switch20_default:
1535   0C5C             ; print("Error: Unknown argument type.\n"); 
1536   0C5C 26 50 20      mov b, _s5 ; "Error: Unknown argument type.\n"
1537   0C5F FD AB         swp b
1538   0C61 D8            push b
1539   0C62 07 F6 1A      call print
1540   0C65 51 02 00      add sp, 2
1541   0C68             _switch20_exit:
1542   0C68             ; format_p++; 
1543   0C68 FA FD FF      lea d, [bp + -3] ; $format_p
1544   0C6B 2A            mov b, [d]
1545   0C6C FD 77         inc b
1546   0C6E FA FD FF      lea d, [bp + -3] ; $format_p
1547   0C71 FD 43         mov [d], b
1548   0C73 FD 7D         dec b
1549   0C75 0A 94 0C      jmp _if19_exit
1550   0C78             _if19_else:
1551   0C78             ; putchar(*format_p); 
1552   0C78 FA FD FF      lea d, [bp + -3] ; $format_p
1553   0C7B 2A            mov b, [d]
1554   0C7C 74            mov d, b
1555   0C7D 32            mov bl, [d]
1556   0C7E A7 00         mov bh, 0
1557   0C80 DD            push bl
1558   0C81 07 AE 1A      call putchar
1559   0C84 51 01 00      add sp, 1
1560   0C87             ; format_p++; 
1561   0C87 FA FD FF      lea d, [bp + -3] ; $format_p
1562   0C8A 2A            mov b, [d]
1563   0C8B FD 77         inc b
1564   0C8D FA FD FF      lea d, [bp + -3] ; $format_p
1565   0C90 FD 43         mov [d], b
1566   0C92 FD 7D         dec b
1567   0C94             _if19_exit:
1568   0C94             _if18_exit:
1569   0C94             _for17_update:
1570   0C94 0A 7D 0A      jmp _for17_cond
1571   0C97             _for17_exit:
1572   0C97 F9            leave
1573   0C98 09            ret
1574   0C99             
1575   0C99             sprintf:
1576   0C99 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1577   0C9C             ; char *p, *format_p; 
1578   0C9C 52 02 00      sub sp, 2
1579   0C9F 52 02 00      sub sp, 2
1580   0CA2             ; char *sp; 
1581   0CA2 52 02 00      sub sp, 2
1582   0CA5             ; sp = dest; 
1583   0CA5 FA FB FF      lea d, [bp + -5] ; $sp
1584   0CA8 DA            push d
1585   0CA9 FA 05 00      lea d, [bp + 5] ; $dest
1586   0CAC 2A            mov b, [d]
1587   0CAD E7            pop d
1588   0CAE FD 43         mov [d], b
1589   0CB0             ; format_p = format; 
1590   0CB0 FA FD FF      lea d, [bp + -3] ; $format_p
1591   0CB3 DA            push d
1592   0CB4 FA 07 00      lea d, [bp + 7] ; $format
1593   0CB7 2A            mov b, [d]
1594   0CB8 E7            pop d
1595   0CB9 FD 43         mov [d], b
1596   0CBB             ; p = &format + 2; 
1597   0CBB FA FF FF      lea d, [bp + -1] ; $p
1598   0CBE DA            push d
1599   0CBF FA 07 00      lea d, [bp + 7] ; $format
1600   0CC2 2D            mov b, d
1601   0CC3             ; --- START TERMS
1602   0CC3 D7            push a
1603   0CC4 11            mov a, b
1604   0CC5 26 02 00      mov b, $2
1605   0CC8 56            add b, a
1606   0CC9 E4            pop a
1607   0CCA             ; --- END TERMS
1608   0CCA E7            pop d
1609   0CCB FD 43         mov [d], b
1610   0CCD             ; for(;;){ 
1611   0CCD             _for24_init:
1612   0CCD             _for24_cond:
1613   0CCD             _for24_block:
1614   0CCD             ; if(!*format_p) break; 
1615   0CCD             _if25_cond:
1616   0CCD FA FD FF      lea d, [bp + -3] ; $format_p
1617   0CD0 2A            mov b, [d]
1618   0CD1 74            mov d, b
1619   0CD2 32            mov bl, [d]
1620   0CD3 A7 00         mov bh, 0
1621   0CD5 C0 00 00      cmp b, 0
1622   0CD8 FD 71         seq ; !
1623   0CDA C0 00 00      cmp b, 0
1624   0CDD C6 E6 0C      je _if25_else
1625   0CE0             _if25_true:
1626   0CE0             ; break; 
1627   0CE0 0A 86 0F      jmp _for24_exit ; for break
1628   0CE3 0A 83 0F      jmp _if25_exit
1629   0CE6             _if25_else:
1630   0CE6             ; if(*format_p == '%'){ 
1631   0CE6             _if26_cond:
1632   0CE6 FA FD FF      lea d, [bp + -3] ; $format_p
1633   0CE9 2A            mov b, [d]
1634   0CEA 74            mov d, b
1635   0CEB 32            mov bl, [d]
1636   0CEC A7 00         mov bh, 0
1637   0CEE             ; --- START RELATIONAL
1638   0CEE D7            push a
1639   0CEF 11            mov a, b
1640   0CF0 26 25 00      mov b, $25
1641   0CF3 B0            cmp a, b
1642   0CF4 FD 71         seq ; ==
1643   0CF6 E4            pop a
1644   0CF7             ; --- END RELATIONAL
1645   0CF7 C0 00 00      cmp b, 0
1646   0CFA C6 61 0F      je _if26_else
1647   0CFD             _if26_true:
1648   0CFD             ; format_p++; 
1649   0CFD FA FD FF      lea d, [bp + -3] ; $format_p
1650   0D00 2A            mov b, [d]
1651   0D01 FD 77         inc b
1652   0D03 FA FD FF      lea d, [bp + -3] ; $format_p
1653   0D06 FD 43         mov [d], b
1654   0D08 FD 7D         dec b
1655   0D0A             ; switch(*format_p){ 
1656   0D0A             _switch27_expr:
1657   0D0A FA FD FF      lea d, [bp + -3] ; $format_p
1658   0D0D 2A            mov b, [d]
1659   0D0E 74            mov d, b
1660   0D0F 32            mov bl, [d]
1661   0D10 A7 00         mov bh, 0
1662   0D12             _switch27_comparisons:
1663   0D12 C1 6C         cmp bl, $6c
1664   0D14 C6 40 0D      je _switch27_case0
1665   0D17 C1 4C         cmp bl, $4c
1666   0D19 C6 40 0D      je _switch27_case1
1667   0D1C C1 64         cmp bl, $64
1668   0D1E C6 2E 0E      je _switch27_case2
1669   0D21 C1 69         cmp bl, $69
1670   0D23 C6 2E 0E      je _switch27_case3
1671   0D26 C1 75         cmp bl, $75
1672   0D28 C6 68 0E      je _switch27_case4
1673   0D2B C1 78         cmp bl, $78
1674   0D2D C6 A2 0E      je _switch27_case5
1675   0D30 C1 63         cmp bl, $63
1676   0D32 C6 C0 0E      je _switch27_case6
1677   0D35 C1 73         cmp bl, $73
1678   0D37 C6 EE 0E      je _switch27_case7
1679   0D3A 0A 45 0F      jmp _switch27_default
1680   0D3D 0A 51 0F      jmp _switch27_exit
1681   0D40             _switch27_case0:
1682   0D40             _switch27_case1:
1683   0D40             ; format_p++; 
1684   0D40 FA FD FF      lea d, [bp + -3] ; $format_p
1685   0D43 2A            mov b, [d]
1686   0D44 FD 77         inc b
1687   0D46 FA FD FF      lea d, [bp + -3] ; $format_p
1688   0D49 FD 43         mov [d], b
1689   0D4B FD 7D         dec b
1690   0D4D             ; if(*format_p == 'd' || *format_p == 'i') 
1691   0D4D             _if28_cond:
1692   0D4D FA FD FF      lea d, [bp + -3] ; $format_p
1693   0D50 2A            mov b, [d]
1694   0D51 74            mov d, b
1695   0D52 32            mov bl, [d]
1696   0D53 A7 00         mov bh, 0
1697   0D55             ; --- START RELATIONAL
1698   0D55 D7            push a
1699   0D56 11            mov a, b
1700   0D57 26 64 00      mov b, $64
1701   0D5A B0            cmp a, b
1702   0D5B FD 71         seq ; ==
1703   0D5D E4            pop a
1704   0D5E             ; --- END RELATIONAL
1705   0D5E             ; --- START LOGICAL OR
1706   0D5E D7            push a
1707   0D5F 11            mov a, b
1708   0D60 FA FD FF      lea d, [bp + -3] ; $format_p
1709   0D63 2A            mov b, [d]
1710   0D64 74            mov d, b
1711   0D65 32            mov bl, [d]
1712   0D66 A7 00         mov bh, 0
1713   0D68             ; --- START RELATIONAL
1714   0D68 D7            push a
1715   0D69 11            mov a, b
1716   0D6A 26 69 00      mov b, $69
1717   0D6D B0            cmp a, b
1718   0D6E FD 71         seq ; ==
1719   0D70 E4            pop a
1720   0D71             ; --- END RELATIONAL
1721   0D71 FD A8         sor a, b ; ||
1722   0D73 E4            pop a
1723   0D74             ; --- END LOGICAL OR
1724   0D74 C0 00 00      cmp b, 0
1725   0D77 C6 9C 0D      je _if28_else
1726   0D7A             _if28_true:
1727   0D7A             ; print_signed_long(*(long *)p); 
1728   0D7A FA FF FF      lea d, [bp + -1] ; $p
1729   0D7D 2A            mov b, [d]
1730   0D7E AB            snex b
1731   0D7F FD 39         mov c, b
1732   0D81 74            mov d, b
1733   0D82 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1734   0D85 FD 39         mov c, b ; And place it into C
1735   0D87 2A            mov b, [d] ; Lower Word in B
1736   0D88 FD 79         mov g, b
1737   0D8A 28            mov b, c
1738   0D8B FD AB         swp b
1739   0D8D D8            push b
1740   0D8E FD 27         mov b, g
1741   0D90 FD AB         swp b
1742   0D92 D8            push b
1743   0D93 07 3D 12      call print_signed_long
1744   0D96 51 04 00      add sp, 4
1745   0D99 0A 19 0E      jmp _if28_exit
1746   0D9C             _if28_else:
1747   0D9C             ; if(*format_p == 'u') 
1748   0D9C             _if29_cond:
1749   0D9C FA FD FF      lea d, [bp + -3] ; $format_p
1750   0D9F 2A            mov b, [d]
1751   0DA0 74            mov d, b
1752   0DA1 32            mov bl, [d]
1753   0DA2 A7 00         mov bh, 0
1754   0DA4             ; --- START RELATIONAL
1755   0DA4 D7            push a
1756   0DA5 11            mov a, b
1757   0DA6 26 75 00      mov b, $75
1758   0DA9 B0            cmp a, b
1759   0DAA FD 71         seq ; ==
1760   0DAC E4            pop a
1761   0DAD             ; --- END RELATIONAL
1762   0DAD C0 00 00      cmp b, 0
1763   0DB0 C6 D7 0D      je _if29_else
1764   0DB3             _if29_true:
1765   0DB3             ; print_unsigned_long(*(unsigned long *)p); 
1766   0DB3 FA FF FF      lea d, [bp + -1] ; $p
1767   0DB6 2A            mov b, [d]
1768   0DB7 A7 00         mov bh, 0
1769   0DB9 38 00 00      mov c, 0
1770   0DBC 74            mov d, b
1771   0DBD 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1772   0DC0 FD 39         mov c, b ; And place it into C
1773   0DC2 2A            mov b, [d] ; Lower Word in B
1774   0DC3 FD 79         mov g, b
1775   0DC5 28            mov b, c
1776   0DC6 FD AB         swp b
1777   0DC8 D8            push b
1778   0DC9 FD 27         mov b, g
1779   0DCB FD AB         swp b
1780   0DCD D8            push b
1781   0DCE 07 7D 15      call print_unsigned_long
1782   0DD1 51 04 00      add sp, 4
1783   0DD4 0A 19 0E      jmp _if29_exit
1784   0DD7             _if29_else:
1785   0DD7             ; if(*format_p == 'x') 
1786   0DD7             _if30_cond:
1787   0DD7 FA FD FF      lea d, [bp + -3] ; $format_p
1788   0DDA 2A            mov b, [d]
1789   0DDB 74            mov d, b
1790   0DDC 32            mov bl, [d]
1791   0DDD A7 00         mov bh, 0
1792   0DDF             ; --- START RELATIONAL
1793   0DDF D7            push a
1794   0DE0 11            mov a, b
1795   0DE1 26 78 00      mov b, $78
1796   0DE4 B0            cmp a, b
1797   0DE5 FD 71         seq ; ==
1798   0DE7 E4            pop a
1799   0DE8             ; --- END RELATIONAL
1800   0DE8 C0 00 00      cmp b, 0
1801   0DEB C6 0D 0E      je _if30_else
1802   0DEE             _if30_true:
1803   0DEE             ; printx32(*(long int *)p); 
1804   0DEE FA FF FF      lea d, [bp + -1] ; $p
1805   0DF1 2A            mov b, [d]
1806   0DF2 74            mov d, b
1807   0DF3 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1808   0DF6 FD 39         mov c, b ; And place it into C
1809   0DF8 2A            mov b, [d] ; Lower Word in B
1810   0DF9 FD 79         mov g, b
1811   0DFB 28            mov b, c
1812   0DFC FD AB         swp b
1813   0DFE D8            push b
1814   0DFF FD 27         mov b, g
1815   0E01 FD AB         swp b
1816   0E03 D8            push b
1817   0E04 07 B2 0F      call printx32
1818   0E07 51 04 00      add sp, 4
1819   0E0A 0A 19 0E      jmp _if30_exit
1820   0E0D             _if30_else:
1821   0E0D             ; err("Unexpected format in printf."); 
1822   0E0D 26 33 20      mov b, _s4 ; "Unexpected format in printf."
1823   0E10 FD AB         swp b
1824   0E12 D8            push b
1825   0E13 07 A0 0F      call err
1826   0E16 51 02 00      add sp, 2
1827   0E19             _if30_exit:
1828   0E19             _if29_exit:
1829   0E19             _if28_exit:
1830   0E19             ; p = p + 4; 
1831   0E19 FA FF FF      lea d, [bp + -1] ; $p
1832   0E1C DA            push d
1833   0E1D FA FF FF      lea d, [bp + -1] ; $p
1834   0E20 2A            mov b, [d]
1835   0E21             ; --- START TERMS
1836   0E21 D7            push a
1837   0E22 11            mov a, b
1838   0E23 26 04 00      mov b, $4
1839   0E26 56            add b, a
1840   0E27 E4            pop a
1841   0E28             ; --- END TERMS
1842   0E28 E7            pop d
1843   0E29 FD 43         mov [d], b
1844   0E2B             ; break; 
1845   0E2B 0A 51 0F      jmp _switch27_exit ; case break
1846   0E2E             _switch27_case2:
1847   0E2E             _switch27_case3:
1848   0E2E             ; sp = sp + sprint_signed(sp, *(int*)p); 
1849   0E2E FA FB FF      lea d, [bp + -5] ; $sp
1850   0E31 DA            push d
1851   0E32 FA FB FF      lea d, [bp + -5] ; $sp
1852   0E35 2A            mov b, [d]
1853   0E36             ; --- START TERMS
1854   0E36 D7            push a
1855   0E37 11            mov a, b
1856   0E38 FA FF FF      lea d, [bp + -1] ; $p
1857   0E3B 2A            mov b, [d]
1858   0E3C 74            mov d, b
1859   0E3D 2A            mov b, [d]
1860   0E3E FD AB         swp b
1861   0E40 D8            push b
1862   0E41 FA FB FF      lea d, [bp + -5] ; $sp
1863   0E44 2A            mov b, [d]
1864   0E45 FD AB         swp b
1865   0E47 D8            push b
1866   0E48 07 4C 19      call sprint_signed
1867   0E4B 51 04 00      add sp, 4
1868   0E4E 56            add b, a
1869   0E4F E4            pop a
1870   0E50             ; --- END TERMS
1871   0E50 E7            pop d
1872   0E51 FD 43         mov [d], b
1873   0E53             ; p = p + 2; 
1874   0E53 FA FF FF      lea d, [bp + -1] ; $p
1875   0E56 DA            push d
1876   0E57 FA FF FF      lea d, [bp + -1] ; $p
1877   0E5A 2A            mov b, [d]
1878   0E5B             ; --- START TERMS
1879   0E5B D7            push a
1880   0E5C 11            mov a, b
1881   0E5D 26 02 00      mov b, $2
1882   0E60 56            add b, a
1883   0E61 E4            pop a
1884   0E62             ; --- END TERMS
1885   0E62 E7            pop d
1886   0E63 FD 43         mov [d], b
1887   0E65             ; break; 
1888   0E65 0A 51 0F      jmp _switch27_exit ; case break
1889   0E68             _switch27_case4:
1890   0E68             ; sp = sp + sprint_unsigned(sp, *(unsigned int*)p); 
1891   0E68 FA FB FF      lea d, [bp + -5] ; $sp
1892   0E6B DA            push d
1893   0E6C FA FB FF      lea d, [bp + -5] ; $sp
1894   0E6F 2A            mov b, [d]
1895   0E70             ; --- START TERMS
1896   0E70 D7            push a
1897   0E71 11            mov a, b
1898   0E72 FA FF FF      lea d, [bp + -1] ; $p
1899   0E75 2A            mov b, [d]
1900   0E76 74            mov d, b
1901   0E77 2A            mov b, [d]
1902   0E78 FD AB         swp b
1903   0E7A D8            push b
1904   0E7B FA FB FF      lea d, [bp + -5] ; $sp
1905   0E7E 2A            mov b, [d]
1906   0E7F FD AB         swp b
1907   0E81 D8            push b
1908   0E82 07 78 17      call sprint_unsigned
1909   0E85 51 04 00      add sp, 4
1910   0E88 56            add b, a
1911   0E89 E4            pop a
1912   0E8A             ; --- END TERMS
1913   0E8A E7            pop d
1914   0E8B FD 43         mov [d], b
1915   0E8D             ; p = p + 2; 
1916   0E8D FA FF FF      lea d, [bp + -1] ; $p
1917   0E90 DA            push d
1918   0E91 FA FF FF      lea d, [bp + -1] ; $p
1919   0E94 2A            mov b, [d]
1920   0E95             ; --- START TERMS
1921   0E95 D7            push a
1922   0E96 11            mov a, b
1923   0E97 26 02 00      mov b, $2
1924   0E9A 56            add b, a
1925   0E9B E4            pop a
1926   0E9C             ; --- END TERMS
1927   0E9C E7            pop d
1928   0E9D FD 43         mov [d], b
1929   0E9F             ; break; 
1930   0E9F 0A 51 0F      jmp _switch27_exit ; case break
1931   0EA2             _switch27_case5:
1932   0EA2             
1933   0EA2             ; --- BEGIN INLINE ASM SEGMENT
1934   0EA2 FA FF FF      lea d, [bp + -1] ; $p
1935   0EA5 FD 2A         mov d, [d]
1936   0EA7 2A            mov b, [d]
1937   0EA8 07 E1 1D      call print_u16x
1938   0EAB             ; --- END INLINE ASM SEGMENT
1939   0EAB             
1940   0EAB             ; p = p + 2; 
1941   0EAB FA FF FF      lea d, [bp + -1] ; $p
1942   0EAE DA            push d
1943   0EAF FA FF FF      lea d, [bp + -1] ; $p
1944   0EB2 2A            mov b, [d]
1945   0EB3             ; --- START TERMS
1946   0EB3 D7            push a
1947   0EB4 11            mov a, b
1948   0EB5 26 02 00      mov b, $2
1949   0EB8 56            add b, a
1950   0EB9 E4            pop a
1951   0EBA             ; --- END TERMS
1952   0EBA E7            pop d
1953   0EBB FD 43         mov [d], b
1954   0EBD             ; break; 
1955   0EBD 0A 51 0F      jmp _switch27_exit ; case break
1956   0EC0             _switch27_case6:
1957   0EC0             ; *sp++ = *(char *)p; 
1958   0EC0 FA FB FF      lea d, [bp + -5] ; $sp
1959   0EC3 2A            mov b, [d]
1960   0EC4 FD 77         inc b
1961   0EC6 FA FB FF      lea d, [bp + -5] ; $sp
1962   0EC9 FD 43         mov [d], b
1963   0ECB FD 7D         dec b
1964   0ECD D8            push b
1965   0ECE FA FF FF      lea d, [bp + -1] ; $p
1966   0ED1 2A            mov b, [d]
1967   0ED2 74            mov d, b
1968   0ED3 32            mov bl, [d]
1969   0ED4 A7 00         mov bh, 0
1970   0ED6 E7            pop d
1971   0ED7 FD 3E         mov [d], bl
1972   0ED9             ; p = p + 1; 
1973   0ED9 FA FF FF      lea d, [bp + -1] ; $p
1974   0EDC DA            push d
1975   0EDD FA FF FF      lea d, [bp + -1] ; $p
1976   0EE0 2A            mov b, [d]
1977   0EE1             ; --- START TERMS
1978   0EE1 D7            push a
1979   0EE2 11            mov a, b
1980   0EE3 26 01 00      mov b, $1
1981   0EE6 56            add b, a
1982   0EE7 E4            pop a
1983   0EE8             ; --- END TERMS
1984   0EE8 E7            pop d
1985   0EE9 FD 43         mov [d], b
1986   0EEB             ; break; 
1987   0EEB 0A 51 0F      jmp _switch27_exit ; case break
1988   0EEE             _switch27_case7:
1989   0EEE             ; int len = strlen(*(char **)p); 
1990   0EEE 52 02 00      sub sp, 2
1991   0EF1             ; --- START LOCAL VAR INITIALIZATION
1992   0EF1 FA F9 FF      lea d, [bp + -7] ; $len
1993   0EF4 DA            push d
1994   0EF5 FA FF FF      lea d, [bp + -1] ; $p
1995   0EF8 2A            mov b, [d]
1996   0EF9 74            mov d, b
1997   0EFA 2A            mov b, [d]
1998   0EFB FD AB         swp b
1999   0EFD D8            push b
2000   0EFE 07 BA 05      call strlen
2001   0F01 51 02 00      add sp, 2
2002   0F04 E7            pop d
2003   0F05 FD 43         mov [d], b
2004   0F07             ; --- END LOCAL VAR INITIALIZATION
2005   0F07             ; strcpy(sp, *(char **)p); 
2006   0F07 FA FF FF      lea d, [bp + -1] ; $p
2007   0F0A 2A            mov b, [d]
2008   0F0B 74            mov d, b
2009   0F0C 2A            mov b, [d]
2010   0F0D FD AB         swp b
2011   0F0F D8            push b
2012   0F10 FA FB FF      lea d, [bp + -5] ; $sp
2013   0F13 2A            mov b, [d]
2014   0F14 FD AB         swp b
2015   0F16 D8            push b
2016   0F17 07 40 04      call strcpy
2017   0F1A 51 04 00      add sp, 4
2018   0F1D             ; sp = sp + len; 
2019   0F1D FA FB FF      lea d, [bp + -5] ; $sp
2020   0F20 DA            push d
2021   0F21 FA FB FF      lea d, [bp + -5] ; $sp
2022   0F24 2A            mov b, [d]
2023   0F25             ; --- START TERMS
2024   0F25 D7            push a
2025   0F26 11            mov a, b
2026   0F27 FA F9 FF      lea d, [bp + -7] ; $len
2027   0F2A 2A            mov b, [d]
2028   0F2B 56            add b, a
2029   0F2C E4            pop a
2030   0F2D             ; --- END TERMS
2031   0F2D E7            pop d
2032   0F2E FD 43         mov [d], b
2033   0F30             ; p = p + 2; 
2034   0F30 FA FF FF      lea d, [bp + -1] ; $p
2035   0F33 DA            push d
2036   0F34 FA FF FF      lea d, [bp + -1] ; $p
2037   0F37 2A            mov b, [d]
2038   0F38             ; --- START TERMS
2039   0F38 D7            push a
2040   0F39 11            mov a, b
2041   0F3A 26 02 00      mov b, $2
2042   0F3D 56            add b, a
2043   0F3E E4            pop a
2044   0F3F             ; --- END TERMS
2045   0F3F E7            pop d
2046   0F40 FD 43         mov [d], b
2047   0F42             ; break; 
2048   0F42 0A 51 0F      jmp _switch27_exit ; case break
2049   0F45             _switch27_default:
2050   0F45             ; print("Error: Unknown argument type.\n"); 
2051   0F45 26 50 20      mov b, _s5 ; "Error: Unknown argument type.\n"
2052   0F48 FD AB         swp b
2053   0F4A D8            push b
2054   0F4B 07 F6 1A      call print
2055   0F4E 51 02 00      add sp, 2
2056   0F51             _switch27_exit:
2057   0F51             ; format_p++; 
2058   0F51 FA FD FF      lea d, [bp + -3] ; $format_p
2059   0F54 2A            mov b, [d]
2060   0F55 FD 77         inc b
2061   0F57 FA FD FF      lea d, [bp + -3] ; $format_p
2062   0F5A FD 43         mov [d], b
2063   0F5C FD 7D         dec b
2064   0F5E 0A 83 0F      jmp _if26_exit
2065   0F61             _if26_else:
2066   0F61             ; *sp++ = *format_p++; 
2067   0F61 FA FB FF      lea d, [bp + -5] ; $sp
2068   0F64 2A            mov b, [d]
2069   0F65 FD 77         inc b
2070   0F67 FA FB FF      lea d, [bp + -5] ; $sp
2071   0F6A FD 43         mov [d], b
2072   0F6C FD 7D         dec b
2073   0F6E D8            push b
2074   0F6F FA FD FF      lea d, [bp + -3] ; $format_p
2075   0F72 2A            mov b, [d]
2076   0F73 FD 77         inc b
2077   0F75 FA FD FF      lea d, [bp + -3] ; $format_p
2078   0F78 FD 43         mov [d], b
2079   0F7A FD 7D         dec b
2080   0F7C 74            mov d, b
2081   0F7D 32            mov bl, [d]
2082   0F7E A7 00         mov bh, 0
2083   0F80 E7            pop d
2084   0F81 FD 3E         mov [d], bl
2085   0F83             _if26_exit:
2086   0F83             _if25_exit:
2087   0F83             _for24_update:
2088   0F83 0A CD 0C      jmp _for24_cond
2089   0F86             _for24_exit:
2090   0F86             ; *sp = '\0'; 
2091   0F86 FA FB FF      lea d, [bp + -5] ; $sp
2092   0F89 2A            mov b, [d]
2093   0F8A D8            push b
2094   0F8B 26 00 00      mov b, $0
2095   0F8E E7            pop d
2096   0F8F FD 3E         mov [d], bl
2097   0F91             ; return sp - dest; // return total number of chars written 
2098   0F91 FA FB FF      lea d, [bp + -5] ; $sp
2099   0F94 2A            mov b, [d]
2100   0F95             ; --- START TERMS
2101   0F95 D7            push a
2102   0F96 11            mov a, b
2103   0F97 FA 05 00      lea d, [bp + 5] ; $dest
2104   0F9A 2A            mov b, [d]
2105   0F9B 60            sub a, b
2106   0F9C 27            mov b, a
2107   0F9D E4            pop a
2108   0F9E             ; --- END TERMS
2109   0F9E F9            leave
2110   0F9F 09            ret
2111   0FA0             
2112   0FA0             err:
2113   0FA0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2114   0FA3             ; print(e); 
2115   0FA3 FA 05 00      lea d, [bp + 5] ; $e
2116   0FA6 2A            mov b, [d]
2117   0FA7 FD AB         swp b
2118   0FA9 D8            push b
2119   0FAA 07 F6 1A      call print
2120   0FAD 51 02 00      add sp, 2
2121   0FB0 F9            leave
2122   0FB1 09            ret
2123   0FB2             
2124   0FB2             printx32:
2125   0FB2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2126   0FB5             
2127   0FB5             ; --- BEGIN INLINE ASM SEGMENT
2128   0FB5 FA 05 00      lea d, [bp + 5] ; $hex
2129   0FB8 2B 02 00      mov b, [d+2]
2130   0FBB 07 E1 1D      call print_u16x
2131   0FBE 2A            mov b, [d]
2132   0FBF 07 E1 1D      call print_u16x
2133   0FC2             ; --- END INLINE ASM SEGMENT
2134   0FC2             
2135   0FC2 F9            leave
2136   0FC3 09            ret
2137   0FC4             
2138   0FC4             printx16:
2139   0FC4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2140   0FC7             
2141   0FC7             ; --- BEGIN INLINE ASM SEGMENT
2142   0FC7 FA 05 00      lea d, [bp + 5] ; $hex
2143   0FCA 2A            mov b, [d]
2144   0FCB 07 E1 1D      call print_u16x
2145   0FCE             ; --- END INLINE ASM SEGMENT
2146   0FCE             
2147   0FCE F9            leave
2148   0FCF 09            ret
2149   0FD0             
2150   0FD0             printx8:
2151   0FD0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2152   0FD3             
2153   0FD3             ; --- BEGIN INLINE ASM SEGMENT
2154   0FD3 FA 05 00      lea d, [bp + 5] ; $hex
2155   0FD6 32            mov bl, [d]
2156   0FD7 07 25 1E      call print_u8x
2157   0FDA             ; --- END INLINE ASM SEGMENT
2158   0FDA             
2159   0FDA F9            leave
2160   0FDB 09            ret
2161   0FDC             
2162   0FDC             hex_str_to_int:
2163   0FDC F8 00 00      enter 0 ; (push bp; mov bp, sp)
2164   0FDF             ; int value = 0; 
2165   0FDF 52 02 00      sub sp, 2
2166   0FE2             ; --- START LOCAL VAR INITIALIZATION
2167   0FE2 FA FF FF      lea d, [bp + -1] ; $value
2168   0FE5 DA            push d
2169   0FE6 26 00 00      mov b, $0
2170   0FE9 E7            pop d
2171   0FEA FD 43         mov [d], b
2172   0FEC             ; --- END LOCAL VAR INITIALIZATION
2173   0FEC             ; int i; 
2174   0FEC 52 02 00      sub sp, 2
2175   0FEF             ; char hex_char; 
2176   0FEF 52 01 00      sub sp, 1
2177   0FF2             ; int len; 
2178   0FF2 52 02 00      sub sp, 2
2179   0FF5             ; len = strlen(hex_string); 
2180   0FF5 FA FA FF      lea d, [bp + -6] ; $len
2181   0FF8 DA            push d
2182   0FF9 FA 05 00      lea d, [bp + 5] ; $hex_string
2183   0FFC 2A            mov b, [d]
2184   0FFD FD AB         swp b
2185   0FFF D8            push b
2186   1000 07 BA 05      call strlen
2187   1003 51 02 00      add sp, 2
2188   1006 E7            pop d
2189   1007 FD 43         mov [d], b
2190   1009             ; for (i = 0; i < len; i++) { 
2191   1009             _for31_init:
2192   1009 FA FD FF      lea d, [bp + -3] ; $i
2193   100C DA            push d
2194   100D 26 00 00      mov b, $0
2195   1010 E7            pop d
2196   1011 FD 43         mov [d], b
2197   1013             _for31_cond:
2198   1013 FA FD FF      lea d, [bp + -3] ; $i
2199   1016 2A            mov b, [d]
2200   1017             ; --- START RELATIONAL
2201   1017 D7            push a
2202   1018 11            mov a, b
2203   1019 FA FA FF      lea d, [bp + -6] ; $len
2204   101C 2A            mov b, [d]
2205   101D B0            cmp a, b
2206   101E FD 73         slt ; < (signed)
2207   1020 E4            pop a
2208   1021             ; --- END RELATIONAL
2209   1021 C0 00 00      cmp b, 0
2210   1024 C6 26 11      je _for31_exit
2211   1027             _for31_block:
2212   1027             ; hex_char = hex_string[i]; 
2213   1027 FA FC FF      lea d, [bp + -4] ; $hex_char
2214   102A DA            push d
2215   102B FA 05 00      lea d, [bp + 5] ; $hex_string
2216   102E FD 2A         mov d, [d]
2217   1030 D7            push a
2218   1031 DA            push d
2219   1032 FA FD FF      lea d, [bp + -3] ; $i
2220   1035 2A            mov b, [d]
2221   1036 E7            pop d
2222   1037 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
2223   103B E4            pop a
2224   103C 32            mov bl, [d]
2225   103D A7 00         mov bh, 0
2226   103F E7            pop d
2227   1040 FD 3E         mov [d], bl
2228   1042             ; if (hex_char >= 'a' && hex_char <= 'f')  
2229   1042             _if32_cond:
2230   1042 FA FC FF      lea d, [bp + -4] ; $hex_char
2231   1045 32            mov bl, [d]
2232   1046 A7 00         mov bh, 0
2233   1048             ; --- START RELATIONAL
2234   1048 D7            push a
2235   1049 11            mov a, b
2236   104A 26 61 00      mov b, $61
2237   104D B0            cmp a, b
2238   104E FD 80         sge ; >=
2239   1050 E4            pop a
2240   1051             ; --- END RELATIONAL
2241   1051             ; --- START LOGICAL AND
2242   1051 D7            push a
2243   1052 11            mov a, b
2244   1053 FA FC FF      lea d, [bp + -4] ; $hex_char
2245   1056 32            mov bl, [d]
2246   1057 A7 00         mov bh, 0
2247   1059             ; --- START RELATIONAL
2248   1059 D7            push a
2249   105A 11            mov a, b
2250   105B 26 66 00      mov b, $66
2251   105E B0            cmp a, b
2252   105F FD 74         sle ; <= (signed)
2253   1061 E4            pop a
2254   1062             ; --- END RELATIONAL
2255   1062 FD A7         sand a, b
2256   1064 E4            pop a
2257   1065             ; --- END LOGICAL AND
2258   1065 C0 00 00      cmp b, 0
2259   1068 C6 99 10      je _if32_else
2260   106B             _if32_true:
2261   106B             ; value = (value * 16) + (hex_char - 'a' + 10); 
2262   106B FA FF FF      lea d, [bp + -1] ; $value
2263   106E DA            push d
2264   106F FA FF FF      lea d, [bp + -1] ; $value
2265   1072 2A            mov b, [d]
2266   1073             ; --- START FACTORS
2267   1073 D7            push a
2268   1074 11            mov a, b
2269   1075 26 10 00      mov b, $10
2270   1078 AC            mul a, b ; *
2271   1079 11            mov a, b
2272   107A 27            mov b, a
2273   107B E4            pop a
2274   107C             ; --- END FACTORS
2275   107C             ; --- START TERMS
2276   107C D7            push a
2277   107D 11            mov a, b
2278   107E FA FC FF      lea d, [bp + -4] ; $hex_char
2279   1081 32            mov bl, [d]
2280   1082 A7 00         mov bh, 0
2281   1084             ; --- START TERMS
2282   1084 D7            push a
2283   1085 11            mov a, b
2284   1086 26 61 00      mov b, $61
2285   1089 60            sub a, b
2286   108A 27            mov b, a
2287   108B 11            mov a, b
2288   108C 26 0A 00      mov b, $a
2289   108F 56            add b, a
2290   1090 E4            pop a
2291   1091             ; --- END TERMS
2292   1091 56            add b, a
2293   1092 E4            pop a
2294   1093             ; --- END TERMS
2295   1093 E7            pop d
2296   1094 FD 43         mov [d], b
2297   1096 0A 16 11      jmp _if32_exit
2298   1099             _if32_else:
2299   1099             ; if (hex_char >= 'A' && hex_char <= 'F')  
2300   1099             _if33_cond:
2301   1099 FA FC FF      lea d, [bp + -4] ; $hex_char
2302   109C 32            mov bl, [d]
2303   109D A7 00         mov bh, 0
2304   109F             ; --- START RELATIONAL
2305   109F D7            push a
2306   10A0 11            mov a, b
2307   10A1 26 41 00      mov b, $41
2308   10A4 B0            cmp a, b
2309   10A5 FD 80         sge ; >=
2310   10A7 E4            pop a
2311   10A8             ; --- END RELATIONAL
2312   10A8             ; --- START LOGICAL AND
2313   10A8 D7            push a
2314   10A9 11            mov a, b
2315   10AA FA FC FF      lea d, [bp + -4] ; $hex_char
2316   10AD 32            mov bl, [d]
2317   10AE A7 00         mov bh, 0
2318   10B0             ; --- START RELATIONAL
2319   10B0 D7            push a
2320   10B1 11            mov a, b
2321   10B2 26 46 00      mov b, $46
2322   10B5 B0            cmp a, b
2323   10B6 FD 74         sle ; <= (signed)
2324   10B8 E4            pop a
2325   10B9             ; --- END RELATIONAL
2326   10B9 FD A7         sand a, b
2327   10BB E4            pop a
2328   10BC             ; --- END LOGICAL AND
2329   10BC C0 00 00      cmp b, 0
2330   10BF C6 F0 10      je _if33_else
2331   10C2             _if33_true:
2332   10C2             ; value = (value * 16) + (hex_char - 'A' + 10); 
2333   10C2 FA FF FF      lea d, [bp + -1] ; $value
2334   10C5 DA            push d
2335   10C6 FA FF FF      lea d, [bp + -1] ; $value
2336   10C9 2A            mov b, [d]
2337   10CA             ; --- START FACTORS
2338   10CA D7            push a
2339   10CB 11            mov a, b
2340   10CC 26 10 00      mov b, $10
2341   10CF AC            mul a, b ; *
2342   10D0 11            mov a, b
2343   10D1 27            mov b, a
2344   10D2 E4            pop a
2345   10D3             ; --- END FACTORS
2346   10D3             ; --- START TERMS
2347   10D3 D7            push a
2348   10D4 11            mov a, b
2349   10D5 FA FC FF      lea d, [bp + -4] ; $hex_char
2350   10D8 32            mov bl, [d]
2351   10D9 A7 00         mov bh, 0
2352   10DB             ; --- START TERMS
2353   10DB D7            push a
2354   10DC 11            mov a, b
2355   10DD 26 41 00      mov b, $41
2356   10E0 60            sub a, b
2357   10E1 27            mov b, a
2358   10E2 11            mov a, b
2359   10E3 26 0A 00      mov b, $a
2360   10E6 56            add b, a
2361   10E7 E4            pop a
2362   10E8             ; --- END TERMS
2363   10E8 56            add b, a
2364   10E9 E4            pop a
2365   10EA             ; --- END TERMS
2366   10EA E7            pop d
2367   10EB FD 43         mov [d], b
2368   10ED 0A 16 11      jmp _if33_exit
2369   10F0             _if33_else:
2370   10F0             ; value = (value * 16) + (hex_char - '0'); 
2371   10F0 FA FF FF      lea d, [bp + -1] ; $value
2372   10F3 DA            push d
2373   10F4 FA FF FF      lea d, [bp + -1] ; $value
2374   10F7 2A            mov b, [d]
2375   10F8             ; --- START FACTORS
2376   10F8 D7            push a
2377   10F9 11            mov a, b
2378   10FA 26 10 00      mov b, $10
2379   10FD AC            mul a, b ; *
2380   10FE 11            mov a, b
2381   10FF 27            mov b, a
2382   1100 E4            pop a
2383   1101             ; --- END FACTORS
2384   1101             ; --- START TERMS
2385   1101 D7            push a
2386   1102 11            mov a, b
2387   1103 FA FC FF      lea d, [bp + -4] ; $hex_char
2388   1106 32            mov bl, [d]
2389   1107 A7 00         mov bh, 0
2390   1109             ; --- START TERMS
2391   1109 D7            push a
2392   110A 11            mov a, b
2393   110B 26 30 00      mov b, $30
2394   110E 60            sub a, b
2395   110F 27            mov b, a
2396   1110 E4            pop a
2397   1111             ; --- END TERMS
2398   1111 56            add b, a
2399   1112 E4            pop a
2400   1113             ; --- END TERMS
2401   1113 E7            pop d
2402   1114 FD 43         mov [d], b
2403   1116             _if33_exit:
2404   1116             _if32_exit:
2405   1116             _for31_update:
2406   1116 FA FD FF      lea d, [bp + -3] ; $i
2407   1119 2A            mov b, [d]
2408   111A FD 77         inc b
2409   111C FA FD FF      lea d, [bp + -3] ; $i
2410   111F FD 43         mov [d], b
2411   1121 FD 7D         dec b
2412   1123 0A 13 10      jmp _for31_cond
2413   1126             _for31_exit:
2414   1126             ; return value; 
2415   1126 FA FF FF      lea d, [bp + -1] ; $value
2416   1129 2A            mov b, [d]
2417   112A F9            leave
2418   112B 09            ret
2419   112C             
2420   112C             gets:
2421   112C F8 00 00      enter 0 ; (push bp; mov bp, sp)
2422   112F             
2423   112F             ; --- BEGIN INLINE ASM SEGMENT
2424   112F FA 05 00      lea d, [bp + 5] ; $s
2425   1132 15            mov a, [d]
2426   1133 3C            mov d, a
2427   1134 07 46 1C      call _gets
2428   1137             ; --- END INLINE ASM SEGMENT
2429   1137             
2430   1137             ; return strlen(s); 
2431   1137 FA 05 00      lea d, [bp + 5] ; $s
2432   113A 2A            mov b, [d]
2433   113B FD AB         swp b
2434   113D D8            push b
2435   113E 07 BA 05      call strlen
2436   1141 51 02 00      add sp, 2
2437   1144 F9            leave
2438   1145 09            ret
2439   1146             
2440   1146             print_signed:
2441   1146 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2442   1149             ; char digits[5]; 
2443   1149 52 05 00      sub sp, 5
2444   114C             ; int i = 0; 
2445   114C 52 02 00      sub sp, 2
2446   114F             ; --- START LOCAL VAR INITIALIZATION
2447   114F FA FA FF      lea d, [bp + -6] ; $i
2448   1152 DA            push d
2449   1153 26 00 00      mov b, $0
2450   1156 E7            pop d
2451   1157 FD 43         mov [d], b
2452   1159             ; --- END LOCAL VAR INITIALIZATION
2453   1159             ; if (num < 0) { 
2454   1159             _if34_cond:
2455   1159 FA 05 00      lea d, [bp + 5] ; $num
2456   115C 2A            mov b, [d]
2457   115D             ; --- START RELATIONAL
2458   115D D7            push a
2459   115E 11            mov a, b
2460   115F 26 00 00      mov b, $0
2461   1162 B0            cmp a, b
2462   1163 FD 73         slt ; < (signed)
2463   1165 E4            pop a
2464   1166             ; --- END RELATIONAL
2465   1166 C0 00 00      cmp b, 0
2466   1169 C6 86 11      je _if34_else
2467   116C             _if34_true:
2468   116C             ; putchar('-'); 
2469   116C 26 2D 00      mov b, $2d
2470   116F DD            push bl
2471   1170 07 AE 1A      call putchar
2472   1173 51 01 00      add sp, 1
2473   1176             ; num = -num; 
2474   1176 FA 05 00      lea d, [bp + 5] ; $num
2475   1179 DA            push d
2476   117A FA 05 00      lea d, [bp + 5] ; $num
2477   117D 2A            mov b, [d]
2478   117E FD 97         neg b
2479   1180 E7            pop d
2480   1181 FD 43         mov [d], b
2481   1183 0A A8 11      jmp _if34_exit
2482   1186             _if34_else:
2483   1186             ; if (num == 0) { 
2484   1186             _if35_cond:
2485   1186 FA 05 00      lea d, [bp + 5] ; $num
2486   1189 2A            mov b, [d]
2487   118A             ; --- START RELATIONAL
2488   118A D7            push a
2489   118B 11            mov a, b
2490   118C 26 00 00      mov b, $0
2491   118F B0            cmp a, b
2492   1190 FD 71         seq ; ==
2493   1192 E4            pop a
2494   1193             ; --- END RELATIONAL
2495   1193 C0 00 00      cmp b, 0
2496   1196 C6 A8 11      je _if35_exit
2497   1199             _if35_true:
2498   1199             ; putchar('0'); 
2499   1199 26 30 00      mov b, $30
2500   119C DD            push bl
2501   119D 07 AE 1A      call putchar
2502   11A0 51 01 00      add sp, 1
2503   11A3             ; return; 
2504   11A3 F9            leave
2505   11A4 09            ret
2506   11A5 0A A8 11      jmp _if35_exit
2507   11A8             _if35_exit:
2508   11A8             _if34_exit:
2509   11A8             ; while (num > 0) { 
2510   11A8             _while36_cond:
2511   11A8 FA 05 00      lea d, [bp + 5] ; $num
2512   11AB 2A            mov b, [d]
2513   11AC             ; --- START RELATIONAL
2514   11AC D7            push a
2515   11AD 11            mov a, b
2516   11AE 26 00 00      mov b, $0
2517   11B1 B0            cmp a, b
2518   11B2 FD 7F         sgt ; >
2519   11B4 E4            pop a
2520   11B5             ; --- END RELATIONAL
2521   11B5 C0 00 00      cmp b, 0
2522   11B8 C6 02 12      je _while36_exit
2523   11BB             _while36_block:
2524   11BB             ; digits[i] = '0' + (num % 10); 
2525   11BB FA FC FF      lea d, [bp + -4] ; $digits
2526   11BE D7            push a
2527   11BF DA            push d
2528   11C0 FA FA FF      lea d, [bp + -6] ; $i
2529   11C3 2A            mov b, [d]
2530   11C4 E7            pop d
2531   11C5 5A            add d, b
2532   11C6 E4            pop a
2533   11C7 DA            push d
2534   11C8 26 30 00      mov b, $30
2535   11CB             ; --- START TERMS
2536   11CB D7            push a
2537   11CC 11            mov a, b
2538   11CD FA 05 00      lea d, [bp + 5] ; $num
2539   11D0 2A            mov b, [d]
2540   11D1             ; --- START FACTORS
2541   11D1 D7            push a
2542   11D2 11            mov a, b
2543   11D3 26 0A 00      mov b, $a
2544   11D6 AE            div a, b ; 
2545   11D7 11            mov a, b
2546   11D8 27            mov b, a
2547   11D9 E4            pop a
2548   11DA             ; --- END FACTORS
2549   11DA 56            add b, a
2550   11DB E4            pop a
2551   11DC             ; --- END TERMS
2552   11DC E7            pop d
2553   11DD FD 3E         mov [d], bl
2554   11DF             ; num = num / 10; 
2555   11DF FA 05 00      lea d, [bp + 5] ; $num
2556   11E2 DA            push d
2557   11E3 FA 05 00      lea d, [bp + 5] ; $num
2558   11E6 2A            mov b, [d]
2559   11E7             ; --- START FACTORS
2560   11E7 D7            push a
2561   11E8 11            mov a, b
2562   11E9 26 0A 00      mov b, $a
2563   11EC AE            div a, b
2564   11ED 27            mov b, a
2565   11EE E4            pop a
2566   11EF             ; --- END FACTORS
2567   11EF E7            pop d
2568   11F0 FD 43         mov [d], b
2569   11F2             ; i++; 
2570   11F2 FA FA FF      lea d, [bp + -6] ; $i
2571   11F5 2A            mov b, [d]
2572   11F6 FD 77         inc b
2573   11F8 FA FA FF      lea d, [bp + -6] ; $i
2574   11FB FD 43         mov [d], b
2575   11FD FD 7D         dec b
2576   11FF 0A A8 11      jmp _while36_cond
2577   1202             _while36_exit:
2578   1202             ; while (i > 0) { 
2579   1202             _while37_cond:
2580   1202 FA FA FF      lea d, [bp + -6] ; $i
2581   1205 2A            mov b, [d]
2582   1206             ; --- START RELATIONAL
2583   1206 D7            push a
2584   1207 11            mov a, b
2585   1208 26 00 00      mov b, $0
2586   120B B0            cmp a, b
2587   120C FD 7F         sgt ; >
2588   120E E4            pop a
2589   120F             ; --- END RELATIONAL
2590   120F C0 00 00      cmp b, 0
2591   1212 C6 3B 12      je _while37_exit
2592   1215             _while37_block:
2593   1215             ; i--; 
2594   1215 FA FA FF      lea d, [bp + -6] ; $i
2595   1218 2A            mov b, [d]
2596   1219 FD 7D         dec b
2597   121B FA FA FF      lea d, [bp + -6] ; $i
2598   121E FD 43         mov [d], b
2599   1220 FD 77         inc b
2600   1222             ; putchar(digits[i]); 
2601   1222 FA FC FF      lea d, [bp + -4] ; $digits
2602   1225 D7            push a
2603   1226 DA            push d
2604   1227 FA FA FF      lea d, [bp + -6] ; $i
2605   122A 2A            mov b, [d]
2606   122B E7            pop d
2607   122C 5A            add d, b
2608   122D E4            pop a
2609   122E 32            mov bl, [d]
2610   122F A7 00         mov bh, 0
2611   1231 DD            push bl
2612   1232 07 AE 1A      call putchar
2613   1235 51 01 00      add sp, 1
2614   1238 0A 02 12      jmp _while37_cond
2615   123B             _while37_exit:
2616   123B F9            leave
2617   123C 09            ret
2618   123D             
2619   123D             print_signed_long:
2620   123D F8 00 00      enter 0 ; (push bp; mov bp, sp)
2621   1240             ; char digits[10]; 
2622   1240 52 0A 00      sub sp, 10
2623   1243             ; int i = 0; 
2624   1243 52 02 00      sub sp, 2
2625   1246             ; --- START LOCAL VAR INITIALIZATION
2626   1246 FA F5 FF      lea d, [bp + -11] ; $i
2627   1249 DA            push d
2628   124A 26 00 00      mov b, $0
2629   124D E7            pop d
2630   124E FD 43         mov [d], b
2631   1250             ; --- END LOCAL VAR INITIALIZATION
2632   1250             ; if (num < 0) { 
2633   1250             _if38_cond:
2634   1250 FA 05 00      lea d, [bp + 5] ; $num
2635   1253 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2636   1256 FD 39         mov c, b ; And place it into C
2637   1258 2A            mov b, [d] ; Lower Word in B
2638   1259             ; --- START RELATIONAL
2639   1259 D7            push a
2640   125A FD D8         push g
2641   125C 11            mov a, b
2642   125D FD 7A         mov g, c
2643   125F 26 00 00      mov b, $0
2644   1262 38 00 00      mov c, 0
2645   1265 FD AF 00 00   cmp32 ga, cb
2645   1269 00 00 00 00 
2645   126D 00 00 00 00 
2645   1271 00 00 00 00 
2645   1275 00 00 00 00 
2645   1279 00 00 00 00 
2645   127D 00 00 00 00 
2645   1281 00 00 00 00 
2645   1285 00 00 00 00 
2645   1289 00 00 00 00 
2645   128D 00 00 00 00 
2645   1291 00 00 00 00 
2645   1295 00 00 00 00 
2645   1299 00 00 00 00 
2645   129D 00 00 00 00 
2645   12A1 00 00 00 00 
2645   12A5 00 00 00 00 
2645   12A9 00 00 00 00 
2645   12AD 00 00 00 00 
2645   12B1 00 00 00 00 
2645   12B5 00 00 00 00 
2645   12B9 00 00 00 00 
2645   12BD 00 00 00 00 
2645   12C1 00 00 00 00 
2645   12C5 00 00 00 00 
2645   12C9 00 00 00 00 
2645   12CD 00 00 00 00 
2645   12D1 00 00 00 00 
2645   12D5 00 00 00 00 
2645   12D9 00 00 00 00 
2645   12DD 00 00 00 00 
2645   12E1 00 00 00 00 
2645   12E5 00 00 00 00 
2645   12E9 00 00 00 00 
2645   12ED 00 00 00 00 
2645   12F1 00 00 00 00 
2645   12F5 00 00 00 00 
2645   12F9 00 00 00 00 
2645   12FD 00 00 00 00 
2645   1301 00 00 00 00 
2645   1305 00 00 00 00 
2645   1309 00 00 00 00 
2645   130D 00 00 00 00 
2645   1311 00 00 00 00 
2645   1315 00 00 00 00 
2645   1319 00 00 00 00 
2645   131D 00 00 00 00 
2645   1321 00 00 00 00 
2645   1325 00 00 00 00 
2645   1329 00 00 00 00 
2645   132D 00 00 00 00 
2645   1331 00 00 00 00 
2645   1335 00 00 00 00 
2645   1339 00 00 00 00 
2645   133D 00 00 00 00 
2645   1341 00 00 00 00 
2645   1345 00 00 00 00 
2645   1349 00 00 00 00 
2645   134D 00 00 00 00 
2645   1351 00 00 00 00 
2645   1355 00 00 00 00 
2645   1359 00 00 00 00 
2645   135D 00 00 00 00 
2645   1361 00 00 00 00 
2645   1365 00 
2646   1366 FD 73         slt ; <
2647   1368 FD F1         pop g
2648   136A E4            pop a
2649   136B             ; --- END RELATIONAL
2650   136B C0 00 00      cmp b, 0
2651   136E C6 95 13      je _if38_else
2652   1371             _if38_true:
2653   1371             ; putchar('-'); 
2654   1371 26 2D 00      mov b, $2d
2655   1374 DD            push bl
2656   1375 07 AE 1A      call putchar
2657   1378 51 01 00      add sp, 1
2658   137B             ; num = -num; 
2659   137B FA 05 00      lea d, [bp + 5] ; $num
2660   137E DA            push d
2661   137F FA 05 00      lea d, [bp + 5] ; $num
2662   1382 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2663   1385 FD 39         mov c, b ; And place it into C
2664   1387 2A            mov b, [d] ; Lower Word in B
2665   1388 FD 97         neg b
2666   138A E7            pop d
2667   138B FD 43         mov [d], b
2668   138D 28            mov b, c
2669   138E FD 44 02 00   mov [d + 2], b
2670   1392 0A C5 14      jmp _if38_exit
2671   1395             _if38_else:
2672   1395             ; if (num == 0) { 
2673   1395             _if39_cond:
2674   1395 FA 05 00      lea d, [bp + 5] ; $num
2675   1398 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2676   139B FD 39         mov c, b ; And place it into C
2677   139D 2A            mov b, [d] ; Lower Word in B
2678   139E             ; --- START RELATIONAL
2679   139E D7            push a
2680   139F FD D8         push g
2681   13A1 11            mov a, b
2682   13A2 FD 7A         mov g, c
2683   13A4 26 00 00      mov b, $0
2684   13A7 38 00 00      mov c, 0
2685   13AA FD AF 00 00   cmp32 ga, cb
2685   13AE 00 00 00 00 
2685   13B2 00 00 00 00 
2685   13B6 00 00 00 00 
2685   13BA 00 00 00 00 
2685   13BE 00 00 00 00 
2685   13C2 00 00 00 00 
2685   13C6 00 00 00 00 
2685   13CA 00 00 00 00 
2685   13CE 00 00 00 00 
2685   13D2 00 00 00 00 
2685   13D6 00 00 00 00 
2685   13DA 00 00 00 00 
2685   13DE 00 00 00 00 
2685   13E2 00 00 00 00 
2685   13E6 00 00 00 00 
2685   13EA 00 00 00 00 
2685   13EE 00 00 00 00 
2685   13F2 00 00 00 00 
2685   13F6 00 00 00 00 
2685   13FA 00 00 00 00 
2685   13FE 00 00 00 00 
2685   1402 00 00 00 00 
2685   1406 00 00 00 00 
2685   140A 00 00 00 00 
2685   140E 00 00 00 00 
2685   1412 00 00 00 00 
2685   1416 00 00 00 00 
2685   141A 00 00 00 00 
2685   141E 00 00 00 00 
2685   1422 00 00 00 00 
2685   1426 00 00 00 00 
2685   142A 00 00 00 00 
2685   142E 00 00 00 00 
2685   1432 00 00 00 00 
2685   1436 00 00 00 00 
2685   143A 00 00 00 00 
2685   143E 00 00 00 00 
2685   1442 00 00 00 00 
2685   1446 00 00 00 00 
2685   144A 00 00 00 00 
2685   144E 00 00 00 00 
2685   1452 00 00 00 00 
2685   1456 00 00 00 00 
2685   145A 00 00 00 00 
2685   145E 00 00 00 00 
2685   1462 00 00 00 00 
2685   1466 00 00 00 00 
2685   146A 00 00 00 00 
2685   146E 00 00 00 00 
2685   1472 00 00 00 00 
2685   1476 00 00 00 00 
2685   147A 00 00 00 00 
2685   147E 00 00 00 00 
2685   1482 00 00 00 00 
2685   1486 00 00 00 00 
2685   148A 00 00 00 00 
2685   148E 00 00 00 00 
2685   1492 00 00 00 00 
2685   1496 00 00 00 00 
2685   149A 00 00 00 00 
2685   149E 00 00 00 00 
2685   14A2 00 00 00 00 
2685   14A6 00 00 00 00 
2685   14AA 00 
2686   14AB FD 71         seq ; ==
2687   14AD FD F1         pop g
2688   14AF E4            pop a
2689   14B0             ; --- END RELATIONAL
2690   14B0 C0 00 00      cmp b, 0
2691   14B3 C6 C5 14      je _if39_exit
2692   14B6             _if39_true:
2693   14B6             ; putchar('0'); 
2694   14B6 26 30 00      mov b, $30
2695   14B9 DD            push bl
2696   14BA 07 AE 1A      call putchar
2697   14BD 51 01 00      add sp, 1
2698   14C0             ; return; 
2699   14C0 F9            leave
2700   14C1 09            ret
2701   14C2 0A C5 14      jmp _if39_exit
2702   14C5             _if39_exit:
2703   14C5             _if38_exit:
2704   14C5             ; while (num > 0) { 
2705   14C5             _while40_cond:
2706   14C5 FA 05 00      lea d, [bp + 5] ; $num
2707   14C8 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2708   14CB FD 39         mov c, b ; And place it into C
2709   14CD 2A            mov b, [d] ; Lower Word in B
2710   14CE             ; --- START RELATIONAL
2711   14CE D7            push a
2712   14CF FD D8         push g
2713   14D1 11            mov a, b
2714   14D2 FD 7A         mov g, c
2715   14D4 26 00 00      mov b, $0
2716   14D7 38 00 00      mov c, 0
2717   14DA FD 7F         sgt
2718   14DC FD F1         pop g
2719   14DE E4            pop a
2720   14DF             ; --- END RELATIONAL
2721   14DF C0 00 00      cmp b, 0
2722   14E2 C6 42 15      je _while40_exit
2723   14E5             _while40_block:
2724   14E5             ; digits[i] = '0' + (num % 10); 
2725   14E5 FA F7 FF      lea d, [bp + -9] ; $digits
2726   14E8 D7            push a
2727   14E9 DA            push d
2728   14EA FA F5 FF      lea d, [bp + -11] ; $i
2729   14ED 2A            mov b, [d]
2730   14EE E7            pop d
2731   14EF 5A            add d, b
2732   14F0 E4            pop a
2733   14F1 DA            push d
2734   14F2 26 30 00      mov b, $30
2735   14F5             ; --- START TERMS
2736   14F5 D7            push a
2737   14F6 11            mov a, b
2738   14F7 FA 05 00      lea d, [bp + 5] ; $num
2739   14FA 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2740   14FD FD 39         mov c, b ; And place it into C
2741   14FF 2A            mov b, [d] ; Lower Word in B
2742   1500             ; --- START FACTORS
2743   1500 D7            push a
2744   1501 11            mov a, b
2745   1502 26 0A 00      mov b, $a
2746   1505 AE            div a, b ; 
2747   1506 11            mov a, b
2748   1507 27            mov b, a
2749   1508 E4            pop a
2750   1509             ; --- END FACTORS
2751   1509 54            add a, b
2752   150A D7            push a
2753   150B FD 12         mov a, g
2754   150D 28            mov b, c
2755   150E 5C            adc a, b
2756   150F 39            mov c, a
2757   1510 E5            pop b
2758   1511 E4            pop a
2759   1512             ; --- END TERMS
2760   1512 E7            pop d
2761   1513 FD 3E         mov [d], bl
2762   1515             ; num = num / 10; 
2763   1515 FA 05 00      lea d, [bp + 5] ; $num
2764   1518 DA            push d
2765   1519 FA 05 00      lea d, [bp + 5] ; $num
2766   151C 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2767   151F FD 39         mov c, b ; And place it into C
2768   1521 2A            mov b, [d] ; Lower Word in B
2769   1522             ; --- START FACTORS
2770   1522 D7            push a
2771   1523 11            mov a, b
2772   1524 26 0A 00      mov b, $a
2773   1527 AE            div a, b
2774   1528 27            mov b, a
2775   1529 E4            pop a
2776   152A             ; --- END FACTORS
2777   152A E7            pop d
2778   152B FD 43         mov [d], b
2779   152D 28            mov b, c
2780   152E FD 44 02 00   mov [d + 2], b
2781   1532             ; i++; 
2782   1532 FA F5 FF      lea d, [bp + -11] ; $i
2783   1535 2A            mov b, [d]
2784   1536 FD 77         inc b
2785   1538 FA F5 FF      lea d, [bp + -11] ; $i
2786   153B FD 43         mov [d], b
2787   153D FD 7D         dec b
2788   153F 0A C5 14      jmp _while40_cond
2789   1542             _while40_exit:
2790   1542             ; while (i > 0) { 
2791   1542             _while41_cond:
2792   1542 FA F5 FF      lea d, [bp + -11] ; $i
2793   1545 2A            mov b, [d]
2794   1546             ; --- START RELATIONAL
2795   1546 D7            push a
2796   1547 11            mov a, b
2797   1548 26 00 00      mov b, $0
2798   154B B0            cmp a, b
2799   154C FD 7F         sgt ; >
2800   154E E4            pop a
2801   154F             ; --- END RELATIONAL
2802   154F C0 00 00      cmp b, 0
2803   1552 C6 7B 15      je _while41_exit
2804   1555             _while41_block:
2805   1555             ; i--; 
2806   1555 FA F5 FF      lea d, [bp + -11] ; $i
2807   1558 2A            mov b, [d]
2808   1559 FD 7D         dec b
2809   155B FA F5 FF      lea d, [bp + -11] ; $i
2810   155E FD 43         mov [d], b
2811   1560 FD 77         inc b
2812   1562             ; putchar(digits[i]); 
2813   1562 FA F7 FF      lea d, [bp + -9] ; $digits
2814   1565 D7            push a
2815   1566 DA            push d
2816   1567 FA F5 FF      lea d, [bp + -11] ; $i
2817   156A 2A            mov b, [d]
2818   156B E7            pop d
2819   156C 5A            add d, b
2820   156D E4            pop a
2821   156E 32            mov bl, [d]
2822   156F A7 00         mov bh, 0
2823   1571 DD            push bl
2824   1572 07 AE 1A      call putchar
2825   1575 51 01 00      add sp, 1
2826   1578 0A 42 15      jmp _while41_cond
2827   157B             _while41_exit:
2828   157B F9            leave
2829   157C 09            ret
2830   157D             
2831   157D             print_unsigned_long:
2832   157D F8 00 00      enter 0 ; (push bp; mov bp, sp)
2833   1580             ; char digits[10]; 
2834   1580 52 0A 00      sub sp, 10
2835   1583             ; int i; 
2836   1583 52 02 00      sub sp, 2
2837   1586             ; i = 0; 
2838   1586 FA F5 FF      lea d, [bp + -11] ; $i
2839   1589 DA            push d
2840   158A 26 00 00      mov b, $0
2841   158D E7            pop d
2842   158E FD 43         mov [d], b
2843   1590             ; if(num == 0){ 
2844   1590             _if42_cond:
2845   1590 FA 05 00      lea d, [bp + 5] ; $num
2846   1593 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2847   1596 FD 39         mov c, b ; And place it into C
2848   1598 2A            mov b, [d] ; Lower Word in B
2849   1599             ; --- START RELATIONAL
2850   1599 D7            push a
2851   159A FD D8         push g
2852   159C 11            mov a, b
2853   159D FD 7A         mov g, c
2854   159F 26 00 00      mov b, $0
2855   15A2 38 00 00      mov c, 0
2856   15A5 FD AF 00 00   cmp32 ga, cb
2856   15A9 00 00 00 00 
2856   15AD 00 00 00 00 
2856   15B1 00 00 00 00 
2856   15B5 00 00 00 00 
2856   15B9 00 00 00 00 
2856   15BD 00 00 00 00 
2856   15C1 00 00 00 00 
2856   15C5 00 00 00 00 
2856   15C9 00 00 00 00 
2856   15CD 00 00 00 00 
2856   15D1 00 00 00 00 
2856   15D5 00 00 00 00 
2856   15D9 00 00 00 00 
2856   15DD 00 00 00 00 
2856   15E1 00 00 00 00 
2856   15E5 00 00 00 00 
2856   15E9 00 00 00 00 
2856   15ED 00 00 00 00 
2856   15F1 00 00 00 00 
2856   15F5 00 00 00 00 
2856   15F9 00 00 00 00 
2856   15FD 00 00 00 00 
2856   1601 00 00 00 00 
2856   1605 00 00 00 00 
2856   1609 00 00 00 00 
2856   160D 00 00 00 00 
2856   1611 00 00 00 00 
2856   1615 00 00 00 00 
2856   1619 00 00 00 00 
2856   161D 00 00 00 00 
2856   1621 00 00 00 00 
2856   1625 00 00 00 00 
2856   1629 00 00 00 00 
2856   162D 00 00 00 00 
2856   1631 00 00 00 00 
2856   1635 00 00 00 00 
2856   1639 00 00 00 00 
2856   163D 00 00 00 00 
2856   1641 00 00 00 00 
2856   1645 00 00 00 00 
2856   1649 00 00 00 00 
2856   164D 00 00 00 00 
2856   1651 00 00 00 00 
2856   1655 00 00 00 00 
2856   1659 00 00 00 00 
2856   165D 00 00 00 00 
2856   1661 00 00 00 00 
2856   1665 00 00 00 00 
2856   1669 00 00 00 00 
2856   166D 00 00 00 00 
2856   1671 00 00 00 00 
2856   1675 00 00 00 00 
2856   1679 00 00 00 00 
2856   167D 00 00 00 00 
2856   1681 00 00 00 00 
2856   1685 00 00 00 00 
2856   1689 00 00 00 00 
2856   168D 00 00 00 00 
2856   1691 00 00 00 00 
2856   1695 00 00 00 00 
2856   1699 00 00 00 00 
2856   169D 00 00 00 00 
2856   16A1 00 00 00 00 
2856   16A5 00 
2857   16A6 FD 71         seq ; ==
2858   16A8 FD F1         pop g
2859   16AA E4            pop a
2860   16AB             ; --- END RELATIONAL
2861   16AB C0 00 00      cmp b, 0
2862   16AE C6 C0 16      je _if42_exit
2863   16B1             _if42_true:
2864   16B1             ; putchar('0'); 
2865   16B1 26 30 00      mov b, $30
2866   16B4 DD            push bl
2867   16B5 07 AE 1A      call putchar
2868   16B8 51 01 00      add sp, 1
2869   16BB             ; return; 
2870   16BB F9            leave
2871   16BC 09            ret
2872   16BD 0A C0 16      jmp _if42_exit
2873   16C0             _if42_exit:
2874   16C0             ; while (num > 0) { 
2875   16C0             _while43_cond:
2876   16C0 FA 05 00      lea d, [bp + 5] ; $num
2877   16C3 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2878   16C6 FD 39         mov c, b ; And place it into C
2879   16C8 2A            mov b, [d] ; Lower Word in B
2880   16C9             ; --- START RELATIONAL
2881   16C9 D7            push a
2882   16CA FD D8         push g
2883   16CC 11            mov a, b
2884   16CD FD 7A         mov g, c
2885   16CF 26 00 00      mov b, $0
2886   16D2 38 00 00      mov c, 0
2887   16D5 FD 81         sgu
2888   16D7 FD F1         pop g
2889   16D9 E4            pop a
2890   16DA             ; --- END RELATIONAL
2891   16DA C0 00 00      cmp b, 0
2892   16DD C6 3D 17      je _while43_exit
2893   16E0             _while43_block:
2894   16E0             ; digits[i] = '0' + (num % 10); 
2895   16E0 FA F7 FF      lea d, [bp + -9] ; $digits
2896   16E3 D7            push a
2897   16E4 DA            push d
2898   16E5 FA F5 FF      lea d, [bp + -11] ; $i
2899   16E8 2A            mov b, [d]
2900   16E9 E7            pop d
2901   16EA 5A            add d, b
2902   16EB E4            pop a
2903   16EC DA            push d
2904   16ED 26 30 00      mov b, $30
2905   16F0             ; --- START TERMS
2906   16F0 D7            push a
2907   16F1 11            mov a, b
2908   16F2 FA 05 00      lea d, [bp + 5] ; $num
2909   16F5 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2910   16F8 FD 39         mov c, b ; And place it into C
2911   16FA 2A            mov b, [d] ; Lower Word in B
2912   16FB             ; --- START FACTORS
2913   16FB D7            push a
2914   16FC 11            mov a, b
2915   16FD 26 0A 00      mov b, $a
2916   1700 AE            div a, b ; 
2917   1701 11            mov a, b
2918   1702 27            mov b, a
2919   1703 E4            pop a
2920   1704             ; --- END FACTORS
2921   1704 54            add a, b
2922   1705 D7            push a
2923   1706 FD 12         mov a, g
2924   1708 28            mov b, c
2925   1709 5C            adc a, b
2926   170A 39            mov c, a
2927   170B E5            pop b
2928   170C E4            pop a
2929   170D             ; --- END TERMS
2930   170D E7            pop d
2931   170E FD 3E         mov [d], bl
2932   1710             ; num = num / 10; 
2933   1710 FA 05 00      lea d, [bp + 5] ; $num
2934   1713 DA            push d
2935   1714 FA 05 00      lea d, [bp + 5] ; $num
2936   1717 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2937   171A FD 39         mov c, b ; And place it into C
2938   171C 2A            mov b, [d] ; Lower Word in B
2939   171D             ; --- START FACTORS
2940   171D D7            push a
2941   171E 11            mov a, b
2942   171F 26 0A 00      mov b, $a
2943   1722 AE            div a, b
2944   1723 27            mov b, a
2945   1724 E4            pop a
2946   1725             ; --- END FACTORS
2947   1725 E7            pop d
2948   1726 FD 43         mov [d], b
2949   1728 28            mov b, c
2950   1729 FD 44 02 00   mov [d + 2], b
2951   172D             ; i++; 
2952   172D FA F5 FF      lea d, [bp + -11] ; $i
2953   1730 2A            mov b, [d]
2954   1731 FD 77         inc b
2955   1733 FA F5 FF      lea d, [bp + -11] ; $i
2956   1736 FD 43         mov [d], b
2957   1738 FD 7D         dec b
2958   173A 0A C0 16      jmp _while43_cond
2959   173D             _while43_exit:
2960   173D             ; while (i > 0) { 
2961   173D             _while44_cond:
2962   173D FA F5 FF      lea d, [bp + -11] ; $i
2963   1740 2A            mov b, [d]
2964   1741             ; --- START RELATIONAL
2965   1741 D7            push a
2966   1742 11            mov a, b
2967   1743 26 00 00      mov b, $0
2968   1746 B0            cmp a, b
2969   1747 FD 7F         sgt ; >
2970   1749 E4            pop a
2971   174A             ; --- END RELATIONAL
2972   174A C0 00 00      cmp b, 0
2973   174D C6 76 17      je _while44_exit
2974   1750             _while44_block:
2975   1750             ; i--; 
2976   1750 FA F5 FF      lea d, [bp + -11] ; $i
2977   1753 2A            mov b, [d]
2978   1754 FD 7D         dec b
2979   1756 FA F5 FF      lea d, [bp + -11] ; $i
2980   1759 FD 43         mov [d], b
2981   175B FD 77         inc b
2982   175D             ; putchar(digits[i]); 
2983   175D FA F7 FF      lea d, [bp + -9] ; $digits
2984   1760 D7            push a
2985   1761 DA            push d
2986   1762 FA F5 FF      lea d, [bp + -11] ; $i
2987   1765 2A            mov b, [d]
2988   1766 E7            pop d
2989   1767 5A            add d, b
2990   1768 E4            pop a
2991   1769 32            mov bl, [d]
2992   176A A7 00         mov bh, 0
2993   176C DD            push bl
2994   176D 07 AE 1A      call putchar
2995   1770 51 01 00      add sp, 1
2996   1773 0A 3D 17      jmp _while44_cond
2997   1776             _while44_exit:
2998   1776 F9            leave
2999   1777 09            ret
3000   1778             
3001   1778             sprint_unsigned:
3002   1778 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3003   177B             ; char digits[5]; 
3004   177B 52 05 00      sub sp, 5
3005   177E             ; int i; 
3006   177E 52 02 00      sub sp, 2
3007   1781             ; int len = 0; 
3008   1781 52 02 00      sub sp, 2
3009   1784             ; --- START LOCAL VAR INITIALIZATION
3010   1784 FA F8 FF      lea d, [bp + -8] ; $len
3011   1787 DA            push d
3012   1788 26 00 00      mov b, $0
3013   178B E7            pop d
3014   178C FD 43         mov [d], b
3015   178E             ; --- END LOCAL VAR INITIALIZATION
3016   178E             ; i = 0; 
3017   178E FA FA FF      lea d, [bp + -6] ; $i
3018   1791 DA            push d
3019   1792 26 00 00      mov b, $0
3020   1795 E7            pop d
3021   1796 FD 43         mov [d], b
3022   1798             ; if(num == 0){ 
3023   1798             _if45_cond:
3024   1798 FA 07 00      lea d, [bp + 7] ; $num
3025   179B 2A            mov b, [d]
3026   179C             ; --- START RELATIONAL
3027   179C D7            push a
3028   179D 11            mov a, b
3029   179E 26 00 00      mov b, $0
3030   17A1 B0            cmp a, b
3031   17A2 FD 71         seq ; ==
3032   17A4 E4            pop a
3033   17A5             ; --- END RELATIONAL
3034   17A5 C0 00 00      cmp b, 0
3035   17A8 C6 C7 17      je _if45_exit
3036   17AB             _if45_true:
3037   17AB             ; *dest++ = '0'; 
3038   17AB FA 05 00      lea d, [bp + 5] ; $dest
3039   17AE 2A            mov b, [d]
3040   17AF FD 77         inc b
3041   17B1 FA 05 00      lea d, [bp + 5] ; $dest
3042   17B4 FD 43         mov [d], b
3043   17B6 FD 7D         dec b
3044   17B8 D8            push b
3045   17B9 26 30 00      mov b, $30
3046   17BC E7            pop d
3047   17BD FD 3E         mov [d], bl
3048   17BF             ; return 1; 
3049   17BF 26 01 00      mov b, $1
3050   17C2 F9            leave
3051   17C3 09            ret
3052   17C4 0A C7 17      jmp _if45_exit
3053   17C7             _if45_exit:
3054   17C7             ; while (num > 0) { 
3055   17C7             _while46_cond:
3056   17C7 FA 07 00      lea d, [bp + 7] ; $num
3057   17CA 2A            mov b, [d]
3058   17CB             ; --- START RELATIONAL
3059   17CB D7            push a
3060   17CC 11            mov a, b
3061   17CD 26 00 00      mov b, $0
3062   17D0 B0            cmp a, b
3063   17D1 FD 81         sgu ; > (unsigned)
3064   17D3 E4            pop a
3065   17D4             ; --- END RELATIONAL
3066   17D4 C0 00 00      cmp b, 0
3067   17D7 C6 21 18      je _while46_exit
3068   17DA             _while46_block:
3069   17DA             ; digits[i] = '0' + (num % 10); 
3070   17DA FA FC FF      lea d, [bp + -4] ; $digits
3071   17DD D7            push a
3072   17DE DA            push d
3073   17DF FA FA FF      lea d, [bp + -6] ; $i
3074   17E2 2A            mov b, [d]
3075   17E3 E7            pop d
3076   17E4 5A            add d, b
3077   17E5 E4            pop a
3078   17E6 DA            push d
3079   17E7 26 30 00      mov b, $30
3080   17EA             ; --- START TERMS
3081   17EA D7            push a
3082   17EB 11            mov a, b
3083   17EC FA 07 00      lea d, [bp + 7] ; $num
3084   17EF 2A            mov b, [d]
3085   17F0             ; --- START FACTORS
3086   17F0 D7            push a
3087   17F1 11            mov a, b
3088   17F2 26 0A 00      mov b, $a
3089   17F5 AE            div a, b ; 
3090   17F6 11            mov a, b
3091   17F7 27            mov b, a
3092   17F8 E4            pop a
3093   17F9             ; --- END FACTORS
3094   17F9 56            add b, a
3095   17FA E4            pop a
3096   17FB             ; --- END TERMS
3097   17FB E7            pop d
3098   17FC FD 3E         mov [d], bl
3099   17FE             ; num = num / 10; 
3100   17FE FA 07 00      lea d, [bp + 7] ; $num
3101   1801 DA            push d
3102   1802 FA 07 00      lea d, [bp + 7] ; $num
3103   1805 2A            mov b, [d]
3104   1806             ; --- START FACTORS
3105   1806 D7            push a
3106   1807 11            mov a, b
3107   1808 26 0A 00      mov b, $a
3108   180B AE            div a, b
3109   180C 27            mov b, a
3110   180D E4            pop a
3111   180E             ; --- END FACTORS
3112   180E E7            pop d
3113   180F FD 43         mov [d], b
3114   1811             ; i++; 
3115   1811 FA FA FF      lea d, [bp + -6] ; $i
3116   1814 2A            mov b, [d]
3117   1815 FD 77         inc b
3118   1817 FA FA FF      lea d, [bp + -6] ; $i
3119   181A FD 43         mov [d], b
3120   181C FD 7D         dec b
3121   181E 0A C7 17      jmp _while46_cond
3122   1821             _while46_exit:
3123   1821             ; while (i > 0) { 
3124   1821             _while47_cond:
3125   1821 FA FA FF      lea d, [bp + -6] ; $i
3126   1824 2A            mov b, [d]
3127   1825             ; --- START RELATIONAL
3128   1825 D7            push a
3129   1826 11            mov a, b
3130   1827 26 00 00      mov b, $0
3131   182A B0            cmp a, b
3132   182B FD 7F         sgt ; >
3133   182D E4            pop a
3134   182E             ; --- END RELATIONAL
3135   182E C0 00 00      cmp b, 0
3136   1831 C6 71 18      je _while47_exit
3137   1834             _while47_block:
3138   1834             ; i--; 
3139   1834 FA FA FF      lea d, [bp + -6] ; $i
3140   1837 2A            mov b, [d]
3141   1838 FD 7D         dec b
3142   183A FA FA FF      lea d, [bp + -6] ; $i
3143   183D FD 43         mov [d], b
3144   183F FD 77         inc b
3145   1841             ; *dest++ = digits[i]; 
3146   1841 FA 05 00      lea d, [bp + 5] ; $dest
3147   1844 2A            mov b, [d]
3148   1845 FD 77         inc b
3149   1847 FA 05 00      lea d, [bp + 5] ; $dest
3150   184A FD 43         mov [d], b
3151   184C FD 7D         dec b
3152   184E D8            push b
3153   184F FA FC FF      lea d, [bp + -4] ; $digits
3154   1852 D7            push a
3155   1853 DA            push d
3156   1854 FA FA FF      lea d, [bp + -6] ; $i
3157   1857 2A            mov b, [d]
3158   1858 E7            pop d
3159   1859 5A            add d, b
3160   185A E4            pop a
3161   185B 32            mov bl, [d]
3162   185C A7 00         mov bh, 0
3163   185E E7            pop d
3164   185F FD 3E         mov [d], bl
3165   1861             ; len++; 
3166   1861 FA F8 FF      lea d, [bp + -8] ; $len
3167   1864 2A            mov b, [d]
3168   1865 FD 77         inc b
3169   1867 FA F8 FF      lea d, [bp + -8] ; $len
3170   186A FD 43         mov [d], b
3171   186C FD 7D         dec b
3172   186E 0A 21 18      jmp _while47_cond
3173   1871             _while47_exit:
3174   1871             ; *dest = '\0'; 
3175   1871 FA 05 00      lea d, [bp + 5] ; $dest
3176   1874 2A            mov b, [d]
3177   1875 D8            push b
3178   1876 26 00 00      mov b, $0
3179   1879 E7            pop d
3180   187A FD 3E         mov [d], bl
3181   187C             ; return len; 
3182   187C FA F8 FF      lea d, [bp + -8] ; $len
3183   187F 2A            mov b, [d]
3184   1880 F9            leave
3185   1881 09            ret
3186   1882             
3187   1882             print_unsigned:
3188   1882 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3189   1885             ; char digits[5]; 
3190   1885 52 05 00      sub sp, 5
3191   1888             ; int i; 
3192   1888 52 02 00      sub sp, 2
3193   188B             ; i = 0; 
3194   188B FA FA FF      lea d, [bp + -6] ; $i
3195   188E DA            push d
3196   188F 26 00 00      mov b, $0
3197   1892 E7            pop d
3198   1893 FD 43         mov [d], b
3199   1895             ; if(num == 0){ 
3200   1895             _if48_cond:
3201   1895 FA 05 00      lea d, [bp + 5] ; $num
3202   1898 2A            mov b, [d]
3203   1899             ; --- START RELATIONAL
3204   1899 D7            push a
3205   189A 11            mov a, b
3206   189B 26 00 00      mov b, $0
3207   189E B0            cmp a, b
3208   189F FD 71         seq ; ==
3209   18A1 E4            pop a
3210   18A2             ; --- END RELATIONAL
3211   18A2 C0 00 00      cmp b, 0
3212   18A5 C6 B7 18      je _if48_exit
3213   18A8             _if48_true:
3214   18A8             ; putchar('0'); 
3215   18A8 26 30 00      mov b, $30
3216   18AB DD            push bl
3217   18AC 07 AE 1A      call putchar
3218   18AF 51 01 00      add sp, 1
3219   18B2             ; return; 
3220   18B2 F9            leave
3221   18B3 09            ret
3222   18B4 0A B7 18      jmp _if48_exit
3223   18B7             _if48_exit:
3224   18B7             ; while (num > 0) { 
3225   18B7             _while49_cond:
3226   18B7 FA 05 00      lea d, [bp + 5] ; $num
3227   18BA 2A            mov b, [d]
3228   18BB             ; --- START RELATIONAL
3229   18BB D7            push a
3230   18BC 11            mov a, b
3231   18BD 26 00 00      mov b, $0
3232   18C0 B0            cmp a, b
3233   18C1 FD 81         sgu ; > (unsigned)
3234   18C3 E4            pop a
3235   18C4             ; --- END RELATIONAL
3236   18C4 C0 00 00      cmp b, 0
3237   18C7 C6 11 19      je _while49_exit
3238   18CA             _while49_block:
3239   18CA             ; digits[i] = '0' + (num % 10); 
3240   18CA FA FC FF      lea d, [bp + -4] ; $digits
3241   18CD D7            push a
3242   18CE DA            push d
3243   18CF FA FA FF      lea d, [bp + -6] ; $i
3244   18D2 2A            mov b, [d]
3245   18D3 E7            pop d
3246   18D4 5A            add d, b
3247   18D5 E4            pop a
3248   18D6 DA            push d
3249   18D7 26 30 00      mov b, $30
3250   18DA             ; --- START TERMS
3251   18DA D7            push a
3252   18DB 11            mov a, b
3253   18DC FA 05 00      lea d, [bp + 5] ; $num
3254   18DF 2A            mov b, [d]
3255   18E0             ; --- START FACTORS
3256   18E0 D7            push a
3257   18E1 11            mov a, b
3258   18E2 26 0A 00      mov b, $a
3259   18E5 AE            div a, b ; 
3260   18E6 11            mov a, b
3261   18E7 27            mov b, a
3262   18E8 E4            pop a
3263   18E9             ; --- END FACTORS
3264   18E9 56            add b, a
3265   18EA E4            pop a
3266   18EB             ; --- END TERMS
3267   18EB E7            pop d
3268   18EC FD 3E         mov [d], bl
3269   18EE             ; num = num / 10; 
3270   18EE FA 05 00      lea d, [bp + 5] ; $num
3271   18F1 DA            push d
3272   18F2 FA 05 00      lea d, [bp + 5] ; $num
3273   18F5 2A            mov b, [d]
3274   18F6             ; --- START FACTORS
3275   18F6 D7            push a
3276   18F7 11            mov a, b
3277   18F8 26 0A 00      mov b, $a
3278   18FB AE            div a, b
3279   18FC 27            mov b, a
3280   18FD E4            pop a
3281   18FE             ; --- END FACTORS
3282   18FE E7            pop d
3283   18FF FD 43         mov [d], b
3284   1901             ; i++; 
3285   1901 FA FA FF      lea d, [bp + -6] ; $i
3286   1904 2A            mov b, [d]
3287   1905 FD 77         inc b
3288   1907 FA FA FF      lea d, [bp + -6] ; $i
3289   190A FD 43         mov [d], b
3290   190C FD 7D         dec b
3291   190E 0A B7 18      jmp _while49_cond
3292   1911             _while49_exit:
3293   1911             ; while (i > 0) { 
3294   1911             _while50_cond:
3295   1911 FA FA FF      lea d, [bp + -6] ; $i
3296   1914 2A            mov b, [d]
3297   1915             ; --- START RELATIONAL
3298   1915 D7            push a
3299   1916 11            mov a, b
3300   1917 26 00 00      mov b, $0
3301   191A B0            cmp a, b
3302   191B FD 7F         sgt ; >
3303   191D E4            pop a
3304   191E             ; --- END RELATIONAL
3305   191E C0 00 00      cmp b, 0
3306   1921 C6 4A 19      je _while50_exit
3307   1924             _while50_block:
3308   1924             ; i--; 
3309   1924 FA FA FF      lea d, [bp + -6] ; $i
3310   1927 2A            mov b, [d]
3311   1928 FD 7D         dec b
3312   192A FA FA FF      lea d, [bp + -6] ; $i
3313   192D FD 43         mov [d], b
3314   192F FD 77         inc b
3315   1931             ; putchar(digits[i]); 
3316   1931 FA FC FF      lea d, [bp + -4] ; $digits
3317   1934 D7            push a
3318   1935 DA            push d
3319   1936 FA FA FF      lea d, [bp + -6] ; $i
3320   1939 2A            mov b, [d]
3321   193A E7            pop d
3322   193B 5A            add d, b
3323   193C E4            pop a
3324   193D 32            mov bl, [d]
3325   193E A7 00         mov bh, 0
3326   1940 DD            push bl
3327   1941 07 AE 1A      call putchar
3328   1944 51 01 00      add sp, 1
3329   1947 0A 11 19      jmp _while50_cond
3330   194A             _while50_exit:
3331   194A F9            leave
3332   194B 09            ret
3333   194C             
3334   194C             sprint_signed:
3335   194C F8 00 00      enter 0 ; (push bp; mov bp, sp)
3336   194F             ; char digits[5]; 
3337   194F 52 05 00      sub sp, 5
3338   1952             ; int i = 0; 
3339   1952 52 02 00      sub sp, 2
3340   1955             ; --- START LOCAL VAR INITIALIZATION
3341   1955 FA FA FF      lea d, [bp + -6] ; $i
3342   1958 DA            push d
3343   1959 26 00 00      mov b, $0
3344   195C E7            pop d
3345   195D FD 43         mov [d], b
3346   195F             ; --- END LOCAL VAR INITIALIZATION
3347   195F             ; int len = 0; 
3348   195F 52 02 00      sub sp, 2
3349   1962             ; --- START LOCAL VAR INITIALIZATION
3350   1962 FA F8 FF      lea d, [bp + -8] ; $len
3351   1965 DA            push d
3352   1966 26 00 00      mov b, $0
3353   1969 E7            pop d
3354   196A FD 43         mov [d], b
3355   196C             ; --- END LOCAL VAR INITIALIZATION
3356   196C             ; if (num < 0) { 
3357   196C             _if51_cond:
3358   196C FA 07 00      lea d, [bp + 7] ; $num
3359   196F 2A            mov b, [d]
3360   1970             ; --- START RELATIONAL
3361   1970 D7            push a
3362   1971 11            mov a, b
3363   1972 26 00 00      mov b, $0
3364   1975 B0            cmp a, b
3365   1976 FD 73         slt ; < (signed)
3366   1978 E4            pop a
3367   1979             ; --- END RELATIONAL
3368   1979 C0 00 00      cmp b, 0
3369   197C C6 B0 19      je _if51_else
3370   197F             _if51_true:
3371   197F             ; *dest++ = '-'; 
3372   197F FA 05 00      lea d, [bp + 5] ; $dest
3373   1982 2A            mov b, [d]
3374   1983 FD 77         inc b
3375   1985 FA 05 00      lea d, [bp + 5] ; $dest
3376   1988 FD 43         mov [d], b
3377   198A FD 7D         dec b
3378   198C D8            push b
3379   198D 26 2D 00      mov b, $2d
3380   1990 E7            pop d
3381   1991 FD 3E         mov [d], bl
3382   1993             ; num = -num; 
3383   1993 FA 07 00      lea d, [bp + 7] ; $num
3384   1996 DA            push d
3385   1997 FA 07 00      lea d, [bp + 7] ; $num
3386   199A 2A            mov b, [d]
3387   199B FD 97         neg b
3388   199D E7            pop d
3389   199E FD 43         mov [d], b
3390   19A0             ; len++; 
3391   19A0 FA F8 FF      lea d, [bp + -8] ; $len
3392   19A3 2A            mov b, [d]
3393   19A4 FD 77         inc b
3394   19A6 FA F8 FF      lea d, [bp + -8] ; $len
3395   19A9 FD 43         mov [d], b
3396   19AB FD 7D         dec b
3397   19AD 0A EA 19      jmp _if51_exit
3398   19B0             _if51_else:
3399   19B0             ; if (num == 0) { 
3400   19B0             _if52_cond:
3401   19B0 FA 07 00      lea d, [bp + 7] ; $num
3402   19B3 2A            mov b, [d]
3403   19B4             ; --- START RELATIONAL
3404   19B4 D7            push a
3405   19B5 11            mov a, b
3406   19B6 26 00 00      mov b, $0
3407   19B9 B0            cmp a, b
3408   19BA FD 71         seq ; ==
3409   19BC E4            pop a
3410   19BD             ; --- END RELATIONAL
3411   19BD C0 00 00      cmp b, 0
3412   19C0 C6 EA 19      je _if52_exit
3413   19C3             _if52_true:
3414   19C3             ; *dest++ = '0'; 
3415   19C3 FA 05 00      lea d, [bp + 5] ; $dest
3416   19C6 2A            mov b, [d]
3417   19C7 FD 77         inc b
3418   19C9 FA 05 00      lea d, [bp + 5] ; $dest
3419   19CC FD 43         mov [d], b
3420   19CE FD 7D         dec b
3421   19D0 D8            push b
3422   19D1 26 30 00      mov b, $30
3423   19D4 E7            pop d
3424   19D5 FD 3E         mov [d], bl
3425   19D7             ; *dest = '\0'; 
3426   19D7 FA 05 00      lea d, [bp + 5] ; $dest
3427   19DA 2A            mov b, [d]
3428   19DB D8            push b
3429   19DC 26 00 00      mov b, $0
3430   19DF E7            pop d
3431   19E0 FD 3E         mov [d], bl
3432   19E2             ; return 1; 
3433   19E2 26 01 00      mov b, $1
3434   19E5 F9            leave
3435   19E6 09            ret
3436   19E7 0A EA 19      jmp _if52_exit
3437   19EA             _if52_exit:
3438   19EA             _if51_exit:
3439   19EA             ; while (num > 0) { 
3440   19EA             _while53_cond:
3441   19EA FA 07 00      lea d, [bp + 7] ; $num
3442   19ED 2A            mov b, [d]
3443   19EE             ; --- START RELATIONAL
3444   19EE D7            push a
3445   19EF 11            mov a, b
3446   19F0 26 00 00      mov b, $0
3447   19F3 B0            cmp a, b
3448   19F4 FD 7F         sgt ; >
3449   19F6 E4            pop a
3450   19F7             ; --- END RELATIONAL
3451   19F7 C0 00 00      cmp b, 0
3452   19FA C6 44 1A      je _while53_exit
3453   19FD             _while53_block:
3454   19FD             ; digits[i] = '0' + (num % 10); 
3455   19FD FA FC FF      lea d, [bp + -4] ; $digits
3456   1A00 D7            push a
3457   1A01 DA            push d
3458   1A02 FA FA FF      lea d, [bp + -6] ; $i
3459   1A05 2A            mov b, [d]
3460   1A06 E7            pop d
3461   1A07 5A            add d, b
3462   1A08 E4            pop a
3463   1A09 DA            push d
3464   1A0A 26 30 00      mov b, $30
3465   1A0D             ; --- START TERMS
3466   1A0D D7            push a
3467   1A0E 11            mov a, b
3468   1A0F FA 07 00      lea d, [bp + 7] ; $num
3469   1A12 2A            mov b, [d]
3470   1A13             ; --- START FACTORS
3471   1A13 D7            push a
3472   1A14 11            mov a, b
3473   1A15 26 0A 00      mov b, $a
3474   1A18 AE            div a, b ; 
3475   1A19 11            mov a, b
3476   1A1A 27            mov b, a
3477   1A1B E4            pop a
3478   1A1C             ; --- END FACTORS
3479   1A1C 56            add b, a
3480   1A1D E4            pop a
3481   1A1E             ; --- END TERMS
3482   1A1E E7            pop d
3483   1A1F FD 3E         mov [d], bl
3484   1A21             ; num = num / 10; 
3485   1A21 FA 07 00      lea d, [bp + 7] ; $num
3486   1A24 DA            push d
3487   1A25 FA 07 00      lea d, [bp + 7] ; $num
3488   1A28 2A            mov b, [d]
3489   1A29             ; --- START FACTORS
3490   1A29 D7            push a
3491   1A2A 11            mov a, b
3492   1A2B 26 0A 00      mov b, $a
3493   1A2E AE            div a, b
3494   1A2F 27            mov b, a
3495   1A30 E4            pop a
3496   1A31             ; --- END FACTORS
3497   1A31 E7            pop d
3498   1A32 FD 43         mov [d], b
3499   1A34             ; i++; 
3500   1A34 FA FA FF      lea d, [bp + -6] ; $i
3501   1A37 2A            mov b, [d]
3502   1A38 FD 77         inc b
3503   1A3A FA FA FF      lea d, [bp + -6] ; $i
3504   1A3D FD 43         mov [d], b
3505   1A3F FD 7D         dec b
3506   1A41 0A EA 19      jmp _while53_cond
3507   1A44             _while53_exit:
3508   1A44             ; while (i > 0) { 
3509   1A44             _while54_cond:
3510   1A44 FA FA FF      lea d, [bp + -6] ; $i
3511   1A47 2A            mov b, [d]
3512   1A48             ; --- START RELATIONAL
3513   1A48 D7            push a
3514   1A49 11            mov a, b
3515   1A4A 26 00 00      mov b, $0
3516   1A4D B0            cmp a, b
3517   1A4E FD 7F         sgt ; >
3518   1A50 E4            pop a
3519   1A51             ; --- END RELATIONAL
3520   1A51 C0 00 00      cmp b, 0
3521   1A54 C6 94 1A      je _while54_exit
3522   1A57             _while54_block:
3523   1A57             ; i--; 
3524   1A57 FA FA FF      lea d, [bp + -6] ; $i
3525   1A5A 2A            mov b, [d]
3526   1A5B FD 7D         dec b
3527   1A5D FA FA FF      lea d, [bp + -6] ; $i
3528   1A60 FD 43         mov [d], b
3529   1A62 FD 77         inc b
3530   1A64             ; *dest++ = digits[i]; 
3531   1A64 FA 05 00      lea d, [bp + 5] ; $dest
3532   1A67 2A            mov b, [d]
3533   1A68 FD 77         inc b
3534   1A6A FA 05 00      lea d, [bp + 5] ; $dest
3535   1A6D FD 43         mov [d], b
3536   1A6F FD 7D         dec b
3537   1A71 D8            push b
3538   1A72 FA FC FF      lea d, [bp + -4] ; $digits
3539   1A75 D7            push a
3540   1A76 DA            push d
3541   1A77 FA FA FF      lea d, [bp + -6] ; $i
3542   1A7A 2A            mov b, [d]
3543   1A7B E7            pop d
3544   1A7C 5A            add d, b
3545   1A7D E4            pop a
3546   1A7E 32            mov bl, [d]
3547   1A7F A7 00         mov bh, 0
3548   1A81 E7            pop d
3549   1A82 FD 3E         mov [d], bl
3550   1A84             ; len++; 
3551   1A84 FA F8 FF      lea d, [bp + -8] ; $len
3552   1A87 2A            mov b, [d]
3553   1A88 FD 77         inc b
3554   1A8A FA F8 FF      lea d, [bp + -8] ; $len
3555   1A8D FD 43         mov [d], b
3556   1A8F FD 7D         dec b
3557   1A91 0A 44 1A      jmp _while54_cond
3558   1A94             _while54_exit:
3559   1A94             ; *dest = '\0'; 
3560   1A94 FA 05 00      lea d, [bp + 5] ; $dest
3561   1A97 2A            mov b, [d]
3562   1A98 D8            push b
3563   1A99 26 00 00      mov b, $0
3564   1A9C E7            pop d
3565   1A9D FD 3E         mov [d], bl
3566   1A9F             ; return len; 
3567   1A9F FA F8 FF      lea d, [bp + -8] ; $len
3568   1AA2 2A            mov b, [d]
3569   1AA3 F9            leave
3570   1AA4 09            ret
3571   1AA5             
3572   1AA5             date:
3573   1AA5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3574   1AA8             
3575   1AA8             ; --- BEGIN INLINE ASM SEGMENT
3576   1AA8 19 00         mov al, 0 
3577   1AAA 05 07         syscall sys_datetime
3578   1AAC             ; --- END INLINE ASM SEGMENT
3579   1AAC             
3580   1AAC F9            leave
3581   1AAD 09            ret
3582   1AAE             
3583   1AAE             putchar:
3584   1AAE F8 00 00      enter 0 ; (push bp; mov bp, sp)
3585   1AB1             
3586   1AB1             ; --- BEGIN INLINE ASM SEGMENT
3587   1AB1 FA 05 00      lea d, [bp + 5] ; $c
3588   1AB4 1E            mov al, [d]
3589   1AB5 23            mov ah, al
3590   1AB6 07 3F 1C      call _putchar
3591   1AB9             ; --- END INLINE ASM SEGMENT
3592   1AB9             
3593   1AB9 F9            leave
3594   1ABA 09            ret
3595   1ABB             
3596   1ABB             getchar:
3597   1ABB F8 00 00      enter 0 ; (push bp; mov bp, sp)
3598   1ABE             ; char c; 
3599   1ABE 52 01 00      sub sp, 1
3600   1AC1             
3601   1AC1             ; --- BEGIN INLINE ASM SEGMENT
3602   1AC1 07 38 1C      call getch
3603   1AC4 1A            mov al, ah
3604   1AC5 FA 00 00      lea d, [bp + 0] ; $c
3605   1AC8 3E            mov [d], al
3606   1AC9             ; --- END INLINE ASM SEGMENT
3607   1AC9             
3608   1AC9             ; return c; 
3609   1AC9 FA 00 00      lea d, [bp + 0] ; $c
3610   1ACC 32            mov bl, [d]
3611   1ACD A7 00         mov bh, 0
3612   1ACF F9            leave
3613   1AD0 09            ret
3614   1AD1             
3615   1AD1             scann:
3616   1AD1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3617   1AD4             ; int m; 
3618   1AD4 52 02 00      sub sp, 2
3619   1AD7             
3620   1AD7             ; --- BEGIN INLINE ASM SEGMENT
3621   1AD7 07 83 1E      call scan_u16d
3622   1ADA FA FF FF      lea d, [bp + -1] ; $m
3623   1ADD 43            mov [d], a
3624   1ADE             ; --- END INLINE ASM SEGMENT
3625   1ADE             
3626   1ADE             ; return m; 
3627   1ADE FA FF FF      lea d, [bp + -1] ; $m
3628   1AE1 2A            mov b, [d]
3629   1AE2 F9            leave
3630   1AE3 09            ret
3631   1AE4             
3632   1AE4             puts:
3633   1AE4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3634   1AE7             
3635   1AE7             ; --- BEGIN INLINE ASM SEGMENT
3636   1AE7 FA 05 00      lea d, [bp + 5] ; $s
3637   1AEA 15            mov a, [d]
3638   1AEB 3C            mov d, a
3639   1AEC 07 89 1D      call _puts
3640   1AEF 10 00 0A      mov a, $0A00
3641   1AF2 05 03         syscall sys_io
3642   1AF4             ; --- END INLINE ASM SEGMENT
3643   1AF4             
3644   1AF4 F9            leave
3645   1AF5 09            ret
3646   1AF6             
3647   1AF6             print:
3648   1AF6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3649   1AF9             
3650   1AF9             ; --- BEGIN INLINE ASM SEGMENT
3651   1AF9 FA 05 00      lea d, [bp + 5] ; $s
3652   1AFC FD 2A         mov d, [d]
3653   1AFE 07 89 1D      call _puts
3654   1B01             ; --- END INLINE ASM SEGMENT
3655   1B01             
3656   1B01 F9            leave
3657   1B02 09            ret
3658   1B03             
3659   1B03             getparam:
3660   1B03 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3661   1B06             ; char data; 
3662   1B06 52 01 00      sub sp, 1
3663   1B09             
3664   1B09             ; --- BEGIN INLINE ASM SEGMENT
3665   1B09 19 04         mov al, 4
3666   1B0B FA 05 00      lea d, [bp + 5] ; $address
3667   1B0E FD 2A         mov d, [d]
3668   1B10 05 0C         syscall sys_system
3669   1B12 FA 00 00      lea d, [bp + 0] ; $data
3670   1B15 FD 3E         mov [d], bl
3671   1B17             ; --- END INLINE ASM SEGMENT
3672   1B17             
3673   1B17             ; return data; 
3674   1B17 FA 00 00      lea d, [bp + 0] ; $data
3675   1B1A 32            mov bl, [d]
3676   1B1B A7 00         mov bh, 0
3677   1B1D F9            leave
3678   1B1E 09            ret
3679   1B1F             
3680   1B1F             clear:
3681   1B1F F8 00 00      enter 0 ; (push bp; mov bp, sp)
3682   1B22             ; print("\033[2J\033[H"); 
3683   1B22 26 6F 20      mov b, _s6 ; "\033[2J\033[H"
3684   1B25 FD AB         swp b
3685   1B27 D8            push b
3686   1B28 07 F6 1A      call print
3687   1B2B 51 02 00      add sp, 2
3688   1B2E F9            leave
3689   1B2F 09            ret
3690   1B30             
3691   1B30             abs:
3692   1B30 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3693   1B33             ; return i < 0 ? -i : i; 
3694   1B33             _ternary55_cond:
3695   1B33 FA 05 00      lea d, [bp + 5] ; $i
3696   1B36 2A            mov b, [d]
3697   1B37             ; --- START RELATIONAL
3698   1B37 D7            push a
3699   1B38 11            mov a, b
3700   1B39 26 00 00      mov b, $0
3701   1B3C B0            cmp a, b
3702   1B3D FD 73         slt ; < (signed)
3703   1B3F E4            pop a
3704   1B40             ; --- END RELATIONAL
3705   1B40 C0 00 00      cmp b, 0
3706   1B43 C6 4F 1B      je _ternary55_false
3707   1B46             _ternary55_true:
3708   1B46 FA 05 00      lea d, [bp + 5] ; $i
3709   1B49 2A            mov b, [d]
3710   1B4A FD 97         neg b
3711   1B4C 0A 53 1B      jmp _ternary55_exit
3712   1B4F             _ternary55_false:
3713   1B4F FA 05 00      lea d, [bp + 5] ; $i
3714   1B52 2A            mov b, [d]
3715   1B53             _ternary55_exit:
3716   1B53 F9            leave
3717   1B54 09            ret
3718   1B55             
3719   1B55             include_stdio_asm:
3720   1B55 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3721   1B58             
3722   1B58             ; --- BEGIN INLINE ASM SEGMENT
3723   1B58             .include "lib/asm/stdio.asm"
0001+  1B58             ;-----------------------------------------------------------------------------
0002+  1B58             ; stdio.s
0003+  1B58             ;-----------------------------------------------------------------------------
0004+  1B58             .include "lib/asm/string.asm"
0001++ 1B58             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 1B58             ; string.s
0003++ 1B58             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 1B58             
0005++ 1B58             
0006++ 1B58             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 1B58             ; _strrev
0008++ 1B58             ; reverse a string
0009++ 1B58             ; D = string address
0010++ 1B58             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 1B58             ; 01234
0012++ 1B58             _strrev:
0013++ 1B58 4B          	pusha
0014++ 1B59 07 9F 1B    	call _strlen	; length in C
0015++ 1B5C 12          	mov a, c
0016++ 1B5D AF 01 00    	cmp a, 1
0017++ 1B60 D0 7A 1B    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 1B63 7D          	dec a
0019++ 1B64 FD 4E       	mov si, d	; beginning of string
0020++ 1B66 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 1B68 59          	add d, a	; end of string
0022++ 1B69 12          	mov a, c
0023++ 1B6A FD 9B       	shr a		; divide by 2
0024++ 1B6C 39          	mov c, a	; C now counts the steps
0025++ 1B6D             _strrev_L0:
0026++ 1B6D 32          	mov bl, [d]	; save load right-side char into BL
0027++ 1B6E F6          	lodsb		; load left-side char into AL; increase SI
0028++ 1B6F 3E          	mov [d], al	; store left char into right side
0029++ 1B70 1B          	mov al, bl
0030++ 1B71 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 1B72 7E          	dec c
0032++ 1B73 7F          	dec d
0033++ 1B74 C2 00 00    	cmp c, 0
0034++ 1B77 C7 6D 1B    	jne _strrev_L0
0035++ 1B7A             _strrev_end:
0036++ 1B7A 4C          	popa
0037++ 1B7B 09          	ret
0038++ 1B7C             	
0039++ 1B7C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 1B7C             ; _strchr
0041++ 1B7C             ; search string in D for char in AL
0042++ 1B7C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 1B7C             _strchr:
0044++ 1B7C             _strchr_L0:
0045++ 1B7C 32          	mov bl, [d]
0046++ 1B7D C1 00       	cmp bl, 0
0047++ 1B7F C6 8A 1B    	je _strchr_end
0048++ 1B82 BA          	cmp al, bl
0049++ 1B83 C6 8A 1B    	je _strchr_end
0050++ 1B86 79          	inc d
0051++ 1B87 0A 7C 1B    	jmp _strchr_L0
0052++ 1B8A             _strchr_end:
0053++ 1B8A 1B          	mov al, bl
0054++ 1B8B 09          	ret
0055++ 1B8C             
0056++ 1B8C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 1B8C             ; _strstr
0058++ 1B8C             ; find sub-string
0059++ 1B8C             ; str1 in SI
0060++ 1B8C             ; str2 in DI
0061++ 1B8C             ; SI points to end of source string
0062++ 1B8C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 1B8C             _strstr:
0064++ 1B8C DB          	push al
0065++ 1B8D DA          	push d
0066++ 1B8E E3          	push di
0067++ 1B8F             _strstr_loop:
0068++ 1B8F F3          	cmpsb					; compare a byte of the strings
0069++ 1B90 C7 9B 1B    	jne _strstr_ret
0070++ 1B93 FC 00 00    	lea d, [di + 0]
0071++ 1B96 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1B98 C7 8F 1B    	jne _strstr_loop				; equal chars but not at end
0073++ 1B9B             _strstr_ret:
0074++ 1B9B F0          	pop di
0075++ 1B9C E7          	pop d
0076++ 1B9D E8          	pop al
0077++ 1B9E 09          	ret
0078++ 1B9F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1B9F             ; length of null terminated string
0080++ 1B9F             ; result in C
0081++ 1B9F             ; pointer in D
0082++ 1B9F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1B9F             _strlen:
0084++ 1B9F DA          	push d
0085++ 1BA0 38 00 00    	mov c, 0
0086++ 1BA3             _strlen_L1:
0087++ 1BA3 BD 00       	cmp byte [d], 0
0088++ 1BA5 C6 AD 1B    	je _strlen_ret
0089++ 1BA8 79          	inc d
0090++ 1BA9 78          	inc c
0091++ 1BAA 0A A3 1B    	jmp _strlen_L1
0092++ 1BAD             _strlen_ret:
0093++ 1BAD E7          	pop d
0094++ 1BAE 09          	ret
0095++ 1BAF             
0096++ 1BAF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1BAF             ; STRCMP
0098++ 1BAF             ; compare two strings
0099++ 1BAF             ; str1 in SI
0100++ 1BAF             ; str2 in DI
0101++ 1BAF             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 1BAF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1BAF             _strcmp:
0104++ 1BAF DB          	push al
0105++ 1BB0 DA          	push d
0106++ 1BB1 E3          	push di
0107++ 1BB2 E2          	push si
0108++ 1BB3             _strcmp_loop:
0109++ 1BB3 F3          	cmpsb					; compare a byte of the strings
0110++ 1BB4 C7 BF 1B    	jne _strcmp_ret
0111++ 1BB7 FB FF FF    	lea d, [si +- 1]
0112++ 1BBA BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1BBC C7 B3 1B    	jne _strcmp_loop				; equal chars but not at end
0114++ 1BBF             _strcmp_ret:
0115++ 1BBF EF          	pop si
0116++ 1BC0 F0          	pop di
0117++ 1BC1 E7          	pop d
0118++ 1BC2 E8          	pop al
0119++ 1BC3 09          	ret
0120++ 1BC4             
0121++ 1BC4             
0122++ 1BC4             ; STRCPY
0123++ 1BC4             ; copy null terminated string from SI to DI
0124++ 1BC4             ; source in SI
0125++ 1BC4             ; destination in DI
0126++ 1BC4             _strcpy:
0127++ 1BC4 E2          	push si
0128++ 1BC5 E3          	push di
0129++ 1BC6 DB          	push al
0130++ 1BC7             _strcpy_L1:
0131++ 1BC7 F6          	lodsb
0132++ 1BC8 F7          	stosb
0133++ 1BC9 B9 00       	cmp al, 0
0134++ 1BCB C7 C7 1B    	jne _strcpy_L1
0135++ 1BCE             _strcpy_end:
0136++ 1BCE E8          	pop al
0137++ 1BCF F0          	pop di
0138++ 1BD0 EF          	pop si
0139++ 1BD1 09          	ret
0140++ 1BD2             
0141++ 1BD2             ; STRCAT
0142++ 1BD2             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 1BD2             ; source in SI
0144++ 1BD2             ; destination in DI
0145++ 1BD2             _strcat:
0146++ 1BD2 E2          	push si
0147++ 1BD3 E3          	push di
0148++ 1BD4 D7          	push a
0149++ 1BD5 DA          	push d
0150++ 1BD6 50          	mov a, di
0151++ 1BD7 3C          	mov d, a
0152++ 1BD8             _strcat_goto_end_L1:
0153++ 1BD8 BD 00       	cmp byte[d], 0
0154++ 1BDA C6 E1 1B    	je _strcat_start
0155++ 1BDD 79          	inc d
0156++ 1BDE 0A D8 1B    	jmp _strcat_goto_end_L1
0157++ 1BE1             _strcat_start:
0158++ 1BE1 FD 50       	mov di, d
0159++ 1BE3             _strcat_L1:
0160++ 1BE3 F6          	lodsb
0161++ 1BE4 F7          	stosb
0162++ 1BE5 B9 00       	cmp al, 0
0163++ 1BE7 C7 E3 1B    	jne _strcat_L1
0164++ 1BEA             _strcat_end:
0165++ 1BEA E7          	pop d
0166++ 1BEB E4          	pop a
0167++ 1BEC F0          	pop di
0168++ 1BED EF          	pop si
0169++ 1BEE 09          	ret
0170++ 1BEF             
0171++ 1BEF             
0005+  1BEF             
0006+  1BEF             ;-----------------------------------------------------------------------------
0007+  1BEF             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0008+  1BEF             ; ASCII in BL
0009+  1BEF             ; result in AL
0010+  1BEF             ; ascii for F = 0100 0110
0011+  1BEF             ; ascii for 9 = 0011 1001
0012+  1BEF             ;-----------------------------------------------------------------------------
0013+  1BEF             hex_ascii_encode:
0014+  1BEF 1B            mov al, bl
0015+  1BF0 93 40         test al, $40        ; test if letter or number
0016+  1BF2 C7 F8 1B      jnz hex_letter
0017+  1BF5 87 0F         and al, $0F        ; get number
0018+  1BF7 09            ret
0019+  1BF8             hex_letter:
0020+  1BF8 87 0F         and al, $0F        ; get letter
0021+  1BFA 6A 09         add al, 9
0022+  1BFC 09            ret
0023+  1BFD             
0024+  1BFD             ;-----------------------------------------------------------------------------
0025+  1BFD             ; ATOI
0026+  1BFD             ; 2 letter hex string in B
0027+  1BFD             ; 8bit integer returned in AL
0028+  1BFD             ;-----------------------------------------------------------------------------
0029+  1BFD             _atoi:
0030+  1BFD D8            push b
0031+  1BFE 07 EF 1B      call hex_ascii_encode      ; convert BL to 4bit code in AL
0032+  1C01 30            mov bl, bh
0033+  1C02 DB            push al          ; save a
0034+  1C03 07 EF 1B      call hex_ascii_encode
0035+  1C06 EA            pop bl  
0036+  1C07 FD 9E 04      shl al, 4
0037+  1C0A 8C            or al, bl
0038+  1C0B E5            pop b
0039+  1C0C 09            ret  
0040+  1C0D             
0041+  1C0D             
0042+  1C0D             ;-----------------------------------------------------------------------------
0043+  1C0D             ; ITOA
0044+  1C0D             ; 8bit value in BL
0045+  1C0D             ; 2 byte ASCII result in A
0046+  1C0D             ;-----------------------------------------------------------------------------
0047+  1C0D             _itoa:
0048+  1C0D DA            push d
0049+  1C0E D8            push b
0050+  1C0F A7 00         mov bh, 0
0051+  1C11 FD A4 04      shr bl, 4  
0052+  1C14 74            mov d, b
0053+  1C15 1F BD 1E      mov al, [d + s_hex_digits]
0054+  1C18 23            mov ah, al
0055+  1C19               
0056+  1C19 E5            pop b
0057+  1C1A D8            push b
0058+  1C1B A7 00         mov bh, 0
0059+  1C1D FD 87 0F      and bl, $0F
0060+  1C20 74            mov d, b
0061+  1C21 1F BD 1E      mov al, [d + s_hex_digits]
0062+  1C24 E5            pop b
0063+  1C25 E7            pop d
0064+  1C26 09            ret
0065+  1C27             
0066+  1C27             ;-----------------------------------------------------------------------------
0067+  1C27             ; HEX STRING TO BINARY
0068+  1C27             ; di = destination address
0069+  1C27             ; si = source
0070+  1C27             ;-----------------------------------------------------------------------------
0071+  1C27             _hex_to_int:
0072+  1C27             _hex_to_int_L1:
0073+  1C27 F6            lodsb          ; load from [SI] to AL
0074+  1C28 B9 00         cmp al, 0        ; check if ASCII 0
0075+  1C2A C6 37 1C      jz _hex_to_int_ret
0076+  1C2D 36            mov bh, al
0077+  1C2E F6            lodsb
0078+  1C2F 2F            mov bl, al
0079+  1C30 07 FD 1B      call _atoi        ; convert ASCII byte in B to int (to AL)
0080+  1C33 F7            stosb          ; store AL to [DI]
0081+  1C34 0A 27 1C      jmp _hex_to_int_L1
0082+  1C37             _hex_to_int_ret:
0083+  1C37 09            ret    
0084+  1C38             
0085+  1C38             ;-----------------------------------------------------------------------------
0086+  1C38             ; GETCHAR
0087+  1C38             ; char in ah
0088+  1C38             ;-----------------------------------------------------------------------------
0089+  1C38             getch:
0090+  1C38 DB            push al
0091+  1C39             getch_retry:
0092+  1C39 19 01         mov al, 1
0093+  1C3B 05 03         syscall sys_io      ; receive in AH
0094+  1C3D E8            pop al
0095+  1C3E 09            ret
0096+  1C3F             
0097+  1C3F             ;-----------------------------------------------------------------------------
0098+  1C3F             ; PUTCHAR
0099+  1C3F             ; char in ah
0100+  1C3F             ;-----------------------------------------------------------------------------
0101+  1C3F             _putchar:
0102+  1C3F D7            push a
0103+  1C40 19 00         mov al, 0
0104+  1C42 05 03         syscall sys_io      ; char in AH
0105+  1C44 E4            pop a
0106+  1C45 09            ret
0107+  1C46             
0108+  1C46             ;-----------------------------------------------------------------------------
0109+  1C46             ;; INPUT A STRING
0110+  1C46             ;; terminates with null
0111+  1C46             ;; pointer in D
0112+  1C46             ;-----------------------------------------------------------------------------
0113+  1C46             _gets:
0114+  1C46 D7            push a
0115+  1C47 DA            push d
0116+  1C48             _gets_loop:
0117+  1C48 19 01         mov al, 1
0118+  1C4A 05 03         syscall sys_io      ; receive in AH
0119+  1C4C B9 00         cmp al, 0        ; check error code (AL)
0120+  1C4E C6 48 1C      je _gets_loop      ; if no char received, retry
0121+  1C51             
0122+  1C51 76 1B         cmp ah, 27
0123+  1C53 C6 74 1C      je _gets_ansi_esc
0124+  1C56 76 0A         cmp ah, $0A        ; LF
0125+  1C58 C6 DF 1C      je _gets_end
0126+  1C5B 76 0D         cmp ah, $0D        ; CR
0127+  1C5D C6 DF 1C      je _gets_end
0128+  1C60 76 5C         cmp ah, $5C        ; '\\'
0129+  1C62 C6 A0 1C      je _gets_escape
0130+  1C65               
0131+  1C65 76 08         cmp ah, $08      ; check for backspace
0132+  1C67 C6 70 1C      je _gets_backspace
0133+  1C6A             
0134+  1C6A 1A            mov al, ah
0135+  1C6B 3E            mov [d], al
0136+  1C6C 79            inc d
0137+  1C6D 0A 48 1C      jmp _gets_loop
0138+  1C70             _gets_backspace:
0139+  1C70 7F            dec d
0140+  1C71 0A 48 1C      jmp _gets_loop
0141+  1C74             _gets_ansi_esc:
0142+  1C74 19 01         mov al, 1
0143+  1C76 05 03         syscall sys_io        ; receive in AH without echo
0144+  1C78 B9 00         cmp al, 0          ; check error code (AL)
0145+  1C7A C6 74 1C      je _gets_ansi_esc    ; if no char received, retry
0146+  1C7D 76 5B         cmp ah, '['
0147+  1C7F C7 48 1C      jne _gets_loop
0148+  1C82             _gets_ansi_esc_2:
0149+  1C82 19 01         mov al, 1
0150+  1C84 05 03         syscall sys_io          ; receive in AH without echo
0151+  1C86 B9 00         cmp al, 0            ; check error code (AL)
0152+  1C88 C6 82 1C      je _gets_ansi_esc_2  ; if no char received, retry
0153+  1C8B 76 44         cmp ah, 'D'
0154+  1C8D C6 98 1C      je _gets_left_arrow
0155+  1C90 76 43         cmp ah, 'C'
0156+  1C92 C6 9C 1C      je _gets_right_arrow
0157+  1C95 0A 48 1C      jmp _gets_loop
0158+  1C98             _gets_left_arrow:
0159+  1C98 7F            dec d
0160+  1C99 0A 48 1C      jmp _gets_loop
0161+  1C9C             _gets_right_arrow:
0162+  1C9C 79            inc d
0163+  1C9D 0A 48 1C      jmp _gets_loop
0164+  1CA0             _gets_escape:
0165+  1CA0 19 01         mov al, 1
0166+  1CA2 05 03         syscall sys_io      ; receive in AH
0167+  1CA4 B9 00         cmp al, 0        ; check error code (AL)
0168+  1CA6 C6 A0 1C      je _gets_escape      ; if no char received, retry
0169+  1CA9 76 6E         cmp ah, 'n'
0170+  1CAB C6 CA 1C      je _gets_LF
0171+  1CAE 76 72         cmp ah, 'r'
0172+  1CB0 C6 D1 1C      je _gets_CR
0173+  1CB3 76 30         cmp ah, '0'
0174+  1CB5 C6 D8 1C      je _gets_NULL
0175+  1CB8 76 5C         cmp ah, $5C  ; '\'
0176+  1CBA C6 C3 1C      je _gets_slash
0177+  1CBD 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0178+  1CBE 3E            mov [d], al
0179+  1CBF 79            inc d
0180+  1CC0 0A 48 1C      jmp _gets_loop
0181+  1CC3             _gets_slash:
0182+  1CC3 19 5C         mov al, $5C
0183+  1CC5 3E            mov [d], al
0184+  1CC6 79            inc d
0185+  1CC7 0A 48 1C      jmp _gets_loop
0186+  1CCA             _gets_LF:
0187+  1CCA 19 0A         mov al, $0A
0188+  1CCC 3E            mov [d], al
0189+  1CCD 79            inc d
0190+  1CCE 0A 48 1C      jmp _gets_loop
0191+  1CD1             _gets_CR:
0192+  1CD1 19 0D         mov al, $0D
0193+  1CD3 3E            mov [d], al
0194+  1CD4 79            inc d
0195+  1CD5 0A 48 1C      jmp _gets_loop
0196+  1CD8             _gets_NULL:
0197+  1CD8 19 00         mov al, $00
0198+  1CDA 3E            mov [d], al
0199+  1CDB 79            inc d
0200+  1CDC 0A 48 1C      jmp _gets_loop
0201+  1CDF             _gets_end:
0202+  1CDF 19 00         mov al, 0
0203+  1CE1 3E            mov [d], al        ; terminate string
0204+  1CE2 E7            pop d
0205+  1CE3 E4            pop a
0206+  1CE4 09            ret
0207+  1CE5             
0208+  1CE5             ;-----------------------------------------------------------------------------
0209+  1CE5             ;; INPUT TEXT
0210+  1CE5             ;; terminated with CTRL+D
0211+  1CE5             ;; pointer in D
0212+  1CE5             ;-----------------------------------------------------------------------------
0213+  1CE5             _gettxt:
0214+  1CE5 D7            push a
0215+  1CE6 DA            push d
0216+  1CE7             _gettxt_loop:
0217+  1CE7 19 01         mov al, 1
0218+  1CE9 05 03         syscall sys_io      ; receive in AH
0219+  1CEB B9 00         cmp al, 0        ; check error code (AL)
0220+  1CED C6 E7 1C      je _gettxt_loop    ; if no char received, retry
0221+  1CF0 76 04         cmp ah, 4      ; EOT
0222+  1CF2 C6 30 1D      je _gettxt_end
0223+  1CF5 76 08         cmp ah, $08      ; check for backspace
0224+  1CF7 C6 2C 1D      je _gettxt_backspace
0225+  1CFA 76 5C         cmp ah, $5C        ; '\'
0226+  1CFC C6 05 1D      je _gettxt_escape
0227+  1CFF 1A            mov al, ah
0228+  1D00 3E            mov [d], al
0229+  1D01 79            inc d
0230+  1D02 0A E7 1C      jmp _gettxt_loop
0231+  1D05             _gettxt_escape:
0232+  1D05 19 01         mov al, 1
0233+  1D07 05 03         syscall sys_io      ; receive in AH
0234+  1D09 B9 00         cmp al, 0        ; check error code (AL)
0235+  1D0B C6 05 1D      je _gettxt_escape    ; if no char received, retry
0236+  1D0E 76 6E         cmp ah, 'n'
0237+  1D10 C6 1E 1D      je _gettxt_LF
0238+  1D13 76 72         cmp ah, 'r'
0239+  1D15 C6 25 1D      je _gettxt_CR
0240+  1D18 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0241+  1D19 3E            mov [d], al
0242+  1D1A 79            inc d
0243+  1D1B 0A E7 1C      jmp _gettxt_loop
0244+  1D1E             _gettxt_LF:
0245+  1D1E 19 0A         mov al, $0A
0246+  1D20 3E            mov [d], al
0247+  1D21 79            inc d
0248+  1D22 0A E7 1C      jmp _gettxt_loop
0249+  1D25             _gettxt_CR:
0250+  1D25 19 0D         mov al, $0D
0251+  1D27 3E            mov [d], al
0252+  1D28 79            inc d
0253+  1D29 0A E7 1C      jmp _gettxt_loop
0254+  1D2C             _gettxt_backspace:
0255+  1D2C 7F            dec d
0256+  1D2D 0A E7 1C      jmp _gettxt_loop
0257+  1D30             _gettxt_end:
0258+  1D30 19 00         mov al, 0
0259+  1D32 3E            mov [d], al        ; terminate string
0260+  1D33 E7            pop d
0261+  1D34 E4            pop a
0262+  1D35 09            ret
0263+  1D36             
0264+  1D36             ;-----------------------------------------------------------------------------
0265+  1D36             ; PRINT NEW LINE
0266+  1D36             ;-----------------------------------------------------------------------------
0267+  1D36             printnl:
0268+  1D36 D7            push a
0269+  1D37 10 00 0A      mov a, $0A00
0270+  1D3A 05 03         syscall sys_io
0271+  1D3C 10 00 0D      mov a, $0D00
0272+  1D3F 05 03         syscall sys_io
0273+  1D41 E4            pop a
0274+  1D42 09            ret
0275+  1D43             
0276+  1D43             ;-----------------------------------------------------------------------------
0277+  1D43             ; _strtoint
0278+  1D43             ; 4 digit hex string number in d
0279+  1D43             ; integer returned in A
0280+  1D43             ;-----------------------------------------------------------------------------
0281+  1D43             _strtointx:
0282+  1D43 D8            push b
0283+  1D44 32            mov bl, [d]
0284+  1D45 37            mov bh, bl
0285+  1D46 33 01 00      mov bl, [d + 1]
0286+  1D49 07 FD 1B      call _atoi        ; convert to int in AL
0287+  1D4C 23            mov ah, al        ; move to AH
0288+  1D4D 33 02 00      mov bl, [d + 2]
0289+  1D50 37            mov bh, bl
0290+  1D51 33 03 00      mov bl, [d + 3]
0291+  1D54 07 FD 1B      call _atoi        ; convert to int in AL
0292+  1D57 E5            pop b
0293+  1D58 09            ret
0294+  1D59             
0295+  1D59             ;-----------------------------------------------------------------------------
0296+  1D59             ; _strtoint
0297+  1D59             ; 5 digit base10 string number in d
0298+  1D59             ; integer returned in A
0299+  1D59             ;-----------------------------------------------------------------------------
0300+  1D59             _strtoint:
0301+  1D59 E2            push si
0302+  1D5A D8            push b
0303+  1D5B D9            push c
0304+  1D5C DA            push d
0305+  1D5D 07 9F 1B      call _strlen      ; get string length in C
0306+  1D60 7E            dec c
0307+  1D61 FD 4E         mov si, d
0308+  1D63 12            mov a, c
0309+  1D64 FD 99         shl a
0310+  1D66 3B D5 1E      mov d, table_power
0311+  1D69 59            add d, a
0312+  1D6A 38 00 00      mov c, 0
0313+  1D6D             _strtoint_L0:
0314+  1D6D F6            lodsb      ; load ASCII to al
0315+  1D6E B9 00         cmp al, 0
0316+  1D70 C6 83 1D      je _strtoint_end
0317+  1D73 6F 30         sub al, $30    ; make into integer
0318+  1D75 22 00         mov ah, 0
0319+  1D77 2A            mov b, [d]
0320+  1D78 AC            mul a, b      ; result in B since it fits in 16bits
0321+  1D79 11            mov a, b
0322+  1D7A 28            mov b, c
0323+  1D7B 54            add a, b
0324+  1D7C 39            mov c, a
0325+  1D7D 63 02 00      sub d, 2
0326+  1D80 0A 6D 1D      jmp _strtoint_L0
0327+  1D83             _strtoint_end:
0328+  1D83 12            mov a, c
0329+  1D84 E7            pop d
0330+  1D85 E6            pop c
0331+  1D86 E5            pop b
0332+  1D87 EF            pop si
0333+  1D88 09            ret
0334+  1D89             
0335+  1D89             ;-----------------------------------------------------------------------------
0336+  1D89             ; PRINT NULL TERMINATED STRING
0337+  1D89             ; pointer in D
0338+  1D89             ;-----------------------------------------------------------------------------
0339+  1D89             _puts:
0340+  1D89 D7            push a
0341+  1D8A DA            push d
0342+  1D8B             _puts_L1:
0343+  1D8B 1E            mov al, [d]
0344+  1D8C B9 00         cmp al, 0
0345+  1D8E C6 9A 1D      jz _puts_END
0346+  1D91 23            mov ah, al
0347+  1D92 19 00         mov al, 0
0348+  1D94 05 03         syscall sys_io
0349+  1D96 79            inc d
0350+  1D97 0A 8B 1D      jmp _puts_L1
0351+  1D9A             _puts_END:
0352+  1D9A E7            pop d
0353+  1D9B E4            pop a
0354+  1D9C 09            ret
0355+  1D9D             
0356+  1D9D             ;-----------------------------------------------------------------------------
0357+  1D9D             ; PRINT N SIZE STRING
0358+  1D9D             ; pointer in D
0359+  1D9D             ; size in C
0360+  1D9D             ;-----------------------------------------------------------------------------
0361+  1D9D             _putsn:
0362+  1D9D DB            push al
0363+  1D9E DA            push d
0364+  1D9F D9            push c
0365+  1DA0             _putsn_L0:
0366+  1DA0 1E            mov al, [d]
0367+  1DA1 23            mov ah, al
0368+  1DA2 19 00         mov al, 0
0369+  1DA4 05 03         syscall sys_io
0370+  1DA6 79            inc d
0371+  1DA7 7E            dec c  
0372+  1DA8 C2 00 00      cmp c, 0
0373+  1DAB C7 A0 1D      jne _putsn_L0
0374+  1DAE             _putsn_end:
0375+  1DAE E6            pop c
0376+  1DAF E7            pop d
0377+  1DB0 E8            pop al
0378+  1DB1 09            ret
0379+  1DB2             
0380+  1DB2             ;-----------------------------------------------------------------------------
0381+  1DB2             ; print 16bit decimal number
0382+  1DB2             ; input number in A
0383+  1DB2             ;-----------------------------------------------------------------------------
0384+  1DB2             print_u16d:
0385+  1DB2 D7            push a
0386+  1DB3 D8            push b
0387+  1DB4 26 10 27      mov b, 10000
0388+  1DB7 AE            div a, b      ; get 10000's coeff.
0389+  1DB8 07 DA 1D      call print_number
0390+  1DBB 11            mov a, b
0391+  1DBC 26 E8 03      mov b, 1000
0392+  1DBF AE            div a, b      ; get 1000's coeff.
0393+  1DC0 07 DA 1D      call print_number
0394+  1DC3 11            mov a, b
0395+  1DC4 26 64 00      mov b, 100
0396+  1DC7 AE            div a, b
0397+  1DC8 07 DA 1D      call print_number
0398+  1DCB 11            mov a, b
0399+  1DCC 26 0A 00      mov b, 10
0400+  1DCF AE            div a, b
0401+  1DD0 07 DA 1D      call print_number
0402+  1DD3 1B            mov al, bl      ; 1's coeff in bl
0403+  1DD4 07 DA 1D      call print_number
0404+  1DD7 E5            pop b
0405+  1DD8 E4            pop a
0406+  1DD9 09            ret
0407+  1DDA             
0408+  1DDA             ;-----------------------------------------------------------------------------
0409+  1DDA             ; print AL
0410+  1DDA             ;-----------------------------------------------------------------------------
0411+  1DDA             print_number:
0412+  1DDA 6A 30         add al, $30
0413+  1DDC 23            mov ah, al
0414+  1DDD 07 3F 1C      call _putchar
0415+  1DE0 09            ret
0416+  1DE1             
0417+  1DE1             ;-----------------------------------------------------------------------------
0418+  1DE1             ; PRINT 16BIT HEX INTEGER
0419+  1DE1             ; integer value in reg B
0420+  1DE1             ;-----------------------------------------------------------------------------
0421+  1DE1             print_u16x:
0422+  1DE1 D7            push a
0423+  1DE2 D8            push b
0424+  1DE3 DD            push bl
0425+  1DE4 30            mov bl, bh
0426+  1DE5 07 0D 1C      call _itoa        ; convert bh to char in A
0427+  1DE8 2F            mov bl, al        ; save al
0428+  1DE9 19 00         mov al, 0
0429+  1DEB 05 03         syscall sys_io        ; display AH
0430+  1DED 24            mov ah, bl        ; retrieve al
0431+  1DEE 19 00         mov al, 0
0432+  1DF0 05 03         syscall sys_io        ; display AL
0433+  1DF2             
0434+  1DF2 EA            pop bl
0435+  1DF3 07 0D 1C      call _itoa        ; convert bh to char in A
0436+  1DF6 2F            mov bl, al        ; save al
0437+  1DF7 19 00         mov al, 0
0438+  1DF9 05 03         syscall sys_io        ; display AH
0439+  1DFB 24            mov ah, bl        ; retrieve al
0440+  1DFC 19 00         mov al, 0
0441+  1DFE 05 03         syscall sys_io        ; display AL
0442+  1E00             
0443+  1E00 E5            pop b
0444+  1E01 E4            pop a
0445+  1E02 09            ret
0446+  1E03             
0447+  1E03             ;-----------------------------------------------------------------------------
0448+  1E03             ; INPUT 16BIT HEX INTEGER
0449+  1E03             ; read 16bit integer into A
0450+  1E03             ;-----------------------------------------------------------------------------
0451+  1E03             scan_u16x:
0452+  1E03 F8 10 00      enter 16
0453+  1E06 D8            push b
0454+  1E07 DA            push d
0455+  1E08             
0456+  1E08 FA F1 FF      lea d, [bp + -15]
0457+  1E0B 07 46 1C      call _gets        ; get number
0458+  1E0E             
0459+  1E0E 32            mov bl, [d]
0460+  1E0F 37            mov bh, bl
0461+  1E10 33 01 00      mov bl, [d + 1]
0462+  1E13 07 FD 1B      call _atoi        ; convert to int in AL
0463+  1E16 23            mov ah, al        ; move to AH
0464+  1E17             
0465+  1E17 33 02 00      mov bl, [d + 2]
0466+  1E1A 37            mov bh, bl
0467+  1E1B 33 03 00      mov bl, [d + 3]
0468+  1E1E 07 FD 1B      call _atoi        ; convert to int in AL
0469+  1E21             
0470+  1E21 E7            pop d
0471+  1E22 E5            pop b
0472+  1E23 F9            leave
0473+  1E24 09            ret
0474+  1E25             
0475+  1E25             ;-----------------------------------------------------------------------------
0476+  1E25             ; PRINT 8bit HEX INTEGER
0477+  1E25             ; integer value in reg bl
0478+  1E25             ;-----------------------------------------------------------------------------
0479+  1E25             print_u8x:
0480+  1E25 D7            push a
0481+  1E26 DD            push bl
0482+  1E27             
0483+  1E27 07 0D 1C      call _itoa        ; convert bl to char in A
0484+  1E2A 2F            mov bl, al        ; save al
0485+  1E2B 19 00         mov al, 0
0486+  1E2D 05 03         syscall sys_io        ; display AH
0487+  1E2F 24            mov ah, bl        ; retrieve al
0488+  1E30 19 00         mov al, 0
0489+  1E32 05 03         syscall sys_io        ; display AL
0490+  1E34             
0491+  1E34 EA            pop bl
0492+  1E35 E4            pop a
0493+  1E36 09            ret
0494+  1E37             
0495+  1E37             ;-----------------------------------------------------------------------------
0496+  1E37             ; print 8bit decimal unsigned number
0497+  1E37             ; input number in AL
0498+  1E37             ;-----------------------------------------------------------------------------
0499+  1E37             print_u8d:
0500+  1E37 D7            push a
0501+  1E38 D8            push b
0502+  1E39             
0503+  1E39 22 00         mov ah, 0
0504+  1E3B 26 64 00      mov b, 100
0505+  1E3E AE            div a, b
0506+  1E3F D8            push b      ; save remainder
0507+  1E40 B9 00         cmp al, 0
0508+  1E42 C6 4C 1E      je skip100
0509+  1E45 6A 30         add al, $30
0510+  1E47 23            mov ah, al
0511+  1E48 19 00         mov al, 0
0512+  1E4A 05 03         syscall sys_io  ; print coeff
0513+  1E4C             skip100:
0514+  1E4C E4            pop a
0515+  1E4D 22 00         mov ah, 0
0516+  1E4F 26 0A 00      mov b, 10
0517+  1E52 AE            div a, b
0518+  1E53 D8            push b      ; save remainder
0519+  1E54 B9 00         cmp al, 0
0520+  1E56 C6 60 1E      je skip10
0521+  1E59 6A 30         add al, $30
0522+  1E5B 23            mov ah, al
0523+  1E5C 19 00         mov al, 0
0524+  1E5E 05 03         syscall sys_io  ; print coeff
0525+  1E60             skip10:
0526+  1E60 E4            pop a
0527+  1E61 1B            mov al, bl
0528+  1E62 6A 30         add al, $30
0529+  1E64 23            mov ah, al
0530+  1E65 19 00         mov al, 0
0531+  1E67 05 03         syscall sys_io  ; print coeff
0532+  1E69 E5            pop b
0533+  1E6A E4            pop a
0534+  1E6B 09            ret
0535+  1E6C             
0536+  1E6C             ;-----------------------------------------------------------------------------
0537+  1E6C             ; INPUT 8BIT HEX INTEGER
0538+  1E6C             ; read 8bit integer into AL
0539+  1E6C             ;-----------------------------------------------------------------------------
0540+  1E6C             scan_u8x:
0541+  1E6C F8 04 00      enter 4
0542+  1E6F D8            push b
0543+  1E70 DA            push d
0544+  1E71             
0545+  1E71 FA FD FF      lea d, [bp + -3]
0546+  1E74 07 46 1C      call _gets        ; get number
0547+  1E77             
0548+  1E77 32            mov bl, [d]
0549+  1E78 37            mov bh, bl
0550+  1E79 33 01 00      mov bl, [d + 1]
0551+  1E7C 07 FD 1B      call _atoi        ; convert to int in AL
0552+  1E7F             
0553+  1E7F E7            pop d
0554+  1E80 E5            pop b
0555+  1E81 F9            leave
0556+  1E82 09            ret
0557+  1E83             
0558+  1E83             ;-----------------------------------------------------------------------------
0559+  1E83             ; input decimal number
0560+  1E83             ; result in A
0561+  1E83             ; 655'\0'
0562+  1E83             ; low--------high
0563+  1E83             ;-----------------------------------------------------------------------------
0564+  1E83             scan_u16d:
0565+  1E83 F8 08 00      enter 8
0566+  1E86 E2            push si
0567+  1E87 D8            push b
0568+  1E88 D9            push c
0569+  1E89 DA            push d
0570+  1E8A FA F9 FF      lea d, [bp +- 7]
0571+  1E8D 07 46 1C      call _gets
0572+  1E90 07 9F 1B      call _strlen      ; get string length in C
0573+  1E93 7E            dec c
0574+  1E94 FD 4E         mov si, d
0575+  1E96 12            mov a, c
0576+  1E97 FD 99         shl a
0577+  1E99 3B D5 1E      mov d, table_power
0578+  1E9C 59            add d, a
0579+  1E9D 38 00 00      mov c, 0
0580+  1EA0             mul_loop:
0581+  1EA0 F6            lodsb      ; load ASCII to al
0582+  1EA1 B9 00         cmp al, 0
0583+  1EA3 C6 B6 1E      je mul_exit
0584+  1EA6 6F 30         sub al, $30    ; make into integer
0585+  1EA8 22 00         mov ah, 0
0586+  1EAA 2A            mov b, [d]
0587+  1EAB AC            mul a, b      ; result in B since it fits in 16bits
0588+  1EAC 11            mov a, b
0589+  1EAD 28            mov b, c
0590+  1EAE 54            add a, b
0591+  1EAF 39            mov c, a
0592+  1EB0 63 02 00      sub d, 2
0593+  1EB3 0A A0 1E      jmp mul_loop
0594+  1EB6             mul_exit:
0595+  1EB6 12            mov a, c
0596+  1EB7 E7            pop d
0597+  1EB8 E6            pop c
0598+  1EB9 E5            pop b
0599+  1EBA EF            pop si
0600+  1EBB F9            leave
0601+  1EBC 09            ret
0602+  1EBD             
0603+  1EBD 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0603+  1EC1 34 35 36 37 
0603+  1EC5 38 39 41 42 
0603+  1EC9 43 44 45 46 
0604+  1ECD 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0604+  1ED1 1B 5B 48 00 
0605+  1ED5             
0606+  1ED5             table_power:
0607+  1ED5 01 00         .dw 1
0608+  1ED7 0A 00         .dw 10
0609+  1ED9 64 00         .dw 100
0610+  1EDB E8 03         .dw 1000
0611+  1EDD 10 27         .dw 100003724   1EDF             ; --- END INLINE ASM SEGMENT
3725   1EDF             
3726   1EDF F9            leave
3727   1EE0 09            ret
3728   1EE1             ; --- END TEXT SEGMENT
3729   1EE1             
3730   1EE1             ; --- BEGIN DATA SEGMENT
3731   1EE1 00 00 00 00 _s_data: .fill 256, 0
3731   1EE5 00 00 00 00 
3731   1EE9 00 00 00 00 
3731   1EED 00 00 00 00 
3731   1EF1 00 00 00 00 
3731   1EF5 00 00 00 00 
3731   1EF9 00 00 00 00 
3731   1EFD 00 00 00 00 
3731   1F01 00 00 00 00 
3731   1F05 00 00 00 00 
3731   1F09 00 00 00 00 
3731   1F0D 00 00 00 00 
3731   1F11 00 00 00 00 
3731   1F15 00 00 00 00 
3731   1F19 00 00 00 00 
3731   1F1D 00 00 00 00 
3731   1F21 00 00 00 00 
3731   1F25 00 00 00 00 
3731   1F29 00 00 00 00 
3731   1F2D 00 00 00 00 
3731   1F31 00 00 00 00 
3731   1F35 00 00 00 00 
3731   1F39 00 00 00 00 
3731   1F3D 00 00 00 00 
3731   1F41 00 00 00 00 
3731   1F45 00 00 00 00 
3731   1F49 00 00 00 00 
3731   1F4D 00 00 00 00 
3731   1F51 00 00 00 00 
3731   1F55 00 00 00 00 
3731   1F59 00 00 00 00 
3731   1F5D 00 00 00 00 
3731   1F61 00 00 00 00 
3731   1F65 00 00 00 00 
3731   1F69 00 00 00 00 
3731   1F6D 00 00 00 00 
3731   1F71 00 00 00 00 
3731   1F75 00 00 00 00 
3731   1F79 00 00 00 00 
3731   1F7D 00 00 00 00 
3731   1F81 00 00 00 00 
3731   1F85 00 00 00 00 
3731   1F89 00 00 00 00 
3731   1F8D 00 00 00 00 
3731   1F91 00 00 00 00 
3731   1F95 00 00 00 00 
3731   1F99 00 00 00 00 
3731   1F9D 00 00 00 00 
3731   1FA1 00 00 00 00 
3731   1FA5 00 00 00 00 
3731   1FA9 00 00 00 00 
3731   1FAD 00 00 00 00 
3731   1FB1 00 00 00 00 
3731   1FB5 00 00 00 00 
3731   1FB9 00 00 00 00 
3731   1FBD 00 00 00 00 
3731   1FC1 00 00 00 00 
3731   1FC5 00 00 00 00 
3731   1FC9 00 00 00 00 
3731   1FCD 00 00 00 00 
3731   1FD1 00 00 00 00 
3731   1FD5 00 00 00 00 
3731   1FD9 00 00 00 00 
3731   1FDD 00 00 00 00 
3732   1FE1             _ss_data: 
3733   1FE1 EB          .db _s0, 
3734   1FE2 00 00 00 00 .fill 9, 0
3734   1FE6 00 00 00 00 
3734   1FEA 00 
3735   1FEB 48 65 6C 6C _s0: .db "Hello", 0
3735   1FEF 6F 00 
3736   1FF1 48 65 6C 6C _s1: .db "Hello World!", 0
3736   1FF5 6F 20 57 6F 
3736   1FF9 72 6C 64 21 
3736   1FFD 00 
3737   1FFE 49 6E 74 65 _s2: .db "Integer: %d, Char: %c, String: %s\n\n", 0
3737   2002 67 65 72 3A 
3737   2006 20 25 64 2C 
3737   200A 20 43 68 61 
3737   200E 72 3A 20 25 
3737   2012 63 2C 20 53 
3737   2016 74 72 69 6E 
3737   201A 67 3A 20 25 
3737   201E 73 0A 0A 00 
3738   2022 46 69 6E 61 _s3: .db "Final String: %s", 0
3738   2026 6C 20 53 74 
3738   202A 72 69 6E 67 
3738   202E 3A 20 25 73 
3738   2032 00 
3739   2033 55 6E 65 78 _s4: .db "Unexpected format in printf.", 0
3739   2037 70 65 63 74 
3739   203B 65 64 20 66 
3739   203F 6F 72 6D 61 
3739   2043 74 20 69 6E 
3739   2047 20 70 72 69 
3739   204B 6E 74 66 2E 
3739   204F 00 
3740   2050 45 72 72 6F _s5: .db "Error: Unknown argument type.\n", 0
3740   2054 72 3A 20 55 
3740   2058 6E 6B 6E 6F 
3740   205C 77 6E 20 61 
3740   2060 72 67 75 6D 
3740   2064 65 6E 74 20 
3740   2068 74 79 70 65 
3740   206C 2E 0A 00 
3741   206F 1B 5B 32 4A _s6: .db "\033[2J\033[H", 0
3741   2073 1B 5B 48 00 
3742   2077             
3743   2077 79 20       _heap_top: .dw _heap
3744   2079 00          _heap: .db 0
3745   207A             ; --- END DATA SEGMENT
3746   207A             
3747   207A             .end
tasm: Number of errors = 0
