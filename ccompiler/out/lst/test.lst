0001   0000             ; --- FILENAME: test
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ;; base64_decode(input, output); 
0011   0408 3B 46 22      mov d, _output_data ; $output
0012   040B 2D            mov b, d
0013   040C FD AB         swp b
0014   040E D8            push b
0015   040F 3B 44 22      mov d, _input ; $input
0016   0412 2A            mov b, [d]
0017   0413 FD AB         swp b
0018   0415 D8            push b
0019   0416 07 76 1A      call base64_decode
0020   0419 51 04 00      add sp, 4
0021   041C             ;; printf("\nResult: %d. Section: %d\n", pass, section); 
0022   041C 3B 48 24      mov d, _section ; $section
0023   041F 2A            mov b, [d]
0024   0420 FD AB         swp b
0025   0422 D8            push b
0026   0423 3B 46 24      mov d, _pass ; $pass
0027   0426 2A            mov b, [d]
0028   0427 FD AB         swp b
0029   0429 D8            push b
0030   042A 26 4A 24      mov b, _s0 ; "\nResult: %d. Section: %d\n"
0031   042D FD AB         swp b
0032   042F D8            push b
0033   0430 07 E9 07      call printf
0034   0433 51 06 00      add sp, 6
0035   0436             ;; printf(output); 
0036   0436 3B 46 22      mov d, _output_data ; $output
0037   0439 2D            mov b, d
0038   043A FD AB         swp b
0039   043C D8            push b
0040   043D 07 E9 07      call printf
0041   0440 51 02 00      add sp, 2
0042   0443 05 0B         syscall sys_terminate_proc
0043   0445             
0044   0445             strcpy:
0045   0445 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0046   0448             ;; char *psrc; 
0047   0448 52 02 00      sub sp, 2 ; psrc
0048   044B             ;; char *pdest; 
0049   044B 52 02 00      sub sp, 2 ; pdest
0050   044E             ;; psrc = src; 
0051   044E FA FF FF      lea d, [bp + -1] ; $psrc
0052   0451 DA            push d
0053   0452 FA 07 00      lea d, [bp + 7] ; $src
0054   0455 2A            mov b, [d]
0055   0456 E7            pop d
0056   0457 FD 43         mov [d], b
0057   0459             ;; pdest = dest; 
0058   0459 FA FD FF      lea d, [bp + -3] ; $pdest
0059   045C DA            push d
0060   045D FA 05 00      lea d, [bp + 5] ; $dest
0061   0460 2A            mov b, [d]
0062   0461 E7            pop d
0063   0462 FD 43         mov [d], b
0064   0464             ;; while(*psrc) *pdest++ = *psrc++; 
0065   0464             _while1_cond:
0066   0464 FA FF FF      lea d, [bp + -1] ; $psrc
0067   0467 2A            mov b, [d]
0068   0468 74            mov d, b
0069   0469 32            mov bl, [d]
0070   046A A7 00         mov bh, 0
0071   046C C0 00 00      cmp b, 0
0072   046F C6 97 04      je _while1_exit
0073   0472             _while1_block:
0074   0472             ;; *pdest++ = *psrc++; 
0075   0472 FA FD FF      lea d, [bp + -3] ; $pdest
0076   0475 2A            mov b, [d]
0077   0476 FD 77         inc b
0078   0478 FA FD FF      lea d, [bp + -3] ; $pdest
0079   047B FD 43         mov [d], b
0080   047D FD 7D         dec b
0081   047F D8            push b
0082   0480 FA FF FF      lea d, [bp + -1] ; $psrc
0083   0483 2A            mov b, [d]
0084   0484 FD 77         inc b
0085   0486 FA FF FF      lea d, [bp + -1] ; $psrc
0086   0489 FD 43         mov [d], b
0087   048B FD 7D         dec b
0088   048D 74            mov d, b
0089   048E 32            mov bl, [d]
0090   048F A7 00         mov bh, 0
0091   0491 E7            pop d
0092   0492 FD 3E         mov [d], bl
0093   0494 0A 64 04      jmp _while1_cond
0094   0497             _while1_exit:
0095   0497             ;; *pdest = '\0'; 
0096   0497 FA FD FF      lea d, [bp + -3] ; $pdest
0097   049A 2A            mov b, [d]
0098   049B D8            push b
0099   049C 26 00 00      mov b, $0
0100   049F E7            pop d
0101   04A0 FD 3E         mov [d], bl
0102   04A2 F9            leave
0103   04A3 09            ret
0104   04A4             
0105   04A4             strcmp:
0106   04A4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0107   04A7             ;; while (*s1 && (*s1 == *s2)) { 
0108   04A7             _while2_cond:
0109   04A7 FA 05 00      lea d, [bp + 5] ; $s1
0110   04AA 2A            mov b, [d]
0111   04AB 74            mov d, b
0112   04AC 32            mov bl, [d]
0113   04AD A7 00         mov bh, 0
0114   04AF             ; START LOGICAL AND
0115   04AF D7            push a
0116   04B0 11            mov a, b
0117   04B1 FA 05 00      lea d, [bp + 5] ; $s1
0118   04B4 2A            mov b, [d]
0119   04B5 74            mov d, b
0120   04B6 32            mov bl, [d]
0121   04B7 A7 00         mov bh, 0
0122   04B9             ; START RELATIONAL
0123   04B9 D7            push a
0124   04BA 11            mov a, b
0125   04BB FA 07 00      lea d, [bp + 7] ; $s2
0126   04BE 2A            mov b, [d]
0127   04BF 74            mov d, b
0128   04C0 32            mov bl, [d]
0129   04C1 A7 00         mov bh, 0
0130   04C3 B0            cmp a, b
0131   04C4 FD 71         seq ; ==
0132   04C6 E4            pop a
0133   04C7             ; END RELATIONAL
0134   04C7 FD A7         sand a, b
0135   04C9 E4            pop a
0136   04CA             ; END LOGICAL AND
0137   04CA C0 00 00      cmp b, 0
0138   04CD C6 ED 04      je _while2_exit
0139   04D0             _while2_block:
0140   04D0             ;; s1++; 
0141   04D0 FA 05 00      lea d, [bp + 5] ; $s1
0142   04D3 2A            mov b, [d]
0143   04D4 FD 77         inc b
0144   04D6 FA 05 00      lea d, [bp + 5] ; $s1
0145   04D9 FD 43         mov [d], b
0146   04DB FD 7D         dec b
0147   04DD             ;; s2++; 
0148   04DD FA 07 00      lea d, [bp + 7] ; $s2
0149   04E0 2A            mov b, [d]
0150   04E1 FD 77         inc b
0151   04E3 FA 07 00      lea d, [bp + 7] ; $s2
0152   04E6 FD 43         mov [d], b
0153   04E8 FD 7D         dec b
0154   04EA 0A A7 04      jmp _while2_cond
0155   04ED             _while2_exit:
0156   04ED             ;; return *s1 - *s2; 
0157   04ED FA 05 00      lea d, [bp + 5] ; $s1
0158   04F0 2A            mov b, [d]
0159   04F1 74            mov d, b
0160   04F2 32            mov bl, [d]
0161   04F3 A7 00         mov bh, 0
0162   04F5             ; START TERMS
0163   04F5 D7            push a
0164   04F6 11            mov a, b
0165   04F7 FA 07 00      lea d, [bp + 7] ; $s2
0166   04FA 2A            mov b, [d]
0167   04FB 74            mov d, b
0168   04FC 32            mov bl, [d]
0169   04FD A7 00         mov bh, 0
0170   04FF 60            sub a, b
0171   0500 27            mov b, a
0172   0501 E4            pop a
0173   0502             ; END TERMS
0174   0502 F9            leave
0175   0503 09            ret
0176   0504             
0177   0504             strncmp:
0178   0504 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0179   0507 F9            leave
0180   0508 09            ret
0181   0509             
0182   0509             strcat:
0183   0509 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0184   050C             ;; int dest_len; 
0185   050C 52 02 00      sub sp, 2 ; dest_len
0186   050F             ;; int i; 
0187   050F 52 02 00      sub sp, 2 ; i
0188   0512             ;; dest_len = strlen(dest); 
0189   0512 FA FF FF      lea d, [bp + -1] ; $dest_len
0190   0515 DA            push d
0191   0516 FA 05 00      lea d, [bp + 5] ; $dest
0192   0519 2A            mov b, [d]
0193   051A FD AB         swp b
0194   051C D8            push b
0195   051D 07 BF 05      call strlen
0196   0520 51 02 00      add sp, 2
0197   0523 E7            pop d
0198   0524 FD 43         mov [d], b
0199   0526             ;; for (i = 0; src[i] != 0; i=i+1) { 
0200   0526             _for3_init:
0201   0526 FA FD FF      lea d, [bp + -3] ; $i
0202   0529 DA            push d
0203   052A 26 00 00      mov b, $0
0204   052D E7            pop d
0205   052E FD 43         mov [d], b
0206   0530             _for3_cond:
0207   0530 FA 07 00      lea d, [bp + 7] ; $src
0208   0533 FD 2A         mov d, [d]
0209   0535 D7            push a
0210   0536 DA            push d
0211   0537 FA FD FF      lea d, [bp + -3] ; $i
0212   053A 2A            mov b, [d]
0213   053B E7            pop d
0214   053C FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0215   0540 E4            pop a
0216   0541 32            mov bl, [d]
0217   0542 A7 00         mov bh, 0
0218   0544             ; START RELATIONAL
0219   0544 D7            push a
0220   0545 11            mov a, b
0221   0546 26 00 00      mov b, $0
0222   0549 B0            cmp a, b
0223   054A FD 72         sneq ; !=
0224   054C E4            pop a
0225   054D             ; END RELATIONAL
0226   054D C0 00 00      cmp b, 0
0227   0550 C6 99 05      je _for3_exit
0228   0553             _for3_block:
0229   0553             ;; dest[dest_len + i] = src[i]; 
0230   0553 FA 05 00      lea d, [bp + 5] ; $dest
0231   0556 FD 2A         mov d, [d]
0232   0558 D7            push a
0233   0559 DA            push d
0234   055A FA FF FF      lea d, [bp + -1] ; $dest_len
0235   055D 2A            mov b, [d]
0236   055E             ; START TERMS
0237   055E D7            push a
0238   055F 11            mov a, b
0239   0560 FA FD FF      lea d, [bp + -3] ; $i
0240   0563 2A            mov b, [d]
0241   0564 56            add b, a
0242   0565 E4            pop a
0243   0566             ; END TERMS
0244   0566 E7            pop d
0245   0567 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0246   056B E4            pop a
0247   056C DA            push d
0248   056D FA 07 00      lea d, [bp + 7] ; $src
0249   0570 FD 2A         mov d, [d]
0250   0572 D7            push a
0251   0573 DA            push d
0252   0574 FA FD FF      lea d, [bp + -3] ; $i
0253   0577 2A            mov b, [d]
0254   0578 E7            pop d
0255   0579 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0256   057D E4            pop a
0257   057E 32            mov bl, [d]
0258   057F A7 00         mov bh, 0
0259   0581 E7            pop d
0260   0582 FD 3E         mov [d], bl
0261   0584             _for3_update:
0262   0584 FA FD FF      lea d, [bp + -3] ; $i
0263   0587 DA            push d
0264   0588 FA FD FF      lea d, [bp + -3] ; $i
0265   058B 2A            mov b, [d]
0266   058C             ; START TERMS
0267   058C D7            push a
0268   058D 11            mov a, b
0269   058E 26 01 00      mov b, $1
0270   0591 56            add b, a
0271   0592 E4            pop a
0272   0593             ; END TERMS
0273   0593 E7            pop d
0274   0594 FD 43         mov [d], b
0275   0596 0A 30 05      jmp _for3_cond
0276   0599             _for3_exit:
0277   0599             ;; dest[dest_len + i] = 0; 
0278   0599 FA 05 00      lea d, [bp + 5] ; $dest
0279   059C FD 2A         mov d, [d]
0280   059E D7            push a
0281   059F DA            push d
0282   05A0 FA FF FF      lea d, [bp + -1] ; $dest_len
0283   05A3 2A            mov b, [d]
0284   05A4             ; START TERMS
0285   05A4 D7            push a
0286   05A5 11            mov a, b
0287   05A6 FA FD FF      lea d, [bp + -3] ; $i
0288   05A9 2A            mov b, [d]
0289   05AA 56            add b, a
0290   05AB E4            pop a
0291   05AC             ; END TERMS
0292   05AC E7            pop d
0293   05AD FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0294   05B1 E4            pop a
0295   05B2 DA            push d
0296   05B3 26 00 00      mov b, $0
0297   05B6 E7            pop d
0298   05B7 FD 3E         mov [d], bl
0299   05B9             ;; return dest; 
0300   05B9 FA 05 00      lea d, [bp + 5] ; $dest
0301   05BC 2A            mov b, [d]
0302   05BD F9            leave
0303   05BE 09            ret
0304   05BF             
0305   05BF             strlen:
0306   05BF F8 00 00      enter 0 ; (push bp; mov bp, sp)
0307   05C2             ;; int length; 
0308   05C2 52 02 00      sub sp, 2 ; length
0309   05C5             ;; length = 0; 
0310   05C5 FA FF FF      lea d, [bp + -1] ; $length
0311   05C8 DA            push d
0312   05C9 26 00 00      mov b, $0
0313   05CC E7            pop d
0314   05CD FD 43         mov [d], b
0315   05CF             ;; while (str[length] != 0) { 
0316   05CF             _while4_cond:
0317   05CF FA 05 00      lea d, [bp + 5] ; $str
0318   05D2 FD 2A         mov d, [d]
0319   05D4 D7            push a
0320   05D5 DA            push d
0321   05D6 FA FF FF      lea d, [bp + -1] ; $length
0322   05D9 2A            mov b, [d]
0323   05DA E7            pop d
0324   05DB FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0325   05DF E4            pop a
0326   05E0 32            mov bl, [d]
0327   05E1 A7 00         mov bh, 0
0328   05E3             ; START RELATIONAL
0329   05E3 D7            push a
0330   05E4 11            mov a, b
0331   05E5 26 00 00      mov b, $0
0332   05E8 B0            cmp a, b
0333   05E9 FD 72         sneq ; !=
0334   05EB E4            pop a
0335   05EC             ; END RELATIONAL
0336   05EC C0 00 00      cmp b, 0
0337   05EF C6 02 06      je _while4_exit
0338   05F2             _while4_block:
0339   05F2             ;; length++; 
0340   05F2 FA FF FF      lea d, [bp + -1] ; $length
0341   05F5 2A            mov b, [d]
0342   05F6 FD 77         inc b
0343   05F8 FA FF FF      lea d, [bp + -1] ; $length
0344   05FB FD 43         mov [d], b
0345   05FD FD 7D         dec b
0346   05FF 0A CF 05      jmp _while4_cond
0347   0602             _while4_exit:
0348   0602             ;; return length; 
0349   0602 FA FF FF      lea d, [bp + -1] ; $length
0350   0605 2A            mov b, [d]
0351   0606 F9            leave
0352   0607 09            ret
0353   0608             
0354   0608             exit:
0355   0608 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0356   060B             
0357   060B             ; --- BEGIN INLINE ASM BLOCK
0358   060B 05 0B         syscall sys_terminate_proc
0359   060D             ; --- END INLINE ASM BLOCK
0360   060D             
0361   060D F9            leave
0362   060E 09            ret
0363   060F             
0364   060F             memset:
0365   060F F8 00 00      enter 0 ; (push bp; mov bp, sp)
0366   0612             ;; int i; 
0367   0612 52 02 00      sub sp, 2 ; i
0368   0615             ;; for(i = 0; i < size; i++){ 
0369   0615             _for5_init:
0370   0615 FA FF FF      lea d, [bp + -1] ; $i
0371   0618 DA            push d
0372   0619 26 00 00      mov b, $0
0373   061C E7            pop d
0374   061D FD 43         mov [d], b
0375   061F             _for5_cond:
0376   061F FA FF FF      lea d, [bp + -1] ; $i
0377   0622 2A            mov b, [d]
0378   0623             ; START RELATIONAL
0379   0623 D7            push a
0380   0624 11            mov a, b
0381   0625 FA 08 00      lea d, [bp + 8] ; $size
0382   0628 2A            mov b, [d]
0383   0629 B0            cmp a, b
0384   062A FD 73         slt ; < (signed)
0385   062C E4            pop a
0386   062D             ; END RELATIONAL
0387   062D C0 00 00      cmp b, 0
0388   0630 C6 59 06      je _for5_exit
0389   0633             _for5_block:
0390   0633             ;; *(s+i) = c; 
0391   0633 FA 05 00      lea d, [bp + 5] ; $s
0392   0636 2A            mov b, [d]
0393   0637             ; START TERMS
0394   0637 D7            push a
0395   0638 11            mov a, b
0396   0639 FA FF FF      lea d, [bp + -1] ; $i
0397   063C 2A            mov b, [d]
0398   063D 56            add b, a
0399   063E E4            pop a
0400   063F             ; END TERMS
0401   063F D8            push b
0402   0640 FA 07 00      lea d, [bp + 7] ; $c
0403   0643 32            mov bl, [d]
0404   0644 A7 00         mov bh, 0
0405   0646 E7            pop d
0406   0647 FD 3E         mov [d], bl
0407   0649             _for5_update:
0408   0649 FA FF FF      lea d, [bp + -1] ; $i
0409   064C 2A            mov b, [d]
0410   064D FD 77         inc b
0411   064F FA FF FF      lea d, [bp + -1] ; $i
0412   0652 FD 43         mov [d], b
0413   0654 FD 7D         dec b
0414   0656 0A 1F 06      jmp _for5_cond
0415   0659             _for5_exit:
0416   0659             ;; return s; 
0417   0659 FA 05 00      lea d, [bp + 5] ; $s
0418   065C 2A            mov b, [d]
0419   065D F9            leave
0420   065E 09            ret
0421   065F             
0422   065F             atoi:
0423   065F F8 00 00      enter 0 ; (push bp; mov bp, sp)
0424   0662             ;; int result = 0;  // Initialize result 
0425   0662 52 02 00      sub sp, 2 ; result
0426   0665             ; --- START LOCAL VAR INITIALIZATION
0427   0665 FA FF FF      lea d, [bp + -1] ; $result
0428   0668 DA            push d
0429   0669 26 00 00      mov b, $0
0430   066C E7            pop d
0431   066D FD 43         mov [d], b
0432   066F             ; --- END LOCAL VAR INITIALIZATION
0433   066F             ;; int sign = 1;    // Initialize sign as positive 
0434   066F 52 02 00      sub sp, 2 ; sign
0435   0672             ; --- START LOCAL VAR INITIALIZATION
0436   0672 FA FD FF      lea d, [bp + -3] ; $sign
0437   0675 DA            push d
0438   0676 26 01 00      mov b, $1
0439   0679 E7            pop d
0440   067A FD 43         mov [d], b
0441   067C             ; --- END LOCAL VAR INITIALIZATION
0442   067C             ;; while (*str == ' ') str++; 
0443   067C             _while6_cond:
0444   067C FA 05 00      lea d, [bp + 5] ; $str
0445   067F 2A            mov b, [d]
0446   0680 74            mov d, b
0447   0681 32            mov bl, [d]
0448   0682 A7 00         mov bh, 0
0449   0684             ; START RELATIONAL
0450   0684 D7            push a
0451   0685 11            mov a, b
0452   0686 26 20 00      mov b, $20
0453   0689 B0            cmp a, b
0454   068A FD 71         seq ; ==
0455   068C E4            pop a
0456   068D             ; END RELATIONAL
0457   068D C0 00 00      cmp b, 0
0458   0690 C6 A3 06      je _while6_exit
0459   0693             _while6_block:
0460   0693             ;; str++; 
0461   0693 FA 05 00      lea d, [bp + 5] ; $str
0462   0696 2A            mov b, [d]
0463   0697 FD 77         inc b
0464   0699 FA 05 00      lea d, [bp + 5] ; $str
0465   069C FD 43         mov [d], b
0466   069E FD 7D         dec b
0467   06A0 0A 7C 06      jmp _while6_cond
0468   06A3             _while6_exit:
0469   06A3             ;; if (*str == '-' || *str == '+') { 
0470   06A3             _if7_cond:
0471   06A3 FA 05 00      lea d, [bp + 5] ; $str
0472   06A6 2A            mov b, [d]
0473   06A7 74            mov d, b
0474   06A8 32            mov bl, [d]
0475   06A9 A7 00         mov bh, 0
0476   06AB             ; START RELATIONAL
0477   06AB D7            push a
0478   06AC 11            mov a, b
0479   06AD 26 2D 00      mov b, $2d
0480   06B0 B0            cmp a, b
0481   06B1 FD 71         seq ; ==
0482   06B3 E4            pop a
0483   06B4             ; END RELATIONAL
0484   06B4             ; START LOGICAL OR
0485   06B4 D7            push a
0486   06B5 11            mov a, b
0487   06B6 FA 05 00      lea d, [bp + 5] ; $str
0488   06B9 2A            mov b, [d]
0489   06BA 74            mov d, b
0490   06BB 32            mov bl, [d]
0491   06BC A7 00         mov bh, 0
0492   06BE             ; START RELATIONAL
0493   06BE D7            push a
0494   06BF 11            mov a, b
0495   06C0 26 2B 00      mov b, $2b
0496   06C3 B0            cmp a, b
0497   06C4 FD 71         seq ; ==
0498   06C6 E4            pop a
0499   06C7             ; END RELATIONAL
0500   06C7 FD A8         sor a, b ; ||
0501   06C9 E4            pop a
0502   06CA             ; END LOGICAL OR
0503   06CA C0 00 00      cmp b, 0
0504   06CD C6 04 07      je _if7_exit
0505   06D0             _if7_true:
0506   06D0             ;; if (*str == '-') sign = -1; 
0507   06D0             _if8_cond:
0508   06D0 FA 05 00      lea d, [bp + 5] ; $str
0509   06D3 2A            mov b, [d]
0510   06D4 74            mov d, b
0511   06D5 32            mov bl, [d]
0512   06D6 A7 00         mov bh, 0
0513   06D8             ; START RELATIONAL
0514   06D8 D7            push a
0515   06D9 11            mov a, b
0516   06DA 26 2D 00      mov b, $2d
0517   06DD B0            cmp a, b
0518   06DE FD 71         seq ; ==
0519   06E0 E4            pop a
0520   06E1             ; END RELATIONAL
0521   06E1 C0 00 00      cmp b, 0
0522   06E4 C6 F4 06      je _if8_exit
0523   06E7             _if8_true:
0524   06E7             ;; sign = -1; 
0525   06E7 FA FD FF      lea d, [bp + -3] ; $sign
0526   06EA DA            push d
0527   06EB 26 FF FF      mov b, $ffff
0528   06EE E7            pop d
0529   06EF FD 43         mov [d], b
0530   06F1 0A F4 06      jmp _if8_exit
0531   06F4             _if8_exit:
0532   06F4             ;; str++; 
0533   06F4 FA 05 00      lea d, [bp + 5] ; $str
0534   06F7 2A            mov b, [d]
0535   06F8 FD 77         inc b
0536   06FA FA 05 00      lea d, [bp + 5] ; $str
0537   06FD FD 43         mov [d], b
0538   06FF FD 7D         dec b
0539   0701 0A 04 07      jmp _if7_exit
0540   0704             _if7_exit:
0541   0704             ;; while (*str >= '0' && *str <= '9') { 
0542   0704             _while9_cond:
0543   0704 FA 05 00      lea d, [bp + 5] ; $str
0544   0707 2A            mov b, [d]
0545   0708 74            mov d, b
0546   0709 32            mov bl, [d]
0547   070A A7 00         mov bh, 0
0548   070C             ; START RELATIONAL
0549   070C D7            push a
0550   070D 11            mov a, b
0551   070E 26 30 00      mov b, $30
0552   0711 B0            cmp a, b
0553   0712 FD 82         sgeu ; >= (unsigned)
0554   0714 E4            pop a
0555   0715             ; END RELATIONAL
0556   0715             ; START LOGICAL AND
0557   0715 D7            push a
0558   0716 11            mov a, b
0559   0717 FA 05 00      lea d, [bp + 5] ; $str
0560   071A 2A            mov b, [d]
0561   071B 74            mov d, b
0562   071C 32            mov bl, [d]
0563   071D A7 00         mov bh, 0
0564   071F             ; START RELATIONAL
0565   071F D7            push a
0566   0720 11            mov a, b
0567   0721 26 39 00      mov b, $39
0568   0724 B0            cmp a, b
0569   0725 FD 76         sleu ; <= (unsigned)
0570   0727 E4            pop a
0571   0728             ; END RELATIONAL
0572   0728 FD A7         sand a, b
0573   072A E4            pop a
0574   072B             ; END LOGICAL AND
0575   072B C0 00 00      cmp b, 0
0576   072E C6 69 07      je _while9_exit
0577   0731             _while9_block:
0578   0731             ;; result = result * 10 + (*str - '0'); 
0579   0731 FA FF FF      lea d, [bp + -1] ; $result
0580   0734 DA            push d
0581   0735 FA FF FF      lea d, [bp + -1] ; $result
0582   0738 2A            mov b, [d]
0583   0739             ; START FACTORS
0584   0739 D7            push a
0585   073A 11            mov a, b
0586   073B 26 0A 00      mov b, $a
0587   073E AC            mul a, b ; *
0588   073F 11            mov a, b
0589   0740 27            mov b, a
0590   0741 E4            pop a
0591   0742             ; END FACTORS
0592   0742             ; START TERMS
0593   0742 D7            push a
0594   0743 11            mov a, b
0595   0744 FA 05 00      lea d, [bp + 5] ; $str
0596   0747 2A            mov b, [d]
0597   0748 74            mov d, b
0598   0749 32            mov bl, [d]
0599   074A A7 00         mov bh, 0
0600   074C             ; START TERMS
0601   074C D7            push a
0602   074D 11            mov a, b
0603   074E 26 30 00      mov b, $30
0604   0751 60            sub a, b
0605   0752 27            mov b, a
0606   0753 E4            pop a
0607   0754             ; END TERMS
0608   0754 56            add b, a
0609   0755 E4            pop a
0610   0756             ; END TERMS
0611   0756 E7            pop d
0612   0757 FD 43         mov [d], b
0613   0759             ;; str++; 
0614   0759 FA 05 00      lea d, [bp + 5] ; $str
0615   075C 2A            mov b, [d]
0616   075D FD 77         inc b
0617   075F FA 05 00      lea d, [bp + 5] ; $str
0618   0762 FD 43         mov [d], b
0619   0764 FD 7D         dec b
0620   0766 0A 04 07      jmp _while9_cond
0621   0769             _while9_exit:
0622   0769             ;; return sign * result; 
0623   0769 FA FD FF      lea d, [bp + -3] ; $sign
0624   076C 2A            mov b, [d]
0625   076D             ; START FACTORS
0626   076D D7            push a
0627   076E 11            mov a, b
0628   076F FA FF FF      lea d, [bp + -1] ; $result
0629   0772 2A            mov b, [d]
0630   0773 AC            mul a, b ; *
0631   0774 11            mov a, b
0632   0775 27            mov b, a
0633   0776 E4            pop a
0634   0777             ; END FACTORS
0635   0777 F9            leave
0636   0778 09            ret
0637   0779             
0638   0779             rand:
0639   0779 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0640   077C             ;; int  sec; 
0641   077C 52 02 00      sub sp, 2 ; sec
0642   077F             
0643   077F             ; --- BEGIN INLINE ASM BLOCK
0644   077F 19 00         mov al, 0
0645   0781 05 01         syscall sys_rtc					
0646   0783 1A            mov al, ah
0647   0784 FA FF FF      lea d, [bp + -1] ; $sec
0648   0787 1E            mov al, [d]
0649   0788 22 00         mov ah, 0
0650   078A             ; --- END INLINE ASM BLOCK
0651   078A             
0652   078A             ;; return sec; 
0653   078A FA FF FF      lea d, [bp + -1] ; $sec
0654   078D 2A            mov b, [d]
0655   078E F9            leave
0656   078F 09            ret
0657   0790             
0658   0790             alloc:
0659   0790 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0660   0793             ;; heap_top = heap_top + bytes; 
0661   0793 3B D2 25      mov d, _heap_top ; $heap_top
0662   0796 DA            push d
0663   0797 3B D2 25      mov d, _heap_top ; $heap_top
0664   079A 2A            mov b, [d]
0665   079B             ; START TERMS
0666   079B D7            push a
0667   079C 11            mov a, b
0668   079D FA 05 00      lea d, [bp + 5] ; $bytes
0669   07A0 2A            mov b, [d]
0670   07A1 56            add b, a
0671   07A2 E4            pop a
0672   07A3             ; END TERMS
0673   07A3 E7            pop d
0674   07A4 FD 43         mov [d], b
0675   07A6             ;; return heap_top - bytes; 
0676   07A6 3B D2 25      mov d, _heap_top ; $heap_top
0677   07A9 2A            mov b, [d]
0678   07AA             ; START TERMS
0679   07AA D7            push a
0680   07AB 11            mov a, b
0681   07AC FA 05 00      lea d, [bp + 5] ; $bytes
0682   07AF 2A            mov b, [d]
0683   07B0 60            sub a, b
0684   07B1 27            mov b, a
0685   07B2 E4            pop a
0686   07B3             ; END TERMS
0687   07B3 F9            leave
0688   07B4 09            ret
0689   07B5             
0690   07B5             free:
0691   07B5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0692   07B8             ;; return heap_top = heap_top - bytes; 
0693   07B8 3B D2 25      mov d, _heap_top ; $heap_top
0694   07BB DA            push d
0695   07BC 3B D2 25      mov d, _heap_top ; $heap_top
0696   07BF 2A            mov b, [d]
0697   07C0             ; START TERMS
0698   07C0 D7            push a
0699   07C1 11            mov a, b
0700   07C2 FA 05 00      lea d, [bp + 5] ; $bytes
0701   07C5 2A            mov b, [d]
0702   07C6 60            sub a, b
0703   07C7 27            mov b, a
0704   07C8 E4            pop a
0705   07C9             ; END TERMS
0706   07C9 E7            pop d
0707   07CA FD 43         mov [d], b
0708   07CC F9            leave
0709   07CD 09            ret
0710   07CE             
0711   07CE             fopen:
0712   07CE F8 00 00      enter 0 ; (push bp; mov bp, sp)
0713   07D1             ;; FILE *fp; 
0714   07D1 52 02 00      sub sp, 2 ; fp
0715   07D4             ;; fp = alloc(sizeof(int)); 
0716   07D4 FA FF FF      lea d, [bp + -1] ; $fp
0717   07D7 DA            push d
0718   07D8 26 02 00      mov b, 2
0719   07DB FD AB         swp b
0720   07DD D8            push b
0721   07DE 07 90 07      call alloc
0722   07E1 51 02 00      add sp, 2
0723   07E4 E7            pop d
0724   07E5 FD 43         mov [d], b
0725   07E7 F9            leave
0726   07E8 09            ret
0727   07E9             
0728   07E9             printf:
0729   07E9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0730   07EC             ;; char *p, *format_p; 
0731   07EC 52 02 00      sub sp, 2 ; p
0732   07EF 52 02 00      sub sp, 2 ; format_p
0733   07F2             ;; format_p = format; 
0734   07F2 FA FD FF      lea d, [bp + -3] ; $format_p
0735   07F5 DA            push d
0736   07F6 FA 05 00      lea d, [bp + 5] ; $format
0737   07F9 2A            mov b, [d]
0738   07FA E7            pop d
0739   07FB FD 43         mov [d], b
0740   07FD             ;; p = &format + 2; 
0741   07FD FA FF FF      lea d, [bp + -1] ; $p
0742   0800 DA            push d
0743   0801 FA 05 00      lea d, [bp + 5] ; $format
0744   0804 2D            mov b, d
0745   0805             ; START TERMS
0746   0805 D7            push a
0747   0806 11            mov a, b
0748   0807 26 02 00      mov b, $2
0749   080A 56            add b, a
0750   080B E4            pop a
0751   080C             ; END TERMS
0752   080C E7            pop d
0753   080D FD 43         mov [d], b
0754   080F             ;; for(;;){ 
0755   080F             _for10_init:
0756   080F             _for10_cond:
0757   080F             _for10_block:
0758   080F             ;; if(!*format_p) break; 
0759   080F             _if11_cond:
0760   080F FA FD FF      lea d, [bp + -3] ; $format_p
0761   0812 2A            mov b, [d]
0762   0813 74            mov d, b
0763   0814 32            mov bl, [d]
0764   0815 A7 00         mov bh, 0
0765   0817 C0 00 00      cmp b, 0
0766   081A FD 71         seq ; !
0767   081C C0 00 00      cmp b, 0
0768   081F C6 28 08      je _if11_else
0769   0822             _if11_true:
0770   0822             ;; break; 
0771   0822 0A 4F 0A      jmp _for10_exit ; for break
0772   0825 0A 4C 0A      jmp _if11_exit
0773   0828             _if11_else:
0774   0828             ;; if(*format_p == '%'){ 
0775   0828             _if12_cond:
0776   0828 FA FD FF      lea d, [bp + -3] ; $format_p
0777   082B 2A            mov b, [d]
0778   082C 74            mov d, b
0779   082D 32            mov bl, [d]
0780   082E A7 00         mov bh, 0
0781   0830             ; START RELATIONAL
0782   0830 D7            push a
0783   0831 11            mov a, b
0784   0832 26 25 00      mov b, $25
0785   0835 B0            cmp a, b
0786   0836 FD 71         seq ; ==
0787   0838 E4            pop a
0788   0839             ; END RELATIONAL
0789   0839 C0 00 00      cmp b, 0
0790   083C C6 30 0A      je _if12_else
0791   083F             _if12_true:
0792   083F             ;; format_p++; 
0793   083F FA FD FF      lea d, [bp + -3] ; $format_p
0794   0842 2A            mov b, [d]
0795   0843 FD 77         inc b
0796   0845 FA FD FF      lea d, [bp + -3] ; $format_p
0797   0848 FD 43         mov [d], b
0798   084A FD 7D         dec b
0799   084C             ;; switch(*format_p){ 
0800   084C             _switch13_expr:
0801   084C FA FD FF      lea d, [bp + -3] ; $format_p
0802   084F 2A            mov b, [d]
0803   0850 74            mov d, b
0804   0851 32            mov bl, [d]
0805   0852 A7 00         mov bh, 0
0806   0854             _switch13_comparisons:
0807   0854 C1 6C         cmp bl, $6c
0808   0856 C6 82 08      je _switch13_case0
0809   0859 C1 4C         cmp bl, $4c
0810   085B C6 82 08      je _switch13_case1
0811   085E C1 64         cmp bl, $64
0812   0860 C6 70 09      je _switch13_case2
0813   0863 C1 69         cmp bl, $69
0814   0865 C6 70 09      je _switch13_case3
0815   0868 C1 75         cmp bl, $75
0816   086A C6 94 09      je _switch13_case4
0817   086D C1 78         cmp bl, $78
0818   086F C6 B8 09      je _switch13_case5
0819   0872 C1 63         cmp bl, $63
0820   0874 C6 D6 09      je _switch13_case6
0821   0877 C1 73         cmp bl, $73
0822   0879 C6 F5 09      je _switch13_case7
0823   087C 0A 14 0A      jmp _switch13_default
0824   087F 0A 20 0A      jmp _switch13_exit
0825   0882             _switch13_case0:
0826   0882             _switch13_case1:
0827   0882             ;; format_p++; 
0828   0882 FA FD FF      lea d, [bp + -3] ; $format_p
0829   0885 2A            mov b, [d]
0830   0886 FD 77         inc b
0831   0888 FA FD FF      lea d, [bp + -3] ; $format_p
0832   088B FD 43         mov [d], b
0833   088D FD 7D         dec b
0834   088F             ;; if(*format_p == 'd' || *format_p == 'i') 
0835   088F             _if14_cond:
0836   088F FA FD FF      lea d, [bp + -3] ; $format_p
0837   0892 2A            mov b, [d]
0838   0893 74            mov d, b
0839   0894 32            mov bl, [d]
0840   0895 A7 00         mov bh, 0
0841   0897             ; START RELATIONAL
0842   0897 D7            push a
0843   0898 11            mov a, b
0844   0899 26 64 00      mov b, $64
0845   089C B0            cmp a, b
0846   089D FD 71         seq ; ==
0847   089F E4            pop a
0848   08A0             ; END RELATIONAL
0849   08A0             ; START LOGICAL OR
0850   08A0 D7            push a
0851   08A1 11            mov a, b
0852   08A2 FA FD FF      lea d, [bp + -3] ; $format_p
0853   08A5 2A            mov b, [d]
0854   08A6 74            mov d, b
0855   08A7 32            mov bl, [d]
0856   08A8 A7 00         mov bh, 0
0857   08AA             ; START RELATIONAL
0858   08AA D7            push a
0859   08AB 11            mov a, b
0860   08AC 26 69 00      mov b, $69
0861   08AF B0            cmp a, b
0862   08B0 FD 71         seq ; ==
0863   08B2 E4            pop a
0864   08B3             ; END RELATIONAL
0865   08B3 FD A8         sor a, b ; ||
0866   08B5 E4            pop a
0867   08B6             ; END LOGICAL OR
0868   08B6 C0 00 00      cmp b, 0
0869   08B9 C6 DE 08      je _if14_else
0870   08BC             _if14_true:
0871   08BC             ;; print_signed_long(*(long *)p); 
0872   08BC FA FF FF      lea d, [bp + -1] ; $p
0873   08BF 2A            mov b, [d]
0874   08C0 AB            snex b
0875   08C1 FD 39         mov c, b
0876   08C3 74            mov d, b
0877   08C4 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0878   08C7 FD 39         mov c, b ; And place it into C
0879   08C9 2A            mov b, [d] ; Lower Word in B
0880   08CA FD 79         mov g, b
0881   08CC 28            mov b, c
0882   08CD FD AB         swp b
0883   08CF D8            push b
0884   08D0 FD 27         mov b, g
0885   08D2 FD AB         swp b
0886   08D4 D8            push b
0887   08D5 07 35 0F      call print_signed_long
0888   08D8 51 04 00      add sp, 4
0889   08DB 0A 5B 09      jmp _if14_exit
0890   08DE             _if14_else:
0891   08DE             ;; if(*format_p == 'u') 
0892   08DE             _if15_cond:
0893   08DE FA FD FF      lea d, [bp + -3] ; $format_p
0894   08E1 2A            mov b, [d]
0895   08E2 74            mov d, b
0896   08E3 32            mov bl, [d]
0897   08E4 A7 00         mov bh, 0
0898   08E6             ; START RELATIONAL
0899   08E6 D7            push a
0900   08E7 11            mov a, b
0901   08E8 26 75 00      mov b, $75
0902   08EB B0            cmp a, b
0903   08EC FD 71         seq ; ==
0904   08EE E4            pop a
0905   08EF             ; END RELATIONAL
0906   08EF C0 00 00      cmp b, 0
0907   08F2 C6 19 09      je _if15_else
0908   08F5             _if15_true:
0909   08F5             ;; print_unsigned_long(*(unsigned long *)p); 
0910   08F5 FA FF FF      lea d, [bp + -1] ; $p
0911   08F8 2A            mov b, [d]
0912   08F9 A7 00         mov bh, 0
0913   08FB 38 00 00      mov c, 0
0914   08FE 74            mov d, b
0915   08FF 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0916   0902 FD 39         mov c, b ; And place it into C
0917   0904 2A            mov b, [d] ; Lower Word in B
0918   0905 FD 79         mov g, b
0919   0907 28            mov b, c
0920   0908 FD AB         swp b
0921   090A D8            push b
0922   090B FD 27         mov b, g
0923   090D FD AB         swp b
0924   090F D8            push b
0925   0910 07 75 12      call print_unsigned_long
0926   0913 51 04 00      add sp, 4
0927   0916 0A 5B 09      jmp _if15_exit
0928   0919             _if15_else:
0929   0919             ;; if(*format_p == 'x') 
0930   0919             _if16_cond:
0931   0919 FA FD FF      lea d, [bp + -3] ; $format_p
0932   091C 2A            mov b, [d]
0933   091D 74            mov d, b
0934   091E 32            mov bl, [d]
0935   091F A7 00         mov bh, 0
0936   0921             ; START RELATIONAL
0937   0921 D7            push a
0938   0922 11            mov a, b
0939   0923 26 78 00      mov b, $78
0940   0926 B0            cmp a, b
0941   0927 FD 71         seq ; ==
0942   0929 E4            pop a
0943   092A             ; END RELATIONAL
0944   092A C0 00 00      cmp b, 0
0945   092D C6 4F 09      je _if16_else
0946   0930             _if16_true:
0947   0930             ;; printx32(*(long int *)p); 
0948   0930 FA FF FF      lea d, [bp + -1] ; $p
0949   0933 2A            mov b, [d]
0950   0934 74            mov d, b
0951   0935 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0952   0938 FD 39         mov c, b ; And place it into C
0953   093A 2A            mov b, [d] ; Lower Word in B
0954   093B FD 79         mov g, b
0955   093D 28            mov b, c
0956   093E FD AB         swp b
0957   0940 D8            push b
0958   0941 FD 27         mov b, g
0959   0943 FD AB         swp b
0960   0945 D8            push b
0961   0946 07 AA 0C      call printx32
0962   0949 51 04 00      add sp, 4
0963   094C 0A 5B 09      jmp _if16_exit
0964   094F             _if16_else:
0965   094F             ;; err("Unexpected format in printf."); 
0966   094F 26 64 24      mov b, _s1 ; "Unexpected format in printf."
0967   0952 FD AB         swp b
0968   0954 D8            push b
0969   0955 07 98 0C      call err
0970   0958 51 02 00      add sp, 2
0971   095B             _if16_exit:
0972   095B             _if15_exit:
0973   095B             _if14_exit:
0974   095B             ;; p = p + 4; 
0975   095B FA FF FF      lea d, [bp + -1] ; $p
0976   095E DA            push d
0977   095F FA FF FF      lea d, [bp + -1] ; $p
0978   0962 2A            mov b, [d]
0979   0963             ; START TERMS
0980   0963 D7            push a
0981   0964 11            mov a, b
0982   0965 26 04 00      mov b, $4
0983   0968 56            add b, a
0984   0969 E4            pop a
0985   096A             ; END TERMS
0986   096A E7            pop d
0987   096B FD 43         mov [d], b
0988   096D             ;; break; 
0989   096D 0A 20 0A      jmp _switch13_exit ; case break
0990   0970             _switch13_case2:
0991   0970             _switch13_case3:
0992   0970             ;; print_signed(*(int*)p); 
0993   0970 FA FF FF      lea d, [bp + -1] ; $p
0994   0973 2A            mov b, [d]
0995   0974 74            mov d, b
0996   0975 2A            mov b, [d]
0997   0976 FD AB         swp b
0998   0978 D8            push b
0999   0979 07 3E 0E      call print_signed
1000   097C 51 02 00      add sp, 2
1001   097F             ;; p = p + 2; 
1002   097F FA FF FF      lea d, [bp + -1] ; $p
1003   0982 DA            push d
1004   0983 FA FF FF      lea d, [bp + -1] ; $p
1005   0986 2A            mov b, [d]
1006   0987             ; START TERMS
1007   0987 D7            push a
1008   0988 11            mov a, b
1009   0989 26 02 00      mov b, $2
1010   098C 56            add b, a
1011   098D E4            pop a
1012   098E             ; END TERMS
1013   098E E7            pop d
1014   098F FD 43         mov [d], b
1015   0991             ;; break; 
1016   0991 0A 20 0A      jmp _switch13_exit ; case break
1017   0994             _switch13_case4:
1018   0994             ;; print_unsigned(*(unsigned int*)p); 
1019   0994 FA FF FF      lea d, [bp + -1] ; $p
1020   0997 2A            mov b, [d]
1021   0998 74            mov d, b
1022   0999 2A            mov b, [d]
1023   099A FD AB         swp b
1024   099C D8            push b
1025   099D 07 70 14      call print_unsigned
1026   09A0 51 02 00      add sp, 2
1027   09A3             ;; p = p + 2; 
1028   09A3 FA FF FF      lea d, [bp + -1] ; $p
1029   09A6 DA            push d
1030   09A7 FA FF FF      lea d, [bp + -1] ; $p
1031   09AA 2A            mov b, [d]
1032   09AB             ; START TERMS
1033   09AB D7            push a
1034   09AC 11            mov a, b
1035   09AD 26 02 00      mov b, $2
1036   09B0 56            add b, a
1037   09B1 E4            pop a
1038   09B2             ; END TERMS
1039   09B2 E7            pop d
1040   09B3 FD 43         mov [d], b
1041   09B5             ;; break; 
1042   09B5 0A 20 0A      jmp _switch13_exit ; case break
1043   09B8             _switch13_case5:
1044   09B8             
1045   09B8             ; --- BEGIN INLINE ASM BLOCK
1046   09B8 FA FF FF      lea d, [bp + -1] ; $p
1047   09BB FD 2A         mov d, [d]
1048   09BD 2A            mov b, [d]
1049   09BE 07 76 18      call print_u16x
1050   09C1             ; --- END INLINE ASM BLOCK
1051   09C1             
1052   09C1             ;; p = p + 2; 
1053   09C1 FA FF FF      lea d, [bp + -1] ; $p
1054   09C4 DA            push d
1055   09C5 FA FF FF      lea d, [bp + -1] ; $p
1056   09C8 2A            mov b, [d]
1057   09C9             ; START TERMS
1058   09C9 D7            push a
1059   09CA 11            mov a, b
1060   09CB 26 02 00      mov b, $2
1061   09CE 56            add b, a
1062   09CF E4            pop a
1063   09D0             ; END TERMS
1064   09D0 E7            pop d
1065   09D1 FD 43         mov [d], b
1066   09D3             ;; break; 
1067   09D3 0A 20 0A      jmp _switch13_exit ; case break
1068   09D6             _switch13_case6:
1069   09D6             
1070   09D6             ; --- BEGIN INLINE ASM BLOCK
1071   09D6 FA FF FF      lea d, [bp + -1] ; $p
1072   09D9 FD 2A         mov d, [d]
1073   09DB 1E            mov al, [d]
1074   09DC 23            mov ah, al
1075   09DD 07 D4 16      call _putchar
1076   09E0             ; --- END INLINE ASM BLOCK
1077   09E0             
1078   09E0             ;; p = p + 2; 
1079   09E0 FA FF FF      lea d, [bp + -1] ; $p
1080   09E3 DA            push d
1081   09E4 FA FF FF      lea d, [bp + -1] ; $p
1082   09E7 2A            mov b, [d]
1083   09E8             ; START TERMS
1084   09E8 D7            push a
1085   09E9 11            mov a, b
1086   09EA 26 02 00      mov b, $2
1087   09ED 56            add b, a
1088   09EE E4            pop a
1089   09EF             ; END TERMS
1090   09EF E7            pop d
1091   09F0 FD 43         mov [d], b
1092   09F2             ;; break; 
1093   09F2 0A 20 0A      jmp _switch13_exit ; case break
1094   09F5             _switch13_case7:
1095   09F5             
1096   09F5             ; --- BEGIN INLINE ASM BLOCK
1097   09F5 FA FF FF      lea d, [bp + -1] ; $p
1098   09F8 FD 2A         mov d, [d]
1099   09FA FD 2A         mov d, [d]
1100   09FC 07 1E 18      call _puts
1101   09FF             ; --- END INLINE ASM BLOCK
1102   09FF             
1103   09FF             ;; p = p + 2; 
1104   09FF FA FF FF      lea d, [bp + -1] ; $p
1105   0A02 DA            push d
1106   0A03 FA FF FF      lea d, [bp + -1] ; $p
1107   0A06 2A            mov b, [d]
1108   0A07             ; START TERMS
1109   0A07 D7            push a
1110   0A08 11            mov a, b
1111   0A09 26 02 00      mov b, $2
1112   0A0C 56            add b, a
1113   0A0D E4            pop a
1114   0A0E             ; END TERMS
1115   0A0E E7            pop d
1116   0A0F FD 43         mov [d], b
1117   0A11             ;; break; 
1118   0A11 0A 20 0A      jmp _switch13_exit ; case break
1119   0A14             _switch13_default:
1120   0A14             ;; print("Error: Unknown argument type.\n"); 
1121   0A14 26 81 24      mov b, _s2 ; "Error: Unknown argument type.\n"
1122   0A17 FD AB         swp b
1123   0A19 D8            push b
1124   0A1A 07 8B 15      call print
1125   0A1D 51 02 00      add sp, 2
1126   0A20             _switch13_exit:
1127   0A20             ;; format_p++; 
1128   0A20 FA FD FF      lea d, [bp + -3] ; $format_p
1129   0A23 2A            mov b, [d]
1130   0A24 FD 77         inc b
1131   0A26 FA FD FF      lea d, [bp + -3] ; $format_p
1132   0A29 FD 43         mov [d], b
1133   0A2B FD 7D         dec b
1134   0A2D 0A 4C 0A      jmp _if12_exit
1135   0A30             _if12_else:
1136   0A30             ;; putchar(*format_p); 
1137   0A30 FA FD FF      lea d, [bp + -3] ; $format_p
1138   0A33 2A            mov b, [d]
1139   0A34 74            mov d, b
1140   0A35 32            mov bl, [d]
1141   0A36 A7 00         mov bh, 0
1142   0A38 DD            push bl
1143   0A39 07 43 15      call putchar
1144   0A3C 51 01 00      add sp, 1
1145   0A3F             ;; format_p++; 
1146   0A3F FA FD FF      lea d, [bp + -3] ; $format_p
1147   0A42 2A            mov b, [d]
1148   0A43 FD 77         inc b
1149   0A45 FA FD FF      lea d, [bp + -3] ; $format_p
1150   0A48 FD 43         mov [d], b
1151   0A4A FD 7D         dec b
1152   0A4C             _if12_exit:
1153   0A4C             _if11_exit:
1154   0A4C             _for10_update:
1155   0A4C 0A 0F 08      jmp _for10_cond
1156   0A4F             _for10_exit:
1157   0A4F F9            leave
1158   0A50 09            ret
1159   0A51             
1160   0A51             scanf:
1161   0A51 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1162   0A54             ;; char *p, *format_p; 
1163   0A54 52 02 00      sub sp, 2 ; p
1164   0A57 52 02 00      sub sp, 2 ; format_p
1165   0A5A             ;; char c; 
1166   0A5A 52 01 00      sub sp, 1 ; c
1167   0A5D             ;; int i; 
1168   0A5D 52 02 00      sub sp, 2 ; i
1169   0A60             ;; char input_string[  512                    ]; 
1170   0A60 52 00 02      sub sp, 512 ; input_string
1171   0A63             ;; format_p = format; 
1172   0A63 FA FD FF      lea d, [bp + -3] ; $format_p
1173   0A66 DA            push d
1174   0A67 FA 05 00      lea d, [bp + 5] ; $format
1175   0A6A 2A            mov b, [d]
1176   0A6B E7            pop d
1177   0A6C FD 43         mov [d], b
1178   0A6E             ;; p = &format + 2; 
1179   0A6E FA FF FF      lea d, [bp + -1] ; $p
1180   0A71 DA            push d
1181   0A72 FA 05 00      lea d, [bp + 5] ; $format
1182   0A75 2D            mov b, d
1183   0A76             ; START TERMS
1184   0A76 D7            push a
1185   0A77 11            mov a, b
1186   0A78 26 02 00      mov b, $2
1187   0A7B 56            add b, a
1188   0A7C E4            pop a
1189   0A7D             ; END TERMS
1190   0A7D E7            pop d
1191   0A7E FD 43         mov [d], b
1192   0A80             ;; for(;;){ 
1193   0A80             _for17_init:
1194   0A80             _for17_cond:
1195   0A80             _for17_block:
1196   0A80             ;; if(!*format_p) break; 
1197   0A80             _if18_cond:
1198   0A80 FA FD FF      lea d, [bp + -3] ; $format_p
1199   0A83 2A            mov b, [d]
1200   0A84 74            mov d, b
1201   0A85 32            mov bl, [d]
1202   0A86 A7 00         mov bh, 0
1203   0A88 C0 00 00      cmp b, 0
1204   0A8B FD 71         seq ; !
1205   0A8D C0 00 00      cmp b, 0
1206   0A90 C6 99 0A      je _if18_else
1207   0A93             _if18_true:
1208   0A93             ;; break; 
1209   0A93 0A 96 0C      jmp _for17_exit ; for break
1210   0A96 0A 93 0C      jmp _if18_exit
1211   0A99             _if18_else:
1212   0A99             ;; if(*format_p == '%'){ 
1213   0A99             _if19_cond:
1214   0A99 FA FD FF      lea d, [bp + -3] ; $format_p
1215   0A9C 2A            mov b, [d]
1216   0A9D 74            mov d, b
1217   0A9E 32            mov bl, [d]
1218   0A9F A7 00         mov bh, 0
1219   0AA1             ; START RELATIONAL
1220   0AA1 D7            push a
1221   0AA2 11            mov a, b
1222   0AA3 26 25 00      mov b, $25
1223   0AA6 B0            cmp a, b
1224   0AA7 FD 71         seq ; ==
1225   0AA9 E4            pop a
1226   0AAA             ; END RELATIONAL
1227   0AAA C0 00 00      cmp b, 0
1228   0AAD C6 77 0C      je _if19_else
1229   0AB0             _if19_true:
1230   0AB0             ;; format_p++; 
1231   0AB0 FA FD FF      lea d, [bp + -3] ; $format_p
1232   0AB3 2A            mov b, [d]
1233   0AB4 FD 77         inc b
1234   0AB6 FA FD FF      lea d, [bp + -3] ; $format_p
1235   0AB9 FD 43         mov [d], b
1236   0ABB FD 7D         dec b
1237   0ABD             ;; switch(*format_p){ 
1238   0ABD             _switch20_expr:
1239   0ABD FA FD FF      lea d, [bp + -3] ; $format_p
1240   0AC0 2A            mov b, [d]
1241   0AC1 74            mov d, b
1242   0AC2 32            mov bl, [d]
1243   0AC3 A7 00         mov bh, 0
1244   0AC5             _switch20_comparisons:
1245   0AC5 C1 6C         cmp bl, $6c
1246   0AC7 C6 F3 0A      je _switch20_case0
1247   0ACA C1 4C         cmp bl, $4c
1248   0ACC C6 F3 0A      je _switch20_case1
1249   0ACF C1 64         cmp bl, $64
1250   0AD1 C6 85 0B      je _switch20_case2
1251   0AD4 C1 69         cmp bl, $69
1252   0AD6 C6 85 0B      je _switch20_case3
1253   0AD9 C1 75         cmp bl, $75
1254   0ADB C6 B2 0B      je _switch20_case4
1255   0ADE C1 78         cmp bl, $78
1256   0AE0 C6 DF 0B      je _switch20_case5
1257   0AE3 C1 63         cmp bl, $63
1258   0AE5 C6 F4 0B      je _switch20_case6
1259   0AE8 C1 73         cmp bl, $73
1260   0AEA C6 23 0C      je _switch20_case7
1261   0AED 0A 5B 0C      jmp _switch20_default
1262   0AF0 0A 67 0C      jmp _switch20_exit
1263   0AF3             _switch20_case0:
1264   0AF3             _switch20_case1:
1265   0AF3             ;; format_p++; 
1266   0AF3 FA FD FF      lea d, [bp + -3] ; $format_p
1267   0AF6 2A            mov b, [d]
1268   0AF7 FD 77         inc b
1269   0AF9 FA FD FF      lea d, [bp + -3] ; $format_p
1270   0AFC FD 43         mov [d], b
1271   0AFE FD 7D         dec b
1272   0B00             ;; if(*format_p == 'd' || *format_p == 'i'); 
1273   0B00             _if21_cond:
1274   0B00 FA FD FF      lea d, [bp + -3] ; $format_p
1275   0B03 2A            mov b, [d]
1276   0B04 74            mov d, b
1277   0B05 32            mov bl, [d]
1278   0B06 A7 00         mov bh, 0
1279   0B08             ; START RELATIONAL
1280   0B08 D7            push a
1281   0B09 11            mov a, b
1282   0B0A 26 64 00      mov b, $64
1283   0B0D B0            cmp a, b
1284   0B0E FD 71         seq ; ==
1285   0B10 E4            pop a
1286   0B11             ; END RELATIONAL
1287   0B11             ; START LOGICAL OR
1288   0B11 D7            push a
1289   0B12 11            mov a, b
1290   0B13 FA FD FF      lea d, [bp + -3] ; $format_p
1291   0B16 2A            mov b, [d]
1292   0B17 74            mov d, b
1293   0B18 32            mov bl, [d]
1294   0B19 A7 00         mov bh, 0
1295   0B1B             ; START RELATIONAL
1296   0B1B D7            push a
1297   0B1C 11            mov a, b
1298   0B1D 26 69 00      mov b, $69
1299   0B20 B0            cmp a, b
1300   0B21 FD 71         seq ; ==
1301   0B23 E4            pop a
1302   0B24             ; END RELATIONAL
1303   0B24 FD A8         sor a, b ; ||
1304   0B26 E4            pop a
1305   0B27             ; END LOGICAL OR
1306   0B27 C0 00 00      cmp b, 0
1307   0B2A C6 30 0B      je _if21_else
1308   0B2D             _if21_true:
1309   0B2D             ;; ; 
1310   0B2D 0A 70 0B      jmp _if21_exit
1311   0B30             _if21_else:
1312   0B30             ;; if(*format_p == 'u'); 
1313   0B30             _if22_cond:
1314   0B30 FA FD FF      lea d, [bp + -3] ; $format_p
1315   0B33 2A            mov b, [d]
1316   0B34 74            mov d, b
1317   0B35 32            mov bl, [d]
1318   0B36 A7 00         mov bh, 0
1319   0B38             ; START RELATIONAL
1320   0B38 D7            push a
1321   0B39 11            mov a, b
1322   0B3A 26 75 00      mov b, $75
1323   0B3D B0            cmp a, b
1324   0B3E FD 71         seq ; ==
1325   0B40 E4            pop a
1326   0B41             ; END RELATIONAL
1327   0B41 C0 00 00      cmp b, 0
1328   0B44 C6 4A 0B      je _if22_else
1329   0B47             _if22_true:
1330   0B47             ;; ; 
1331   0B47 0A 70 0B      jmp _if22_exit
1332   0B4A             _if22_else:
1333   0B4A             ;; if(*format_p == 'x'); 
1334   0B4A             _if23_cond:
1335   0B4A FA FD FF      lea d, [bp + -3] ; $format_p
1336   0B4D 2A            mov b, [d]
1337   0B4E 74            mov d, b
1338   0B4F 32            mov bl, [d]
1339   0B50 A7 00         mov bh, 0
1340   0B52             ; START RELATIONAL
1341   0B52 D7            push a
1342   0B53 11            mov a, b
1343   0B54 26 78 00      mov b, $78
1344   0B57 B0            cmp a, b
1345   0B58 FD 71         seq ; ==
1346   0B5A E4            pop a
1347   0B5B             ; END RELATIONAL
1348   0B5B C0 00 00      cmp b, 0
1349   0B5E C6 64 0B      je _if23_else
1350   0B61             _if23_true:
1351   0B61             ;; ; 
1352   0B61 0A 70 0B      jmp _if23_exit
1353   0B64             _if23_else:
1354   0B64             ;; err("Unexpected format in printf."); 
1355   0B64 26 64 24      mov b, _s1 ; "Unexpected format in printf."
1356   0B67 FD AB         swp b
1357   0B69 D8            push b
1358   0B6A 07 98 0C      call err
1359   0B6D 51 02 00      add sp, 2
1360   0B70             _if23_exit:
1361   0B70             _if22_exit:
1362   0B70             _if21_exit:
1363   0B70             ;; p = p + 4; 
1364   0B70 FA FF FF      lea d, [bp + -1] ; $p
1365   0B73 DA            push d
1366   0B74 FA FF FF      lea d, [bp + -1] ; $p
1367   0B77 2A            mov b, [d]
1368   0B78             ; START TERMS
1369   0B78 D7            push a
1370   0B79 11            mov a, b
1371   0B7A 26 04 00      mov b, $4
1372   0B7D 56            add b, a
1373   0B7E E4            pop a
1374   0B7F             ; END TERMS
1375   0B7F E7            pop d
1376   0B80 FD 43         mov [d], b
1377   0B82             ;; break; 
1378   0B82 0A 67 0C      jmp _switch20_exit ; case break
1379   0B85             _switch20_case2:
1380   0B85             _switch20_case3:
1381   0B85             ;; i = scann(); 
1382   0B85 FA FA FF      lea d, [bp + -6] ; $i
1383   0B88 DA            push d
1384   0B89 07 66 15      call scann
1385   0B8C E7            pop d
1386   0B8D FD 43         mov [d], b
1387   0B8F             ;; **(int **)p = i; 
1388   0B8F FA FF FF      lea d, [bp + -1] ; $p
1389   0B92 2A            mov b, [d]
1390   0B93 74            mov d, b
1391   0B94 2A            mov b, [d]
1392   0B95 D8            push b
1393   0B96 FA FA FF      lea d, [bp + -6] ; $i
1394   0B99 2A            mov b, [d]
1395   0B9A E7            pop d
1396   0B9B FD 43         mov [d], b
1397   0B9D             ;; p = p + 2; 
1398   0B9D FA FF FF      lea d, [bp + -1] ; $p
1399   0BA0 DA            push d
1400   0BA1 FA FF FF      lea d, [bp + -1] ; $p
1401   0BA4 2A            mov b, [d]
1402   0BA5             ; START TERMS
1403   0BA5 D7            push a
1404   0BA6 11            mov a, b
1405   0BA7 26 02 00      mov b, $2
1406   0BAA 56            add b, a
1407   0BAB E4            pop a
1408   0BAC             ; END TERMS
1409   0BAC E7            pop d
1410   0BAD FD 43         mov [d], b
1411   0BAF             ;; break; 
1412   0BAF 0A 67 0C      jmp _switch20_exit ; case break
1413   0BB2             _switch20_case4:
1414   0BB2             ;; i = scann(); 
1415   0BB2 FA FA FF      lea d, [bp + -6] ; $i
1416   0BB5 DA            push d
1417   0BB6 07 66 15      call scann
1418   0BB9 E7            pop d
1419   0BBA FD 43         mov [d], b
1420   0BBC             ;; **(int **)p = i; 
1421   0BBC FA FF FF      lea d, [bp + -1] ; $p
1422   0BBF 2A            mov b, [d]
1423   0BC0 74            mov d, b
1424   0BC1 2A            mov b, [d]
1425   0BC2 D8            push b
1426   0BC3 FA FA FF      lea d, [bp + -6] ; $i
1427   0BC6 2A            mov b, [d]
1428   0BC7 E7            pop d
1429   0BC8 FD 43         mov [d], b
1430   0BCA             ;; p = p + 2; 
1431   0BCA FA FF FF      lea d, [bp + -1] ; $p
1432   0BCD DA            push d
1433   0BCE FA FF FF      lea d, [bp + -1] ; $p
1434   0BD1 2A            mov b, [d]
1435   0BD2             ; START TERMS
1436   0BD2 D7            push a
1437   0BD3 11            mov a, b
1438   0BD4 26 02 00      mov b, $2
1439   0BD7 56            add b, a
1440   0BD8 E4            pop a
1441   0BD9             ; END TERMS
1442   0BD9 E7            pop d
1443   0BDA FD 43         mov [d], b
1444   0BDC             ;; break; 
1445   0BDC 0A 67 0C      jmp _switch20_exit ; case break
1446   0BDF             _switch20_case5:
1447   0BDF             ;; p = p + 2; 
1448   0BDF FA FF FF      lea d, [bp + -1] ; $p
1449   0BE2 DA            push d
1450   0BE3 FA FF FF      lea d, [bp + -1] ; $p
1451   0BE6 2A            mov b, [d]
1452   0BE7             ; START TERMS
1453   0BE7 D7            push a
1454   0BE8 11            mov a, b
1455   0BE9 26 02 00      mov b, $2
1456   0BEC 56            add b, a
1457   0BED E4            pop a
1458   0BEE             ; END TERMS
1459   0BEE E7            pop d
1460   0BEF FD 43         mov [d], b
1461   0BF1             ;; break; 
1462   0BF1 0A 67 0C      jmp _switch20_exit ; case break
1463   0BF4             _switch20_case6:
1464   0BF4             ;; c = getchar(); 
1465   0BF4 FA FC FF      lea d, [bp + -4] ; $c
1466   0BF7 DA            push d
1467   0BF8 07 50 15      call getchar
1468   0BFB E7            pop d
1469   0BFC FD 3E         mov [d], bl
1470   0BFE             ;; **(char **)p = c; 
1471   0BFE FA FF FF      lea d, [bp + -1] ; $p
1472   0C01 2A            mov b, [d]
1473   0C02 74            mov d, b
1474   0C03 2A            mov b, [d]
1475   0C04 D8            push b
1476   0C05 FA FC FF      lea d, [bp + -4] ; $c
1477   0C08 32            mov bl, [d]
1478   0C09 A7 00         mov bh, 0
1479   0C0B E7            pop d
1480   0C0C FD 43         mov [d], b
1481   0C0E             ;; p = p + 2; 
1482   0C0E FA FF FF      lea d, [bp + -1] ; $p
1483   0C11 DA            push d
1484   0C12 FA FF FF      lea d, [bp + -1] ; $p
1485   0C15 2A            mov b, [d]
1486   0C16             ; START TERMS
1487   0C16 D7            push a
1488   0C17 11            mov a, b
1489   0C18 26 02 00      mov b, $2
1490   0C1B 56            add b, a
1491   0C1C E4            pop a
1492   0C1D             ; END TERMS
1493   0C1D E7            pop d
1494   0C1E FD 43         mov [d], b
1495   0C20             ;; break; 
1496   0C20 0A 67 0C      jmp _switch20_exit ; case break
1497   0C23             _switch20_case7:
1498   0C23             ;; gets(input_string); 
1499   0C23 FA FA FD      lea d, [bp + -518] ; $input_string
1500   0C26 2D            mov b, d
1501   0C27 FD AB         swp b
1502   0C29 D8            push b
1503   0C2A 07 24 0E      call gets
1504   0C2D 51 02 00      add sp, 2
1505   0C30             ;; strcpy(*(char **)p, input_string); 
1506   0C30 FA FA FD      lea d, [bp + -518] ; $input_string
1507   0C33 2D            mov b, d
1508   0C34 FD AB         swp b
1509   0C36 D8            push b
1510   0C37 FA FF FF      lea d, [bp + -1] ; $p
1511   0C3A 2A            mov b, [d]
1512   0C3B 74            mov d, b
1513   0C3C 2A            mov b, [d]
1514   0C3D FD AB         swp b
1515   0C3F D8            push b
1516   0C40 07 45 04      call strcpy
1517   0C43 51 04 00      add sp, 4
1518   0C46             ;; p = p + 2; 
1519   0C46 FA FF FF      lea d, [bp + -1] ; $p
1520   0C49 DA            push d
1521   0C4A FA FF FF      lea d, [bp + -1] ; $p
1522   0C4D 2A            mov b, [d]
1523   0C4E             ; START TERMS
1524   0C4E D7            push a
1525   0C4F 11            mov a, b
1526   0C50 26 02 00      mov b, $2
1527   0C53 56            add b, a
1528   0C54 E4            pop a
1529   0C55             ; END TERMS
1530   0C55 E7            pop d
1531   0C56 FD 43         mov [d], b
1532   0C58             ;; break; 
1533   0C58 0A 67 0C      jmp _switch20_exit ; case break
1534   0C5B             _switch20_default:
1535   0C5B             ;; print("Error: Unknown argument type.\n"); 
1536   0C5B 26 81 24      mov b, _s2 ; "Error: Unknown argument type.\n"
1537   0C5E FD AB         swp b
1538   0C60 D8            push b
1539   0C61 07 8B 15      call print
1540   0C64 51 02 00      add sp, 2
1541   0C67             _switch20_exit:
1542   0C67             ;; format_p++; 
1543   0C67 FA FD FF      lea d, [bp + -3] ; $format_p
1544   0C6A 2A            mov b, [d]
1545   0C6B FD 77         inc b
1546   0C6D FA FD FF      lea d, [bp + -3] ; $format_p
1547   0C70 FD 43         mov [d], b
1548   0C72 FD 7D         dec b
1549   0C74 0A 93 0C      jmp _if19_exit
1550   0C77             _if19_else:
1551   0C77             ;; putchar(*format_p); 
1552   0C77 FA FD FF      lea d, [bp + -3] ; $format_p
1553   0C7A 2A            mov b, [d]
1554   0C7B 74            mov d, b
1555   0C7C 32            mov bl, [d]
1556   0C7D A7 00         mov bh, 0
1557   0C7F DD            push bl
1558   0C80 07 43 15      call putchar
1559   0C83 51 01 00      add sp, 1
1560   0C86             ;; format_p++; 
1561   0C86 FA FD FF      lea d, [bp + -3] ; $format_p
1562   0C89 2A            mov b, [d]
1563   0C8A FD 77         inc b
1564   0C8C FA FD FF      lea d, [bp + -3] ; $format_p
1565   0C8F FD 43         mov [d], b
1566   0C91 FD 7D         dec b
1567   0C93             _if19_exit:
1568   0C93             _if18_exit:
1569   0C93             _for17_update:
1570   0C93 0A 80 0A      jmp _for17_cond
1571   0C96             _for17_exit:
1572   0C96 F9            leave
1573   0C97 09            ret
1574   0C98             
1575   0C98             err:
1576   0C98 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1577   0C9B             ;; print(e); 
1578   0C9B FA 05 00      lea d, [bp + 5] ; $e
1579   0C9E 2A            mov b, [d]
1580   0C9F FD AB         swp b
1581   0CA1 D8            push b
1582   0CA2 07 8B 15      call print
1583   0CA5 51 02 00      add sp, 2
1584   0CA8 F9            leave
1585   0CA9 09            ret
1586   0CAA             
1587   0CAA             printx32:
1588   0CAA F8 00 00      enter 0 ; (push bp; mov bp, sp)
1589   0CAD             
1590   0CAD             ; --- BEGIN INLINE ASM BLOCK
1591   0CAD FA 05 00      lea d, [bp + 5] ; $hex
1592   0CB0 2B 02 00      mov b, [d+2]
1593   0CB3 07 76 18      call print_u16x
1594   0CB6 2A            mov b, [d]
1595   0CB7 07 76 18      call print_u16x
1596   0CBA             ; --- END INLINE ASM BLOCK
1597   0CBA             
1598   0CBA F9            leave
1599   0CBB 09            ret
1600   0CBC             
1601   0CBC             printx16:
1602   0CBC F8 00 00      enter 0 ; (push bp; mov bp, sp)
1603   0CBF             
1604   0CBF             ; --- BEGIN INLINE ASM BLOCK
1605   0CBF FA 05 00      lea d, [bp + 5] ; $hex
1606   0CC2 2A            mov b, [d]
1607   0CC3 07 76 18      call print_u16x
1608   0CC6             ; --- END INLINE ASM BLOCK
1609   0CC6             
1610   0CC6 F9            leave
1611   0CC7 09            ret
1612   0CC8             
1613   0CC8             printx8:
1614   0CC8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1615   0CCB             
1616   0CCB             ; --- BEGIN INLINE ASM BLOCK
1617   0CCB FA 05 00      lea d, [bp + 5] ; $hex
1618   0CCE 32            mov bl, [d]
1619   0CCF 07 BA 18      call print_u8x
1620   0CD2             ; --- END INLINE ASM BLOCK
1621   0CD2             
1622   0CD2 F9            leave
1623   0CD3 09            ret
1624   0CD4             
1625   0CD4             hex_str_to_int:
1626   0CD4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1627   0CD7             ;; int value = 0; 
1628   0CD7 52 02 00      sub sp, 2 ; value
1629   0CDA             ; --- START LOCAL VAR INITIALIZATION
1630   0CDA FA FF FF      lea d, [bp + -1] ; $value
1631   0CDD DA            push d
1632   0CDE 26 00 00      mov b, $0
1633   0CE1 E7            pop d
1634   0CE2 FD 43         mov [d], b
1635   0CE4             ; --- END LOCAL VAR INITIALIZATION
1636   0CE4             ;; int i; 
1637   0CE4 52 02 00      sub sp, 2 ; i
1638   0CE7             ;; char hex_char; 
1639   0CE7 52 01 00      sub sp, 1 ; hex_char
1640   0CEA             ;; int len; 
1641   0CEA 52 02 00      sub sp, 2 ; len
1642   0CED             ;; len = strlen(hex_string); 
1643   0CED FA FA FF      lea d, [bp + -6] ; $len
1644   0CF0 DA            push d
1645   0CF1 FA 05 00      lea d, [bp + 5] ; $hex_string
1646   0CF4 2A            mov b, [d]
1647   0CF5 FD AB         swp b
1648   0CF7 D8            push b
1649   0CF8 07 BF 05      call strlen
1650   0CFB 51 02 00      add sp, 2
1651   0CFE E7            pop d
1652   0CFF FD 43         mov [d], b
1653   0D01             ;; for (i = 0; i < len; i++) { 
1654   0D01             _for24_init:
1655   0D01 FA FD FF      lea d, [bp + -3] ; $i
1656   0D04 DA            push d
1657   0D05 26 00 00      mov b, $0
1658   0D08 E7            pop d
1659   0D09 FD 43         mov [d], b
1660   0D0B             _for24_cond:
1661   0D0B FA FD FF      lea d, [bp + -3] ; $i
1662   0D0E 2A            mov b, [d]
1663   0D0F             ; START RELATIONAL
1664   0D0F D7            push a
1665   0D10 11            mov a, b
1666   0D11 FA FA FF      lea d, [bp + -6] ; $len
1667   0D14 2A            mov b, [d]
1668   0D15 B0            cmp a, b
1669   0D16 FD 73         slt ; < (signed)
1670   0D18 E4            pop a
1671   0D19             ; END RELATIONAL
1672   0D19 C0 00 00      cmp b, 0
1673   0D1C C6 1E 0E      je _for24_exit
1674   0D1F             _for24_block:
1675   0D1F             ;; hex_char = hex_string[i]; 
1676   0D1F FA FC FF      lea d, [bp + -4] ; $hex_char
1677   0D22 DA            push d
1678   0D23 FA 05 00      lea d, [bp + 5] ; $hex_string
1679   0D26 FD 2A         mov d, [d]
1680   0D28 D7            push a
1681   0D29 DA            push d
1682   0D2A FA FD FF      lea d, [bp + -3] ; $i
1683   0D2D 2A            mov b, [d]
1684   0D2E E7            pop d
1685   0D2F FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
1686   0D33 E4            pop a
1687   0D34 32            mov bl, [d]
1688   0D35 A7 00         mov bh, 0
1689   0D37 E7            pop d
1690   0D38 FD 3E         mov [d], bl
1691   0D3A             ;; if (hex_char >= 'a' && hex_char <= 'f')  
1692   0D3A             _if25_cond:
1693   0D3A FA FC FF      lea d, [bp + -4] ; $hex_char
1694   0D3D 32            mov bl, [d]
1695   0D3E A7 00         mov bh, 0
1696   0D40             ; START RELATIONAL
1697   0D40 D7            push a
1698   0D41 11            mov a, b
1699   0D42 26 61 00      mov b, $61
1700   0D45 B0            cmp a, b
1701   0D46 FD 80         sge ; >=
1702   0D48 E4            pop a
1703   0D49             ; END RELATIONAL
1704   0D49             ; START LOGICAL AND
1705   0D49 D7            push a
1706   0D4A 11            mov a, b
1707   0D4B FA FC FF      lea d, [bp + -4] ; $hex_char
1708   0D4E 32            mov bl, [d]
1709   0D4F A7 00         mov bh, 0
1710   0D51             ; START RELATIONAL
1711   0D51 D7            push a
1712   0D52 11            mov a, b
1713   0D53 26 66 00      mov b, $66
1714   0D56 B0            cmp a, b
1715   0D57 FD 74         sle ; <= (signed)
1716   0D59 E4            pop a
1717   0D5A             ; END RELATIONAL
1718   0D5A FD A7         sand a, b
1719   0D5C E4            pop a
1720   0D5D             ; END LOGICAL AND
1721   0D5D C0 00 00      cmp b, 0
1722   0D60 C6 91 0D      je _if25_else
1723   0D63             _if25_true:
1724   0D63             ;; value = (value * 16) + (hex_char - 'a' + 10); 
1725   0D63 FA FF FF      lea d, [bp + -1] ; $value
1726   0D66 DA            push d
1727   0D67 FA FF FF      lea d, [bp + -1] ; $value
1728   0D6A 2A            mov b, [d]
1729   0D6B             ; START FACTORS
1730   0D6B D7            push a
1731   0D6C 11            mov a, b
1732   0D6D 26 10 00      mov b, $10
1733   0D70 AC            mul a, b ; *
1734   0D71 11            mov a, b
1735   0D72 27            mov b, a
1736   0D73 E4            pop a
1737   0D74             ; END FACTORS
1738   0D74             ; START TERMS
1739   0D74 D7            push a
1740   0D75 11            mov a, b
1741   0D76 FA FC FF      lea d, [bp + -4] ; $hex_char
1742   0D79 32            mov bl, [d]
1743   0D7A A7 00         mov bh, 0
1744   0D7C             ; START TERMS
1745   0D7C D7            push a
1746   0D7D 11            mov a, b
1747   0D7E 26 61 00      mov b, $61
1748   0D81 60            sub a, b
1749   0D82 27            mov b, a
1750   0D83 11            mov a, b
1751   0D84 26 0A 00      mov b, $a
1752   0D87 56            add b, a
1753   0D88 E4            pop a
1754   0D89             ; END TERMS
1755   0D89 56            add b, a
1756   0D8A E4            pop a
1757   0D8B             ; END TERMS
1758   0D8B E7            pop d
1759   0D8C FD 43         mov [d], b
1760   0D8E 0A 0E 0E      jmp _if25_exit
1761   0D91             _if25_else:
1762   0D91             ;; if (hex_char >= 'A' && hex_char <= 'F')  
1763   0D91             _if26_cond:
1764   0D91 FA FC FF      lea d, [bp + -4] ; $hex_char
1765   0D94 32            mov bl, [d]
1766   0D95 A7 00         mov bh, 0
1767   0D97             ; START RELATIONAL
1768   0D97 D7            push a
1769   0D98 11            mov a, b
1770   0D99 26 41 00      mov b, $41
1771   0D9C B0            cmp a, b
1772   0D9D FD 80         sge ; >=
1773   0D9F E4            pop a
1774   0DA0             ; END RELATIONAL
1775   0DA0             ; START LOGICAL AND
1776   0DA0 D7            push a
1777   0DA1 11            mov a, b
1778   0DA2 FA FC FF      lea d, [bp + -4] ; $hex_char
1779   0DA5 32            mov bl, [d]
1780   0DA6 A7 00         mov bh, 0
1781   0DA8             ; START RELATIONAL
1782   0DA8 D7            push a
1783   0DA9 11            mov a, b
1784   0DAA 26 46 00      mov b, $46
1785   0DAD B0            cmp a, b
1786   0DAE FD 74         sle ; <= (signed)
1787   0DB0 E4            pop a
1788   0DB1             ; END RELATIONAL
1789   0DB1 FD A7         sand a, b
1790   0DB3 E4            pop a
1791   0DB4             ; END LOGICAL AND
1792   0DB4 C0 00 00      cmp b, 0
1793   0DB7 C6 E8 0D      je _if26_else
1794   0DBA             _if26_true:
1795   0DBA             ;; value = (value * 16) + (hex_char - 'A' + 10); 
1796   0DBA FA FF FF      lea d, [bp + -1] ; $value
1797   0DBD DA            push d
1798   0DBE FA FF FF      lea d, [bp + -1] ; $value
1799   0DC1 2A            mov b, [d]
1800   0DC2             ; START FACTORS
1801   0DC2 D7            push a
1802   0DC3 11            mov a, b
1803   0DC4 26 10 00      mov b, $10
1804   0DC7 AC            mul a, b ; *
1805   0DC8 11            mov a, b
1806   0DC9 27            mov b, a
1807   0DCA E4            pop a
1808   0DCB             ; END FACTORS
1809   0DCB             ; START TERMS
1810   0DCB D7            push a
1811   0DCC 11            mov a, b
1812   0DCD FA FC FF      lea d, [bp + -4] ; $hex_char
1813   0DD0 32            mov bl, [d]
1814   0DD1 A7 00         mov bh, 0
1815   0DD3             ; START TERMS
1816   0DD3 D7            push a
1817   0DD4 11            mov a, b
1818   0DD5 26 41 00      mov b, $41
1819   0DD8 60            sub a, b
1820   0DD9 27            mov b, a
1821   0DDA 11            mov a, b
1822   0DDB 26 0A 00      mov b, $a
1823   0DDE 56            add b, a
1824   0DDF E4            pop a
1825   0DE0             ; END TERMS
1826   0DE0 56            add b, a
1827   0DE1 E4            pop a
1828   0DE2             ; END TERMS
1829   0DE2 E7            pop d
1830   0DE3 FD 43         mov [d], b
1831   0DE5 0A 0E 0E      jmp _if26_exit
1832   0DE8             _if26_else:
1833   0DE8             ;; value = (value * 16) + (hex_char - '0'); 
1834   0DE8 FA FF FF      lea d, [bp + -1] ; $value
1835   0DEB DA            push d
1836   0DEC FA FF FF      lea d, [bp + -1] ; $value
1837   0DEF 2A            mov b, [d]
1838   0DF0             ; START FACTORS
1839   0DF0 D7            push a
1840   0DF1 11            mov a, b
1841   0DF2 26 10 00      mov b, $10
1842   0DF5 AC            mul a, b ; *
1843   0DF6 11            mov a, b
1844   0DF7 27            mov b, a
1845   0DF8 E4            pop a
1846   0DF9             ; END FACTORS
1847   0DF9             ; START TERMS
1848   0DF9 D7            push a
1849   0DFA 11            mov a, b
1850   0DFB FA FC FF      lea d, [bp + -4] ; $hex_char
1851   0DFE 32            mov bl, [d]
1852   0DFF A7 00         mov bh, 0
1853   0E01             ; START TERMS
1854   0E01 D7            push a
1855   0E02 11            mov a, b
1856   0E03 26 30 00      mov b, $30
1857   0E06 60            sub a, b
1858   0E07 27            mov b, a
1859   0E08 E4            pop a
1860   0E09             ; END TERMS
1861   0E09 56            add b, a
1862   0E0A E4            pop a
1863   0E0B             ; END TERMS
1864   0E0B E7            pop d
1865   0E0C FD 43         mov [d], b
1866   0E0E             _if26_exit:
1867   0E0E             _if25_exit:
1868   0E0E             _for24_update:
1869   0E0E FA FD FF      lea d, [bp + -3] ; $i
1870   0E11 2A            mov b, [d]
1871   0E12 FD 77         inc b
1872   0E14 FA FD FF      lea d, [bp + -3] ; $i
1873   0E17 FD 43         mov [d], b
1874   0E19 FD 7D         dec b
1875   0E1B 0A 0B 0D      jmp _for24_cond
1876   0E1E             _for24_exit:
1877   0E1E             ;; return value; 
1878   0E1E FA FF FF      lea d, [bp + -1] ; $value
1879   0E21 2A            mov b, [d]
1880   0E22 F9            leave
1881   0E23 09            ret
1882   0E24             
1883   0E24             gets:
1884   0E24 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1885   0E27             
1886   0E27             ; --- BEGIN INLINE ASM BLOCK
1887   0E27 FA 05 00      lea d, [bp + 5] ; $s
1888   0E2A 15            mov a, [d]
1889   0E2B 3C            mov d, a
1890   0E2C 07 DB 16      call _gets
1891   0E2F             ; --- END INLINE ASM BLOCK
1892   0E2F             
1893   0E2F             ;; return strlen(s); 
1894   0E2F FA 05 00      lea d, [bp + 5] ; $s
1895   0E32 2A            mov b, [d]
1896   0E33 FD AB         swp b
1897   0E35 D8            push b
1898   0E36 07 BF 05      call strlen
1899   0E39 51 02 00      add sp, 2
1900   0E3C F9            leave
1901   0E3D 09            ret
1902   0E3E             
1903   0E3E             print_signed:
1904   0E3E F8 00 00      enter 0 ; (push bp; mov bp, sp)
1905   0E41             ;; char digits[5]; 
1906   0E41 52 05 00      sub sp, 5 ; digits
1907   0E44             ;; int i = 0; 
1908   0E44 52 02 00      sub sp, 2 ; i
1909   0E47             ; --- START LOCAL VAR INITIALIZATION
1910   0E47 FA FA FF      lea d, [bp + -6] ; $i
1911   0E4A DA            push d
1912   0E4B 26 00 00      mov b, $0
1913   0E4E E7            pop d
1914   0E4F FD 43         mov [d], b
1915   0E51             ; --- END LOCAL VAR INITIALIZATION
1916   0E51             ;; if (num < 0) { 
1917   0E51             _if27_cond:
1918   0E51 FA 05 00      lea d, [bp + 5] ; $num
1919   0E54 2A            mov b, [d]
1920   0E55             ; START RELATIONAL
1921   0E55 D7            push a
1922   0E56 11            mov a, b
1923   0E57 26 00 00      mov b, $0
1924   0E5A B0            cmp a, b
1925   0E5B FD 73         slt ; < (signed)
1926   0E5D E4            pop a
1927   0E5E             ; END RELATIONAL
1928   0E5E C0 00 00      cmp b, 0
1929   0E61 C6 7E 0E      je _if27_else
1930   0E64             _if27_true:
1931   0E64             ;; putchar('-'); 
1932   0E64 26 2D 00      mov b, $2d
1933   0E67 DD            push bl
1934   0E68 07 43 15      call putchar
1935   0E6B 51 01 00      add sp, 1
1936   0E6E             ;; num = -num; 
1937   0E6E FA 05 00      lea d, [bp + 5] ; $num
1938   0E71 DA            push d
1939   0E72 FA 05 00      lea d, [bp + 5] ; $num
1940   0E75 2A            mov b, [d]
1941   0E76 FD 97         neg b
1942   0E78 E7            pop d
1943   0E79 FD 43         mov [d], b
1944   0E7B 0A A0 0E      jmp _if27_exit
1945   0E7E             _if27_else:
1946   0E7E             ;; if (num == 0) { 
1947   0E7E             _if28_cond:
1948   0E7E FA 05 00      lea d, [bp + 5] ; $num
1949   0E81 2A            mov b, [d]
1950   0E82             ; START RELATIONAL
1951   0E82 D7            push a
1952   0E83 11            mov a, b
1953   0E84 26 00 00      mov b, $0
1954   0E87 B0            cmp a, b
1955   0E88 FD 71         seq ; ==
1956   0E8A E4            pop a
1957   0E8B             ; END RELATIONAL
1958   0E8B C0 00 00      cmp b, 0
1959   0E8E C6 A0 0E      je _if28_exit
1960   0E91             _if28_true:
1961   0E91             ;; putchar('0'); 
1962   0E91 26 30 00      mov b, $30
1963   0E94 DD            push bl
1964   0E95 07 43 15      call putchar
1965   0E98 51 01 00      add sp, 1
1966   0E9B             ;; return; 
1967   0E9B F9            leave
1968   0E9C 09            ret
1969   0E9D 0A A0 0E      jmp _if28_exit
1970   0EA0             _if28_exit:
1971   0EA0             _if27_exit:
1972   0EA0             ;; while (num > 0) { 
1973   0EA0             _while29_cond:
1974   0EA0 FA 05 00      lea d, [bp + 5] ; $num
1975   0EA3 2A            mov b, [d]
1976   0EA4             ; START RELATIONAL
1977   0EA4 D7            push a
1978   0EA5 11            mov a, b
1979   0EA6 26 00 00      mov b, $0
1980   0EA9 B0            cmp a, b
1981   0EAA FD 7F         sgt ; >
1982   0EAC E4            pop a
1983   0EAD             ; END RELATIONAL
1984   0EAD C0 00 00      cmp b, 0
1985   0EB0 C6 FA 0E      je _while29_exit
1986   0EB3             _while29_block:
1987   0EB3             ;; digits[i] = '0' + (num % 10); 
1988   0EB3 FA FC FF      lea d, [bp + -4] ; $digits
1989   0EB6 D7            push a
1990   0EB7 DA            push d
1991   0EB8 FA FA FF      lea d, [bp + -6] ; $i
1992   0EBB 2A            mov b, [d]
1993   0EBC E7            pop d
1994   0EBD 5A            add d, b
1995   0EBE E4            pop a
1996   0EBF DA            push d
1997   0EC0 26 30 00      mov b, $30
1998   0EC3             ; START TERMS
1999   0EC3 D7            push a
2000   0EC4 11            mov a, b
2001   0EC5 FA 05 00      lea d, [bp + 5] ; $num
2002   0EC8 2A            mov b, [d]
2003   0EC9             ; START FACTORS
2004   0EC9 D7            push a
2005   0ECA 11            mov a, b
2006   0ECB 26 0A 00      mov b, $a
2007   0ECE AE            div a, b ; 
2008   0ECF 11            mov a, b
2009   0ED0 27            mov b, a
2010   0ED1 E4            pop a
2011   0ED2             ; END FACTORS
2012   0ED2 56            add b, a
2013   0ED3 E4            pop a
2014   0ED4             ; END TERMS
2015   0ED4 E7            pop d
2016   0ED5 FD 3E         mov [d], bl
2017   0ED7             ;; num = num / 10; 
2018   0ED7 FA 05 00      lea d, [bp + 5] ; $num
2019   0EDA DA            push d
2020   0EDB FA 05 00      lea d, [bp + 5] ; $num
2021   0EDE 2A            mov b, [d]
2022   0EDF             ; START FACTORS
2023   0EDF D7            push a
2024   0EE0 11            mov a, b
2025   0EE1 26 0A 00      mov b, $a
2026   0EE4 AE            div a, b
2027   0EE5 27            mov b, a
2028   0EE6 E4            pop a
2029   0EE7             ; END FACTORS
2030   0EE7 E7            pop d
2031   0EE8 FD 43         mov [d], b
2032   0EEA             ;; i++; 
2033   0EEA FA FA FF      lea d, [bp + -6] ; $i
2034   0EED 2A            mov b, [d]
2035   0EEE FD 77         inc b
2036   0EF0 FA FA FF      lea d, [bp + -6] ; $i
2037   0EF3 FD 43         mov [d], b
2038   0EF5 FD 7D         dec b
2039   0EF7 0A A0 0E      jmp _while29_cond
2040   0EFA             _while29_exit:
2041   0EFA             ;; while (i > 0) { 
2042   0EFA             _while30_cond:
2043   0EFA FA FA FF      lea d, [bp + -6] ; $i
2044   0EFD 2A            mov b, [d]
2045   0EFE             ; START RELATIONAL
2046   0EFE D7            push a
2047   0EFF 11            mov a, b
2048   0F00 26 00 00      mov b, $0
2049   0F03 B0            cmp a, b
2050   0F04 FD 7F         sgt ; >
2051   0F06 E4            pop a
2052   0F07             ; END RELATIONAL
2053   0F07 C0 00 00      cmp b, 0
2054   0F0A C6 33 0F      je _while30_exit
2055   0F0D             _while30_block:
2056   0F0D             ;; i--; 
2057   0F0D FA FA FF      lea d, [bp + -6] ; $i
2058   0F10 2A            mov b, [d]
2059   0F11 FD 7D         dec b
2060   0F13 FA FA FF      lea d, [bp + -6] ; $i
2061   0F16 FD 43         mov [d], b
2062   0F18 FD 77         inc b
2063   0F1A             ;; putchar(digits[i]); 
2064   0F1A FA FC FF      lea d, [bp + -4] ; $digits
2065   0F1D D7            push a
2066   0F1E DA            push d
2067   0F1F FA FA FF      lea d, [bp + -6] ; $i
2068   0F22 2A            mov b, [d]
2069   0F23 E7            pop d
2070   0F24 5A            add d, b
2071   0F25 E4            pop a
2072   0F26 32            mov bl, [d]
2073   0F27 A7 00         mov bh, 0
2074   0F29 DD            push bl
2075   0F2A 07 43 15      call putchar
2076   0F2D 51 01 00      add sp, 1
2077   0F30 0A FA 0E      jmp _while30_cond
2078   0F33             _while30_exit:
2079   0F33 F9            leave
2080   0F34 09            ret
2081   0F35             
2082   0F35             print_signed_long:
2083   0F35 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2084   0F38             ;; char digits[10]; 
2085   0F38 52 0A 00      sub sp, 10 ; digits
2086   0F3B             ;; int i = 0; 
2087   0F3B 52 02 00      sub sp, 2 ; i
2088   0F3E             ; --- START LOCAL VAR INITIALIZATION
2089   0F3E FA F5 FF      lea d, [bp + -11] ; $i
2090   0F41 DA            push d
2091   0F42 26 00 00      mov b, $0
2092   0F45 E7            pop d
2093   0F46 FD 43         mov [d], b
2094   0F48             ; --- END LOCAL VAR INITIALIZATION
2095   0F48             ;; if (num < 0) { 
2096   0F48             _if31_cond:
2097   0F48 FA 05 00      lea d, [bp + 5] ; $num
2098   0F4B 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2099   0F4E FD 39         mov c, b ; And place it into C
2100   0F50 2A            mov b, [d] ; Lower Word in B
2101   0F51             ; START RELATIONAL
2102   0F51 D7            push a
2103   0F52 FD D8         push g
2104   0F54 11            mov a, b
2105   0F55 FD 7A         mov g, c
2106   0F57 26 00 00      mov b, $0
2107   0F5A 38 00 00      mov c, 0
2108   0F5D FD AF 00 00   cmp32 ga, cb
2108   0F61 00 00 00 00 
2108   0F65 00 00 00 00 
2108   0F69 00 00 00 00 
2108   0F6D 00 00 00 00 
2108   0F71 00 00 00 00 
2108   0F75 00 00 00 00 
2108   0F79 00 00 00 00 
2108   0F7D 00 00 00 00 
2108   0F81 00 00 00 00 
2108   0F85 00 00 00 00 
2108   0F89 00 00 00 00 
2108   0F8D 00 00 00 00 
2108   0F91 00 00 00 00 
2108   0F95 00 00 00 00 
2108   0F99 00 00 00 00 
2108   0F9D 00 00 00 00 
2108   0FA1 00 00 00 00 
2108   0FA5 00 00 00 00 
2108   0FA9 00 00 00 00 
2108   0FAD 00 00 00 00 
2108   0FB1 00 00 00 00 
2108   0FB5 00 00 00 00 
2108   0FB9 00 00 00 00 
2108   0FBD 00 00 00 00 
2108   0FC1 00 00 00 00 
2108   0FC5 00 00 00 00 
2108   0FC9 00 00 00 00 
2108   0FCD 00 00 00 00 
2108   0FD1 00 00 00 00 
2108   0FD5 00 00 00 00 
2108   0FD9 00 00 00 00 
2108   0FDD 00 00 00 00 
2108   0FE1 00 00 00 00 
2108   0FE5 00 00 00 00 
2108   0FE9 00 00 00 00 
2108   0FED 00 00 00 00 
2108   0FF1 00 00 00 00 
2108   0FF5 00 00 00 00 
2108   0FF9 00 00 00 00 
2108   0FFD 00 00 00 00 
2108   1001 00 00 00 00 
2108   1005 00 00 00 00 
2108   1009 00 00 00 00 
2108   100D 00 00 00 00 
2108   1011 00 00 00 00 
2108   1015 00 00 00 00 
2108   1019 00 00 00 00 
2108   101D 00 00 00 00 
2108   1021 00 00 00 00 
2108   1025 00 00 00 00 
2108   1029 00 00 00 00 
2108   102D 00 00 00 00 
2108   1031 00 00 00 00 
2108   1035 00 00 00 00 
2108   1039 00 00 00 00 
2108   103D 00 00 00 00 
2108   1041 00 00 00 00 
2108   1045 00 00 00 00 
2108   1049 00 00 00 00 
2108   104D 00 00 00 00 
2108   1051 00 00 00 00 
2108   1055 00 00 00 00 
2108   1059 00 00 00 00 
2108   105D 00 
2109   105E FD 73         slt ; <
2110   1060 FD F1         pop g
2111   1062 E4            pop a
2112   1063             ; END RELATIONAL
2113   1063 C0 00 00      cmp b, 0
2114   1066 C6 8D 10      je _if31_else
2115   1069             _if31_true:
2116   1069             ;; putchar('-'); 
2117   1069 26 2D 00      mov b, $2d
2118   106C DD            push bl
2119   106D 07 43 15      call putchar
2120   1070 51 01 00      add sp, 1
2121   1073             ;; num = -num; 
2122   1073 FA 05 00      lea d, [bp + 5] ; $num
2123   1076 DA            push d
2124   1077 FA 05 00      lea d, [bp + 5] ; $num
2125   107A 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2126   107D FD 39         mov c, b ; And place it into C
2127   107F 2A            mov b, [d] ; Lower Word in B
2128   1080 FD 97         neg b
2129   1082 E7            pop d
2130   1083 FD 43         mov [d], b
2131   1085 28            mov b, c
2132   1086 FD 44 02 00   mov [d + 2], b
2133   108A 0A BD 11      jmp _if31_exit
2134   108D             _if31_else:
2135   108D             ;; if (num == 0) { 
2136   108D             _if32_cond:
2137   108D FA 05 00      lea d, [bp + 5] ; $num
2138   1090 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2139   1093 FD 39         mov c, b ; And place it into C
2140   1095 2A            mov b, [d] ; Lower Word in B
2141   1096             ; START RELATIONAL
2142   1096 D7            push a
2143   1097 FD D8         push g
2144   1099 11            mov a, b
2145   109A FD 7A         mov g, c
2146   109C 26 00 00      mov b, $0
2147   109F 38 00 00      mov c, 0
2148   10A2 FD AF 00 00   cmp32 ga, cb
2148   10A6 00 00 00 00 
2148   10AA 00 00 00 00 
2148   10AE 00 00 00 00 
2148   10B2 00 00 00 00 
2148   10B6 00 00 00 00 
2148   10BA 00 00 00 00 
2148   10BE 00 00 00 00 
2148   10C2 00 00 00 00 
2148   10C6 00 00 00 00 
2148   10CA 00 00 00 00 
2148   10CE 00 00 00 00 
2148   10D2 00 00 00 00 
2148   10D6 00 00 00 00 
2148   10DA 00 00 00 00 
2148   10DE 00 00 00 00 
2148   10E2 00 00 00 00 
2148   10E6 00 00 00 00 
2148   10EA 00 00 00 00 
2148   10EE 00 00 00 00 
2148   10F2 00 00 00 00 
2148   10F6 00 00 00 00 
2148   10FA 00 00 00 00 
2148   10FE 00 00 00 00 
2148   1102 00 00 00 00 
2148   1106 00 00 00 00 
2148   110A 00 00 00 00 
2148   110E 00 00 00 00 
2148   1112 00 00 00 00 
2148   1116 00 00 00 00 
2148   111A 00 00 00 00 
2148   111E 00 00 00 00 
2148   1122 00 00 00 00 
2148   1126 00 00 00 00 
2148   112A 00 00 00 00 
2148   112E 00 00 00 00 
2148   1132 00 00 00 00 
2148   1136 00 00 00 00 
2148   113A 00 00 00 00 
2148   113E 00 00 00 00 
2148   1142 00 00 00 00 
2148   1146 00 00 00 00 
2148   114A 00 00 00 00 
2148   114E 00 00 00 00 
2148   1152 00 00 00 00 
2148   1156 00 00 00 00 
2148   115A 00 00 00 00 
2148   115E 00 00 00 00 
2148   1162 00 00 00 00 
2148   1166 00 00 00 00 
2148   116A 00 00 00 00 
2148   116E 00 00 00 00 
2148   1172 00 00 00 00 
2148   1176 00 00 00 00 
2148   117A 00 00 00 00 
2148   117E 00 00 00 00 
2148   1182 00 00 00 00 
2148   1186 00 00 00 00 
2148   118A 00 00 00 00 
2148   118E 00 00 00 00 
2148   1192 00 00 00 00 
2148   1196 00 00 00 00 
2148   119A 00 00 00 00 
2148   119E 00 00 00 00 
2148   11A2 00 
2149   11A3 FD 71         seq ; ==
2150   11A5 FD F1         pop g
2151   11A7 E4            pop a
2152   11A8             ; END RELATIONAL
2153   11A8 C0 00 00      cmp b, 0
2154   11AB C6 BD 11      je _if32_exit
2155   11AE             _if32_true:
2156   11AE             ;; putchar('0'); 
2157   11AE 26 30 00      mov b, $30
2158   11B1 DD            push bl
2159   11B2 07 43 15      call putchar
2160   11B5 51 01 00      add sp, 1
2161   11B8             ;; return; 
2162   11B8 F9            leave
2163   11B9 09            ret
2164   11BA 0A BD 11      jmp _if32_exit
2165   11BD             _if32_exit:
2166   11BD             _if31_exit:
2167   11BD             ;; while (num > 0) { 
2168   11BD             _while33_cond:
2169   11BD FA 05 00      lea d, [bp + 5] ; $num
2170   11C0 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2171   11C3 FD 39         mov c, b ; And place it into C
2172   11C5 2A            mov b, [d] ; Lower Word in B
2173   11C6             ; START RELATIONAL
2174   11C6 D7            push a
2175   11C7 FD D8         push g
2176   11C9 11            mov a, b
2177   11CA FD 7A         mov g, c
2178   11CC 26 00 00      mov b, $0
2179   11CF 38 00 00      mov c, 0
2180   11D2 FD 7F         sgt
2181   11D4 FD F1         pop g
2182   11D6 E4            pop a
2183   11D7             ; END RELATIONAL
2184   11D7 C0 00 00      cmp b, 0
2185   11DA C6 3A 12      je _while33_exit
2186   11DD             _while33_block:
2187   11DD             ;; digits[i] = '0' + (num % 10); 
2188   11DD FA F7 FF      lea d, [bp + -9] ; $digits
2189   11E0 D7            push a
2190   11E1 DA            push d
2191   11E2 FA F5 FF      lea d, [bp + -11] ; $i
2192   11E5 2A            mov b, [d]
2193   11E6 E7            pop d
2194   11E7 5A            add d, b
2195   11E8 E4            pop a
2196   11E9 DA            push d
2197   11EA 26 30 00      mov b, $30
2198   11ED             ; START TERMS
2199   11ED D7            push a
2200   11EE 11            mov a, b
2201   11EF FA 05 00      lea d, [bp + 5] ; $num
2202   11F2 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2203   11F5 FD 39         mov c, b ; And place it into C
2204   11F7 2A            mov b, [d] ; Lower Word in B
2205   11F8             ; START FACTORS
2206   11F8 D7            push a
2207   11F9 11            mov a, b
2208   11FA 26 0A 00      mov b, $a
2209   11FD AE            div a, b ; 
2210   11FE 11            mov a, b
2211   11FF 27            mov b, a
2212   1200 E4            pop a
2213   1201             ; END FACTORS
2214   1201 54            add a, b
2215   1202 D7            push a
2216   1203 FD 12         mov a, g
2217   1205 28            mov b, c
2218   1206 5C            adc a, b
2219   1207 39            mov c, a
2220   1208 E5            pop b
2221   1209 E4            pop a
2222   120A             ; END TERMS
2223   120A E7            pop d
2224   120B FD 3E         mov [d], bl
2225   120D             ;; num = num / 10; 
2226   120D FA 05 00      lea d, [bp + 5] ; $num
2227   1210 DA            push d
2228   1211 FA 05 00      lea d, [bp + 5] ; $num
2229   1214 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2230   1217 FD 39         mov c, b ; And place it into C
2231   1219 2A            mov b, [d] ; Lower Word in B
2232   121A             ; START FACTORS
2233   121A D7            push a
2234   121B 11            mov a, b
2235   121C 26 0A 00      mov b, $a
2236   121F AE            div a, b
2237   1220 27            mov b, a
2238   1221 E4            pop a
2239   1222             ; END FACTORS
2240   1222 E7            pop d
2241   1223 FD 43         mov [d], b
2242   1225 28            mov b, c
2243   1226 FD 44 02 00   mov [d + 2], b
2244   122A             ;; i++; 
2245   122A FA F5 FF      lea d, [bp + -11] ; $i
2246   122D 2A            mov b, [d]
2247   122E FD 77         inc b
2248   1230 FA F5 FF      lea d, [bp + -11] ; $i
2249   1233 FD 43         mov [d], b
2250   1235 FD 7D         dec b
2251   1237 0A BD 11      jmp _while33_cond
2252   123A             _while33_exit:
2253   123A             ;; while (i > 0) { 
2254   123A             _while34_cond:
2255   123A FA F5 FF      lea d, [bp + -11] ; $i
2256   123D 2A            mov b, [d]
2257   123E             ; START RELATIONAL
2258   123E D7            push a
2259   123F 11            mov a, b
2260   1240 26 00 00      mov b, $0
2261   1243 B0            cmp a, b
2262   1244 FD 7F         sgt ; >
2263   1246 E4            pop a
2264   1247             ; END RELATIONAL
2265   1247 C0 00 00      cmp b, 0
2266   124A C6 73 12      je _while34_exit
2267   124D             _while34_block:
2268   124D             ;; i--; 
2269   124D FA F5 FF      lea d, [bp + -11] ; $i
2270   1250 2A            mov b, [d]
2271   1251 FD 7D         dec b
2272   1253 FA F5 FF      lea d, [bp + -11] ; $i
2273   1256 FD 43         mov [d], b
2274   1258 FD 77         inc b
2275   125A             ;; putchar(digits[i]); 
2276   125A FA F7 FF      lea d, [bp + -9] ; $digits
2277   125D D7            push a
2278   125E DA            push d
2279   125F FA F5 FF      lea d, [bp + -11] ; $i
2280   1262 2A            mov b, [d]
2281   1263 E7            pop d
2282   1264 5A            add d, b
2283   1265 E4            pop a
2284   1266 32            mov bl, [d]
2285   1267 A7 00         mov bh, 0
2286   1269 DD            push bl
2287   126A 07 43 15      call putchar
2288   126D 51 01 00      add sp, 1
2289   1270 0A 3A 12      jmp _while34_cond
2290   1273             _while34_exit:
2291   1273 F9            leave
2292   1274 09            ret
2293   1275             
2294   1275             print_unsigned_long:
2295   1275 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2296   1278             ;; char digits[10]; 
2297   1278 52 0A 00      sub sp, 10 ; digits
2298   127B             ;; int i; 
2299   127B 52 02 00      sub sp, 2 ; i
2300   127E             ;; i = 0; 
2301   127E FA F5 FF      lea d, [bp + -11] ; $i
2302   1281 DA            push d
2303   1282 26 00 00      mov b, $0
2304   1285 E7            pop d
2305   1286 FD 43         mov [d], b
2306   1288             ;; if(num == 0){ 
2307   1288             _if35_cond:
2308   1288 FA 05 00      lea d, [bp + 5] ; $num
2309   128B 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2310   128E FD 39         mov c, b ; And place it into C
2311   1290 2A            mov b, [d] ; Lower Word in B
2312   1291             ; START RELATIONAL
2313   1291 D7            push a
2314   1292 FD D8         push g
2315   1294 11            mov a, b
2316   1295 FD 7A         mov g, c
2317   1297 26 00 00      mov b, $0
2318   129A 38 00 00      mov c, 0
2319   129D FD AF 00 00   cmp32 ga, cb
2319   12A1 00 00 00 00 
2319   12A5 00 00 00 00 
2319   12A9 00 00 00 00 
2319   12AD 00 00 00 00 
2319   12B1 00 00 00 00 
2319   12B5 00 00 00 00 
2319   12B9 00 00 00 00 
2319   12BD 00 00 00 00 
2319   12C1 00 00 00 00 
2319   12C5 00 00 00 00 
2319   12C9 00 00 00 00 
2319   12CD 00 00 00 00 
2319   12D1 00 00 00 00 
2319   12D5 00 00 00 00 
2319   12D9 00 00 00 00 
2319   12DD 00 00 00 00 
2319   12E1 00 00 00 00 
2319   12E5 00 00 00 00 
2319   12E9 00 00 00 00 
2319   12ED 00 00 00 00 
2319   12F1 00 00 00 00 
2319   12F5 00 00 00 00 
2319   12F9 00 00 00 00 
2319   12FD 00 00 00 00 
2319   1301 00 00 00 00 
2319   1305 00 00 00 00 
2319   1309 00 00 00 00 
2319   130D 00 00 00 00 
2319   1311 00 00 00 00 
2319   1315 00 00 00 00 
2319   1319 00 00 00 00 
2319   131D 00 00 00 00 
2319   1321 00 00 00 00 
2319   1325 00 00 00 00 
2319   1329 00 00 00 00 
2319   132D 00 00 00 00 
2319   1331 00 00 00 00 
2319   1335 00 00 00 00 
2319   1339 00 00 00 00 
2319   133D 00 00 00 00 
2319   1341 00 00 00 00 
2319   1345 00 00 00 00 
2319   1349 00 00 00 00 
2319   134D 00 00 00 00 
2319   1351 00 00 00 00 
2319   1355 00 00 00 00 
2319   1359 00 00 00 00 
2319   135D 00 00 00 00 
2319   1361 00 00 00 00 
2319   1365 00 00 00 00 
2319   1369 00 00 00 00 
2319   136D 00 00 00 00 
2319   1371 00 00 00 00 
2319   1375 00 00 00 00 
2319   1379 00 00 00 00 
2319   137D 00 00 00 00 
2319   1381 00 00 00 00 
2319   1385 00 00 00 00 
2319   1389 00 00 00 00 
2319   138D 00 00 00 00 
2319   1391 00 00 00 00 
2319   1395 00 00 00 00 
2319   1399 00 00 00 00 
2319   139D 00 
2320   139E FD 71         seq ; ==
2321   13A0 FD F1         pop g
2322   13A2 E4            pop a
2323   13A3             ; END RELATIONAL
2324   13A3 C0 00 00      cmp b, 0
2325   13A6 C6 B8 13      je _if35_exit
2326   13A9             _if35_true:
2327   13A9             ;; putchar('0'); 
2328   13A9 26 30 00      mov b, $30
2329   13AC DD            push bl
2330   13AD 07 43 15      call putchar
2331   13B0 51 01 00      add sp, 1
2332   13B3             ;; return; 
2333   13B3 F9            leave
2334   13B4 09            ret
2335   13B5 0A B8 13      jmp _if35_exit
2336   13B8             _if35_exit:
2337   13B8             ;; while (num > 0) { 
2338   13B8             _while36_cond:
2339   13B8 FA 05 00      lea d, [bp + 5] ; $num
2340   13BB 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2341   13BE FD 39         mov c, b ; And place it into C
2342   13C0 2A            mov b, [d] ; Lower Word in B
2343   13C1             ; START RELATIONAL
2344   13C1 D7            push a
2345   13C2 FD D8         push g
2346   13C4 11            mov a, b
2347   13C5 FD 7A         mov g, c
2348   13C7 26 00 00      mov b, $0
2349   13CA 38 00 00      mov c, 0
2350   13CD FD 81         sgu
2351   13CF FD F1         pop g
2352   13D1 E4            pop a
2353   13D2             ; END RELATIONAL
2354   13D2 C0 00 00      cmp b, 0
2355   13D5 C6 35 14      je _while36_exit
2356   13D8             _while36_block:
2357   13D8             ;; digits[i] = '0' + (num % 10); 
2358   13D8 FA F7 FF      lea d, [bp + -9] ; $digits
2359   13DB D7            push a
2360   13DC DA            push d
2361   13DD FA F5 FF      lea d, [bp + -11] ; $i
2362   13E0 2A            mov b, [d]
2363   13E1 E7            pop d
2364   13E2 5A            add d, b
2365   13E3 E4            pop a
2366   13E4 DA            push d
2367   13E5 26 30 00      mov b, $30
2368   13E8             ; START TERMS
2369   13E8 D7            push a
2370   13E9 11            mov a, b
2371   13EA FA 05 00      lea d, [bp + 5] ; $num
2372   13ED 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2373   13F0 FD 39         mov c, b ; And place it into C
2374   13F2 2A            mov b, [d] ; Lower Word in B
2375   13F3             ; START FACTORS
2376   13F3 D7            push a
2377   13F4 11            mov a, b
2378   13F5 26 0A 00      mov b, $a
2379   13F8 AE            div a, b ; 
2380   13F9 11            mov a, b
2381   13FA 27            mov b, a
2382   13FB E4            pop a
2383   13FC             ; END FACTORS
2384   13FC 54            add a, b
2385   13FD D7            push a
2386   13FE FD 12         mov a, g
2387   1400 28            mov b, c
2388   1401 5C            adc a, b
2389   1402 39            mov c, a
2390   1403 E5            pop b
2391   1404 E4            pop a
2392   1405             ; END TERMS
2393   1405 E7            pop d
2394   1406 FD 3E         mov [d], bl
2395   1408             ;; num = num / 10; 
2396   1408 FA 05 00      lea d, [bp + 5] ; $num
2397   140B DA            push d
2398   140C FA 05 00      lea d, [bp + 5] ; $num
2399   140F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2400   1412 FD 39         mov c, b ; And place it into C
2401   1414 2A            mov b, [d] ; Lower Word in B
2402   1415             ; START FACTORS
2403   1415 D7            push a
2404   1416 11            mov a, b
2405   1417 26 0A 00      mov b, $a
2406   141A AE            div a, b
2407   141B 27            mov b, a
2408   141C E4            pop a
2409   141D             ; END FACTORS
2410   141D E7            pop d
2411   141E FD 43         mov [d], b
2412   1420 28            mov b, c
2413   1421 FD 44 02 00   mov [d + 2], b
2414   1425             ;; i++; 
2415   1425 FA F5 FF      lea d, [bp + -11] ; $i
2416   1428 2A            mov b, [d]
2417   1429 FD 77         inc b
2418   142B FA F5 FF      lea d, [bp + -11] ; $i
2419   142E FD 43         mov [d], b
2420   1430 FD 7D         dec b
2421   1432 0A B8 13      jmp _while36_cond
2422   1435             _while36_exit:
2423   1435             ;; while (i > 0) { 
2424   1435             _while37_cond:
2425   1435 FA F5 FF      lea d, [bp + -11] ; $i
2426   1438 2A            mov b, [d]
2427   1439             ; START RELATIONAL
2428   1439 D7            push a
2429   143A 11            mov a, b
2430   143B 26 00 00      mov b, $0
2431   143E B0            cmp a, b
2432   143F FD 7F         sgt ; >
2433   1441 E4            pop a
2434   1442             ; END RELATIONAL
2435   1442 C0 00 00      cmp b, 0
2436   1445 C6 6E 14      je _while37_exit
2437   1448             _while37_block:
2438   1448             ;; i--; 
2439   1448 FA F5 FF      lea d, [bp + -11] ; $i
2440   144B 2A            mov b, [d]
2441   144C FD 7D         dec b
2442   144E FA F5 FF      lea d, [bp + -11] ; $i
2443   1451 FD 43         mov [d], b
2444   1453 FD 77         inc b
2445   1455             ;; putchar(digits[i]); 
2446   1455 FA F7 FF      lea d, [bp + -9] ; $digits
2447   1458 D7            push a
2448   1459 DA            push d
2449   145A FA F5 FF      lea d, [bp + -11] ; $i
2450   145D 2A            mov b, [d]
2451   145E E7            pop d
2452   145F 5A            add d, b
2453   1460 E4            pop a
2454   1461 32            mov bl, [d]
2455   1462 A7 00         mov bh, 0
2456   1464 DD            push bl
2457   1465 07 43 15      call putchar
2458   1468 51 01 00      add sp, 1
2459   146B 0A 35 14      jmp _while37_cond
2460   146E             _while37_exit:
2461   146E F9            leave
2462   146F 09            ret
2463   1470             
2464   1470             print_unsigned:
2465   1470 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2466   1473             ;; char digits[5]; 
2467   1473 52 05 00      sub sp, 5 ; digits
2468   1476             ;; int i; 
2469   1476 52 02 00      sub sp, 2 ; i
2470   1479             ;; i = 0; 
2471   1479 FA FA FF      lea d, [bp + -6] ; $i
2472   147C DA            push d
2473   147D 26 00 00      mov b, $0
2474   1480 E7            pop d
2475   1481 FD 43         mov [d], b
2476   1483             ;; if(num == 0){ 
2477   1483             _if38_cond:
2478   1483 FA 05 00      lea d, [bp + 5] ; $num
2479   1486 2A            mov b, [d]
2480   1487             ; START RELATIONAL
2481   1487 D7            push a
2482   1488 11            mov a, b
2483   1489 26 00 00      mov b, $0
2484   148C B0            cmp a, b
2485   148D FD 71         seq ; ==
2486   148F E4            pop a
2487   1490             ; END RELATIONAL
2488   1490 C0 00 00      cmp b, 0
2489   1493 C6 A5 14      je _if38_exit
2490   1496             _if38_true:
2491   1496             ;; putchar('0'); 
2492   1496 26 30 00      mov b, $30
2493   1499 DD            push bl
2494   149A 07 43 15      call putchar
2495   149D 51 01 00      add sp, 1
2496   14A0             ;; return; 
2497   14A0 F9            leave
2498   14A1 09            ret
2499   14A2 0A A5 14      jmp _if38_exit
2500   14A5             _if38_exit:
2501   14A5             ;; while (num > 0) { 
2502   14A5             _while39_cond:
2503   14A5 FA 05 00      lea d, [bp + 5] ; $num
2504   14A8 2A            mov b, [d]
2505   14A9             ; START RELATIONAL
2506   14A9 D7            push a
2507   14AA 11            mov a, b
2508   14AB 26 00 00      mov b, $0
2509   14AE B0            cmp a, b
2510   14AF FD 81         sgu ; > (unsigned)
2511   14B1 E4            pop a
2512   14B2             ; END RELATIONAL
2513   14B2 C0 00 00      cmp b, 0
2514   14B5 C6 FF 14      je _while39_exit
2515   14B8             _while39_block:
2516   14B8             ;; digits[i] = '0' + (num % 10); 
2517   14B8 FA FC FF      lea d, [bp + -4] ; $digits
2518   14BB D7            push a
2519   14BC DA            push d
2520   14BD FA FA FF      lea d, [bp + -6] ; $i
2521   14C0 2A            mov b, [d]
2522   14C1 E7            pop d
2523   14C2 5A            add d, b
2524   14C3 E4            pop a
2525   14C4 DA            push d
2526   14C5 26 30 00      mov b, $30
2527   14C8             ; START TERMS
2528   14C8 D7            push a
2529   14C9 11            mov a, b
2530   14CA FA 05 00      lea d, [bp + 5] ; $num
2531   14CD 2A            mov b, [d]
2532   14CE             ; START FACTORS
2533   14CE D7            push a
2534   14CF 11            mov a, b
2535   14D0 26 0A 00      mov b, $a
2536   14D3 AE            div a, b ; 
2537   14D4 11            mov a, b
2538   14D5 27            mov b, a
2539   14D6 E4            pop a
2540   14D7             ; END FACTORS
2541   14D7 56            add b, a
2542   14D8 E4            pop a
2543   14D9             ; END TERMS
2544   14D9 E7            pop d
2545   14DA FD 3E         mov [d], bl
2546   14DC             ;; num = num / 10; 
2547   14DC FA 05 00      lea d, [bp + 5] ; $num
2548   14DF DA            push d
2549   14E0 FA 05 00      lea d, [bp + 5] ; $num
2550   14E3 2A            mov b, [d]
2551   14E4             ; START FACTORS
2552   14E4 D7            push a
2553   14E5 11            mov a, b
2554   14E6 26 0A 00      mov b, $a
2555   14E9 AE            div a, b
2556   14EA 27            mov b, a
2557   14EB E4            pop a
2558   14EC             ; END FACTORS
2559   14EC E7            pop d
2560   14ED FD 43         mov [d], b
2561   14EF             ;; i++; 
2562   14EF FA FA FF      lea d, [bp + -6] ; $i
2563   14F2 2A            mov b, [d]
2564   14F3 FD 77         inc b
2565   14F5 FA FA FF      lea d, [bp + -6] ; $i
2566   14F8 FD 43         mov [d], b
2567   14FA FD 7D         dec b
2568   14FC 0A A5 14      jmp _while39_cond
2569   14FF             _while39_exit:
2570   14FF             ;; while (i > 0) { 
2571   14FF             _while40_cond:
2572   14FF FA FA FF      lea d, [bp + -6] ; $i
2573   1502 2A            mov b, [d]
2574   1503             ; START RELATIONAL
2575   1503 D7            push a
2576   1504 11            mov a, b
2577   1505 26 00 00      mov b, $0
2578   1508 B0            cmp a, b
2579   1509 FD 7F         sgt ; >
2580   150B E4            pop a
2581   150C             ; END RELATIONAL
2582   150C C0 00 00      cmp b, 0
2583   150F C6 38 15      je _while40_exit
2584   1512             _while40_block:
2585   1512             ;; i--; 
2586   1512 FA FA FF      lea d, [bp + -6] ; $i
2587   1515 2A            mov b, [d]
2588   1516 FD 7D         dec b
2589   1518 FA FA FF      lea d, [bp + -6] ; $i
2590   151B FD 43         mov [d], b
2591   151D FD 77         inc b
2592   151F             ;; putchar(digits[i]); 
2593   151F FA FC FF      lea d, [bp + -4] ; $digits
2594   1522 D7            push a
2595   1523 DA            push d
2596   1524 FA FA FF      lea d, [bp + -6] ; $i
2597   1527 2A            mov b, [d]
2598   1528 E7            pop d
2599   1529 5A            add d, b
2600   152A E4            pop a
2601   152B 32            mov bl, [d]
2602   152C A7 00         mov bh, 0
2603   152E DD            push bl
2604   152F 07 43 15      call putchar
2605   1532 51 01 00      add sp, 1
2606   1535 0A FF 14      jmp _while40_cond
2607   1538             _while40_exit:
2608   1538 F9            leave
2609   1539 09            ret
2610   153A             
2611   153A             date:
2612   153A F8 00 00      enter 0 ; (push bp; mov bp, sp)
2613   153D             
2614   153D             ; --- BEGIN INLINE ASM BLOCK
2615   153D 19 00         mov al, 0 
2616   153F 05 07         syscall sys_datetime
2617   1541             ; --- END INLINE ASM BLOCK
2618   1541             
2619   1541 F9            leave
2620   1542 09            ret
2621   1543             
2622   1543             putchar:
2623   1543 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2624   1546             
2625   1546             ; --- BEGIN INLINE ASM BLOCK
2626   1546 FA 05 00      lea d, [bp + 5] ; $c
2627   1549 1E            mov al, [d]
2628   154A 23            mov ah, al
2629   154B 07 D4 16      call _putchar
2630   154E             ; --- END INLINE ASM BLOCK
2631   154E             
2632   154E F9            leave
2633   154F 09            ret
2634   1550             
2635   1550             getchar:
2636   1550 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2637   1553             ;; char c; 
2638   1553 52 01 00      sub sp, 1 ; c
2639   1556             
2640   1556             ; --- BEGIN INLINE ASM BLOCK
2641   1556 07 CD 16      call getch
2642   1559 1A            mov al, ah
2643   155A FA 00 00      lea d, [bp + 0] ; $c
2644   155D 3E            mov [d], al
2645   155E             ; --- END INLINE ASM BLOCK
2646   155E             
2647   155E             ;; return c; 
2648   155E FA 00 00      lea d, [bp + 0] ; $c
2649   1561 32            mov bl, [d]
2650   1562 A7 00         mov bh, 0
2651   1564 F9            leave
2652   1565 09            ret
2653   1566             
2654   1566             scann:
2655   1566 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2656   1569             ;; int m; 
2657   1569 52 02 00      sub sp, 2 ; m
2658   156C             
2659   156C             ; --- BEGIN INLINE ASM BLOCK
2660   156C 07 18 19      call scan_u16d
2661   156F FA FF FF      lea d, [bp + -1] ; $m
2662   1572 43            mov [d], a
2663   1573             ; --- END INLINE ASM BLOCK
2664   1573             
2665   1573             ;; return m; 
2666   1573 FA FF FF      lea d, [bp + -1] ; $m
2667   1576 2A            mov b, [d]
2668   1577 F9            leave
2669   1578 09            ret
2670   1579             
2671   1579             puts:
2672   1579 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2673   157C             
2674   157C             ; --- BEGIN INLINE ASM BLOCK
2675   157C FA 05 00      lea d, [bp + 5] ; $s
2676   157F 15            mov a, [d]
2677   1580 3C            mov d, a
2678   1581 07 1E 18      call _puts
2679   1584 10 00 0A      mov a, $0A00
2680   1587 05 03         syscall sys_io
2681   1589             ; --- END INLINE ASM BLOCK
2682   1589             
2683   1589 F9            leave
2684   158A 09            ret
2685   158B             
2686   158B             print:
2687   158B F8 00 00      enter 0 ; (push bp; mov bp, sp)
2688   158E             
2689   158E             ; --- BEGIN INLINE ASM BLOCK
2690   158E FA 05 00      lea d, [bp + 5] ; $s
2691   1591 FD 2A         mov d, [d]
2692   1593 07 1E 18      call _puts
2693   1596             ; --- END INLINE ASM BLOCK
2694   1596             
2695   1596 F9            leave
2696   1597 09            ret
2697   1598             
2698   1598             getparam:
2699   1598 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2700   159B             ;; char data; 
2701   159B 52 01 00      sub sp, 1 ; data
2702   159E             
2703   159E             ; --- BEGIN INLINE ASM BLOCK
2704   159E 19 04         mov al, 4
2705   15A0 FA 05 00      lea d, [bp + 5] ; $address
2706   15A3 FD 2A         mov d, [d]
2707   15A5 05 0C         syscall sys_system
2708   15A7 FA 00 00      lea d, [bp + 0] ; $data
2709   15AA FD 3E         mov [d], bl
2710   15AC             ; --- END INLINE ASM BLOCK
2711   15AC             
2712   15AC             ;; return data; 
2713   15AC FA 00 00      lea d, [bp + 0] ; $data
2714   15AF 32            mov bl, [d]
2715   15B0 A7 00         mov bh, 0
2716   15B2 F9            leave
2717   15B3 09            ret
2718   15B4             
2719   15B4             clear:
2720   15B4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2721   15B7             ;; print("\033[2J\033[H"); 
2722   15B7 26 A0 24      mov b, _s3 ; "\033[2J\033[H"
2723   15BA FD AB         swp b
2724   15BC D8            push b
2725   15BD 07 8B 15      call print
2726   15C0 51 02 00      add sp, 2
2727   15C3 F9            leave
2728   15C4 09            ret
2729   15C5             
2730   15C5             abs:
2731   15C5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2732   15C8             ;; return i < 0 ? -i : i; 
2733   15C8             _ternary41_cond:
2734   15C8 FA 05 00      lea d, [bp + 5] ; $i
2735   15CB 2A            mov b, [d]
2736   15CC             ; START RELATIONAL
2737   15CC D7            push a
2738   15CD 11            mov a, b
2739   15CE 26 00 00      mov b, $0
2740   15D1 B0            cmp a, b
2741   15D2 FD 73         slt ; < (signed)
2742   15D4 E4            pop a
2743   15D5             ; END RELATIONAL
2744   15D5 C0 00 00      cmp b, 0
2745   15D8 C6 E4 15      je _ternary41_false
2746   15DB             _ternary41_true:
2747   15DB FA 05 00      lea d, [bp + 5] ; $i
2748   15DE 2A            mov b, [d]
2749   15DF FD 97         neg b
2750   15E1 0A E8 15      jmp _ternary41_exit
2751   15E4             _ternary41_false:
2752   15E4 FA 05 00      lea d, [bp + 5] ; $i
2753   15E7 2A            mov b, [d]
2754   15E8             _ternary41_exit:
2755   15E8 F9            leave
2756   15E9 09            ret
2757   15EA             
2758   15EA             include_stdio_asm:
2759   15EA F8 00 00      enter 0 ; (push bp; mov bp, sp)
2760   15ED             
2761   15ED             ; --- BEGIN INLINE ASM BLOCK
2762   15ED             .include "lib/asm/stdio.asm"
0001+  15ED             ;-----------------------------------------------------------------------------
0002+  15ED             ; stdio.s
0003+  15ED             ;-----------------------------------------------------------------------------
0004+  15ED             .include "lib/asm/string.asm"
0001++ 15ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 15ED             ; string.s
0003++ 15ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 15ED             
0005++ 15ED             
0006++ 15ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 15ED             ; _strrev
0008++ 15ED             ; reverse a string
0009++ 15ED             ; D = string address
0010++ 15ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 15ED             ; 01234
0012++ 15ED             _strrev:
0013++ 15ED 4B          	pusha
0014++ 15EE 07 34 16    	call _strlen	; length in C
0015++ 15F1 12          	mov a, c
0016++ 15F2 AF 01 00    	cmp a, 1
0017++ 15F5 D0 0F 16    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 15F8 7D          	dec a
0019++ 15F9 FD 4E       	mov si, d	; beginning of string
0020++ 15FB FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 15FD 59          	add d, a	; end of string
0022++ 15FE 12          	mov a, c
0023++ 15FF FD 9B       	shr a		; divide by 2
0024++ 1601 39          	mov c, a	; C now counts the steps
0025++ 1602             _strrev_L0:
0026++ 1602 32          	mov bl, [d]	; save load right-side char into BL
0027++ 1603 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 1604 3E          	mov [d], al	; store left char into right side
0029++ 1605 1B          	mov al, bl
0030++ 1606 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 1607 7E          	dec c
0032++ 1608 7F          	dec d
0033++ 1609 C2 00 00    	cmp c, 0
0034++ 160C C7 02 16    	jne _strrev_L0
0035++ 160F             _strrev_end:
0036++ 160F 4C          	popa
0037++ 1610 09          	ret
0038++ 1611             	
0039++ 1611             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 1611             ; _strchr
0041++ 1611             ; search string in D for char in AL
0042++ 1611             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 1611             _strchr:
0044++ 1611             _strchr_L0:
0045++ 1611 32          	mov bl, [d]
0046++ 1612 C1 00       	cmp bl, 0
0047++ 1614 C6 1F 16    	je _strchr_end
0048++ 1617 BA          	cmp al, bl
0049++ 1618 C6 1F 16    	je _strchr_end
0050++ 161B 79          	inc d
0051++ 161C 0A 11 16    	jmp _strchr_L0
0052++ 161F             _strchr_end:
0053++ 161F 1B          	mov al, bl
0054++ 1620 09          	ret
0055++ 1621             
0056++ 1621             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 1621             ; _strstr
0058++ 1621             ; find sub-string
0059++ 1621             ; str1 in SI
0060++ 1621             ; str2 in DI
0061++ 1621             ; SI points to end of source string
0062++ 1621             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 1621             _strstr:
0064++ 1621 DB          	push al
0065++ 1622 DA          	push d
0066++ 1623 E3          	push di
0067++ 1624             _strstr_loop:
0068++ 1624 F3          	cmpsb					; compare a byte of the strings
0069++ 1625 C7 30 16    	jne _strstr_ret
0070++ 1628 FC 00 00    	lea d, [di + 0]
0071++ 162B BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 162D C7 24 16    	jne _strstr_loop				; equal chars but not at end
0073++ 1630             _strstr_ret:
0074++ 1630 F0          	pop di
0075++ 1631 E7          	pop d
0076++ 1632 E8          	pop al
0077++ 1633 09          	ret
0078++ 1634             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1634             ; length of null terminated string
0080++ 1634             ; result in C
0081++ 1634             ; pointer in D
0082++ 1634             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1634             _strlen:
0084++ 1634 DA          	push d
0085++ 1635 38 00 00    	mov c, 0
0086++ 1638             _strlen_L1:
0087++ 1638 BD 00       	cmp byte [d], 0
0088++ 163A C6 42 16    	je _strlen_ret
0089++ 163D 79          	inc d
0090++ 163E 78          	inc c
0091++ 163F 0A 38 16    	jmp _strlen_L1
0092++ 1642             _strlen_ret:
0093++ 1642 E7          	pop d
0094++ 1643 09          	ret
0095++ 1644             
0096++ 1644             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1644             ; STRCMP
0098++ 1644             ; compare two strings
0099++ 1644             ; str1 in SI
0100++ 1644             ; str2 in DI
0101++ 1644             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 1644             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1644             _strcmp:
0104++ 1644 DB          	push al
0105++ 1645 DA          	push d
0106++ 1646 E3          	push di
0107++ 1647 E2          	push si
0108++ 1648             _strcmp_loop:
0109++ 1648 F3          	cmpsb					; compare a byte of the strings
0110++ 1649 C7 54 16    	jne _strcmp_ret
0111++ 164C FB FF FF    	lea d, [si +- 1]
0112++ 164F BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1651 C7 48 16    	jne _strcmp_loop				; equal chars but not at end
0114++ 1654             _strcmp_ret:
0115++ 1654 EF          	pop si
0116++ 1655 F0          	pop di
0117++ 1656 E7          	pop d
0118++ 1657 E8          	pop al
0119++ 1658 09          	ret
0120++ 1659             
0121++ 1659             
0122++ 1659             ; STRCPY
0123++ 1659             ; copy null terminated string from SI to DI
0124++ 1659             ; source in SI
0125++ 1659             ; destination in DI
0126++ 1659             _strcpy:
0127++ 1659 E2          	push si
0128++ 165A E3          	push di
0129++ 165B DB          	push al
0130++ 165C             _strcpy_L1:
0131++ 165C F6          	lodsb
0132++ 165D F7          	stosb
0133++ 165E B9 00       	cmp al, 0
0134++ 1660 C7 5C 16    	jne _strcpy_L1
0135++ 1663             _strcpy_end:
0136++ 1663 E8          	pop al
0137++ 1664 F0          	pop di
0138++ 1665 EF          	pop si
0139++ 1666 09          	ret
0140++ 1667             
0141++ 1667             ; STRCAT
0142++ 1667             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 1667             ; source in SI
0144++ 1667             ; destination in DI
0145++ 1667             _strcat:
0146++ 1667 E2          	push si
0147++ 1668 E3          	push di
0148++ 1669 D7          	push a
0149++ 166A DA          	push d
0150++ 166B 50          	mov a, di
0151++ 166C 3C          	mov d, a
0152++ 166D             _strcat_goto_end_L1:
0153++ 166D BD 00       	cmp byte[d], 0
0154++ 166F C6 76 16    	je _strcat_start
0155++ 1672 79          	inc d
0156++ 1673 0A 6D 16    	jmp _strcat_goto_end_L1
0157++ 1676             _strcat_start:
0158++ 1676 FD 50       	mov di, d
0159++ 1678             _strcat_L1:
0160++ 1678 F6          	lodsb
0161++ 1679 F7          	stosb
0162++ 167A B9 00       	cmp al, 0
0163++ 167C C7 78 16    	jne _strcat_L1
0164++ 167F             _strcat_end:
0165++ 167F E7          	pop d
0166++ 1680 E4          	pop a
0167++ 1681 F0          	pop di
0168++ 1682 EF          	pop si
0169++ 1683 09          	ret
0170++ 1684             
0171++ 1684             
0005+  1684             
0006+  1684             ;-----------------------------------------------------------------------------
0007+  1684             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0008+  1684             ; ASCII in BL
0009+  1684             ; result in AL
0010+  1684             ; ascii for F = 0100 0110
0011+  1684             ; ascii for 9 = 0011 1001
0012+  1684             ;-----------------------------------------------------------------------------
0013+  1684             hex_ascii_encode:
0014+  1684 1B            mov al, bl
0015+  1685 93 40         test al, $40        ; test if letter or number
0016+  1687 C7 8D 16      jnz hex_letter
0017+  168A 87 0F         and al, $0F        ; get number
0018+  168C 09            ret
0019+  168D             hex_letter:
0020+  168D 87 0F         and al, $0F        ; get letter
0021+  168F 6A 09         add al, 9
0022+  1691 09            ret
0023+  1692             
0024+  1692             ;-----------------------------------------------------------------------------
0025+  1692             ; ATOI
0026+  1692             ; 2 letter hex string in B
0027+  1692             ; 8bit integer returned in AL
0028+  1692             ;-----------------------------------------------------------------------------
0029+  1692             _atoi:
0030+  1692 D8            push b
0031+  1693 07 84 16      call hex_ascii_encode      ; convert BL to 4bit code in AL
0032+  1696 30            mov bl, bh
0033+  1697 DB            push al          ; save a
0034+  1698 07 84 16      call hex_ascii_encode
0035+  169B EA            pop bl  
0036+  169C FD 9E 04      shl al, 4
0037+  169F 8C            or al, bl
0038+  16A0 E5            pop b
0039+  16A1 09            ret  
0040+  16A2             
0041+  16A2             
0042+  16A2             ;-----------------------------------------------------------------------------
0043+  16A2             ; ITOA
0044+  16A2             ; 8bit value in BL
0045+  16A2             ; 2 byte ASCII result in A
0046+  16A2             ;-----------------------------------------------------------------------------
0047+  16A2             _itoa:
0048+  16A2 DA            push d
0049+  16A3 D8            push b
0050+  16A4 A7 00         mov bh, 0
0051+  16A6 FD A4 04      shr bl, 4  
0052+  16A9 74            mov d, b
0053+  16AA 1F 52 19      mov al, [d + s_hex_digits]
0054+  16AD 23            mov ah, al
0055+  16AE               
0056+  16AE E5            pop b
0057+  16AF D8            push b
0058+  16B0 A7 00         mov bh, 0
0059+  16B2 FD 87 0F      and bl, $0F
0060+  16B5 74            mov d, b
0061+  16B6 1F 52 19      mov al, [d + s_hex_digits]
0062+  16B9 E5            pop b
0063+  16BA E7            pop d
0064+  16BB 09            ret
0065+  16BC             
0066+  16BC             ;-----------------------------------------------------------------------------
0067+  16BC             ; HEX STRING TO BINARY
0068+  16BC             ; di = destination address
0069+  16BC             ; si = source
0070+  16BC             ;-----------------------------------------------------------------------------
0071+  16BC             _hex_to_int:
0072+  16BC             _hex_to_int_L1:
0073+  16BC F6            lodsb          ; load from [SI] to AL
0074+  16BD B9 00         cmp al, 0        ; check if ASCII 0
0075+  16BF C6 CC 16      jz _hex_to_int_ret
0076+  16C2 36            mov bh, al
0077+  16C3 F6            lodsb
0078+  16C4 2F            mov bl, al
0079+  16C5 07 92 16      call _atoi        ; convert ASCII byte in B to int (to AL)
0080+  16C8 F7            stosb          ; store AL to [DI]
0081+  16C9 0A BC 16      jmp _hex_to_int_L1
0082+  16CC             _hex_to_int_ret:
0083+  16CC 09            ret    
0084+  16CD             
0085+  16CD             ;-----------------------------------------------------------------------------
0086+  16CD             ; GETCHAR
0087+  16CD             ; char in ah
0088+  16CD             ;-----------------------------------------------------------------------------
0089+  16CD             getch:
0090+  16CD DB            push al
0091+  16CE             getch_retry:
0092+  16CE 19 01         mov al, 1
0093+  16D0 05 03         syscall sys_io      ; receive in AH
0094+  16D2 E8            pop al
0095+  16D3 09            ret
0096+  16D4             
0097+  16D4             ;-----------------------------------------------------------------------------
0098+  16D4             ; PUTCHAR
0099+  16D4             ; char in ah
0100+  16D4             ;-----------------------------------------------------------------------------
0101+  16D4             _putchar:
0102+  16D4 D7            push a
0103+  16D5 19 00         mov al, 0
0104+  16D7 05 03         syscall sys_io      ; char in AH
0105+  16D9 E4            pop a
0106+  16DA 09            ret
0107+  16DB             
0108+  16DB             ;-----------------------------------------------------------------------------
0109+  16DB             ;; INPUT A STRING
0110+  16DB             ;; terminates with null
0111+  16DB             ;; pointer in D
0112+  16DB             ;-----------------------------------------------------------------------------
0113+  16DB             _gets:
0114+  16DB D7            push a
0115+  16DC DA            push d
0116+  16DD             _gets_loop:
0117+  16DD 19 01         mov al, 1
0118+  16DF 05 03         syscall sys_io      ; receive in AH
0119+  16E1 B9 00         cmp al, 0        ; check error code (AL)
0120+  16E3 C6 DD 16      je _gets_loop      ; if no char received, retry
0121+  16E6             
0122+  16E6 76 1B         cmp ah, 27
0123+  16E8 C6 09 17      je _gets_ansi_esc
0124+  16EB 76 0A         cmp ah, $0A        ; LF
0125+  16ED C6 74 17      je _gets_end
0126+  16F0 76 0D         cmp ah, $0D        ; CR
0127+  16F2 C6 74 17      je _gets_end
0128+  16F5 76 5C         cmp ah, $5C        ; '\\'
0129+  16F7 C6 35 17      je _gets_escape
0130+  16FA               
0131+  16FA 76 08         cmp ah, $08      ; check for backspace
0132+  16FC C6 05 17      je _gets_backspace
0133+  16FF             
0134+  16FF 1A            mov al, ah
0135+  1700 3E            mov [d], al
0136+  1701 79            inc d
0137+  1702 0A DD 16      jmp _gets_loop
0138+  1705             _gets_backspace:
0139+  1705 7F            dec d
0140+  1706 0A DD 16      jmp _gets_loop
0141+  1709             _gets_ansi_esc:
0142+  1709 19 01         mov al, 1
0143+  170B 05 03         syscall sys_io        ; receive in AH without echo
0144+  170D B9 00         cmp al, 0          ; check error code (AL)
0145+  170F C6 09 17      je _gets_ansi_esc    ; if no char received, retry
0146+  1712 76 5B         cmp ah, '['
0147+  1714 C7 DD 16      jne _gets_loop
0148+  1717             _gets_ansi_esc_2:
0149+  1717 19 01         mov al, 1
0150+  1719 05 03         syscall sys_io          ; receive in AH without echo
0151+  171B B9 00         cmp al, 0            ; check error code (AL)
0152+  171D C6 17 17      je _gets_ansi_esc_2  ; if no char received, retry
0153+  1720 76 44         cmp ah, 'D'
0154+  1722 C6 2D 17      je _gets_left_arrow
0155+  1725 76 43         cmp ah, 'C'
0156+  1727 C6 31 17      je _gets_right_arrow
0157+  172A 0A DD 16      jmp _gets_loop
0158+  172D             _gets_left_arrow:
0159+  172D 7F            dec d
0160+  172E 0A DD 16      jmp _gets_loop
0161+  1731             _gets_right_arrow:
0162+  1731 79            inc d
0163+  1732 0A DD 16      jmp _gets_loop
0164+  1735             _gets_escape:
0165+  1735 19 01         mov al, 1
0166+  1737 05 03         syscall sys_io      ; receive in AH
0167+  1739 B9 00         cmp al, 0        ; check error code (AL)
0168+  173B C6 35 17      je _gets_escape      ; if no char received, retry
0169+  173E 76 6E         cmp ah, 'n'
0170+  1740 C6 5F 17      je _gets_LF
0171+  1743 76 72         cmp ah, 'r'
0172+  1745 C6 66 17      je _gets_CR
0173+  1748 76 30         cmp ah, '0'
0174+  174A C6 6D 17      je _gets_NULL
0175+  174D 76 5C         cmp ah, $5C  ; '\'
0176+  174F C6 58 17      je _gets_slash
0177+  1752 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0178+  1753 3E            mov [d], al
0179+  1754 79            inc d
0180+  1755 0A DD 16      jmp _gets_loop
0181+  1758             _gets_slash:
0182+  1758 19 5C         mov al, $5C
0183+  175A 3E            mov [d], al
0184+  175B 79            inc d
0185+  175C 0A DD 16      jmp _gets_loop
0186+  175F             _gets_LF:
0187+  175F 19 0A         mov al, $0A
0188+  1761 3E            mov [d], al
0189+  1762 79            inc d
0190+  1763 0A DD 16      jmp _gets_loop
0191+  1766             _gets_CR:
0192+  1766 19 0D         mov al, $0D
0193+  1768 3E            mov [d], al
0194+  1769 79            inc d
0195+  176A 0A DD 16      jmp _gets_loop
0196+  176D             _gets_NULL:
0197+  176D 19 00         mov al, $00
0198+  176F 3E            mov [d], al
0199+  1770 79            inc d
0200+  1771 0A DD 16      jmp _gets_loop
0201+  1774             _gets_end:
0202+  1774 19 00         mov al, 0
0203+  1776 3E            mov [d], al        ; terminate string
0204+  1777 E7            pop d
0205+  1778 E4            pop a
0206+  1779 09            ret
0207+  177A             
0208+  177A             ;-----------------------------------------------------------------------------
0209+  177A             ;; INPUT TEXT
0210+  177A             ;; terminated with CTRL+D
0211+  177A             ;; pointer in D
0212+  177A             ;-----------------------------------------------------------------------------
0213+  177A             _gettxt:
0214+  177A D7            push a
0215+  177B DA            push d
0216+  177C             _gettxt_loop:
0217+  177C 19 01         mov al, 1
0218+  177E 05 03         syscall sys_io      ; receive in AH
0219+  1780 B9 00         cmp al, 0        ; check error code (AL)
0220+  1782 C6 7C 17      je _gettxt_loop    ; if no char received, retry
0221+  1785 76 04         cmp ah, 4      ; EOT
0222+  1787 C6 C5 17      je _gettxt_end
0223+  178A 76 08         cmp ah, $08      ; check for backspace
0224+  178C C6 C1 17      je _gettxt_backspace
0225+  178F 76 5C         cmp ah, $5C        ; '\'
0226+  1791 C6 9A 17      je _gettxt_escape
0227+  1794 1A            mov al, ah
0228+  1795 3E            mov [d], al
0229+  1796 79            inc d
0230+  1797 0A 7C 17      jmp _gettxt_loop
0231+  179A             _gettxt_escape:
0232+  179A 19 01         mov al, 1
0233+  179C 05 03         syscall sys_io      ; receive in AH
0234+  179E B9 00         cmp al, 0        ; check error code (AL)
0235+  17A0 C6 9A 17      je _gettxt_escape    ; if no char received, retry
0236+  17A3 76 6E         cmp ah, 'n'
0237+  17A5 C6 B3 17      je _gettxt_LF
0238+  17A8 76 72         cmp ah, 'r'
0239+  17AA C6 BA 17      je _gettxt_CR
0240+  17AD 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0241+  17AE 3E            mov [d], al
0242+  17AF 79            inc d
0243+  17B0 0A 7C 17      jmp _gettxt_loop
0244+  17B3             _gettxt_LF:
0245+  17B3 19 0A         mov al, $0A
0246+  17B5 3E            mov [d], al
0247+  17B6 79            inc d
0248+  17B7 0A 7C 17      jmp _gettxt_loop
0249+  17BA             _gettxt_CR:
0250+  17BA 19 0D         mov al, $0D
0251+  17BC 3E            mov [d], al
0252+  17BD 79            inc d
0253+  17BE 0A 7C 17      jmp _gettxt_loop
0254+  17C1             _gettxt_backspace:
0255+  17C1 7F            dec d
0256+  17C2 0A 7C 17      jmp _gettxt_loop
0257+  17C5             _gettxt_end:
0258+  17C5 19 00         mov al, 0
0259+  17C7 3E            mov [d], al        ; terminate string
0260+  17C8 E7            pop d
0261+  17C9 E4            pop a
0262+  17CA 09            ret
0263+  17CB             
0264+  17CB             ;-----------------------------------------------------------------------------
0265+  17CB             ; PRINT NEW LINE
0266+  17CB             ;-----------------------------------------------------------------------------
0267+  17CB             printnl:
0268+  17CB D7            push a
0269+  17CC 10 00 0A      mov a, $0A00
0270+  17CF 05 03         syscall sys_io
0271+  17D1 10 00 0D      mov a, $0D00
0272+  17D4 05 03         syscall sys_io
0273+  17D6 E4            pop a
0274+  17D7 09            ret
0275+  17D8             
0276+  17D8             ;-----------------------------------------------------------------------------
0277+  17D8             ; _strtoint
0278+  17D8             ; 4 digit hex string number in d
0279+  17D8             ; integer returned in A
0280+  17D8             ;-----------------------------------------------------------------------------
0281+  17D8             _strtointx:
0282+  17D8 D8            push b
0283+  17D9 32            mov bl, [d]
0284+  17DA 37            mov bh, bl
0285+  17DB 33 01 00      mov bl, [d + 1]
0286+  17DE 07 92 16      call _atoi        ; convert to int in AL
0287+  17E1 23            mov ah, al        ; move to AH
0288+  17E2 33 02 00      mov bl, [d + 2]
0289+  17E5 37            mov bh, bl
0290+  17E6 33 03 00      mov bl, [d + 3]
0291+  17E9 07 92 16      call _atoi        ; convert to int in AL
0292+  17EC E5            pop b
0293+  17ED 09            ret
0294+  17EE             
0295+  17EE             ;-----------------------------------------------------------------------------
0296+  17EE             ; _strtoint
0297+  17EE             ; 5 digit base10 string number in d
0298+  17EE             ; integer returned in A
0299+  17EE             ;-----------------------------------------------------------------------------
0300+  17EE             _strtoint:
0301+  17EE E2            push si
0302+  17EF D8            push b
0303+  17F0 D9            push c
0304+  17F1 DA            push d
0305+  17F2 07 34 16      call _strlen      ; get string length in C
0306+  17F5 7E            dec c
0307+  17F6 FD 4E         mov si, d
0308+  17F8 12            mov a, c
0309+  17F9 FD 99         shl a
0310+  17FB 3B 6A 19      mov d, table_power
0311+  17FE 59            add d, a
0312+  17FF 38 00 00      mov c, 0
0313+  1802             _strtoint_L0:
0314+  1802 F6            lodsb      ; load ASCII to al
0315+  1803 B9 00         cmp al, 0
0316+  1805 C6 18 18      je _strtoint_end
0317+  1808 6F 30         sub al, $30    ; make into integer
0318+  180A 22 00         mov ah, 0
0319+  180C 2A            mov b, [d]
0320+  180D AC            mul a, b      ; result in B since it fits in 16bits
0321+  180E 11            mov a, b
0322+  180F 28            mov b, c
0323+  1810 54            add a, b
0324+  1811 39            mov c, a
0325+  1812 63 02 00      sub d, 2
0326+  1815 0A 02 18      jmp _strtoint_L0
0327+  1818             _strtoint_end:
0328+  1818 12            mov a, c
0329+  1819 E7            pop d
0330+  181A E6            pop c
0331+  181B E5            pop b
0332+  181C EF            pop si
0333+  181D 09            ret
0334+  181E             
0335+  181E             ;-----------------------------------------------------------------------------
0336+  181E             ; PRINT NULL TERMINATED STRING
0337+  181E             ; pointer in D
0338+  181E             ;-----------------------------------------------------------------------------
0339+  181E             _puts:
0340+  181E D7            push a
0341+  181F DA            push d
0342+  1820             _puts_L1:
0343+  1820 1E            mov al, [d]
0344+  1821 B9 00         cmp al, 0
0345+  1823 C6 2F 18      jz _puts_END
0346+  1826 23            mov ah, al
0347+  1827 19 00         mov al, 0
0348+  1829 05 03         syscall sys_io
0349+  182B 79            inc d
0350+  182C 0A 20 18      jmp _puts_L1
0351+  182F             _puts_END:
0352+  182F E7            pop d
0353+  1830 E4            pop a
0354+  1831 09            ret
0355+  1832             
0356+  1832             ;-----------------------------------------------------------------------------
0357+  1832             ; PRINT N SIZE STRING
0358+  1832             ; pointer in D
0359+  1832             ; size in C
0360+  1832             ;-----------------------------------------------------------------------------
0361+  1832             _putsn:
0362+  1832 DB            push al
0363+  1833 DA            push d
0364+  1834 D9            push c
0365+  1835             _putsn_L0:
0366+  1835 1E            mov al, [d]
0367+  1836 23            mov ah, al
0368+  1837 19 00         mov al, 0
0369+  1839 05 03         syscall sys_io
0370+  183B 79            inc d
0371+  183C 7E            dec c  
0372+  183D C2 00 00      cmp c, 0
0373+  1840 C7 35 18      jne _putsn_L0
0374+  1843             _putsn_end:
0375+  1843 E6            pop c
0376+  1844 E7            pop d
0377+  1845 E8            pop al
0378+  1846 09            ret
0379+  1847             
0380+  1847             ;-----------------------------------------------------------------------------
0381+  1847             ; print 16bit decimal number
0382+  1847             ; input number in A
0383+  1847             ;-----------------------------------------------------------------------------
0384+  1847             print_u16d:
0385+  1847 D7            push a
0386+  1848 D8            push b
0387+  1849 26 10 27      mov b, 10000
0388+  184C AE            div a, b      ; get 10000's coeff.
0389+  184D 07 6F 18      call print_number
0390+  1850 11            mov a, b
0391+  1851 26 E8 03      mov b, 1000
0392+  1854 AE            div a, b      ; get 1000's coeff.
0393+  1855 07 6F 18      call print_number
0394+  1858 11            mov a, b
0395+  1859 26 64 00      mov b, 100
0396+  185C AE            div a, b
0397+  185D 07 6F 18      call print_number
0398+  1860 11            mov a, b
0399+  1861 26 0A 00      mov b, 10
0400+  1864 AE            div a, b
0401+  1865 07 6F 18      call print_number
0402+  1868 1B            mov al, bl      ; 1's coeff in bl
0403+  1869 07 6F 18      call print_number
0404+  186C E5            pop b
0405+  186D E4            pop a
0406+  186E 09            ret
0407+  186F             
0408+  186F             ;-----------------------------------------------------------------------------
0409+  186F             ; print AL
0410+  186F             ;-----------------------------------------------------------------------------
0411+  186F             print_number:
0412+  186F 6A 30         add al, $30
0413+  1871 23            mov ah, al
0414+  1872 07 D4 16      call _putchar
0415+  1875 09            ret
0416+  1876             
0417+  1876             ;-----------------------------------------------------------------------------
0418+  1876             ; PRINT 16BIT HEX INTEGER
0419+  1876             ; integer value in reg B
0420+  1876             ;-----------------------------------------------------------------------------
0421+  1876             print_u16x:
0422+  1876 D7            push a
0423+  1877 D8            push b
0424+  1878 DD            push bl
0425+  1879 30            mov bl, bh
0426+  187A 07 A2 16      call _itoa        ; convert bh to char in A
0427+  187D 2F            mov bl, al        ; save al
0428+  187E 19 00         mov al, 0
0429+  1880 05 03         syscall sys_io        ; display AH
0430+  1882 24            mov ah, bl        ; retrieve al
0431+  1883 19 00         mov al, 0
0432+  1885 05 03         syscall sys_io        ; display AL
0433+  1887             
0434+  1887 EA            pop bl
0435+  1888 07 A2 16      call _itoa        ; convert bh to char in A
0436+  188B 2F            mov bl, al        ; save al
0437+  188C 19 00         mov al, 0
0438+  188E 05 03         syscall sys_io        ; display AH
0439+  1890 24            mov ah, bl        ; retrieve al
0440+  1891 19 00         mov al, 0
0441+  1893 05 03         syscall sys_io        ; display AL
0442+  1895             
0443+  1895 E5            pop b
0444+  1896 E4            pop a
0445+  1897 09            ret
0446+  1898             
0447+  1898             ;-----------------------------------------------------------------------------
0448+  1898             ; INPUT 16BIT HEX INTEGER
0449+  1898             ; read 16bit integer into A
0450+  1898             ;-----------------------------------------------------------------------------
0451+  1898             scan_u16x:
0452+  1898 F8 10 00      enter 16
0453+  189B D8            push b
0454+  189C DA            push d
0455+  189D             
0456+  189D FA F1 FF      lea d, [bp + -15]
0457+  18A0 07 DB 16      call _gets        ; get number
0458+  18A3             
0459+  18A3 32            mov bl, [d]
0460+  18A4 37            mov bh, bl
0461+  18A5 33 01 00      mov bl, [d + 1]
0462+  18A8 07 92 16      call _atoi        ; convert to int in AL
0463+  18AB 23            mov ah, al        ; move to AH
0464+  18AC             
0465+  18AC 33 02 00      mov bl, [d + 2]
0466+  18AF 37            mov bh, bl
0467+  18B0 33 03 00      mov bl, [d + 3]
0468+  18B3 07 92 16      call _atoi        ; convert to int in AL
0469+  18B6             
0470+  18B6 E7            pop d
0471+  18B7 E5            pop b
0472+  18B8 F9            leave
0473+  18B9 09            ret
0474+  18BA             
0475+  18BA             ;-----------------------------------------------------------------------------
0476+  18BA             ; PRINT 8bit HEX INTEGER
0477+  18BA             ; integer value in reg bl
0478+  18BA             ;-----------------------------------------------------------------------------
0479+  18BA             print_u8x:
0480+  18BA D7            push a
0481+  18BB DD            push bl
0482+  18BC             
0483+  18BC 07 A2 16      call _itoa        ; convert bl to char in A
0484+  18BF 2F            mov bl, al        ; save al
0485+  18C0 19 00         mov al, 0
0486+  18C2 05 03         syscall sys_io        ; display AH
0487+  18C4 24            mov ah, bl        ; retrieve al
0488+  18C5 19 00         mov al, 0
0489+  18C7 05 03         syscall sys_io        ; display AL
0490+  18C9             
0491+  18C9 EA            pop bl
0492+  18CA E4            pop a
0493+  18CB 09            ret
0494+  18CC             
0495+  18CC             ;-----------------------------------------------------------------------------
0496+  18CC             ; print 8bit decimal unsigned number
0497+  18CC             ; input number in AL
0498+  18CC             ;-----------------------------------------------------------------------------
0499+  18CC             print_u8d:
0500+  18CC D7            push a
0501+  18CD D8            push b
0502+  18CE             
0503+  18CE 22 00         mov ah, 0
0504+  18D0 26 64 00      mov b, 100
0505+  18D3 AE            div a, b
0506+  18D4 D8            push b      ; save remainder
0507+  18D5 B9 00         cmp al, 0
0508+  18D7 C6 E1 18      je skip100
0509+  18DA 6A 30         add al, $30
0510+  18DC 23            mov ah, al
0511+  18DD 19 00         mov al, 0
0512+  18DF 05 03         syscall sys_io  ; print coeff
0513+  18E1             skip100:
0514+  18E1 E4            pop a
0515+  18E2 22 00         mov ah, 0
0516+  18E4 26 0A 00      mov b, 10
0517+  18E7 AE            div a, b
0518+  18E8 D8            push b      ; save remainder
0519+  18E9 B9 00         cmp al, 0
0520+  18EB C6 F5 18      je skip10
0521+  18EE 6A 30         add al, $30
0522+  18F0 23            mov ah, al
0523+  18F1 19 00         mov al, 0
0524+  18F3 05 03         syscall sys_io  ; print coeff
0525+  18F5             skip10:
0526+  18F5 E4            pop a
0527+  18F6 1B            mov al, bl
0528+  18F7 6A 30         add al, $30
0529+  18F9 23            mov ah, al
0530+  18FA 19 00         mov al, 0
0531+  18FC 05 03         syscall sys_io  ; print coeff
0532+  18FE E5            pop b
0533+  18FF E4            pop a
0534+  1900 09            ret
0535+  1901             
0536+  1901             ;-----------------------------------------------------------------------------
0537+  1901             ; INPUT 8BIT HEX INTEGER
0538+  1901             ; read 8bit integer into AL
0539+  1901             ;-----------------------------------------------------------------------------
0540+  1901             scan_u8x:
0541+  1901 F8 04 00      enter 4
0542+  1904 D8            push b
0543+  1905 DA            push d
0544+  1906             
0545+  1906 FA FD FF      lea d, [bp + -3]
0546+  1909 07 DB 16      call _gets        ; get number
0547+  190C             
0548+  190C 32            mov bl, [d]
0549+  190D 37            mov bh, bl
0550+  190E 33 01 00      mov bl, [d + 1]
0551+  1911 07 92 16      call _atoi        ; convert to int in AL
0552+  1914             
0553+  1914 E7            pop d
0554+  1915 E5            pop b
0555+  1916 F9            leave
0556+  1917 09            ret
0557+  1918             
0558+  1918             ;-----------------------------------------------------------------------------
0559+  1918             ; input decimal number
0560+  1918             ; result in A
0561+  1918             ; 655'\0'
0562+  1918             ; low--------high
0563+  1918             ;-----------------------------------------------------------------------------
0564+  1918             scan_u16d:
0565+  1918 F8 08 00      enter 8
0566+  191B E2            push si
0567+  191C D8            push b
0568+  191D D9            push c
0569+  191E DA            push d
0570+  191F FA F9 FF      lea d, [bp +- 7]
0571+  1922 07 DB 16      call _gets
0572+  1925 07 34 16      call _strlen      ; get string length in C
0573+  1928 7E            dec c
0574+  1929 FD 4E         mov si, d
0575+  192B 12            mov a, c
0576+  192C FD 99         shl a
0577+  192E 3B 6A 19      mov d, table_power
0578+  1931 59            add d, a
0579+  1932 38 00 00      mov c, 0
0580+  1935             mul_loop:
0581+  1935 F6            lodsb      ; load ASCII to al
0582+  1936 B9 00         cmp al, 0
0583+  1938 C6 4B 19      je mul_exit
0584+  193B 6F 30         sub al, $30    ; make into integer
0585+  193D 22 00         mov ah, 0
0586+  193F 2A            mov b, [d]
0587+  1940 AC            mul a, b      ; result in B since it fits in 16bits
0588+  1941 11            mov a, b
0589+  1942 28            mov b, c
0590+  1943 54            add a, b
0591+  1944 39            mov c, a
0592+  1945 63 02 00      sub d, 2
0593+  1948 0A 35 19      jmp mul_loop
0594+  194B             mul_exit:
0595+  194B 12            mov a, c
0596+  194C E7            pop d
0597+  194D E6            pop c
0598+  194E E5            pop b
0599+  194F EF            pop si
0600+  1950 F9            leave
0601+  1951 09            ret
0602+  1952             
0603+  1952 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0603+  1956 34 35 36 37 
0603+  195A 38 39 41 42 
0603+  195E 43 44 45 46 
0604+  1962 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0604+  1966 1B 5B 48 00 
0605+  196A             
0606+  196A             table_power:
0607+  196A 01 00         .dw 1
0608+  196C 0A 00         .dw 10
0609+  196E 64 00         .dw 100
0610+  1970 E8 03         .dw 1000
0611+  1972 10 27         .dw 100002763   1974             ; --- END INLINE ASM BLOCK
2764   1974             
2765   1974 F9            leave
2766   1975 09            ret
2767   1976             
2768   1976             base64_char_value:
2769   1976 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2770   1979             ;; if (c >= 'A' && c <= 'Z') return c - 'A'; 
2771   1979             _if42_cond:
2772   1979 FA 05 00      lea d, [bp + 5] ; $c
2773   197C 32            mov bl, [d]
2774   197D A7 00         mov bh, 0
2775   197F             ; START RELATIONAL
2776   197F D7            push a
2777   1980 11            mov a, b
2778   1981 26 41 00      mov b, $41
2779   1984 B0            cmp a, b
2780   1985 FD 80         sge ; >=
2781   1987 E4            pop a
2782   1988             ; END RELATIONAL
2783   1988             ; START LOGICAL AND
2784   1988 D7            push a
2785   1989 11            mov a, b
2786   198A FA 05 00      lea d, [bp + 5] ; $c
2787   198D 32            mov bl, [d]
2788   198E A7 00         mov bh, 0
2789   1990             ; START RELATIONAL
2790   1990 D7            push a
2791   1991 11            mov a, b
2792   1992 26 5A 00      mov b, $5a
2793   1995 B0            cmp a, b
2794   1996 FD 74         sle ; <= (signed)
2795   1998 E4            pop a
2796   1999             ; END RELATIONAL
2797   1999 FD A7         sand a, b
2798   199B E4            pop a
2799   199C             ; END LOGICAL AND
2800   199C C0 00 00      cmp b, 0
2801   199F C6 B5 19      je _if42_exit
2802   19A2             _if42_true:
2803   19A2             ;; return c - 'A'; 
2804   19A2 FA 05 00      lea d, [bp + 5] ; $c
2805   19A5 32            mov bl, [d]
2806   19A6 A7 00         mov bh, 0
2807   19A8             ; START TERMS
2808   19A8 D7            push a
2809   19A9 11            mov a, b
2810   19AA 26 41 00      mov b, $41
2811   19AD 60            sub a, b
2812   19AE 27            mov b, a
2813   19AF E4            pop a
2814   19B0             ; END TERMS
2815   19B0 F9            leave
2816   19B1 09            ret
2817   19B2 0A B5 19      jmp _if42_exit
2818   19B5             _if42_exit:
2819   19B5             ;; if (c >= 'a' && c <= 'z') return c - 'a' + 26; 
2820   19B5             _if43_cond:
2821   19B5 FA 05 00      lea d, [bp + 5] ; $c
2822   19B8 32            mov bl, [d]
2823   19B9 A7 00         mov bh, 0
2824   19BB             ; START RELATIONAL
2825   19BB D7            push a
2826   19BC 11            mov a, b
2827   19BD 26 61 00      mov b, $61
2828   19C0 B0            cmp a, b
2829   19C1 FD 80         sge ; >=
2830   19C3 E4            pop a
2831   19C4             ; END RELATIONAL
2832   19C4             ; START LOGICAL AND
2833   19C4 D7            push a
2834   19C5 11            mov a, b
2835   19C6 FA 05 00      lea d, [bp + 5] ; $c
2836   19C9 32            mov bl, [d]
2837   19CA A7 00         mov bh, 0
2838   19CC             ; START RELATIONAL
2839   19CC D7            push a
2840   19CD 11            mov a, b
2841   19CE 26 7A 00      mov b, $7a
2842   19D1 B0            cmp a, b
2843   19D2 FD 74         sle ; <= (signed)
2844   19D4 E4            pop a
2845   19D5             ; END RELATIONAL
2846   19D5 FD A7         sand a, b
2847   19D7 E4            pop a
2848   19D8             ; END LOGICAL AND
2849   19D8 C0 00 00      cmp b, 0
2850   19DB C6 F6 19      je _if43_exit
2851   19DE             _if43_true:
2852   19DE             ;; return c - 'a' + 26; 
2853   19DE FA 05 00      lea d, [bp + 5] ; $c
2854   19E1 32            mov bl, [d]
2855   19E2 A7 00         mov bh, 0
2856   19E4             ; START TERMS
2857   19E4 D7            push a
2858   19E5 11            mov a, b
2859   19E6 26 61 00      mov b, $61
2860   19E9 60            sub a, b
2861   19EA 27            mov b, a
2862   19EB 11            mov a, b
2863   19EC 26 1A 00      mov b, $1a
2864   19EF 56            add b, a
2865   19F0 E4            pop a
2866   19F1             ; END TERMS
2867   19F1 F9            leave
2868   19F2 09            ret
2869   19F3 0A F6 19      jmp _if43_exit
2870   19F6             _if43_exit:
2871   19F6             ;; if (c >= '0' && c <= '9') return c - '0' + 52; 
2872   19F6             _if44_cond:
2873   19F6 FA 05 00      lea d, [bp + 5] ; $c
2874   19F9 32            mov bl, [d]
2875   19FA A7 00         mov bh, 0
2876   19FC             ; START RELATIONAL
2877   19FC D7            push a
2878   19FD 11            mov a, b
2879   19FE 26 30 00      mov b, $30
2880   1A01 B0            cmp a, b
2881   1A02 FD 80         sge ; >=
2882   1A04 E4            pop a
2883   1A05             ; END RELATIONAL
2884   1A05             ; START LOGICAL AND
2885   1A05 D7            push a
2886   1A06 11            mov a, b
2887   1A07 FA 05 00      lea d, [bp + 5] ; $c
2888   1A0A 32            mov bl, [d]
2889   1A0B A7 00         mov bh, 0
2890   1A0D             ; START RELATIONAL
2891   1A0D D7            push a
2892   1A0E 11            mov a, b
2893   1A0F 26 39 00      mov b, $39
2894   1A12 B0            cmp a, b
2895   1A13 FD 74         sle ; <= (signed)
2896   1A15 E4            pop a
2897   1A16             ; END RELATIONAL
2898   1A16 FD A7         sand a, b
2899   1A18 E4            pop a
2900   1A19             ; END LOGICAL AND
2901   1A19 C0 00 00      cmp b, 0
2902   1A1C C6 37 1A      je _if44_exit
2903   1A1F             _if44_true:
2904   1A1F             ;; return c - '0' + 52; 
2905   1A1F FA 05 00      lea d, [bp + 5] ; $c
2906   1A22 32            mov bl, [d]
2907   1A23 A7 00         mov bh, 0
2908   1A25             ; START TERMS
2909   1A25 D7            push a
2910   1A26 11            mov a, b
2911   1A27 26 30 00      mov b, $30
2912   1A2A 60            sub a, b
2913   1A2B 27            mov b, a
2914   1A2C 11            mov a, b
2915   1A2D 26 34 00      mov b, $34
2916   1A30 56            add b, a
2917   1A31 E4            pop a
2918   1A32             ; END TERMS
2919   1A32 F9            leave
2920   1A33 09            ret
2921   1A34 0A 37 1A      jmp _if44_exit
2922   1A37             _if44_exit:
2923   1A37             ;; if (c == '+') return 62; 
2924   1A37             _if45_cond:
2925   1A37 FA 05 00      lea d, [bp + 5] ; $c
2926   1A3A 32            mov bl, [d]
2927   1A3B A7 00         mov bh, 0
2928   1A3D             ; START RELATIONAL
2929   1A3D D7            push a
2930   1A3E 11            mov a, b
2931   1A3F 26 2B 00      mov b, $2b
2932   1A42 B0            cmp a, b
2933   1A43 FD 71         seq ; ==
2934   1A45 E4            pop a
2935   1A46             ; END RELATIONAL
2936   1A46 C0 00 00      cmp b, 0
2937   1A49 C6 54 1A      je _if45_exit
2938   1A4C             _if45_true:
2939   1A4C             ;; return 62; 
2940   1A4C 26 3E 00      mov b, $3e
2941   1A4F F9            leave
2942   1A50 09            ret
2943   1A51 0A 54 1A      jmp _if45_exit
2944   1A54             _if45_exit:
2945   1A54             ;; if (c == '/') return 63; 
2946   1A54             _if46_cond:
2947   1A54 FA 05 00      lea d, [bp + 5] ; $c
2948   1A57 32            mov bl, [d]
2949   1A58 A7 00         mov bh, 0
2950   1A5A             ; START RELATIONAL
2951   1A5A D7            push a
2952   1A5B 11            mov a, b
2953   1A5C 26 2F 00      mov b, $2f
2954   1A5F B0            cmp a, b
2955   1A60 FD 71         seq ; ==
2956   1A62 E4            pop a
2957   1A63             ; END RELATIONAL
2958   1A63 C0 00 00      cmp b, 0
2959   1A66 C6 71 1A      je _if46_exit
2960   1A69             _if46_true:
2961   1A69             ;; return 63; 
2962   1A69 26 3F 00      mov b, $3f
2963   1A6C F9            leave
2964   1A6D 09            ret
2965   1A6E 0A 71 1A      jmp _if46_exit
2966   1A71             _if46_exit:
2967   1A71             ;; return -1; 
2968   1A71 26 FF FF      mov b, $ffff
2969   1A74 F9            leave
2970   1A75 09            ret
2971   1A76             
2972   1A76             base64_decode:
2973   1A76 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2974   1A79             ;; int i = 0, j = 0, k = 0; 
2975   1A79 52 02 00      sub sp, 2 ; i
2976   1A7C             ; --- START LOCAL VAR INITIALIZATION
2977   1A7C FA FF FF      lea d, [bp + -1] ; $i
2978   1A7F DA            push d
2979   1A80 26 00 00      mov b, $0
2980   1A83 E7            pop d
2981   1A84 FD 43         mov [d], b
2982   1A86             ; --- END LOCAL VAR INITIALIZATION
2983   1A86 52 02 00      sub sp, 2 ; j
2984   1A89             ; --- START LOCAL VAR INITIALIZATION
2985   1A89 FA FD FF      lea d, [bp + -3] ; $j
2986   1A8C DA            push d
2987   1A8D 26 00 00      mov b, $0
2988   1A90 E7            pop d
2989   1A91 FD 43         mov [d], b
2990   1A93             ; --- END LOCAL VAR INITIALIZATION
2991   1A93 52 02 00      sub sp, 2 ; k
2992   1A96             ; --- START LOCAL VAR INITIALIZATION
2993   1A96 FA FB FF      lea d, [bp + -5] ; $k
2994   1A99 DA            push d
2995   1A9A 26 00 00      mov b, $0
2996   1A9D E7            pop d
2997   1A9E FD 43         mov [d], b
2998   1AA0             ; --- END LOCAL VAR INITIALIZATION
2999   1AA0             ;; int input_len; 
3000   1AA0 52 02 00      sub sp, 2 ; input_len
3001   1AA3             ;; unsigned char input_buffer[4]; 
3002   1AA3 52 04 00      sub sp, 4 ; input_buffer
3003   1AA6             ;; unsigned char output_buffer[3]; 
3004   1AA6 52 03 00      sub sp, 3 ; output_buffer
3005   1AA9             ;; char a; 
3006   1AA9 52 01 00      sub sp, 1 ; a
3007   1AAC             ;; input_len = strlen(input); 
3008   1AAC FA F9 FF      lea d, [bp + -7] ; $input_len
3009   1AAF DA            push d
3010   1AB0 FA 05 00      lea d, [bp + 5] ; $input
3011   1AB3 2A            mov b, [d]
3012   1AB4 FD AB         swp b
3013   1AB6 D8            push b
3014   1AB7 07 BF 05      call strlen
3015   1ABA 51 02 00      add sp, 2
3016   1ABD E7            pop d
3017   1ABE FD 43         mov [d], b
3018   1AC0             ;; printf("Len: %d\n", input_len); 
3019   1AC0 FA F9 FF      lea d, [bp + -7] ; $input_len
3020   1AC3 2A            mov b, [d]
3021   1AC4 FD AB         swp b
3022   1AC6 D8            push b
3023   1AC7 26 A8 24      mov b, _s4 ; "Len: %d\n"
3024   1ACA FD AB         swp b
3025   1ACC D8            push b
3026   1ACD 07 E9 07      call printf
3027   1AD0 51 04 00      add sp, 4
3028   1AD3             ;; while (input_len-- && (input[k] != '=') && base64_char_value(input[k]) != -1){ 
3029   1AD3             _while47_cond:
3030   1AD3 FA F9 FF      lea d, [bp + -7] ; $input_len
3031   1AD6 2A            mov b, [d]
3032   1AD7 FD 7D         dec b
3033   1AD9 FA F9 FF      lea d, [bp + -7] ; $input_len
3034   1ADC FD 43         mov [d], b
3035   1ADE FD 77         inc b
3036   1AE0             ; START LOGICAL AND
3037   1AE0 D7            push a
3038   1AE1 11            mov a, b
3039   1AE2 FA 05 00      lea d, [bp + 5] ; $input
3040   1AE5 FD 2A         mov d, [d]
3041   1AE7 D7            push a
3042   1AE8 DA            push d
3043   1AE9 FA FB FF      lea d, [bp + -5] ; $k
3044   1AEC 2A            mov b, [d]
3045   1AED E7            pop d
3046   1AEE FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
3047   1AF2 E4            pop a
3048   1AF3 32            mov bl, [d]
3049   1AF4 A7 00         mov bh, 0
3050   1AF6             ; START RELATIONAL
3051   1AF6 D7            push a
3052   1AF7 11            mov a, b
3053   1AF8 26 3D 00      mov b, $3d
3054   1AFB B0            cmp a, b
3055   1AFC FD 72         sneq ; !=
3056   1AFE E4            pop a
3057   1AFF             ; END RELATIONAL
3058   1AFF FD A7         sand a, b
3059   1B01 11            mov a, b
3060   1B02 FA 05 00      lea d, [bp + 5] ; $input
3061   1B05 FD 2A         mov d, [d]
3062   1B07 D7            push a
3063   1B08 DA            push d
3064   1B09 FA FB FF      lea d, [bp + -5] ; $k
3065   1B0C 2A            mov b, [d]
3066   1B0D E7            pop d
3067   1B0E FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
3068   1B12 E4            pop a
3069   1B13 32            mov bl, [d]
3070   1B14 A7 00         mov bh, 0
3071   1B16 DD            push bl
3072   1B17 07 76 19      call base64_char_value
3073   1B1A 51 01 00      add sp, 1
3074   1B1D             ; START RELATIONAL
3075   1B1D D7            push a
3076   1B1E 11            mov a, b
3077   1B1F 26 FF FF      mov b, $ffff
3078   1B22 B0            cmp a, b
3079   1B23 FD 72         sneq ; !=
3080   1B25 E4            pop a
3081   1B26             ; END RELATIONAL
3082   1B26 FD A7         sand a, b
3083   1B28 E4            pop a
3084   1B29             ; END LOGICAL AND
3085   1B29 C0 00 00      cmp b, 0
3086   1B2C C6 23 1F      je _while47_exit
3087   1B2F             _while47_block:
3088   1B2F             ;; printf("input_len: %d, i: %d, j: %d, k: %d, input[k]: %c, base64: %d\n", 
3089   1B2F FA 05 00      lea d, [bp + 5] ; $input
3090   1B32 FD 2A         mov d, [d]
3091   1B34 D7            push a
3092   1B35 DA            push d
3093   1B36 FA FB FF      lea d, [bp + -5] ; $k
3094   1B39 2A            mov b, [d]
3095   1B3A E7            pop d
3096   1B3B FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
3097   1B3F E4            pop a
3098   1B40 32            mov bl, [d]
3099   1B41 A7 00         mov bh, 0
3100   1B43 DD            push bl
3101   1B44 07 76 19      call base64_char_value
3102   1B47 51 01 00      add sp, 1
3103   1B4A FD AB         swp b
3104   1B4C D8            push b
3105   1B4D FA 05 00      lea d, [bp + 5] ; $input
3106   1B50 FD 2A         mov d, [d]
3107   1B52 D7            push a
3108   1B53 DA            push d
3109   1B54 FA FB FF      lea d, [bp + -5] ; $k
3110   1B57 2A            mov b, [d]
3111   1B58 E7            pop d
3112   1B59 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
3113   1B5D E4            pop a
3114   1B5E 32            mov bl, [d]
3115   1B5F A7 00         mov bh, 0
3116   1B61 DD            push bl
3117   1B62 FA FB FF      lea d, [bp + -5] ; $k
3118   1B65 2A            mov b, [d]
3119   1B66 FD AB         swp b
3120   1B68 D8            push b
3121   1B69 FA FD FF      lea d, [bp + -3] ; $j
3122   1B6C 2A            mov b, [d]
3123   1B6D FD AB         swp b
3124   1B6F D8            push b
3125   1B70 FA FF FF      lea d, [bp + -1] ; $i
3126   1B73 2A            mov b, [d]
3127   1B74 FD AB         swp b
3128   1B76 D8            push b
3129   1B77 FA F9 FF      lea d, [bp + -7] ; $input_len
3130   1B7A 2A            mov b, [d]
3131   1B7B FD AB         swp b
3132   1B7D D8            push b
3133   1B7E 26 B1 24      mov b, _s5 ; "input_len: %d, i: %d, j: %d, k: %d, input[k]: %c, base64: %d\n"
3134   1B81 FD AB         swp b
3135   1B83 D8            push b
3136   1B84 07 E9 07      call printf
3137   1B87 51 0D 00      add sp, 13
3138   1B8A             ;; printf("Inside while loop. condition: %d\n", input_len-- && (input[k] != '=') && base64_char_value(input[k]) != -1); 
3139   1B8A FA F9 FF      lea d, [bp + -7] ; $input_len
3140   1B8D 2A            mov b, [d]
3141   1B8E FD 7D         dec b
3142   1B90 FA F9 FF      lea d, [bp + -7] ; $input_len
3143   1B93 FD 43         mov [d], b
3144   1B95 FD 77         inc b
3145   1B97             ; START LOGICAL AND
3146   1B97 D7            push a
3147   1B98 11            mov a, b
3148   1B99 FA 05 00      lea d, [bp + 5] ; $input
3149   1B9C FD 2A         mov d, [d]
3150   1B9E D7            push a
3151   1B9F DA            push d
3152   1BA0 FA FB FF      lea d, [bp + -5] ; $k
3153   1BA3 2A            mov b, [d]
3154   1BA4 E7            pop d
3155   1BA5 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
3156   1BA9 E4            pop a
3157   1BAA 32            mov bl, [d]
3158   1BAB A7 00         mov bh, 0
3159   1BAD             ; START RELATIONAL
3160   1BAD D7            push a
3161   1BAE 11            mov a, b
3162   1BAF 26 3D 00      mov b, $3d
3163   1BB2 B0            cmp a, b
3164   1BB3 FD 72         sneq ; !=
3165   1BB5 E4            pop a
3166   1BB6             ; END RELATIONAL
3167   1BB6 FD A7         sand a, b
3168   1BB8 11            mov a, b
3169   1BB9 FA 05 00      lea d, [bp + 5] ; $input
3170   1BBC FD 2A         mov d, [d]
3171   1BBE D7            push a
3172   1BBF DA            push d
3173   1BC0 FA FB FF      lea d, [bp + -5] ; $k
3174   1BC3 2A            mov b, [d]
3175   1BC4 E7            pop d
3176   1BC5 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
3177   1BC9 E4            pop a
3178   1BCA 32            mov bl, [d]
3179   1BCB A7 00         mov bh, 0
3180   1BCD DD            push bl
3181   1BCE 07 76 19      call base64_char_value
3182   1BD1 51 01 00      add sp, 1
3183   1BD4             ; START RELATIONAL
3184   1BD4 D7            push a
3185   1BD5 11            mov a, b
3186   1BD6 26 FF FF      mov b, $ffff
3187   1BD9 B0            cmp a, b
3188   1BDA FD 72         sneq ; !=
3189   1BDC E4            pop a
3190   1BDD             ; END RELATIONAL
3191   1BDD FD A7         sand a, b
3192   1BDF E4            pop a
3193   1BE0             ; END LOGICAL AND
3194   1BE0 FD AB         swp b
3195   1BE2 D8            push b
3196   1BE3 26 EF 24      mov b, _s6 ; "Inside while loop. condition: %d\n"
3197   1BE6 FD AB         swp b
3198   1BE8 D8            push b
3199   1BE9 07 E9 07      call printf
3200   1BEC 51 04 00      add sp, 4
3201   1BEF             ;; pass = pass && (input_len-- && (input[k] != '=') && base64_char_value(input[k]) != -1); 
3202   1BEF 3B 46 24      mov d, _pass ; $pass
3203   1BF2 DA            push d
3204   1BF3 3B 46 24      mov d, _pass ; $pass
3205   1BF6 2A            mov b, [d]
3206   1BF7             ; START LOGICAL AND
3207   1BF7 D7            push a
3208   1BF8 11            mov a, b
3209   1BF9 FA F9 FF      lea d, [bp + -7] ; $input_len
3210   1BFC 2A            mov b, [d]
3211   1BFD FD 7D         dec b
3212   1BFF FA F9 FF      lea d, [bp + -7] ; $input_len
3213   1C02 FD 43         mov [d], b
3214   1C04 FD 77         inc b
3215   1C06             ; START LOGICAL AND
3216   1C06 D7            push a
3217   1C07 11            mov a, b
3218   1C08 FA 05 00      lea d, [bp + 5] ; $input
3219   1C0B FD 2A         mov d, [d]
3220   1C0D D7            push a
3221   1C0E DA            push d
3222   1C0F FA FB FF      lea d, [bp + -5] ; $k
3223   1C12 2A            mov b, [d]
3224   1C13 E7            pop d
3225   1C14 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
3226   1C18 E4            pop a
3227   1C19 32            mov bl, [d]
3228   1C1A A7 00         mov bh, 0
3229   1C1C             ; START RELATIONAL
3230   1C1C D7            push a
3231   1C1D 11            mov a, b
3232   1C1E 26 3D 00      mov b, $3d
3233   1C21 B0            cmp a, b
3234   1C22 FD 72         sneq ; !=
3235   1C24 E4            pop a
3236   1C25             ; END RELATIONAL
3237   1C25 FD A7         sand a, b
3238   1C27 11            mov a, b
3239   1C28 FA 05 00      lea d, [bp + 5] ; $input
3240   1C2B FD 2A         mov d, [d]
3241   1C2D D7            push a
3242   1C2E DA            push d
3243   1C2F FA FB FF      lea d, [bp + -5] ; $k
3244   1C32 2A            mov b, [d]
3245   1C33 E7            pop d
3246   1C34 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
3247   1C38 E4            pop a
3248   1C39 32            mov bl, [d]
3249   1C3A A7 00         mov bh, 0
3250   1C3C DD            push bl
3251   1C3D 07 76 19      call base64_char_value
3252   1C40 51 01 00      add sp, 1
3253   1C43             ; START RELATIONAL
3254   1C43 D7            push a
3255   1C44 11            mov a, b
3256   1C45 26 FF FF      mov b, $ffff
3257   1C48 B0            cmp a, b
3258   1C49 FD 72         sneq ; !=
3259   1C4B E4            pop a
3260   1C4C             ; END RELATIONAL
3261   1C4C FD A7         sand a, b
3262   1C4E E4            pop a
3263   1C4F             ; END LOGICAL AND
3264   1C4F FD A7         sand a, b
3265   1C51 E4            pop a
3266   1C52             ; END LOGICAL AND
3267   1C52 E7            pop d
3268   1C53 FD 43         mov [d], b
3269   1C55             ;; if(!pass){ 
3270   1C55             _if48_cond:
3271   1C55 3B 46 24      mov d, _pass ; $pass
3272   1C58 2A            mov b, [d]
3273   1C59 C0 00 00      cmp b, 0
3274   1C5C FD 71         seq ; !
3275   1C5E C0 00 00      cmp b, 0
3276   1C61 C6 73 1C      je _if48_exit
3277   1C64             _if48_true:
3278   1C64             ;; section = 0; 
3279   1C64 3B 48 24      mov d, _section ; $section
3280   1C67 DA            push d
3281   1C68 26 00 00      mov b, $0
3282   1C6B E7            pop d
3283   1C6C FD 43         mov [d], b
3284   1C6E             ;; return; 
3285   1C6E F9            leave
3286   1C6F 09            ret
3287   1C70 0A 73 1C      jmp _if48_exit
3288   1C73             _if48_exit:
3289   1C73             ;; input_buffer[i++] = input[k++]; 
3290   1C73 FA F5 FF      lea d, [bp + -11] ; $input_buffer
3291   1C76 D7            push a
3292   1C77 DA            push d
3293   1C78 FA FF FF      lea d, [bp + -1] ; $i
3294   1C7B 2A            mov b, [d]
3295   1C7C FD 77         inc b
3296   1C7E FA FF FF      lea d, [bp + -1] ; $i
3297   1C81 FD 43         mov [d], b
3298   1C83 FD 7D         dec b
3299   1C85 E7            pop d
3300   1C86 5A            add d, b
3301   1C87 E4            pop a
3302   1C88 DA            push d
3303   1C89 FA 05 00      lea d, [bp + 5] ; $input
3304   1C8C FD 2A         mov d, [d]
3305   1C8E D7            push a
3306   1C8F DA            push d
3307   1C90 FA FB FF      lea d, [bp + -5] ; $k
3308   1C93 2A            mov b, [d]
3309   1C94 FD 77         inc b
3310   1C96 FA FB FF      lea d, [bp + -5] ; $k
3311   1C99 FD 43         mov [d], b
3312   1C9B FD 7D         dec b
3313   1C9D E7            pop d
3314   1C9E FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
3315   1CA2 E4            pop a
3316   1CA3 32            mov bl, [d]
3317   1CA4 A7 00         mov bh, 0
3318   1CA6 E7            pop d
3319   1CA7 FD 3E         mov [d], bl
3320   1CA9             ;; if (i == 4) { 
3321   1CA9             _if49_cond:
3322   1CA9 FA FF FF      lea d, [bp + -1] ; $i
3323   1CAC 2A            mov b, [d]
3324   1CAD             ; START RELATIONAL
3325   1CAD D7            push a
3326   1CAE 11            mov a, b
3327   1CAF 26 04 00      mov b, $4
3328   1CB2 B0            cmp a, b
3329   1CB3 FD 71         seq ; ==
3330   1CB5 E4            pop a
3331   1CB6             ; END RELATIONAL
3332   1CB6 C0 00 00      cmp b, 0
3333   1CB9 C6 20 1F      je _if49_exit
3334   1CBC             _if49_true:
3335   1CBC             ;; printf("is i 4? %d\n", i==4); 
3336   1CBC FA FF FF      lea d, [bp + -1] ; $i
3337   1CBF 2A            mov b, [d]
3338   1CC0             ; START RELATIONAL
3339   1CC0 D7            push a
3340   1CC1 11            mov a, b
3341   1CC2 26 04 00      mov b, $4
3342   1CC5 B0            cmp a, b
3343   1CC6 FD 71         seq ; ==
3344   1CC8 E4            pop a
3345   1CC9             ; END RELATIONAL
3346   1CC9 FD AB         swp b
3347   1CCB D8            push b
3348   1CCC 26 11 25      mov b, _s7 ; "is i 4? %d\n"
3349   1CCF FD AB         swp b
3350   1CD1 D8            push b
3351   1CD2 07 E9 07      call printf
3352   1CD5 51 04 00      add sp, 4
3353   1CD8             ;; pass=pass && i==4; 
3354   1CD8 3B 46 24      mov d, _pass ; $pass
3355   1CDB DA            push d
3356   1CDC 3B 46 24      mov d, _pass ; $pass
3357   1CDF 2A            mov b, [d]
3358   1CE0             ; START LOGICAL AND
3359   1CE0 D7            push a
3360   1CE1 11            mov a, b
3361   1CE2 FA FF FF      lea d, [bp + -1] ; $i
3362   1CE5 2A            mov b, [d]
3363   1CE6             ; START RELATIONAL
3364   1CE6 D7            push a
3365   1CE7 11            mov a, b
3366   1CE8 26 04 00      mov b, $4
3367   1CEB B0            cmp a, b
3368   1CEC FD 71         seq ; ==
3369   1CEE E4            pop a
3370   1CEF             ; END RELATIONAL
3371   1CEF FD A7         sand a, b
3372   1CF1 E4            pop a
3373   1CF2             ; END LOGICAL AND
3374   1CF2 E7            pop d
3375   1CF3 FD 43         mov [d], b
3376   1CF5             ;; if(!pass){ 
3377   1CF5             _if50_cond:
3378   1CF5 3B 46 24      mov d, _pass ; $pass
3379   1CF8 2A            mov b, [d]
3380   1CF9 C0 00 00      cmp b, 0
3381   1CFC FD 71         seq ; !
3382   1CFE C0 00 00      cmp b, 0
3383   1D01 C6 13 1D      je _if50_exit
3384   1D04             _if50_true:
3385   1D04             ;; section = 1; 
3386   1D04 3B 48 24      mov d, _section ; $section
3387   1D07 DA            push d
3388   1D08 26 01 00      mov b, $1
3389   1D0B E7            pop d
3390   1D0C FD 43         mov [d], b
3391   1D0E             ;; return; 
3392   1D0E F9            leave
3393   1D0F 09            ret
3394   1D10 0A 13 1D      jmp _if50_exit
3395   1D13             _if50_exit:
3396   1D13             ;; for (i = 0; i < 4; i++) { 
3397   1D13             _for51_init:
3398   1D13 FA FF FF      lea d, [bp + -1] ; $i
3399   1D16 DA            push d
3400   1D17 26 00 00      mov b, $0
3401   1D1A E7            pop d
3402   1D1B FD 43         mov [d], b
3403   1D1D             _for51_cond:
3404   1D1D FA FF FF      lea d, [bp + -1] ; $i
3405   1D20 2A            mov b, [d]
3406   1D21             ; START RELATIONAL
3407   1D21 D7            push a
3408   1D22 11            mov a, b
3409   1D23 26 04 00      mov b, $4
3410   1D26 B0            cmp a, b
3411   1D27 FD 73         slt ; < (signed)
3412   1D29 E4            pop a
3413   1D2A             ; END RELATIONAL
3414   1D2A C0 00 00      cmp b, 0
3415   1D2D C6 09 1E      je _for51_exit
3416   1D30             _for51_block:
3417   1D30             ;; printf("inside first for loop for i=0 to 3. i = %d\n", i); 
3418   1D30 FA FF FF      lea d, [bp + -1] ; $i
3419   1D33 2A            mov b, [d]
3420   1D34 FD AB         swp b
3421   1D36 D8            push b
3422   1D37 26 1D 25      mov b, _s8 ; "inside first for loop for i=0 to 3. i = %d\n"
3423   1D3A FD AB         swp b
3424   1D3C D8            push b
3425   1D3D 07 E9 07      call printf
3426   1D40 51 04 00      add sp, 4
3427   1D43             ;; a = base64_char_value(input_buffer[i]); 
3428   1D43 FA F1 FF      lea d, [bp + -15] ; $a
3429   1D46 DA            push d
3430   1D47 FA F5 FF      lea d, [bp + -11] ; $input_buffer
3431   1D4A D7            push a
3432   1D4B DA            push d
3433   1D4C FA FF FF      lea d, [bp + -1] ; $i
3434   1D4F 2A            mov b, [d]
3435   1D50 E7            pop d
3436   1D51 5A            add d, b
3437   1D52 E4            pop a
3438   1D53 32            mov bl, [d]
3439   1D54 A7 00         mov bh, 0
3440   1D56 DD            push bl
3441   1D57 07 76 19      call base64_char_value
3442   1D5A 51 01 00      add sp, 1
3443   1D5D E7            pop d
3444   1D5E FD 3E         mov [d], bl
3445   1D60             ;; input_buffer[i] = base64_char_value(input_buffer[i]); 
3446   1D60 FA F5 FF      lea d, [bp + -11] ; $input_buffer
3447   1D63 D7            push a
3448   1D64 DA            push d
3449   1D65 FA FF FF      lea d, [bp + -1] ; $i
3450   1D68 2A            mov b, [d]
3451   1D69 E7            pop d
3452   1D6A 5A            add d, b
3453   1D6B E4            pop a
3454   1D6C DA            push d
3455   1D6D FA F5 FF      lea d, [bp + -11] ; $input_buffer
3456   1D70 D7            push a
3457   1D71 DA            push d
3458   1D72 FA FF FF      lea d, [bp + -1] ; $i
3459   1D75 2A            mov b, [d]
3460   1D76 E7            pop d
3461   1D77 5A            add d, b
3462   1D78 E4            pop a
3463   1D79 32            mov bl, [d]
3464   1D7A A7 00         mov bh, 0
3465   1D7C DD            push bl
3466   1D7D 07 76 19      call base64_char_value
3467   1D80 51 01 00      add sp, 1
3468   1D83 E7            pop d
3469   1D84 FD 3E         mov [d], bl
3470   1D86             ;; printf("input_buffer[i] == base64_char_val(input_buffer[i]): %d\n", input_buffer[i] == a); 
3471   1D86 FA F5 FF      lea d, [bp + -11] ; $input_buffer
3472   1D89 D7            push a
3473   1D8A DA            push d
3474   1D8B FA FF FF      lea d, [bp + -1] ; $i
3475   1D8E 2A            mov b, [d]
3476   1D8F E7            pop d
3477   1D90 5A            add d, b
3478   1D91 E4            pop a
3479   1D92 32            mov bl, [d]
3480   1D93 A7 00         mov bh, 0
3481   1D95             ; START RELATIONAL
3482   1D95 D7            push a
3483   1D96 11            mov a, b
3484   1D97 FA F1 FF      lea d, [bp + -15] ; $a
3485   1D9A 32            mov bl, [d]
3486   1D9B A7 00         mov bh, 0
3487   1D9D B0            cmp a, b
3488   1D9E FD 71         seq ; ==
3489   1DA0 E4            pop a
3490   1DA1             ; END RELATIONAL
3491   1DA1 FD AB         swp b
3492   1DA3 D8            push b
3493   1DA4 26 49 25      mov b, _s9 ; "input_buffer[i] == base64_char_val(input_buffer[i]): %d\n"
3494   1DA7 FD AB         swp b
3495   1DA9 D8            push b
3496   1DAA 07 E9 07      call printf
3497   1DAD 51 04 00      add sp, 4
3498   1DB0             ;; pass=pass && input_buffer[i] == a; 
3499   1DB0 3B 46 24      mov d, _pass ; $pass
3500   1DB3 DA            push d
3501   1DB4 3B 46 24      mov d, _pass ; $pass
3502   1DB7 2A            mov b, [d]
3503   1DB8             ; START LOGICAL AND
3504   1DB8 D7            push a
3505   1DB9 11            mov a, b
3506   1DBA FA F5 FF      lea d, [bp + -11] ; $input_buffer
3507   1DBD D7            push a
3508   1DBE DA            push d
3509   1DBF FA FF FF      lea d, [bp + -1] ; $i
3510   1DC2 2A            mov b, [d]
3511   1DC3 E7            pop d
3512   1DC4 5A            add d, b
3513   1DC5 E4            pop a
3514   1DC6 32            mov bl, [d]
3515   1DC7 A7 00         mov bh, 0
3516   1DC9             ; START RELATIONAL
3517   1DC9 D7            push a
3518   1DCA 11            mov a, b
3519   1DCB FA F1 FF      lea d, [bp + -15] ; $a
3520   1DCE 32            mov bl, [d]
3521   1DCF A7 00         mov bh, 0
3522   1DD1 B0            cmp a, b
3523   1DD2 FD 71         seq ; ==
3524   1DD4 E4            pop a
3525   1DD5             ; END RELATIONAL
3526   1DD5 FD A7         sand a, b
3527   1DD7 E4            pop a
3528   1DD8             ; END LOGICAL AND
3529   1DD8 E7            pop d
3530   1DD9 FD 43         mov [d], b
3531   1DDB             ;; if(!pass){ 
3532   1DDB             _if52_cond:
3533   1DDB 3B 46 24      mov d, _pass ; $pass
3534   1DDE 2A            mov b, [d]
3535   1DDF C0 00 00      cmp b, 0
3536   1DE2 FD 71         seq ; !
3537   1DE4 C0 00 00      cmp b, 0
3538   1DE7 C6 F9 1D      je _if52_exit
3539   1DEA             _if52_true:
3540   1DEA             ;; section = 2; 
3541   1DEA 3B 48 24      mov d, _section ; $section
3542   1DED DA            push d
3543   1DEE 26 02 00      mov b, $2
3544   1DF1 E7            pop d
3545   1DF2 FD 43         mov [d], b
3546   1DF4             ;; return; 
3547   1DF4 F9            leave
3548   1DF5 09            ret
3549   1DF6 0A F9 1D      jmp _if52_exit
3550   1DF9             _if52_exit:
3551   1DF9             _for51_update:
3552   1DF9 FA FF FF      lea d, [bp + -1] ; $i
3553   1DFC 2A            mov b, [d]
3554   1DFD FD 77         inc b
3555   1DFF FA FF FF      lea d, [bp + -1] ; $i
3556   1E02 FD 43         mov [d], b
3557   1E04 FD 7D         dec b
3558   1E06 0A 1D 1D      jmp _for51_cond
3559   1E09             _for51_exit:
3560   1E09             ;; for (i = 0; i < 3; i++) { 
3561   1E09             _for53_init:
3562   1E09 FA FF FF      lea d, [bp + -1] ; $i
3563   1E0C DA            push d
3564   1E0D 26 00 00      mov b, $0
3565   1E10 E7            pop d
3566   1E11 FD 43         mov [d], b
3567   1E13             _for53_cond:
3568   1E13 FA FF FF      lea d, [bp + -1] ; $i
3569   1E16 2A            mov b, [d]
3570   1E17             ; START RELATIONAL
3571   1E17 D7            push a
3572   1E18 11            mov a, b
3573   1E19 26 03 00      mov b, $3
3574   1E1C B0            cmp a, b
3575   1E1D FD 73         slt ; < (signed)
3576   1E1F E4            pop a
3577   1E20             ; END RELATIONAL
3578   1E20 C0 00 00      cmp b, 0
3579   1E23 C6 13 1F      je _for53_exit
3580   1E26             _for53_block:
3581   1E26             ;; printf("inside second for loop for i=0 to 2. i = %d\n", i); 
3582   1E26 FA FF FF      lea d, [bp + -1] ; $i
3583   1E29 2A            mov b, [d]
3584   1E2A FD AB         swp b
3585   1E2C D8            push b
3586   1E2D 26 82 25      mov b, _s10 ; "inside second for loop for i=0 to 2. i = %d\n"
3587   1E30 FD AB         swp b
3588   1E32 D8            push b
3589   1E33 07 E9 07      call printf
3590   1E36 51 04 00      add sp, 4
3591   1E39             ;; output[j++] = output_buffer[i]; 
3592   1E39 FA 07 00      lea d, [bp + 7] ; $output
3593   1E3C FD 2A         mov d, [d]
3594   1E3E D7            push a
3595   1E3F DA            push d
3596   1E40 FA FD FF      lea d, [bp + -3] ; $j
3597   1E43 2A            mov b, [d]
3598   1E44 FD 77         inc b
3599   1E46 FA FD FF      lea d, [bp + -3] ; $j
3600   1E49 FD 43         mov [d], b
3601   1E4B FD 7D         dec b
3602   1E4D E7            pop d
3603   1E4E FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
3604   1E52 E4            pop a
3605   1E53 DA            push d
3606   1E54 FA F2 FF      lea d, [bp + -14] ; $output_buffer
3607   1E57 D7            push a
3608   1E58 DA            push d
3609   1E59 FA FF FF      lea d, [bp + -1] ; $i
3610   1E5C 2A            mov b, [d]
3611   1E5D E7            pop d
3612   1E5E 5A            add d, b
3613   1E5F E4            pop a
3614   1E60 32            mov bl, [d]
3615   1E61 A7 00         mov bh, 0
3616   1E63 E7            pop d
3617   1E64 FD 3E         mov [d], bl
3618   1E66             ;; printf("output[j] == output_buffer[i]: %d\n", output[j+-1] == output_buffer[i]); 
3619   1E66 FA 07 00      lea d, [bp + 7] ; $output
3620   1E69 FD 2A         mov d, [d]
3621   1E6B D7            push a
3622   1E6C DA            push d
3623   1E6D FA FD FF      lea d, [bp + -3] ; $j
3624   1E70 2A            mov b, [d]
3625   1E71             ; START TERMS
3626   1E71 D7            push a
3627   1E72 11            mov a, b
3628   1E73 26 FF FF      mov b, $ffff
3629   1E76 56            add b, a
3630   1E77 E4            pop a
3631   1E78             ; END TERMS
3632   1E78 E7            pop d
3633   1E79 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
3634   1E7D E4            pop a
3635   1E7E 32            mov bl, [d]
3636   1E7F A7 00         mov bh, 0
3637   1E81             ; START RELATIONAL
3638   1E81 D7            push a
3639   1E82 11            mov a, b
3640   1E83 FA F2 FF      lea d, [bp + -14] ; $output_buffer
3641   1E86 D7            push a
3642   1E87 DA            push d
3643   1E88 FA FF FF      lea d, [bp + -1] ; $i
3644   1E8B 2A            mov b, [d]
3645   1E8C E7            pop d
3646   1E8D 5A            add d, b
3647   1E8E E4            pop a
3648   1E8F 32            mov bl, [d]
3649   1E90 A7 00         mov bh, 0
3650   1E92 B0            cmp a, b
3651   1E93 FD 71         seq ; ==
3652   1E95 E4            pop a
3653   1E96             ; END RELATIONAL
3654   1E96 FD AB         swp b
3655   1E98 D8            push b
3656   1E99 26 AF 25      mov b, _s11 ; "output[j] == output_buffer[i]: %d\n"
3657   1E9C FD AB         swp b
3658   1E9E D8            push b
3659   1E9F 07 E9 07      call printf
3660   1EA2 51 04 00      add sp, 4
3661   1EA5             ;; pass=pass && output[j+-1] == output_buffer[i]; 
3662   1EA5 3B 46 24      mov d, _pass ; $pass
3663   1EA8 DA            push d
3664   1EA9 3B 46 24      mov d, _pass ; $pass
3665   1EAC 2A            mov b, [d]
3666   1EAD             ; START LOGICAL AND
3667   1EAD D7            push a
3668   1EAE 11            mov a, b
3669   1EAF FA 07 00      lea d, [bp + 7] ; $output
3670   1EB2 FD 2A         mov d, [d]
3671   1EB4 D7            push a
3672   1EB5 DA            push d
3673   1EB6 FA FD FF      lea d, [bp + -3] ; $j
3674   1EB9 2A            mov b, [d]
3675   1EBA             ; START TERMS
3676   1EBA D7            push a
3677   1EBB 11            mov a, b
3678   1EBC 26 FF FF      mov b, $ffff
3679   1EBF 56            add b, a
3680   1EC0 E4            pop a
3681   1EC1             ; END TERMS
3682   1EC1 E7            pop d
3683   1EC2 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
3684   1EC6 E4            pop a
3685   1EC7 32            mov bl, [d]
3686   1EC8 A7 00         mov bh, 0
3687   1ECA             ; START RELATIONAL
3688   1ECA D7            push a
3689   1ECB 11            mov a, b
3690   1ECC FA F2 FF      lea d, [bp + -14] ; $output_buffer
3691   1ECF D7            push a
3692   1ED0 DA            push d
3693   1ED1 FA FF FF      lea d, [bp + -1] ; $i
3694   1ED4 2A            mov b, [d]
3695   1ED5 E7            pop d
3696   1ED6 5A            add d, b
3697   1ED7 E4            pop a
3698   1ED8 32            mov bl, [d]
3699   1ED9 A7 00         mov bh, 0
3700   1EDB B0            cmp a, b
3701   1EDC FD 71         seq ; ==
3702   1EDE E4            pop a
3703   1EDF             ; END RELATIONAL
3704   1EDF FD A7         sand a, b
3705   1EE1 E4            pop a
3706   1EE2             ; END LOGICAL AND
3707   1EE2 E7            pop d
3708   1EE3 FD 43         mov [d], b
3709   1EE5             ;; if(!pass){ 
3710   1EE5             _if54_cond:
3711   1EE5 3B 46 24      mov d, _pass ; $pass
3712   1EE8 2A            mov b, [d]
3713   1EE9 C0 00 00      cmp b, 0
3714   1EEC FD 71         seq ; !
3715   1EEE C0 00 00      cmp b, 0
3716   1EF1 C6 03 1F      je _if54_exit
3717   1EF4             _if54_true:
3718   1EF4             ;; section = 3; 
3719   1EF4 3B 48 24      mov d, _section ; $section
3720   1EF7 DA            push d
3721   1EF8 26 03 00      mov b, $3
3722   1EFB E7            pop d
3723   1EFC FD 43         mov [d], b
3724   1EFE             ;; return; 
3725   1EFE F9            leave
3726   1EFF 09            ret
3727   1F00 0A 03 1F      jmp _if54_exit
3728   1F03             _if54_exit:
3729   1F03             _for53_update:
3730   1F03 FA FF FF      lea d, [bp + -1] ; $i
3731   1F06 2A            mov b, [d]
3732   1F07 FD 77         inc b
3733   1F09 FA FF FF      lea d, [bp + -1] ; $i
3734   1F0C FD 43         mov [d], b
3735   1F0E FD 7D         dec b
3736   1F10 0A 13 1E      jmp _for53_cond
3737   1F13             _for53_exit:
3738   1F13             ;; i = 0; 
3739   1F13 FA FF FF      lea d, [bp + -1] ; $i
3740   1F16 DA            push d
3741   1F17 26 00 00      mov b, $0
3742   1F1A E7            pop d
3743   1F1B FD 43         mov [d], b
3744   1F1D 0A 20 1F      jmp _if49_exit
3745   1F20             _if49_exit:
3746   1F20 0A D3 1A      jmp _while47_cond
3747   1F23             _while47_exit:
3748   1F23             ;; if (i) { 
3749   1F23             _if55_cond:
3750   1F23 FA FF FF      lea d, [bp + -1] ; $i
3751   1F26 2A            mov b, [d]
3752   1F27 C0 00 00      cmp b, 0
3753   1F2A C6 01 22      je _if55_exit
3754   1F2D             _if55_true:
3755   1F2D             ;; pass=pass && i; 
3756   1F2D 3B 46 24      mov d, _pass ; $pass
3757   1F30 DA            push d
3758   1F31 3B 46 24      mov d, _pass ; $pass
3759   1F34 2A            mov b, [d]
3760   1F35             ; START LOGICAL AND
3761   1F35 D7            push a
3762   1F36 11            mov a, b
3763   1F37 FA FF FF      lea d, [bp + -1] ; $i
3764   1F3A 2A            mov b, [d]
3765   1F3B FD A7         sand a, b
3766   1F3D E4            pop a
3767   1F3E             ; END LOGICAL AND
3768   1F3E E7            pop d
3769   1F3F FD 43         mov [d], b
3770   1F41             ;; if(!pass){ 
3771   1F41             _if56_cond:
3772   1F41 3B 46 24      mov d, _pass ; $pass
3773   1F44 2A            mov b, [d]
3774   1F45 C0 00 00      cmp b, 0
3775   1F48 FD 71         seq ; !
3776   1F4A C0 00 00      cmp b, 0
3777   1F4D C6 5F 1F      je _if56_exit
3778   1F50             _if56_true:
3779   1F50             ;; section = 4; 
3780   1F50 3B 48 24      mov d, _section ; $section
3781   1F53 DA            push d
3782   1F54 26 04 00      mov b, $4
3783   1F57 E7            pop d
3784   1F58 FD 43         mov [d], b
3785   1F5A             ;; return; 
3786   1F5A F9            leave
3787   1F5B 09            ret
3788   1F5C 0A 5F 1F      jmp _if56_exit
3789   1F5F             _if56_exit:
3790   1F5F             ;; for (k = i; k < 4; k++) { 
3791   1F5F             _for57_init:
3792   1F5F FA FB FF      lea d, [bp + -5] ; $k
3793   1F62 DA            push d
3794   1F63 FA FF FF      lea d, [bp + -1] ; $i
3795   1F66 2A            mov b, [d]
3796   1F67 E7            pop d
3797   1F68 FD 43         mov [d], b
3798   1F6A             _for57_cond:
3799   1F6A FA FB FF      lea d, [bp + -5] ; $k
3800   1F6D 2A            mov b, [d]
3801   1F6E             ; START RELATIONAL
3802   1F6E D7            push a
3803   1F6F 11            mov a, b
3804   1F70 26 04 00      mov b, $4
3805   1F73 B0            cmp a, b
3806   1F74 FD 73         slt ; < (signed)
3807   1F76 E4            pop a
3808   1F77             ; END RELATIONAL
3809   1F77 C0 00 00      cmp b, 0
3810   1F7A C6 E6 1F      je _for57_exit
3811   1F7D             _for57_block:
3812   1F7D             ;; input_buffer[k] = 0; 
3813   1F7D FA F5 FF      lea d, [bp + -11] ; $input_buffer
3814   1F80 D7            push a
3815   1F81 DA            push d
3816   1F82 FA FB FF      lea d, [bp + -5] ; $k
3817   1F85 2A            mov b, [d]
3818   1F86 E7            pop d
3819   1F87 5A            add d, b
3820   1F88 E4            pop a
3821   1F89 DA            push d
3822   1F8A 26 00 00      mov b, $0
3823   1F8D E7            pop d
3824   1F8E FD 3E         mov [d], bl
3825   1F90             ;; pass=pass && input_buffer[k]==0; 
3826   1F90 3B 46 24      mov d, _pass ; $pass
3827   1F93 DA            push d
3828   1F94 3B 46 24      mov d, _pass ; $pass
3829   1F97 2A            mov b, [d]
3830   1F98             ; START LOGICAL AND
3831   1F98 D7            push a
3832   1F99 11            mov a, b
3833   1F9A FA F5 FF      lea d, [bp + -11] ; $input_buffer
3834   1F9D D7            push a
3835   1F9E DA            push d
3836   1F9F FA FB FF      lea d, [bp + -5] ; $k
3837   1FA2 2A            mov b, [d]
3838   1FA3 E7            pop d
3839   1FA4 5A            add d, b
3840   1FA5 E4            pop a
3841   1FA6 32            mov bl, [d]
3842   1FA7 A7 00         mov bh, 0
3843   1FA9             ; START RELATIONAL
3844   1FA9 D7            push a
3845   1FAA 11            mov a, b
3846   1FAB 26 00 00      mov b, $0
3847   1FAE B0            cmp a, b
3848   1FAF FD 71         seq ; ==
3849   1FB1 E4            pop a
3850   1FB2             ; END RELATIONAL
3851   1FB2 FD A7         sand a, b
3852   1FB4 E4            pop a
3853   1FB5             ; END LOGICAL AND
3854   1FB5 E7            pop d
3855   1FB6 FD 43         mov [d], b
3856   1FB8             ;; if(!pass){ 
3857   1FB8             _if58_cond:
3858   1FB8 3B 46 24      mov d, _pass ; $pass
3859   1FBB 2A            mov b, [d]
3860   1FBC C0 00 00      cmp b, 0
3861   1FBF FD 71         seq ; !
3862   1FC1 C0 00 00      cmp b, 0
3863   1FC4 C6 D6 1F      je _if58_exit
3864   1FC7             _if58_true:
3865   1FC7             ;; section = 5; 
3866   1FC7 3B 48 24      mov d, _section ; $section
3867   1FCA DA            push d
3868   1FCB 26 05 00      mov b, $5
3869   1FCE E7            pop d
3870   1FCF FD 43         mov [d], b
3871   1FD1             ;; return; 
3872   1FD1 F9            leave
3873   1FD2 09            ret
3874   1FD3 0A D6 1F      jmp _if58_exit
3875   1FD6             _if58_exit:
3876   1FD6             _for57_update:
3877   1FD6 FA FB FF      lea d, [bp + -5] ; $k
3878   1FD9 2A            mov b, [d]
3879   1FDA FD 77         inc b
3880   1FDC FA FB FF      lea d, [bp + -5] ; $k
3881   1FDF FD 43         mov [d], b
3882   1FE1 FD 7D         dec b
3883   1FE3 0A 6A 1F      jmp _for57_cond
3884   1FE6             _for57_exit:
3885   1FE6             ;; for (k = 0; k < 4; k++) { 
3886   1FE6             _for59_init:
3887   1FE6 FA FB FF      lea d, [bp + -5] ; $k
3888   1FE9 DA            push d
3889   1FEA 26 00 00      mov b, $0
3890   1FED E7            pop d
3891   1FEE FD 43         mov [d], b
3892   1FF0             _for59_cond:
3893   1FF0 FA FB FF      lea d, [bp + -5] ; $k
3894   1FF3 2A            mov b, [d]
3895   1FF4             ; START RELATIONAL
3896   1FF4 D7            push a
3897   1FF5 11            mov a, b
3898   1FF6 26 04 00      mov b, $4
3899   1FF9 B0            cmp a, b
3900   1FFA FD 73         slt ; < (signed)
3901   1FFC E4            pop a
3902   1FFD             ; END RELATIONAL
3903   1FFD C0 00 00      cmp b, 0
3904   2000 C6 9F 20      je _for59_exit
3905   2003             _for59_block:
3906   2003             ;; a = base64_char_value(input_buffer[k]); 
3907   2003 FA F1 FF      lea d, [bp + -15] ; $a
3908   2006 DA            push d
3909   2007 FA F5 FF      lea d, [bp + -11] ; $input_buffer
3910   200A D7            push a
3911   200B DA            push d
3912   200C FA FB FF      lea d, [bp + -5] ; $k
3913   200F 2A            mov b, [d]
3914   2010 E7            pop d
3915   2011 5A            add d, b
3916   2012 E4            pop a
3917   2013 32            mov bl, [d]
3918   2014 A7 00         mov bh, 0
3919   2016 DD            push bl
3920   2017 07 76 19      call base64_char_value
3921   201A 51 01 00      add sp, 1
3922   201D E7            pop d
3923   201E FD 3E         mov [d], bl
3924   2020             ;; input_buffer[k] = base64_char_value(input_buffer[k]); 
3925   2020 FA F5 FF      lea d, [bp + -11] ; $input_buffer
3926   2023 D7            push a
3927   2024 DA            push d
3928   2025 FA FB FF      lea d, [bp + -5] ; $k
3929   2028 2A            mov b, [d]
3930   2029 E7            pop d
3931   202A 5A            add d, b
3932   202B E4            pop a
3933   202C DA            push d
3934   202D FA F5 FF      lea d, [bp + -11] ; $input_buffer
3935   2030 D7            push a
3936   2031 DA            push d
3937   2032 FA FB FF      lea d, [bp + -5] ; $k
3938   2035 2A            mov b, [d]
3939   2036 E7            pop d
3940   2037 5A            add d, b
3941   2038 E4            pop a
3942   2039 32            mov bl, [d]
3943   203A A7 00         mov bh, 0
3944   203C DD            push bl
3945   203D 07 76 19      call base64_char_value
3946   2040 51 01 00      add sp, 1
3947   2043 E7            pop d
3948   2044 FD 3E         mov [d], bl
3949   2046             ;; pass=pass && input_buffer[k] == a; 
3950   2046 3B 46 24      mov d, _pass ; $pass
3951   2049 DA            push d
3952   204A 3B 46 24      mov d, _pass ; $pass
3953   204D 2A            mov b, [d]
3954   204E             ; START LOGICAL AND
3955   204E D7            push a
3956   204F 11            mov a, b
3957   2050 FA F5 FF      lea d, [bp + -11] ; $input_buffer
3958   2053 D7            push a
3959   2054 DA            push d
3960   2055 FA FB FF      lea d, [bp + -5] ; $k
3961   2058 2A            mov b, [d]
3962   2059 E7            pop d
3963   205A 5A            add d, b
3964   205B E4            pop a
3965   205C 32            mov bl, [d]
3966   205D A7 00         mov bh, 0
3967   205F             ; START RELATIONAL
3968   205F D7            push a
3969   2060 11            mov a, b
3970   2061 FA F1 FF      lea d, [bp + -15] ; $a
3971   2064 32            mov bl, [d]
3972   2065 A7 00         mov bh, 0
3973   2067 B0            cmp a, b
3974   2068 FD 71         seq ; ==
3975   206A E4            pop a
3976   206B             ; END RELATIONAL
3977   206B FD A7         sand a, b
3978   206D E4            pop a
3979   206E             ; END LOGICAL AND
3980   206E E7            pop d
3981   206F FD 43         mov [d], b
3982   2071             ;; if(!pass){ 
3983   2071             _if60_cond:
3984   2071 3B 46 24      mov d, _pass ; $pass
3985   2074 2A            mov b, [d]
3986   2075 C0 00 00      cmp b, 0
3987   2078 FD 71         seq ; !
3988   207A C0 00 00      cmp b, 0
3989   207D C6 8F 20      je _if60_exit
3990   2080             _if60_true:
3991   2080             ;; section = 6; 
3992   2080 3B 48 24      mov d, _section ; $section
3993   2083 DA            push d
3994   2084 26 06 00      mov b, $6
3995   2087 E7            pop d
3996   2088 FD 43         mov [d], b
3997   208A             ;; return; 
3998   208A F9            leave
3999   208B 09            ret
4000   208C 0A 8F 20      jmp _if60_exit
4001   208F             _if60_exit:
4002   208F             _for59_update:
4003   208F FA FB FF      lea d, [bp + -5] ; $k
4004   2092 2A            mov b, [d]
4005   2093 FD 77         inc b
4006   2095 FA FB FF      lea d, [bp + -5] ; $k
4007   2098 FD 43         mov [d], b
4008   209A FD 7D         dec b
4009   209C 0A F0 1F      jmp _for59_cond
4010   209F             _for59_exit:
4011   209F             ;; output_buffer[0] = (input_buffer[0] << 2) + ((input_buffer[1] & 0x30) >> 4); 
4012   209F FA F2 FF      lea d, [bp + -14] ; $output_buffer
4013   20A2 D7            push a
4014   20A3 DA            push d
4015   20A4 26 00 00      mov b, $0
4016   20A7 E7            pop d
4017   20A8 5A            add d, b
4018   20A9 E4            pop a
4019   20AA DA            push d
4020   20AB FA F5 FF      lea d, [bp + -11] ; $input_buffer
4021   20AE D7            push a
4022   20AF DA            push d
4023   20B0 26 00 00      mov b, $0
4024   20B3 E7            pop d
4025   20B4 5A            add d, b
4026   20B5 E4            pop a
4027   20B6 32            mov bl, [d]
4028   20B7 A7 00         mov bh, 0
4029   20B9             ; START SHIFT
4030   20B9 D7            push a
4031   20BA 11            mov a, b
4032   20BB 26 02 00      mov b, $2
4033   20BE FD 39         mov c, b
4034   20C0 9D            shl a, cl
4035   20C1 27            mov b, a
4036   20C2 E4            pop a
4037   20C3             ; END SHIFT
4038   20C3             ; START TERMS
4039   20C3 D7            push a
4040   20C4 11            mov a, b
4041   20C5 FA F5 FF      lea d, [bp + -11] ; $input_buffer
4042   20C8 D7            push a
4043   20C9 DA            push d
4044   20CA 26 01 00      mov b, $1
4045   20CD E7            pop d
4046   20CE 5A            add d, b
4047   20CF E4            pop a
4048   20D0 32            mov bl, [d]
4049   20D1 A7 00         mov bh, 0
4050   20D3 D7            push a
4051   20D4 11            mov a, b
4052   20D5 26 30 00      mov b, $30
4053   20D8 FD 92         and b, a ; &
4054   20DA E4            pop a
4055   20DB             ; START SHIFT
4056   20DB D7            push a
4057   20DC 11            mov a, b
4058   20DD 26 04 00      mov b, $4
4059   20E0 FD 39         mov c, b
4060   20E2 A5            ashr a, cl
4061   20E3 27            mov b, a
4062   20E4 E4            pop a
4063   20E5             ; END SHIFT
4064   20E5 56            add b, a
4065   20E6 E4            pop a
4066   20E7             ; END TERMS
4067   20E7 E7            pop d
4068   20E8 FD 3E         mov [d], bl
4069   20EA             ;; output_buffer[1] = ((input_buffer[1] & 0x0F) << 4) + ((input_buffer[2] & 0x3C) >> 2); 
4070   20EA FA F2 FF      lea d, [bp + -14] ; $output_buffer
4071   20ED D7            push a
4072   20EE DA            push d
4073   20EF 26 01 00      mov b, $1
4074   20F2 E7            pop d
4075   20F3 5A            add d, b
4076   20F4 E4            pop a
4077   20F5 DA            push d
4078   20F6 FA F5 FF      lea d, [bp + -11] ; $input_buffer
4079   20F9 D7            push a
4080   20FA DA            push d
4081   20FB 26 01 00      mov b, $1
4082   20FE E7            pop d
4083   20FF 5A            add d, b
4084   2100 E4            pop a
4085   2101 32            mov bl, [d]
4086   2102 A7 00         mov bh, 0
4087   2104 D7            push a
4088   2105 11            mov a, b
4089   2106 26 0F 00      mov b, $f
4090   2109 FD 92         and b, a ; &
4091   210B E4            pop a
4092   210C             ; START SHIFT
4093   210C D7            push a
4094   210D 11            mov a, b
4095   210E 26 04 00      mov b, $4
4096   2111 FD 39         mov c, b
4097   2113 9D            shl a, cl
4098   2114 27            mov b, a
4099   2115 E4            pop a
4100   2116             ; END SHIFT
4101   2116             ; START TERMS
4102   2116 D7            push a
4103   2117 11            mov a, b
4104   2118 FA F5 FF      lea d, [bp + -11] ; $input_buffer
4105   211B D7            push a
4106   211C DA            push d
4107   211D 26 02 00      mov b, $2
4108   2120 E7            pop d
4109   2121 5A            add d, b
4110   2122 E4            pop a
4111   2123 32            mov bl, [d]
4112   2124 A7 00         mov bh, 0
4113   2126 D7            push a
4114   2127 11            mov a, b
4115   2128 26 3C 00      mov b, $3c
4116   212B FD 92         and b, a ; &
4117   212D E4            pop a
4118   212E             ; START SHIFT
4119   212E D7            push a
4120   212F 11            mov a, b
4121   2130 26 02 00      mov b, $2
4122   2133 FD 39         mov c, b
4123   2135 A5            ashr a, cl
4124   2136 27            mov b, a
4125   2137 E4            pop a
4126   2138             ; END SHIFT
4127   2138 56            add b, a
4128   2139 E4            pop a
4129   213A             ; END TERMS
4130   213A E7            pop d
4131   213B FD 3E         mov [d], bl
4132   213D             ;; for (k = 0; k < i - 1; k++) { 
4133   213D             _for61_init:
4134   213D FA FB FF      lea d, [bp + -5] ; $k
4135   2140 DA            push d
4136   2141 26 00 00      mov b, $0
4137   2144 E7            pop d
4138   2145 FD 43         mov [d], b
4139   2147             _for61_cond:
4140   2147 FA FB FF      lea d, [bp + -5] ; $k
4141   214A 2A            mov b, [d]
4142   214B             ; START RELATIONAL
4143   214B D7            push a
4144   214C 11            mov a, b
4145   214D FA FF FF      lea d, [bp + -1] ; $i
4146   2150 2A            mov b, [d]
4147   2151             ; START TERMS
4148   2151 D7            push a
4149   2152 11            mov a, b
4150   2153 26 01 00      mov b, $1
4151   2156 60            sub a, b
4152   2157 27            mov b, a
4153   2158 E4            pop a
4154   2159             ; END TERMS
4155   2159 B0            cmp a, b
4156   215A FD 73         slt ; < (signed)
4157   215C E4            pop a
4158   215D             ; END RELATIONAL
4159   215D C0 00 00      cmp b, 0
4160   2160 C6 FE 21      je _for61_exit
4161   2163             _for61_block:
4162   2163             ;; output[j++] = output_buffer[k]; 
4163   2163 FA 07 00      lea d, [bp + 7] ; $output
4164   2166 FD 2A         mov d, [d]
4165   2168 D7            push a
4166   2169 DA            push d
4167   216A FA FD FF      lea d, [bp + -3] ; $j
4168   216D 2A            mov b, [d]
4169   216E FD 77         inc b
4170   2170 FA FD FF      lea d, [bp + -3] ; $j
4171   2173 FD 43         mov [d], b
4172   2175 FD 7D         dec b
4173   2177 E7            pop d
4174   2178 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
4175   217C E4            pop a
4176   217D DA            push d
4177   217E FA F2 FF      lea d, [bp + -14] ; $output_buffer
4178   2181 D7            push a
4179   2182 DA            push d
4180   2183 FA FB FF      lea d, [bp + -5] ; $k
4181   2186 2A            mov b, [d]
4182   2187 E7            pop d
4183   2188 5A            add d, b
4184   2189 E4            pop a
4185   218A 32            mov bl, [d]
4186   218B A7 00         mov bh, 0
4187   218D E7            pop d
4188   218E FD 3E         mov [d], bl
4189   2190             ;; pass=pass && output[j+-1] == output_buffer[k]; 
4190   2190 3B 46 24      mov d, _pass ; $pass
4191   2193 DA            push d
4192   2194 3B 46 24      mov d, _pass ; $pass
4193   2197 2A            mov b, [d]
4194   2198             ; START LOGICAL AND
4195   2198 D7            push a
4196   2199 11            mov a, b
4197   219A FA 07 00      lea d, [bp + 7] ; $output
4198   219D FD 2A         mov d, [d]
4199   219F D7            push a
4200   21A0 DA            push d
4201   21A1 FA FD FF      lea d, [bp + -3] ; $j
4202   21A4 2A            mov b, [d]
4203   21A5             ; START TERMS
4204   21A5 D7            push a
4205   21A6 11            mov a, b
4206   21A7 26 FF FF      mov b, $ffff
4207   21AA 56            add b, a
4208   21AB E4            pop a
4209   21AC             ; END TERMS
4210   21AC E7            pop d
4211   21AD FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
4212   21B1 E4            pop a
4213   21B2 32            mov bl, [d]
4214   21B3 A7 00         mov bh, 0
4215   21B5             ; START RELATIONAL
4216   21B5 D7            push a
4217   21B6 11            mov a, b
4218   21B7 FA F2 FF      lea d, [bp + -14] ; $output_buffer
4219   21BA D7            push a
4220   21BB DA            push d
4221   21BC FA FB FF      lea d, [bp + -5] ; $k
4222   21BF 2A            mov b, [d]
4223   21C0 E7            pop d
4224   21C1 5A            add d, b
4225   21C2 E4            pop a
4226   21C3 32            mov bl, [d]
4227   21C4 A7 00         mov bh, 0
4228   21C6 B0            cmp a, b
4229   21C7 FD 71         seq ; ==
4230   21C9 E4            pop a
4231   21CA             ; END RELATIONAL
4232   21CA FD A7         sand a, b
4233   21CC E4            pop a
4234   21CD             ; END LOGICAL AND
4235   21CD E7            pop d
4236   21CE FD 43         mov [d], b
4237   21D0             ;; if(!pass){ 
4238   21D0             _if62_cond:
4239   21D0 3B 46 24      mov d, _pass ; $pass
4240   21D3 2A            mov b, [d]
4241   21D4 C0 00 00      cmp b, 0
4242   21D7 FD 71         seq ; !
4243   21D9 C0 00 00      cmp b, 0
4244   21DC C6 EE 21      je _if62_exit
4245   21DF             _if62_true:
4246   21DF             ;; section = 7; 
4247   21DF 3B 48 24      mov d, _section ; $section
4248   21E2 DA            push d
4249   21E3 26 07 00      mov b, $7
4250   21E6 E7            pop d
4251   21E7 FD 43         mov [d], b
4252   21E9             ;; return; 
4253   21E9 F9            leave
4254   21EA 09            ret
4255   21EB 0A EE 21      jmp _if62_exit
4256   21EE             _if62_exit:
4257   21EE             _for61_update:
4258   21EE FA FB FF      lea d, [bp + -5] ; $k
4259   21F1 2A            mov b, [d]
4260   21F2 FD 77         inc b
4261   21F4 FA FB FF      lea d, [bp + -5] ; $k
4262   21F7 FD 43         mov [d], b
4263   21F9 FD 7D         dec b
4264   21FB 0A 47 21      jmp _for61_cond
4265   21FE             _for61_exit:
4266   21FE 0A 01 22      jmp _if55_exit
4267   2201             _if55_exit:
4268   2201             ;; output[j] = '\0'; 
4269   2201 FA 07 00      lea d, [bp + 7] ; $output
4270   2204 FD 2A         mov d, [d]
4271   2206 D7            push a
4272   2207 DA            push d
4273   2208 FA FD FF      lea d, [bp + -3] ; $j
4274   220B 2A            mov b, [d]
4275   220C E7            pop d
4276   220D FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
4277   2211 E4            pop a
4278   2212 DA            push d
4279   2213 26 00 00      mov b, $0
4280   2216 E7            pop d
4281   2217 FD 3E         mov [d], bl
4282   2219 F9            leave
4283   221A 09            ret
4284   221B             ; --- END TEXT BLOCK
4285   221B             
4286   221B             ; --- BEGIN DATA BLOCK
4287   221B 61 47 56 73 _input_data: .db "aGVsbG8gd29ybGQgbXkgbmFtZSBpcyBzb2wtMS4=", 0
4287   221F 62 47 38 67 
4287   2223 64 32 39 79 
4287   2227 62 47 51 67 
4287   222B 62 58 6B 67 
4287   222F 62 6D 46 74 
4287   2233 5A 53 42 70 
4287   2237 63 79 42 7A 
4287   223B 62 32 77 74 
4287   223F 4D 53 34 3D 
4287   2243 00 
4288   2244 1B 22       _input: .dw _input_data
4289   2246 00 00 00 00 _output_data: .fill 512, 0
4289   224A 00 00 00 00 
4289   224E 00 00 00 00 
4289   2252 00 00 00 00 
4289   2256 00 00 00 00 
4289   225A 00 00 00 00 
4289   225E 00 00 00 00 
4289   2262 00 00 00 00 
4289   2266 00 00 00 00 
4289   226A 00 00 00 00 
4289   226E 00 00 00 00 
4289   2272 00 00 00 00 
4289   2276 00 00 00 00 
4289   227A 00 00 00 00 
4289   227E 00 00 00 00 
4289   2282 00 00 00 00 
4289   2286 00 00 00 00 
4289   228A 00 00 00 00 
4289   228E 00 00 00 00 
4289   2292 00 00 00 00 
4289   2296 00 00 00 00 
4289   229A 00 00 00 00 
4289   229E 00 00 00 00 
4289   22A2 00 00 00 00 
4289   22A6 00 00 00 00 
4289   22AA 00 00 00 00 
4289   22AE 00 00 00 00 
4289   22B2 00 00 00 00 
4289   22B6 00 00 00 00 
4289   22BA 00 00 00 00 
4289   22BE 00 00 00 00 
4289   22C2 00 00 00 00 
4289   22C6 00 00 00 00 
4289   22CA 00 00 00 00 
4289   22CE 00 00 00 00 
4289   22D2 00 00 00 00 
4289   22D6 00 00 00 00 
4289   22DA 00 00 00 00 
4289   22DE 00 00 00 00 
4289   22E2 00 00 00 00 
4289   22E6 00 00 00 00 
4289   22EA 00 00 00 00 
4289   22EE 00 00 00 00 
4289   22F2 00 00 00 00 
4289   22F6 00 00 00 00 
4289   22FA 00 00 00 00 
4289   22FE 00 00 00 00 
4289   2302 00 00 00 00 
4289   2306 00 00 00 00 
4289   230A 00 00 00 00 
4289   230E 00 00 00 00 
4289   2312 00 00 00 00 
4289   2316 00 00 00 00 
4289   231A 00 00 00 00 
4289   231E 00 00 00 00 
4289   2322 00 00 00 00 
4289   2326 00 00 00 00 
4289   232A 00 00 00 00 
4289   232E 00 00 00 00 
4289   2332 00 00 00 00 
4289   2336 00 00 00 00 
4289   233A 00 00 00 00 
4289   233E 00 00 00 00 
4289   2342 00 00 00 00 
4289   2346 00 00 00 00 
4289   234A 00 00 00 00 
4289   234E 00 00 00 00 
4289   2352 00 00 00 00 
4289   2356 00 00 00 00 
4289   235A 00 00 00 00 
4289   235E 00 00 00 00 
4289   2362 00 00 00 00 
4289   2366 00 00 00 00 
4289   236A 00 00 00 00 
4289   236E 00 00 00 00 
4289   2372 00 00 00 00 
4289   2376 00 00 00 00 
4289   237A 00 00 00 00 
4289   237E 00 00 00 00 
4289   2382 00 00 00 00 
4289   2386 00 00 00 00 
4289   238A 00 00 00 00 
4289   238E 00 00 00 00 
4289   2392 00 00 00 00 
4289   2396 00 00 00 00 
4289   239A 00 00 00 00 
4289   239E 00 00 00 00 
4289   23A2 00 00 00 00 
4289   23A6 00 00 00 00 
4289   23AA 00 00 00 00 
4289   23AE 00 00 00 00 
4289   23B2 00 00 00 00 
4289   23B6 00 00 00 00 
4289   23BA 00 00 00 00 
4289   23BE 00 00 00 00 
4289   23C2 00 00 00 00 
4289   23C6 00 00 00 00 
4289   23CA 00 00 00 00 
4289   23CE 00 00 00 00 
4289   23D2 00 00 00 00 
4289   23D6 00 00 00 00 
4289   23DA 00 00 00 00 
4289   23DE 00 00 00 00 
4289   23E2 00 00 00 00 
4289   23E6 00 00 00 00 
4289   23EA 00 00 00 00 
4289   23EE 00 00 00 00 
4289   23F2 00 00 00 00 
4289   23F6 00 00 00 00 
4289   23FA 00 00 00 00 
4289   23FE 00 00 00 00 
4289   2402 00 00 00 00 
4289   2406 00 00 00 00 
4289   240A 00 00 00 00 
4289   240E 00 00 00 00 
4289   2412 00 00 00 00 
4289   2416 00 00 00 00 
4289   241A 00 00 00 00 
4289   241E 00 00 00 00 
4289   2422 00 00 00 00 
4289   2426 00 00 00 00 
4289   242A 00 00 00 00 
4289   242E 00 00 00 00 
4289   2432 00 00 00 00 
4289   2436 00 00 00 00 
4289   243A 00 00 00 00 
4289   243E 00 00 00 00 
4289   2442 00 00 00 00 
4290   2446 01 00       _pass: .dw 1
4291   2448 00 00       _section: .fill 2, 0
4292   244A 0A 52 65 73 _s0: .db "\nResult: %d. Section: %d\n", 0
4292   244E 75 6C 74 3A 
4292   2452 20 25 64 2E 
4292   2456 20 53 65 63 
4292   245A 74 69 6F 6E 
4292   245E 3A 20 25 64 
4292   2462 0A 00 
4293   2464 55 6E 65 78 _s1: .db "Unexpected format in printf.", 0
4293   2468 70 65 63 74 
4293   246C 65 64 20 66 
4293   2470 6F 72 6D 61 
4293   2474 74 20 69 6E 
4293   2478 20 70 72 69 
4293   247C 6E 74 66 2E 
4293   2480 00 
4294   2481 45 72 72 6F _s2: .db "Error: Unknown argument type.\n", 0
4294   2485 72 3A 20 55 
4294   2489 6E 6B 6E 6F 
4294   248D 77 6E 20 61 
4294   2491 72 67 75 6D 
4294   2495 65 6E 74 20 
4294   2499 74 79 70 65 
4294   249D 2E 0A 00 
4295   24A0 1B 5B 32 4A _s3: .db "\033[2J\033[H", 0
4295   24A4 1B 5B 48 00 
4296   24A8 4C 65 6E 3A _s4: .db "Len: %d\n", 0
4296   24AC 20 25 64 0A 
4296   24B0 00 
4297   24B1 69 6E 70 75 _s5: .db "input_len: %d, i: %d, j: %d, k: %d, input[k]: %c, base64: %d\n", 0
4297   24B5 74 5F 6C 65 
4297   24B9 6E 3A 20 25 
4297   24BD 64 2C 20 69 
4297   24C1 3A 20 25 64 
4297   24C5 2C 20 6A 3A 
4297   24C9 20 25 64 2C 
4297   24CD 20 6B 3A 20 
4297   24D1 25 64 2C 20 
4297   24D5 69 6E 70 75 
4297   24D9 74 5B 6B 5D 
4297   24DD 3A 20 25 63 
4297   24E1 2C 20 62 61 
4297   24E5 73 65 36 34 
4297   24E9 3A 20 25 64 
4297   24ED 0A 00 
4298   24EF 49 6E 73 69 _s6: .db "Inside while loop. condition: %d\n", 0
4298   24F3 64 65 20 77 
4298   24F7 68 69 6C 65 
4298   24FB 20 6C 6F 6F 
4298   24FF 70 2E 20 63 
4298   2503 6F 6E 64 69 
4298   2507 74 69 6F 6E 
4298   250B 3A 20 25 64 
4298   250F 0A 00 
4299   2511 69 73 20 69 _s7: .db "is i 4? %d\n", 0
4299   2515 20 34 3F 20 
4299   2519 25 64 0A 00 
4300   251D 69 6E 73 69 _s8: .db "inside first for loop for i=0 to 3. i = %d\n", 0
4300   2521 64 65 20 66 
4300   2525 69 72 73 74 
4300   2529 20 66 6F 72 
4300   252D 20 6C 6F 6F 
4300   2531 70 20 66 6F 
4300   2535 72 20 69 3D 
4300   2539 30 20 74 6F 
4300   253D 20 33 2E 20 
4300   2541 69 20 3D 20 
4300   2545 25 64 0A 00 
4301   2549 69 6E 70 75 _s9: .db "input_buffer[i] == base64_char_val(input_buffer[i]): %d\n", 0
4301   254D 74 5F 62 75 
4301   2551 66 66 65 72 
4301   2555 5B 69 5D 20 
4301   2559 3D 3D 20 62 
4301   255D 61 73 65 36 
4301   2561 34 5F 63 68 
4301   2565 61 72 5F 76 
4301   2569 61 6C 28 69 
4301   256D 6E 70 75 74 
4301   2571 5F 62 75 66 
4301   2575 66 65 72 5B 
4301   2579 69 5D 29 3A 
4301   257D 20 25 64 0A 
4301   2581 00 
4302   2582 69 6E 73 69 _s10: .db "inside second for loop for i=0 to 2. i = %d\n", 0
4302   2586 64 65 20 73 
4302   258A 65 63 6F 6E 
4302   258E 64 20 66 6F 
4302   2592 72 20 6C 6F 
4302   2596 6F 70 20 66 
4302   259A 6F 72 20 69 
4302   259E 3D 30 20 74 
4302   25A2 6F 20 32 2E 
4302   25A6 20 69 20 3D 
4302   25AA 20 25 64 0A 
4302   25AE 00 
4303   25AF 6F 75 74 70 _s11: .db "output[j] == output_buffer[i]: %d\n", 0
4303   25B3 75 74 5B 6A 
4303   25B7 5D 20 3D 3D 
4303   25BB 20 6F 75 74 
4303   25BF 70 75 74 5F 
4303   25C3 62 75 66 66 
4303   25C7 65 72 5B 69 
4303   25CB 5D 3A 20 25 
4303   25CF 64 0A 00 
4304   25D2             
4305   25D2 D4 25       _heap_top: .dw _heap
4306   25D4 00          _heap: .db 0
4307   25D5             ; --- END DATA BLOCK
4308   25D5             
4309   25D5             .end
tasm: Number of errors = 0
