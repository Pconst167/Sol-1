0001   0000             ; --- FILENAME: test
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; $i 
0011   0408 52 04 00      sub sp, 4
0012   040B             ;; i = 0xAABBCCDDL; 
0013   040B FA FD FF      lea d, [bp + -3] ; $i
0014   040E DA            push d
0015   040F 26 DD CC      mov b, $ccdd
0016   0412 38 BB AA      mov c, $aabb
0017   0415 E7            pop d
0018   0416 FD 43         mov [d], b
0019   0418             ;; printx32(i); 
0020   0418 FA FD FF      lea d, [bp + -3] ; $i
0021   041B 2A            mov b, [d]
0022   041C FD 79         mov g, b
0023   041E 28            mov b, c
0024   041F FD AB         swp b
0025   0421 D8            push b
0026   0422 FD 27         mov b, g
0027   0424 D8            push b
0028   0425 07 4A 08      call printx32
0029   0428 51 04 00      add sp, 4
0030   042B 05 0B         syscall sys_terminate_proc
0031   042D             
0032   042D             strcpy:
0033   042D F8 00 00      enter 0 ; (push bp; mov bp, sp)
0034   0430             ; $psrc 
0035   0430             ; $pdest 
0036   0430 52 04 00      sub sp, 4
0037   0433             ;; psrc = src; 
0038   0433 FA FF FF      lea d, [bp + -1] ; $psrc
0039   0436 DA            push d
0040   0437 FA 07 00      lea d, [bp + 7] ; $src
0041   043A 2A            mov b, [d]
0042   043B E7            pop d
0043   043C FD 43         mov [d], b
0044   043E             ;; pdest = dest; 
0045   043E FA FD FF      lea d, [bp + -3] ; $pdest
0046   0441 DA            push d
0047   0442 FA 05 00      lea d, [bp + 5] ; $dest
0048   0445 2A            mov b, [d]
0049   0446 E7            pop d
0050   0447 FD 43         mov [d], b
0051   0449             ;; while(*psrc) *pdest++ = *psrc++; 
0052   0449             _while1_cond:
0053   0449 FA FF FF      lea d, [bp + -1] ; $psrc
0054   044C 2A            mov b, [d]
0055   044D 74            mov d, b
0056   044E 32            mov bl, [d]
0057   044F A7 00         mov bh, 0
0058   0451 C0 00 00      cmp b, 0
0059   0454 C6 7C 04      je _while1_exit
0060   0457             _while1_block:
0061   0457             ;; *pdest++ = *psrc++; 
0062   0457 FA FD FF      lea d, [bp + -3] ; $pdest
0063   045A 2A            mov b, [d]
0064   045B D8            push b
0065   045C FD 77         inc b
0066   045E FA FD FF      lea d, [bp + -3] ; $pdest
0067   0461 FD 43         mov [d], b
0068   0463 E5            pop b
0069   0464 D8            push b
0070   0465 FA FF FF      lea d, [bp + -1] ; $psrc
0071   0468 2A            mov b, [d]
0072   0469 D8            push b
0073   046A FD 77         inc b
0074   046C FA FF FF      lea d, [bp + -1] ; $psrc
0075   046F FD 43         mov [d], b
0076   0471 E5            pop b
0077   0472 74            mov d, b
0078   0473 32            mov bl, [d]
0079   0474 A7 00         mov bh, 0
0080   0476 E7            pop d
0081   0477 FD 3E         mov [d], bl
0082   0479 0A 49 04      jmp _while1_cond
0083   047C             _while1_exit:
0084   047C             ;; *pdest = '\0'; 
0085   047C FA FD FF      lea d, [bp + -3] ; $pdest
0086   047F 2A            mov b, [d]
0087   0480 D8            push b
0088   0481 26 00 00      mov b, $0
0089   0484 E7            pop d
0090   0485 FD 3E         mov [d], bl
0091   0487 F9            leave
0092   0488 09            ret
0093   0489             
0094   0489             strcmp:
0095   0489 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0096   048C             ;; while (*s1 && (*s1 == *s2)) { 
0097   048C             _while2_cond:
0098   048C FA 05 00      lea d, [bp + 5] ; $s1
0099   048F 2A            mov b, [d]
0100   0490 74            mov d, b
0101   0491 32            mov bl, [d]
0102   0492 A7 00         mov bh, 0
0103   0494 D7            push a
0104   0495 11            mov a, b
0105   0496 FA 05 00      lea d, [bp + 5] ; $s1
0106   0499 2A            mov b, [d]
0107   049A 74            mov d, b
0108   049B 32            mov bl, [d]
0109   049C A7 00         mov bh, 0
0110   049E             ; START RELATIONAL
0111   049E D7            push a
0112   049F 11            mov a, b
0113   04A0 FA 07 00      lea d, [bp + 7] ; $s2
0114   04A3 2A            mov b, [d]
0115   04A4 74            mov d, b
0116   04A5 32            mov bl, [d]
0117   04A6 A7 00         mov bh, 0
0118   04A8 B0            cmp a, b
0119   04A9 FD 71         seq ; ==
0120   04AB E4            pop a
0121   04AC             ; END RELATIONAL
0122   04AC FD A7         sand a, b ; &&
0123   04AE E4            pop a
0124   04AF C0 00 00      cmp b, 0
0125   04B2 C6 D2 04      je _while2_exit
0126   04B5             _while2_block:
0127   04B5             ;; s1++; 
0128   04B5 FA 05 00      lea d, [bp + 5] ; $s1
0129   04B8 2A            mov b, [d]
0130   04B9 D8            push b
0131   04BA FD 77         inc b
0132   04BC FA 05 00      lea d, [bp + 5] ; $s1
0133   04BF FD 43         mov [d], b
0134   04C1 E5            pop b
0135   04C2             ;; s2++; 
0136   04C2 FA 07 00      lea d, [bp + 7] ; $s2
0137   04C5 2A            mov b, [d]
0138   04C6 D8            push b
0139   04C7 FD 77         inc b
0140   04C9 FA 07 00      lea d, [bp + 7] ; $s2
0141   04CC FD 43         mov [d], b
0142   04CE E5            pop b
0143   04CF 0A 8C 04      jmp _while2_cond
0144   04D2             _while2_exit:
0145   04D2             ;; return *s1 - *s2; 
0146   04D2 FA 05 00      lea d, [bp + 5] ; $s1
0147   04D5 2A            mov b, [d]
0148   04D6 74            mov d, b
0149   04D7 32            mov bl, [d]
0150   04D8 A7 00         mov bh, 0
0151   04DA             ; START TERMS
0152   04DA D7            push a
0153   04DB 11            mov a, b
0154   04DC FA 07 00      lea d, [bp + 7] ; $s2
0155   04DF 2A            mov b, [d]
0156   04E0 74            mov d, b
0157   04E1 32            mov bl, [d]
0158   04E2 A7 00         mov bh, 0
0159   04E4 60            sub a, b
0160   04E5 27            mov b, a
0161   04E6 E4            pop a
0162   04E7             ; END TERMS
0163   04E7 F9            leave
0164   04E8 09            ret
0165   04E9             
0166   04E9             strcat:
0167   04E9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0168   04EC             ; $dest_len 
0169   04EC             ; $i 
0170   04EC 52 04 00      sub sp, 4
0171   04EF             ;; dest_len = strlen(dest); 
0172   04EF FA FF FF      lea d, [bp + -1] ; $dest_len
0173   04F2 DA            push d
0174   04F3 FA 05 00      lea d, [bp + 5] ; $dest
0175   04F6 2A            mov b, [d]
0176   04F7 FD AB         swp b
0177   04F9 D8            push b
0178   04FA 07 9F 05      call strlen
0179   04FD 51 02 00      add sp, 2
0180   0500 E7            pop d
0181   0501 FD 43         mov [d], b
0182   0503             ;; for (i = 0; src[i] != 0; i=i+1) { 
0183   0503             _for3_init:
0184   0503 FA FD FF      lea d, [bp + -3] ; $i
0185   0506 DA            push d
0186   0507 26 00 00      mov b, $0
0187   050A E7            pop d
0188   050B FD 43         mov [d], b
0189   050D             _for3_cond:
0190   050D FA 07 00      lea d, [bp + 7] ; $src
0191   0510 FD 2A         mov d, [d]
0192   0512 D7            push a
0193   0513 DA            push d
0194   0514 FA FD FF      lea d, [bp + -3] ; $i
0195   0517 2A            mov b, [d]
0196   0518 E7            pop d
0197   0519 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0198   051D E4            pop a
0199   051E 32            mov bl, [d]
0200   051F A7 00         mov bh, 0
0201   0521             ; START RELATIONAL
0202   0521 D7            push a
0203   0522 11            mov a, b
0204   0523 26 00 00      mov b, $0
0205   0526 B0            cmp a, b
0206   0527 FD 72         sneq ; !=
0207   0529 E4            pop a
0208   052A             ; END RELATIONAL
0209   052A C0 00 00      cmp b, 0
0210   052D C6 78 05      je _for3_exit
0211   0530             _for3_block:
0212   0530             ;; dest[dest_len + i] = src[i]; 
0213   0530 FA 05 00      lea d, [bp + 5] ; $dest
0214   0533 FD 2A         mov d, [d]
0215   0535 D7            push a
0216   0536 DA            push d
0217   0537 FA FF FF      lea d, [bp + -1] ; $dest_len
0218   053A 2A            mov b, [d]
0219   053B             ; START TERMS
0220   053B D7            push a
0221   053C 11            mov a, b
0222   053D FA FD FF      lea d, [bp + -3] ; $i
0223   0540 2A            mov b, [d]
0224   0541 54            add a, b
0225   0542 27            mov b, a
0226   0543 E4            pop a
0227   0544             ; END TERMS
0228   0544 E7            pop d
0229   0545 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0230   0549 E4            pop a
0231   054A DA            push d
0232   054B FA 07 00      lea d, [bp + 7] ; $src
0233   054E FD 2A         mov d, [d]
0234   0550 D7            push a
0235   0551 DA            push d
0236   0552 FA FD FF      lea d, [bp + -3] ; $i
0237   0555 2A            mov b, [d]
0238   0556 E7            pop d
0239   0557 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0240   055B E4            pop a
0241   055C 32            mov bl, [d]
0242   055D A7 00         mov bh, 0
0243   055F E7            pop d
0244   0560 FD 3E         mov [d], bl
0245   0562             _for3_update:
0246   0562 FA FD FF      lea d, [bp + -3] ; $i
0247   0565 DA            push d
0248   0566 FA FD FF      lea d, [bp + -3] ; $i
0249   0569 2A            mov b, [d]
0250   056A             ; START TERMS
0251   056A D7            push a
0252   056B 11            mov a, b
0253   056C 26 01 00      mov b, $1
0254   056F 54            add a, b
0255   0570 27            mov b, a
0256   0571 E4            pop a
0257   0572             ; END TERMS
0258   0572 E7            pop d
0259   0573 FD 43         mov [d], b
0260   0575 0A 0D 05      jmp _for3_cond
0261   0578             _for3_exit:
0262   0578             ;; dest[dest_len + i] = 0; 
0263   0578 FA 05 00      lea d, [bp + 5] ; $dest
0264   057B FD 2A         mov d, [d]
0265   057D D7            push a
0266   057E DA            push d
0267   057F FA FF FF      lea d, [bp + -1] ; $dest_len
0268   0582 2A            mov b, [d]
0269   0583             ; START TERMS
0270   0583 D7            push a
0271   0584 11            mov a, b
0272   0585 FA FD FF      lea d, [bp + -3] ; $i
0273   0588 2A            mov b, [d]
0274   0589 54            add a, b
0275   058A 27            mov b, a
0276   058B E4            pop a
0277   058C             ; END TERMS
0278   058C E7            pop d
0279   058D FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0280   0591 E4            pop a
0281   0592 DA            push d
0282   0593 26 00 00      mov b, $0
0283   0596 E7            pop d
0284   0597 FD 3E         mov [d], bl
0285   0599             ;; return dest; 
0286   0599 FA 05 00      lea d, [bp + 5] ; $dest
0287   059C 2A            mov b, [d]
0288   059D F9            leave
0289   059E 09            ret
0290   059F             
0291   059F             strlen:
0292   059F F8 00 00      enter 0 ; (push bp; mov bp, sp)
0293   05A2             ; $length 
0294   05A2 52 02 00      sub sp, 2
0295   05A5             ;; length = 0; 
0296   05A5 FA FF FF      lea d, [bp + -1] ; $length
0297   05A8 DA            push d
0298   05A9 26 00 00      mov b, $0
0299   05AC E7            pop d
0300   05AD FD 43         mov [d], b
0301   05AF             ;; while (str[length] != 0) { 
0302   05AF             _while4_cond:
0303   05AF FA 05 00      lea d, [bp + 5] ; $str
0304   05B2 FD 2A         mov d, [d]
0305   05B4 D7            push a
0306   05B5 DA            push d
0307   05B6 FA FF FF      lea d, [bp + -1] ; $length
0308   05B9 2A            mov b, [d]
0309   05BA E7            pop d
0310   05BB FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0311   05BF E4            pop a
0312   05C0 32            mov bl, [d]
0313   05C1 A7 00         mov bh, 0
0314   05C3             ; START RELATIONAL
0315   05C3 D7            push a
0316   05C4 11            mov a, b
0317   05C5 26 00 00      mov b, $0
0318   05C8 B0            cmp a, b
0319   05C9 FD 72         sneq ; !=
0320   05CB E4            pop a
0321   05CC             ; END RELATIONAL
0322   05CC C0 00 00      cmp b, 0
0323   05CF C6 E2 05      je _while4_exit
0324   05D2             _while4_block:
0325   05D2             ;; length++; 
0326   05D2 FA FF FF      lea d, [bp + -1] ; $length
0327   05D5 2A            mov b, [d]
0328   05D6 D8            push b
0329   05D7 FD 77         inc b
0330   05D9 FA FF FF      lea d, [bp + -1] ; $length
0331   05DC FD 43         mov [d], b
0332   05DE E5            pop b
0333   05DF 0A AF 05      jmp _while4_cond
0334   05E2             _while4_exit:
0335   05E2             ;; return length; 
0336   05E2 FA FF FF      lea d, [bp + -1] ; $length
0337   05E5 2A            mov b, [d]
0338   05E6 F9            leave
0339   05E7 09            ret
0340   05E8             
0341   05E8             printf:
0342   05E8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0343   05EB             ; $p 
0344   05EB             ; $fp 
0345   05EB             ; $i 
0346   05EB 52 06 00      sub sp, 6
0347   05EE             ;; fp = format; 
0348   05EE FA FD FF      lea d, [bp + -3] ; $fp
0349   05F1 DA            push d
0350   05F2 FA 05 00      lea d, [bp + 5] ; $format
0351   05F5 2A            mov b, [d]
0352   05F6 E7            pop d
0353   05F7 FD 43         mov [d], b
0354   05F9             ;; p = &format + 2; 
0355   05F9 FA FF FF      lea d, [bp + -1] ; $p
0356   05FC DA            push d
0357   05FD FA 05 00      lea d, [bp + 5] ; $format
0358   0600 2D            mov b, d
0359   0601             ; START TERMS
0360   0601 D7            push a
0361   0602 11            mov a, b
0362   0603 26 02 00      mov b, $2
0363   0606 54            add a, b
0364   0607 27            mov b, a
0365   0608 E4            pop a
0366   0609             ; END TERMS
0367   0609 E7            pop d
0368   060A FD 43         mov [d], b
0369   060C             ;; for(;;){ 
0370   060C             _for5_init:
0371   060C             _for5_cond:
0372   060C             _for5_block:
0373   060C             ;; if(!*fp) break; 
0374   060C             _if6_cond:
0375   060C FA FD FF      lea d, [bp + -3] ; $fp
0376   060F 2A            mov b, [d]
0377   0610 74            mov d, b
0378   0611 32            mov bl, [d]
0379   0612 A7 00         mov bh, 0
0380   0614 C0 00 00      cmp b, 0
0381   0617 FD 71         seq ; !
0382   0619 C0 00 00      cmp b, 0
0383   061C C6 25 06      je _if6_else
0384   061F             _if6_true:
0385   061F             ;; break; 
0386   061F 0A 33 08      jmp _for5_exit ; for break
0387   0622 0A 30 08      jmp _if6_exit
0388   0625             _if6_else:
0389   0625             ;; if(*fp == '%'){ 
0390   0625             _if7_cond:
0391   0625 FA FD FF      lea d, [bp + -3] ; $fp
0392   0628 2A            mov b, [d]
0393   0629 74            mov d, b
0394   062A 32            mov bl, [d]
0395   062B A7 00         mov bh, 0
0396   062D             ; START RELATIONAL
0397   062D D7            push a
0398   062E 11            mov a, b
0399   062F 26 25 00      mov b, $25
0400   0632 B0            cmp a, b
0401   0633 FD 71         seq ; ==
0402   0635 E4            pop a
0403   0636             ; END RELATIONAL
0404   0636 C0 00 00      cmp b, 0
0405   0639 C6 14 08      je _if7_else
0406   063C             _if7_true:
0407   063C             ;; fp++; 
0408   063C FA FD FF      lea d, [bp + -3] ; $fp
0409   063F 2A            mov b, [d]
0410   0640 D8            push b
0411   0641 FD 77         inc b
0412   0643 FA FD FF      lea d, [bp + -3] ; $fp
0413   0646 FD 43         mov [d], b
0414   0648 E5            pop b
0415   0649             ;; switch(*fp){ 
0416   0649             _switch8_expr:
0417   0649 FA FD FF      lea d, [bp + -3] ; $fp
0418   064C 2A            mov b, [d]
0419   064D 74            mov d, b
0420   064E 32            mov bl, [d]
0421   064F A7 00         mov bh, 0
0422   0651             _switch8_comparisons:
0423   0651 C1 6C         cmp bl, $6c
0424   0653 C6 7F 06      je _switch8_case0
0425   0656 C1 4C         cmp bl, $4c
0426   0658 C6 7F 06      je _switch8_case1
0427   065B C1 64         cmp bl, $64
0428   065D C6 3F 07      je _switch8_case2
0429   0660 C1 69         cmp bl, $69
0430   0662 C6 3F 07      je _switch8_case3
0431   0665 C1 75         cmp bl, $75
0432   0667 C6 64 07      je _switch8_case4
0433   066A C1 78         cmp bl, $78
0434   066C C6 89 07      je _switch8_case5
0435   066F C1 63         cmp bl, $63
0436   0671 C6 AE 07      je _switch8_case6
0437   0674 C1 73         cmp bl, $73
0438   0676 C6 D3 07      je _switch8_case7
0439   0679 0A F8 07      jmp _switch8_default
0440   067C 0A 04 08      jmp _switch8_exit
0441   067F             _switch8_case0:
0442   067F             _switch8_case1:
0443   067F             ;; fp++; 
0444   067F FA FD FF      lea d, [bp + -3] ; $fp
0445   0682 2A            mov b, [d]
0446   0683 D8            push b
0447   0684 FD 77         inc b
0448   0686 FA FD FF      lea d, [bp + -3] ; $fp
0449   0689 FD 43         mov [d], b
0450   068B E5            pop b
0451   068C             ;; if(*fp == 'd' || *fp == 'i'){ 
0452   068C             _if9_cond:
0453   068C FA FD FF      lea d, [bp + -3] ; $fp
0454   068F 2A            mov b, [d]
0455   0690 74            mov d, b
0456   0691 32            mov bl, [d]
0457   0692 A7 00         mov bh, 0
0458   0694             ; START RELATIONAL
0459   0694 D7            push a
0460   0695 11            mov a, b
0461   0696 26 64 00      mov b, $64
0462   0699 B0            cmp a, b
0463   069A FD 71         seq ; ==
0464   069C E4            pop a
0465   069D             ; END RELATIONAL
0466   069D D7            push a
0467   069E 11            mov a, b
0468   069F FA FD FF      lea d, [bp + -3] ; $fp
0469   06A2 2A            mov b, [d]
0470   06A3 74            mov d, b
0471   06A4 32            mov bl, [d]
0472   06A5 A7 00         mov bh, 0
0473   06A7             ; START RELATIONAL
0474   06A7 D7            push a
0475   06A8 11            mov a, b
0476   06A9 26 69 00      mov b, $69
0477   06AC B0            cmp a, b
0478   06AD FD 71         seq ; ==
0479   06AF E4            pop a
0480   06B0             ; END RELATIONAL
0481   06B0 FD A8         sor a, b ; ||
0482   06B2 E4            pop a
0483   06B3 C0 00 00      cmp b, 0
0484   06B6 C6 E9 06      je _if9_else
0485   06B9             _if9_true:
0486   06B9             ;; print_signed_long(*(long *)p); 
0487   06B9 FA FF FF      lea d, [bp + -1] ; $p
0488   06BC 2A            mov b, [d]
0489   06BD 74            mov d, b
0490   06BE 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0491   06C1 FD 39         mov c, b ; And place it into C
0492   06C3 2A            mov b, [d] ; Lower Word in B
0493   06C4 FD 79         mov g, b
0494   06C6 28            mov b, c
0495   06C7 FD AB         swp b
0496   06C9 D8            push b
0497   06CA FD 27         mov b, g
0498   06CC D8            push b
0499   06CD 07 D7 0B      call print_signed_long
0500   06D0 51 04 00      add sp, 4
0501   06D3             ;; p = p + 4; 
0502   06D3 FA FF FF      lea d, [bp + -1] ; $p
0503   06D6 DA            push d
0504   06D7 FA FF FF      lea d, [bp + -1] ; $p
0505   06DA 2A            mov b, [d]
0506   06DB             ; START TERMS
0507   06DB D7            push a
0508   06DC 11            mov a, b
0509   06DD 26 04 00      mov b, $4
0510   06E0 54            add a, b
0511   06E1 27            mov b, a
0512   06E2 E4            pop a
0513   06E3             ; END TERMS
0514   06E3 E7            pop d
0515   06E4 FD 43         mov [d], b
0516   06E6 0A 3C 07      jmp _if9_exit
0517   06E9             _if9_else:
0518   06E9             ;; if(*fp == 'u'){ 
0519   06E9             _if10_cond:
0520   06E9 FA FD FF      lea d, [bp + -3] ; $fp
0521   06EC 2A            mov b, [d]
0522   06ED 74            mov d, b
0523   06EE 32            mov bl, [d]
0524   06EF A7 00         mov bh, 0
0525   06F1             ; START RELATIONAL
0526   06F1 D7            push a
0527   06F2 11            mov a, b
0528   06F3 26 75 00      mov b, $75
0529   06F6 B0            cmp a, b
0530   06F7 FD 71         seq ; ==
0531   06F9 E4            pop a
0532   06FA             ; END RELATIONAL
0533   06FA C0 00 00      cmp b, 0
0534   06FD C6 30 07      je _if10_else
0535   0700             _if10_true:
0536   0700             ;; print_unsigned_long(*(unsigned long *)p); 
0537   0700 FA FF FF      lea d, [bp + -1] ; $p
0538   0703 2A            mov b, [d]
0539   0704 74            mov d, b
0540   0705 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0541   0708 FD 39         mov c, b ; And place it into C
0542   070A 2A            mov b, [d] ; Lower Word in B
0543   070B FD 79         mov g, b
0544   070D 28            mov b, c
0545   070E FD AB         swp b
0546   0710 D8            push b
0547   0711 FD 27         mov b, g
0548   0713 D8            push b
0549   0714 07 C8 0C      call print_unsigned_long
0550   0717 51 04 00      add sp, 4
0551   071A             ;; p = p + 4; 
0552   071A FA FF FF      lea d, [bp + -1] ; $p
0553   071D DA            push d
0554   071E FA FF FF      lea d, [bp + -1] ; $p
0555   0721 2A            mov b, [d]
0556   0722             ; START TERMS
0557   0722 D7            push a
0558   0723 11            mov a, b
0559   0724 26 04 00      mov b, $4
0560   0727 54            add a, b
0561   0728 27            mov b, a
0562   0729 E4            pop a
0563   072A             ; END TERMS
0564   072A E7            pop d
0565   072B FD 43         mov [d], b
0566   072D 0A 3C 07      jmp _if10_exit
0567   0730             _if10_else:
0568   0730             ;; err("Unexpected format in printf."); 
0569   0730 26 FE 13      mov b, __s0 ; "Unexpected format in printf."
0570   0733 FD AB         swp b
0571   0735 D8            push b
0572   0736 07 35 08      call err
0573   0739 51 02 00      add sp, 2
0574   073C             _if10_exit:
0575   073C             _if9_exit:
0576   073C             ;; break; 
0577   073C 0A 04 08      jmp _switch8_exit ; case break
0578   073F             _switch8_case2:
0579   073F             _switch8_case3:
0580   073F             ;; print_signed(*(int*)p); 
0581   073F FA FF FF      lea d, [bp + -1] ; $p
0582   0742 2A            mov b, [d]
0583   0743 74            mov d, b
0584   0744 2A            mov b, [d]
0585   0745 FD AB         swp b
0586   0747 D8            push b
0587   0748 07 E6 0A      call print_signed
0588   074B 51 02 00      add sp, 2
0589   074E             ;; p = p + 2; 
0590   074E FA FF FF      lea d, [bp + -1] ; $p
0591   0751 DA            push d
0592   0752 FA FF FF      lea d, [bp + -1] ; $p
0593   0755 2A            mov b, [d]
0594   0756             ; START TERMS
0595   0756 D7            push a
0596   0757 11            mov a, b
0597   0758 26 02 00      mov b, $2
0598   075B 54            add a, b
0599   075C 27            mov b, a
0600   075D E4            pop a
0601   075E             ; END TERMS
0602   075E E7            pop d
0603   075F FD 43         mov [d], b
0604   0761             ;; break; 
0605   0761 0A 04 08      jmp _switch8_exit ; case break
0606   0764             _switch8_case4:
0607   0764             ;; print_unsigned(*(unsigned int*)p); 
0608   0764 FA FF FF      lea d, [bp + -1] ; $p
0609   0767 2A            mov b, [d]
0610   0768 74            mov d, b
0611   0769 2A            mov b, [d]
0612   076A FD AB         swp b
0613   076C D8            push b
0614   076D 07 90 0D      call print_unsigned
0615   0770 51 02 00      add sp, 2
0616   0773             ;; p = p + 2; 
0617   0773 FA FF FF      lea d, [bp + -1] ; $p
0618   0776 DA            push d
0619   0777 FA FF FF      lea d, [bp + -1] ; $p
0620   077A 2A            mov b, [d]
0621   077B             ; START TERMS
0622   077B D7            push a
0623   077C 11            mov a, b
0624   077D 26 02 00      mov b, $2
0625   0780 54            add a, b
0626   0781 27            mov b, a
0627   0782 E4            pop a
0628   0783             ; END TERMS
0629   0783 E7            pop d
0630   0784 FD 43         mov [d], b
0631   0786             ;; break; 
0632   0786 0A 04 08      jmp _switch8_exit ; case break
0633   0789             _switch8_case5:
0634   0789             ;; printx16(*(unsigned int*)p); 
0635   0789 FA FF FF      lea d, [bp + -1] ; $p
0636   078C 2A            mov b, [d]
0637   078D 74            mov d, b
0638   078E 2A            mov b, [d]
0639   078F FD AB         swp b
0640   0791 D8            push b
0641   0792 07 5C 08      call printx16
0642   0795 51 02 00      add sp, 2
0643   0798             ;; p = p + 2; 
0644   0798 FA FF FF      lea d, [bp + -1] ; $p
0645   079B DA            push d
0646   079C FA FF FF      lea d, [bp + -1] ; $p
0647   079F 2A            mov b, [d]
0648   07A0             ; START TERMS
0649   07A0 D7            push a
0650   07A1 11            mov a, b
0651   07A2 26 02 00      mov b, $2
0652   07A5 54            add a, b
0653   07A6 27            mov b, a
0654   07A7 E4            pop a
0655   07A8             ; END TERMS
0656   07A8 E7            pop d
0657   07A9 FD 43         mov [d], b
0658   07AB             ;; break; 
0659   07AB 0A 04 08      jmp _switch8_exit ; case break
0660   07AE             _switch8_case6:
0661   07AE             ;; putchar(*(char*)p); 
0662   07AE FA FF FF      lea d, [bp + -1] ; $p
0663   07B1 2A            mov b, [d]
0664   07B2 74            mov d, b
0665   07B3 32            mov bl, [d]
0666   07B4 A7 00         mov bh, 0
0667   07B6 DD            push bl
0668   07B7 07 78 0E      call putchar
0669   07BA 51 01 00      add sp, 1
0670   07BD             ;; p = p + 2; 
0671   07BD FA FF FF      lea d, [bp + -1] ; $p
0672   07C0 DA            push d
0673   07C1 FA FF FF      lea d, [bp + -1] ; $p
0674   07C4 2A            mov b, [d]
0675   07C5             ; START TERMS
0676   07C5 D7            push a
0677   07C6 11            mov a, b
0678   07C7 26 02 00      mov b, $2
0679   07CA 54            add a, b
0680   07CB 27            mov b, a
0681   07CC E4            pop a
0682   07CD             ; END TERMS
0683   07CD E7            pop d
0684   07CE FD 43         mov [d], b
0685   07D0             ;; break; 
0686   07D0 0A 04 08      jmp _switch8_exit ; case break
0687   07D3             _switch8_case7:
0688   07D3             ;; print(*(char**)p); 
0689   07D3 FA FF FF      lea d, [bp + -1] ; $p
0690   07D6 2A            mov b, [d]
0691   07D7 74            mov d, b
0692   07D8 2A            mov b, [d]
0693   07D9 FD AB         swp b
0694   07DB D8            push b
0695   07DC 07 C0 0E      call print
0696   07DF 51 02 00      add sp, 2
0697   07E2             ;; p = p + 2; 
0698   07E2 FA FF FF      lea d, [bp + -1] ; $p
0699   07E5 DA            push d
0700   07E6 FA FF FF      lea d, [bp + -1] ; $p
0701   07E9 2A            mov b, [d]
0702   07EA             ; START TERMS
0703   07EA D7            push a
0704   07EB 11            mov a, b
0705   07EC 26 02 00      mov b, $2
0706   07EF 54            add a, b
0707   07F0 27            mov b, a
0708   07F1 E4            pop a
0709   07F2             ; END TERMS
0710   07F2 E7            pop d
0711   07F3 FD 43         mov [d], b
0712   07F5             ;; break; 
0713   07F5 0A 04 08      jmp _switch8_exit ; case break
0714   07F8             _switch8_default:
0715   07F8             ;; print("Error: Unknown argument type.\n"); 
0716   07F8 26 1B 14      mov b, __s1 ; "Error: Unknown argument type.\n"
0717   07FB FD AB         swp b
0718   07FD D8            push b
0719   07FE 07 C0 0E      call print
0720   0801 51 02 00      add sp, 2
0721   0804             _switch8_exit:
0722   0804             ;; fp++; 
0723   0804 FA FD FF      lea d, [bp + -3] ; $fp
0724   0807 2A            mov b, [d]
0725   0808 D8            push b
0726   0809 FD 77         inc b
0727   080B FA FD FF      lea d, [bp + -3] ; $fp
0728   080E FD 43         mov [d], b
0729   0810 E5            pop b
0730   0811 0A 30 08      jmp _if7_exit
0731   0814             _if7_else:
0732   0814             ;; putchar(*fp); 
0733   0814 FA FD FF      lea d, [bp + -3] ; $fp
0734   0817 2A            mov b, [d]
0735   0818 74            mov d, b
0736   0819 32            mov bl, [d]
0737   081A A7 00         mov bh, 0
0738   081C DD            push bl
0739   081D 07 78 0E      call putchar
0740   0820 51 01 00      add sp, 1
0741   0823             ;; fp++; 
0742   0823 FA FD FF      lea d, [bp + -3] ; $fp
0743   0826 2A            mov b, [d]
0744   0827 D8            push b
0745   0828 FD 77         inc b
0746   082A FA FD FF      lea d, [bp + -3] ; $fp
0747   082D FD 43         mov [d], b
0748   082F E5            pop b
0749   0830             _if7_exit:
0750   0830             _if6_exit:
0751   0830             _for5_update:
0752   0830 0A 0C 06      jmp _for5_cond
0753   0833             _for5_exit:
0754   0833 F9            leave
0755   0834 09            ret
0756   0835             
0757   0835             err:
0758   0835 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0759   0838             ;; print(e); 
0760   0838 FA 05 00      lea d, [bp + 5] ; $e
0761   083B 2A            mov b, [d]
0762   083C FD AB         swp b
0763   083E D8            push b
0764   083F 07 C0 0E      call print
0765   0842 51 02 00      add sp, 2
0766   0845             ;; exit(); 
0767   0845 07 3A 0F      call exit
0768   0848 F9            leave
0769   0849 09            ret
0770   084A             
0771   084A             printx32:
0772   084A F8 00 00      enter 0 ; (push bp; mov bp, sp)
0773   084D             
0774   084D             ; --- BEGIN INLINE ASM BLOCK
0775   084D FA 05 00      lea d, [bp + 5] ; $hex
0776   0850 2B 02 00      mov b, [d+2]
0777   0853 07 97 12      call print_u16x
0778   0856 2A            mov b, [d]
0779   0857 07 97 12      call print_u16x
0780   085A             ; --- END INLINE ASM BLOCK
0781   085A             
0782   085A F9            leave
0783   085B 09            ret
0784   085C             
0785   085C             printx16:
0786   085C F8 00 00      enter 0 ; (push bp; mov bp, sp)
0787   085F             
0788   085F             ; --- BEGIN INLINE ASM BLOCK
0789   085F FA 05 00      lea d, [bp + 5] ; $hex
0790   0862 2A            mov b, [d]
0791   0863 07 97 12      call print_u16x
0792   0866             ; --- END INLINE ASM BLOCK
0793   0866             
0794   0866 F9            leave
0795   0867 09            ret
0796   0868             
0797   0868             printx8:
0798   0868 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0799   086B             
0800   086B             ; --- BEGIN INLINE ASM BLOCK
0801   086B FA 05 00      lea d, [bp + 5] ; $hex
0802   086E 32            mov bl, [d]
0803   086F 07 DB 12      call print_u8x
0804   0872             ; --- END INLINE ASM BLOCK
0805   0872             
0806   0872 F9            leave
0807   0873 09            ret
0808   0874             
0809   0874             hex_to_int:
0810   0874 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0811   0877             ; $value 
0812   0877 10 00 00      mov a, $0
0813   087A 45 FF FF      mov [bp + -1], a
0814   087D             ; $i 
0815   087D             ; $hex_char 
0816   087D             ; $len 
0817   087D 52 07 00      sub sp, 7
0818   0880             ;; len = strlen(hex_string); 
0819   0880 FA FA FF      lea d, [bp + -6] ; $len
0820   0883 DA            push d
0821   0884 FA 05 00      lea d, [bp + 5] ; $hex_string
0822   0887 2A            mov b, [d]
0823   0888 FD AB         swp b
0824   088A D8            push b
0825   088B 07 9F 05      call strlen
0826   088E 51 02 00      add sp, 2
0827   0891 E7            pop d
0828   0892 FD 43         mov [d], b
0829   0894             ;; for (i = 0; i < len; i++) { 
0830   0894             _for11_init:
0831   0894 FA FD FF      lea d, [bp + -3] ; $i
0832   0897 DA            push d
0833   0898 26 00 00      mov b, $0
0834   089B E7            pop d
0835   089C FD 43         mov [d], b
0836   089E             _for11_cond:
0837   089E FA FD FF      lea d, [bp + -3] ; $i
0838   08A1 2A            mov b, [d]
0839   08A2             ; START RELATIONAL
0840   08A2 D7            push a
0841   08A3 11            mov a, b
0842   08A4 FA FA FF      lea d, [bp + -6] ; $len
0843   08A7 2A            mov b, [d]
0844   08A8 B0            cmp a, b
0845   08A9 FD 73         slt ; < 
0846   08AB E4            pop a
0847   08AC             ; END RELATIONAL
0848   08AC C0 00 00      cmp b, 0
0849   08AF C6 B4 09      je _for11_exit
0850   08B2             _for11_block:
0851   08B2             ;; hex_char = hex_string[i]; 
0852   08B2 FA FC FF      lea d, [bp + -4] ; $hex_char
0853   08B5 DA            push d
0854   08B6 FA 05 00      lea d, [bp + 5] ; $hex_string
0855   08B9 FD 2A         mov d, [d]
0856   08BB D7            push a
0857   08BC DA            push d
0858   08BD FA FD FF      lea d, [bp + -3] ; $i
0859   08C0 2A            mov b, [d]
0860   08C1 E7            pop d
0861   08C2 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0862   08C6 E4            pop a
0863   08C7 32            mov bl, [d]
0864   08C8 A7 00         mov bh, 0
0865   08CA E7            pop d
0866   08CB FD 3E         mov [d], bl
0867   08CD             ;; if (hex_char >= 'a' && hex_char <= 'f')  
0868   08CD             _if12_cond:
0869   08CD FA FC FF      lea d, [bp + -4] ; $hex_char
0870   08D0 32            mov bl, [d]
0871   08D1 A7 00         mov bh, 0
0872   08D3             ; START RELATIONAL
0873   08D3 D7            push a
0874   08D4 11            mov a, b
0875   08D5 26 61 00      mov b, $61
0876   08D8 B0            cmp a, b
0877   08D9 FD 80         sge ; >=
0878   08DB E4            pop a
0879   08DC             ; END RELATIONAL
0880   08DC D7            push a
0881   08DD 11            mov a, b
0882   08DE FA FC FF      lea d, [bp + -4] ; $hex_char
0883   08E1 32            mov bl, [d]
0884   08E2 A7 00         mov bh, 0
0885   08E4             ; START RELATIONAL
0886   08E4 D7            push a
0887   08E5 11            mov a, b
0888   08E6 26 66 00      mov b, $66
0889   08E9 B0            cmp a, b
0890   08EA FD 74         sle ; <=
0891   08EC E4            pop a
0892   08ED             ; END RELATIONAL
0893   08ED FD A7         sand a, b ; &&
0894   08EF E4            pop a
0895   08F0 C0 00 00      cmp b, 0
0896   08F3 C6 25 09      je _if12_else
0897   08F6             _if12_true:
0898   08F6             ;; value = (value * 16) + (hex_char - 'a' + 10); 
0899   08F6 FA FF FF      lea d, [bp + -1] ; $value
0900   08F9 DA            push d
0901   08FA FA FF FF      lea d, [bp + -1] ; $value
0902   08FD 2A            mov b, [d]
0903   08FE             ; START FACTORS
0904   08FE D7            push a
0905   08FF 11            mov a, b
0906   0900 26 10 00      mov b, $10
0907   0903 AC            mul a, b ; *
0908   0904 11            mov a, b
0909   0905 27            mov b, a
0910   0906 E4            pop a
0911   0907             ; END FACTORS
0912   0907             ; START TERMS
0913   0907 D7            push a
0914   0908 11            mov a, b
0915   0909 FA FC FF      lea d, [bp + -4] ; $hex_char
0916   090C 32            mov bl, [d]
0917   090D A7 00         mov bh, 0
0918   090F             ; START TERMS
0919   090F D7            push a
0920   0910 11            mov a, b
0921   0911 26 61 00      mov b, $61
0922   0914 60            sub a, b
0923   0915 11            mov a, b
0924   0916 26 0A 00      mov b, $a
0925   0919 54            add a, b
0926   091A 27            mov b, a
0927   091B E4            pop a
0928   091C             ; END TERMS
0929   091C 54            add a, b
0930   091D 27            mov b, a
0931   091E E4            pop a
0932   091F             ; END TERMS
0933   091F E7            pop d
0934   0920 FD 43         mov [d], b
0935   0922 0A A4 09      jmp _if12_exit
0936   0925             _if12_else:
0937   0925             ;; if (hex_char >= 'A' && hex_char <= 'F')  
0938   0925             _if13_cond:
0939   0925 FA FC FF      lea d, [bp + -4] ; $hex_char
0940   0928 32            mov bl, [d]
0941   0929 A7 00         mov bh, 0
0942   092B             ; START RELATIONAL
0943   092B D7            push a
0944   092C 11            mov a, b
0945   092D 26 41 00      mov b, $41
0946   0930 B0            cmp a, b
0947   0931 FD 80         sge ; >=
0948   0933 E4            pop a
0949   0934             ; END RELATIONAL
0950   0934 D7            push a
0951   0935 11            mov a, b
0952   0936 FA FC FF      lea d, [bp + -4] ; $hex_char
0953   0939 32            mov bl, [d]
0954   093A A7 00         mov bh, 0
0955   093C             ; START RELATIONAL
0956   093C D7            push a
0957   093D 11            mov a, b
0958   093E 26 46 00      mov b, $46
0959   0941 B0            cmp a, b
0960   0942 FD 74         sle ; <=
0961   0944 E4            pop a
0962   0945             ; END RELATIONAL
0963   0945 FD A7         sand a, b ; &&
0964   0947 E4            pop a
0965   0948 C0 00 00      cmp b, 0
0966   094B C6 7D 09      je _if13_else
0967   094E             _if13_true:
0968   094E             ;; value = (value * 16) + (hex_char - 'A' + 10); 
0969   094E FA FF FF      lea d, [bp + -1] ; $value
0970   0951 DA            push d
0971   0952 FA FF FF      lea d, [bp + -1] ; $value
0972   0955 2A            mov b, [d]
0973   0956             ; START FACTORS
0974   0956 D7            push a
0975   0957 11            mov a, b
0976   0958 26 10 00      mov b, $10
0977   095B AC            mul a, b ; *
0978   095C 11            mov a, b
0979   095D 27            mov b, a
0980   095E E4            pop a
0981   095F             ; END FACTORS
0982   095F             ; START TERMS
0983   095F D7            push a
0984   0960 11            mov a, b
0985   0961 FA FC FF      lea d, [bp + -4] ; $hex_char
0986   0964 32            mov bl, [d]
0987   0965 A7 00         mov bh, 0
0988   0967             ; START TERMS
0989   0967 D7            push a
0990   0968 11            mov a, b
0991   0969 26 41 00      mov b, $41
0992   096C 60            sub a, b
0993   096D 11            mov a, b
0994   096E 26 0A 00      mov b, $a
0995   0971 54            add a, b
0996   0972 27            mov b, a
0997   0973 E4            pop a
0998   0974             ; END TERMS
0999   0974 54            add a, b
1000   0975 27            mov b, a
1001   0976 E4            pop a
1002   0977             ; END TERMS
1003   0977 E7            pop d
1004   0978 FD 43         mov [d], b
1005   097A 0A A4 09      jmp _if13_exit
1006   097D             _if13_else:
1007   097D             ;; value = (value * 16) + (hex_char - '0'); 
1008   097D FA FF FF      lea d, [bp + -1] ; $value
1009   0980 DA            push d
1010   0981 FA FF FF      lea d, [bp + -1] ; $value
1011   0984 2A            mov b, [d]
1012   0985             ; START FACTORS
1013   0985 D7            push a
1014   0986 11            mov a, b
1015   0987 26 10 00      mov b, $10
1016   098A AC            mul a, b ; *
1017   098B 11            mov a, b
1018   098C 27            mov b, a
1019   098D E4            pop a
1020   098E             ; END FACTORS
1021   098E             ; START TERMS
1022   098E D7            push a
1023   098F 11            mov a, b
1024   0990 FA FC FF      lea d, [bp + -4] ; $hex_char
1025   0993 32            mov bl, [d]
1026   0994 A7 00         mov bh, 0
1027   0996             ; START TERMS
1028   0996 D7            push a
1029   0997 11            mov a, b
1030   0998 26 30 00      mov b, $30
1031   099B 60            sub a, b
1032   099C 27            mov b, a
1033   099D E4            pop a
1034   099E             ; END TERMS
1035   099E 54            add a, b
1036   099F 27            mov b, a
1037   09A0 E4            pop a
1038   09A1             ; END TERMS
1039   09A1 E7            pop d
1040   09A2 FD 43         mov [d], b
1041   09A4             _if13_exit:
1042   09A4             _if12_exit:
1043   09A4             _for11_update:
1044   09A4 FA FD FF      lea d, [bp + -3] ; $i
1045   09A7 2A            mov b, [d]
1046   09A8 D8            push b
1047   09A9 FD 77         inc b
1048   09AB FA FD FF      lea d, [bp + -3] ; $i
1049   09AE FD 43         mov [d], b
1050   09B0 E5            pop b
1051   09B1 0A 9E 08      jmp _for11_cond
1052   09B4             _for11_exit:
1053   09B4             ;; return value; 
1054   09B4 FA FF FF      lea d, [bp + -1] ; $value
1055   09B7 2A            mov b, [d]
1056   09B8 F9            leave
1057   09B9 09            ret
1058   09BA             
1059   09BA             atoi:
1060   09BA F8 00 00      enter 0 ; (push bp; mov bp, sp)
1061   09BD             ; $result 
1062   09BD 10 00 00      mov a, $0
1063   09C0 45 FF FF      mov [bp + -1], a
1064   09C3             ; $sign 
1065   09C3 10 01 00      mov a, $1
1066   09C6 45 FD FF      mov [bp + -3], a
1067   09C9 52 04 00      sub sp, 4
1068   09CC             ;; while (*str == ' ') str++; 
1069   09CC             _while14_cond:
1070   09CC FA 05 00      lea d, [bp + 5] ; $str
1071   09CF 2A            mov b, [d]
1072   09D0 74            mov d, b
1073   09D1 32            mov bl, [d]
1074   09D2 A7 00         mov bh, 0
1075   09D4             ; START RELATIONAL
1076   09D4 D7            push a
1077   09D5 11            mov a, b
1078   09D6 26 20 00      mov b, $20
1079   09D9 B0            cmp a, b
1080   09DA FD 71         seq ; ==
1081   09DC E4            pop a
1082   09DD             ; END RELATIONAL
1083   09DD C0 00 00      cmp b, 0
1084   09E0 C6 F3 09      je _while14_exit
1085   09E3             _while14_block:
1086   09E3             ;; str++; 
1087   09E3 FA 05 00      lea d, [bp + 5] ; $str
1088   09E6 2A            mov b, [d]
1089   09E7 D8            push b
1090   09E8 FD 77         inc b
1091   09EA FA 05 00      lea d, [bp + 5] ; $str
1092   09ED FD 43         mov [d], b
1093   09EF E5            pop b
1094   09F0 0A CC 09      jmp _while14_cond
1095   09F3             _while14_exit:
1096   09F3             ;; if (*str == '-' || *str == '+') { 
1097   09F3             _if15_cond:
1098   09F3 FA 05 00      lea d, [bp + 5] ; $str
1099   09F6 2A            mov b, [d]
1100   09F7 74            mov d, b
1101   09F8 32            mov bl, [d]
1102   09F9 A7 00         mov bh, 0
1103   09FB             ; START RELATIONAL
1104   09FB D7            push a
1105   09FC 11            mov a, b
1106   09FD 26 2D 00      mov b, $2d
1107   0A00 B0            cmp a, b
1108   0A01 FD 71         seq ; ==
1109   0A03 E4            pop a
1110   0A04             ; END RELATIONAL
1111   0A04 D7            push a
1112   0A05 11            mov a, b
1113   0A06 FA 05 00      lea d, [bp + 5] ; $str
1114   0A09 2A            mov b, [d]
1115   0A0A 74            mov d, b
1116   0A0B 32            mov bl, [d]
1117   0A0C A7 00         mov bh, 0
1118   0A0E             ; START RELATIONAL
1119   0A0E D7            push a
1120   0A0F 11            mov a, b
1121   0A10 26 2B 00      mov b, $2b
1122   0A13 B0            cmp a, b
1123   0A14 FD 71         seq ; ==
1124   0A16 E4            pop a
1125   0A17             ; END RELATIONAL
1126   0A17 FD A8         sor a, b ; ||
1127   0A19 E4            pop a
1128   0A1A C0 00 00      cmp b, 0
1129   0A1D C6 56 0A      je _if15_exit
1130   0A20             _if15_true:
1131   0A20             ;; if (*str == '-') sign = -1; 
1132   0A20             _if16_cond:
1133   0A20 FA 05 00      lea d, [bp + 5] ; $str
1134   0A23 2A            mov b, [d]
1135   0A24 74            mov d, b
1136   0A25 32            mov bl, [d]
1137   0A26 A7 00         mov bh, 0
1138   0A28             ; START RELATIONAL
1139   0A28 D7            push a
1140   0A29 11            mov a, b
1141   0A2A 26 2D 00      mov b, $2d
1142   0A2D B0            cmp a, b
1143   0A2E FD 71         seq ; ==
1144   0A30 E4            pop a
1145   0A31             ; END RELATIONAL
1146   0A31 C0 00 00      cmp b, 0
1147   0A34 C6 46 0A      je _if16_exit
1148   0A37             _if16_true:
1149   0A37             ;; sign = -1; 
1150   0A37 FA FD FF      lea d, [bp + -3] ; $sign
1151   0A3A DA            push d
1152   0A3B 26 01 00      mov b, $1
1153   0A3E FD 97         neg b
1154   0A40 E7            pop d
1155   0A41 FD 43         mov [d], b
1156   0A43 0A 46 0A      jmp _if16_exit
1157   0A46             _if16_exit:
1158   0A46             ;; str++; 
1159   0A46 FA 05 00      lea d, [bp + 5] ; $str
1160   0A49 2A            mov b, [d]
1161   0A4A D8            push b
1162   0A4B FD 77         inc b
1163   0A4D FA 05 00      lea d, [bp + 5] ; $str
1164   0A50 FD 43         mov [d], b
1165   0A52 E5            pop b
1166   0A53 0A 56 0A      jmp _if15_exit
1167   0A56             _if15_exit:
1168   0A56             ;; while (*str >= '0' && *str <= '9') { 
1169   0A56             _while17_cond:
1170   0A56 FA 05 00      lea d, [bp + 5] ; $str
1171   0A59 2A            mov b, [d]
1172   0A5A 74            mov d, b
1173   0A5B 32            mov bl, [d]
1174   0A5C A7 00         mov bh, 0
1175   0A5E             ; START RELATIONAL
1176   0A5E D7            push a
1177   0A5F 11            mov a, b
1178   0A60 26 30 00      mov b, $30
1179   0A63 B0            cmp a, b
1180   0A64 FD 82         sgeu ; >= (unsigned)
1181   0A66 E4            pop a
1182   0A67             ; END RELATIONAL
1183   0A67 D7            push a
1184   0A68 11            mov a, b
1185   0A69 FA 05 00      lea d, [bp + 5] ; $str
1186   0A6C 2A            mov b, [d]
1187   0A6D 74            mov d, b
1188   0A6E 32            mov bl, [d]
1189   0A6F A7 00         mov bh, 0
1190   0A71             ; START RELATIONAL
1191   0A71 D7            push a
1192   0A72 11            mov a, b
1193   0A73 26 39 00      mov b, $39
1194   0A76 B0            cmp a, b
1195   0A77 FD 76         sleu ; <= (unsigned)
1196   0A79 E4            pop a
1197   0A7A             ; END RELATIONAL
1198   0A7A FD A7         sand a, b ; &&
1199   0A7C E4            pop a
1200   0A7D C0 00 00      cmp b, 0
1201   0A80 C6 BC 0A      je _while17_exit
1202   0A83             _while17_block:
1203   0A83             ;; result = result * 10 + (*str - '0'); 
1204   0A83 FA FF FF      lea d, [bp + -1] ; $result
1205   0A86 DA            push d
1206   0A87 FA FF FF      lea d, [bp + -1] ; $result
1207   0A8A 2A            mov b, [d]
1208   0A8B             ; START FACTORS
1209   0A8B D7            push a
1210   0A8C 11            mov a, b
1211   0A8D 26 0A 00      mov b, $a
1212   0A90 AC            mul a, b ; *
1213   0A91 11            mov a, b
1214   0A92 27            mov b, a
1215   0A93 E4            pop a
1216   0A94             ; END FACTORS
1217   0A94             ; START TERMS
1218   0A94 D7            push a
1219   0A95 11            mov a, b
1220   0A96 FA 05 00      lea d, [bp + 5] ; $str
1221   0A99 2A            mov b, [d]
1222   0A9A 74            mov d, b
1223   0A9B 32            mov bl, [d]
1224   0A9C A7 00         mov bh, 0
1225   0A9E             ; START TERMS
1226   0A9E D7            push a
1227   0A9F 11            mov a, b
1228   0AA0 26 30 00      mov b, $30
1229   0AA3 60            sub a, b
1230   0AA4 27            mov b, a
1231   0AA5 E4            pop a
1232   0AA6             ; END TERMS
1233   0AA6 54            add a, b
1234   0AA7 27            mov b, a
1235   0AA8 E4            pop a
1236   0AA9             ; END TERMS
1237   0AA9 E7            pop d
1238   0AAA FD 43         mov [d], b
1239   0AAC             ;; str++; 
1240   0AAC FA 05 00      lea d, [bp + 5] ; $str
1241   0AAF 2A            mov b, [d]
1242   0AB0 D8            push b
1243   0AB1 FD 77         inc b
1244   0AB3 FA 05 00      lea d, [bp + 5] ; $str
1245   0AB6 FD 43         mov [d], b
1246   0AB8 E5            pop b
1247   0AB9 0A 56 0A      jmp _while17_cond
1248   0ABC             _while17_exit:
1249   0ABC             ;; return sign * result; 
1250   0ABC FA FD FF      lea d, [bp + -3] ; $sign
1251   0ABF 2A            mov b, [d]
1252   0AC0             ; START FACTORS
1253   0AC0 D7            push a
1254   0AC1 11            mov a, b
1255   0AC2 FA FF FF      lea d, [bp + -1] ; $result
1256   0AC5 2A            mov b, [d]
1257   0AC6 AC            mul a, b ; *
1258   0AC7 11            mov a, b
1259   0AC8 27            mov b, a
1260   0AC9 E4            pop a
1261   0ACA             ; END FACTORS
1262   0ACA F9            leave
1263   0ACB 09            ret
1264   0ACC             
1265   0ACC             gets:
1266   0ACC F8 00 00      enter 0 ; (push bp; mov bp, sp)
1267   0ACF             
1268   0ACF             ; --- BEGIN INLINE ASM BLOCK
1269   0ACF FA 05 00      lea d, [bp + 5] ; $s
1270   0AD2 15            mov a, [d]
1271   0AD3 3C            mov d, a
1272   0AD4 07 FC 10      call _gets
1273   0AD7             ; --- END INLINE ASM BLOCK
1274   0AD7             
1275   0AD7             ;; return strlen(s); 
1276   0AD7 FA 05 00      lea d, [bp + 5] ; $s
1277   0ADA 2A            mov b, [d]
1278   0ADB FD AB         swp b
1279   0ADD D8            push b
1280   0ADE 07 9F 05      call strlen
1281   0AE1 51 02 00      add sp, 2
1282   0AE4 F9            leave
1283   0AE5 09            ret
1284   0AE6             
1285   0AE6             print_signed:
1286   0AE6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1287   0AE9             ; $digits 
1288   0AE9             ; $i 
1289   0AE9 10 00 00      mov a, $0
1290   0AEC 45 FA FF      mov [bp + -6], a
1291   0AEF 52 07 00      sub sp, 7
1292   0AF2             ;; if (num < 0) { 
1293   0AF2             _if18_cond:
1294   0AF2 FA 05 00      lea d, [bp + 5] ; $num
1295   0AF5 2A            mov b, [d]
1296   0AF6             ; START RELATIONAL
1297   0AF6 D7            push a
1298   0AF7 11            mov a, b
1299   0AF8 26 00 00      mov b, $0
1300   0AFB B0            cmp a, b
1301   0AFC FD 73         slt ; < 
1302   0AFE E4            pop a
1303   0AFF             ; END RELATIONAL
1304   0AFF C0 00 00      cmp b, 0
1305   0B02 C6 1F 0B      je _if18_else
1306   0B05             _if18_true:
1307   0B05             ;; putchar('-'); 
1308   0B05 26 2D 00      mov b, $2d
1309   0B08 DD            push bl
1310   0B09 07 78 0E      call putchar
1311   0B0C 51 01 00      add sp, 1
1312   0B0F             ;; num = -num; 
1313   0B0F FA 05 00      lea d, [bp + 5] ; $num
1314   0B12 DA            push d
1315   0B13 FA 05 00      lea d, [bp + 5] ; $num
1316   0B16 2A            mov b, [d]
1317   0B17 FD 97         neg b
1318   0B19 E7            pop d
1319   0B1A FD 43         mov [d], b
1320   0B1C 0A 41 0B      jmp _if18_exit
1321   0B1F             _if18_else:
1322   0B1F             ;; if (num == 0) { 
1323   0B1F             _if19_cond:
1324   0B1F FA 05 00      lea d, [bp + 5] ; $num
1325   0B22 2A            mov b, [d]
1326   0B23             ; START RELATIONAL
1327   0B23 D7            push a
1328   0B24 11            mov a, b
1329   0B25 26 00 00      mov b, $0
1330   0B28 B0            cmp a, b
1331   0B29 FD 71         seq ; ==
1332   0B2B E4            pop a
1333   0B2C             ; END RELATIONAL
1334   0B2C C0 00 00      cmp b, 0
1335   0B2F C6 41 0B      je _if19_exit
1336   0B32             _if19_true:
1337   0B32             ;; putchar('0'); 
1338   0B32 26 30 00      mov b, $30
1339   0B35 DD            push bl
1340   0B36 07 78 0E      call putchar
1341   0B39 51 01 00      add sp, 1
1342   0B3C             ;; return; 
1343   0B3C F9            leave
1344   0B3D 09            ret
1345   0B3E 0A 41 0B      jmp _if19_exit
1346   0B41             _if19_exit:
1347   0B41             _if18_exit:
1348   0B41             ;; while (num > 0) { 
1349   0B41             _while20_cond:
1350   0B41 FA 05 00      lea d, [bp + 5] ; $num
1351   0B44 2A            mov b, [d]
1352   0B45             ; START RELATIONAL
1353   0B45 D7            push a
1354   0B46 11            mov a, b
1355   0B47 26 00 00      mov b, $0
1356   0B4A B0            cmp a, b
1357   0B4B FD 7F         sgt ; >
1358   0B4D E4            pop a
1359   0B4E             ; END RELATIONAL
1360   0B4E C0 00 00      cmp b, 0
1361   0B51 C6 9C 0B      je _while20_exit
1362   0B54             _while20_block:
1363   0B54             ;; digits[i] = '0' + (num % 10); 
1364   0B54 FA FC FF      lea d, [bp + -4] ; $digits
1365   0B57 D7            push a
1366   0B58 DA            push d
1367   0B59 FA FA FF      lea d, [bp + -6] ; $i
1368   0B5C 2A            mov b, [d]
1369   0B5D E7            pop d
1370   0B5E 5A            add d, b
1371   0B5F E4            pop a
1372   0B60 DA            push d
1373   0B61 26 30 00      mov b, $30
1374   0B64             ; START TERMS
1375   0B64 D7            push a
1376   0B65 11            mov a, b
1377   0B66 FA 05 00      lea d, [bp + 5] ; $num
1378   0B69 2A            mov b, [d]
1379   0B6A             ; START FACTORS
1380   0B6A D7            push a
1381   0B6B 11            mov a, b
1382   0B6C 26 0A 00      mov b, $a
1383   0B6F AE            div a, b ; 
1384   0B70 11            mov a, b
1385   0B71 27            mov b, a
1386   0B72 E4            pop a
1387   0B73             ; END FACTORS
1388   0B73 54            add a, b
1389   0B74 27            mov b, a
1390   0B75 E4            pop a
1391   0B76             ; END TERMS
1392   0B76 E7            pop d
1393   0B77 FD 3E         mov [d], bl
1394   0B79             ;; num = num / 10; 
1395   0B79 FA 05 00      lea d, [bp + 5] ; $num
1396   0B7C DA            push d
1397   0B7D FA 05 00      lea d, [bp + 5] ; $num
1398   0B80 2A            mov b, [d]
1399   0B81             ; START FACTORS
1400   0B81 D7            push a
1401   0B82 11            mov a, b
1402   0B83 26 0A 00      mov b, $a
1403   0B86 AE            div a, b
1404   0B87 27            mov b, a
1405   0B88 E4            pop a
1406   0B89             ; END FACTORS
1407   0B89 E7            pop d
1408   0B8A FD 43         mov [d], b
1409   0B8C             ;; i++; 
1410   0B8C FA FA FF      lea d, [bp + -6] ; $i
1411   0B8F 2A            mov b, [d]
1412   0B90 D8            push b
1413   0B91 FD 77         inc b
1414   0B93 FA FA FF      lea d, [bp + -6] ; $i
1415   0B96 FD 43         mov [d], b
1416   0B98 E5            pop b
1417   0B99 0A 41 0B      jmp _while20_cond
1418   0B9C             _while20_exit:
1419   0B9C             ;; while (i > 0) { 
1420   0B9C             _while21_cond:
1421   0B9C FA FA FF      lea d, [bp + -6] ; $i
1422   0B9F 2A            mov b, [d]
1423   0BA0             ; START RELATIONAL
1424   0BA0 D7            push a
1425   0BA1 11            mov a, b
1426   0BA2 26 00 00      mov b, $0
1427   0BA5 B0            cmp a, b
1428   0BA6 FD 7F         sgt ; >
1429   0BA8 E4            pop a
1430   0BA9             ; END RELATIONAL
1431   0BA9 C0 00 00      cmp b, 0
1432   0BAC C6 D5 0B      je _while21_exit
1433   0BAF             _while21_block:
1434   0BAF             ;; i--; 
1435   0BAF FA FA FF      lea d, [bp + -6] ; $i
1436   0BB2 2A            mov b, [d]
1437   0BB3 D8            push b
1438   0BB4 FD 7D         dec b
1439   0BB6 FA FA FF      lea d, [bp + -6] ; $i
1440   0BB9 FD 43         mov [d], b
1441   0BBB E5            pop b
1442   0BBC             ;; putchar(digits[i]); 
1443   0BBC FA FC FF      lea d, [bp + -4] ; $digits
1444   0BBF D7            push a
1445   0BC0 DA            push d
1446   0BC1 FA FA FF      lea d, [bp + -6] ; $i
1447   0BC4 2A            mov b, [d]
1448   0BC5 E7            pop d
1449   0BC6 5A            add d, b
1450   0BC7 E4            pop a
1451   0BC8 32            mov bl, [d]
1452   0BC9 A7 00         mov bh, 0
1453   0BCB DD            push bl
1454   0BCC 07 78 0E      call putchar
1455   0BCF 51 01 00      add sp, 1
1456   0BD2 0A 9C 0B      jmp _while21_cond
1457   0BD5             _while21_exit:
1458   0BD5 F9            leave
1459   0BD6 09            ret
1460   0BD7             
1461   0BD7             print_signed_long:
1462   0BD7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1463   0BDA             ; $digits 
1464   0BDA             ; $i 
1465   0BDA 10 00 00      mov a, $0
1466   0BDD 45 F5 FF      mov [bp + -11], a
1467   0BE0 52 0C 00      sub sp, 12
1468   0BE3             ;; if (num < 0) { 
1469   0BE3             _if22_cond:
1470   0BE3 FA 05 00      lea d, [bp + 5] ; $num
1471   0BE6 2A            mov b, [d]
1472   0BE7             ; START RELATIONAL
1473   0BE7 D7            push a
1474   0BE8 11            mov a, b
1475   0BE9 26 00 00      mov b, $0
1476   0BEC B0            cmp a, b
1477   0BED FD 73         slt ; < 
1478   0BEF E4            pop a
1479   0BF0             ; END RELATIONAL
1480   0BF0 C0 00 00      cmp b, 0
1481   0BF3 C6 10 0C      je _if22_else
1482   0BF6             _if22_true:
1483   0BF6             ;; putchar('-'); 
1484   0BF6 26 2D 00      mov b, $2d
1485   0BF9 DD            push bl
1486   0BFA 07 78 0E      call putchar
1487   0BFD 51 01 00      add sp, 1
1488   0C00             ;; num = -num; 
1489   0C00 FA 05 00      lea d, [bp + 5] ; $num
1490   0C03 DA            push d
1491   0C04 FA 05 00      lea d, [bp + 5] ; $num
1492   0C07 2A            mov b, [d]
1493   0C08 FD 97         neg b
1494   0C0A E7            pop d
1495   0C0B FD 43         mov [d], b
1496   0C0D 0A 32 0C      jmp _if22_exit
1497   0C10             _if22_else:
1498   0C10             ;; if (num == 0) { 
1499   0C10             _if23_cond:
1500   0C10 FA 05 00      lea d, [bp + 5] ; $num
1501   0C13 2A            mov b, [d]
1502   0C14             ; START RELATIONAL
1503   0C14 D7            push a
1504   0C15 11            mov a, b
1505   0C16 26 00 00      mov b, $0
1506   0C19 B0            cmp a, b
1507   0C1A FD 71         seq ; ==
1508   0C1C E4            pop a
1509   0C1D             ; END RELATIONAL
1510   0C1D C0 00 00      cmp b, 0
1511   0C20 C6 32 0C      je _if23_exit
1512   0C23             _if23_true:
1513   0C23             ;; putchar('0'); 
1514   0C23 26 30 00      mov b, $30
1515   0C26 DD            push bl
1516   0C27 07 78 0E      call putchar
1517   0C2A 51 01 00      add sp, 1
1518   0C2D             ;; return; 
1519   0C2D F9            leave
1520   0C2E 09            ret
1521   0C2F 0A 32 0C      jmp _if23_exit
1522   0C32             _if23_exit:
1523   0C32             _if22_exit:
1524   0C32             ;; while (num > 0) { 
1525   0C32             _while24_cond:
1526   0C32 FA 05 00      lea d, [bp + 5] ; $num
1527   0C35 2A            mov b, [d]
1528   0C36             ; START RELATIONAL
1529   0C36 D7            push a
1530   0C37 11            mov a, b
1531   0C38 26 00 00      mov b, $0
1532   0C3B B0            cmp a, b
1533   0C3C FD 7F         sgt ; >
1534   0C3E E4            pop a
1535   0C3F             ; END RELATIONAL
1536   0C3F C0 00 00      cmp b, 0
1537   0C42 C6 8D 0C      je _while24_exit
1538   0C45             _while24_block:
1539   0C45             ;; digits[i] = '0' + (num % 10); 
1540   0C45 FA F7 FF      lea d, [bp + -9] ; $digits
1541   0C48 D7            push a
1542   0C49 DA            push d
1543   0C4A FA F5 FF      lea d, [bp + -11] ; $i
1544   0C4D 2A            mov b, [d]
1545   0C4E E7            pop d
1546   0C4F 5A            add d, b
1547   0C50 E4            pop a
1548   0C51 DA            push d
1549   0C52 26 30 00      mov b, $30
1550   0C55             ; START TERMS
1551   0C55 D7            push a
1552   0C56 11            mov a, b
1553   0C57 FA 05 00      lea d, [bp + 5] ; $num
1554   0C5A 2A            mov b, [d]
1555   0C5B             ; START FACTORS
1556   0C5B D7            push a
1557   0C5C 11            mov a, b
1558   0C5D 26 0A 00      mov b, $a
1559   0C60 AE            div a, b ; 
1560   0C61 11            mov a, b
1561   0C62 27            mov b, a
1562   0C63 E4            pop a
1563   0C64             ; END FACTORS
1564   0C64 54            add a, b
1565   0C65 27            mov b, a
1566   0C66 E4            pop a
1567   0C67             ; END TERMS
1568   0C67 E7            pop d
1569   0C68 FD 3E         mov [d], bl
1570   0C6A             ;; num = num / 10; 
1571   0C6A FA 05 00      lea d, [bp + 5] ; $num
1572   0C6D DA            push d
1573   0C6E FA 05 00      lea d, [bp + 5] ; $num
1574   0C71 2A            mov b, [d]
1575   0C72             ; START FACTORS
1576   0C72 D7            push a
1577   0C73 11            mov a, b
1578   0C74 26 0A 00      mov b, $a
1579   0C77 AE            div a, b
1580   0C78 27            mov b, a
1581   0C79 E4            pop a
1582   0C7A             ; END FACTORS
1583   0C7A E7            pop d
1584   0C7B FD 43         mov [d], b
1585   0C7D             ;; i++; 
1586   0C7D FA F5 FF      lea d, [bp + -11] ; $i
1587   0C80 2A            mov b, [d]
1588   0C81 D8            push b
1589   0C82 FD 77         inc b
1590   0C84 FA F5 FF      lea d, [bp + -11] ; $i
1591   0C87 FD 43         mov [d], b
1592   0C89 E5            pop b
1593   0C8A 0A 32 0C      jmp _while24_cond
1594   0C8D             _while24_exit:
1595   0C8D             ;; while (i > 0) { 
1596   0C8D             _while25_cond:
1597   0C8D FA F5 FF      lea d, [bp + -11] ; $i
1598   0C90 2A            mov b, [d]
1599   0C91             ; START RELATIONAL
1600   0C91 D7            push a
1601   0C92 11            mov a, b
1602   0C93 26 00 00      mov b, $0
1603   0C96 B0            cmp a, b
1604   0C97 FD 7F         sgt ; >
1605   0C99 E4            pop a
1606   0C9A             ; END RELATIONAL
1607   0C9A C0 00 00      cmp b, 0
1608   0C9D C6 C6 0C      je _while25_exit
1609   0CA0             _while25_block:
1610   0CA0             ;; i--; 
1611   0CA0 FA F5 FF      lea d, [bp + -11] ; $i
1612   0CA3 2A            mov b, [d]
1613   0CA4 D8            push b
1614   0CA5 FD 7D         dec b
1615   0CA7 FA F5 FF      lea d, [bp + -11] ; $i
1616   0CAA FD 43         mov [d], b
1617   0CAC E5            pop b
1618   0CAD             ;; putchar(digits[i]); 
1619   0CAD FA F7 FF      lea d, [bp + -9] ; $digits
1620   0CB0 D7            push a
1621   0CB1 DA            push d
1622   0CB2 FA F5 FF      lea d, [bp + -11] ; $i
1623   0CB5 2A            mov b, [d]
1624   0CB6 E7            pop d
1625   0CB7 5A            add d, b
1626   0CB8 E4            pop a
1627   0CB9 32            mov bl, [d]
1628   0CBA A7 00         mov bh, 0
1629   0CBC DD            push bl
1630   0CBD 07 78 0E      call putchar
1631   0CC0 51 01 00      add sp, 1
1632   0CC3 0A 8D 0C      jmp _while25_cond
1633   0CC6             _while25_exit:
1634   0CC6 F9            leave
1635   0CC7 09            ret
1636   0CC8             
1637   0CC8             print_unsigned_long:
1638   0CC8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1639   0CCB             ; $digits 
1640   0CCB             ; $i 
1641   0CCB 52 0C 00      sub sp, 12
1642   0CCE             ;; i = 0; 
1643   0CCE FA F5 FF      lea d, [bp + -11] ; $i
1644   0CD1 DA            push d
1645   0CD2 26 00 00      mov b, $0
1646   0CD5 E7            pop d
1647   0CD6 FD 43         mov [d], b
1648   0CD8             ;; if(num == 0){ 
1649   0CD8             _if26_cond:
1650   0CD8 FA 05 00      lea d, [bp + 5] ; $num
1651   0CDB 2A            mov b, [d]
1652   0CDC             ; START RELATIONAL
1653   0CDC D7            push a
1654   0CDD 11            mov a, b
1655   0CDE 26 00 00      mov b, $0
1656   0CE1 B0            cmp a, b
1657   0CE2 FD 71         seq ; ==
1658   0CE4 E4            pop a
1659   0CE5             ; END RELATIONAL
1660   0CE5 C0 00 00      cmp b, 0
1661   0CE8 C6 FA 0C      je _if26_exit
1662   0CEB             _if26_true:
1663   0CEB             ;; putchar('0'); 
1664   0CEB 26 30 00      mov b, $30
1665   0CEE DD            push bl
1666   0CEF 07 78 0E      call putchar
1667   0CF2 51 01 00      add sp, 1
1668   0CF5             ;; return; 
1669   0CF5 F9            leave
1670   0CF6 09            ret
1671   0CF7 0A FA 0C      jmp _if26_exit
1672   0CFA             _if26_exit:
1673   0CFA             ;; while (num > 0) { 
1674   0CFA             _while27_cond:
1675   0CFA FA 05 00      lea d, [bp + 5] ; $num
1676   0CFD 2A            mov b, [d]
1677   0CFE             ; START RELATIONAL
1678   0CFE D7            push a
1679   0CFF 11            mov a, b
1680   0D00 26 00 00      mov b, $0
1681   0D03 B0            cmp a, b
1682   0D04 FD 81         sgu ; > (unsigned)
1683   0D06 E4            pop a
1684   0D07             ; END RELATIONAL
1685   0D07 C0 00 00      cmp b, 0
1686   0D0A C6 55 0D      je _while27_exit
1687   0D0D             _while27_block:
1688   0D0D             ;; digits[i] = '0' + (num % 10); 
1689   0D0D FA F7 FF      lea d, [bp + -9] ; $digits
1690   0D10 D7            push a
1691   0D11 DA            push d
1692   0D12 FA F5 FF      lea d, [bp + -11] ; $i
1693   0D15 2A            mov b, [d]
1694   0D16 E7            pop d
1695   0D17 5A            add d, b
1696   0D18 E4            pop a
1697   0D19 DA            push d
1698   0D1A 26 30 00      mov b, $30
1699   0D1D             ; START TERMS
1700   0D1D D7            push a
1701   0D1E 11            mov a, b
1702   0D1F FA 05 00      lea d, [bp + 5] ; $num
1703   0D22 2A            mov b, [d]
1704   0D23             ; START FACTORS
1705   0D23 D7            push a
1706   0D24 11            mov a, b
1707   0D25 26 0A 00      mov b, $a
1708   0D28 AE            div a, b ; 
1709   0D29 11            mov a, b
1710   0D2A 27            mov b, a
1711   0D2B E4            pop a
1712   0D2C             ; END FACTORS
1713   0D2C 54            add a, b
1714   0D2D 27            mov b, a
1715   0D2E E4            pop a
1716   0D2F             ; END TERMS
1717   0D2F E7            pop d
1718   0D30 FD 3E         mov [d], bl
1719   0D32             ;; num = num / 10; 
1720   0D32 FA 05 00      lea d, [bp + 5] ; $num
1721   0D35 DA            push d
1722   0D36 FA 05 00      lea d, [bp + 5] ; $num
1723   0D39 2A            mov b, [d]
1724   0D3A             ; START FACTORS
1725   0D3A D7            push a
1726   0D3B 11            mov a, b
1727   0D3C 26 0A 00      mov b, $a
1728   0D3F AE            div a, b
1729   0D40 27            mov b, a
1730   0D41 E4            pop a
1731   0D42             ; END FACTORS
1732   0D42 E7            pop d
1733   0D43 FD 43         mov [d], b
1734   0D45             ;; i++; 
1735   0D45 FA F5 FF      lea d, [bp + -11] ; $i
1736   0D48 2A            mov b, [d]
1737   0D49 D8            push b
1738   0D4A FD 77         inc b
1739   0D4C FA F5 FF      lea d, [bp + -11] ; $i
1740   0D4F FD 43         mov [d], b
1741   0D51 E5            pop b
1742   0D52 0A FA 0C      jmp _while27_cond
1743   0D55             _while27_exit:
1744   0D55             ;; while (i > 0) { 
1745   0D55             _while28_cond:
1746   0D55 FA F5 FF      lea d, [bp + -11] ; $i
1747   0D58 2A            mov b, [d]
1748   0D59             ; START RELATIONAL
1749   0D59 D7            push a
1750   0D5A 11            mov a, b
1751   0D5B 26 00 00      mov b, $0
1752   0D5E B0            cmp a, b
1753   0D5F FD 7F         sgt ; >
1754   0D61 E4            pop a
1755   0D62             ; END RELATIONAL
1756   0D62 C0 00 00      cmp b, 0
1757   0D65 C6 8E 0D      je _while28_exit
1758   0D68             _while28_block:
1759   0D68             ;; i--; 
1760   0D68 FA F5 FF      lea d, [bp + -11] ; $i
1761   0D6B 2A            mov b, [d]
1762   0D6C D8            push b
1763   0D6D FD 7D         dec b
1764   0D6F FA F5 FF      lea d, [bp + -11] ; $i
1765   0D72 FD 43         mov [d], b
1766   0D74 E5            pop b
1767   0D75             ;; putchar(digits[i]); 
1768   0D75 FA F7 FF      lea d, [bp + -9] ; $digits
1769   0D78 D7            push a
1770   0D79 DA            push d
1771   0D7A FA F5 FF      lea d, [bp + -11] ; $i
1772   0D7D 2A            mov b, [d]
1773   0D7E E7            pop d
1774   0D7F 5A            add d, b
1775   0D80 E4            pop a
1776   0D81 32            mov bl, [d]
1777   0D82 A7 00         mov bh, 0
1778   0D84 DD            push bl
1779   0D85 07 78 0E      call putchar
1780   0D88 51 01 00      add sp, 1
1781   0D8B 0A 55 0D      jmp _while28_cond
1782   0D8E             _while28_exit:
1783   0D8E F9            leave
1784   0D8F 09            ret
1785   0D90             
1786   0D90             print_unsigned:
1787   0D90 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1788   0D93             ; $digits 
1789   0D93             ; $i 
1790   0D93 52 07 00      sub sp, 7
1791   0D96             ;; i = 0; 
1792   0D96 FA FA FF      lea d, [bp + -6] ; $i
1793   0D99 DA            push d
1794   0D9A 26 00 00      mov b, $0
1795   0D9D E7            pop d
1796   0D9E FD 43         mov [d], b
1797   0DA0             ;; if(num == 0){ 
1798   0DA0             _if29_cond:
1799   0DA0 FA 05 00      lea d, [bp + 5] ; $num
1800   0DA3 2A            mov b, [d]
1801   0DA4             ; START RELATIONAL
1802   0DA4 D7            push a
1803   0DA5 11            mov a, b
1804   0DA6 26 00 00      mov b, $0
1805   0DA9 B0            cmp a, b
1806   0DAA FD 71         seq ; ==
1807   0DAC E4            pop a
1808   0DAD             ; END RELATIONAL
1809   0DAD C0 00 00      cmp b, 0
1810   0DB0 C6 C2 0D      je _if29_exit
1811   0DB3             _if29_true:
1812   0DB3             ;; putchar('0'); 
1813   0DB3 26 30 00      mov b, $30
1814   0DB6 DD            push bl
1815   0DB7 07 78 0E      call putchar
1816   0DBA 51 01 00      add sp, 1
1817   0DBD             ;; return; 
1818   0DBD F9            leave
1819   0DBE 09            ret
1820   0DBF 0A C2 0D      jmp _if29_exit
1821   0DC2             _if29_exit:
1822   0DC2             ;; while (num > 0) { 
1823   0DC2             _while30_cond:
1824   0DC2 FA 05 00      lea d, [bp + 5] ; $num
1825   0DC5 2A            mov b, [d]
1826   0DC6             ; START RELATIONAL
1827   0DC6 D7            push a
1828   0DC7 11            mov a, b
1829   0DC8 26 00 00      mov b, $0
1830   0DCB B0            cmp a, b
1831   0DCC FD 81         sgu ; > (unsigned)
1832   0DCE E4            pop a
1833   0DCF             ; END RELATIONAL
1834   0DCF C0 00 00      cmp b, 0
1835   0DD2 C6 1D 0E      je _while30_exit
1836   0DD5             _while30_block:
1837   0DD5             ;; digits[i] = '0' + (num % 10); 
1838   0DD5 FA FC FF      lea d, [bp + -4] ; $digits
1839   0DD8 D7            push a
1840   0DD9 DA            push d
1841   0DDA FA FA FF      lea d, [bp + -6] ; $i
1842   0DDD 2A            mov b, [d]
1843   0DDE E7            pop d
1844   0DDF 5A            add d, b
1845   0DE0 E4            pop a
1846   0DE1 DA            push d
1847   0DE2 26 30 00      mov b, $30
1848   0DE5             ; START TERMS
1849   0DE5 D7            push a
1850   0DE6 11            mov a, b
1851   0DE7 FA 05 00      lea d, [bp + 5] ; $num
1852   0DEA 2A            mov b, [d]
1853   0DEB             ; START FACTORS
1854   0DEB D7            push a
1855   0DEC 11            mov a, b
1856   0DED 26 0A 00      mov b, $a
1857   0DF0 AE            div a, b ; 
1858   0DF1 11            mov a, b
1859   0DF2 27            mov b, a
1860   0DF3 E4            pop a
1861   0DF4             ; END FACTORS
1862   0DF4 54            add a, b
1863   0DF5 27            mov b, a
1864   0DF6 E4            pop a
1865   0DF7             ; END TERMS
1866   0DF7 E7            pop d
1867   0DF8 FD 3E         mov [d], bl
1868   0DFA             ;; num = num / 10; 
1869   0DFA FA 05 00      lea d, [bp + 5] ; $num
1870   0DFD DA            push d
1871   0DFE FA 05 00      lea d, [bp + 5] ; $num
1872   0E01 2A            mov b, [d]
1873   0E02             ; START FACTORS
1874   0E02 D7            push a
1875   0E03 11            mov a, b
1876   0E04 26 0A 00      mov b, $a
1877   0E07 AE            div a, b
1878   0E08 27            mov b, a
1879   0E09 E4            pop a
1880   0E0A             ; END FACTORS
1881   0E0A E7            pop d
1882   0E0B FD 43         mov [d], b
1883   0E0D             ;; i++; 
1884   0E0D FA FA FF      lea d, [bp + -6] ; $i
1885   0E10 2A            mov b, [d]
1886   0E11 D8            push b
1887   0E12 FD 77         inc b
1888   0E14 FA FA FF      lea d, [bp + -6] ; $i
1889   0E17 FD 43         mov [d], b
1890   0E19 E5            pop b
1891   0E1A 0A C2 0D      jmp _while30_cond
1892   0E1D             _while30_exit:
1893   0E1D             ;; while (i > 0) { 
1894   0E1D             _while31_cond:
1895   0E1D FA FA FF      lea d, [bp + -6] ; $i
1896   0E20 2A            mov b, [d]
1897   0E21             ; START RELATIONAL
1898   0E21 D7            push a
1899   0E22 11            mov a, b
1900   0E23 26 00 00      mov b, $0
1901   0E26 B0            cmp a, b
1902   0E27 FD 7F         sgt ; >
1903   0E29 E4            pop a
1904   0E2A             ; END RELATIONAL
1905   0E2A C0 00 00      cmp b, 0
1906   0E2D C6 56 0E      je _while31_exit
1907   0E30             _while31_block:
1908   0E30             ;; i--; 
1909   0E30 FA FA FF      lea d, [bp + -6] ; $i
1910   0E33 2A            mov b, [d]
1911   0E34 D8            push b
1912   0E35 FD 7D         dec b
1913   0E37 FA FA FF      lea d, [bp + -6] ; $i
1914   0E3A FD 43         mov [d], b
1915   0E3C E5            pop b
1916   0E3D             ;; putchar(digits[i]); 
1917   0E3D FA FC FF      lea d, [bp + -4] ; $digits
1918   0E40 D7            push a
1919   0E41 DA            push d
1920   0E42 FA FA FF      lea d, [bp + -6] ; $i
1921   0E45 2A            mov b, [d]
1922   0E46 E7            pop d
1923   0E47 5A            add d, b
1924   0E48 E4            pop a
1925   0E49 32            mov bl, [d]
1926   0E4A A7 00         mov bh, 0
1927   0E4C DD            push bl
1928   0E4D 07 78 0E      call putchar
1929   0E50 51 01 00      add sp, 1
1930   0E53 0A 1D 0E      jmp _while31_cond
1931   0E56             _while31_exit:
1932   0E56 F9            leave
1933   0E57 09            ret
1934   0E58             
1935   0E58             rand:
1936   0E58 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1937   0E5B             ; $sec 
1938   0E5B 52 01 00      sub sp, 1
1939   0E5E             
1940   0E5E             ; --- BEGIN INLINE ASM BLOCK
1941   0E5E 19 00         mov al, 0
1942   0E60 05 01         syscall sys_rtc					
1943   0E62 1A            mov al, ah
1944   0E63 FA 00 00      lea d, [bp + 0] ; $sec
1945   0E66 1E            mov al, [d]
1946   0E67             ; --- END INLINE ASM BLOCK
1947   0E67             
1948   0E67             ;; return sec; 
1949   0E67 FA 00 00      lea d, [bp + 0] ; $sec
1950   0E6A 32            mov bl, [d]
1951   0E6B A7 00         mov bh, 0
1952   0E6D F9            leave
1953   0E6E 09            ret
1954   0E6F             
1955   0E6F             date:
1956   0E6F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1957   0E72             
1958   0E72             ; --- BEGIN INLINE ASM BLOCK
1959   0E72 19 00         mov al, 0 
1960   0E74 05 07         syscall sys_datetime
1961   0E76             ; --- END INLINE ASM BLOCK
1962   0E76             
1963   0E76 F9            leave
1964   0E77 09            ret
1965   0E78             
1966   0E78             putchar:
1967   0E78 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1968   0E7B             
1969   0E7B             ; --- BEGIN INLINE ASM BLOCK
1970   0E7B FA 05 00      lea d, [bp + 5] ; $c
1971   0E7E 1E            mov al, [d]
1972   0E7F 23            mov ah, al
1973   0E80 07 F5 10      call _putchar
1974   0E83             ; --- END INLINE ASM BLOCK
1975   0E83             
1976   0E83 F9            leave
1977   0E84 09            ret
1978   0E85             
1979   0E85             getchar:
1980   0E85 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1981   0E88             ; $c 
1982   0E88 52 01 00      sub sp, 1
1983   0E8B             
1984   0E8B             ; --- BEGIN INLINE ASM BLOCK
1985   0E8B 07 EE 10      call getch
1986   0E8E 1A            mov al, ah
1987   0E8F FA 00 00      lea d, [bp + 0] ; $c
1988   0E92 3E            mov [d], al
1989   0E93             ; --- END INLINE ASM BLOCK
1990   0E93             
1991   0E93             ;; return c; 
1992   0E93 FA 00 00      lea d, [bp + 0] ; $c
1993   0E96 32            mov bl, [d]
1994   0E97 A7 00         mov bh, 0
1995   0E99 F9            leave
1996   0E9A 09            ret
1997   0E9B             
1998   0E9B             scann:
1999   0E9B F8 00 00      enter 0 ; (push bp; mov bp, sp)
2000   0E9E             ; $m 
2001   0E9E 52 02 00      sub sp, 2
2002   0EA1             
2003   0EA1             ; --- BEGIN INLINE ASM BLOCK
2004   0EA1 07 39 13      call scan_u16d
2005   0EA4 FA FF FF      lea d, [bp + -1] ; $m
2006   0EA7 43            mov [d], a
2007   0EA8             ; --- END INLINE ASM BLOCK
2008   0EA8             
2009   0EA8             ;; return m; 
2010   0EA8 FA FF FF      lea d, [bp + -1] ; $m
2011   0EAB 2A            mov b, [d]
2012   0EAC F9            leave
2013   0EAD 09            ret
2014   0EAE             
2015   0EAE             puts:
2016   0EAE F8 00 00      enter 0 ; (push bp; mov bp, sp)
2017   0EB1             
2018   0EB1             ; --- BEGIN INLINE ASM BLOCK
2019   0EB1 FA 05 00      lea d, [bp + 5] ; $s
2020   0EB4 15            mov a, [d]
2021   0EB5 3C            mov d, a
2022   0EB6 07 3F 12      call _puts
2023   0EB9 10 00 0A      mov a, $0A00
2024   0EBC 05 03         syscall sys_io
2025   0EBE             ; --- END INLINE ASM BLOCK
2026   0EBE             
2027   0EBE F9            leave
2028   0EBF 09            ret
2029   0EC0             
2030   0EC0             print:
2031   0EC0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2032   0EC3             
2033   0EC3             ; --- BEGIN INLINE ASM BLOCK
2034   0EC3 FA 05 00      lea d, [bp + 5] ; $s
2035   0EC6 FD 2A         mov d, [d]
2036   0EC8 07 3F 12      call _puts
2037   0ECB             ; --- END INLINE ASM BLOCK
2038   0ECB             
2039   0ECB F9            leave
2040   0ECC 09            ret
2041   0ECD             
2042   0ECD             loadfile:
2043   0ECD F8 00 00      enter 0 ; (push bp; mov bp, sp)
2044   0ED0             
2045   0ED0             ; --- BEGIN INLINE ASM BLOCK
2046   0ED0 FA 07 00      lea d, [bp + 7] ; $destination
2047   0ED3 15            mov a, [d]
2048   0ED4 4F            mov di, a
2049   0ED5 FA 05 00      lea d, [bp + 5] ; $filename
2050   0ED8 FD 2A         mov d, [d]
2051   0EDA 19 14         mov al, 20
2052   0EDC 05 04         syscall sys_filesystem
2053   0EDE             ; --- END INLINE ASM BLOCK
2054   0EDE             
2055   0EDE F9            leave
2056   0EDF 09            ret
2057   0EE0             
2058   0EE0             create_file:
2059   0EE0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2060   0EE3 F9            leave
2061   0EE4 09            ret
2062   0EE5             
2063   0EE5             delete_file:
2064   0EE5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2065   0EE8             
2066   0EE8             ; --- BEGIN INLINE ASM BLOCK
2067   0EE8 FA 05 00      lea d, [bp + 5] ; $filename
2068   0EEB 19 0A         mov al, 10
2069   0EED 05 04         syscall sys_filesystem
2070   0EEF             ; --- END INLINE ASM BLOCK
2071   0EEF             
2072   0EEF F9            leave
2073   0EF0 09            ret
2074   0EF1             
2075   0EF1             fopen:
2076   0EF1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2077   0EF4 F9            leave
2078   0EF5 09            ret
2079   0EF6             
2080   0EF6             fclose:
2081   0EF6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2082   0EF9 F9            leave
2083   0EFA 09            ret
2084   0EFB             
2085   0EFB             alloc:
2086   0EFB F8 00 00      enter 0 ; (push bp; mov bp, sp)
2087   0EFE             ;; heap_top = heap_top + bytes; 
2088   0EFE 3B 44 14      mov d, _heap_top ; $heap_top
2089   0F01 DA            push d
2090   0F02 3B 44 14      mov d, _heap_top ; $heap_top
2091   0F05 2A            mov b, [d]
2092   0F06             ; START TERMS
2093   0F06 D7            push a
2094   0F07 11            mov a, b
2095   0F08 FA 05 00      lea d, [bp + 5] ; $bytes
2096   0F0B 2A            mov b, [d]
2097   0F0C 54            add a, b
2098   0F0D 27            mov b, a
2099   0F0E E4            pop a
2100   0F0F             ; END TERMS
2101   0F0F E7            pop d
2102   0F10 FD 43         mov [d], b
2103   0F12             ;; return heap_top - bytes; 
2104   0F12 3B 44 14      mov d, _heap_top ; $heap_top
2105   0F15 2A            mov b, [d]
2106   0F16             ; START TERMS
2107   0F16 D7            push a
2108   0F17 11            mov a, b
2109   0F18 FA 05 00      lea d, [bp + 5] ; $bytes
2110   0F1B 2A            mov b, [d]
2111   0F1C 60            sub a, b
2112   0F1D 27            mov b, a
2113   0F1E E4            pop a
2114   0F1F             ; END TERMS
2115   0F1F F9            leave
2116   0F20 09            ret
2117   0F21             
2118   0F21             free:
2119   0F21 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2120   0F24             ;; return heap_top = heap_top - bytes; 
2121   0F24 3B 44 14      mov d, _heap_top ; $heap_top
2122   0F27 DA            push d
2123   0F28 3B 44 14      mov d, _heap_top ; $heap_top
2124   0F2B 2A            mov b, [d]
2125   0F2C             ; START TERMS
2126   0F2C D7            push a
2127   0F2D 11            mov a, b
2128   0F2E FA 05 00      lea d, [bp + 5] ; $bytes
2129   0F31 2A            mov b, [d]
2130   0F32 60            sub a, b
2131   0F33 27            mov b, a
2132   0F34 E4            pop a
2133   0F35             ; END TERMS
2134   0F35 E7            pop d
2135   0F36 FD 43         mov [d], b
2136   0F38 F9            leave
2137   0F39 09            ret
2138   0F3A             
2139   0F3A             exit:
2140   0F3A F8 00 00      enter 0 ; (push bp; mov bp, sp)
2141   0F3D             
2142   0F3D             ; --- BEGIN INLINE ASM BLOCK
2143   0F3D 05 0B         syscall sys_terminate_proc
2144   0F3F             ; --- END INLINE ASM BLOCK
2145   0F3F             
2146   0F3F F9            leave
2147   0F40 09            ret
2148   0F41             
2149   0F41             load_hex:
2150   0F41 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2151   0F44             ; $temp 
2152   0F44 52 02 00      sub sp, 2
2153   0F47             ;; temp = alloc(32768); 
2154   0F47 FA FF FF      lea d, [bp + -1] ; $temp
2155   0F4A DA            push d
2156   0F4B 26 00 80      mov b, $8000
2157   0F4E FD AB         swp b
2158   0F50 D8            push b
2159   0F51 07 FB 0E      call alloc
2160   0F54 51 02 00      add sp, 2
2161   0F57 E7            pop d
2162   0F58 FD 43         mov [d], b
2163   0F5A             
2164   0F5A             ; --- BEGIN INLINE ASM BLOCK
2165   0F5A               
2166   0F5A               
2167   0F5A               
2168   0F5A               
2169   0F5A               
2170   0F5A             _load_hex:
2171   0F5A D7            push a
2172   0F5B D8            push b
2173   0F5C DA            push d
2174   0F5D E2            push si
2175   0F5E E3            push di
2176   0F5F 52 00 80      sub sp, $8000      
2177   0F62 38 00 00      mov c, 0
2178   0F65 48            mov a, sp
2179   0F66 77            inc a
2180   0F67 3C            mov d, a          
2181   0F68 07 FC 10      call _gets        
2182   0F6B 4D            mov si, a
2183   0F6C             __load_hex_loop:
2184   0F6C F6            lodsb             
2185   0F6D B9 00         cmp al, 0         
2186   0F6F C6 7D 0F      jz __load_hex_ret
2187   0F72 36            mov bh, al
2188   0F73 F6            lodsb
2189   0F74 2F            mov bl, al
2190   0F75 07 B2 10      call _atoi        
2191   0F78 F7            stosb             
2192   0F79 78            inc c
2193   0F7A 0A 6C 0F      jmp __load_hex_loop
2194   0F7D             __load_hex_ret:
2195   0F7D 51 00 80      add sp, $8000
2196   0F80 F0            pop di
2197   0F81 EF            pop si
2198   0F82 E7            pop d
2199   0F83 E5            pop b
2200   0F84 E4            pop a
2201   0F85             ; --- END INLINE ASM BLOCK
2202   0F85             
2203   0F85 F9            leave
2204   0F86 09            ret
2205   0F87             
2206   0F87             getparam:
2207   0F87 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2208   0F8A             ; $data 
2209   0F8A 52 01 00      sub sp, 1
2210   0F8D             
2211   0F8D             ; --- BEGIN INLINE ASM BLOCK
2212   0F8D 19 04         mov al, 4
2213   0F8F FA 05 00      lea d, [bp + 5] ; $address
2214   0F92 FD 2A         mov d, [d]
2215   0F94 05 0C         syscall sys_system
2216   0F96 FA 00 00      lea d, [bp + 0] ; $data
2217   0F99 FD 3E         mov [d], bl
2218   0F9B             ; --- END INLINE ASM BLOCK
2219   0F9B             
2220   0F9B             ;; return data; 
2221   0F9B FA 00 00      lea d, [bp + 0] ; $data
2222   0F9E 32            mov bl, [d]
2223   0F9F A7 00         mov bh, 0
2224   0FA1 F9            leave
2225   0FA2 09            ret
2226   0FA3             
2227   0FA3             clear:
2228   0FA3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2229   0FA6             ;; print("\033[2J\033[H"); 
2230   0FA6 26 3A 14      mov b, __s2 ; "\033[2J\033[H"
2231   0FA9 FD AB         swp b
2232   0FAB D8            push b
2233   0FAC 07 C0 0E      call print
2234   0FAF 51 02 00      add sp, 2
2235   0FB2 F9            leave
2236   0FB3 09            ret
2237   0FB4             
2238   0FB4             printun:
2239   0FB4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2240   0FB7             ;; print(prompt); 
2241   0FB7 FA 05 00      lea d, [bp + 5] ; $prompt
2242   0FBA 2A            mov b, [d]
2243   0FBB FD AB         swp b
2244   0FBD D8            push b
2245   0FBE 07 C0 0E      call print
2246   0FC1 51 02 00      add sp, 2
2247   0FC4             ;; print_unsigned(n); 
2248   0FC4 FA 07 00      lea d, [bp + 7] ; $n
2249   0FC7 2A            mov b, [d]
2250   0FC8 FD AB         swp b
2251   0FCA D8            push b
2252   0FCB 07 90 0D      call print_unsigned
2253   0FCE 51 02 00      add sp, 2
2254   0FD1             ;; print("\n"); 
2255   0FD1 26 42 14      mov b, __s3 ; "\n"
2256   0FD4 FD AB         swp b
2257   0FD6 D8            push b
2258   0FD7 07 C0 0E      call print
2259   0FDA 51 02 00      add sp, 2
2260   0FDD F9            leave
2261   0FDE 09            ret
2262   0FDF             
2263   0FDF             printsn:
2264   0FDF F8 00 00      enter 0 ; (push bp; mov bp, sp)
2265   0FE2             ;; print(prompt); 
2266   0FE2 FA 05 00      lea d, [bp + 5] ; $prompt
2267   0FE5 2A            mov b, [d]
2268   0FE6 FD AB         swp b
2269   0FE8 D8            push b
2270   0FE9 07 C0 0E      call print
2271   0FEC 51 02 00      add sp, 2
2272   0FEF             ;; print_signed(n); 
2273   0FEF FA 07 00      lea d, [bp + 7] ; $n
2274   0FF2 2A            mov b, [d]
2275   0FF3 FD AB         swp b
2276   0FF5 D8            push b
2277   0FF6 07 E6 0A      call print_signed
2278   0FF9 51 02 00      add sp, 2
2279   0FFC             ;; print("\n"); 
2280   0FFC 26 42 14      mov b, __s3 ; "\n"
2281   0FFF FD AB         swp b
2282   1001 D8            push b
2283   1002 07 C0 0E      call print
2284   1005 51 02 00      add sp, 2
2285   1008 F9            leave
2286   1009 09            ret
2287   100A             
2288   100A             include_stdio_asm:
2289   100A F8 00 00      enter 0 ; (push bp; mov bp, sp)
2290   100D             
2291   100D             ; --- BEGIN INLINE ASM BLOCK
2292   100D             .include "lib/asm/stdio.asm"
0001+  100D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  100D             ; stdio.s
0003+  100D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  100D             .include "lib/asm/string.asm"
0001++ 100D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 100D             ; string.s
0003++ 100D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 100D             
0005++ 100D             
0006++ 100D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 100D             ; _strrev
0008++ 100D             ; reverse a string
0009++ 100D             ; D = string address
0010++ 100D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 100D             ; 01234
0012++ 100D             _strrev:
0013++ 100D 4B          	pusha
0014++ 100E 07 54 10    	call _strlen	; length in C
0015++ 1011 12          	mov a, c
0016++ 1012 AF 01 00    	cmp a, 1
0017++ 1015 D0 2F 10    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 1018 7D          	dec a
0019++ 1019 FD 4E       	mov si, d	; beginning of string
0020++ 101B FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 101D 59          	add d, a	; end of string
0022++ 101E 12          	mov a, c
0023++ 101F FD 9B       	shr a		; divide by 2
0024++ 1021 39          	mov c, a	; C now counts the steps
0025++ 1022             _strrev_L0:
0026++ 1022 32          	mov bl, [d]	; save load right-side char into BL
0027++ 1023 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 1024 3E          	mov [d], al	; store left char into right side
0029++ 1025 1B          	mov al, bl
0030++ 1026 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 1027 7E          	dec c
0032++ 1028 7F          	dec d
0033++ 1029 C2 00 00    	cmp c, 0
0034++ 102C C7 22 10    	jne _strrev_L0
0035++ 102F             _strrev_end:
0036++ 102F 4C          	popa
0037++ 1030 09          	ret
0038++ 1031             	
0039++ 1031             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 1031             ; _strchr
0041++ 1031             ; search string in D for char in AL
0042++ 1031             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 1031             _strchr:
0044++ 1031             _strchr_L0:
0045++ 1031 32          	mov bl, [d]
0046++ 1032 C1 00       	cmp bl, 0
0047++ 1034 C6 3F 10    	je _strchr_end
0048++ 1037 BA          	cmp al, bl
0049++ 1038 C6 3F 10    	je _strchr_end
0050++ 103B 79          	inc d
0051++ 103C 0A 31 10    	jmp _strchr_L0
0052++ 103F             _strchr_end:
0053++ 103F 1B          	mov al, bl
0054++ 1040 09          	ret
0055++ 1041             
0056++ 1041             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 1041             ; _strstr
0058++ 1041             ; find sub-string
0059++ 1041             ; str1 in SI
0060++ 1041             ; str2 in DI
0061++ 1041             ; SI points to end of source string
0062++ 1041             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 1041             _strstr:
0064++ 1041 DB          	push al
0065++ 1042 DA          	push d
0066++ 1043 E3          	push di
0067++ 1044             _strstr_loop:
0068++ 1044 F3          	cmpsb					; compare a byte of the strings
0069++ 1045 C7 50 10    	jne _strstr_ret
0070++ 1048 FC 00 00    	lea d, [di + 0]
0071++ 104B BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 104D C7 44 10    	jne _strstr_loop				; equal chars but not at end
0073++ 1050             _strstr_ret:
0074++ 1050 F0          	pop di
0075++ 1051 E7          	pop d
0076++ 1052 E8          	pop al
0077++ 1053 09          	ret
0078++ 1054             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1054             ; length of null terminated string
0080++ 1054             ; result in C
0081++ 1054             ; pointer in D
0082++ 1054             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1054             _strlen:
0084++ 1054 DA          	push d
0085++ 1055 38 00 00    	mov c, 0
0086++ 1058             _strlen_L1:
0087++ 1058 BD 00       	cmp byte [d], 0
0088++ 105A C6 62 10    	je _strlen_ret
0089++ 105D 79          	inc d
0090++ 105E 78          	inc c
0091++ 105F 0A 58 10    	jmp _strlen_L1
0092++ 1062             _strlen_ret:
0093++ 1062 E7          	pop d
0094++ 1063 09          	ret
0095++ 1064             
0096++ 1064             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1064             ; STRCMP
0098++ 1064             ; compare two strings
0099++ 1064             ; str1 in SI
0100++ 1064             ; str2 in DI
0101++ 1064             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 1064             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1064             _strcmp:
0104++ 1064 DB          	push al
0105++ 1065 DA          	push d
0106++ 1066 E3          	push di
0107++ 1067 E2          	push si
0108++ 1068             _strcmp_loop:
0109++ 1068 F3          	cmpsb					; compare a byte of the strings
0110++ 1069 C7 74 10    	jne _strcmp_ret
0111++ 106C FB FF FF    	lea d, [si +- 1]
0112++ 106F BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1071 C7 68 10    	jne _strcmp_loop				; equal chars but not at end
0114++ 1074             _strcmp_ret:
0115++ 1074 EF          	pop si
0116++ 1075 F0          	pop di
0117++ 1076 E7          	pop d
0118++ 1077 E8          	pop al
0119++ 1078 09          	ret
0120++ 1079             
0121++ 1079             
0122++ 1079             ; STRCPY
0123++ 1079             ; copy null terminated string from SI to DI
0124++ 1079             ; source in SI
0125++ 1079             ; destination in DI
0126++ 1079             _strcpy:
0127++ 1079 E2          	push si
0128++ 107A E3          	push di
0129++ 107B DB          	push al
0130++ 107C             _strcpy_L1:
0131++ 107C F6          	lodsb
0132++ 107D F7          	stosb
0133++ 107E B9 00       	cmp al, 0
0134++ 1080 C7 7C 10    	jne _strcpy_L1
0135++ 1083             _strcpy_end:
0136++ 1083 E8          	pop al
0137++ 1084 F0          	pop di
0138++ 1085 EF          	pop si
0139++ 1086 09          	ret
0140++ 1087             
0141++ 1087             ; STRCAT
0142++ 1087             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 1087             ; source in SI
0144++ 1087             ; destination in DI
0145++ 1087             _strcat:
0146++ 1087 E2          	push si
0147++ 1088 E3          	push di
0148++ 1089 D7          	push a
0149++ 108A DA          	push d
0150++ 108B 50          	mov a, di
0151++ 108C 3C          	mov d, a
0152++ 108D             _strcat_goto_end_L1:
0153++ 108D BD 00       	cmp byte[d], 0
0154++ 108F C6 96 10    	je _strcat_start
0155++ 1092 79          	inc d
0156++ 1093 0A 8D 10    	jmp _strcat_goto_end_L1
0157++ 1096             _strcat_start:
0158++ 1096 FD 50       	mov di, d
0159++ 1098             _strcat_L1:
0160++ 1098 F6          	lodsb
0161++ 1099 F7          	stosb
0162++ 109A B9 00       	cmp al, 0
0163++ 109C C7 98 10    	jne _strcat_L1
0164++ 109F             _strcat_end:
0165++ 109F E7          	pop d
0166++ 10A0 E4          	pop a
0167++ 10A1 F0          	pop di
0168++ 10A2 EF          	pop si
0169++ 10A3 09          	ret
0170++ 10A4             
0171++ 10A4             
0005+  10A4             
0006+  10A4             
0007+  10A4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  10A4             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  10A4             ; ASCII in BL
0010+  10A4             ; result in AL
0011+  10A4             ; ascii for F = 0100 0110
0012+  10A4             ; ascii for 9 = 0011 1001
0013+  10A4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  10A4             hex_ascii_encode:
0015+  10A4 1B            mov al, bl
0016+  10A5 93 40         test al, $40        ; test if letter or number
0017+  10A7 C7 AD 10      jnz hex_letter
0018+  10AA 87 0F         and al, $0F        ; get number
0019+  10AC 09            ret
0020+  10AD             hex_letter:
0021+  10AD 87 0F         and al, $0F        ; get letter
0022+  10AF 6A 09         add al, 9
0023+  10B1 09            ret
0024+  10B2             
0025+  10B2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  10B2             ; ATOI
0027+  10B2             ; 2 letter hex string in B
0028+  10B2             ; 8bit integer returned in AL
0029+  10B2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  10B2             _atoi:
0031+  10B2 D8            push b
0032+  10B3 07 A4 10      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  10B6 30            mov bl, bh
0034+  10B7 DB            push al          ; save a
0035+  10B8 07 A4 10      call hex_ascii_encode
0036+  10BB EA            pop bl  
0037+  10BC FD 9E 04      shl al, 4
0038+  10BF 8C            or al, bl
0039+  10C0 E5            pop b
0040+  10C1 09            ret  
0041+  10C2             
0042+  10C2             
0043+  10C2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  10C2             ; scanf
0045+  10C2             ; no need for explanations!
0046+  10C2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  10C2             scanf:
0048+  10C2 09            ret
0049+  10C3             
0050+  10C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  10C3             ; ITOA
0052+  10C3             ; 8bit value in BL
0053+  10C3             ; 2 byte ASCII result in A
0054+  10C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  10C3             _itoa:
0056+  10C3 DA            push d
0057+  10C4 D8            push b
0058+  10C5 A7 00         mov bh, 0
0059+  10C7 FD A4 04      shr bl, 4  
0060+  10CA 74            mov d, b
0061+  10CB 1F 73 13      mov al, [d + s_hex_digits]
0062+  10CE 23            mov ah, al
0063+  10CF               
0064+  10CF E5            pop b
0065+  10D0 D8            push b
0066+  10D1 A7 00         mov bh, 0
0067+  10D3 FD 87 0F      and bl, $0F
0068+  10D6 74            mov d, b
0069+  10D7 1F 73 13      mov al, [d + s_hex_digits]
0070+  10DA E5            pop b
0071+  10DB E7            pop d
0072+  10DC 09            ret
0073+  10DD             
0074+  10DD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  10DD             ; HEX STRING TO BINARY
0076+  10DD             ; di = destination address
0077+  10DD             ; si = source
0078+  10DD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  10DD             _hex_to_int:
0080+  10DD             _hex_to_int_L1:
0081+  10DD F6            lodsb          ; load from [SI] to AL
0082+  10DE B9 00         cmp al, 0        ; check if ASCII 0
0083+  10E0 C6 ED 10      jz _hex_to_int_ret
0084+  10E3 36            mov bh, al
0085+  10E4 F6            lodsb
0086+  10E5 2F            mov bl, al
0087+  10E6 07 B2 10      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  10E9 F7            stosb          ; store AL to [DI]
0089+  10EA 0A DD 10      jmp _hex_to_int_L1
0090+  10ED             _hex_to_int_ret:
0091+  10ED 09            ret    
0092+  10EE             
0093+  10EE             
0094+  10EE             
0095+  10EE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  10EE             ; GETCHAR
0097+  10EE             ; char in ah
0098+  10EE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  10EE             getch:
0100+  10EE DB            push al
0101+  10EF             getch_retry:
0102+  10EF 19 01         mov al, 1
0103+  10F1 05 03         syscall sys_io      ; receive in AH
0104+  10F3 E8            pop al
0105+  10F4 09            ret
0106+  10F5             
0107+  10F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  10F5             ; PUTCHAR
0109+  10F5             ; char in ah
0110+  10F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  10F5             _putchar:
0112+  10F5 D7            push a
0113+  10F6 19 00         mov al, 0
0114+  10F8 05 03         syscall sys_io      ; char in AH
0115+  10FA E4            pop a
0116+  10FB 09            ret
0117+  10FC             
0118+  10FC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  10FC             ;; INPUT A STRING
0120+  10FC             ;; terminates with null
0121+  10FC             ;; pointer in D
0122+  10FC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  10FC             _gets:
0124+  10FC D7            push a
0125+  10FD DA            push d
0126+  10FE             _gets_loop:
0127+  10FE 19 01         mov al, 1
0128+  1100 05 03         syscall sys_io      ; receive in AH
0129+  1102 B9 00         cmp al, 0        ; check error code (AL)
0130+  1104 C6 FE 10      je _gets_loop      ; if no char received, retry
0131+  1107             
0132+  1107 76 1B         cmp ah, 27
0133+  1109 C6 2A 11      je _gets_ansi_esc
0134+  110C 76 0A         cmp ah, $0A        ; LF
0135+  110E C6 95 11      je _gets_end
0136+  1111 76 0D         cmp ah, $0D        ; CR
0137+  1113 C6 95 11      je _gets_end
0138+  1116 76 5C         cmp ah, $5C        ; '\\'
0139+  1118 C6 56 11      je _gets_escape
0140+  111B               
0141+  111B 76 08         cmp ah, $08      ; check for backspace
0142+  111D C6 26 11      je _gets_backspace
0143+  1120             
0144+  1120 1A            mov al, ah
0145+  1121 3E            mov [d], al
0146+  1122 79            inc d
0147+  1123 0A FE 10      jmp _gets_loop
0148+  1126             _gets_backspace:
0149+  1126 7F            dec d
0150+  1127 0A FE 10      jmp _gets_loop
0151+  112A             _gets_ansi_esc:
0152+  112A 19 01         mov al, 1
0153+  112C 05 03         syscall sys_io        ; receive in AH without echo
0154+  112E B9 00         cmp al, 0          ; check error code (AL)
0155+  1130 C6 2A 11      je _gets_ansi_esc    ; if no char received, retry
0156+  1133 76 5B         cmp ah, '['
0157+  1135 C7 FE 10      jne _gets_loop
0158+  1138             _gets_ansi_esc_2:
0159+  1138 19 01         mov al, 1
0160+  113A 05 03         syscall sys_io          ; receive in AH without echo
0161+  113C B9 00         cmp al, 0            ; check error code (AL)
0162+  113E C6 38 11      je _gets_ansi_esc_2  ; if no char received, retry
0163+  1141 76 44         cmp ah, 'D'
0164+  1143 C6 4E 11      je _gets_left_arrow
0165+  1146 76 43         cmp ah, 'C'
0166+  1148 C6 52 11      je _gets_right_arrow
0167+  114B 0A FE 10      jmp _gets_loop
0168+  114E             _gets_left_arrow:
0169+  114E 7F            dec d
0170+  114F 0A FE 10      jmp _gets_loop
0171+  1152             _gets_right_arrow:
0172+  1152 79            inc d
0173+  1153 0A FE 10      jmp _gets_loop
0174+  1156             _gets_escape:
0175+  1156 19 01         mov al, 1
0176+  1158 05 03         syscall sys_io      ; receive in AH
0177+  115A B9 00         cmp al, 0        ; check error code (AL)
0178+  115C C6 56 11      je _gets_escape      ; if no char received, retry
0179+  115F 76 6E         cmp ah, 'n'
0180+  1161 C6 80 11      je _gets_LF
0181+  1164 76 72         cmp ah, 'r'
0182+  1166 C6 87 11      je _gets_CR
0183+  1169 76 30         cmp ah, '0'
0184+  116B C6 8E 11      je _gets_NULL
0185+  116E 76 5C         cmp ah, $5C  ; '\'
0186+  1170 C6 79 11      je _gets_slash
0187+  1173 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0188+  1174 3E            mov [d], al
0189+  1175 79            inc d
0190+  1176 0A FE 10      jmp _gets_loop
0191+  1179             _gets_slash:
0192+  1179 19 5C         mov al, $5C
0193+  117B 3E            mov [d], al
0194+  117C 79            inc d
0195+  117D 0A FE 10      jmp _gets_loop
0196+  1180             _gets_LF:
0197+  1180 19 0A         mov al, $0A
0198+  1182 3E            mov [d], al
0199+  1183 79            inc d
0200+  1184 0A FE 10      jmp _gets_loop
0201+  1187             _gets_CR:
0202+  1187 19 0D         mov al, $0D
0203+  1189 3E            mov [d], al
0204+  118A 79            inc d
0205+  118B 0A FE 10      jmp _gets_loop
0206+  118E             _gets_NULL:
0207+  118E 19 00         mov al, $00
0208+  1190 3E            mov [d], al
0209+  1191 79            inc d
0210+  1192 0A FE 10      jmp _gets_loop
0211+  1195             _gets_end:
0212+  1195 19 00         mov al, 0
0213+  1197 3E            mov [d], al        ; terminate string
0214+  1198 E7            pop d
0215+  1199 E4            pop a
0216+  119A 09            ret
0217+  119B             
0218+  119B             
0219+  119B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0220+  119B             ;; INPUT TEXT
0221+  119B             ;; terminated with CTRL+D
0222+  119B             ;; pointer in D
0223+  119B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0224+  119B             _gettxt:
0225+  119B D7            push a
0226+  119C DA            push d
0227+  119D             _gettxt_loop:
0228+  119D 19 01         mov al, 1
0229+  119F 05 03         syscall sys_io      ; receive in AH
0230+  11A1 B9 00         cmp al, 0        ; check error code (AL)
0231+  11A3 C6 9D 11      je _gettxt_loop    ; if no char received, retry
0232+  11A6 76 04         cmp ah, 4      ; EOT
0233+  11A8 C6 E6 11      je _gettxt_end
0234+  11AB 76 08         cmp ah, $08      ; check for backspace
0235+  11AD C6 E2 11      je _gettxt_backspace
0236+  11B0 76 5C         cmp ah, $5C        ; '\'
0237+  11B2 C6 BB 11      je _gettxt_escape
0238+  11B5 1A            mov al, ah
0239+  11B6 3E            mov [d], al
0240+  11B7 79            inc d
0241+  11B8 0A 9D 11      jmp _gettxt_loop
0242+  11BB             _gettxt_escape:
0243+  11BB 19 01         mov al, 1
0244+  11BD 05 03         syscall sys_io      ; receive in AH
0245+  11BF B9 00         cmp al, 0        ; check error code (AL)
0246+  11C1 C6 BB 11      je _gettxt_escape    ; if no char received, retry
0247+  11C4 76 6E         cmp ah, 'n'
0248+  11C6 C6 D4 11      je _gettxt_LF
0249+  11C9 76 72         cmp ah, 'r'
0250+  11CB C6 DB 11      je _gettxt_CR
0251+  11CE 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0252+  11CF 3E            mov [d], al
0253+  11D0 79            inc d
0254+  11D1 0A 9D 11      jmp _gettxt_loop
0255+  11D4             _gettxt_LF:
0256+  11D4 19 0A         mov al, $0A
0257+  11D6 3E            mov [d], al
0258+  11D7 79            inc d
0259+  11D8 0A 9D 11      jmp _gettxt_loop
0260+  11DB             _gettxt_CR:
0261+  11DB 19 0D         mov al, $0D
0262+  11DD 3E            mov [d], al
0263+  11DE 79            inc d
0264+  11DF 0A 9D 11      jmp _gettxt_loop
0265+  11E2             _gettxt_backspace:
0266+  11E2 7F            dec d
0267+  11E3 0A 9D 11      jmp _gettxt_loop
0268+  11E6             _gettxt_end:
0269+  11E6 19 00         mov al, 0
0270+  11E8 3E            mov [d], al        ; terminate string
0271+  11E9 E7            pop d
0272+  11EA E4            pop a
0273+  11EB 09            ret
0274+  11EC             
0275+  11EC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  11EC             ; PRINT NEW LINE
0277+  11EC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0278+  11EC             printnl:
0279+  11EC D7            push a
0280+  11ED 10 00 0A      mov a, $0A00
0281+  11F0 05 03         syscall sys_io
0282+  11F2 10 00 0D      mov a, $0D00
0283+  11F5 05 03         syscall sys_io
0284+  11F7 E4            pop a
0285+  11F8 09            ret
0286+  11F9             
0287+  11F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  11F9             ; _strtoint
0289+  11F9             ; 4 digit hex string number in d
0290+  11F9             ; integer returned in A
0291+  11F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0292+  11F9             _strtointx:
0293+  11F9 D8            push b
0294+  11FA 32            mov bl, [d]
0295+  11FB 37            mov bh, bl
0296+  11FC 33 01 00      mov bl, [d + 1]
0297+  11FF 07 B2 10      call _atoi        ; convert to int in AL
0298+  1202 23            mov ah, al        ; move to AH
0299+  1203 33 02 00      mov bl, [d + 2]
0300+  1206 37            mov bh, bl
0301+  1207 33 03 00      mov bl, [d + 3]
0302+  120A 07 B2 10      call _atoi        ; convert to int in AL
0303+  120D E5            pop b
0304+  120E 09            ret
0305+  120F             
0306+  120F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0307+  120F             ; _strtoint
0308+  120F             ; 5 digit base10 string number in d
0309+  120F             ; integer returned in A
0310+  120F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0311+  120F             _strtoint:
0312+  120F E2            push si
0313+  1210 D8            push b
0314+  1211 D9            push c
0315+  1212 DA            push d
0316+  1213 07 54 10      call _strlen      ; get string length in C
0317+  1216 7E            dec c
0318+  1217 FD 4E         mov si, d
0319+  1219 12            mov a, c
0320+  121A FD 99         shl a
0321+  121C 3B 8B 13      mov d, table_power
0322+  121F 59            add d, a
0323+  1220 38 00 00      mov c, 0
0324+  1223             _strtoint_L0:
0325+  1223 F6            lodsb      ; load ASCII to al
0326+  1224 B9 00         cmp al, 0
0327+  1226 C6 39 12      je _strtoint_end
0328+  1229 6F 30         sub al, $30    ; make into integer
0329+  122B 22 00         mov ah, 0
0330+  122D 2A            mov b, [d]
0331+  122E AC            mul a, b      ; result in B since it fits in 16bits
0332+  122F 11            mov a, b
0333+  1230 28            mov b, c
0334+  1231 54            add a, b
0335+  1232 39            mov c, a
0336+  1233 63 02 00      sub d, 2
0337+  1236 0A 23 12      jmp _strtoint_L0
0338+  1239             _strtoint_end:
0339+  1239 12            mov a, c
0340+  123A E7            pop d
0341+  123B E6            pop c
0342+  123C E5            pop b
0343+  123D EF            pop si
0344+  123E 09            ret
0345+  123F             
0346+  123F             
0347+  123F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0348+  123F             ; PRINT NULL TERMINATED STRING
0349+  123F             ; pointer in D
0350+  123F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0351+  123F             _puts:
0352+  123F D7            push a
0353+  1240 DA            push d
0354+  1241             _puts_L1:
0355+  1241 1E            mov al, [d]
0356+  1242 B9 00         cmp al, 0
0357+  1244 C6 50 12      jz _puts_END
0358+  1247 23            mov ah, al
0359+  1248 19 00         mov al, 0
0360+  124A 05 03         syscall sys_io
0361+  124C 79            inc d
0362+  124D 0A 41 12      jmp _puts_L1
0363+  1250             _puts_END:
0364+  1250 E7            pop d
0365+  1251 E4            pop a
0366+  1252 09            ret
0367+  1253             
0368+  1253             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0369+  1253             ; PRINT N SIZE STRING
0370+  1253             ; pointer in D
0371+  1253             ; size in C
0372+  1253             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0373+  1253             _putsn:
0374+  1253 DB            push al
0375+  1254 DA            push d
0376+  1255 D9            push c
0377+  1256             _putsn_L0:
0378+  1256 1E            mov al, [d]
0379+  1257 23            mov ah, al
0380+  1258 19 00         mov al, 0
0381+  125A 05 03         syscall sys_io
0382+  125C 79            inc d
0383+  125D 7E            dec c  
0384+  125E C2 00 00      cmp c, 0
0385+  1261 C7 56 12      jne _putsn_L0
0386+  1264             _putsn_end:
0387+  1264 E6            pop c
0388+  1265 E7            pop d
0389+  1266 E8            pop al
0390+  1267 09            ret
0391+  1268             
0392+  1268             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0393+  1268             ; print 16bit decimal number
0394+  1268             ; input number in A
0395+  1268             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0396+  1268             print_u16d:
0397+  1268 D7            push a
0398+  1269 D8            push b
0399+  126A 26 10 27      mov b, 10000
0400+  126D AE            div a, b      ; get 10000's coeff.
0401+  126E 07 90 12      call print_number
0402+  1271 11            mov a, b
0403+  1272 26 E8 03      mov b, 1000
0404+  1275 AE            div a, b      ; get 1000's coeff.
0405+  1276 07 90 12      call print_number
0406+  1279 11            mov a, b
0407+  127A 26 64 00      mov b, 100
0408+  127D AE            div a, b
0409+  127E 07 90 12      call print_number
0410+  1281 11            mov a, b
0411+  1282 26 0A 00      mov b, 10
0412+  1285 AE            div a, b
0413+  1286 07 90 12      call print_number
0414+  1289 1B            mov al, bl      ; 1's coeff in bl
0415+  128A 07 90 12      call print_number
0416+  128D E5            pop b
0417+  128E E4            pop a
0418+  128F 09            ret
0419+  1290             
0420+  1290             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0421+  1290             ; print AL
0422+  1290             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0423+  1290             print_number:
0424+  1290 6A 30         add al, $30
0425+  1292 23            mov ah, al
0426+  1293 07 F5 10      call _putchar
0427+  1296 09            ret
0428+  1297             
0429+  1297             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0430+  1297             ; PRINT 16BIT HEX INTEGER
0431+  1297             ; integer value in reg B
0432+  1297             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  1297             print_u16x:
0434+  1297 D7            push a
0435+  1298 D8            push b
0436+  1299 DD            push bl
0437+  129A 30            mov bl, bh
0438+  129B 07 C3 10      call _itoa        ; convert bh to char in A
0439+  129E 2F            mov bl, al        ; save al
0440+  129F 19 00         mov al, 0
0441+  12A1 05 03         syscall sys_io        ; display AH
0442+  12A3 24            mov ah, bl        ; retrieve al
0443+  12A4 19 00         mov al, 0
0444+  12A6 05 03         syscall sys_io        ; display AL
0445+  12A8             
0446+  12A8 EA            pop bl
0447+  12A9 07 C3 10      call _itoa        ; convert bh to char in A
0448+  12AC 2F            mov bl, al        ; save al
0449+  12AD 19 00         mov al, 0
0450+  12AF 05 03         syscall sys_io        ; display AH
0451+  12B1 24            mov ah, bl        ; retrieve al
0452+  12B2 19 00         mov al, 0
0453+  12B4 05 03         syscall sys_io        ; display AL
0454+  12B6             
0455+  12B6 E5            pop b
0456+  12B7 E4            pop a
0457+  12B8 09            ret
0458+  12B9             
0459+  12B9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0460+  12B9             ; INPUT 16BIT HEX INTEGER
0461+  12B9             ; read 16bit integer into A
0462+  12B9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0463+  12B9             scan_u16x:
0464+  12B9 F8 10 00      enter 16
0465+  12BC D8            push b
0466+  12BD DA            push d
0467+  12BE             
0468+  12BE FA F1 FF      lea d, [bp + -15]
0469+  12C1 07 FC 10      call _gets        ; get number
0470+  12C4             
0471+  12C4 32            mov bl, [d]
0472+  12C5 37            mov bh, bl
0473+  12C6 33 01 00      mov bl, [d + 1]
0474+  12C9 07 B2 10      call _atoi        ; convert to int in AL
0475+  12CC 23            mov ah, al        ; move to AH
0476+  12CD             
0477+  12CD 33 02 00      mov bl, [d + 2]
0478+  12D0 37            mov bh, bl
0479+  12D1 33 03 00      mov bl, [d + 3]
0480+  12D4 07 B2 10      call _atoi        ; convert to int in AL
0481+  12D7             
0482+  12D7 E7            pop d
0483+  12D8 E5            pop b
0484+  12D9 F9            leave
0485+  12DA 09            ret
0486+  12DB             
0487+  12DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0488+  12DB             ; PRINT 8bit HEX INTEGER
0489+  12DB             ; integer value in reg bl
0490+  12DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0491+  12DB             print_u8x:
0492+  12DB D7            push a
0493+  12DC DD            push bl
0494+  12DD             
0495+  12DD 07 C3 10      call _itoa        ; convert bl to char in A
0496+  12E0 2F            mov bl, al        ; save al
0497+  12E1 19 00         mov al, 0
0498+  12E3 05 03         syscall sys_io        ; display AH
0499+  12E5 24            mov ah, bl        ; retrieve al
0500+  12E6 19 00         mov al, 0
0501+  12E8 05 03         syscall sys_io        ; display AL
0502+  12EA             
0503+  12EA EA            pop bl
0504+  12EB E4            pop a
0505+  12EC 09            ret
0506+  12ED             
0507+  12ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0508+  12ED             ; print 8bit decimal unsigned number
0509+  12ED             ; input number in AL
0510+  12ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0511+  12ED             print_u8d:
0512+  12ED D7            push a
0513+  12EE D8            push b
0514+  12EF             
0515+  12EF 22 00         mov ah, 0
0516+  12F1 26 64 00      mov b, 100
0517+  12F4 AE            div a, b
0518+  12F5 D8            push b      ; save remainder
0519+  12F6 B9 00         cmp al, 0
0520+  12F8 C6 02 13      je skip100
0521+  12FB 6A 30         add al, $30
0522+  12FD 23            mov ah, al
0523+  12FE 19 00         mov al, 0
0524+  1300 05 03         syscall sys_io  ; print coeff
0525+  1302             skip100:
0526+  1302 E4            pop a
0527+  1303 22 00         mov ah, 0
0528+  1305 26 0A 00      mov b, 10
0529+  1308 AE            div a, b
0530+  1309 D8            push b      ; save remainder
0531+  130A B9 00         cmp al, 0
0532+  130C C6 16 13      je skip10
0533+  130F 6A 30         add al, $30
0534+  1311 23            mov ah, al
0535+  1312 19 00         mov al, 0
0536+  1314 05 03         syscall sys_io  ; print coeff
0537+  1316             skip10:
0538+  1316 E4            pop a
0539+  1317 1B            mov al, bl
0540+  1318 6A 30         add al, $30
0541+  131A 23            mov ah, al
0542+  131B 19 00         mov al, 0
0543+  131D 05 03         syscall sys_io  ; print coeff
0544+  131F E5            pop b
0545+  1320 E4            pop a
0546+  1321 09            ret
0547+  1322             
0548+  1322             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0549+  1322             ; INPUT 8BIT HEX INTEGER
0550+  1322             ; read 8bit integer into AL
0551+  1322             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0552+  1322             scan_u8x:
0553+  1322 F8 04 00      enter 4
0554+  1325 D8            push b
0555+  1326 DA            push d
0556+  1327             
0557+  1327 FA FD FF      lea d, [bp + -3]
0558+  132A 07 FC 10      call _gets        ; get number
0559+  132D             
0560+  132D 32            mov bl, [d]
0561+  132E 37            mov bh, bl
0562+  132F 33 01 00      mov bl, [d + 1]
0563+  1332 07 B2 10      call _atoi        ; convert to int in AL
0564+  1335             
0565+  1335 E7            pop d
0566+  1336 E5            pop b
0567+  1337 F9            leave
0568+  1338 09            ret
0569+  1339             
0570+  1339             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  1339             ; input decimal number
0572+  1339             ; result in A
0573+  1339             ; 655'\0'
0574+  1339             ; low--------high
0575+  1339             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0576+  1339             scan_u16d:
0577+  1339 F8 08 00      enter 8
0578+  133C E2            push si
0579+  133D D8            push b
0580+  133E D9            push c
0581+  133F DA            push d
0582+  1340 FA F9 FF      lea d, [bp +- 7]
0583+  1343 07 FC 10      call _gets
0584+  1346 07 54 10      call _strlen      ; get string length in C
0585+  1349 7E            dec c
0586+  134A FD 4E         mov si, d
0587+  134C 12            mov a, c
0588+  134D FD 99         shl a
0589+  134F 3B 8B 13      mov d, table_power
0590+  1352 59            add d, a
0591+  1353 38 00 00      mov c, 0
0592+  1356             mul_loop:
0593+  1356 F6            lodsb      ; load ASCII to al
0594+  1357 B9 00         cmp al, 0
0595+  1359 C6 6C 13      je mul_exit
0596+  135C 6F 30         sub al, $30    ; make into integer
0597+  135E 22 00         mov ah, 0
0598+  1360 2A            mov b, [d]
0599+  1361 AC            mul a, b      ; result in B since it fits in 16bits
0600+  1362 11            mov a, b
0601+  1363 28            mov b, c
0602+  1364 54            add a, b
0603+  1365 39            mov c, a
0604+  1366 63 02 00      sub d, 2
0605+  1369 0A 56 13      jmp mul_loop
0606+  136C             mul_exit:
0607+  136C 12            mov a, c
0608+  136D E7            pop d
0609+  136E E6            pop c
0610+  136F E5            pop b
0611+  1370 EF            pop si
0612+  1371 F9            leave
0613+  1372 09            ret
0614+  1373             
0615+  1373             
0616+  1373 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0616+  1377 34 35 36 37 
0616+  137B 38 39 41 42 
0616+  137F 43 44 45 46 
0617+  1383 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0617+  1387 1B 5B 48 00 
0618+  138B             
0619+  138B             table_power:
0620+  138B 01 00         .dw 1
0621+  138D 0A 00         .dw 10
0622+  138F 64 00         .dw 100
0623+  1391 E8 03         .dw 1000
0624+  1393 10 27         .dw 100002293   1395             ; --- END INLINE ASM BLOCK
2294   1395             
2295   1395 F9            leave
2296   1396 09            ret
2297   1397             
2298   1397             print_unsigned_long2:
2299   1397 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2300   139A             ; $p 
2301   139A 52 02 00      sub sp, 2
2302   139D             ;; p = &num; 
2303   139D FA FF FF      lea d, [bp + -1] ; $p
2304   13A0 DA            push d
2305   13A1 FA 05 00      lea d, [bp + 5] ; $num
2306   13A4 2D            mov b, d
2307   13A5 E7            pop d
2308   13A6 FD 43         mov [d], b
2309   13A8             ;; printx8(*p); 
2310   13A8 FA FF FF      lea d, [bp + -1] ; $p
2311   13AB 2A            mov b, [d]
2312   13AC 74            mov d, b
2313   13AD 32            mov bl, [d]
2314   13AE A7 00         mov bh, 0
2315   13B0 DD            push bl
2316   13B1 07 68 08      call printx8
2317   13B4 51 01 00      add sp, 1
2318   13B7             ;; printx8(*(p+1)); 
2319   13B7 FA FF FF      lea d, [bp + -1] ; $p
2320   13BA 2A            mov b, [d]
2321   13BB             ; START TERMS
2322   13BB D7            push a
2323   13BC 11            mov a, b
2324   13BD 26 01 00      mov b, $1
2325   13C0 54            add a, b
2326   13C1 27            mov b, a
2327   13C2 E4            pop a
2328   13C3             ; END TERMS
2329   13C3 74            mov d, b
2330   13C4 32            mov bl, [d]
2331   13C5 A7 00         mov bh, 0
2332   13C7 DD            push bl
2333   13C8 07 68 08      call printx8
2334   13CB 51 01 00      add sp, 1
2335   13CE             ;; printx8(*(p-2)); 
2336   13CE FA FF FF      lea d, [bp + -1] ; $p
2337   13D1 2A            mov b, [d]
2338   13D2             ; START TERMS
2339   13D2 D7            push a
2340   13D3 11            mov a, b
2341   13D4 26 02 00      mov b, $2
2342   13D7 60            sub a, b
2343   13D8 27            mov b, a
2344   13D9 E4            pop a
2345   13DA             ; END TERMS
2346   13DA 74            mov d, b
2347   13DB 32            mov bl, [d]
2348   13DC A7 00         mov bh, 0
2349   13DE DD            push bl
2350   13DF 07 68 08      call printx8
2351   13E2 51 01 00      add sp, 1
2352   13E5             ;; printx8(*(p-3)); 
2353   13E5 FA FF FF      lea d, [bp + -1] ; $p
2354   13E8 2A            mov b, [d]
2355   13E9             ; START TERMS
2356   13E9 D7            push a
2357   13EA 11            mov a, b
2358   13EB 26 03 00      mov b, $3
2359   13EE 60            sub a, b
2360   13EF 27            mov b, a
2361   13F0 E4            pop a
2362   13F1             ; END TERMS
2363   13F1 74            mov d, b
2364   13F2 32            mov bl, [d]
2365   13F3 A7 00         mov bh, 0
2366   13F5 DD            push bl
2367   13F6 07 68 08      call printx8
2368   13F9 51 01 00      add sp, 1
2369   13FC F9            leave
2370   13FD 09            ret
2371   13FE             ; --- END TEXT BLOCK
2372   13FE             
2373   13FE             ; --- BEGIN DATA BLOCK
2374   13FE 55 6E 65 78 __s0: .db "Unexpected format in printf.", 0
2374   1402 70 65 63 74 
2374   1406 65 64 20 66 
2374   140A 6F 72 6D 61 
2374   140E 74 20 69 6E 
2374   1412 20 70 72 69 
2374   1416 6E 74 66 2E 
2374   141A 00 
2375   141B 45 72 72 6F __s1: .db "Error: Unknown argument type.\n", 0
2375   141F 72 3A 20 55 
2375   1423 6E 6B 6E 6F 
2375   1427 77 6E 20 61 
2375   142B 72 67 75 6D 
2375   142F 65 6E 74 20 
2375   1433 74 79 70 65 
2375   1437 2E 0A 00 
2376   143A 1B 5B 32 4A __s2: .db "\033[2J\033[H", 0
2376   143E 1B 5B 48 00 
2377   1442 0A 00       __s3: .db "\n", 0
2378   1444             
2379   1444 46 14       _heap_top: .dw _heap
2380   1446 00          _heap: .db 0
2381   1447             ; --- END DATA BLOCK
2382   1447             
2383   1447             .end
tasm: Number of errors = 0
