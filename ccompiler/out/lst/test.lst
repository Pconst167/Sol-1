0001   0000             ; --- FILENAME: test
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ;; int i =10; 
0011   0408 52 02 00      sub sp, 2 ; i
0012   040B             ; --- START LOCAL VAR INITIALIZATION
0013   040B FA FF FF      lea d, [bp + -1] ; $i
0014   040E DA            push d
0015   040F 26 0A 00      mov b, $a
0016   0412 E7            pop d
0017   0413 FD 43         mov [d], b
0018   0415             ; --- END LOCAL VAR INITIALIZATION
0019   0415             ;; int j =1; 
0020   0415 52 02 00      sub sp, 2 ; j
0021   0418             ; --- START LOCAL VAR INITIALIZATION
0022   0418 FA FD FF      lea d, [bp + -3] ; $j
0023   041B DA            push d
0024   041C 26 01 00      mov b, $1
0025   041F E7            pop d
0026   0420 FD 43         mov [d], b
0027   0422             ; --- END LOCAL VAR INITIALIZATION
0028   0422             ;; printf("hello World: %d, the number is: %d", i, j); 
0029   0422 FA FD FF      lea d, [bp + -3] ; $j
0030   0425 2A            mov b, [d]
0031   0426 FD AB         swp b
0032   0428 D8            push b
0033   0429 FA FF FF      lea d, [bp + -1] ; $i
0034   042C 2A            mov b, [d]
0035   042D FD AB         swp b
0036   042F D8            push b
0037   0430 26 7A 19      mov b, _s0 ; "hello World: %d, the number is: %d"
0038   0433 FD AB         swp b
0039   0435 D8            push b
0040   0436 07 E2 07      call printf
0041   0439 51 06 00      add sp, 6
0042   043C 05 0B         syscall sys_terminate_proc
0043   043E             
0044   043E             strcpy:
0045   043E F8 00 00      enter 0 ; (push bp; mov bp, sp)
0046   0441             ;; char *psrc; 
0047   0441 52 02 00      sub sp, 2 ; psrc
0048   0444             ;; char *pdest; 
0049   0444 52 02 00      sub sp, 2 ; pdest
0050   0447             ;; psrc = src; 
0051   0447 FA FF FF      lea d, [bp + -1] ; $psrc
0052   044A DA            push d
0053   044B FA 07 00      lea d, [bp + 7] ; $src
0054   044E 2A            mov b, [d]
0055   044F E7            pop d
0056   0450 FD 43         mov [d], b
0057   0452             ;; pdest = dest; 
0058   0452 FA FD FF      lea d, [bp + -3] ; $pdest
0059   0455 DA            push d
0060   0456 FA 05 00      lea d, [bp + 5] ; $dest
0061   0459 2A            mov b, [d]
0062   045A E7            pop d
0063   045B FD 43         mov [d], b
0064   045D             ;; while(*psrc) *pdest++ = *psrc++; 
0065   045D             _while1_cond:
0066   045D FA FF FF      lea d, [bp + -1] ; $psrc
0067   0460 2A            mov b, [d]
0068   0461 74            mov d, b
0069   0462 32            mov bl, [d]
0070   0463 A7 00         mov bh, 0
0071   0465 C0 00 00      cmp b, 0
0072   0468 C6 90 04      je _while1_exit
0073   046B             _while1_block:
0074   046B             ;; *pdest++ = *psrc++; 
0075   046B FA FD FF      lea d, [bp + -3] ; $pdest
0076   046E 2A            mov b, [d]
0077   046F D8            push b
0078   0470 FD 77         inc b
0079   0472 FA FD FF      lea d, [bp + -3] ; $pdest
0080   0475 FD 43         mov [d], b
0081   0477 E5            pop b
0082   0478 D8            push b
0083   0479 FA FF FF      lea d, [bp + -1] ; $psrc
0084   047C 2A            mov b, [d]
0085   047D D8            push b
0086   047E FD 77         inc b
0087   0480 FA FF FF      lea d, [bp + -1] ; $psrc
0088   0483 FD 43         mov [d], b
0089   0485 E5            pop b
0090   0486 74            mov d, b
0091   0487 32            mov bl, [d]
0092   0488 A7 00         mov bh, 0
0093   048A E7            pop d
0094   048B FD 3E         mov [d], bl
0095   048D 0A 5D 04      jmp _while1_cond
0096   0490             _while1_exit:
0097   0490             ;; *pdest = '\0'; 
0098   0490 FA FD FF      lea d, [bp + -3] ; $pdest
0099   0493 2A            mov b, [d]
0100   0494 D8            push b
0101   0495 26 00 00      mov b, $0
0102   0498 E7            pop d
0103   0499 FD 3E         mov [d], bl
0104   049B F9            leave
0105   049C 09            ret
0106   049D             
0107   049D             strcmp:
0108   049D F8 00 00      enter 0 ; (push bp; mov bp, sp)
0109   04A0             ;; while (*s1 && (*s1 == *s2)) { 
0110   04A0             _while2_cond:
0111   04A0 FA 05 00      lea d, [bp + 5] ; $s1
0112   04A3 2A            mov b, [d]
0113   04A4 74            mov d, b
0114   04A5 32            mov bl, [d]
0115   04A6 A7 00         mov bh, 0
0116   04A8 D7            push a
0117   04A9 11            mov a, b
0118   04AA FA 05 00      lea d, [bp + 5] ; $s1
0119   04AD 2A            mov b, [d]
0120   04AE 74            mov d, b
0121   04AF 32            mov bl, [d]
0122   04B0 A7 00         mov bh, 0
0123   04B2             ; START RELATIONAL
0124   04B2 D7            push a
0125   04B3 11            mov a, b
0126   04B4 FA 07 00      lea d, [bp + 7] ; $s2
0127   04B7 2A            mov b, [d]
0128   04B8 74            mov d, b
0129   04B9 32            mov bl, [d]
0130   04BA A7 00         mov bh, 0
0131   04BC B0            cmp a, b
0132   04BD FD 71         seq ; ==
0133   04BF E4            pop a
0134   04C0             ; END RELATIONAL
0135   04C0 FD A7         sand a, b
0136   04C2 E4            pop a
0137   04C3 C0 00 00      cmp b, 0
0138   04C6 C6 E6 04      je _while2_exit
0139   04C9             _while2_block:
0140   04C9             ;; s1++; 
0141   04C9 FA 05 00      lea d, [bp + 5] ; $s1
0142   04CC 2A            mov b, [d]
0143   04CD D8            push b
0144   04CE FD 77         inc b
0145   04D0 FA 05 00      lea d, [bp + 5] ; $s1
0146   04D3 FD 43         mov [d], b
0147   04D5 E5            pop b
0148   04D6             ;; s2++; 
0149   04D6 FA 07 00      lea d, [bp + 7] ; $s2
0150   04D9 2A            mov b, [d]
0151   04DA D8            push b
0152   04DB FD 77         inc b
0153   04DD FA 07 00      lea d, [bp + 7] ; $s2
0154   04E0 FD 43         mov [d], b
0155   04E2 E5            pop b
0156   04E3 0A A0 04      jmp _while2_cond
0157   04E6             _while2_exit:
0158   04E6             ;; return *s1 - *s2; 
0159   04E6 FA 05 00      lea d, [bp + 5] ; $s1
0160   04E9 2A            mov b, [d]
0161   04EA 74            mov d, b
0162   04EB 32            mov bl, [d]
0163   04EC A7 00         mov bh, 0
0164   04EE             ; START TERMS
0165   04EE D7            push a
0166   04EF 11            mov a, b
0167   04F0 FA 07 00      lea d, [bp + 7] ; $s2
0168   04F3 2A            mov b, [d]
0169   04F4 74            mov d, b
0170   04F5 32            mov bl, [d]
0171   04F6 A7 00         mov bh, 0
0172   04F8 60            sub a, b
0173   04F9 27            mov b, a
0174   04FA E4            pop a
0175   04FB             ; END TERMS
0176   04FB F9            leave
0177   04FC 09            ret
0178   04FD             
0179   04FD             strncmp:
0180   04FD F8 00 00      enter 0 ; (push bp; mov bp, sp)
0181   0500 F9            leave
0182   0501 09            ret
0183   0502             
0184   0502             strcat:
0185   0502 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0186   0505             ;; int dest_len; 
0187   0505 52 02 00      sub sp, 2 ; dest_len
0188   0508             ;; int i; 
0189   0508 52 02 00      sub sp, 2 ; i
0190   050B             ;; dest_len = strlen(dest); 
0191   050B FA FF FF      lea d, [bp + -1] ; $dest_len
0192   050E DA            push d
0193   050F FA 05 00      lea d, [bp + 5] ; $dest
0194   0512 2A            mov b, [d]
0195   0513 FD AB         swp b
0196   0515 D8            push b
0197   0516 07 B8 05      call strlen
0198   0519 51 02 00      add sp, 2
0199   051C E7            pop d
0200   051D FD 43         mov [d], b
0201   051F             ;; for (i = 0; src[i] != 0; i=i+1) { 
0202   051F             _for3_init:
0203   051F FA FD FF      lea d, [bp + -3] ; $i
0204   0522 DA            push d
0205   0523 26 00 00      mov b, $0
0206   0526 E7            pop d
0207   0527 FD 43         mov [d], b
0208   0529             _for3_cond:
0209   0529 FA 07 00      lea d, [bp + 7] ; $src
0210   052C FD 2A         mov d, [d]
0211   052E D7            push a
0212   052F DA            push d
0213   0530 FA FD FF      lea d, [bp + -3] ; $i
0214   0533 2A            mov b, [d]
0215   0534 E7            pop d
0216   0535 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0217   0539 E4            pop a
0218   053A 32            mov bl, [d]
0219   053B A7 00         mov bh, 0
0220   053D             ; START RELATIONAL
0221   053D D7            push a
0222   053E 11            mov a, b
0223   053F 26 00 00      mov b, $0
0224   0542 B0            cmp a, b
0225   0543 FD 72         sneq ; !=
0226   0545 E4            pop a
0227   0546             ; END RELATIONAL
0228   0546 C0 00 00      cmp b, 0
0229   0549 C6 92 05      je _for3_exit
0230   054C             _for3_block:
0231   054C             ;; dest[dest_len + i] = src[i]; 
0232   054C FA 05 00      lea d, [bp + 5] ; $dest
0233   054F FD 2A         mov d, [d]
0234   0551 D7            push a
0235   0552 DA            push d
0236   0553 FA FF FF      lea d, [bp + -1] ; $dest_len
0237   0556 2A            mov b, [d]
0238   0557             ; START TERMS
0239   0557 D7            push a
0240   0558 11            mov a, b
0241   0559 FA FD FF      lea d, [bp + -3] ; $i
0242   055C 2A            mov b, [d]
0243   055D 56            add b, a
0244   055E E4            pop a
0245   055F             ; END TERMS
0246   055F E7            pop d
0247   0560 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0248   0564 E4            pop a
0249   0565 DA            push d
0250   0566 FA 07 00      lea d, [bp + 7] ; $src
0251   0569 FD 2A         mov d, [d]
0252   056B D7            push a
0253   056C DA            push d
0254   056D FA FD FF      lea d, [bp + -3] ; $i
0255   0570 2A            mov b, [d]
0256   0571 E7            pop d
0257   0572 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0258   0576 E4            pop a
0259   0577 32            mov bl, [d]
0260   0578 A7 00         mov bh, 0
0261   057A E7            pop d
0262   057B FD 3E         mov [d], bl
0263   057D             _for3_update:
0264   057D FA FD FF      lea d, [bp + -3] ; $i
0265   0580 DA            push d
0266   0581 FA FD FF      lea d, [bp + -3] ; $i
0267   0584 2A            mov b, [d]
0268   0585             ; START TERMS
0269   0585 D7            push a
0270   0586 11            mov a, b
0271   0587 26 01 00      mov b, $1
0272   058A 56            add b, a
0273   058B E4            pop a
0274   058C             ; END TERMS
0275   058C E7            pop d
0276   058D FD 43         mov [d], b
0277   058F 0A 29 05      jmp _for3_cond
0278   0592             _for3_exit:
0279   0592             ;; dest[dest_len + i] = 0; 
0280   0592 FA 05 00      lea d, [bp + 5] ; $dest
0281   0595 FD 2A         mov d, [d]
0282   0597 D7            push a
0283   0598 DA            push d
0284   0599 FA FF FF      lea d, [bp + -1] ; $dest_len
0285   059C 2A            mov b, [d]
0286   059D             ; START TERMS
0287   059D D7            push a
0288   059E 11            mov a, b
0289   059F FA FD FF      lea d, [bp + -3] ; $i
0290   05A2 2A            mov b, [d]
0291   05A3 56            add b, a
0292   05A4 E4            pop a
0293   05A5             ; END TERMS
0294   05A5 E7            pop d
0295   05A6 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0296   05AA E4            pop a
0297   05AB DA            push d
0298   05AC 26 00 00      mov b, $0
0299   05AF E7            pop d
0300   05B0 FD 3E         mov [d], bl
0301   05B2             ;; return dest; 
0302   05B2 FA 05 00      lea d, [bp + 5] ; $dest
0303   05B5 2A            mov b, [d]
0304   05B6 F9            leave
0305   05B7 09            ret
0306   05B8             
0307   05B8             strlen:
0308   05B8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0309   05BB             ;; int length; 
0310   05BB 52 02 00      sub sp, 2 ; length
0311   05BE             ;; length = 0; 
0312   05BE FA FF FF      lea d, [bp + -1] ; $length
0313   05C1 DA            push d
0314   05C2 26 00 00      mov b, $0
0315   05C5 E7            pop d
0316   05C6 FD 43         mov [d], b
0317   05C8             ;; while (str[length] != 0) { 
0318   05C8             _while4_cond:
0319   05C8 FA 05 00      lea d, [bp + 5] ; $str
0320   05CB FD 2A         mov d, [d]
0321   05CD D7            push a
0322   05CE DA            push d
0323   05CF FA FF FF      lea d, [bp + -1] ; $length
0324   05D2 2A            mov b, [d]
0325   05D3 E7            pop d
0326   05D4 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0327   05D8 E4            pop a
0328   05D9 32            mov bl, [d]
0329   05DA A7 00         mov bh, 0
0330   05DC             ; START RELATIONAL
0331   05DC D7            push a
0332   05DD 11            mov a, b
0333   05DE 26 00 00      mov b, $0
0334   05E1 B0            cmp a, b
0335   05E2 FD 72         sneq ; !=
0336   05E4 E4            pop a
0337   05E5             ; END RELATIONAL
0338   05E5 C0 00 00      cmp b, 0
0339   05E8 C6 FB 05      je _while4_exit
0340   05EB             _while4_block:
0341   05EB             ;; length++; 
0342   05EB FA FF FF      lea d, [bp + -1] ; $length
0343   05EE 2A            mov b, [d]
0344   05EF D8            push b
0345   05F0 FD 77         inc b
0346   05F2 FA FF FF      lea d, [bp + -1] ; $length
0347   05F5 FD 43         mov [d], b
0348   05F7 E5            pop b
0349   05F8 0A C8 05      jmp _while4_cond
0350   05FB             _while4_exit:
0351   05FB             ;; return length; 
0352   05FB FA FF FF      lea d, [bp + -1] ; $length
0353   05FE 2A            mov b, [d]
0354   05FF F9            leave
0355   0600 09            ret
0356   0601             
0357   0601             exit:
0358   0601 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0359   0604             
0360   0604             ; --- BEGIN INLINE ASM BLOCK
0361   0604 05 0B         syscall sys_terminate_proc
0362   0606             ; --- END INLINE ASM BLOCK
0363   0606             
0364   0606 F9            leave
0365   0607 09            ret
0366   0608             
0367   0608             memset:
0368   0608 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0369   060B             ;; int i; 
0370   060B 52 02 00      sub sp, 2 ; i
0371   060E             ;; for(i = 0; i < size; i++){ 
0372   060E             _for5_init:
0373   060E FA FF FF      lea d, [bp + -1] ; $i
0374   0611 DA            push d
0375   0612 26 00 00      mov b, $0
0376   0615 E7            pop d
0377   0616 FD 43         mov [d], b
0378   0618             _for5_cond:
0379   0618 FA FF FF      lea d, [bp + -1] ; $i
0380   061B 2A            mov b, [d]
0381   061C             ; START RELATIONAL
0382   061C D7            push a
0383   061D 11            mov a, b
0384   061E FA 08 00      lea d, [bp + 8] ; $size
0385   0621 2A            mov b, [d]
0386   0622 B0            cmp a, b
0387   0623 FD 73         slt ; < (signed)
0388   0625 E4            pop a
0389   0626             ; END RELATIONAL
0390   0626 C0 00 00      cmp b, 0
0391   0629 C6 52 06      je _for5_exit
0392   062C             _for5_block:
0393   062C             ;; *(s+i) = c; 
0394   062C FA 05 00      lea d, [bp + 5] ; $s
0395   062F 2A            mov b, [d]
0396   0630             ; START TERMS
0397   0630 D7            push a
0398   0631 11            mov a, b
0399   0632 FA FF FF      lea d, [bp + -1] ; $i
0400   0635 2A            mov b, [d]
0401   0636 56            add b, a
0402   0637 E4            pop a
0403   0638             ; END TERMS
0404   0638 D8            push b
0405   0639 FA 07 00      lea d, [bp + 7] ; $c
0406   063C 32            mov bl, [d]
0407   063D A7 00         mov bh, 0
0408   063F E7            pop d
0409   0640 FD 3E         mov [d], bl
0410   0642             _for5_update:
0411   0642 FA FF FF      lea d, [bp + -1] ; $i
0412   0645 2A            mov b, [d]
0413   0646 D8            push b
0414   0647 FD 77         inc b
0415   0649 FA FF FF      lea d, [bp + -1] ; $i
0416   064C FD 43         mov [d], b
0417   064E E5            pop b
0418   064F 0A 18 06      jmp _for5_cond
0419   0652             _for5_exit:
0420   0652             ;; return s; 
0421   0652 FA 05 00      lea d, [bp + 5] ; $s
0422   0655 2A            mov b, [d]
0423   0656 F9            leave
0424   0657 09            ret
0425   0658             
0426   0658             atoi:
0427   0658 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0428   065B             ;; int result = 0;  // Initialize result 
0429   065B 52 02 00      sub sp, 2 ; result
0430   065E             ; --- START LOCAL VAR INITIALIZATION
0431   065E FA FF FF      lea d, [bp + -1] ; $result
0432   0661 DA            push d
0433   0662 26 00 00      mov b, $0
0434   0665 E7            pop d
0435   0666 FD 43         mov [d], b
0436   0668             ; --- END LOCAL VAR INITIALIZATION
0437   0668             ;; int sign = 1;    // Initialize sign as positive 
0438   0668 52 02 00      sub sp, 2 ; sign
0439   066B             ; --- START LOCAL VAR INITIALIZATION
0440   066B FA FD FF      lea d, [bp + -3] ; $sign
0441   066E DA            push d
0442   066F 26 01 00      mov b, $1
0443   0672 E7            pop d
0444   0673 FD 43         mov [d], b
0445   0675             ; --- END LOCAL VAR INITIALIZATION
0446   0675             ;; while (*str == ' ') str++; 
0447   0675             _while6_cond:
0448   0675 FA 05 00      lea d, [bp + 5] ; $str
0449   0678 2A            mov b, [d]
0450   0679 74            mov d, b
0451   067A 32            mov bl, [d]
0452   067B A7 00         mov bh, 0
0453   067D             ; START RELATIONAL
0454   067D D7            push a
0455   067E 11            mov a, b
0456   067F 26 20 00      mov b, $20
0457   0682 B0            cmp a, b
0458   0683 FD 71         seq ; ==
0459   0685 E4            pop a
0460   0686             ; END RELATIONAL
0461   0686 C0 00 00      cmp b, 0
0462   0689 C6 9C 06      je _while6_exit
0463   068C             _while6_block:
0464   068C             ;; str++; 
0465   068C FA 05 00      lea d, [bp + 5] ; $str
0466   068F 2A            mov b, [d]
0467   0690 D8            push b
0468   0691 FD 77         inc b
0469   0693 FA 05 00      lea d, [bp + 5] ; $str
0470   0696 FD 43         mov [d], b
0471   0698 E5            pop b
0472   0699 0A 75 06      jmp _while6_cond
0473   069C             _while6_exit:
0474   069C             ;; if (*str == '-' || *str == '+') { 
0475   069C             _if7_cond:
0476   069C FA 05 00      lea d, [bp + 5] ; $str
0477   069F 2A            mov b, [d]
0478   06A0 74            mov d, b
0479   06A1 32            mov bl, [d]
0480   06A2 A7 00         mov bh, 0
0481   06A4             ; START RELATIONAL
0482   06A4 D7            push a
0483   06A5 11            mov a, b
0484   06A6 26 2D 00      mov b, $2d
0485   06A9 B0            cmp a, b
0486   06AA FD 71         seq ; ==
0487   06AC E4            pop a
0488   06AD             ; END RELATIONAL
0489   06AD D7            push a
0490   06AE 11            mov a, b
0491   06AF FA 05 00      lea d, [bp + 5] ; $str
0492   06B2 2A            mov b, [d]
0493   06B3 74            mov d, b
0494   06B4 32            mov bl, [d]
0495   06B5 A7 00         mov bh, 0
0496   06B7             ; START RELATIONAL
0497   06B7 D7            push a
0498   06B8 11            mov a, b
0499   06B9 26 2B 00      mov b, $2b
0500   06BC B0            cmp a, b
0501   06BD FD 71         seq ; ==
0502   06BF E4            pop a
0503   06C0             ; END RELATIONAL
0504   06C0 FD A8         sor a, b ; ||
0505   06C2 E4            pop a
0506   06C3 C0 00 00      cmp b, 0
0507   06C6 C6 FD 06      je _if7_exit
0508   06C9             _if7_true:
0509   06C9             ;; if (*str == '-') sign = -1; 
0510   06C9             _if8_cond:
0511   06C9 FA 05 00      lea d, [bp + 5] ; $str
0512   06CC 2A            mov b, [d]
0513   06CD 74            mov d, b
0514   06CE 32            mov bl, [d]
0515   06CF A7 00         mov bh, 0
0516   06D1             ; START RELATIONAL
0517   06D1 D7            push a
0518   06D2 11            mov a, b
0519   06D3 26 2D 00      mov b, $2d
0520   06D6 B0            cmp a, b
0521   06D7 FD 71         seq ; ==
0522   06D9 E4            pop a
0523   06DA             ; END RELATIONAL
0524   06DA C0 00 00      cmp b, 0
0525   06DD C6 ED 06      je _if8_exit
0526   06E0             _if8_true:
0527   06E0             ;; sign = -1; 
0528   06E0 FA FD FF      lea d, [bp + -3] ; $sign
0529   06E3 DA            push d
0530   06E4 26 FF FF      mov b, $ffff
0531   06E7 E7            pop d
0532   06E8 FD 43         mov [d], b
0533   06EA 0A ED 06      jmp _if8_exit
0534   06ED             _if8_exit:
0535   06ED             ;; str++; 
0536   06ED FA 05 00      lea d, [bp + 5] ; $str
0537   06F0 2A            mov b, [d]
0538   06F1 D8            push b
0539   06F2 FD 77         inc b
0540   06F4 FA 05 00      lea d, [bp + 5] ; $str
0541   06F7 FD 43         mov [d], b
0542   06F9 E5            pop b
0543   06FA 0A FD 06      jmp _if7_exit
0544   06FD             _if7_exit:
0545   06FD             ;; while (*str >= '0' && *str <= '9') { 
0546   06FD             _while9_cond:
0547   06FD FA 05 00      lea d, [bp + 5] ; $str
0548   0700 2A            mov b, [d]
0549   0701 74            mov d, b
0550   0702 32            mov bl, [d]
0551   0703 A7 00         mov bh, 0
0552   0705             ; START RELATIONAL
0553   0705 D7            push a
0554   0706 11            mov a, b
0555   0707 26 30 00      mov b, $30
0556   070A B0            cmp a, b
0557   070B FD 82         sgeu ; >= (unsigned)
0558   070D E4            pop a
0559   070E             ; END RELATIONAL
0560   070E D7            push a
0561   070F 11            mov a, b
0562   0710 FA 05 00      lea d, [bp + 5] ; $str
0563   0713 2A            mov b, [d]
0564   0714 74            mov d, b
0565   0715 32            mov bl, [d]
0566   0716 A7 00         mov bh, 0
0567   0718             ; START RELATIONAL
0568   0718 D7            push a
0569   0719 11            mov a, b
0570   071A 26 39 00      mov b, $39
0571   071D B0            cmp a, b
0572   071E FD 75         slu ; <= (unsigned)
0573   0720 E4            pop a
0574   0721             ; END RELATIONAL
0575   0721 FD A7         sand a, b
0576   0723 E4            pop a
0577   0724 C0 00 00      cmp b, 0
0578   0727 C6 62 07      je _while9_exit
0579   072A             _while9_block:
0580   072A             ;; result = result * 10 + (*str - '0'); 
0581   072A FA FF FF      lea d, [bp + -1] ; $result
0582   072D DA            push d
0583   072E FA FF FF      lea d, [bp + -1] ; $result
0584   0731 2A            mov b, [d]
0585   0732             ; START FACTORS
0586   0732 D7            push a
0587   0733 11            mov a, b
0588   0734 26 0A 00      mov b, $a
0589   0737 AC            mul a, b ; *
0590   0738 11            mov a, b
0591   0739 27            mov b, a
0592   073A E4            pop a
0593   073B             ; END FACTORS
0594   073B             ; START TERMS
0595   073B D7            push a
0596   073C 11            mov a, b
0597   073D FA 05 00      lea d, [bp + 5] ; $str
0598   0740 2A            mov b, [d]
0599   0741 74            mov d, b
0600   0742 32            mov bl, [d]
0601   0743 A7 00         mov bh, 0
0602   0745             ; START TERMS
0603   0745 D7            push a
0604   0746 11            mov a, b
0605   0747 26 30 00      mov b, $30
0606   074A 60            sub a, b
0607   074B 27            mov b, a
0608   074C E4            pop a
0609   074D             ; END TERMS
0610   074D 56            add b, a
0611   074E E4            pop a
0612   074F             ; END TERMS
0613   074F E7            pop d
0614   0750 FD 43         mov [d], b
0615   0752             ;; str++; 
0616   0752 FA 05 00      lea d, [bp + 5] ; $str
0617   0755 2A            mov b, [d]
0618   0756 D8            push b
0619   0757 FD 77         inc b
0620   0759 FA 05 00      lea d, [bp + 5] ; $str
0621   075C FD 43         mov [d], b
0622   075E E5            pop b
0623   075F 0A FD 06      jmp _while9_cond
0624   0762             _while9_exit:
0625   0762             ;; return sign * result; 
0626   0762 FA FD FF      lea d, [bp + -3] ; $sign
0627   0765 2A            mov b, [d]
0628   0766             ; START FACTORS
0629   0766 D7            push a
0630   0767 11            mov a, b
0631   0768 FA FF FF      lea d, [bp + -1] ; $result
0632   076B 2A            mov b, [d]
0633   076C AC            mul a, b ; *
0634   076D 11            mov a, b
0635   076E 27            mov b, a
0636   076F E4            pop a
0637   0770             ; END FACTORS
0638   0770 F9            leave
0639   0771 09            ret
0640   0772             
0641   0772             rand:
0642   0772 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0643   0775             ;; int  sec; 
0644   0775 52 02 00      sub sp, 2 ; sec
0645   0778             
0646   0778             ; --- BEGIN INLINE ASM BLOCK
0647   0778 19 00         mov al, 0
0648   077A 05 01         syscall sys_rtc					
0649   077C 1A            mov al, ah
0650   077D FA FF FF      lea d, [bp + -1] ; $sec
0651   0780 1E            mov al, [d]
0652   0781 22 00         mov ah, 0
0653   0783             ; --- END INLINE ASM BLOCK
0654   0783             
0655   0783             ;; return sec; 
0656   0783 FA FF FF      lea d, [bp + -1] ; $sec
0657   0786 2A            mov b, [d]
0658   0787 F9            leave
0659   0788 09            ret
0660   0789             
0661   0789             alloc:
0662   0789 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0663   078C             ;; heap_top = heap_top + bytes; 
0664   078C 3B E1 19      mov d, _heap_top ; $heap_top
0665   078F DA            push d
0666   0790 3B E1 19      mov d, _heap_top ; $heap_top
0667   0793 2A            mov b, [d]
0668   0794             ; START TERMS
0669   0794 D7            push a
0670   0795 11            mov a, b
0671   0796 FA 05 00      lea d, [bp + 5] ; $bytes
0672   0799 2A            mov b, [d]
0673   079A 56            add b, a
0674   079B E4            pop a
0675   079C             ; END TERMS
0676   079C E7            pop d
0677   079D FD 43         mov [d], b
0678   079F             ;; return heap_top - bytes; 
0679   079F 3B E1 19      mov d, _heap_top ; $heap_top
0680   07A2 2A            mov b, [d]
0681   07A3             ; START TERMS
0682   07A3 D7            push a
0683   07A4 11            mov a, b
0684   07A5 FA 05 00      lea d, [bp + 5] ; $bytes
0685   07A8 2A            mov b, [d]
0686   07A9 60            sub a, b
0687   07AA 27            mov b, a
0688   07AB E4            pop a
0689   07AC             ; END TERMS
0690   07AC F9            leave
0691   07AD 09            ret
0692   07AE             
0693   07AE             free:
0694   07AE F8 00 00      enter 0 ; (push bp; mov bp, sp)
0695   07B1             ;; return heap_top = heap_top - bytes; 
0696   07B1 3B E1 19      mov d, _heap_top ; $heap_top
0697   07B4 DA            push d
0698   07B5 3B E1 19      mov d, _heap_top ; $heap_top
0699   07B8 2A            mov b, [d]
0700   07B9             ; START TERMS
0701   07B9 D7            push a
0702   07BA 11            mov a, b
0703   07BB FA 05 00      lea d, [bp + 5] ; $bytes
0704   07BE 2A            mov b, [d]
0705   07BF 60            sub a, b
0706   07C0 27            mov b, a
0707   07C1 E4            pop a
0708   07C2             ; END TERMS
0709   07C2 E7            pop d
0710   07C3 FD 43         mov [d], b
0711   07C5 F9            leave
0712   07C6 09            ret
0713   07C7             
0714   07C7             fopen:
0715   07C7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0716   07CA             ;; FILE *fp; 
0717   07CA 52 02 00      sub sp, 2 ; fp
0718   07CD             ;; fp = alloc(sizeof(int)); 
0719   07CD FA FF FF      lea d, [bp + -1] ; $fp
0720   07D0 DA            push d
0721   07D1 26 02 00      mov b, 2
0722   07D4 FD AB         swp b
0723   07D6 D8            push b
0724   07D7 07 89 07      call alloc
0725   07DA 51 02 00      add sp, 2
0726   07DD E7            pop d
0727   07DE FD 43         mov [d], b
0728   07E0 F9            leave
0729   07E1 09            ret
0730   07E2             
0731   07E2             printf:
0732   07E2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0733   07E5             ;; char *p, *format_p; 
0734   07E5 52 02 00      sub sp, 2 ; p
0735   07E8 52 02 00      sub sp, 2 ; format_p
0736   07EB             ;; format_p = format; 
0737   07EB FA FD FF      lea d, [bp + -3] ; $format_p
0738   07EE DA            push d
0739   07EF FA 05 00      lea d, [bp + 5] ; $format
0740   07F2 2A            mov b, [d]
0741   07F3 E7            pop d
0742   07F4 FD 43         mov [d], b
0743   07F6             ;; p = &format + 2; 
0744   07F6 FA FF FF      lea d, [bp + -1] ; $p
0745   07F9 DA            push d
0746   07FA FA 05 00      lea d, [bp + 5] ; $format
0747   07FD 2D            mov b, d
0748   07FE             ; START TERMS
0749   07FE D7            push a
0750   07FF 11            mov a, b
0751   0800 26 02 00      mov b, $2
0752   0803 56            add b, a
0753   0804 E4            pop a
0754   0805             ; END TERMS
0755   0805 E7            pop d
0756   0806 FD 43         mov [d], b
0757   0808             ;; for(;;){ 
0758   0808             _for10_init:
0759   0808             _for10_cond:
0760   0808             _for10_block:
0761   0808             ;; if(!*format_p) break; 
0762   0808             _if11_cond:
0763   0808 FA FD FF      lea d, [bp + -3] ; $format_p
0764   080B 2A            mov b, [d]
0765   080C 74            mov d, b
0766   080D 32            mov bl, [d]
0767   080E A7 00         mov bh, 0
0768   0810 C0 00 00      cmp b, 0
0769   0813 FD 71         seq ; !
0770   0815 C0 00 00      cmp b, 0
0771   0818 C6 21 08      je _if11_else
0772   081B             _if11_true:
0773   081B             ;; break; 
0774   081B 0A 48 0A      jmp _for10_exit ; for break
0775   081E 0A 45 0A      jmp _if11_exit
0776   0821             _if11_else:
0777   0821             ;; if(*format_p == '%'){ 
0778   0821             _if12_cond:
0779   0821 FA FD FF      lea d, [bp + -3] ; $format_p
0780   0824 2A            mov b, [d]
0781   0825 74            mov d, b
0782   0826 32            mov bl, [d]
0783   0827 A7 00         mov bh, 0
0784   0829             ; START RELATIONAL
0785   0829 D7            push a
0786   082A 11            mov a, b
0787   082B 26 25 00      mov b, $25
0788   082E B0            cmp a, b
0789   082F FD 71         seq ; ==
0790   0831 E4            pop a
0791   0832             ; END RELATIONAL
0792   0832 C0 00 00      cmp b, 0
0793   0835 C6 29 0A      je _if12_else
0794   0838             _if12_true:
0795   0838             ;; format_p++; 
0796   0838 FA FD FF      lea d, [bp + -3] ; $format_p
0797   083B 2A            mov b, [d]
0798   083C D8            push b
0799   083D FD 77         inc b
0800   083F FA FD FF      lea d, [bp + -3] ; $format_p
0801   0842 FD 43         mov [d], b
0802   0844 E5            pop b
0803   0845             ;; switch(*format_p){ 
0804   0845             _switch13_expr:
0805   0845 FA FD FF      lea d, [bp + -3] ; $format_p
0806   0848 2A            mov b, [d]
0807   0849 74            mov d, b
0808   084A 32            mov bl, [d]
0809   084B A7 00         mov bh, 0
0810   084D             _switch13_comparisons:
0811   084D C1 6C         cmp bl, $6c
0812   084F C6 7B 08      je _switch13_case0
0813   0852 C1 4C         cmp bl, $4c
0814   0854 C6 7B 08      je _switch13_case1
0815   0857 C1 64         cmp bl, $64
0816   0859 C6 69 09      je _switch13_case2
0817   085C C1 69         cmp bl, $69
0818   085E C6 69 09      je _switch13_case3
0819   0861 C1 75         cmp bl, $75
0820   0863 C6 8D 09      je _switch13_case4
0821   0866 C1 78         cmp bl, $78
0822   0868 C6 B1 09      je _switch13_case5
0823   086B C1 63         cmp bl, $63
0824   086D C6 CF 09      je _switch13_case6
0825   0870 C1 73         cmp bl, $73
0826   0872 C6 EE 09      je _switch13_case7
0827   0875 0A 0D 0A      jmp _switch13_default
0828   0878 0A 19 0A      jmp _switch13_exit
0829   087B             _switch13_case0:
0830   087B             _switch13_case1:
0831   087B             ;; format_p++; 
0832   087B FA FD FF      lea d, [bp + -3] ; $format_p
0833   087E 2A            mov b, [d]
0834   087F D8            push b
0835   0880 FD 77         inc b
0836   0882 FA FD FF      lea d, [bp + -3] ; $format_p
0837   0885 FD 43         mov [d], b
0838   0887 E5            pop b
0839   0888             ;; if(*format_p == 'd' || *format_p == 'i') 
0840   0888             _if14_cond:
0841   0888 FA FD FF      lea d, [bp + -3] ; $format_p
0842   088B 2A            mov b, [d]
0843   088C 74            mov d, b
0844   088D 32            mov bl, [d]
0845   088E A7 00         mov bh, 0
0846   0890             ; START RELATIONAL
0847   0890 D7            push a
0848   0891 11            mov a, b
0849   0892 26 64 00      mov b, $64
0850   0895 B0            cmp a, b
0851   0896 FD 71         seq ; ==
0852   0898 E4            pop a
0853   0899             ; END RELATIONAL
0854   0899 D7            push a
0855   089A 11            mov a, b
0856   089B FA FD FF      lea d, [bp + -3] ; $format_p
0857   089E 2A            mov b, [d]
0858   089F 74            mov d, b
0859   08A0 32            mov bl, [d]
0860   08A1 A7 00         mov bh, 0
0861   08A3             ; START RELATIONAL
0862   08A3 D7            push a
0863   08A4 11            mov a, b
0864   08A5 26 69 00      mov b, $69
0865   08A8 B0            cmp a, b
0866   08A9 FD 71         seq ; ==
0867   08AB E4            pop a
0868   08AC             ; END RELATIONAL
0869   08AC FD A8         sor a, b ; ||
0870   08AE E4            pop a
0871   08AF C0 00 00      cmp b, 0
0872   08B2 C6 D7 08      je _if14_else
0873   08B5             _if14_true:
0874   08B5             ;; print_signed_long(*(long *)p); 
0875   08B5 FA FF FF      lea d, [bp + -1] ; $p
0876   08B8 2A            mov b, [d]
0877   08B9 AB            snex b
0878   08BA FD 39         mov c, b
0879   08BC 74            mov d, b
0880   08BD 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0881   08C0 FD 39         mov c, b ; And place it into C
0882   08C2 2A            mov b, [d] ; Lower Word in B
0883   08C3 FD 79         mov g, b
0884   08C5 28            mov b, c
0885   08C6 FD AB         swp b
0886   08C8 D8            push b
0887   08C9 FD 27         mov b, g
0888   08CB FD AB         swp b
0889   08CD D8            push b
0890   08CE 07 2E 0F      call print_signed_long
0891   08D1 51 04 00      add sp, 4
0892   08D4 0A 54 09      jmp _if14_exit
0893   08D7             _if14_else:
0894   08D7             ;; if(*format_p == 'u') 
0895   08D7             _if15_cond:
0896   08D7 FA FD FF      lea d, [bp + -3] ; $format_p
0897   08DA 2A            mov b, [d]
0898   08DB 74            mov d, b
0899   08DC 32            mov bl, [d]
0900   08DD A7 00         mov bh, 0
0901   08DF             ; START RELATIONAL
0902   08DF D7            push a
0903   08E0 11            mov a, b
0904   08E1 26 75 00      mov b, $75
0905   08E4 B0            cmp a, b
0906   08E5 FD 71         seq ; ==
0907   08E7 E4            pop a
0908   08E8             ; END RELATIONAL
0909   08E8 C0 00 00      cmp b, 0
0910   08EB C6 12 09      je _if15_else
0911   08EE             _if15_true:
0912   08EE             ;; print_unsigned_long(*(unsigned long *)p); 
0913   08EE FA FF FF      lea d, [bp + -1] ; $p
0914   08F1 2A            mov b, [d]
0915   08F2 A7 00         mov bh, 0
0916   08F4 38 00 00      mov c, 0
0917   08F7 74            mov d, b
0918   08F8 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0919   08FB FD 39         mov c, b ; And place it into C
0920   08FD 2A            mov b, [d] ; Lower Word in B
0921   08FE FD 79         mov g, b
0922   0900 28            mov b, c
0923   0901 FD AB         swp b
0924   0903 D8            push b
0925   0904 FD 27         mov b, g
0926   0906 FD AB         swp b
0927   0908 D8            push b
0928   0909 07 6E 12      call print_unsigned_long
0929   090C 51 04 00      add sp, 4
0930   090F 0A 54 09      jmp _if15_exit
0931   0912             _if15_else:
0932   0912             ;; if(*format_p == 'x') 
0933   0912             _if16_cond:
0934   0912 FA FD FF      lea d, [bp + -3] ; $format_p
0935   0915 2A            mov b, [d]
0936   0916 74            mov d, b
0937   0917 32            mov bl, [d]
0938   0918 A7 00         mov bh, 0
0939   091A             ; START RELATIONAL
0940   091A D7            push a
0941   091B 11            mov a, b
0942   091C 26 78 00      mov b, $78
0943   091F B0            cmp a, b
0944   0920 FD 71         seq ; ==
0945   0922 E4            pop a
0946   0923             ; END RELATIONAL
0947   0923 C0 00 00      cmp b, 0
0948   0926 C6 48 09      je _if16_else
0949   0929             _if16_true:
0950   0929             ;; printx32(*(long int *)p); 
0951   0929 FA FF FF      lea d, [bp + -1] ; $p
0952   092C 2A            mov b, [d]
0953   092D 74            mov d, b
0954   092E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0955   0931 FD 39         mov c, b ; And place it into C
0956   0933 2A            mov b, [d] ; Lower Word in B
0957   0934 FD 79         mov g, b
0958   0936 28            mov b, c
0959   0937 FD AB         swp b
0960   0939 D8            push b
0961   093A FD 27         mov b, g
0962   093C FD AB         swp b
0963   093E D8            push b
0964   093F 07 A3 0C      call printx32
0965   0942 51 04 00      add sp, 4
0966   0945 0A 54 09      jmp _if16_exit
0967   0948             _if16_else:
0968   0948             ;; err("Unexpected format in printf."); 
0969   0948 26 9D 19      mov b, _s1 ; "Unexpected format in printf."
0970   094B FD AB         swp b
0971   094D D8            push b
0972   094E 07 91 0C      call err
0973   0951 51 02 00      add sp, 2
0974   0954             _if16_exit:
0975   0954             _if15_exit:
0976   0954             _if14_exit:
0977   0954             ;; p = p + 4; 
0978   0954 FA FF FF      lea d, [bp + -1] ; $p
0979   0957 DA            push d
0980   0958 FA FF FF      lea d, [bp + -1] ; $p
0981   095B 2A            mov b, [d]
0982   095C             ; START TERMS
0983   095C D7            push a
0984   095D 11            mov a, b
0985   095E 26 04 00      mov b, $4
0986   0961 56            add b, a
0987   0962 E4            pop a
0988   0963             ; END TERMS
0989   0963 E7            pop d
0990   0964 FD 43         mov [d], b
0991   0966             ;; break; 
0992   0966 0A 19 0A      jmp _switch13_exit ; case break
0993   0969             _switch13_case2:
0994   0969             _switch13_case3:
0995   0969             ;; print_signed(*(int*)p); 
0996   0969 FA FF FF      lea d, [bp + -1] ; $p
0997   096C 2A            mov b, [d]
0998   096D 74            mov d, b
0999   096E 2A            mov b, [d]
1000   096F FD AB         swp b
1001   0971 D8            push b
1002   0972 07 37 0E      call print_signed
1003   0975 51 02 00      add sp, 2
1004   0978             ;; p = p + 2; 
1005   0978 FA FF FF      lea d, [bp + -1] ; $p
1006   097B DA            push d
1007   097C FA FF FF      lea d, [bp + -1] ; $p
1008   097F 2A            mov b, [d]
1009   0980             ; START TERMS
1010   0980 D7            push a
1011   0981 11            mov a, b
1012   0982 26 02 00      mov b, $2
1013   0985 56            add b, a
1014   0986 E4            pop a
1015   0987             ; END TERMS
1016   0987 E7            pop d
1017   0988 FD 43         mov [d], b
1018   098A             ;; break; 
1019   098A 0A 19 0A      jmp _switch13_exit ; case break
1020   098D             _switch13_case4:
1021   098D             ;; print_unsigned(*(unsigned int*)p); 
1022   098D FA FF FF      lea d, [bp + -1] ; $p
1023   0990 2A            mov b, [d]
1024   0991 74            mov d, b
1025   0992 2A            mov b, [d]
1026   0993 FD AB         swp b
1027   0995 D8            push b
1028   0996 07 69 14      call print_unsigned
1029   0999 51 02 00      add sp, 2
1030   099C             ;; p = p + 2; 
1031   099C FA FF FF      lea d, [bp + -1] ; $p
1032   099F DA            push d
1033   09A0 FA FF FF      lea d, [bp + -1] ; $p
1034   09A3 2A            mov b, [d]
1035   09A4             ; START TERMS
1036   09A4 D7            push a
1037   09A5 11            mov a, b
1038   09A6 26 02 00      mov b, $2
1039   09A9 56            add b, a
1040   09AA E4            pop a
1041   09AB             ; END TERMS
1042   09AB E7            pop d
1043   09AC FD 43         mov [d], b
1044   09AE             ;; break; 
1045   09AE 0A 19 0A      jmp _switch13_exit ; case break
1046   09B1             _switch13_case5:
1047   09B1             
1048   09B1             ; --- BEGIN INLINE ASM BLOCK
1049   09B1 FA FF FF      lea d, [bp + -1] ; $p
1050   09B4 FD 2A         mov d, [d]
1051   09B6 2A            mov b, [d]
1052   09B7 07 6F 18      call print_u16x
1053   09BA             ; --- END INLINE ASM BLOCK
1054   09BA             
1055   09BA             ;; p = p + 2; 
1056   09BA FA FF FF      lea d, [bp + -1] ; $p
1057   09BD DA            push d
1058   09BE FA FF FF      lea d, [bp + -1] ; $p
1059   09C1 2A            mov b, [d]
1060   09C2             ; START TERMS
1061   09C2 D7            push a
1062   09C3 11            mov a, b
1063   09C4 26 02 00      mov b, $2
1064   09C7 56            add b, a
1065   09C8 E4            pop a
1066   09C9             ; END TERMS
1067   09C9 E7            pop d
1068   09CA FD 43         mov [d], b
1069   09CC             ;; break; 
1070   09CC 0A 19 0A      jmp _switch13_exit ; case break
1071   09CF             _switch13_case6:
1072   09CF             
1073   09CF             ; --- BEGIN INLINE ASM BLOCK
1074   09CF FA FF FF      lea d, [bp + -1] ; $p
1075   09D2 FD 2A         mov d, [d]
1076   09D4 1E            mov al, [d]
1077   09D5 23            mov ah, al
1078   09D6 07 CD 16      call _putchar
1079   09D9             ; --- END INLINE ASM BLOCK
1080   09D9             
1081   09D9             ;; p = p + 2; 
1082   09D9 FA FF FF      lea d, [bp + -1] ; $p
1083   09DC DA            push d
1084   09DD FA FF FF      lea d, [bp + -1] ; $p
1085   09E0 2A            mov b, [d]
1086   09E1             ; START TERMS
1087   09E1 D7            push a
1088   09E2 11            mov a, b
1089   09E3 26 02 00      mov b, $2
1090   09E6 56            add b, a
1091   09E7 E4            pop a
1092   09E8             ; END TERMS
1093   09E8 E7            pop d
1094   09E9 FD 43         mov [d], b
1095   09EB             ;; break; 
1096   09EB 0A 19 0A      jmp _switch13_exit ; case break
1097   09EE             _switch13_case7:
1098   09EE             
1099   09EE             ; --- BEGIN INLINE ASM BLOCK
1100   09EE FA FF FF      lea d, [bp + -1] ; $p
1101   09F1 FD 2A         mov d, [d]
1102   09F3 FD 2A         mov d, [d]
1103   09F5 07 17 18      call _puts
1104   09F8             ; --- END INLINE ASM BLOCK
1105   09F8             
1106   09F8             ;; p = p + 2; 
1107   09F8 FA FF FF      lea d, [bp + -1] ; $p
1108   09FB DA            push d
1109   09FC FA FF FF      lea d, [bp + -1] ; $p
1110   09FF 2A            mov b, [d]
1111   0A00             ; START TERMS
1112   0A00 D7            push a
1113   0A01 11            mov a, b
1114   0A02 26 02 00      mov b, $2
1115   0A05 56            add b, a
1116   0A06 E4            pop a
1117   0A07             ; END TERMS
1118   0A07 E7            pop d
1119   0A08 FD 43         mov [d], b
1120   0A0A             ;; break; 
1121   0A0A 0A 19 0A      jmp _switch13_exit ; case break
1122   0A0D             _switch13_default:
1123   0A0D             ;; print("Error: Unknown argument type.\n"); 
1124   0A0D 26 BA 19      mov b, _s2 ; "Error: Unknown argument type.\n"
1125   0A10 FD AB         swp b
1126   0A12 D8            push b
1127   0A13 07 84 15      call print
1128   0A16 51 02 00      add sp, 2
1129   0A19             _switch13_exit:
1130   0A19             ;; format_p++; 
1131   0A19 FA FD FF      lea d, [bp + -3] ; $format_p
1132   0A1C 2A            mov b, [d]
1133   0A1D D8            push b
1134   0A1E FD 77         inc b
1135   0A20 FA FD FF      lea d, [bp + -3] ; $format_p
1136   0A23 FD 43         mov [d], b
1137   0A25 E5            pop b
1138   0A26 0A 45 0A      jmp _if12_exit
1139   0A29             _if12_else:
1140   0A29             ;; putchar(*format_p); 
1141   0A29 FA FD FF      lea d, [bp + -3] ; $format_p
1142   0A2C 2A            mov b, [d]
1143   0A2D 74            mov d, b
1144   0A2E 32            mov bl, [d]
1145   0A2F A7 00         mov bh, 0
1146   0A31 DD            push bl
1147   0A32 07 3C 15      call putchar
1148   0A35 51 01 00      add sp, 1
1149   0A38             ;; format_p++; 
1150   0A38 FA FD FF      lea d, [bp + -3] ; $format_p
1151   0A3B 2A            mov b, [d]
1152   0A3C D8            push b
1153   0A3D FD 77         inc b
1154   0A3F FA FD FF      lea d, [bp + -3] ; $format_p
1155   0A42 FD 43         mov [d], b
1156   0A44 E5            pop b
1157   0A45             _if12_exit:
1158   0A45             _if11_exit:
1159   0A45             _for10_update:
1160   0A45 0A 08 08      jmp _for10_cond
1161   0A48             _for10_exit:
1162   0A48 F9            leave
1163   0A49 09            ret
1164   0A4A             
1165   0A4A             scanf:
1166   0A4A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1167   0A4D             ;; char *p, *format_p; 
1168   0A4D 52 02 00      sub sp, 2 ; p
1169   0A50 52 02 00      sub sp, 2 ; format_p
1170   0A53             ;; char c; 
1171   0A53 52 01 00      sub sp, 1 ; c
1172   0A56             ;; int i; 
1173   0A56 52 02 00      sub sp, 2 ; i
1174   0A59             ;; char input_string[  512                    ]; 
1175   0A59 52 00 02      sub sp, 512 ; input_string
1176   0A5C             ;; format_p = format; 
1177   0A5C FA FD FF      lea d, [bp + -3] ; $format_p
1178   0A5F DA            push d
1179   0A60 FA 05 00      lea d, [bp + 5] ; $format
1180   0A63 2A            mov b, [d]
1181   0A64 E7            pop d
1182   0A65 FD 43         mov [d], b
1183   0A67             ;; p = &format + 2; 
1184   0A67 FA FF FF      lea d, [bp + -1] ; $p
1185   0A6A DA            push d
1186   0A6B FA 05 00      lea d, [bp + 5] ; $format
1187   0A6E 2D            mov b, d
1188   0A6F             ; START TERMS
1189   0A6F D7            push a
1190   0A70 11            mov a, b
1191   0A71 26 02 00      mov b, $2
1192   0A74 56            add b, a
1193   0A75 E4            pop a
1194   0A76             ; END TERMS
1195   0A76 E7            pop d
1196   0A77 FD 43         mov [d], b
1197   0A79             ;; for(;;){ 
1198   0A79             _for17_init:
1199   0A79             _for17_cond:
1200   0A79             _for17_block:
1201   0A79             ;; if(!*format_p) break; 
1202   0A79             _if18_cond:
1203   0A79 FA FD FF      lea d, [bp + -3] ; $format_p
1204   0A7C 2A            mov b, [d]
1205   0A7D 74            mov d, b
1206   0A7E 32            mov bl, [d]
1207   0A7F A7 00         mov bh, 0
1208   0A81 C0 00 00      cmp b, 0
1209   0A84 FD 71         seq ; !
1210   0A86 C0 00 00      cmp b, 0
1211   0A89 C6 92 0A      je _if18_else
1212   0A8C             _if18_true:
1213   0A8C             ;; break; 
1214   0A8C 0A 8F 0C      jmp _for17_exit ; for break
1215   0A8F 0A 8C 0C      jmp _if18_exit
1216   0A92             _if18_else:
1217   0A92             ;; if(*format_p == '%'){ 
1218   0A92             _if19_cond:
1219   0A92 FA FD FF      lea d, [bp + -3] ; $format_p
1220   0A95 2A            mov b, [d]
1221   0A96 74            mov d, b
1222   0A97 32            mov bl, [d]
1223   0A98 A7 00         mov bh, 0
1224   0A9A             ; START RELATIONAL
1225   0A9A D7            push a
1226   0A9B 11            mov a, b
1227   0A9C 26 25 00      mov b, $25
1228   0A9F B0            cmp a, b
1229   0AA0 FD 71         seq ; ==
1230   0AA2 E4            pop a
1231   0AA3             ; END RELATIONAL
1232   0AA3 C0 00 00      cmp b, 0
1233   0AA6 C6 70 0C      je _if19_else
1234   0AA9             _if19_true:
1235   0AA9             ;; format_p++; 
1236   0AA9 FA FD FF      lea d, [bp + -3] ; $format_p
1237   0AAC 2A            mov b, [d]
1238   0AAD D8            push b
1239   0AAE FD 77         inc b
1240   0AB0 FA FD FF      lea d, [bp + -3] ; $format_p
1241   0AB3 FD 43         mov [d], b
1242   0AB5 E5            pop b
1243   0AB6             ;; switch(*format_p){ 
1244   0AB6             _switch20_expr:
1245   0AB6 FA FD FF      lea d, [bp + -3] ; $format_p
1246   0AB9 2A            mov b, [d]
1247   0ABA 74            mov d, b
1248   0ABB 32            mov bl, [d]
1249   0ABC A7 00         mov bh, 0
1250   0ABE             _switch20_comparisons:
1251   0ABE C1 6C         cmp bl, $6c
1252   0AC0 C6 EC 0A      je _switch20_case0
1253   0AC3 C1 4C         cmp bl, $4c
1254   0AC5 C6 EC 0A      je _switch20_case1
1255   0AC8 C1 64         cmp bl, $64
1256   0ACA C6 7E 0B      je _switch20_case2
1257   0ACD C1 69         cmp bl, $69
1258   0ACF C6 7E 0B      je _switch20_case3
1259   0AD2 C1 75         cmp bl, $75
1260   0AD4 C6 AB 0B      je _switch20_case4
1261   0AD7 C1 78         cmp bl, $78
1262   0AD9 C6 D8 0B      je _switch20_case5
1263   0ADC C1 63         cmp bl, $63
1264   0ADE C6 ED 0B      je _switch20_case6
1265   0AE1 C1 73         cmp bl, $73
1266   0AE3 C6 1C 0C      je _switch20_case7
1267   0AE6 0A 54 0C      jmp _switch20_default
1268   0AE9 0A 60 0C      jmp _switch20_exit
1269   0AEC             _switch20_case0:
1270   0AEC             _switch20_case1:
1271   0AEC             ;; format_p++; 
1272   0AEC FA FD FF      lea d, [bp + -3] ; $format_p
1273   0AEF 2A            mov b, [d]
1274   0AF0 D8            push b
1275   0AF1 FD 77         inc b
1276   0AF3 FA FD FF      lea d, [bp + -3] ; $format_p
1277   0AF6 FD 43         mov [d], b
1278   0AF8 E5            pop b
1279   0AF9             ;; if(*format_p == 'd' || *format_p == 'i'); 
1280   0AF9             _if21_cond:
1281   0AF9 FA FD FF      lea d, [bp + -3] ; $format_p
1282   0AFC 2A            mov b, [d]
1283   0AFD 74            mov d, b
1284   0AFE 32            mov bl, [d]
1285   0AFF A7 00         mov bh, 0
1286   0B01             ; START RELATIONAL
1287   0B01 D7            push a
1288   0B02 11            mov a, b
1289   0B03 26 64 00      mov b, $64
1290   0B06 B0            cmp a, b
1291   0B07 FD 71         seq ; ==
1292   0B09 E4            pop a
1293   0B0A             ; END RELATIONAL
1294   0B0A D7            push a
1295   0B0B 11            mov a, b
1296   0B0C FA FD FF      lea d, [bp + -3] ; $format_p
1297   0B0F 2A            mov b, [d]
1298   0B10 74            mov d, b
1299   0B11 32            mov bl, [d]
1300   0B12 A7 00         mov bh, 0
1301   0B14             ; START RELATIONAL
1302   0B14 D7            push a
1303   0B15 11            mov a, b
1304   0B16 26 69 00      mov b, $69
1305   0B19 B0            cmp a, b
1306   0B1A FD 71         seq ; ==
1307   0B1C E4            pop a
1308   0B1D             ; END RELATIONAL
1309   0B1D FD A8         sor a, b ; ||
1310   0B1F E4            pop a
1311   0B20 C0 00 00      cmp b, 0
1312   0B23 C6 29 0B      je _if21_else
1313   0B26             _if21_true:
1314   0B26             ;; ; 
1315   0B26 0A 69 0B      jmp _if21_exit
1316   0B29             _if21_else:
1317   0B29             ;; if(*format_p == 'u'); 
1318   0B29             _if22_cond:
1319   0B29 FA FD FF      lea d, [bp + -3] ; $format_p
1320   0B2C 2A            mov b, [d]
1321   0B2D 74            mov d, b
1322   0B2E 32            mov bl, [d]
1323   0B2F A7 00         mov bh, 0
1324   0B31             ; START RELATIONAL
1325   0B31 D7            push a
1326   0B32 11            mov a, b
1327   0B33 26 75 00      mov b, $75
1328   0B36 B0            cmp a, b
1329   0B37 FD 71         seq ; ==
1330   0B39 E4            pop a
1331   0B3A             ; END RELATIONAL
1332   0B3A C0 00 00      cmp b, 0
1333   0B3D C6 43 0B      je _if22_else
1334   0B40             _if22_true:
1335   0B40             ;; ; 
1336   0B40 0A 69 0B      jmp _if22_exit
1337   0B43             _if22_else:
1338   0B43             ;; if(*format_p == 'x'); 
1339   0B43             _if23_cond:
1340   0B43 FA FD FF      lea d, [bp + -3] ; $format_p
1341   0B46 2A            mov b, [d]
1342   0B47 74            mov d, b
1343   0B48 32            mov bl, [d]
1344   0B49 A7 00         mov bh, 0
1345   0B4B             ; START RELATIONAL
1346   0B4B D7            push a
1347   0B4C 11            mov a, b
1348   0B4D 26 78 00      mov b, $78
1349   0B50 B0            cmp a, b
1350   0B51 FD 71         seq ; ==
1351   0B53 E4            pop a
1352   0B54             ; END RELATIONAL
1353   0B54 C0 00 00      cmp b, 0
1354   0B57 C6 5D 0B      je _if23_else
1355   0B5A             _if23_true:
1356   0B5A             ;; ; 
1357   0B5A 0A 69 0B      jmp _if23_exit
1358   0B5D             _if23_else:
1359   0B5D             ;; err("Unexpected format in printf."); 
1360   0B5D 26 9D 19      mov b, _s1 ; "Unexpected format in printf."
1361   0B60 FD AB         swp b
1362   0B62 D8            push b
1363   0B63 07 91 0C      call err
1364   0B66 51 02 00      add sp, 2
1365   0B69             _if23_exit:
1366   0B69             _if22_exit:
1367   0B69             _if21_exit:
1368   0B69             ;; p = p + 4; 
1369   0B69 FA FF FF      lea d, [bp + -1] ; $p
1370   0B6C DA            push d
1371   0B6D FA FF FF      lea d, [bp + -1] ; $p
1372   0B70 2A            mov b, [d]
1373   0B71             ; START TERMS
1374   0B71 D7            push a
1375   0B72 11            mov a, b
1376   0B73 26 04 00      mov b, $4
1377   0B76 56            add b, a
1378   0B77 E4            pop a
1379   0B78             ; END TERMS
1380   0B78 E7            pop d
1381   0B79 FD 43         mov [d], b
1382   0B7B             ;; break; 
1383   0B7B 0A 60 0C      jmp _switch20_exit ; case break
1384   0B7E             _switch20_case2:
1385   0B7E             _switch20_case3:
1386   0B7E             ;; i = scann(); 
1387   0B7E FA FA FF      lea d, [bp + -6] ; $i
1388   0B81 DA            push d
1389   0B82 07 5F 15      call scann
1390   0B85 E7            pop d
1391   0B86 FD 43         mov [d], b
1392   0B88             ;; **(int **)p = i; 
1393   0B88 FA FF FF      lea d, [bp + -1] ; $p
1394   0B8B 2A            mov b, [d]
1395   0B8C 74            mov d, b
1396   0B8D 2A            mov b, [d]
1397   0B8E D8            push b
1398   0B8F FA FA FF      lea d, [bp + -6] ; $i
1399   0B92 2A            mov b, [d]
1400   0B93 E7            pop d
1401   0B94 FD 43         mov [d], b
1402   0B96             ;; p = p + 2; 
1403   0B96 FA FF FF      lea d, [bp + -1] ; $p
1404   0B99 DA            push d
1405   0B9A FA FF FF      lea d, [bp + -1] ; $p
1406   0B9D 2A            mov b, [d]
1407   0B9E             ; START TERMS
1408   0B9E D7            push a
1409   0B9F 11            mov a, b
1410   0BA0 26 02 00      mov b, $2
1411   0BA3 56            add b, a
1412   0BA4 E4            pop a
1413   0BA5             ; END TERMS
1414   0BA5 E7            pop d
1415   0BA6 FD 43         mov [d], b
1416   0BA8             ;; break; 
1417   0BA8 0A 60 0C      jmp _switch20_exit ; case break
1418   0BAB             _switch20_case4:
1419   0BAB             ;; i = scann(); 
1420   0BAB FA FA FF      lea d, [bp + -6] ; $i
1421   0BAE DA            push d
1422   0BAF 07 5F 15      call scann
1423   0BB2 E7            pop d
1424   0BB3 FD 43         mov [d], b
1425   0BB5             ;; **(int **)p = i; 
1426   0BB5 FA FF FF      lea d, [bp + -1] ; $p
1427   0BB8 2A            mov b, [d]
1428   0BB9 74            mov d, b
1429   0BBA 2A            mov b, [d]
1430   0BBB D8            push b
1431   0BBC FA FA FF      lea d, [bp + -6] ; $i
1432   0BBF 2A            mov b, [d]
1433   0BC0 E7            pop d
1434   0BC1 FD 43         mov [d], b
1435   0BC3             ;; p = p + 2; 
1436   0BC3 FA FF FF      lea d, [bp + -1] ; $p
1437   0BC6 DA            push d
1438   0BC7 FA FF FF      lea d, [bp + -1] ; $p
1439   0BCA 2A            mov b, [d]
1440   0BCB             ; START TERMS
1441   0BCB D7            push a
1442   0BCC 11            mov a, b
1443   0BCD 26 02 00      mov b, $2
1444   0BD0 56            add b, a
1445   0BD1 E4            pop a
1446   0BD2             ; END TERMS
1447   0BD2 E7            pop d
1448   0BD3 FD 43         mov [d], b
1449   0BD5             ;; break; 
1450   0BD5 0A 60 0C      jmp _switch20_exit ; case break
1451   0BD8             _switch20_case5:
1452   0BD8             ;; p = p + 2; 
1453   0BD8 FA FF FF      lea d, [bp + -1] ; $p
1454   0BDB DA            push d
1455   0BDC FA FF FF      lea d, [bp + -1] ; $p
1456   0BDF 2A            mov b, [d]
1457   0BE0             ; START TERMS
1458   0BE0 D7            push a
1459   0BE1 11            mov a, b
1460   0BE2 26 02 00      mov b, $2
1461   0BE5 56            add b, a
1462   0BE6 E4            pop a
1463   0BE7             ; END TERMS
1464   0BE7 E7            pop d
1465   0BE8 FD 43         mov [d], b
1466   0BEA             ;; break; 
1467   0BEA 0A 60 0C      jmp _switch20_exit ; case break
1468   0BED             _switch20_case6:
1469   0BED             ;; c = getchar(); 
1470   0BED FA FC FF      lea d, [bp + -4] ; $c
1471   0BF0 DA            push d
1472   0BF1 07 49 15      call getchar
1473   0BF4 E7            pop d
1474   0BF5 FD 3E         mov [d], bl
1475   0BF7             ;; **(char **)p = c; 
1476   0BF7 FA FF FF      lea d, [bp + -1] ; $p
1477   0BFA 2A            mov b, [d]
1478   0BFB 74            mov d, b
1479   0BFC 2A            mov b, [d]
1480   0BFD D8            push b
1481   0BFE FA FC FF      lea d, [bp + -4] ; $c
1482   0C01 32            mov bl, [d]
1483   0C02 A7 00         mov bh, 0
1484   0C04 E7            pop d
1485   0C05 FD 43         mov [d], b
1486   0C07             ;; p = p + 2; 
1487   0C07 FA FF FF      lea d, [bp + -1] ; $p
1488   0C0A DA            push d
1489   0C0B FA FF FF      lea d, [bp + -1] ; $p
1490   0C0E 2A            mov b, [d]
1491   0C0F             ; START TERMS
1492   0C0F D7            push a
1493   0C10 11            mov a, b
1494   0C11 26 02 00      mov b, $2
1495   0C14 56            add b, a
1496   0C15 E4            pop a
1497   0C16             ; END TERMS
1498   0C16 E7            pop d
1499   0C17 FD 43         mov [d], b
1500   0C19             ;; break; 
1501   0C19 0A 60 0C      jmp _switch20_exit ; case break
1502   0C1C             _switch20_case7:
1503   0C1C             ;; gets(input_string); 
1504   0C1C FA FA FD      lea d, [bp + -518] ; $input_string
1505   0C1F 2D            mov b, d
1506   0C20 FD AB         swp b
1507   0C22 D8            push b
1508   0C23 07 1D 0E      call gets
1509   0C26 51 02 00      add sp, 2
1510   0C29             ;; strcpy(*(char **)p, input_string); 
1511   0C29 FA FA FD      lea d, [bp + -518] ; $input_string
1512   0C2C 2D            mov b, d
1513   0C2D FD AB         swp b
1514   0C2F D8            push b
1515   0C30 FA FF FF      lea d, [bp + -1] ; $p
1516   0C33 2A            mov b, [d]
1517   0C34 74            mov d, b
1518   0C35 2A            mov b, [d]
1519   0C36 FD AB         swp b
1520   0C38 D8            push b
1521   0C39 07 3E 04      call strcpy
1522   0C3C 51 04 00      add sp, 4
1523   0C3F             ;; p = p + 2; 
1524   0C3F FA FF FF      lea d, [bp + -1] ; $p
1525   0C42 DA            push d
1526   0C43 FA FF FF      lea d, [bp + -1] ; $p
1527   0C46 2A            mov b, [d]
1528   0C47             ; START TERMS
1529   0C47 D7            push a
1530   0C48 11            mov a, b
1531   0C49 26 02 00      mov b, $2
1532   0C4C 56            add b, a
1533   0C4D E4            pop a
1534   0C4E             ; END TERMS
1535   0C4E E7            pop d
1536   0C4F FD 43         mov [d], b
1537   0C51             ;; break; 
1538   0C51 0A 60 0C      jmp _switch20_exit ; case break
1539   0C54             _switch20_default:
1540   0C54             ;; print("Error: Unknown argument type.\n"); 
1541   0C54 26 BA 19      mov b, _s2 ; "Error: Unknown argument type.\n"
1542   0C57 FD AB         swp b
1543   0C59 D8            push b
1544   0C5A 07 84 15      call print
1545   0C5D 51 02 00      add sp, 2
1546   0C60             _switch20_exit:
1547   0C60             ;; format_p++; 
1548   0C60 FA FD FF      lea d, [bp + -3] ; $format_p
1549   0C63 2A            mov b, [d]
1550   0C64 D8            push b
1551   0C65 FD 77         inc b
1552   0C67 FA FD FF      lea d, [bp + -3] ; $format_p
1553   0C6A FD 43         mov [d], b
1554   0C6C E5            pop b
1555   0C6D 0A 8C 0C      jmp _if19_exit
1556   0C70             _if19_else:
1557   0C70             ;; putchar(*format_p); 
1558   0C70 FA FD FF      lea d, [bp + -3] ; $format_p
1559   0C73 2A            mov b, [d]
1560   0C74 74            mov d, b
1561   0C75 32            mov bl, [d]
1562   0C76 A7 00         mov bh, 0
1563   0C78 DD            push bl
1564   0C79 07 3C 15      call putchar
1565   0C7C 51 01 00      add sp, 1
1566   0C7F             ;; format_p++; 
1567   0C7F FA FD FF      lea d, [bp + -3] ; $format_p
1568   0C82 2A            mov b, [d]
1569   0C83 D8            push b
1570   0C84 FD 77         inc b
1571   0C86 FA FD FF      lea d, [bp + -3] ; $format_p
1572   0C89 FD 43         mov [d], b
1573   0C8B E5            pop b
1574   0C8C             _if19_exit:
1575   0C8C             _if18_exit:
1576   0C8C             _for17_update:
1577   0C8C 0A 79 0A      jmp _for17_cond
1578   0C8F             _for17_exit:
1579   0C8F F9            leave
1580   0C90 09            ret
1581   0C91             
1582   0C91             err:
1583   0C91 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1584   0C94             ;; print(e); 
1585   0C94 FA 05 00      lea d, [bp + 5] ; $e
1586   0C97 2A            mov b, [d]
1587   0C98 FD AB         swp b
1588   0C9A D8            push b
1589   0C9B 07 84 15      call print
1590   0C9E 51 02 00      add sp, 2
1591   0CA1 F9            leave
1592   0CA2 09            ret
1593   0CA3             
1594   0CA3             printx32:
1595   0CA3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1596   0CA6             
1597   0CA6             ; --- BEGIN INLINE ASM BLOCK
1598   0CA6 FA 05 00      lea d, [bp + 5] ; $hex
1599   0CA9 2B 02 00      mov b, [d+2]
1600   0CAC 07 6F 18      call print_u16x
1601   0CAF 2A            mov b, [d]
1602   0CB0 07 6F 18      call print_u16x
1603   0CB3             ; --- END INLINE ASM BLOCK
1604   0CB3             
1605   0CB3 F9            leave
1606   0CB4 09            ret
1607   0CB5             
1608   0CB5             printx16:
1609   0CB5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1610   0CB8             
1611   0CB8             ; --- BEGIN INLINE ASM BLOCK
1612   0CB8 FA 05 00      lea d, [bp + 5] ; $hex
1613   0CBB 2A            mov b, [d]
1614   0CBC 07 6F 18      call print_u16x
1615   0CBF             ; --- END INLINE ASM BLOCK
1616   0CBF             
1617   0CBF F9            leave
1618   0CC0 09            ret
1619   0CC1             
1620   0CC1             printx8:
1621   0CC1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1622   0CC4             
1623   0CC4             ; --- BEGIN INLINE ASM BLOCK
1624   0CC4 FA 05 00      lea d, [bp + 5] ; $hex
1625   0CC7 32            mov bl, [d]
1626   0CC8 07 B3 18      call print_u8x
1627   0CCB             ; --- END INLINE ASM BLOCK
1628   0CCB             
1629   0CCB F9            leave
1630   0CCC 09            ret
1631   0CCD             
1632   0CCD             hex_str_to_int:
1633   0CCD F8 00 00      enter 0 ; (push bp; mov bp, sp)
1634   0CD0             ;; int value = 0; 
1635   0CD0 52 02 00      sub sp, 2 ; value
1636   0CD3             ; --- START LOCAL VAR INITIALIZATION
1637   0CD3 FA FF FF      lea d, [bp + -1] ; $value
1638   0CD6 DA            push d
1639   0CD7 26 00 00      mov b, $0
1640   0CDA E7            pop d
1641   0CDB FD 43         mov [d], b
1642   0CDD             ; --- END LOCAL VAR INITIALIZATION
1643   0CDD             ;; int i; 
1644   0CDD 52 02 00      sub sp, 2 ; i
1645   0CE0             ;; char hex_char; 
1646   0CE0 52 01 00      sub sp, 1 ; hex_char
1647   0CE3             ;; int len; 
1648   0CE3 52 02 00      sub sp, 2 ; len
1649   0CE6             ;; len = strlen(hex_string); 
1650   0CE6 FA FA FF      lea d, [bp + -6] ; $len
1651   0CE9 DA            push d
1652   0CEA FA 05 00      lea d, [bp + 5] ; $hex_string
1653   0CED 2A            mov b, [d]
1654   0CEE FD AB         swp b
1655   0CF0 D8            push b
1656   0CF1 07 B8 05      call strlen
1657   0CF4 51 02 00      add sp, 2
1658   0CF7 E7            pop d
1659   0CF8 FD 43         mov [d], b
1660   0CFA             ;; for (i = 0; i < len; i++) { 
1661   0CFA             _for24_init:
1662   0CFA FA FD FF      lea d, [bp + -3] ; $i
1663   0CFD DA            push d
1664   0CFE 26 00 00      mov b, $0
1665   0D01 E7            pop d
1666   0D02 FD 43         mov [d], b
1667   0D04             _for24_cond:
1668   0D04 FA FD FF      lea d, [bp + -3] ; $i
1669   0D07 2A            mov b, [d]
1670   0D08             ; START RELATIONAL
1671   0D08 D7            push a
1672   0D09 11            mov a, b
1673   0D0A FA FA FF      lea d, [bp + -6] ; $len
1674   0D0D 2A            mov b, [d]
1675   0D0E B0            cmp a, b
1676   0D0F FD 73         slt ; < (signed)
1677   0D11 E4            pop a
1678   0D12             ; END RELATIONAL
1679   0D12 C0 00 00      cmp b, 0
1680   0D15 C6 17 0E      je _for24_exit
1681   0D18             _for24_block:
1682   0D18             ;; hex_char = hex_string[i]; 
1683   0D18 FA FC FF      lea d, [bp + -4] ; $hex_char
1684   0D1B DA            push d
1685   0D1C FA 05 00      lea d, [bp + 5] ; $hex_string
1686   0D1F FD 2A         mov d, [d]
1687   0D21 D7            push a
1688   0D22 DA            push d
1689   0D23 FA FD FF      lea d, [bp + -3] ; $i
1690   0D26 2A            mov b, [d]
1691   0D27 E7            pop d
1692   0D28 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
1693   0D2C E4            pop a
1694   0D2D 32            mov bl, [d]
1695   0D2E A7 00         mov bh, 0
1696   0D30 E7            pop d
1697   0D31 FD 3E         mov [d], bl
1698   0D33             ;; if (hex_char >= 'a' && hex_char <= 'f')  
1699   0D33             _if25_cond:
1700   0D33 FA FC FF      lea d, [bp + -4] ; $hex_char
1701   0D36 32            mov bl, [d]
1702   0D37 A7 00         mov bh, 0
1703   0D39             ; START RELATIONAL
1704   0D39 D7            push a
1705   0D3A 11            mov a, b
1706   0D3B 26 61 00      mov b, $61
1707   0D3E B0            cmp a, b
1708   0D3F FD 80         sge ; >=
1709   0D41 E4            pop a
1710   0D42             ; END RELATIONAL
1711   0D42 D7            push a
1712   0D43 11            mov a, b
1713   0D44 FA FC FF      lea d, [bp + -4] ; $hex_char
1714   0D47 32            mov bl, [d]
1715   0D48 A7 00         mov bh, 0
1716   0D4A             ; START RELATIONAL
1717   0D4A D7            push a
1718   0D4B 11            mov a, b
1719   0D4C 26 66 00      mov b, $66
1720   0D4F B0            cmp a, b
1721   0D50 FD 73         slt ; <= (signed)
1722   0D52 E4            pop a
1723   0D53             ; END RELATIONAL
1724   0D53 FD A7         sand a, b
1725   0D55 E4            pop a
1726   0D56 C0 00 00      cmp b, 0
1727   0D59 C6 8A 0D      je _if25_else
1728   0D5C             _if25_true:
1729   0D5C             ;; value = (value * 16) + (hex_char - 'a' + 10); 
1730   0D5C FA FF FF      lea d, [bp + -1] ; $value
1731   0D5F DA            push d
1732   0D60 FA FF FF      lea d, [bp + -1] ; $value
1733   0D63 2A            mov b, [d]
1734   0D64             ; START FACTORS
1735   0D64 D7            push a
1736   0D65 11            mov a, b
1737   0D66 26 10 00      mov b, $10
1738   0D69 AC            mul a, b ; *
1739   0D6A 11            mov a, b
1740   0D6B 27            mov b, a
1741   0D6C E4            pop a
1742   0D6D             ; END FACTORS
1743   0D6D             ; START TERMS
1744   0D6D D7            push a
1745   0D6E 11            mov a, b
1746   0D6F FA FC FF      lea d, [bp + -4] ; $hex_char
1747   0D72 32            mov bl, [d]
1748   0D73 A7 00         mov bh, 0
1749   0D75             ; START TERMS
1750   0D75 D7            push a
1751   0D76 11            mov a, b
1752   0D77 26 61 00      mov b, $61
1753   0D7A 60            sub a, b
1754   0D7B 27            mov b, a
1755   0D7C 11            mov a, b
1756   0D7D 26 0A 00      mov b, $a
1757   0D80 56            add b, a
1758   0D81 E4            pop a
1759   0D82             ; END TERMS
1760   0D82 56            add b, a
1761   0D83 E4            pop a
1762   0D84             ; END TERMS
1763   0D84 E7            pop d
1764   0D85 FD 43         mov [d], b
1765   0D87 0A 07 0E      jmp _if25_exit
1766   0D8A             _if25_else:
1767   0D8A             ;; if (hex_char >= 'A' && hex_char <= 'F')  
1768   0D8A             _if26_cond:
1769   0D8A FA FC FF      lea d, [bp + -4] ; $hex_char
1770   0D8D 32            mov bl, [d]
1771   0D8E A7 00         mov bh, 0
1772   0D90             ; START RELATIONAL
1773   0D90 D7            push a
1774   0D91 11            mov a, b
1775   0D92 26 41 00      mov b, $41
1776   0D95 B0            cmp a, b
1777   0D96 FD 80         sge ; >=
1778   0D98 E4            pop a
1779   0D99             ; END RELATIONAL
1780   0D99 D7            push a
1781   0D9A 11            mov a, b
1782   0D9B FA FC FF      lea d, [bp + -4] ; $hex_char
1783   0D9E 32            mov bl, [d]
1784   0D9F A7 00         mov bh, 0
1785   0DA1             ; START RELATIONAL
1786   0DA1 D7            push a
1787   0DA2 11            mov a, b
1788   0DA3 26 46 00      mov b, $46
1789   0DA6 B0            cmp a, b
1790   0DA7 FD 73         slt ; <= (signed)
1791   0DA9 E4            pop a
1792   0DAA             ; END RELATIONAL
1793   0DAA FD A7         sand a, b
1794   0DAC E4            pop a
1795   0DAD C0 00 00      cmp b, 0
1796   0DB0 C6 E1 0D      je _if26_else
1797   0DB3             _if26_true:
1798   0DB3             ;; value = (value * 16) + (hex_char - 'A' + 10); 
1799   0DB3 FA FF FF      lea d, [bp + -1] ; $value
1800   0DB6 DA            push d
1801   0DB7 FA FF FF      lea d, [bp + -1] ; $value
1802   0DBA 2A            mov b, [d]
1803   0DBB             ; START FACTORS
1804   0DBB D7            push a
1805   0DBC 11            mov a, b
1806   0DBD 26 10 00      mov b, $10
1807   0DC0 AC            mul a, b ; *
1808   0DC1 11            mov a, b
1809   0DC2 27            mov b, a
1810   0DC3 E4            pop a
1811   0DC4             ; END FACTORS
1812   0DC4             ; START TERMS
1813   0DC4 D7            push a
1814   0DC5 11            mov a, b
1815   0DC6 FA FC FF      lea d, [bp + -4] ; $hex_char
1816   0DC9 32            mov bl, [d]
1817   0DCA A7 00         mov bh, 0
1818   0DCC             ; START TERMS
1819   0DCC D7            push a
1820   0DCD 11            mov a, b
1821   0DCE 26 41 00      mov b, $41
1822   0DD1 60            sub a, b
1823   0DD2 27            mov b, a
1824   0DD3 11            mov a, b
1825   0DD4 26 0A 00      mov b, $a
1826   0DD7 56            add b, a
1827   0DD8 E4            pop a
1828   0DD9             ; END TERMS
1829   0DD9 56            add b, a
1830   0DDA E4            pop a
1831   0DDB             ; END TERMS
1832   0DDB E7            pop d
1833   0DDC FD 43         mov [d], b
1834   0DDE 0A 07 0E      jmp _if26_exit
1835   0DE1             _if26_else:
1836   0DE1             ;; value = (value * 16) + (hex_char - '0'); 
1837   0DE1 FA FF FF      lea d, [bp + -1] ; $value
1838   0DE4 DA            push d
1839   0DE5 FA FF FF      lea d, [bp + -1] ; $value
1840   0DE8 2A            mov b, [d]
1841   0DE9             ; START FACTORS
1842   0DE9 D7            push a
1843   0DEA 11            mov a, b
1844   0DEB 26 10 00      mov b, $10
1845   0DEE AC            mul a, b ; *
1846   0DEF 11            mov a, b
1847   0DF0 27            mov b, a
1848   0DF1 E4            pop a
1849   0DF2             ; END FACTORS
1850   0DF2             ; START TERMS
1851   0DF2 D7            push a
1852   0DF3 11            mov a, b
1853   0DF4 FA FC FF      lea d, [bp + -4] ; $hex_char
1854   0DF7 32            mov bl, [d]
1855   0DF8 A7 00         mov bh, 0
1856   0DFA             ; START TERMS
1857   0DFA D7            push a
1858   0DFB 11            mov a, b
1859   0DFC 26 30 00      mov b, $30
1860   0DFF 60            sub a, b
1861   0E00 27            mov b, a
1862   0E01 E4            pop a
1863   0E02             ; END TERMS
1864   0E02 56            add b, a
1865   0E03 E4            pop a
1866   0E04             ; END TERMS
1867   0E04 E7            pop d
1868   0E05 FD 43         mov [d], b
1869   0E07             _if26_exit:
1870   0E07             _if25_exit:
1871   0E07             _for24_update:
1872   0E07 FA FD FF      lea d, [bp + -3] ; $i
1873   0E0A 2A            mov b, [d]
1874   0E0B D8            push b
1875   0E0C FD 77         inc b
1876   0E0E FA FD FF      lea d, [bp + -3] ; $i
1877   0E11 FD 43         mov [d], b
1878   0E13 E5            pop b
1879   0E14 0A 04 0D      jmp _for24_cond
1880   0E17             _for24_exit:
1881   0E17             ;; return value; 
1882   0E17 FA FF FF      lea d, [bp + -1] ; $value
1883   0E1A 2A            mov b, [d]
1884   0E1B F9            leave
1885   0E1C 09            ret
1886   0E1D             
1887   0E1D             gets:
1888   0E1D F8 00 00      enter 0 ; (push bp; mov bp, sp)
1889   0E20             
1890   0E20             ; --- BEGIN INLINE ASM BLOCK
1891   0E20 FA 05 00      lea d, [bp + 5] ; $s
1892   0E23 15            mov a, [d]
1893   0E24 3C            mov d, a
1894   0E25 07 D4 16      call _gets
1895   0E28             ; --- END INLINE ASM BLOCK
1896   0E28             
1897   0E28             ;; return strlen(s); 
1898   0E28 FA 05 00      lea d, [bp + 5] ; $s
1899   0E2B 2A            mov b, [d]
1900   0E2C FD AB         swp b
1901   0E2E D8            push b
1902   0E2F 07 B8 05      call strlen
1903   0E32 51 02 00      add sp, 2
1904   0E35 F9            leave
1905   0E36 09            ret
1906   0E37             
1907   0E37             print_signed:
1908   0E37 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1909   0E3A             ;; char digits[5]; 
1910   0E3A 52 05 00      sub sp, 5 ; digits
1911   0E3D             ;; int i = 0; 
1912   0E3D 52 02 00      sub sp, 2 ; i
1913   0E40             ; --- START LOCAL VAR INITIALIZATION
1914   0E40 FA FA FF      lea d, [bp + -6] ; $i
1915   0E43 DA            push d
1916   0E44 26 00 00      mov b, $0
1917   0E47 E7            pop d
1918   0E48 FD 43         mov [d], b
1919   0E4A             ; --- END LOCAL VAR INITIALIZATION
1920   0E4A             ;; if (num < 0) { 
1921   0E4A             _if27_cond:
1922   0E4A FA 05 00      lea d, [bp + 5] ; $num
1923   0E4D 2A            mov b, [d]
1924   0E4E             ; START RELATIONAL
1925   0E4E D7            push a
1926   0E4F 11            mov a, b
1927   0E50 26 00 00      mov b, $0
1928   0E53 B0            cmp a, b
1929   0E54 FD 73         slt ; < (signed)
1930   0E56 E4            pop a
1931   0E57             ; END RELATIONAL
1932   0E57 C0 00 00      cmp b, 0
1933   0E5A C6 77 0E      je _if27_else
1934   0E5D             _if27_true:
1935   0E5D             ;; putchar('-'); 
1936   0E5D 26 2D 00      mov b, $2d
1937   0E60 DD            push bl
1938   0E61 07 3C 15      call putchar
1939   0E64 51 01 00      add sp, 1
1940   0E67             ;; num = -num; 
1941   0E67 FA 05 00      lea d, [bp + 5] ; $num
1942   0E6A DA            push d
1943   0E6B FA 05 00      lea d, [bp + 5] ; $num
1944   0E6E 2A            mov b, [d]
1945   0E6F FD 97         neg b
1946   0E71 E7            pop d
1947   0E72 FD 43         mov [d], b
1948   0E74 0A 99 0E      jmp _if27_exit
1949   0E77             _if27_else:
1950   0E77             ;; if (num == 0) { 
1951   0E77             _if28_cond:
1952   0E77 FA 05 00      lea d, [bp + 5] ; $num
1953   0E7A 2A            mov b, [d]
1954   0E7B             ; START RELATIONAL
1955   0E7B D7            push a
1956   0E7C 11            mov a, b
1957   0E7D 26 00 00      mov b, $0
1958   0E80 B0            cmp a, b
1959   0E81 FD 71         seq ; ==
1960   0E83 E4            pop a
1961   0E84             ; END RELATIONAL
1962   0E84 C0 00 00      cmp b, 0
1963   0E87 C6 99 0E      je _if28_exit
1964   0E8A             _if28_true:
1965   0E8A             ;; putchar('0'); 
1966   0E8A 26 30 00      mov b, $30
1967   0E8D DD            push bl
1968   0E8E 07 3C 15      call putchar
1969   0E91 51 01 00      add sp, 1
1970   0E94             ;; return; 
1971   0E94 F9            leave
1972   0E95 09            ret
1973   0E96 0A 99 0E      jmp _if28_exit
1974   0E99             _if28_exit:
1975   0E99             _if27_exit:
1976   0E99             ;; while (num > 0) { 
1977   0E99             _while29_cond:
1978   0E99 FA 05 00      lea d, [bp + 5] ; $num
1979   0E9C 2A            mov b, [d]
1980   0E9D             ; START RELATIONAL
1981   0E9D D7            push a
1982   0E9E 11            mov a, b
1983   0E9F 26 00 00      mov b, $0
1984   0EA2 B0            cmp a, b
1985   0EA3 FD 7F         sgt ; >
1986   0EA5 E4            pop a
1987   0EA6             ; END RELATIONAL
1988   0EA6 C0 00 00      cmp b, 0
1989   0EA9 C6 F3 0E      je _while29_exit
1990   0EAC             _while29_block:
1991   0EAC             ;; digits[i] = '0' + (num % 10); 
1992   0EAC FA FC FF      lea d, [bp + -4] ; $digits
1993   0EAF D7            push a
1994   0EB0 DA            push d
1995   0EB1 FA FA FF      lea d, [bp + -6] ; $i
1996   0EB4 2A            mov b, [d]
1997   0EB5 E7            pop d
1998   0EB6 5A            add d, b
1999   0EB7 E4            pop a
2000   0EB8 DA            push d
2001   0EB9 26 30 00      mov b, $30
2002   0EBC             ; START TERMS
2003   0EBC D7            push a
2004   0EBD 11            mov a, b
2005   0EBE FA 05 00      lea d, [bp + 5] ; $num
2006   0EC1 2A            mov b, [d]
2007   0EC2             ; START FACTORS
2008   0EC2 D7            push a
2009   0EC3 11            mov a, b
2010   0EC4 26 0A 00      mov b, $a
2011   0EC7 AE            div a, b ; 
2012   0EC8 11            mov a, b
2013   0EC9 27            mov b, a
2014   0ECA E4            pop a
2015   0ECB             ; END FACTORS
2016   0ECB 56            add b, a
2017   0ECC E4            pop a
2018   0ECD             ; END TERMS
2019   0ECD E7            pop d
2020   0ECE FD 3E         mov [d], bl
2021   0ED0             ;; num = num / 10; 
2022   0ED0 FA 05 00      lea d, [bp + 5] ; $num
2023   0ED3 DA            push d
2024   0ED4 FA 05 00      lea d, [bp + 5] ; $num
2025   0ED7 2A            mov b, [d]
2026   0ED8             ; START FACTORS
2027   0ED8 D7            push a
2028   0ED9 11            mov a, b
2029   0EDA 26 0A 00      mov b, $a
2030   0EDD AE            div a, b
2031   0EDE 27            mov b, a
2032   0EDF E4            pop a
2033   0EE0             ; END FACTORS
2034   0EE0 E7            pop d
2035   0EE1 FD 43         mov [d], b
2036   0EE3             ;; i++; 
2037   0EE3 FA FA FF      lea d, [bp + -6] ; $i
2038   0EE6 2A            mov b, [d]
2039   0EE7 D8            push b
2040   0EE8 FD 77         inc b
2041   0EEA FA FA FF      lea d, [bp + -6] ; $i
2042   0EED FD 43         mov [d], b
2043   0EEF E5            pop b
2044   0EF0 0A 99 0E      jmp _while29_cond
2045   0EF3             _while29_exit:
2046   0EF3             ;; while (i > 0) { 
2047   0EF3             _while30_cond:
2048   0EF3 FA FA FF      lea d, [bp + -6] ; $i
2049   0EF6 2A            mov b, [d]
2050   0EF7             ; START RELATIONAL
2051   0EF7 D7            push a
2052   0EF8 11            mov a, b
2053   0EF9 26 00 00      mov b, $0
2054   0EFC B0            cmp a, b
2055   0EFD FD 7F         sgt ; >
2056   0EFF E4            pop a
2057   0F00             ; END RELATIONAL
2058   0F00 C0 00 00      cmp b, 0
2059   0F03 C6 2C 0F      je _while30_exit
2060   0F06             _while30_block:
2061   0F06             ;; i--; 
2062   0F06 FA FA FF      lea d, [bp + -6] ; $i
2063   0F09 2A            mov b, [d]
2064   0F0A D8            push b
2065   0F0B FD 7D         dec b
2066   0F0D FA FA FF      lea d, [bp + -6] ; $i
2067   0F10 FD 43         mov [d], b
2068   0F12 E5            pop b
2069   0F13             ;; putchar(digits[i]); 
2070   0F13 FA FC FF      lea d, [bp + -4] ; $digits
2071   0F16 D7            push a
2072   0F17 DA            push d
2073   0F18 FA FA FF      lea d, [bp + -6] ; $i
2074   0F1B 2A            mov b, [d]
2075   0F1C E7            pop d
2076   0F1D 5A            add d, b
2077   0F1E E4            pop a
2078   0F1F 32            mov bl, [d]
2079   0F20 A7 00         mov bh, 0
2080   0F22 DD            push bl
2081   0F23 07 3C 15      call putchar
2082   0F26 51 01 00      add sp, 1
2083   0F29 0A F3 0E      jmp _while30_cond
2084   0F2C             _while30_exit:
2085   0F2C F9            leave
2086   0F2D 09            ret
2087   0F2E             
2088   0F2E             print_signed_long:
2089   0F2E F8 00 00      enter 0 ; (push bp; mov bp, sp)
2090   0F31             ;; char digits[10]; 
2091   0F31 52 0A 00      sub sp, 10 ; digits
2092   0F34             ;; int i = 0; 
2093   0F34 52 02 00      sub sp, 2 ; i
2094   0F37             ; --- START LOCAL VAR INITIALIZATION
2095   0F37 FA F5 FF      lea d, [bp + -11] ; $i
2096   0F3A DA            push d
2097   0F3B 26 00 00      mov b, $0
2098   0F3E E7            pop d
2099   0F3F FD 43         mov [d], b
2100   0F41             ; --- END LOCAL VAR INITIALIZATION
2101   0F41             ;; if (num < 0) { 
2102   0F41             _if31_cond:
2103   0F41 FA 05 00      lea d, [bp + 5] ; $num
2104   0F44 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2105   0F47 FD 39         mov c, b ; And place it into C
2106   0F49 2A            mov b, [d] ; Lower Word in B
2107   0F4A             ; START RELATIONAL
2108   0F4A D7            push a
2109   0F4B FD D8         push g
2110   0F4D 11            mov a, b
2111   0F4E FD 7A         mov g, c
2112   0F50 26 00 00      mov b, $0
2113   0F53 38 00 00      mov c, 0
2114   0F56 FD AF 00 00   cmp32 ga, cb
2114   0F5A 00 00 00 00 
2114   0F5E 00 00 00 00 
2114   0F62 00 00 00 00 
2114   0F66 00 00 00 00 
2114   0F6A 00 00 00 00 
2114   0F6E 00 00 00 00 
2114   0F72 00 00 00 00 
2114   0F76 00 00 00 00 
2114   0F7A 00 00 00 00 
2114   0F7E 00 00 00 00 
2114   0F82 00 00 00 00 
2114   0F86 00 00 00 00 
2114   0F8A 00 00 00 00 
2114   0F8E 00 00 00 00 
2114   0F92 00 00 00 00 
2114   0F96 00 00 00 00 
2114   0F9A 00 00 00 00 
2114   0F9E 00 00 00 00 
2114   0FA2 00 00 00 00 
2114   0FA6 00 00 00 00 
2114   0FAA 00 00 00 00 
2114   0FAE 00 00 00 00 
2114   0FB2 00 00 00 00 
2114   0FB6 00 00 00 00 
2114   0FBA 00 00 00 00 
2114   0FBE 00 00 00 00 
2114   0FC2 00 00 00 00 
2114   0FC6 00 00 00 00 
2114   0FCA 00 00 00 00 
2114   0FCE 00 00 00 00 
2114   0FD2 00 00 00 00 
2114   0FD6 00 00 00 00 
2114   0FDA 00 00 00 00 
2114   0FDE 00 00 00 00 
2114   0FE2 00 00 00 00 
2114   0FE6 00 00 00 00 
2114   0FEA 00 00 00 00 
2114   0FEE 00 00 00 00 
2114   0FF2 00 00 00 00 
2114   0FF6 00 00 00 00 
2114   0FFA 00 00 00 00 
2114   0FFE 00 00 00 00 
2114   1002 00 00 00 00 
2114   1006 00 00 00 00 
2114   100A 00 00 00 00 
2114   100E 00 00 00 00 
2114   1012 00 00 00 00 
2114   1016 00 00 00 00 
2114   101A 00 00 00 00 
2114   101E 00 00 00 00 
2114   1022 00 00 00 00 
2114   1026 00 00 00 00 
2114   102A 00 00 00 00 
2114   102E 00 00 00 00 
2114   1032 00 00 00 00 
2114   1036 00 00 00 00 
2114   103A 00 00 00 00 
2114   103E 00 00 00 00 
2114   1042 00 00 00 00 
2114   1046 00 00 00 00 
2114   104A 00 00 00 00 
2114   104E 00 00 00 00 
2114   1052 00 00 00 00 
2114   1056 00 
2115   1057 FD 73         slt ; <
2116   1059 FD F1         pop g
2117   105B E4            pop a
2118   105C             ; END RELATIONAL
2119   105C C0 00 00      cmp b, 0
2120   105F C6 86 10      je _if31_else
2121   1062             _if31_true:
2122   1062             ;; putchar('-'); 
2123   1062 26 2D 00      mov b, $2d
2124   1065 DD            push bl
2125   1066 07 3C 15      call putchar
2126   1069 51 01 00      add sp, 1
2127   106C             ;; num = -num; 
2128   106C FA 05 00      lea d, [bp + 5] ; $num
2129   106F DA            push d
2130   1070 FA 05 00      lea d, [bp + 5] ; $num
2131   1073 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2132   1076 FD 39         mov c, b ; And place it into C
2133   1078 2A            mov b, [d] ; Lower Word in B
2134   1079 FD 97         neg b
2135   107B E7            pop d
2136   107C FD 43         mov [d], b
2137   107E 28            mov b, c
2138   107F FD 44 02 00   mov [d + 2], b
2139   1083 0A B6 11      jmp _if31_exit
2140   1086             _if31_else:
2141   1086             ;; if (num == 0) { 
2142   1086             _if32_cond:
2143   1086 FA 05 00      lea d, [bp + 5] ; $num
2144   1089 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2145   108C FD 39         mov c, b ; And place it into C
2146   108E 2A            mov b, [d] ; Lower Word in B
2147   108F             ; START RELATIONAL
2148   108F D7            push a
2149   1090 FD D8         push g
2150   1092 11            mov a, b
2151   1093 FD 7A         mov g, c
2152   1095 26 00 00      mov b, $0
2153   1098 38 00 00      mov c, 0
2154   109B FD AF 00 00   cmp32 ga, cb
2154   109F 00 00 00 00 
2154   10A3 00 00 00 00 
2154   10A7 00 00 00 00 
2154   10AB 00 00 00 00 
2154   10AF 00 00 00 00 
2154   10B3 00 00 00 00 
2154   10B7 00 00 00 00 
2154   10BB 00 00 00 00 
2154   10BF 00 00 00 00 
2154   10C3 00 00 00 00 
2154   10C7 00 00 00 00 
2154   10CB 00 00 00 00 
2154   10CF 00 00 00 00 
2154   10D3 00 00 00 00 
2154   10D7 00 00 00 00 
2154   10DB 00 00 00 00 
2154   10DF 00 00 00 00 
2154   10E3 00 00 00 00 
2154   10E7 00 00 00 00 
2154   10EB 00 00 00 00 
2154   10EF 00 00 00 00 
2154   10F3 00 00 00 00 
2154   10F7 00 00 00 00 
2154   10FB 00 00 00 00 
2154   10FF 00 00 00 00 
2154   1103 00 00 00 00 
2154   1107 00 00 00 00 
2154   110B 00 00 00 00 
2154   110F 00 00 00 00 
2154   1113 00 00 00 00 
2154   1117 00 00 00 00 
2154   111B 00 00 00 00 
2154   111F 00 00 00 00 
2154   1123 00 00 00 00 
2154   1127 00 00 00 00 
2154   112B 00 00 00 00 
2154   112F 00 00 00 00 
2154   1133 00 00 00 00 
2154   1137 00 00 00 00 
2154   113B 00 00 00 00 
2154   113F 00 00 00 00 
2154   1143 00 00 00 00 
2154   1147 00 00 00 00 
2154   114B 00 00 00 00 
2154   114F 00 00 00 00 
2154   1153 00 00 00 00 
2154   1157 00 00 00 00 
2154   115B 00 00 00 00 
2154   115F 00 00 00 00 
2154   1163 00 00 00 00 
2154   1167 00 00 00 00 
2154   116B 00 00 00 00 
2154   116F 00 00 00 00 
2154   1173 00 00 00 00 
2154   1177 00 00 00 00 
2154   117B 00 00 00 00 
2154   117F 00 00 00 00 
2154   1183 00 00 00 00 
2154   1187 00 00 00 00 
2154   118B 00 00 00 00 
2154   118F 00 00 00 00 
2154   1193 00 00 00 00 
2154   1197 00 00 00 00 
2154   119B 00 
2155   119C FD 71         seq ; ==
2156   119E FD F1         pop g
2157   11A0 E4            pop a
2158   11A1             ; END RELATIONAL
2159   11A1 C0 00 00      cmp b, 0
2160   11A4 C6 B6 11      je _if32_exit
2161   11A7             _if32_true:
2162   11A7             ;; putchar('0'); 
2163   11A7 26 30 00      mov b, $30
2164   11AA DD            push bl
2165   11AB 07 3C 15      call putchar
2166   11AE 51 01 00      add sp, 1
2167   11B1             ;; return; 
2168   11B1 F9            leave
2169   11B2 09            ret
2170   11B3 0A B6 11      jmp _if32_exit
2171   11B6             _if32_exit:
2172   11B6             _if31_exit:
2173   11B6             ;; while (num > 0) { 
2174   11B6             _while33_cond:
2175   11B6 FA 05 00      lea d, [bp + 5] ; $num
2176   11B9 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2177   11BC FD 39         mov c, b ; And place it into C
2178   11BE 2A            mov b, [d] ; Lower Word in B
2179   11BF             ; START RELATIONAL
2180   11BF D7            push a
2181   11C0 FD D8         push g
2182   11C2 11            mov a, b
2183   11C3 FD 7A         mov g, c
2184   11C5 26 00 00      mov b, $0
2185   11C8 38 00 00      mov c, 0
2186   11CB FD 7F         sgt
2187   11CD FD F1         pop g
2188   11CF E4            pop a
2189   11D0             ; END RELATIONAL
2190   11D0 C0 00 00      cmp b, 0
2191   11D3 C6 33 12      je _while33_exit
2192   11D6             _while33_block:
2193   11D6             ;; digits[i] = '0' + (num % 10); 
2194   11D6 FA F7 FF      lea d, [bp + -9] ; $digits
2195   11D9 D7            push a
2196   11DA DA            push d
2197   11DB FA F5 FF      lea d, [bp + -11] ; $i
2198   11DE 2A            mov b, [d]
2199   11DF E7            pop d
2200   11E0 5A            add d, b
2201   11E1 E4            pop a
2202   11E2 DA            push d
2203   11E3 26 30 00      mov b, $30
2204   11E6             ; START TERMS
2205   11E6 D7            push a
2206   11E7 11            mov a, b
2207   11E8 FA 05 00      lea d, [bp + 5] ; $num
2208   11EB 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2209   11EE FD 39         mov c, b ; And place it into C
2210   11F0 2A            mov b, [d] ; Lower Word in B
2211   11F1             ; START FACTORS
2212   11F1 D7            push a
2213   11F2 11            mov a, b
2214   11F3 26 0A 00      mov b, $a
2215   11F6 AE            div a, b ; 
2216   11F7 11            mov a, b
2217   11F8 27            mov b, a
2218   11F9 E4            pop a
2219   11FA             ; END FACTORS
2220   11FA 54            add a, b
2221   11FB D7            push a
2222   11FC FD 12         mov a, g
2223   11FE 28            mov b, c
2224   11FF 5C            adc a, b
2225   1200 39            mov c, a
2226   1201 E5            pop b
2227   1202 E4            pop a
2228   1203             ; END TERMS
2229   1203 E7            pop d
2230   1204 FD 3E         mov [d], bl
2231   1206             ;; num = num / 10; 
2232   1206 FA 05 00      lea d, [bp + 5] ; $num
2233   1209 DA            push d
2234   120A FA 05 00      lea d, [bp + 5] ; $num
2235   120D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2236   1210 FD 39         mov c, b ; And place it into C
2237   1212 2A            mov b, [d] ; Lower Word in B
2238   1213             ; START FACTORS
2239   1213 D7            push a
2240   1214 11            mov a, b
2241   1215 26 0A 00      mov b, $a
2242   1218 AE            div a, b
2243   1219 27            mov b, a
2244   121A E4            pop a
2245   121B             ; END FACTORS
2246   121B E7            pop d
2247   121C FD 43         mov [d], b
2248   121E 28            mov b, c
2249   121F FD 44 02 00   mov [d + 2], b
2250   1223             ;; i++; 
2251   1223 FA F5 FF      lea d, [bp + -11] ; $i
2252   1226 2A            mov b, [d]
2253   1227 D8            push b
2254   1228 FD 77         inc b
2255   122A FA F5 FF      lea d, [bp + -11] ; $i
2256   122D FD 43         mov [d], b
2257   122F E5            pop b
2258   1230 0A B6 11      jmp _while33_cond
2259   1233             _while33_exit:
2260   1233             ;; while (i > 0) { 
2261   1233             _while34_cond:
2262   1233 FA F5 FF      lea d, [bp + -11] ; $i
2263   1236 2A            mov b, [d]
2264   1237             ; START RELATIONAL
2265   1237 D7            push a
2266   1238 11            mov a, b
2267   1239 26 00 00      mov b, $0
2268   123C B0            cmp a, b
2269   123D FD 7F         sgt ; >
2270   123F E4            pop a
2271   1240             ; END RELATIONAL
2272   1240 C0 00 00      cmp b, 0
2273   1243 C6 6C 12      je _while34_exit
2274   1246             _while34_block:
2275   1246             ;; i--; 
2276   1246 FA F5 FF      lea d, [bp + -11] ; $i
2277   1249 2A            mov b, [d]
2278   124A D8            push b
2279   124B FD 7D         dec b
2280   124D FA F5 FF      lea d, [bp + -11] ; $i
2281   1250 FD 43         mov [d], b
2282   1252 E5            pop b
2283   1253             ;; putchar(digits[i]); 
2284   1253 FA F7 FF      lea d, [bp + -9] ; $digits
2285   1256 D7            push a
2286   1257 DA            push d
2287   1258 FA F5 FF      lea d, [bp + -11] ; $i
2288   125B 2A            mov b, [d]
2289   125C E7            pop d
2290   125D 5A            add d, b
2291   125E E4            pop a
2292   125F 32            mov bl, [d]
2293   1260 A7 00         mov bh, 0
2294   1262 DD            push bl
2295   1263 07 3C 15      call putchar
2296   1266 51 01 00      add sp, 1
2297   1269 0A 33 12      jmp _while34_cond
2298   126C             _while34_exit:
2299   126C F9            leave
2300   126D 09            ret
2301   126E             
2302   126E             print_unsigned_long:
2303   126E F8 00 00      enter 0 ; (push bp; mov bp, sp)
2304   1271             ;; char digits[10]; 
2305   1271 52 0A 00      sub sp, 10 ; digits
2306   1274             ;; int i; 
2307   1274 52 02 00      sub sp, 2 ; i
2308   1277             ;; i = 0; 
2309   1277 FA F5 FF      lea d, [bp + -11] ; $i
2310   127A DA            push d
2311   127B 26 00 00      mov b, $0
2312   127E E7            pop d
2313   127F FD 43         mov [d], b
2314   1281             ;; if(num == 0){ 
2315   1281             _if35_cond:
2316   1281 FA 05 00      lea d, [bp + 5] ; $num
2317   1284 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2318   1287 FD 39         mov c, b ; And place it into C
2319   1289 2A            mov b, [d] ; Lower Word in B
2320   128A             ; START RELATIONAL
2321   128A D7            push a
2322   128B FD D8         push g
2323   128D 11            mov a, b
2324   128E FD 7A         mov g, c
2325   1290 26 00 00      mov b, $0
2326   1293 38 00 00      mov c, 0
2327   1296 FD AF 00 00   cmp32 ga, cb
2327   129A 00 00 00 00 
2327   129E 00 00 00 00 
2327   12A2 00 00 00 00 
2327   12A6 00 00 00 00 
2327   12AA 00 00 00 00 
2327   12AE 00 00 00 00 
2327   12B2 00 00 00 00 
2327   12B6 00 00 00 00 
2327   12BA 00 00 00 00 
2327   12BE 00 00 00 00 
2327   12C2 00 00 00 00 
2327   12C6 00 00 00 00 
2327   12CA 00 00 00 00 
2327   12CE 00 00 00 00 
2327   12D2 00 00 00 00 
2327   12D6 00 00 00 00 
2327   12DA 00 00 00 00 
2327   12DE 00 00 00 00 
2327   12E2 00 00 00 00 
2327   12E6 00 00 00 00 
2327   12EA 00 00 00 00 
2327   12EE 00 00 00 00 
2327   12F2 00 00 00 00 
2327   12F6 00 00 00 00 
2327   12FA 00 00 00 00 
2327   12FE 00 00 00 00 
2327   1302 00 00 00 00 
2327   1306 00 00 00 00 
2327   130A 00 00 00 00 
2327   130E 00 00 00 00 
2327   1312 00 00 00 00 
2327   1316 00 00 00 00 
2327   131A 00 00 00 00 
2327   131E 00 00 00 00 
2327   1322 00 00 00 00 
2327   1326 00 00 00 00 
2327   132A 00 00 00 00 
2327   132E 00 00 00 00 
2327   1332 00 00 00 00 
2327   1336 00 00 00 00 
2327   133A 00 00 00 00 
2327   133E 00 00 00 00 
2327   1342 00 00 00 00 
2327   1346 00 00 00 00 
2327   134A 00 00 00 00 
2327   134E 00 00 00 00 
2327   1352 00 00 00 00 
2327   1356 00 00 00 00 
2327   135A 00 00 00 00 
2327   135E 00 00 00 00 
2327   1362 00 00 00 00 
2327   1366 00 00 00 00 
2327   136A 00 00 00 00 
2327   136E 00 00 00 00 
2327   1372 00 00 00 00 
2327   1376 00 00 00 00 
2327   137A 00 00 00 00 
2327   137E 00 00 00 00 
2327   1382 00 00 00 00 
2327   1386 00 00 00 00 
2327   138A 00 00 00 00 
2327   138E 00 00 00 00 
2327   1392 00 00 00 00 
2327   1396 00 
2328   1397 FD 71         seq ; ==
2329   1399 FD F1         pop g
2330   139B E4            pop a
2331   139C             ; END RELATIONAL
2332   139C C0 00 00      cmp b, 0
2333   139F C6 B1 13      je _if35_exit
2334   13A2             _if35_true:
2335   13A2             ;; putchar('0'); 
2336   13A2 26 30 00      mov b, $30
2337   13A5 DD            push bl
2338   13A6 07 3C 15      call putchar
2339   13A9 51 01 00      add sp, 1
2340   13AC             ;; return; 
2341   13AC F9            leave
2342   13AD 09            ret
2343   13AE 0A B1 13      jmp _if35_exit
2344   13B1             _if35_exit:
2345   13B1             ;; while (num > 0) { 
2346   13B1             _while36_cond:
2347   13B1 FA 05 00      lea d, [bp + 5] ; $num
2348   13B4 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2349   13B7 FD 39         mov c, b ; And place it into C
2350   13B9 2A            mov b, [d] ; Lower Word in B
2351   13BA             ; START RELATIONAL
2352   13BA D7            push a
2353   13BB FD D8         push g
2354   13BD 11            mov a, b
2355   13BE FD 7A         mov g, c
2356   13C0 26 00 00      mov b, $0
2357   13C3 38 00 00      mov c, 0
2358   13C6 FD 81         sgu
2359   13C8 FD F1         pop g
2360   13CA E4            pop a
2361   13CB             ; END RELATIONAL
2362   13CB C0 00 00      cmp b, 0
2363   13CE C6 2E 14      je _while36_exit
2364   13D1             _while36_block:
2365   13D1             ;; digits[i] = '0' + (num % 10); 
2366   13D1 FA F7 FF      lea d, [bp + -9] ; $digits
2367   13D4 D7            push a
2368   13D5 DA            push d
2369   13D6 FA F5 FF      lea d, [bp + -11] ; $i
2370   13D9 2A            mov b, [d]
2371   13DA E7            pop d
2372   13DB 5A            add d, b
2373   13DC E4            pop a
2374   13DD DA            push d
2375   13DE 26 30 00      mov b, $30
2376   13E1             ; START TERMS
2377   13E1 D7            push a
2378   13E2 11            mov a, b
2379   13E3 FA 05 00      lea d, [bp + 5] ; $num
2380   13E6 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2381   13E9 FD 39         mov c, b ; And place it into C
2382   13EB 2A            mov b, [d] ; Lower Word in B
2383   13EC             ; START FACTORS
2384   13EC D7            push a
2385   13ED 11            mov a, b
2386   13EE 26 0A 00      mov b, $a
2387   13F1 AE            div a, b ; 
2388   13F2 11            mov a, b
2389   13F3 27            mov b, a
2390   13F4 E4            pop a
2391   13F5             ; END FACTORS
2392   13F5 54            add a, b
2393   13F6 D7            push a
2394   13F7 FD 12         mov a, g
2395   13F9 28            mov b, c
2396   13FA 5C            adc a, b
2397   13FB 39            mov c, a
2398   13FC E5            pop b
2399   13FD E4            pop a
2400   13FE             ; END TERMS
2401   13FE E7            pop d
2402   13FF FD 3E         mov [d], bl
2403   1401             ;; num = num / 10; 
2404   1401 FA 05 00      lea d, [bp + 5] ; $num
2405   1404 DA            push d
2406   1405 FA 05 00      lea d, [bp + 5] ; $num
2407   1408 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2408   140B FD 39         mov c, b ; And place it into C
2409   140D 2A            mov b, [d] ; Lower Word in B
2410   140E             ; START FACTORS
2411   140E D7            push a
2412   140F 11            mov a, b
2413   1410 26 0A 00      mov b, $a
2414   1413 AE            div a, b
2415   1414 27            mov b, a
2416   1415 E4            pop a
2417   1416             ; END FACTORS
2418   1416 E7            pop d
2419   1417 FD 43         mov [d], b
2420   1419 28            mov b, c
2421   141A FD 44 02 00   mov [d + 2], b
2422   141E             ;; i++; 
2423   141E FA F5 FF      lea d, [bp + -11] ; $i
2424   1421 2A            mov b, [d]
2425   1422 D8            push b
2426   1423 FD 77         inc b
2427   1425 FA F5 FF      lea d, [bp + -11] ; $i
2428   1428 FD 43         mov [d], b
2429   142A E5            pop b
2430   142B 0A B1 13      jmp _while36_cond
2431   142E             _while36_exit:
2432   142E             ;; while (i > 0) { 
2433   142E             _while37_cond:
2434   142E FA F5 FF      lea d, [bp + -11] ; $i
2435   1431 2A            mov b, [d]
2436   1432             ; START RELATIONAL
2437   1432 D7            push a
2438   1433 11            mov a, b
2439   1434 26 00 00      mov b, $0
2440   1437 B0            cmp a, b
2441   1438 FD 7F         sgt ; >
2442   143A E4            pop a
2443   143B             ; END RELATIONAL
2444   143B C0 00 00      cmp b, 0
2445   143E C6 67 14      je _while37_exit
2446   1441             _while37_block:
2447   1441             ;; i--; 
2448   1441 FA F5 FF      lea d, [bp + -11] ; $i
2449   1444 2A            mov b, [d]
2450   1445 D8            push b
2451   1446 FD 7D         dec b
2452   1448 FA F5 FF      lea d, [bp + -11] ; $i
2453   144B FD 43         mov [d], b
2454   144D E5            pop b
2455   144E             ;; putchar(digits[i]); 
2456   144E FA F7 FF      lea d, [bp + -9] ; $digits
2457   1451 D7            push a
2458   1452 DA            push d
2459   1453 FA F5 FF      lea d, [bp + -11] ; $i
2460   1456 2A            mov b, [d]
2461   1457 E7            pop d
2462   1458 5A            add d, b
2463   1459 E4            pop a
2464   145A 32            mov bl, [d]
2465   145B A7 00         mov bh, 0
2466   145D DD            push bl
2467   145E 07 3C 15      call putchar
2468   1461 51 01 00      add sp, 1
2469   1464 0A 2E 14      jmp _while37_cond
2470   1467             _while37_exit:
2471   1467 F9            leave
2472   1468 09            ret
2473   1469             
2474   1469             print_unsigned:
2475   1469 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2476   146C             ;; char digits[5]; 
2477   146C 52 05 00      sub sp, 5 ; digits
2478   146F             ;; int i; 
2479   146F 52 02 00      sub sp, 2 ; i
2480   1472             ;; i = 0; 
2481   1472 FA FA FF      lea d, [bp + -6] ; $i
2482   1475 DA            push d
2483   1476 26 00 00      mov b, $0
2484   1479 E7            pop d
2485   147A FD 43         mov [d], b
2486   147C             ;; if(num == 0){ 
2487   147C             _if38_cond:
2488   147C FA 05 00      lea d, [bp + 5] ; $num
2489   147F 2A            mov b, [d]
2490   1480             ; START RELATIONAL
2491   1480 D7            push a
2492   1481 11            mov a, b
2493   1482 26 00 00      mov b, $0
2494   1485 B0            cmp a, b
2495   1486 FD 71         seq ; ==
2496   1488 E4            pop a
2497   1489             ; END RELATIONAL
2498   1489 C0 00 00      cmp b, 0
2499   148C C6 9E 14      je _if38_exit
2500   148F             _if38_true:
2501   148F             ;; putchar('0'); 
2502   148F 26 30 00      mov b, $30
2503   1492 DD            push bl
2504   1493 07 3C 15      call putchar
2505   1496 51 01 00      add sp, 1
2506   1499             ;; return; 
2507   1499 F9            leave
2508   149A 09            ret
2509   149B 0A 9E 14      jmp _if38_exit
2510   149E             _if38_exit:
2511   149E             ;; while (num > 0) { 
2512   149E             _while39_cond:
2513   149E FA 05 00      lea d, [bp + 5] ; $num
2514   14A1 2A            mov b, [d]
2515   14A2             ; START RELATIONAL
2516   14A2 D7            push a
2517   14A3 11            mov a, b
2518   14A4 26 00 00      mov b, $0
2519   14A7 B0            cmp a, b
2520   14A8 FD 81         sgu ; > (unsigned)
2521   14AA E4            pop a
2522   14AB             ; END RELATIONAL
2523   14AB C0 00 00      cmp b, 0
2524   14AE C6 F8 14      je _while39_exit
2525   14B1             _while39_block:
2526   14B1             ;; digits[i] = '0' + (num % 10); 
2527   14B1 FA FC FF      lea d, [bp + -4] ; $digits
2528   14B4 D7            push a
2529   14B5 DA            push d
2530   14B6 FA FA FF      lea d, [bp + -6] ; $i
2531   14B9 2A            mov b, [d]
2532   14BA E7            pop d
2533   14BB 5A            add d, b
2534   14BC E4            pop a
2535   14BD DA            push d
2536   14BE 26 30 00      mov b, $30
2537   14C1             ; START TERMS
2538   14C1 D7            push a
2539   14C2 11            mov a, b
2540   14C3 FA 05 00      lea d, [bp + 5] ; $num
2541   14C6 2A            mov b, [d]
2542   14C7             ; START FACTORS
2543   14C7 D7            push a
2544   14C8 11            mov a, b
2545   14C9 26 0A 00      mov b, $a
2546   14CC AE            div a, b ; 
2547   14CD 11            mov a, b
2548   14CE 27            mov b, a
2549   14CF E4            pop a
2550   14D0             ; END FACTORS
2551   14D0 56            add b, a
2552   14D1 E4            pop a
2553   14D2             ; END TERMS
2554   14D2 E7            pop d
2555   14D3 FD 3E         mov [d], bl
2556   14D5             ;; num = num / 10; 
2557   14D5 FA 05 00      lea d, [bp + 5] ; $num
2558   14D8 DA            push d
2559   14D9 FA 05 00      lea d, [bp + 5] ; $num
2560   14DC 2A            mov b, [d]
2561   14DD             ; START FACTORS
2562   14DD D7            push a
2563   14DE 11            mov a, b
2564   14DF 26 0A 00      mov b, $a
2565   14E2 AE            div a, b
2566   14E3 27            mov b, a
2567   14E4 E4            pop a
2568   14E5             ; END FACTORS
2569   14E5 E7            pop d
2570   14E6 FD 43         mov [d], b
2571   14E8             ;; i++; 
2572   14E8 FA FA FF      lea d, [bp + -6] ; $i
2573   14EB 2A            mov b, [d]
2574   14EC D8            push b
2575   14ED FD 77         inc b
2576   14EF FA FA FF      lea d, [bp + -6] ; $i
2577   14F2 FD 43         mov [d], b
2578   14F4 E5            pop b
2579   14F5 0A 9E 14      jmp _while39_cond
2580   14F8             _while39_exit:
2581   14F8             ;; while (i > 0) { 
2582   14F8             _while40_cond:
2583   14F8 FA FA FF      lea d, [bp + -6] ; $i
2584   14FB 2A            mov b, [d]
2585   14FC             ; START RELATIONAL
2586   14FC D7            push a
2587   14FD 11            mov a, b
2588   14FE 26 00 00      mov b, $0
2589   1501 B0            cmp a, b
2590   1502 FD 7F         sgt ; >
2591   1504 E4            pop a
2592   1505             ; END RELATIONAL
2593   1505 C0 00 00      cmp b, 0
2594   1508 C6 31 15      je _while40_exit
2595   150B             _while40_block:
2596   150B             ;; i--; 
2597   150B FA FA FF      lea d, [bp + -6] ; $i
2598   150E 2A            mov b, [d]
2599   150F D8            push b
2600   1510 FD 7D         dec b
2601   1512 FA FA FF      lea d, [bp + -6] ; $i
2602   1515 FD 43         mov [d], b
2603   1517 E5            pop b
2604   1518             ;; putchar(digits[i]); 
2605   1518 FA FC FF      lea d, [bp + -4] ; $digits
2606   151B D7            push a
2607   151C DA            push d
2608   151D FA FA FF      lea d, [bp + -6] ; $i
2609   1520 2A            mov b, [d]
2610   1521 E7            pop d
2611   1522 5A            add d, b
2612   1523 E4            pop a
2613   1524 32            mov bl, [d]
2614   1525 A7 00         mov bh, 0
2615   1527 DD            push bl
2616   1528 07 3C 15      call putchar
2617   152B 51 01 00      add sp, 1
2618   152E 0A F8 14      jmp _while40_cond
2619   1531             _while40_exit:
2620   1531 F9            leave
2621   1532 09            ret
2622   1533             
2623   1533             date:
2624   1533 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2625   1536             
2626   1536             ; --- BEGIN INLINE ASM BLOCK
2627   1536 19 00         mov al, 0 
2628   1538 05 07         syscall sys_datetime
2629   153A             ; --- END INLINE ASM BLOCK
2630   153A             
2631   153A F9            leave
2632   153B 09            ret
2633   153C             
2634   153C             putchar:
2635   153C F8 00 00      enter 0 ; (push bp; mov bp, sp)
2636   153F             
2637   153F             ; --- BEGIN INLINE ASM BLOCK
2638   153F FA 05 00      lea d, [bp + 5] ; $c
2639   1542 1E            mov al, [d]
2640   1543 23            mov ah, al
2641   1544 07 CD 16      call _putchar
2642   1547             ; --- END INLINE ASM BLOCK
2643   1547             
2644   1547 F9            leave
2645   1548 09            ret
2646   1549             
2647   1549             getchar:
2648   1549 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2649   154C             ;; char c; 
2650   154C 52 01 00      sub sp, 1 ; c
2651   154F             
2652   154F             ; --- BEGIN INLINE ASM BLOCK
2653   154F 07 C6 16      call getch
2654   1552 1A            mov al, ah
2655   1553 FA 00 00      lea d, [bp + 0] ; $c
2656   1556 3E            mov [d], al
2657   1557             ; --- END INLINE ASM BLOCK
2658   1557             
2659   1557             ;; return c; 
2660   1557 FA 00 00      lea d, [bp + 0] ; $c
2661   155A 32            mov bl, [d]
2662   155B A7 00         mov bh, 0
2663   155D F9            leave
2664   155E 09            ret
2665   155F             
2666   155F             scann:
2667   155F F8 00 00      enter 0 ; (push bp; mov bp, sp)
2668   1562             ;; int m; 
2669   1562 52 02 00      sub sp, 2 ; m
2670   1565             
2671   1565             ; --- BEGIN INLINE ASM BLOCK
2672   1565 07 11 19      call scan_u16d
2673   1568 FA FF FF      lea d, [bp + -1] ; $m
2674   156B 43            mov [d], a
2675   156C             ; --- END INLINE ASM BLOCK
2676   156C             
2677   156C             ;; return m; 
2678   156C FA FF FF      lea d, [bp + -1] ; $m
2679   156F 2A            mov b, [d]
2680   1570 F9            leave
2681   1571 09            ret
2682   1572             
2683   1572             puts:
2684   1572 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2685   1575             
2686   1575             ; --- BEGIN INLINE ASM BLOCK
2687   1575 FA 05 00      lea d, [bp + 5] ; $s
2688   1578 15            mov a, [d]
2689   1579 3C            mov d, a
2690   157A 07 17 18      call _puts
2691   157D 10 00 0A      mov a, $0A00
2692   1580 05 03         syscall sys_io
2693   1582             ; --- END INLINE ASM BLOCK
2694   1582             
2695   1582 F9            leave
2696   1583 09            ret
2697   1584             
2698   1584             print:
2699   1584 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2700   1587             
2701   1587             ; --- BEGIN INLINE ASM BLOCK
2702   1587 FA 05 00      lea d, [bp + 5] ; $s
2703   158A FD 2A         mov d, [d]
2704   158C 07 17 18      call _puts
2705   158F             ; --- END INLINE ASM BLOCK
2706   158F             
2707   158F F9            leave
2708   1590 09            ret
2709   1591             
2710   1591             getparam:
2711   1591 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2712   1594             ;; char data; 
2713   1594 52 01 00      sub sp, 1 ; data
2714   1597             
2715   1597             ; --- BEGIN INLINE ASM BLOCK
2716   1597 19 04         mov al, 4
2717   1599 FA 05 00      lea d, [bp + 5] ; $address
2718   159C FD 2A         mov d, [d]
2719   159E 05 0C         syscall sys_system
2720   15A0 FA 00 00      lea d, [bp + 0] ; $data
2721   15A3 FD 3E         mov [d], bl
2722   15A5             ; --- END INLINE ASM BLOCK
2723   15A5             
2724   15A5             ;; return data; 
2725   15A5 FA 00 00      lea d, [bp + 0] ; $data
2726   15A8 32            mov bl, [d]
2727   15A9 A7 00         mov bh, 0
2728   15AB F9            leave
2729   15AC 09            ret
2730   15AD             
2731   15AD             clear:
2732   15AD F8 00 00      enter 0 ; (push bp; mov bp, sp)
2733   15B0             ;; print("\033[2J\033[H"); 
2734   15B0 26 D9 19      mov b, _s3 ; "\033[2J\033[H"
2735   15B3 FD AB         swp b
2736   15B5 D8            push b
2737   15B6 07 84 15      call print
2738   15B9 51 02 00      add sp, 2
2739   15BC F9            leave
2740   15BD 09            ret
2741   15BE             
2742   15BE             abs:
2743   15BE F8 00 00      enter 0 ; (push bp; mov bp, sp)
2744   15C1             ;; return i < 0 ? -i : i; 
2745   15C1             _ternary41_cond:
2746   15C1 FA 05 00      lea d, [bp + 5] ; $i
2747   15C4 2A            mov b, [d]
2748   15C5             ; START RELATIONAL
2749   15C5 D7            push a
2750   15C6 11            mov a, b
2751   15C7 26 00 00      mov b, $0
2752   15CA B0            cmp a, b
2753   15CB FD 73         slt ; < (signed)
2754   15CD E4            pop a
2755   15CE             ; END RELATIONAL
2756   15CE C0 00 00      cmp b, 0
2757   15D1 C6 DD 15      je _ternary41_false
2758   15D4             _ternary41_true:
2759   15D4 FA 05 00      lea d, [bp + 5] ; $i
2760   15D7 2A            mov b, [d]
2761   15D8 FD 97         neg b
2762   15DA 0A E1 15      jmp _ternary41_exit
2763   15DD             _ternary41_false:
2764   15DD FA 05 00      lea d, [bp + 5] ; $i
2765   15E0 2A            mov b, [d]
2766   15E1             _ternary41_exit:
2767   15E1 F9            leave
2768   15E2 09            ret
2769   15E3             
2770   15E3             include_stdio_asm:
2771   15E3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2772   15E6             
2773   15E6             ; --- BEGIN INLINE ASM BLOCK
2774   15E6             .include "lib/asm/stdio.asm"
0001+  15E6             ;-----------------------------------------------------------------------------
0002+  15E6             ; stdio.s
0003+  15E6             ;-----------------------------------------------------------------------------
0004+  15E6             .include "lib/asm/string.asm"
0001++ 15E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 15E6             ; string.s
0003++ 15E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 15E6             
0005++ 15E6             
0006++ 15E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 15E6             ; _strrev
0008++ 15E6             ; reverse a string
0009++ 15E6             ; D = string address
0010++ 15E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 15E6             ; 01234
0012++ 15E6             _strrev:
0013++ 15E6 4B          	pusha
0014++ 15E7 07 2D 16    	call _strlen	; length in C
0015++ 15EA 12          	mov a, c
0016++ 15EB AF 01 00    	cmp a, 1
0017++ 15EE D0 08 16    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 15F1 7D          	dec a
0019++ 15F2 FD 4E       	mov si, d	; beginning of string
0020++ 15F4 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 15F6 59          	add d, a	; end of string
0022++ 15F7 12          	mov a, c
0023++ 15F8 FD 9B       	shr a		; divide by 2
0024++ 15FA 39          	mov c, a	; C now counts the steps
0025++ 15FB             _strrev_L0:
0026++ 15FB 32          	mov bl, [d]	; save load right-side char into BL
0027++ 15FC F6          	lodsb		; load left-side char into AL; increase SI
0028++ 15FD 3E          	mov [d], al	; store left char into right side
0029++ 15FE 1B          	mov al, bl
0030++ 15FF F7          	stosb		; store right-side char into left-side; increase DI
0031++ 1600 7E          	dec c
0032++ 1601 7F          	dec d
0033++ 1602 C2 00 00    	cmp c, 0
0034++ 1605 C7 FB 15    	jne _strrev_L0
0035++ 1608             _strrev_end:
0036++ 1608 4C          	popa
0037++ 1609 09          	ret
0038++ 160A             	
0039++ 160A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 160A             ; _strchr
0041++ 160A             ; search string in D for char in AL
0042++ 160A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 160A             _strchr:
0044++ 160A             _strchr_L0:
0045++ 160A 32          	mov bl, [d]
0046++ 160B C1 00       	cmp bl, 0
0047++ 160D C6 18 16    	je _strchr_end
0048++ 1610 BA          	cmp al, bl
0049++ 1611 C6 18 16    	je _strchr_end
0050++ 1614 79          	inc d
0051++ 1615 0A 0A 16    	jmp _strchr_L0
0052++ 1618             _strchr_end:
0053++ 1618 1B          	mov al, bl
0054++ 1619 09          	ret
0055++ 161A             
0056++ 161A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 161A             ; _strstr
0058++ 161A             ; find sub-string
0059++ 161A             ; str1 in SI
0060++ 161A             ; str2 in DI
0061++ 161A             ; SI points to end of source string
0062++ 161A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 161A             _strstr:
0064++ 161A DB          	push al
0065++ 161B DA          	push d
0066++ 161C E3          	push di
0067++ 161D             _strstr_loop:
0068++ 161D F3          	cmpsb					; compare a byte of the strings
0069++ 161E C7 29 16    	jne _strstr_ret
0070++ 1621 FC 00 00    	lea d, [di + 0]
0071++ 1624 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1626 C7 1D 16    	jne _strstr_loop				; equal chars but not at end
0073++ 1629             _strstr_ret:
0074++ 1629 F0          	pop di
0075++ 162A E7          	pop d
0076++ 162B E8          	pop al
0077++ 162C 09          	ret
0078++ 162D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 162D             ; length of null terminated string
0080++ 162D             ; result in C
0081++ 162D             ; pointer in D
0082++ 162D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 162D             _strlen:
0084++ 162D DA          	push d
0085++ 162E 38 00 00    	mov c, 0
0086++ 1631             _strlen_L1:
0087++ 1631 BD 00       	cmp byte [d], 0
0088++ 1633 C6 3B 16    	je _strlen_ret
0089++ 1636 79          	inc d
0090++ 1637 78          	inc c
0091++ 1638 0A 31 16    	jmp _strlen_L1
0092++ 163B             _strlen_ret:
0093++ 163B E7          	pop d
0094++ 163C 09          	ret
0095++ 163D             
0096++ 163D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 163D             ; STRCMP
0098++ 163D             ; compare two strings
0099++ 163D             ; str1 in SI
0100++ 163D             ; str2 in DI
0101++ 163D             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 163D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 163D             _strcmp:
0104++ 163D DB          	push al
0105++ 163E DA          	push d
0106++ 163F E3          	push di
0107++ 1640 E2          	push si
0108++ 1641             _strcmp_loop:
0109++ 1641 F3          	cmpsb					; compare a byte of the strings
0110++ 1642 C7 4D 16    	jne _strcmp_ret
0111++ 1645 FB FF FF    	lea d, [si +- 1]
0112++ 1648 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 164A C7 41 16    	jne _strcmp_loop				; equal chars but not at end
0114++ 164D             _strcmp_ret:
0115++ 164D EF          	pop si
0116++ 164E F0          	pop di
0117++ 164F E7          	pop d
0118++ 1650 E8          	pop al
0119++ 1651 09          	ret
0120++ 1652             
0121++ 1652             
0122++ 1652             ; STRCPY
0123++ 1652             ; copy null terminated string from SI to DI
0124++ 1652             ; source in SI
0125++ 1652             ; destination in DI
0126++ 1652             _strcpy:
0127++ 1652 E2          	push si
0128++ 1653 E3          	push di
0129++ 1654 DB          	push al
0130++ 1655             _strcpy_L1:
0131++ 1655 F6          	lodsb
0132++ 1656 F7          	stosb
0133++ 1657 B9 00       	cmp al, 0
0134++ 1659 C7 55 16    	jne _strcpy_L1
0135++ 165C             _strcpy_end:
0136++ 165C E8          	pop al
0137++ 165D F0          	pop di
0138++ 165E EF          	pop si
0139++ 165F 09          	ret
0140++ 1660             
0141++ 1660             ; STRCAT
0142++ 1660             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 1660             ; source in SI
0144++ 1660             ; destination in DI
0145++ 1660             _strcat:
0146++ 1660 E2          	push si
0147++ 1661 E3          	push di
0148++ 1662 D7          	push a
0149++ 1663 DA          	push d
0150++ 1664 50          	mov a, di
0151++ 1665 3C          	mov d, a
0152++ 1666             _strcat_goto_end_L1:
0153++ 1666 BD 00       	cmp byte[d], 0
0154++ 1668 C6 6F 16    	je _strcat_start
0155++ 166B 79          	inc d
0156++ 166C 0A 66 16    	jmp _strcat_goto_end_L1
0157++ 166F             _strcat_start:
0158++ 166F FD 50       	mov di, d
0159++ 1671             _strcat_L1:
0160++ 1671 F6          	lodsb
0161++ 1672 F7          	stosb
0162++ 1673 B9 00       	cmp al, 0
0163++ 1675 C7 71 16    	jne _strcat_L1
0164++ 1678             _strcat_end:
0165++ 1678 E7          	pop d
0166++ 1679 E4          	pop a
0167++ 167A F0          	pop di
0168++ 167B EF          	pop si
0169++ 167C 09          	ret
0170++ 167D             
0171++ 167D             
0005+  167D             
0006+  167D             ;-----------------------------------------------------------------------------
0007+  167D             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0008+  167D             ; ASCII in BL
0009+  167D             ; result in AL
0010+  167D             ; ascii for F = 0100 0110
0011+  167D             ; ascii for 9 = 0011 1001
0012+  167D             ;-----------------------------------------------------------------------------
0013+  167D             hex_ascii_encode:
0014+  167D 1B            mov al, bl
0015+  167E 93 40         test al, $40        ; test if letter or number
0016+  1680 C7 86 16      jnz hex_letter
0017+  1683 87 0F         and al, $0F        ; get number
0018+  1685 09            ret
0019+  1686             hex_letter:
0020+  1686 87 0F         and al, $0F        ; get letter
0021+  1688 6A 09         add al, 9
0022+  168A 09            ret
0023+  168B             
0024+  168B             ;-----------------------------------------------------------------------------
0025+  168B             ; ATOI
0026+  168B             ; 2 letter hex string in B
0027+  168B             ; 8bit integer returned in AL
0028+  168B             ;-----------------------------------------------------------------------------
0029+  168B             _atoi:
0030+  168B D8            push b
0031+  168C 07 7D 16      call hex_ascii_encode      ; convert BL to 4bit code in AL
0032+  168F 30            mov bl, bh
0033+  1690 DB            push al          ; save a
0034+  1691 07 7D 16      call hex_ascii_encode
0035+  1694 EA            pop bl  
0036+  1695 FD 9E 04      shl al, 4
0037+  1698 8C            or al, bl
0038+  1699 E5            pop b
0039+  169A 09            ret  
0040+  169B             
0041+  169B             
0042+  169B             ;-----------------------------------------------------------------------------
0043+  169B             ; ITOA
0044+  169B             ; 8bit value in BL
0045+  169B             ; 2 byte ASCII result in A
0046+  169B             ;-----------------------------------------------------------------------------
0047+  169B             _itoa:
0048+  169B DA            push d
0049+  169C D8            push b
0050+  169D A7 00         mov bh, 0
0051+  169F FD A4 04      shr bl, 4  
0052+  16A2 74            mov d, b
0053+  16A3 1F 4B 19      mov al, [d + s_hex_digits]
0054+  16A6 23            mov ah, al
0055+  16A7               
0056+  16A7 E5            pop b
0057+  16A8 D8            push b
0058+  16A9 A7 00         mov bh, 0
0059+  16AB FD 87 0F      and bl, $0F
0060+  16AE 74            mov d, b
0061+  16AF 1F 4B 19      mov al, [d + s_hex_digits]
0062+  16B2 E5            pop b
0063+  16B3 E7            pop d
0064+  16B4 09            ret
0065+  16B5             
0066+  16B5             ;-----------------------------------------------------------------------------
0067+  16B5             ; HEX STRING TO BINARY
0068+  16B5             ; di = destination address
0069+  16B5             ; si = source
0070+  16B5             ;-----------------------------------------------------------------------------
0071+  16B5             _hex_to_int:
0072+  16B5             _hex_to_int_L1:
0073+  16B5 F6            lodsb          ; load from [SI] to AL
0074+  16B6 B9 00         cmp al, 0        ; check if ASCII 0
0075+  16B8 C6 C5 16      jz _hex_to_int_ret
0076+  16BB 36            mov bh, al
0077+  16BC F6            lodsb
0078+  16BD 2F            mov bl, al
0079+  16BE 07 8B 16      call _atoi        ; convert ASCII byte in B to int (to AL)
0080+  16C1 F7            stosb          ; store AL to [DI]
0081+  16C2 0A B5 16      jmp _hex_to_int_L1
0082+  16C5             _hex_to_int_ret:
0083+  16C5 09            ret    
0084+  16C6             
0085+  16C6             ;-----------------------------------------------------------------------------
0086+  16C6             ; GETCHAR
0087+  16C6             ; char in ah
0088+  16C6             ;-----------------------------------------------------------------------------
0089+  16C6             getch:
0090+  16C6 DB            push al
0091+  16C7             getch_retry:
0092+  16C7 19 01         mov al, 1
0093+  16C9 05 03         syscall sys_io      ; receive in AH
0094+  16CB E8            pop al
0095+  16CC 09            ret
0096+  16CD             
0097+  16CD             ;-----------------------------------------------------------------------------
0098+  16CD             ; PUTCHAR
0099+  16CD             ; char in ah
0100+  16CD             ;-----------------------------------------------------------------------------
0101+  16CD             _putchar:
0102+  16CD D7            push a
0103+  16CE 19 00         mov al, 0
0104+  16D0 05 03         syscall sys_io      ; char in AH
0105+  16D2 E4            pop a
0106+  16D3 09            ret
0107+  16D4             
0108+  16D4             ;-----------------------------------------------------------------------------
0109+  16D4             ;; INPUT A STRING
0110+  16D4             ;; terminates with null
0111+  16D4             ;; pointer in D
0112+  16D4             ;-----------------------------------------------------------------------------
0113+  16D4             _gets:
0114+  16D4 D7            push a
0115+  16D5 DA            push d
0116+  16D6             _gets_loop:
0117+  16D6 19 01         mov al, 1
0118+  16D8 05 03         syscall sys_io      ; receive in AH
0119+  16DA B9 00         cmp al, 0        ; check error code (AL)
0120+  16DC C6 D6 16      je _gets_loop      ; if no char received, retry
0121+  16DF             
0122+  16DF 76 1B         cmp ah, 27
0123+  16E1 C6 02 17      je _gets_ansi_esc
0124+  16E4 76 0A         cmp ah, $0A        ; LF
0125+  16E6 C6 6D 17      je _gets_end
0126+  16E9 76 0D         cmp ah, $0D        ; CR
0127+  16EB C6 6D 17      je _gets_end
0128+  16EE 76 5C         cmp ah, $5C        ; '\\'
0129+  16F0 C6 2E 17      je _gets_escape
0130+  16F3               
0131+  16F3 76 08         cmp ah, $08      ; check for backspace
0132+  16F5 C6 FE 16      je _gets_backspace
0133+  16F8             
0134+  16F8 1A            mov al, ah
0135+  16F9 3E            mov [d], al
0136+  16FA 79            inc d
0137+  16FB 0A D6 16      jmp _gets_loop
0138+  16FE             _gets_backspace:
0139+  16FE 7F            dec d
0140+  16FF 0A D6 16      jmp _gets_loop
0141+  1702             _gets_ansi_esc:
0142+  1702 19 01         mov al, 1
0143+  1704 05 03         syscall sys_io        ; receive in AH without echo
0144+  1706 B9 00         cmp al, 0          ; check error code (AL)
0145+  1708 C6 02 17      je _gets_ansi_esc    ; if no char received, retry
0146+  170B 76 5B         cmp ah, '['
0147+  170D C7 D6 16      jne _gets_loop
0148+  1710             _gets_ansi_esc_2:
0149+  1710 19 01         mov al, 1
0150+  1712 05 03         syscall sys_io          ; receive in AH without echo
0151+  1714 B9 00         cmp al, 0            ; check error code (AL)
0152+  1716 C6 10 17      je _gets_ansi_esc_2  ; if no char received, retry
0153+  1719 76 44         cmp ah, 'D'
0154+  171B C6 26 17      je _gets_left_arrow
0155+  171E 76 43         cmp ah, 'C'
0156+  1720 C6 2A 17      je _gets_right_arrow
0157+  1723 0A D6 16      jmp _gets_loop
0158+  1726             _gets_left_arrow:
0159+  1726 7F            dec d
0160+  1727 0A D6 16      jmp _gets_loop
0161+  172A             _gets_right_arrow:
0162+  172A 79            inc d
0163+  172B 0A D6 16      jmp _gets_loop
0164+  172E             _gets_escape:
0165+  172E 19 01         mov al, 1
0166+  1730 05 03         syscall sys_io      ; receive in AH
0167+  1732 B9 00         cmp al, 0        ; check error code (AL)
0168+  1734 C6 2E 17      je _gets_escape      ; if no char received, retry
0169+  1737 76 6E         cmp ah, 'n'
0170+  1739 C6 58 17      je _gets_LF
0171+  173C 76 72         cmp ah, 'r'
0172+  173E C6 5F 17      je _gets_CR
0173+  1741 76 30         cmp ah, '0'
0174+  1743 C6 66 17      je _gets_NULL
0175+  1746 76 5C         cmp ah, $5C  ; '\'
0176+  1748 C6 51 17      je _gets_slash
0177+  174B 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0178+  174C 3E            mov [d], al
0179+  174D 79            inc d
0180+  174E 0A D6 16      jmp _gets_loop
0181+  1751             _gets_slash:
0182+  1751 19 5C         mov al, $5C
0183+  1753 3E            mov [d], al
0184+  1754 79            inc d
0185+  1755 0A D6 16      jmp _gets_loop
0186+  1758             _gets_LF:
0187+  1758 19 0A         mov al, $0A
0188+  175A 3E            mov [d], al
0189+  175B 79            inc d
0190+  175C 0A D6 16      jmp _gets_loop
0191+  175F             _gets_CR:
0192+  175F 19 0D         mov al, $0D
0193+  1761 3E            mov [d], al
0194+  1762 79            inc d
0195+  1763 0A D6 16      jmp _gets_loop
0196+  1766             _gets_NULL:
0197+  1766 19 00         mov al, $00
0198+  1768 3E            mov [d], al
0199+  1769 79            inc d
0200+  176A 0A D6 16      jmp _gets_loop
0201+  176D             _gets_end:
0202+  176D 19 00         mov al, 0
0203+  176F 3E            mov [d], al        ; terminate string
0204+  1770 E7            pop d
0205+  1771 E4            pop a
0206+  1772 09            ret
0207+  1773             
0208+  1773             ;-----------------------------------------------------------------------------
0209+  1773             ;; INPUT TEXT
0210+  1773             ;; terminated with CTRL+D
0211+  1773             ;; pointer in D
0212+  1773             ;-----------------------------------------------------------------------------
0213+  1773             _gettxt:
0214+  1773 D7            push a
0215+  1774 DA            push d
0216+  1775             _gettxt_loop:
0217+  1775 19 01         mov al, 1
0218+  1777 05 03         syscall sys_io      ; receive in AH
0219+  1779 B9 00         cmp al, 0        ; check error code (AL)
0220+  177B C6 75 17      je _gettxt_loop    ; if no char received, retry
0221+  177E 76 04         cmp ah, 4      ; EOT
0222+  1780 C6 BE 17      je _gettxt_end
0223+  1783 76 08         cmp ah, $08      ; check for backspace
0224+  1785 C6 BA 17      je _gettxt_backspace
0225+  1788 76 5C         cmp ah, $5C        ; '\'
0226+  178A C6 93 17      je _gettxt_escape
0227+  178D 1A            mov al, ah
0228+  178E 3E            mov [d], al
0229+  178F 79            inc d
0230+  1790 0A 75 17      jmp _gettxt_loop
0231+  1793             _gettxt_escape:
0232+  1793 19 01         mov al, 1
0233+  1795 05 03         syscall sys_io      ; receive in AH
0234+  1797 B9 00         cmp al, 0        ; check error code (AL)
0235+  1799 C6 93 17      je _gettxt_escape    ; if no char received, retry
0236+  179C 76 6E         cmp ah, 'n'
0237+  179E C6 AC 17      je _gettxt_LF
0238+  17A1 76 72         cmp ah, 'r'
0239+  17A3 C6 B3 17      je _gettxt_CR
0240+  17A6 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0241+  17A7 3E            mov [d], al
0242+  17A8 79            inc d
0243+  17A9 0A 75 17      jmp _gettxt_loop
0244+  17AC             _gettxt_LF:
0245+  17AC 19 0A         mov al, $0A
0246+  17AE 3E            mov [d], al
0247+  17AF 79            inc d
0248+  17B0 0A 75 17      jmp _gettxt_loop
0249+  17B3             _gettxt_CR:
0250+  17B3 19 0D         mov al, $0D
0251+  17B5 3E            mov [d], al
0252+  17B6 79            inc d
0253+  17B7 0A 75 17      jmp _gettxt_loop
0254+  17BA             _gettxt_backspace:
0255+  17BA 7F            dec d
0256+  17BB 0A 75 17      jmp _gettxt_loop
0257+  17BE             _gettxt_end:
0258+  17BE 19 00         mov al, 0
0259+  17C0 3E            mov [d], al        ; terminate string
0260+  17C1 E7            pop d
0261+  17C2 E4            pop a
0262+  17C3 09            ret
0263+  17C4             
0264+  17C4             ;-----------------------------------------------------------------------------
0265+  17C4             ; PRINT NEW LINE
0266+  17C4             ;-----------------------------------------------------------------------------
0267+  17C4             printnl:
0268+  17C4 D7            push a
0269+  17C5 10 00 0A      mov a, $0A00
0270+  17C8 05 03         syscall sys_io
0271+  17CA 10 00 0D      mov a, $0D00
0272+  17CD 05 03         syscall sys_io
0273+  17CF E4            pop a
0274+  17D0 09            ret
0275+  17D1             
0276+  17D1             ;-----------------------------------------------------------------------------
0277+  17D1             ; _strtoint
0278+  17D1             ; 4 digit hex string number in d
0279+  17D1             ; integer returned in A
0280+  17D1             ;-----------------------------------------------------------------------------
0281+  17D1             _strtointx:
0282+  17D1 D8            push b
0283+  17D2 32            mov bl, [d]
0284+  17D3 37            mov bh, bl
0285+  17D4 33 01 00      mov bl, [d + 1]
0286+  17D7 07 8B 16      call _atoi        ; convert to int in AL
0287+  17DA 23            mov ah, al        ; move to AH
0288+  17DB 33 02 00      mov bl, [d + 2]
0289+  17DE 37            mov bh, bl
0290+  17DF 33 03 00      mov bl, [d + 3]
0291+  17E2 07 8B 16      call _atoi        ; convert to int in AL
0292+  17E5 E5            pop b
0293+  17E6 09            ret
0294+  17E7             
0295+  17E7             ;-----------------------------------------------------------------------------
0296+  17E7             ; _strtoint
0297+  17E7             ; 5 digit base10 string number in d
0298+  17E7             ; integer returned in A
0299+  17E7             ;-----------------------------------------------------------------------------
0300+  17E7             _strtoint:
0301+  17E7 E2            push si
0302+  17E8 D8            push b
0303+  17E9 D9            push c
0304+  17EA DA            push d
0305+  17EB 07 2D 16      call _strlen      ; get string length in C
0306+  17EE 7E            dec c
0307+  17EF FD 4E         mov si, d
0308+  17F1 12            mov a, c
0309+  17F2 FD 99         shl a
0310+  17F4 3B 63 19      mov d, table_power
0311+  17F7 59            add d, a
0312+  17F8 38 00 00      mov c, 0
0313+  17FB             _strtoint_L0:
0314+  17FB F6            lodsb      ; load ASCII to al
0315+  17FC B9 00         cmp al, 0
0316+  17FE C6 11 18      je _strtoint_end
0317+  1801 6F 30         sub al, $30    ; make into integer
0318+  1803 22 00         mov ah, 0
0319+  1805 2A            mov b, [d]
0320+  1806 AC            mul a, b      ; result in B since it fits in 16bits
0321+  1807 11            mov a, b
0322+  1808 28            mov b, c
0323+  1809 54            add a, b
0324+  180A 39            mov c, a
0325+  180B 63 02 00      sub d, 2
0326+  180E 0A FB 17      jmp _strtoint_L0
0327+  1811             _strtoint_end:
0328+  1811 12            mov a, c
0329+  1812 E7            pop d
0330+  1813 E6            pop c
0331+  1814 E5            pop b
0332+  1815 EF            pop si
0333+  1816 09            ret
0334+  1817             
0335+  1817             ;-----------------------------------------------------------------------------
0336+  1817             ; PRINT NULL TERMINATED STRING
0337+  1817             ; pointer in D
0338+  1817             ;-----------------------------------------------------------------------------
0339+  1817             _puts:
0340+  1817 D7            push a
0341+  1818 DA            push d
0342+  1819             _puts_L1:
0343+  1819 1E            mov al, [d]
0344+  181A B9 00         cmp al, 0
0345+  181C C6 28 18      jz _puts_END
0346+  181F 23            mov ah, al
0347+  1820 19 00         mov al, 0
0348+  1822 05 03         syscall sys_io
0349+  1824 79            inc d
0350+  1825 0A 19 18      jmp _puts_L1
0351+  1828             _puts_END:
0352+  1828 E7            pop d
0353+  1829 E4            pop a
0354+  182A 09            ret
0355+  182B             
0356+  182B             ;-----------------------------------------------------------------------------
0357+  182B             ; PRINT N SIZE STRING
0358+  182B             ; pointer in D
0359+  182B             ; size in C
0360+  182B             ;-----------------------------------------------------------------------------
0361+  182B             _putsn:
0362+  182B DB            push al
0363+  182C DA            push d
0364+  182D D9            push c
0365+  182E             _putsn_L0:
0366+  182E 1E            mov al, [d]
0367+  182F 23            mov ah, al
0368+  1830 19 00         mov al, 0
0369+  1832 05 03         syscall sys_io
0370+  1834 79            inc d
0371+  1835 7E            dec c  
0372+  1836 C2 00 00      cmp c, 0
0373+  1839 C7 2E 18      jne _putsn_L0
0374+  183C             _putsn_end:
0375+  183C E6            pop c
0376+  183D E7            pop d
0377+  183E E8            pop al
0378+  183F 09            ret
0379+  1840             
0380+  1840             ;-----------------------------------------------------------------------------
0381+  1840             ; print 16bit decimal number
0382+  1840             ; input number in A
0383+  1840             ;-----------------------------------------------------------------------------
0384+  1840             print_u16d:
0385+  1840 D7            push a
0386+  1841 D8            push b
0387+  1842 26 10 27      mov b, 10000
0388+  1845 AE            div a, b      ; get 10000's coeff.
0389+  1846 07 68 18      call print_number
0390+  1849 11            mov a, b
0391+  184A 26 E8 03      mov b, 1000
0392+  184D AE            div a, b      ; get 1000's coeff.
0393+  184E 07 68 18      call print_number
0394+  1851 11            mov a, b
0395+  1852 26 64 00      mov b, 100
0396+  1855 AE            div a, b
0397+  1856 07 68 18      call print_number
0398+  1859 11            mov a, b
0399+  185A 26 0A 00      mov b, 10
0400+  185D AE            div a, b
0401+  185E 07 68 18      call print_number
0402+  1861 1B            mov al, bl      ; 1's coeff in bl
0403+  1862 07 68 18      call print_number
0404+  1865 E5            pop b
0405+  1866 E4            pop a
0406+  1867 09            ret
0407+  1868             
0408+  1868             ;-----------------------------------------------------------------------------
0409+  1868             ; print AL
0410+  1868             ;-----------------------------------------------------------------------------
0411+  1868             print_number:
0412+  1868 6A 30         add al, $30
0413+  186A 23            mov ah, al
0414+  186B 07 CD 16      call _putchar
0415+  186E 09            ret
0416+  186F             
0417+  186F             ;-----------------------------------------------------------------------------
0418+  186F             ; PRINT 16BIT HEX INTEGER
0419+  186F             ; integer value in reg B
0420+  186F             ;-----------------------------------------------------------------------------
0421+  186F             print_u16x:
0422+  186F D7            push a
0423+  1870 D8            push b
0424+  1871 DD            push bl
0425+  1872 30            mov bl, bh
0426+  1873 07 9B 16      call _itoa        ; convert bh to char in A
0427+  1876 2F            mov bl, al        ; save al
0428+  1877 19 00         mov al, 0
0429+  1879 05 03         syscall sys_io        ; display AH
0430+  187B 24            mov ah, bl        ; retrieve al
0431+  187C 19 00         mov al, 0
0432+  187E 05 03         syscall sys_io        ; display AL
0433+  1880             
0434+  1880 EA            pop bl
0435+  1881 07 9B 16      call _itoa        ; convert bh to char in A
0436+  1884 2F            mov bl, al        ; save al
0437+  1885 19 00         mov al, 0
0438+  1887 05 03         syscall sys_io        ; display AH
0439+  1889 24            mov ah, bl        ; retrieve al
0440+  188A 19 00         mov al, 0
0441+  188C 05 03         syscall sys_io        ; display AL
0442+  188E             
0443+  188E E5            pop b
0444+  188F E4            pop a
0445+  1890 09            ret
0446+  1891             
0447+  1891             ;-----------------------------------------------------------------------------
0448+  1891             ; INPUT 16BIT HEX INTEGER
0449+  1891             ; read 16bit integer into A
0450+  1891             ;-----------------------------------------------------------------------------
0451+  1891             scan_u16x:
0452+  1891 F8 10 00      enter 16
0453+  1894 D8            push b
0454+  1895 DA            push d
0455+  1896             
0456+  1896 FA F1 FF      lea d, [bp + -15]
0457+  1899 07 D4 16      call _gets        ; get number
0458+  189C             
0459+  189C 32            mov bl, [d]
0460+  189D 37            mov bh, bl
0461+  189E 33 01 00      mov bl, [d + 1]
0462+  18A1 07 8B 16      call _atoi        ; convert to int in AL
0463+  18A4 23            mov ah, al        ; move to AH
0464+  18A5             
0465+  18A5 33 02 00      mov bl, [d + 2]
0466+  18A8 37            mov bh, bl
0467+  18A9 33 03 00      mov bl, [d + 3]
0468+  18AC 07 8B 16      call _atoi        ; convert to int in AL
0469+  18AF             
0470+  18AF E7            pop d
0471+  18B0 E5            pop b
0472+  18B1 F9            leave
0473+  18B2 09            ret
0474+  18B3             
0475+  18B3             ;-----------------------------------------------------------------------------
0476+  18B3             ; PRINT 8bit HEX INTEGER
0477+  18B3             ; integer value in reg bl
0478+  18B3             ;-----------------------------------------------------------------------------
0479+  18B3             print_u8x:
0480+  18B3 D7            push a
0481+  18B4 DD            push bl
0482+  18B5             
0483+  18B5 07 9B 16      call _itoa        ; convert bl to char in A
0484+  18B8 2F            mov bl, al        ; save al
0485+  18B9 19 00         mov al, 0
0486+  18BB 05 03         syscall sys_io        ; display AH
0487+  18BD 24            mov ah, bl        ; retrieve al
0488+  18BE 19 00         mov al, 0
0489+  18C0 05 03         syscall sys_io        ; display AL
0490+  18C2             
0491+  18C2 EA            pop bl
0492+  18C3 E4            pop a
0493+  18C4 09            ret
0494+  18C5             
0495+  18C5             ;-----------------------------------------------------------------------------
0496+  18C5             ; print 8bit decimal unsigned number
0497+  18C5             ; input number in AL
0498+  18C5             ;-----------------------------------------------------------------------------
0499+  18C5             print_u8d:
0500+  18C5 D7            push a
0501+  18C6 D8            push b
0502+  18C7             
0503+  18C7 22 00         mov ah, 0
0504+  18C9 26 64 00      mov b, 100
0505+  18CC AE            div a, b
0506+  18CD D8            push b      ; save remainder
0507+  18CE B9 00         cmp al, 0
0508+  18D0 C6 DA 18      je skip100
0509+  18D3 6A 30         add al, $30
0510+  18D5 23            mov ah, al
0511+  18D6 19 00         mov al, 0
0512+  18D8 05 03         syscall sys_io  ; print coeff
0513+  18DA             skip100:
0514+  18DA E4            pop a
0515+  18DB 22 00         mov ah, 0
0516+  18DD 26 0A 00      mov b, 10
0517+  18E0 AE            div a, b
0518+  18E1 D8            push b      ; save remainder
0519+  18E2 B9 00         cmp al, 0
0520+  18E4 C6 EE 18      je skip10
0521+  18E7 6A 30         add al, $30
0522+  18E9 23            mov ah, al
0523+  18EA 19 00         mov al, 0
0524+  18EC 05 03         syscall sys_io  ; print coeff
0525+  18EE             skip10:
0526+  18EE E4            pop a
0527+  18EF 1B            mov al, bl
0528+  18F0 6A 30         add al, $30
0529+  18F2 23            mov ah, al
0530+  18F3 19 00         mov al, 0
0531+  18F5 05 03         syscall sys_io  ; print coeff
0532+  18F7 E5            pop b
0533+  18F8 E4            pop a
0534+  18F9 09            ret
0535+  18FA             
0536+  18FA             ;-----------------------------------------------------------------------------
0537+  18FA             ; INPUT 8BIT HEX INTEGER
0538+  18FA             ; read 8bit integer into AL
0539+  18FA             ;-----------------------------------------------------------------------------
0540+  18FA             scan_u8x:
0541+  18FA F8 04 00      enter 4
0542+  18FD D8            push b
0543+  18FE DA            push d
0544+  18FF             
0545+  18FF FA FD FF      lea d, [bp + -3]
0546+  1902 07 D4 16      call _gets        ; get number
0547+  1905             
0548+  1905 32            mov bl, [d]
0549+  1906 37            mov bh, bl
0550+  1907 33 01 00      mov bl, [d + 1]
0551+  190A 07 8B 16      call _atoi        ; convert to int in AL
0552+  190D             
0553+  190D E7            pop d
0554+  190E E5            pop b
0555+  190F F9            leave
0556+  1910 09            ret
0557+  1911             
0558+  1911             ;-----------------------------------------------------------------------------
0559+  1911             ; input decimal number
0560+  1911             ; result in A
0561+  1911             ; 655'\0'
0562+  1911             ; low--------high
0563+  1911             ;-----------------------------------------------------------------------------
0564+  1911             scan_u16d:
0565+  1911 F8 08 00      enter 8
0566+  1914 E2            push si
0567+  1915 D8            push b
0568+  1916 D9            push c
0569+  1917 DA            push d
0570+  1918 FA F9 FF      lea d, [bp +- 7]
0571+  191B 07 D4 16      call _gets
0572+  191E 07 2D 16      call _strlen      ; get string length in C
0573+  1921 7E            dec c
0574+  1922 FD 4E         mov si, d
0575+  1924 12            mov a, c
0576+  1925 FD 99         shl a
0577+  1927 3B 63 19      mov d, table_power
0578+  192A 59            add d, a
0579+  192B 38 00 00      mov c, 0
0580+  192E             mul_loop:
0581+  192E F6            lodsb      ; load ASCII to al
0582+  192F B9 00         cmp al, 0
0583+  1931 C6 44 19      je mul_exit
0584+  1934 6F 30         sub al, $30    ; make into integer
0585+  1936 22 00         mov ah, 0
0586+  1938 2A            mov b, [d]
0587+  1939 AC            mul a, b      ; result in B since it fits in 16bits
0588+  193A 11            mov a, b
0589+  193B 28            mov b, c
0590+  193C 54            add a, b
0591+  193D 39            mov c, a
0592+  193E 63 02 00      sub d, 2
0593+  1941 0A 2E 19      jmp mul_loop
0594+  1944             mul_exit:
0595+  1944 12            mov a, c
0596+  1945 E7            pop d
0597+  1946 E6            pop c
0598+  1947 E5            pop b
0599+  1948 EF            pop si
0600+  1949 F9            leave
0601+  194A 09            ret
0602+  194B             
0603+  194B 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0603+  194F 34 35 36 37 
0603+  1953 38 39 41 42 
0603+  1957 43 44 45 46 
0604+  195B 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0604+  195F 1B 5B 48 00 
0605+  1963             
0606+  1963             table_power:
0607+  1963 01 00         .dw 1
0608+  1965 0A 00         .dw 10
0609+  1967 64 00         .dw 100
0610+  1969 E8 03         .dw 1000
0611+  196B 10 27         .dw 100002775   196D             ; --- END INLINE ASM BLOCK
2776   196D             
2777   196D F9            leave
2778   196E 09            ret
2779   196F             
2780   196F             F:
2781   196F F8 00 00      enter 0 ; (push bp; mov bp, sp)
2782   1972             ;; int yy; 
2783   1972 52 02 00      sub sp, 2 ; yy
2784   1975             ;; int h; 
2785   1975 52 02 00      sub sp, 2 ; h
2786   1978 F9            leave
2787   1979 09            ret
2788   197A             ; --- END TEXT BLOCK
2789   197A             
2790   197A             ; --- BEGIN DATA BLOCK
2791   197A 68 65 6C 6C _s0: .db "hello World: %d, the number is: %d", 0
2791   197E 6F 20 57 6F 
2791   1982 72 6C 64 3A 
2791   1986 20 25 64 2C 
2791   198A 20 74 68 65 
2791   198E 20 6E 75 6D 
2791   1992 62 65 72 20 
2791   1996 69 73 3A 20 
2791   199A 25 64 00 
2792   199D 55 6E 65 78 _s1: .db "Unexpected format in printf.", 0
2792   19A1 70 65 63 74 
2792   19A5 65 64 20 66 
2792   19A9 6F 72 6D 61 
2792   19AD 74 20 69 6E 
2792   19B1 20 70 72 69 
2792   19B5 6E 74 66 2E 
2792   19B9 00 
2793   19BA 45 72 72 6F _s2: .db "Error: Unknown argument type.\n", 0
2793   19BE 72 3A 20 55 
2793   19C2 6E 6B 6E 6F 
2793   19C6 77 6E 20 61 
2793   19CA 72 67 75 6D 
2793   19CE 65 6E 74 20 
2793   19D2 74 79 70 65 
2793   19D6 2E 0A 00 
2794   19D9 1B 5B 32 4A _s3: .db "\033[2J\033[H", 0
2794   19DD 1B 5B 48 00 
2795   19E1             
2796   19E1 E3 19       _heap_top: .dw _heap
2797   19E3 00          _heap: .db 0
2798   19E4             ; --- END DATA BLOCK
2799   19E4             
2800   19E4             .end
tasm: Number of errors = 0
