0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT SEGMENT
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; !1L; 
0011   0408 FD 2E 01 00   mov32 cb, $00000001
0011   040C 00 00 
0012   040E               cmp32 cb, 0
out/test.asm line 0012: unrecognized argument.             (cb,0)
0013   040E FD 71         seq ; !
0014   0410 05 0B         syscall sys_terminate_proc
0015   0412             
0016   0412             strcpy:
0017   0412 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0018   0415             ; char *psrc; 
0019   0415 52 02 00      sub sp, 2
0020   0418             ; char *pdest; 
0021   0418 52 02 00      sub sp, 2
0022   041B             ; psrc = src; 
0023   041B FA FF FF      lea d, [bp + -1] ; $psrc
0024   041E DA            push d
0025   041F FA 07 00      lea d, [bp + 7] ; $src
0026   0422 2A            mov b, [d]
0027   0423 38 00 00      mov c, 0
0028   0426 E7            pop d
0029   0427 FD 43         mov [d], b
0030   0429             ; pdest = dest; 
0031   0429 FA FD FF      lea d, [bp + -3] ; $pdest
0032   042C DA            push d
0033   042D FA 05 00      lea d, [bp + 5] ; $dest
0034   0430 2A            mov b, [d]
0035   0431 38 00 00      mov c, 0
0036   0434 E7            pop d
0037   0435 FD 43         mov [d], b
0038   0437             ; while(*psrc) *pdest++ = *psrc++; 
0039   0437             _while1_cond:
0040   0437 FA FF FF      lea d, [bp + -1] ; $psrc
0041   043A 2A            mov b, [d]
0042   043B 38 00 00      mov c, 0
0043   043E 74            mov d, b
0044   043F 32            mov bl, [d]
0045   0440 A7 00         mov bh, 0
0046   0442 38 00 00      mov c, 0
0047   0445 C0 00 00      cmp b, 0
0048   0448 C6 79 04      je _while1_exit
0049   044B             _while1_block:
0050   044B             ; *pdest++ = *psrc++; 
0051   044B FA FD FF      lea d, [bp + -3] ; $pdest
0052   044E 2A            mov b, [d]
0053   044F 38 00 00      mov c, 0
0054   0452 FD 77         inc b
0055   0454 FA FD FF      lea d, [bp + -3] ; $pdest
0056   0457 FD 43         mov [d], b
0057   0459 FD 7D         dec b
0058   045B D8            push b
0059   045C FA FF FF      lea d, [bp + -1] ; $psrc
0060   045F 2A            mov b, [d]
0061   0460 38 00 00      mov c, 0
0062   0463 FD 77         inc b
0063   0465 FA FF FF      lea d, [bp + -1] ; $psrc
0064   0468 FD 43         mov [d], b
0065   046A FD 7D         dec b
0066   046C 74            mov d, b
0067   046D 32            mov bl, [d]
0068   046E A7 00         mov bh, 0
0069   0470 38 00 00      mov c, 0
0070   0473 E7            pop d
0071   0474 FD 3E         mov [d], bl
0072   0476 0A 37 04      jmp _while1_cond
0073   0479             _while1_exit:
0074   0479             ; *pdest = '\0'; 
0075   0479 FA FD FF      lea d, [bp + -3] ; $pdest
0076   047C 2A            mov b, [d]
0077   047D 38 00 00      mov c, 0
0078   0480 D8            push b
0079   0481 FD 2E 00 00   mov32 cb, $00000000
0079   0485 00 00 
0080   0487 E7            pop d
0081   0488 FD 3E         mov [d], bl
0082   048A F9            leave
0083   048B 09            ret
0084   048C             
0085   048C             strcmp:
0086   048C F8 00 00      enter 0 ; (push bp; mov bp, sp)
0087   048F             ; while (*s1 && (*s1 == *s2)) { 
0088   048F             _while2_cond:
0089   048F FA 05 00      lea d, [bp + 5] ; $s1
0090   0492 2A            mov b, [d]
0091   0493 38 00 00      mov c, 0
0092   0496 74            mov d, b
0093   0497 32            mov bl, [d]
0094   0498 A7 00         mov bh, 0
0095   049A 38 00 00      mov c, 0
0096   049D             ; --- START LOGICAL AND
0097   049D D7            push a
0098   049E 11            mov a, b
0099   049F FA 05 00      lea d, [bp + 5] ; $s1
0100   04A2 2A            mov b, [d]
0101   04A3 38 00 00      mov c, 0
0102   04A6 74            mov d, b
0103   04A7 32            mov bl, [d]
0104   04A8 A7 00         mov bh, 0
0105   04AA 38 00 00      mov c, 0
0106   04AD             ; --- START RELATIONAL
0107   04AD D7            push a
0108   04AE 11            mov a, b
0109   04AF FA 07 00      lea d, [bp + 7] ; $s2
0110   04B2 2A            mov b, [d]
0111   04B3 38 00 00      mov c, 0
0112   04B6 74            mov d, b
0113   04B7 32            mov bl, [d]
0114   04B8 A7 00         mov bh, 0
0115   04BA 38 00 00      mov c, 0
0116   04BD B0            cmp a, b
0117   04BE FD 71         seq ; ==
0118   04C0 E4            pop a
0119   04C1             ; --- END RELATIONAL
0120   04C1 FD A7         sand a, b
0121   04C3 E4            pop a
0122   04C4             ; --- END LOGICAL AND
0123   04C4 C0 00 00      cmp b, 0
0124   04C7 C6 ED 04      je _while2_exit
0125   04CA             _while2_block:
0126   04CA             ; s1++; 
0127   04CA FA 05 00      lea d, [bp + 5] ; $s1
0128   04CD 2A            mov b, [d]
0129   04CE 38 00 00      mov c, 0
0130   04D1 FD 77         inc b
0131   04D3 FA 05 00      lea d, [bp + 5] ; $s1
0132   04D6 FD 43         mov [d], b
0133   04D8 FD 7D         dec b
0134   04DA             ; s2++; 
0135   04DA FA 07 00      lea d, [bp + 7] ; $s2
0136   04DD 2A            mov b, [d]
0137   04DE 38 00 00      mov c, 0
0138   04E1 FD 77         inc b
0139   04E3 FA 07 00      lea d, [bp + 7] ; $s2
0140   04E6 FD 43         mov [d], b
0141   04E8 FD 7D         dec b
0142   04EA 0A 8F 04      jmp _while2_cond
0143   04ED             _while2_exit:
0144   04ED             ; return *s1 - *s2; 
0145   04ED FA 05 00      lea d, [bp + 5] ; $s1
0146   04F0 2A            mov b, [d]
0147   04F1 38 00 00      mov c, 0
0148   04F4 74            mov d, b
0149   04F5 32            mov bl, [d]
0150   04F6 A7 00         mov bh, 0
0151   04F8 38 00 00      mov c, 0
0152   04FB             ; --- START TERMS
0153   04FB D7            push a
0154   04FC 11            mov a, b
0155   04FD FA 07 00      lea d, [bp + 7] ; $s2
0156   0500 2A            mov b, [d]
0157   0501 38 00 00      mov c, 0
0158   0504 74            mov d, b
0159   0505 32            mov bl, [d]
0160   0506 A7 00         mov bh, 0
0161   0508 38 00 00      mov c, 0
0162   050B 60            sub a, b
0163   050C 27            mov b, a
0164   050D E4            pop a
0165   050E             ; --- END TERMS
0166   050E F9            leave
0167   050F 09            ret
0168   0510             
0169   0510             strncmp:
0170   0510 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0171   0513 F9            leave
0172   0514 09            ret
0173   0515             
0174   0515             strcat:
0175   0515 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0176   0518             ; int dest_len; 
0177   0518 52 02 00      sub sp, 2
0178   051B             ; int i; 
0179   051B 52 02 00      sub sp, 2
0180   051E             ; dest_len = strlen(dest); 
0181   051E FA FF FF      lea d, [bp + -1] ; $dest_len
0182   0521 DA            push d
0183   0522             ; --- START FUNCTION CALL
0184   0522 FA 05 00      lea d, [bp + 5] ; $dest
0185   0525 2A            mov b, [d]
0186   0526 38 00 00      mov c, 0
0187   0529 FD AB         swp b
0188   052B D8            push b
0189   052C 07 F8 05      call strlen
0190   052F 51 02 00      add sp, 2
0191   0532             ; --- END FUNCTION CALL
0192   0532 E7            pop d
0193   0533 FD 43         mov [d], b
0194   0535             ; for (i = 0; src[i] != 0; i=i+1) { 
0195   0535             _for3_init:
0196   0535 FA FD FF      lea d, [bp + -3] ; $i
0197   0538 DA            push d
0198   0539 FD 2E 00 00   mov32 cb, $00000000
0198   053D 00 00 
0199   053F E7            pop d
0200   0540 FD 43         mov [d], b
0201   0542             _for3_cond:
0202   0542 FA 07 00      lea d, [bp + 7] ; $src
0203   0545 FD 2A         mov d, [d]
0204   0547 D7            push a
0205   0548 DA            push d
0206   0549 FA FD FF      lea d, [bp + -3] ; $i
0207   054C 2A            mov b, [d]
0208   054D 38 00 00      mov c, 0
0209   0550 E7            pop d
0210   0551 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0211   0555 E4            pop a
0212   0556 32            mov bl, [d]
0213   0557 A7 00         mov bh, 0
0214   0559 38 00 00      mov c, 0
0215   055C             ; --- START RELATIONAL
0216   055C D7            push a
0217   055D 11            mov a, b
0218   055E FD 2E 00 00   mov32 cb, $00000000
0218   0562 00 00 
0219   0564 B0            cmp a, b
0220   0565 FD 72         sneq ; !=
0221   0567 E4            pop a
0222   0568             ; --- END RELATIONAL
0223   0568 C0 00 00      cmp b, 0
0224   056B C6 C6 05      je _for3_exit
0225   056E             _for3_block:
0226   056E             ; dest[dest_len + i] = src[i]; 
0227   056E FA 05 00      lea d, [bp + 5] ; $dest
0228   0571 FD 2A         mov d, [d]
0229   0573 D7            push a
0230   0574 DA            push d
0231   0575 FA FF FF      lea d, [bp + -1] ; $dest_len
0232   0578 2A            mov b, [d]
0233   0579 38 00 00      mov c, 0
0234   057C             ; --- START TERMS
0235   057C D7            push a
0236   057D 11            mov a, b
0237   057E FA FD FF      lea d, [bp + -3] ; $i
0238   0581 2A            mov b, [d]
0239   0582 38 00 00      mov c, 0
0240   0585 56            add b, a
0241   0586 E4            pop a
0242   0587             ; --- END TERMS
0243   0587 E7            pop d
0244   0588 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0245   058C E4            pop a
0246   058D DA            push d
0247   058E FA 07 00      lea d, [bp + 7] ; $src
0248   0591 FD 2A         mov d, [d]
0249   0593 D7            push a
0250   0594 DA            push d
0251   0595 FA FD FF      lea d, [bp + -3] ; $i
0252   0598 2A            mov b, [d]
0253   0599 38 00 00      mov c, 0
0254   059C E7            pop d
0255   059D FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0256   05A1 E4            pop a
0257   05A2 32            mov bl, [d]
0258   05A3 A7 00         mov bh, 0
0259   05A5 38 00 00      mov c, 0
0260   05A8 E7            pop d
0261   05A9 FD 3E         mov [d], bl
0262   05AB             _for3_update:
0263   05AB FA FD FF      lea d, [bp + -3] ; $i
0264   05AE DA            push d
0265   05AF FA FD FF      lea d, [bp + -3] ; $i
0266   05B2 2A            mov b, [d]
0267   05B3 38 00 00      mov c, 0
0268   05B6             ; --- START TERMS
0269   05B6 D7            push a
0270   05B7 11            mov a, b
0271   05B8 FD 2E 01 00   mov32 cb, $00000001
0271   05BC 00 00 
0272   05BE 56            add b, a
0273   05BF E4            pop a
0274   05C0             ; --- END TERMS
0275   05C0 E7            pop d
0276   05C1 FD 43         mov [d], b
0277   05C3 0A 42 05      jmp _for3_cond
0278   05C6             _for3_exit:
0279   05C6             ; dest[dest_len + i] = 0; 
0280   05C6 FA 05 00      lea d, [bp + 5] ; $dest
0281   05C9 FD 2A         mov d, [d]
0282   05CB D7            push a
0283   05CC DA            push d
0284   05CD FA FF FF      lea d, [bp + -1] ; $dest_len
0285   05D0 2A            mov b, [d]
0286   05D1 38 00 00      mov c, 0
0287   05D4             ; --- START TERMS
0288   05D4 D7            push a
0289   05D5 11            mov a, b
0290   05D6 FA FD FF      lea d, [bp + -3] ; $i
0291   05D9 2A            mov b, [d]
0292   05DA 38 00 00      mov c, 0
0293   05DD 56            add b, a
0294   05DE E4            pop a
0295   05DF             ; --- END TERMS
0296   05DF E7            pop d
0297   05E0 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0298   05E4 E4            pop a
0299   05E5 DA            push d
0300   05E6 FD 2E 00 00   mov32 cb, $00000000
0300   05EA 00 00 
0301   05EC E7            pop d
0302   05ED FD 3E         mov [d], bl
0303   05EF             ; return dest; 
0304   05EF FA 05 00      lea d, [bp + 5] ; $dest
0305   05F2 2A            mov b, [d]
0306   05F3 38 00 00      mov c, 0
0307   05F6 F9            leave
0308   05F7 09            ret
0309   05F8             
0310   05F8             strlen:
0311   05F8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0312   05FB             ; int length; 
0313   05FB 52 02 00      sub sp, 2
0314   05FE             ; length = 0; 
0315   05FE FA FF FF      lea d, [bp + -1] ; $length
0316   0601 DA            push d
0317   0602 FD 2E 00 00   mov32 cb, $00000000
0317   0606 00 00 
0318   0608 E7            pop d
0319   0609 FD 43         mov [d], b
0320   060B             ; while (str[length] != 0) { 
0321   060B             _while4_cond:
0322   060B FA 05 00      lea d, [bp + 5] ; $str
0323   060E FD 2A         mov d, [d]
0324   0610 D7            push a
0325   0611 DA            push d
0326   0612 FA FF FF      lea d, [bp + -1] ; $length
0327   0615 2A            mov b, [d]
0328   0616 38 00 00      mov c, 0
0329   0619 E7            pop d
0330   061A FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0331   061E E4            pop a
0332   061F 32            mov bl, [d]
0333   0620 A7 00         mov bh, 0
0334   0622 38 00 00      mov c, 0
0335   0625             ; --- START RELATIONAL
0336   0625 D7            push a
0337   0626 11            mov a, b
0338   0627 FD 2E 00 00   mov32 cb, $00000000
0338   062B 00 00 
0339   062D B0            cmp a, b
0340   062E FD 72         sneq ; !=
0341   0630 E4            pop a
0342   0631             ; --- END RELATIONAL
0343   0631 C0 00 00      cmp b, 0
0344   0634 C6 4A 06      je _while4_exit
0345   0637             _while4_block:
0346   0637             ; length++; 
0347   0637 FA FF FF      lea d, [bp + -1] ; $length
0348   063A 2A            mov b, [d]
0349   063B 38 00 00      mov c, 0
0350   063E FD 77         inc b
0351   0640 FA FF FF      lea d, [bp + -1] ; $length
0352   0643 FD 43         mov [d], b
0353   0645 FD 7D         dec b
0354   0647 0A 0B 06      jmp _while4_cond
0355   064A             _while4_exit:
0356   064A             ; return length; 
0357   064A FA FF FF      lea d, [bp + -1] ; $length
0358   064D 2A            mov b, [d]
0359   064E 38 00 00      mov c, 0
0360   0651 F9            leave
0361   0652 09            ret
0362   0653             
0363   0653             exit:
0364   0653 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0365   0656             
0366   0656             ; --- BEGIN INLINE ASM SEGMENT
0367   0656 05 0B         syscall sys_terminate_proc
0368   0658             ; --- END INLINE ASM SEGMENT
0369   0658             
0370   0658 F9            leave
0371   0659 09            ret
0372   065A             
0373   065A             memset:
0374   065A F8 00 00      enter 0 ; (push bp; mov bp, sp)
0375   065D             ; int i; 
0376   065D 52 02 00      sub sp, 2
0377   0660             ; for(i = 0; i < size; i++){ 
0378   0660             _for5_init:
0379   0660 FA FF FF      lea d, [bp + -1] ; $i
0380   0663 DA            push d
0381   0664 FD 2E 00 00   mov32 cb, $00000000
0381   0668 00 00 
0382   066A E7            pop d
0383   066B FD 43         mov [d], b
0384   066D             _for5_cond:
0385   066D FA FF FF      lea d, [bp + -1] ; $i
0386   0670 2A            mov b, [d]
0387   0671 38 00 00      mov c, 0
0388   0674             ; --- START RELATIONAL
0389   0674 D7            push a
0390   0675 11            mov a, b
0391   0676 FA 08 00      lea d, [bp + 8] ; $size
0392   0679 2A            mov b, [d]
0393   067A 38 00 00      mov c, 0
0394   067D B0            cmp a, b
0395   067E FD 73         slt ; < (signed)
0396   0680 E4            pop a
0397   0681             ; --- END RELATIONAL
0398   0681 C0 00 00      cmp b, 0
0399   0684 C6 B9 06      je _for5_exit
0400   0687             _for5_block:
0401   0687             ; *(s+i) = c; 
0402   0687 FA 05 00      lea d, [bp + 5] ; $s
0403   068A 2A            mov b, [d]
0404   068B 38 00 00      mov c, 0
0405   068E             ; --- START TERMS
0406   068E D7            push a
0407   068F 11            mov a, b
0408   0690 FA FF FF      lea d, [bp + -1] ; $i
0409   0693 2A            mov b, [d]
0410   0694 38 00 00      mov c, 0
0411   0697 56            add b, a
0412   0698 E4            pop a
0413   0699             ; --- END TERMS
0414   0699 D8            push b
0415   069A FA 07 00      lea d, [bp + 7] ; $c
0416   069D 32            mov bl, [d]
0417   069E A7 00         mov bh, 0
0418   06A0 38 00 00      mov c, 0
0419   06A3 E7            pop d
0420   06A4 FD 3E         mov [d], bl
0421   06A6             _for5_update:
0422   06A6 FA FF FF      lea d, [bp + -1] ; $i
0423   06A9 2A            mov b, [d]
0424   06AA 38 00 00      mov c, 0
0425   06AD FD 77         inc b
0426   06AF FA FF FF      lea d, [bp + -1] ; $i
0427   06B2 FD 43         mov [d], b
0428   06B4 FD 7D         dec b
0429   06B6 0A 6D 06      jmp _for5_cond
0430   06B9             _for5_exit:
0431   06B9             ; return s; 
0432   06B9 FA 05 00      lea d, [bp + 5] ; $s
0433   06BC 2A            mov b, [d]
0434   06BD 38 00 00      mov c, 0
0435   06C0 F9            leave
0436   06C1 09            ret
0437   06C2             
0438   06C2             atoi:
0439   06C2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0440   06C5             ; int result = 0;  // Initialize result 
0441   06C5 52 02 00      sub sp, 2
0442   06C8             ; --- START LOCAL VAR INITIALIZATION
0443   06C8 FA FF FF      lea d, [bp + -1] ; $result
0444   06CB DA            push d
0445   06CC FD 2E 00 00   mov32 cb, $00000000
0445   06D0 00 00 
0446   06D2 E7            pop d
0447   06D3 FD 43         mov [d], b
0448   06D5             ; --- END LOCAL VAR INITIALIZATION
0449   06D5             ; int sign = 1;    // Initialize sign as positive 
0450   06D5 52 02 00      sub sp, 2
0451   06D8             ; --- START LOCAL VAR INITIALIZATION
0452   06D8 FA FD FF      lea d, [bp + -3] ; $sign
0453   06DB DA            push d
0454   06DC FD 2E 01 00   mov32 cb, $00000001
0454   06E0 00 00 
0455   06E2 E7            pop d
0456   06E3 FD 43         mov [d], b
0457   06E5             ; --- END LOCAL VAR INITIALIZATION
0458   06E5             ; while (*str == ' ') str++; 
0459   06E5             _while6_cond:
0460   06E5 FA 05 00      lea d, [bp + 5] ; $str
0461   06E8 2A            mov b, [d]
0462   06E9 38 00 00      mov c, 0
0463   06EC 74            mov d, b
0464   06ED 32            mov bl, [d]
0465   06EE A7 00         mov bh, 0
0466   06F0 38 00 00      mov c, 0
0467   06F3             ; --- START RELATIONAL
0468   06F3 D7            push a
0469   06F4 11            mov a, b
0470   06F5 FD 2E 20 00   mov32 cb, $00000020
0470   06F9 00 00 
0471   06FB B0            cmp a, b
0472   06FC FD 71         seq ; ==
0473   06FE E4            pop a
0474   06FF             ; --- END RELATIONAL
0475   06FF C0 00 00      cmp b, 0
0476   0702 C6 18 07      je _while6_exit
0477   0705             _while6_block:
0478   0705             ; str++; 
0479   0705 FA 05 00      lea d, [bp + 5] ; $str
0480   0708 2A            mov b, [d]
0481   0709 38 00 00      mov c, 0
0482   070C FD 77         inc b
0483   070E FA 05 00      lea d, [bp + 5] ; $str
0484   0711 FD 43         mov [d], b
0485   0713 FD 7D         dec b
0486   0715 0A E5 06      jmp _while6_cond
0487   0718             _while6_exit:
0488   0718             ; if (*str == '-' || *str == '+') { 
0489   0718             _if7_cond:
0490   0718 FA 05 00      lea d, [bp + 5] ; $str
0491   071B 2A            mov b, [d]
0492   071C 38 00 00      mov c, 0
0493   071F 74            mov d, b
0494   0720 32            mov bl, [d]
0495   0721 A7 00         mov bh, 0
0496   0723 38 00 00      mov c, 0
0497   0726             ; --- START RELATIONAL
0498   0726 D7            push a
0499   0727 11            mov a, b
0500   0728 FD 2E 2D 00   mov32 cb, $0000002d
0500   072C 00 00 
0501   072E B0            cmp a, b
0502   072F FD 71         seq ; ==
0503   0731 E4            pop a
0504   0732             ; --- END RELATIONAL
0505   0732             ; --- START LOGICAL OR
0506   0732 D7            push a
0507   0733 11            mov a, b
0508   0734 FA 05 00      lea d, [bp + 5] ; $str
0509   0737 2A            mov b, [d]
0510   0738 38 00 00      mov c, 0
0511   073B 74            mov d, b
0512   073C 32            mov bl, [d]
0513   073D A7 00         mov bh, 0
0514   073F 38 00 00      mov c, 0
0515   0742             ; --- START RELATIONAL
0516   0742 D7            push a
0517   0743 11            mov a, b
0518   0744 FD 2E 2B 00   mov32 cb, $0000002b
0518   0748 00 00 
0519   074A B0            cmp a, b
0520   074B FD 71         seq ; ==
0521   074D E4            pop a
0522   074E             ; --- END RELATIONAL
0523   074E FD A8         sor a, b ; ||
0524   0750 E4            pop a
0525   0751             ; --- END LOGICAL OR
0526   0751 C0 00 00      cmp b, 0
0527   0754 C6 9C 07      je _if7_exit
0528   0757             _if7_true:
0529   0757             ; if (*str == '-') sign = -1; 
0530   0757             _if8_cond:
0531   0757 FA 05 00      lea d, [bp + 5] ; $str
0532   075A 2A            mov b, [d]
0533   075B 38 00 00      mov c, 0
0534   075E 74            mov d, b
0535   075F 32            mov bl, [d]
0536   0760 A7 00         mov bh, 0
0537   0762 38 00 00      mov c, 0
0538   0765             ; --- START RELATIONAL
0539   0765 D7            push a
0540   0766 11            mov a, b
0541   0767 FD 2E 2D 00   mov32 cb, $0000002d
0541   076B 00 00 
0542   076D B0            cmp a, b
0543   076E FD 71         seq ; ==
0544   0770 E4            pop a
0545   0771             ; --- END RELATIONAL
0546   0771 C0 00 00      cmp b, 0
0547   0774 C6 89 07      je _if8_exit
0548   0777             _if8_true:
0549   0777             ; sign = -1; 
0550   0777 FA FD FF      lea d, [bp + -3] ; $sign
0551   077A DA            push d
0552   077B FD 2E 01 00   mov32 cb, $00000001
0552   077F 00 00 
0553   0781 FD 97         neg b
0554   0783 E7            pop d
0555   0784 FD 43         mov [d], b
0556   0786 0A 89 07      jmp _if8_exit
0557   0789             _if8_exit:
0558   0789             ; str++; 
0559   0789 FA 05 00      lea d, [bp + 5] ; $str
0560   078C 2A            mov b, [d]
0561   078D 38 00 00      mov c, 0
0562   0790 FD 77         inc b
0563   0792 FA 05 00      lea d, [bp + 5] ; $str
0564   0795 FD 43         mov [d], b
0565   0797 FD 7D         dec b
0566   0799 0A 9C 07      jmp _if7_exit
0567   079C             _if7_exit:
0568   079C             ; while (*str >= '0' && *str <= '9') { 
0569   079C             _while9_cond:
0570   079C FA 05 00      lea d, [bp + 5] ; $str
0571   079F 2A            mov b, [d]
0572   07A0 38 00 00      mov c, 0
0573   07A3 74            mov d, b
0574   07A4 32            mov bl, [d]
0575   07A5 A7 00         mov bh, 0
0576   07A7 38 00 00      mov c, 0
0577   07AA             ; --- START RELATIONAL
0578   07AA D7            push a
0579   07AB 11            mov a, b
0580   07AC FD 2E 30 00   mov32 cb, $00000030
0580   07B0 00 00 
0581   07B2 B0            cmp a, b
0582   07B3 FD 82         sgeu ; >= (unsigned)
0583   07B5 E4            pop a
0584   07B6             ; --- END RELATIONAL
0585   07B6             ; --- START LOGICAL AND
0586   07B6 D7            push a
0587   07B7 11            mov a, b
0588   07B8 FA 05 00      lea d, [bp + 5] ; $str
0589   07BB 2A            mov b, [d]
0590   07BC 38 00 00      mov c, 0
0591   07BF 74            mov d, b
0592   07C0 32            mov bl, [d]
0593   07C1 A7 00         mov bh, 0
0594   07C3 38 00 00      mov c, 0
0595   07C6             ; --- START RELATIONAL
0596   07C6 D7            push a
0597   07C7 11            mov a, b
0598   07C8 FD 2E 39 00   mov32 cb, $00000039
0598   07CC 00 00 
0599   07CE B0            cmp a, b
0600   07CF FD 76         sleu ; <= (unsigned)
0601   07D1 E4            pop a
0602   07D2             ; --- END RELATIONAL
0603   07D2 FD A7         sand a, b
0604   07D4 E4            pop a
0605   07D5             ; --- END LOGICAL AND
0606   07D5 C0 00 00      cmp b, 0
0607   07D8 C6 25 08      je _while9_exit
0608   07DB             _while9_block:
0609   07DB             ; result = result * 10 + (*str - '0'); 
0610   07DB FA FF FF      lea d, [bp + -1] ; $result
0611   07DE DA            push d
0612   07DF FA FF FF      lea d, [bp + -1] ; $result
0613   07E2 2A            mov b, [d]
0614   07E3 38 00 00      mov c, 0
0615   07E6             ; --- START FACTORS
0616   07E6 D7            push a
0617   07E7 11            mov a, b
0618   07E8 FD 2E 0A 00   mov32 cb, $0000000a
0618   07EC 00 00 
0619   07EE AC            mul a, b ; *
0620   07EF 11            mov a, b
0621   07F0 27            mov b, a
0622   07F1 E4            pop a
0623   07F2             ; --- END FACTORS
0624   07F2             ; --- START TERMS
0625   07F2 D7            push a
0626   07F3 11            mov a, b
0627   07F4 FA 05 00      lea d, [bp + 5] ; $str
0628   07F7 2A            mov b, [d]
0629   07F8 38 00 00      mov c, 0
0630   07FB 74            mov d, b
0631   07FC 32            mov bl, [d]
0632   07FD A7 00         mov bh, 0
0633   07FF 38 00 00      mov c, 0
0634   0802             ; --- START TERMS
0635   0802 D7            push a
0636   0803 11            mov a, b
0637   0804 FD 2E 30 00   mov32 cb, $00000030
0637   0808 00 00 
0638   080A 60            sub a, b
0639   080B 27            mov b, a
0640   080C E4            pop a
0641   080D             ; --- END TERMS
0642   080D 56            add b, a
0643   080E E4            pop a
0644   080F             ; --- END TERMS
0645   080F E7            pop d
0646   0810 FD 43         mov [d], b
0647   0812             ; str++; 
0648   0812 FA 05 00      lea d, [bp + 5] ; $str
0649   0815 2A            mov b, [d]
0650   0816 38 00 00      mov c, 0
0651   0819 FD 77         inc b
0652   081B FA 05 00      lea d, [bp + 5] ; $str
0653   081E FD 43         mov [d], b
0654   0820 FD 7D         dec b
0655   0822 0A 9C 07      jmp _while9_cond
0656   0825             _while9_exit:
0657   0825             ; return sign * result; 
0658   0825 FA FD FF      lea d, [bp + -3] ; $sign
0659   0828 2A            mov b, [d]
0660   0829 38 00 00      mov c, 0
0661   082C             ; --- START FACTORS
0662   082C D7            push a
0663   082D 11            mov a, b
0664   082E FA FF FF      lea d, [bp + -1] ; $result
0665   0831 2A            mov b, [d]
0666   0832 38 00 00      mov c, 0
0667   0835 AC            mul a, b ; *
0668   0836 11            mov a, b
0669   0837 27            mov b, a
0670   0838 E4            pop a
0671   0839             ; --- END FACTORS
0672   0839 F9            leave
0673   083A 09            ret
0674   083B             
0675   083B             rand:
0676   083B F8 00 00      enter 0 ; (push bp; mov bp, sp)
0677   083E             ; int  sec; 
0678   083E 52 02 00      sub sp, 2
0679   0841             
0680   0841             ; --- BEGIN INLINE ASM SEGMENT
0681   0841 19 00         mov al, 0
0682   0843 05 01         syscall sys_rtc					
0683   0845 1A            mov al, ah
0684   0846 FA FF FF      lea d, [bp + -1] ; $sec
0685   0849 1E            mov al, [d]
0686   084A 22 00         mov ah, 0
0687   084C             ; --- END INLINE ASM SEGMENT
0688   084C             
0689   084C             ; return sec; 
0690   084C FA FF FF      lea d, [bp + -1] ; $sec
0691   084F 2A            mov b, [d]
0692   0850 38 00 00      mov c, 0
0693   0853 F9            leave
0694   0854 09            ret
0695   0855             
0696   0855             alloc:
0697   0855 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0698   0858             ; heap_top = heap_top + bytes; 
0699   0858 3B 9D 21      mov d, _heap_top ; $heap_top
0700   085B DA            push d
0701   085C 3B 9D 21      mov d, _heap_top ; $heap_top
0702   085F 2A            mov b, [d]
0703   0860 38 00 00      mov c, 0
0704   0863             ; --- START TERMS
0705   0863 D7            push a
0706   0864 11            mov a, b
0707   0865 FA 05 00      lea d, [bp + 5] ; $bytes
0708   0868 2A            mov b, [d]
0709   0869 38 00 00      mov c, 0
0710   086C 56            add b, a
0711   086D E4            pop a
0712   086E             ; --- END TERMS
0713   086E E7            pop d
0714   086F FD 43         mov [d], b
0715   0871             ; return heap_top - bytes; 
0716   0871 3B 9D 21      mov d, _heap_top ; $heap_top
0717   0874 2A            mov b, [d]
0718   0875 38 00 00      mov c, 0
0719   0878             ; --- START TERMS
0720   0878 D7            push a
0721   0879 11            mov a, b
0722   087A FA 05 00      lea d, [bp + 5] ; $bytes
0723   087D 2A            mov b, [d]
0724   087E 38 00 00      mov c, 0
0725   0881 60            sub a, b
0726   0882 27            mov b, a
0727   0883 E4            pop a
0728   0884             ; --- END TERMS
0729   0884 F9            leave
0730   0885 09            ret
0731   0886             
0732   0886             free:
0733   0886 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0734   0889             ; return heap_top = heap_top - bytes; 
0735   0889 3B 9D 21      mov d, _heap_top ; $heap_top
0736   088C DA            push d
0737   088D 3B 9D 21      mov d, _heap_top ; $heap_top
0738   0890 2A            mov b, [d]
0739   0891 38 00 00      mov c, 0
0740   0894             ; --- START TERMS
0741   0894 D7            push a
0742   0895 11            mov a, b
0743   0896 FA 05 00      lea d, [bp + 5] ; $bytes
0744   0899 2A            mov b, [d]
0745   089A 38 00 00      mov c, 0
0746   089D 60            sub a, b
0747   089E 27            mov b, a
0748   089F E4            pop a
0749   08A0             ; --- END TERMS
0750   08A0 E7            pop d
0751   08A1 FD 43         mov [d], b
0752   08A3 F9            leave
0753   08A4 09            ret
0754   08A5             
0755   08A5             fopen:
0756   08A5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0757   08A8             ; FILE *fp; 
0758   08A8 52 02 00      sub sp, 2
0759   08AB             ; static int max_handle = 0; 
0760   08AB 52 02 00      sub sp, 2
0761   08AE             ; fp = alloc(sizeof(FILE)); 
0762   08AE FA FF FF      lea d, [bp + -1] ; $fp
0763   08B1 DA            push d
0764   08B2             ; --- START FUNCTION CALL
0765   08B2 26 04 01      mov b, 260
0766   08B5 FD AB         swp b
0767   08B7 D8            push b
0768   08B8 07 55 08      call alloc
0769   08BB 51 02 00      add sp, 2
0770   08BE             ; --- END FUNCTION CALL
0771   08BE E7            pop d
0772   08BF FD 43         mov [d], b
0773   08C1             ; strcpy(fp->filename, filename); 
0774   08C1             ; --- START FUNCTION CALL
0775   08C1 FA 05 00      lea d, [bp + 5] ; $filename
0776   08C4 2A            mov b, [d]
0777   08C5 38 00 00      mov c, 0
0778   08C8 FD AB         swp b
0779   08CA D8            push b
0780   08CB FA FF FF      lea d, [bp + -1] ; $fp
0781   08CE FD 2A         mov d, [d]
0782   08D0 58 02 00      add d, 2
0783   08D3 2D            mov b, d
0784   08D4 38 00 00      mov c, 0
0785   08D7 FD AB         swp b
0786   08D9 D8            push b
0787   08DA 07 12 04      call strcpy
0788   08DD 51 04 00      add sp, 4
0789   08E0             ; --- END FUNCTION CALL
0790   08E0             ; fp->handle = max_handle; 
0791   08E0 FA FF FF      lea d, [bp + -1] ; $fp
0792   08E3 FD 2A         mov d, [d]
0793   08E5 58 00 00      add d, 0
0794   08E8 DA            push d
0795   08E9 3B 57 21      mov d, st_fopen_max_handle ; static max_handle
0796   08EC 2A            mov b, [d]
0797   08ED 38 00 00      mov c, 0
0798   08F0 E7            pop d
0799   08F1 FD 43         mov [d], b
0800   08F3             ; fp->mode = mode; 
0801   08F3 FA FF FF      lea d, [bp + -1] ; $fp
0802   08F6 FD 2A         mov d, [d]
0803   08F8 58 02 01      add d, 258
0804   08FB DA            push d
0805   08FC FA 07 00      lea d, [bp + 7] ; $mode
0806   08FF 32            mov bl, [d]
0807   0900 A7 00         mov bh, 0
0808   0902 38 00 00      mov c, 0
0809   0905 E7            pop d
0810   0906 FD 3E         mov [d], bl
0811   0908             ; fp->loc = 0; 
0812   0908 FA FF FF      lea d, [bp + -1] ; $fp
0813   090B FD 2A         mov d, [d]
0814   090D 58 03 01      add d, 259
0815   0910 DA            push d
0816   0911 FD 2E 00 00   mov32 cb, $00000000
0816   0915 00 00 
0817   0917 E7            pop d
0818   0918 FD 3E         mov [d], bl
0819   091A             ; max_handle++; 
0820   091A 3B 57 21      mov d, st_fopen_max_handle ; static max_handle
0821   091D 2A            mov b, [d]
0822   091E 38 00 00      mov c, 0
0823   0921 FD 77         inc b
0824   0923 3B 57 21      mov d, st_fopen_max_handle ; static max_handle
0825   0926 FD 43         mov [d], b
0826   0928 FD 7D         dec b
0827   092A F9            leave
0828   092B 09            ret
0829   092C             
0830   092C             fclose:
0831   092C F8 00 00      enter 0 ; (push bp; mov bp, sp)
0832   092F             ; free(sizeof(FILE)); 
0833   092F             ; --- START FUNCTION CALL
0834   092F 26 04 01      mov b, 260
0835   0932 FD AB         swp b
0836   0934 D8            push b
0837   0935 07 86 08      call free
0838   0938 51 02 00      add sp, 2
0839   093B             ; --- END FUNCTION CALL
0840   093B F9            leave
0841   093C 09            ret
0842   093D             
0843   093D             printf:
0844   093D F8 00 00      enter 0 ; (push bp; mov bp, sp)
0845   0940             ; char *p, *format_p; 
0846   0940 52 02 00      sub sp, 2
0847   0943 52 02 00      sub sp, 2
0848   0946             ; format_p = format; 
0849   0946 FA FD FF      lea d, [bp + -3] ; $format_p
0850   0949 DA            push d
0851   094A FA 05 00      lea d, [bp + 5] ; $format
0852   094D 2A            mov b, [d]
0853   094E 38 00 00      mov c, 0
0854   0951 E7            pop d
0855   0952 FD 43         mov [d], b
0856   0954             ; p = &format + 2; 
0857   0954 FA FF FF      lea d, [bp + -1] ; $p
0858   0957 DA            push d
0859   0958 FA 05 00      lea d, [bp + 5] ; $format
0860   095B 2D            mov b, d
0861   095C             ; --- START TERMS
0862   095C D7            push a
0863   095D 11            mov a, b
0864   095E FD 2E 02 00   mov32 cb, $00000002
0864   0962 00 00 
0865   0964 56            add b, a
0866   0965 E4            pop a
0867   0966             ; --- END TERMS
0868   0966 E7            pop d
0869   0967 FD 43         mov [d], b
0870   0969             ; for(;;){ 
0871   0969             _for10_init:
0872   0969             _for10_cond:
0873   0969             _for10_block:
0874   0969             ; if(!*format_p) break; 
0875   0969             _if11_cond:
0876   0969 FA FD FF      lea d, [bp + -3] ; $format_p
0877   096C 2A            mov b, [d]
0878   096D 38 00 00      mov c, 0
0879   0970 74            mov d, b
0880   0971 32            mov bl, [d]
0881   0972 A7 00         mov bh, 0
0882   0974 38 00 00      mov c, 0
0883   0977 C0 00 00      cmp b, 0
0884   097A FD 71         seq ; !
0885   097C C0 00 00      cmp b, 0
0886   097F C6 88 09      je _if11_else
0887   0982             _if11_true:
0888   0982             ; break; 
0889   0982 0A 21 0C      jmp _for10_exit ; for break
0890   0985 0A 1E 0C      jmp _if11_exit
0891   0988             _if11_else:
0892   0988             ; if(*format_p == '%'){ 
0893   0988             _if12_cond:
0894   0988 FA FD FF      lea d, [bp + -3] ; $format_p
0895   098B 2A            mov b, [d]
0896   098C 38 00 00      mov c, 0
0897   098F 74            mov d, b
0898   0990 32            mov bl, [d]
0899   0991 A7 00         mov bh, 0
0900   0993 38 00 00      mov c, 0
0901   0996             ; --- START RELATIONAL
0902   0996 D7            push a
0903   0997 11            mov a, b
0904   0998 FD 2E 25 00   mov32 cb, $00000025
0904   099C 00 00 
0905   099E B0            cmp a, b
0906   099F FD 71         seq ; ==
0907   09A1 E4            pop a
0908   09A2             ; --- END RELATIONAL
0909   09A2 C0 00 00      cmp b, 0
0910   09A5 C6 F9 0B      je _if12_else
0911   09A8             _if12_true:
0912   09A8             ; format_p++; 
0913   09A8 FA FD FF      lea d, [bp + -3] ; $format_p
0914   09AB 2A            mov b, [d]
0915   09AC 38 00 00      mov c, 0
0916   09AF FD 77         inc b
0917   09B1 FA FD FF      lea d, [bp + -3] ; $format_p
0918   09B4 FD 43         mov [d], b
0919   09B6 FD 7D         dec b
0920   09B8             ; switch(*format_p){ 
0921   09B8             _switch13_expr:
0922   09B8 FA FD FF      lea d, [bp + -3] ; $format_p
0923   09BB 2A            mov b, [d]
0924   09BC 38 00 00      mov c, 0
0925   09BF 74            mov d, b
0926   09C0 32            mov bl, [d]
0927   09C1 A7 00         mov bh, 0
0928   09C3 38 00 00      mov c, 0
0929   09C6             _switch13_comparisons:
0930   09C6 C1 6C         cmp bl, $6c
0931   09C8 C6 F4 09      je _switch13_case0
0932   09CB C1 4C         cmp bl, $4c
0933   09CD C6 F4 09      je _switch13_case1
0934   09D0 C1 64         cmp bl, $64
0935   09D2 C6 0C 0B      je _switch13_case2
0936   09D5 C1 69         cmp bl, $69
0937   09D7 C6 0C 0B      je _switch13_case3
0938   09DA C1 75         cmp bl, $75
0939   09DC C6 3C 0B      je _switch13_case4
0940   09DF C1 78         cmp bl, $78
0941   09E1 C6 6C 0B      je _switch13_case5
0942   09E4 C1 63         cmp bl, $63
0943   09E6 C6 90 0B      je _switch13_case6
0944   09E9 C1 73         cmp bl, $73
0945   09EB C6 B5 0B      je _switch13_case7
0946   09EE 0A DA 0B      jmp _switch13_default
0947   09F1 0A E6 0B      jmp _switch13_exit
0948   09F4             _switch13_case0:
0949   09F4             _switch13_case1:
0950   09F4             ; format_p++; 
0951   09F4 FA FD FF      lea d, [bp + -3] ; $format_p
0952   09F7 2A            mov b, [d]
0953   09F8 38 00 00      mov c, 0
0954   09FB FD 77         inc b
0955   09FD FA FD FF      lea d, [bp + -3] ; $format_p
0956   0A00 FD 43         mov [d], b
0957   0A02 FD 7D         dec b
0958   0A04             ; if(*format_p == 'd' || *format_p == 'i') 
0959   0A04             _if14_cond:
0960   0A04 FA FD FF      lea d, [bp + -3] ; $format_p
0961   0A07 2A            mov b, [d]
0962   0A08 38 00 00      mov c, 0
0963   0A0B 74            mov d, b
0964   0A0C 32            mov bl, [d]
0965   0A0D A7 00         mov bh, 0
0966   0A0F 38 00 00      mov c, 0
0967   0A12             ; --- START RELATIONAL
0968   0A12 D7            push a
0969   0A13 11            mov a, b
0970   0A14 FD 2E 64 00   mov32 cb, $00000064
0970   0A18 00 00 
0971   0A1A B0            cmp a, b
0972   0A1B FD 71         seq ; ==
0973   0A1D E4            pop a
0974   0A1E             ; --- END RELATIONAL
0975   0A1E             ; --- START LOGICAL OR
0976   0A1E D7            push a
0977   0A1F 11            mov a, b
0978   0A20 FA FD FF      lea d, [bp + -3] ; $format_p
0979   0A23 2A            mov b, [d]
0980   0A24 38 00 00      mov c, 0
0981   0A27 74            mov d, b
0982   0A28 32            mov bl, [d]
0983   0A29 A7 00         mov bh, 0
0984   0A2B 38 00 00      mov c, 0
0985   0A2E             ; --- START RELATIONAL
0986   0A2E D7            push a
0987   0A2F 11            mov a, b
0988   0A30 FD 2E 69 00   mov32 cb, $00000069
0988   0A34 00 00 
0989   0A36 B0            cmp a, b
0990   0A37 FD 71         seq ; ==
0991   0A39 E4            pop a
0992   0A3A             ; --- END RELATIONAL
0993   0A3A FD A8         sor a, b ; ||
0994   0A3C E4            pop a
0995   0A3D             ; --- END LOGICAL OR
0996   0A3D C0 00 00      cmp b, 0
0997   0A40 C6 64 0A      je _if14_else
0998   0A43             _if14_true:
0999   0A43             ; print_signed_long(*(long *)p); 
1000   0A43             ; --- START FUNCTION CALL
1001   0A43 FA FF FF      lea d, [bp + -1] ; $p
1002   0A46 2A            mov b, [d]
1003   0A47 38 00 00      mov c, 0
1004   0A4A AB            snex b
1005   0A4B FD 39         mov c, b
1006   0A4D 74            mov d, b
1007   0A4E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1008   0A51 FD 39         mov c, b ; And place it into C
1009   0A53 2A            mov b, [d] ; Lower Word in B
1010   0A54 12            mov a, c
1011   0A55 FD AA         swp a
1012   0A57 D7            push a
1013   0A58 FD AB         swp b
1014   0A5A D8            push b
1015   0A5B 07 FB 15      call print_signed_long
1016   0A5E 51 04 00      add sp, 4
1017   0A61             ; --- END FUNCTION CALL
1018   0A61 0A F1 0A      jmp _if14_exit
1019   0A64             _if14_else:
1020   0A64             ; if(*format_p == 'u') 
1021   0A64             _if15_cond:
1022   0A64 FA FD FF      lea d, [bp + -3] ; $format_p
1023   0A67 2A            mov b, [d]
1024   0A68 38 00 00      mov c, 0
1025   0A6B 74            mov d, b
1026   0A6C 32            mov bl, [d]
1027   0A6D A7 00         mov bh, 0
1028   0A6F 38 00 00      mov c, 0
1029   0A72             ; --- START RELATIONAL
1030   0A72 D7            push a
1031   0A73 11            mov a, b
1032   0A74 FD 2E 75 00   mov32 cb, $00000075
1032   0A78 00 00 
1033   0A7A B0            cmp a, b
1034   0A7B FD 71         seq ; ==
1035   0A7D E4            pop a
1036   0A7E             ; --- END RELATIONAL
1037   0A7E C0 00 00      cmp b, 0
1038   0A81 C6 A7 0A      je _if15_else
1039   0A84             _if15_true:
1040   0A84             ; print_unsigned_long(*(unsigned long *)p); 
1041   0A84             ; --- START FUNCTION CALL
1042   0A84 FA FF FF      lea d, [bp + -1] ; $p
1043   0A87 2A            mov b, [d]
1044   0A88 38 00 00      mov c, 0
1045   0A8B A7 00         mov bh, 0
1046   0A8D 38 00 00      mov c, 0
1047   0A90 74            mov d, b
1048   0A91 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1049   0A94 FD 39         mov c, b ; And place it into C
1050   0A96 2A            mov b, [d] ; Lower Word in B
1051   0A97 12            mov a, c
1052   0A98 FD AA         swp a
1053   0A9A D7            push a
1054   0A9B FD AB         swp b
1055   0A9D D8            push b
1056   0A9E 07 6A 17      call print_unsigned_long
1057   0AA1 51 04 00      add sp, 4
1058   0AA4             ; --- END FUNCTION CALL
1059   0AA4 0A F1 0A      jmp _if15_exit
1060   0AA7             _if15_else:
1061   0AA7             ; if(*format_p == 'x') 
1062   0AA7             _if16_cond:
1063   0AA7 FA FD FF      lea d, [bp + -3] ; $format_p
1064   0AAA 2A            mov b, [d]
1065   0AAB 38 00 00      mov c, 0
1066   0AAE 74            mov d, b
1067   0AAF 32            mov bl, [d]
1068   0AB0 A7 00         mov bh, 0
1069   0AB2 38 00 00      mov c, 0
1070   0AB5             ; --- START RELATIONAL
1071   0AB5 D7            push a
1072   0AB6 11            mov a, b
1073   0AB7 FD 2E 78 00   mov32 cb, $00000078
1073   0ABB 00 00 
1074   0ABD B0            cmp a, b
1075   0ABE FD 71         seq ; ==
1076   0AC0 E4            pop a
1077   0AC1             ; --- END RELATIONAL
1078   0AC1 C0 00 00      cmp b, 0
1079   0AC4 C6 E5 0A      je _if16_else
1080   0AC7             _if16_true:
1081   0AC7             ; printx32(*(long int *)p); 
1082   0AC7             ; --- START FUNCTION CALL
1083   0AC7 FA FF FF      lea d, [bp + -1] ; $p
1084   0ACA 2A            mov b, [d]
1085   0ACB 38 00 00      mov c, 0
1086   0ACE 74            mov d, b
1087   0ACF 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1088   0AD2 FD 39         mov c, b ; And place it into C
1089   0AD4 2A            mov b, [d] ; Lower Word in B
1090   0AD5 12            mov a, c
1091   0AD6 FD AA         swp a
1092   0AD8 D7            push a
1093   0AD9 FD AB         swp b
1094   0ADB D8            push b
1095   0ADC 07 CE 12      call printx32
1096   0ADF 51 04 00      add sp, 4
1097   0AE2             ; --- END FUNCTION CALL
1098   0AE2 0A F1 0A      jmp _if16_exit
1099   0AE5             _if16_else:
1100   0AE5             ; err("Unexpected format in printf."); 
1101   0AE5             ; --- START FUNCTION CALL
1102   0AE5 26 59 21      mov b, _s0 ; "Unexpected format in printf."
1103   0AE8 FD AB         swp b
1104   0AEA D8            push b
1105   0AEB 07 B9 12      call err
1106   0AEE 51 02 00      add sp, 2
1107   0AF1             ; --- END FUNCTION CALL
1108   0AF1             _if16_exit:
1109   0AF1             _if15_exit:
1110   0AF1             _if14_exit:
1111   0AF1             ; p = p + 4; 
1112   0AF1 FA FF FF      lea d, [bp + -1] ; $p
1113   0AF4 DA            push d
1114   0AF5 FA FF FF      lea d, [bp + -1] ; $p
1115   0AF8 2A            mov b, [d]
1116   0AF9 38 00 00      mov c, 0
1117   0AFC             ; --- START TERMS
1118   0AFC D7            push a
1119   0AFD 11            mov a, b
1120   0AFE FD 2E 04 00   mov32 cb, $00000004
1120   0B02 00 00 
1121   0B04 56            add b, a
1122   0B05 E4            pop a
1123   0B06             ; --- END TERMS
1124   0B06 E7            pop d
1125   0B07 FD 43         mov [d], b
1126   0B09             ; break; 
1127   0B09 0A E6 0B      jmp _switch13_exit ; case break
1128   0B0C             _switch13_case2:
1129   0B0C             _switch13_case3:
1130   0B0C             ; print_signed(*(int*)p); 
1131   0B0C             ; --- START FUNCTION CALL
1132   0B0C FA FF FF      lea d, [bp + -1] ; $p
1133   0B0F 2A            mov b, [d]
1134   0B10 38 00 00      mov c, 0
1135   0B13 74            mov d, b
1136   0B14 2A            mov b, [d]
1137   0B15 38 00 00      mov c, 0
1138   0B18 FD AB         swp b
1139   0B1A D8            push b
1140   0B1B 07 C2 14      call print_signed
1141   0B1E 51 02 00      add sp, 2
1142   0B21             ; --- END FUNCTION CALL
1143   0B21             ; p = p + 2; 
1144   0B21 FA FF FF      lea d, [bp + -1] ; $p
1145   0B24 DA            push d
1146   0B25 FA FF FF      lea d, [bp + -1] ; $p
1147   0B28 2A            mov b, [d]
1148   0B29 38 00 00      mov c, 0
1149   0B2C             ; --- START TERMS
1150   0B2C D7            push a
1151   0B2D 11            mov a, b
1152   0B2E FD 2E 02 00   mov32 cb, $00000002
1152   0B32 00 00 
1153   0B34 56            add b, a
1154   0B35 E4            pop a
1155   0B36             ; --- END TERMS
1156   0B36 E7            pop d
1157   0B37 FD 43         mov [d], b
1158   0B39             ; break; 
1159   0B39 0A E6 0B      jmp _switch13_exit ; case break
1160   0B3C             _switch13_case4:
1161   0B3C             ; print_unsigned(*(unsigned int*)p); 
1162   0B3C             ; --- START FUNCTION CALL
1163   0B3C FA FF FF      lea d, [bp + -1] ; $p
1164   0B3F 2A            mov b, [d]
1165   0B40 38 00 00      mov c, 0
1166   0B43 74            mov d, b
1167   0B44 2A            mov b, [d]
1168   0B45 38 00 00      mov c, 0
1169   0B48 FD AB         swp b
1170   0B4A D8            push b
1171   0B4B 07 DE 19      call print_unsigned
1172   0B4E 51 02 00      add sp, 2
1173   0B51             ; --- END FUNCTION CALL
1174   0B51             ; p = p + 2; 
1175   0B51 FA FF FF      lea d, [bp + -1] ; $p
1176   0B54 DA            push d
1177   0B55 FA FF FF      lea d, [bp + -1] ; $p
1178   0B58 2A            mov b, [d]
1179   0B59 38 00 00      mov c, 0
1180   0B5C             ; --- START TERMS
1181   0B5C D7            push a
1182   0B5D 11            mov a, b
1183   0B5E FD 2E 02 00   mov32 cb, $00000002
1183   0B62 00 00 
1184   0B64 56            add b, a
1185   0B65 E4            pop a
1186   0B66             ; --- END TERMS
1187   0B66 E7            pop d
1188   0B67 FD 43         mov [d], b
1189   0B69             ; break; 
1190   0B69 0A E6 0B      jmp _switch13_exit ; case break
1191   0B6C             _switch13_case5:
1192   0B6C             
1193   0B6C             ; --- BEGIN INLINE ASM SEGMENT
1194   0B6C FA FF FF      lea d, [bp + -1] ; $p
1195   0B6F FD 2A         mov d, [d]
1196   0B71 2A            mov b, [d]
1197   0B72 07 57 20      call print_u16x
1198   0B75             ; --- END INLINE ASM SEGMENT
1199   0B75             
1200   0B75             ; p = p + 2; 
1201   0B75 FA FF FF      lea d, [bp + -1] ; $p
1202   0B78 DA            push d
1203   0B79 FA FF FF      lea d, [bp + -1] ; $p
1204   0B7C 2A            mov b, [d]
1205   0B7D 38 00 00      mov c, 0
1206   0B80             ; --- START TERMS
1207   0B80 D7            push a
1208   0B81 11            mov a, b
1209   0B82 FD 2E 02 00   mov32 cb, $00000002
1209   0B86 00 00 
1210   0B88 56            add b, a
1211   0B89 E4            pop a
1212   0B8A             ; --- END TERMS
1213   0B8A E7            pop d
1214   0B8B FD 43         mov [d], b
1215   0B8D             ; break; 
1216   0B8D 0A E6 0B      jmp _switch13_exit ; case break
1217   0B90             _switch13_case6:
1218   0B90             
1219   0B90             ; --- BEGIN INLINE ASM SEGMENT
1220   0B90 FA FF FF      lea d, [bp + -1] ; $p
1221   0B93 FD 2A         mov d, [d]
1222   0B95 1E            mov al, [d]
1223   0B96 23            mov ah, al
1224   0B97 07 B5 1E      call _putchar
1225   0B9A             ; --- END INLINE ASM SEGMENT
1226   0B9A             
1227   0B9A             ; p = p + 1; 
1228   0B9A FA FF FF      lea d, [bp + -1] ; $p
1229   0B9D DA            push d
1230   0B9E FA FF FF      lea d, [bp + -1] ; $p
1231   0BA1 2A            mov b, [d]
1232   0BA2 38 00 00      mov c, 0
1233   0BA5             ; --- START TERMS
1234   0BA5 D7            push a
1235   0BA6 11            mov a, b
1236   0BA7 FD 2E 01 00   mov32 cb, $00000001
1236   0BAB 00 00 
1237   0BAD 56            add b, a
1238   0BAE E4            pop a
1239   0BAF             ; --- END TERMS
1240   0BAF E7            pop d
1241   0BB0 FD 43         mov [d], b
1242   0BB2             ; break; 
1243   0BB2 0A E6 0B      jmp _switch13_exit ; case break
1244   0BB5             _switch13_case7:
1245   0BB5             
1246   0BB5             ; --- BEGIN INLINE ASM SEGMENT
1247   0BB5 FA FF FF      lea d, [bp + -1] ; $p
1248   0BB8 FD 2A         mov d, [d]
1249   0BBA FD 2A         mov d, [d]
1250   0BBC 07 FF 1F      call _puts
1251   0BBF             ; --- END INLINE ASM SEGMENT
1252   0BBF             
1253   0BBF             ; p = p + 2; 
1254   0BBF FA FF FF      lea d, [bp + -1] ; $p
1255   0BC2 DA            push d
1256   0BC3 FA FF FF      lea d, [bp + -1] ; $p
1257   0BC6 2A            mov b, [d]
1258   0BC7 38 00 00      mov c, 0
1259   0BCA             ; --- START TERMS
1260   0BCA D7            push a
1261   0BCB 11            mov a, b
1262   0BCC FD 2E 02 00   mov32 cb, $00000002
1262   0BD0 00 00 
1263   0BD2 56            add b, a
1264   0BD3 E4            pop a
1265   0BD4             ; --- END TERMS
1266   0BD4 E7            pop d
1267   0BD5 FD 43         mov [d], b
1268   0BD7             ; break; 
1269   0BD7 0A E6 0B      jmp _switch13_exit ; case break
1270   0BDA             _switch13_default:
1271   0BDA             ; print("Error: Unknown argument type.\n"); 
1272   0BDA             ; --- START FUNCTION CALL
1273   0BDA 26 76 21      mov b, _s1 ; "Error: Unknown argument type.\n"
1274   0BDD FD AB         swp b
1275   0BDF D8            push b
1276   0BE0 07 F4 1C      call print
1277   0BE3 51 02 00      add sp, 2
1278   0BE6             ; --- END FUNCTION CALL
1279   0BE6             _switch13_exit:
1280   0BE6             ; format_p++; 
1281   0BE6 FA FD FF      lea d, [bp + -3] ; $format_p
1282   0BE9 2A            mov b, [d]
1283   0BEA 38 00 00      mov c, 0
1284   0BED FD 77         inc b
1285   0BEF FA FD FF      lea d, [bp + -3] ; $format_p
1286   0BF2 FD 43         mov [d], b
1287   0BF4 FD 7D         dec b
1288   0BF6 0A 1E 0C      jmp _if12_exit
1289   0BF9             _if12_else:
1290   0BF9             ; putchar(*format_p); 
1291   0BF9             ; --- START FUNCTION CALL
1292   0BF9 FA FD FF      lea d, [bp + -3] ; $format_p
1293   0BFC 2A            mov b, [d]
1294   0BFD 38 00 00      mov c, 0
1295   0C00 74            mov d, b
1296   0C01 32            mov bl, [d]
1297   0C02 A7 00         mov bh, 0
1298   0C04 38 00 00      mov c, 0
1299   0C07 DD            push bl
1300   0C08 07 A6 1C      call putchar
1301   0C0B 51 01 00      add sp, 1
1302   0C0E             ; --- END FUNCTION CALL
1303   0C0E             ; format_p++; 
1304   0C0E FA FD FF      lea d, [bp + -3] ; $format_p
1305   0C11 2A            mov b, [d]
1306   0C12 38 00 00      mov c, 0
1307   0C15 FD 77         inc b
1308   0C17 FA FD FF      lea d, [bp + -3] ; $format_p
1309   0C1A FD 43         mov [d], b
1310   0C1C FD 7D         dec b
1311   0C1E             _if12_exit:
1312   0C1E             _if11_exit:
1313   0C1E             _for10_update:
1314   0C1E 0A 69 09      jmp _for10_cond
1315   0C21             _for10_exit:
1316   0C21 F9            leave
1317   0C22 09            ret
1318   0C23             
1319   0C23             scanf:
1320   0C23 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1321   0C26             ; char *p, *format_p; 
1322   0C26 52 02 00      sub sp, 2
1323   0C29 52 02 00      sub sp, 2
1324   0C2C             ; char c; 
1325   0C2C 52 01 00      sub sp, 1
1326   0C2F             ; int i; 
1327   0C2F 52 02 00      sub sp, 2
1328   0C32             ; char input_string[  512                    ]; 
1329   0C32 52 00 02      sub sp, 512
1330   0C35             ; format_p = format; 
1331   0C35 FA FD FF      lea d, [bp + -3] ; $format_p
1332   0C38 DA            push d
1333   0C39 FA 05 00      lea d, [bp + 5] ; $format
1334   0C3C 2A            mov b, [d]
1335   0C3D 38 00 00      mov c, 0
1336   0C40 E7            pop d
1337   0C41 FD 43         mov [d], b
1338   0C43             ; p = &format + 2; 
1339   0C43 FA FF FF      lea d, [bp + -1] ; $p
1340   0C46 DA            push d
1341   0C47 FA 05 00      lea d, [bp + 5] ; $format
1342   0C4A 2D            mov b, d
1343   0C4B             ; --- START TERMS
1344   0C4B D7            push a
1345   0C4C 11            mov a, b
1346   0C4D FD 2E 02 00   mov32 cb, $00000002
1346   0C51 00 00 
1347   0C53 56            add b, a
1348   0C54 E4            pop a
1349   0C55             ; --- END TERMS
1350   0C55 E7            pop d
1351   0C56 FD 43         mov [d], b
1352   0C58             ; for(;;){ 
1353   0C58             _for17_init:
1354   0C58             _for17_cond:
1355   0C58             _for17_block:
1356   0C58             ; if(!*format_p) break; 
1357   0C58             _if18_cond:
1358   0C58 FA FD FF      lea d, [bp + -3] ; $format_p
1359   0C5B 2A            mov b, [d]
1360   0C5C 38 00 00      mov c, 0
1361   0C5F 74            mov d, b
1362   0C60 32            mov bl, [d]
1363   0C61 A7 00         mov bh, 0
1364   0C63 38 00 00      mov c, 0
1365   0C66 C0 00 00      cmp b, 0
1366   0C69 FD 71         seq ; !
1367   0C6B C0 00 00      cmp b, 0
1368   0C6E C6 77 0C      je _if18_else
1369   0C71             _if18_true:
1370   0C71             ; break; 
1371   0C71 0A FF 0E      jmp _for17_exit ; for break
1372   0C74 0A FC 0E      jmp _if18_exit
1373   0C77             _if18_else:
1374   0C77             ; if(*format_p == '%'){ 
1375   0C77             _if19_cond:
1376   0C77 FA FD FF      lea d, [bp + -3] ; $format_p
1377   0C7A 2A            mov b, [d]
1378   0C7B 38 00 00      mov c, 0
1379   0C7E 74            mov d, b
1380   0C7F 32            mov bl, [d]
1381   0C80 A7 00         mov bh, 0
1382   0C82 38 00 00      mov c, 0
1383   0C85             ; --- START RELATIONAL
1384   0C85 D7            push a
1385   0C86 11            mov a, b
1386   0C87 FD 2E 25 00   mov32 cb, $00000025
1386   0C8B 00 00 
1387   0C8D B0            cmp a, b
1388   0C8E FD 71         seq ; ==
1389   0C90 E4            pop a
1390   0C91             ; --- END RELATIONAL
1391   0C91 C0 00 00      cmp b, 0
1392   0C94 C6 D7 0E      je _if19_else
1393   0C97             _if19_true:
1394   0C97             ; format_p++; 
1395   0C97 FA FD FF      lea d, [bp + -3] ; $format_p
1396   0C9A 2A            mov b, [d]
1397   0C9B 38 00 00      mov c, 0
1398   0C9E FD 77         inc b
1399   0CA0 FA FD FF      lea d, [bp + -3] ; $format_p
1400   0CA3 FD 43         mov [d], b
1401   0CA5 FD 7D         dec b
1402   0CA7             ; switch(*format_p){ 
1403   0CA7             _switch20_expr:
1404   0CA7 FA FD FF      lea d, [bp + -3] ; $format_p
1405   0CAA 2A            mov b, [d]
1406   0CAB 38 00 00      mov c, 0
1407   0CAE 74            mov d, b
1408   0CAF 32            mov bl, [d]
1409   0CB0 A7 00         mov bh, 0
1410   0CB2 38 00 00      mov c, 0
1411   0CB5             _switch20_comparisons:
1412   0CB5 C1 6C         cmp bl, $6c
1413   0CB7 C6 E3 0C      je _switch20_case0
1414   0CBA C1 4C         cmp bl, $4c
1415   0CBC C6 E3 0C      je _switch20_case1
1416   0CBF C1 64         cmp bl, $64
1417   0CC1 C6 A2 0D      je _switch20_case2
1418   0CC4 C1 69         cmp bl, $69
1419   0CC6 C6 A2 0D      je _switch20_case3
1420   0CC9 C1 75         cmp bl, $75
1421   0CCB C6 DB 0D      je _switch20_case4
1422   0CCE C1 78         cmp bl, $78
1423   0CD0 C6 14 0E      je _switch20_case5
1424   0CD3 C1 63         cmp bl, $63
1425   0CD5 C6 2F 0E      je _switch20_case6
1426   0CD8 C1 73         cmp bl, $73
1427   0CDA C6 71 0E      je _switch20_case7
1428   0CDD 0A B8 0E      jmp _switch20_default
1429   0CE0 0A C4 0E      jmp _switch20_exit
1430   0CE3             _switch20_case0:
1431   0CE3             _switch20_case1:
1432   0CE3             ; format_p++; 
1433   0CE3 FA FD FF      lea d, [bp + -3] ; $format_p
1434   0CE6 2A            mov b, [d]
1435   0CE7 38 00 00      mov c, 0
1436   0CEA FD 77         inc b
1437   0CEC FA FD FF      lea d, [bp + -3] ; $format_p
1438   0CEF FD 43         mov [d], b
1439   0CF1 FD 7D         dec b
1440   0CF3             ; if(*format_p == 'd' || *format_p == 'i'); 
1441   0CF3             _if21_cond:
1442   0CF3 FA FD FF      lea d, [bp + -3] ; $format_p
1443   0CF6 2A            mov b, [d]
1444   0CF7 38 00 00      mov c, 0
1445   0CFA 74            mov d, b
1446   0CFB 32            mov bl, [d]
1447   0CFC A7 00         mov bh, 0
1448   0CFE 38 00 00      mov c, 0
1449   0D01             ; --- START RELATIONAL
1450   0D01 D7            push a
1451   0D02 11            mov a, b
1452   0D03 FD 2E 64 00   mov32 cb, $00000064
1452   0D07 00 00 
1453   0D09 B0            cmp a, b
1454   0D0A FD 71         seq ; ==
1455   0D0C E4            pop a
1456   0D0D             ; --- END RELATIONAL
1457   0D0D             ; --- START LOGICAL OR
1458   0D0D D7            push a
1459   0D0E 11            mov a, b
1460   0D0F FA FD FF      lea d, [bp + -3] ; $format_p
1461   0D12 2A            mov b, [d]
1462   0D13 38 00 00      mov c, 0
1463   0D16 74            mov d, b
1464   0D17 32            mov bl, [d]
1465   0D18 A7 00         mov bh, 0
1466   0D1A 38 00 00      mov c, 0
1467   0D1D             ; --- START RELATIONAL
1468   0D1D D7            push a
1469   0D1E 11            mov a, b
1470   0D1F FD 2E 69 00   mov32 cb, $00000069
1470   0D23 00 00 
1471   0D25 B0            cmp a, b
1472   0D26 FD 71         seq ; ==
1473   0D28 E4            pop a
1474   0D29             ; --- END RELATIONAL
1475   0D29 FD A8         sor a, b ; ||
1476   0D2B E4            pop a
1477   0D2C             ; --- END LOGICAL OR
1478   0D2C C0 00 00      cmp b, 0
1479   0D2F C6 35 0D      je _if21_else
1480   0D32             _if21_true:
1481   0D32             ; ; 
1482   0D32 0A 87 0D      jmp _if21_exit
1483   0D35             _if21_else:
1484   0D35             ; if(*format_p == 'u'); 
1485   0D35             _if22_cond:
1486   0D35 FA FD FF      lea d, [bp + -3] ; $format_p
1487   0D38 2A            mov b, [d]
1488   0D39 38 00 00      mov c, 0
1489   0D3C 74            mov d, b
1490   0D3D 32            mov bl, [d]
1491   0D3E A7 00         mov bh, 0
1492   0D40 38 00 00      mov c, 0
1493   0D43             ; --- START RELATIONAL
1494   0D43 D7            push a
1495   0D44 11            mov a, b
1496   0D45 FD 2E 75 00   mov32 cb, $00000075
1496   0D49 00 00 
1497   0D4B B0            cmp a, b
1498   0D4C FD 71         seq ; ==
1499   0D4E E4            pop a
1500   0D4F             ; --- END RELATIONAL
1501   0D4F C0 00 00      cmp b, 0
1502   0D52 C6 58 0D      je _if22_else
1503   0D55             _if22_true:
1504   0D55             ; ; 
1505   0D55 0A 87 0D      jmp _if22_exit
1506   0D58             _if22_else:
1507   0D58             ; if(*format_p == 'x'); 
1508   0D58             _if23_cond:
1509   0D58 FA FD FF      lea d, [bp + -3] ; $format_p
1510   0D5B 2A            mov b, [d]
1511   0D5C 38 00 00      mov c, 0
1512   0D5F 74            mov d, b
1513   0D60 32            mov bl, [d]
1514   0D61 A7 00         mov bh, 0
1515   0D63 38 00 00      mov c, 0
1516   0D66             ; --- START RELATIONAL
1517   0D66 D7            push a
1518   0D67 11            mov a, b
1519   0D68 FD 2E 78 00   mov32 cb, $00000078
1519   0D6C 00 00 
1520   0D6E B0            cmp a, b
1521   0D6F FD 71         seq ; ==
1522   0D71 E4            pop a
1523   0D72             ; --- END RELATIONAL
1524   0D72 C0 00 00      cmp b, 0
1525   0D75 C6 7B 0D      je _if23_else
1526   0D78             _if23_true:
1527   0D78             ; ; 
1528   0D78 0A 87 0D      jmp _if23_exit
1529   0D7B             _if23_else:
1530   0D7B             ; err("Unexpected format in printf."); 
1531   0D7B             ; --- START FUNCTION CALL
1532   0D7B 26 59 21      mov b, _s0 ; "Unexpected format in printf."
1533   0D7E FD AB         swp b
1534   0D80 D8            push b
1535   0D81 07 B9 12      call err
1536   0D84 51 02 00      add sp, 2
1537   0D87             ; --- END FUNCTION CALL
1538   0D87             _if23_exit:
1539   0D87             _if22_exit:
1540   0D87             _if21_exit:
1541   0D87             ; p = p + 4; 
1542   0D87 FA FF FF      lea d, [bp + -1] ; $p
1543   0D8A DA            push d
1544   0D8B FA FF FF      lea d, [bp + -1] ; $p
1545   0D8E 2A            mov b, [d]
1546   0D8F 38 00 00      mov c, 0
1547   0D92             ; --- START TERMS
1548   0D92 D7            push a
1549   0D93 11            mov a, b
1550   0D94 FD 2E 04 00   mov32 cb, $00000004
1550   0D98 00 00 
1551   0D9A 56            add b, a
1552   0D9B E4            pop a
1553   0D9C             ; --- END TERMS
1554   0D9C E7            pop d
1555   0D9D FD 43         mov [d], b
1556   0D9F             ; break; 
1557   0D9F 0A C4 0E      jmp _switch20_exit ; case break
1558   0DA2             _switch20_case2:
1559   0DA2             _switch20_case3:
1560   0DA2             ; i = scann(); 
1561   0DA2 FA FA FF      lea d, [bp + -6] ; $i
1562   0DA5 DA            push d
1563   0DA6             ; --- START FUNCTION CALL
1564   0DA6 07 CC 1C      call scann
1565   0DA9 E7            pop d
1566   0DAA FD 43         mov [d], b
1567   0DAC             ; **(int **)p = i; 
1568   0DAC FA FF FF      lea d, [bp + -1] ; $p
1569   0DAF 2A            mov b, [d]
1570   0DB0 38 00 00      mov c, 0
1571   0DB3 74            mov d, b
1572   0DB4 2A            mov b, [d]
1573   0DB5 D8            push b
1574   0DB6 FA FA FF      lea d, [bp + -6] ; $i
1575   0DB9 2A            mov b, [d]
1576   0DBA 38 00 00      mov c, 0
1577   0DBD E7            pop d
1578   0DBE FD 43         mov [d], b
1579   0DC0             ; p = p + 2; 
1580   0DC0 FA FF FF      lea d, [bp + -1] ; $p
1581   0DC3 DA            push d
1582   0DC4 FA FF FF      lea d, [bp + -1] ; $p
1583   0DC7 2A            mov b, [d]
1584   0DC8 38 00 00      mov c, 0
1585   0DCB             ; --- START TERMS
1586   0DCB D7            push a
1587   0DCC 11            mov a, b
1588   0DCD FD 2E 02 00   mov32 cb, $00000002
1588   0DD1 00 00 
1589   0DD3 56            add b, a
1590   0DD4 E4            pop a
1591   0DD5             ; --- END TERMS
1592   0DD5 E7            pop d
1593   0DD6 FD 43         mov [d], b
1594   0DD8             ; break; 
1595   0DD8 0A C4 0E      jmp _switch20_exit ; case break
1596   0DDB             _switch20_case4:
1597   0DDB             ; i = scann(); 
1598   0DDB FA FA FF      lea d, [bp + -6] ; $i
1599   0DDE DA            push d
1600   0DDF             ; --- START FUNCTION CALL
1601   0DDF 07 CC 1C      call scann
1602   0DE2 E7            pop d
1603   0DE3 FD 43         mov [d], b
1604   0DE5             ; **(int **)p = i; 
1605   0DE5 FA FF FF      lea d, [bp + -1] ; $p
1606   0DE8 2A            mov b, [d]
1607   0DE9 38 00 00      mov c, 0
1608   0DEC 74            mov d, b
1609   0DED 2A            mov b, [d]
1610   0DEE D8            push b
1611   0DEF FA FA FF      lea d, [bp + -6] ; $i
1612   0DF2 2A            mov b, [d]
1613   0DF3 38 00 00      mov c, 0
1614   0DF6 E7            pop d
1615   0DF7 FD 43         mov [d], b
1616   0DF9             ; p = p + 2; 
1617   0DF9 FA FF FF      lea d, [bp + -1] ; $p
1618   0DFC DA            push d
1619   0DFD FA FF FF      lea d, [bp + -1] ; $p
1620   0E00 2A            mov b, [d]
1621   0E01 38 00 00      mov c, 0
1622   0E04             ; --- START TERMS
1623   0E04 D7            push a
1624   0E05 11            mov a, b
1625   0E06 FD 2E 02 00   mov32 cb, $00000002
1625   0E0A 00 00 
1626   0E0C 56            add b, a
1627   0E0D E4            pop a
1628   0E0E             ; --- END TERMS
1629   0E0E E7            pop d
1630   0E0F FD 43         mov [d], b
1631   0E11             ; break; 
1632   0E11 0A C4 0E      jmp _switch20_exit ; case break
1633   0E14             _switch20_case5:
1634   0E14             ; p = p + 2; 
1635   0E14 FA FF FF      lea d, [bp + -1] ; $p
1636   0E17 DA            push d
1637   0E18 FA FF FF      lea d, [bp + -1] ; $p
1638   0E1B 2A            mov b, [d]
1639   0E1C 38 00 00      mov c, 0
1640   0E1F             ; --- START TERMS
1641   0E1F D7            push a
1642   0E20 11            mov a, b
1643   0E21 FD 2E 02 00   mov32 cb, $00000002
1643   0E25 00 00 
1644   0E27 56            add b, a
1645   0E28 E4            pop a
1646   0E29             ; --- END TERMS
1647   0E29 E7            pop d
1648   0E2A FD 43         mov [d], b
1649   0E2C             ; break; 
1650   0E2C 0A C4 0E      jmp _switch20_exit ; case break
1651   0E2F             _switch20_case6:
1652   0E2F             ; c = getchar(); 
1653   0E2F FA FC FF      lea d, [bp + -4] ; $c
1654   0E32 DA            push d
1655   0E33             ; --- START FUNCTION CALL
1656   0E33 07 B3 1C      call getchar
1657   0E36 E7            pop d
1658   0E37 FD 3E         mov [d], bl
1659   0E39             ; **(char **)p = *(char *)c; 
1660   0E39 FA FF FF      lea d, [bp + -1] ; $p
1661   0E3C 2A            mov b, [d]
1662   0E3D 38 00 00      mov c, 0
1663   0E40 74            mov d, b
1664   0E41 2A            mov b, [d]
1665   0E42 D8            push b
1666   0E43 FA FC FF      lea d, [bp + -4] ; $c
1667   0E46 32            mov bl, [d]
1668   0E47 A7 00         mov bh, 0
1669   0E49 38 00 00      mov c, 0
1670   0E4C 74            mov d, b
1671   0E4D 32            mov bl, [d]
1672   0E4E A7 00         mov bh, 0
1673   0E50 38 00 00      mov c, 0
1674   0E53 E7            pop d
1675   0E54 FD 43         mov [d], b
1676   0E56             ; p = p + 1; 
1677   0E56 FA FF FF      lea d, [bp + -1] ; $p
1678   0E59 DA            push d
1679   0E5A FA FF FF      lea d, [bp + -1] ; $p
1680   0E5D 2A            mov b, [d]
1681   0E5E 38 00 00      mov c, 0
1682   0E61             ; --- START TERMS
1683   0E61 D7            push a
1684   0E62 11            mov a, b
1685   0E63 FD 2E 01 00   mov32 cb, $00000001
1685   0E67 00 00 
1686   0E69 56            add b, a
1687   0E6A E4            pop a
1688   0E6B             ; --- END TERMS
1689   0E6B E7            pop d
1690   0E6C FD 43         mov [d], b
1691   0E6E             ; break; 
1692   0E6E 0A C4 0E      jmp _switch20_exit ; case break
1693   0E71             _switch20_case7:
1694   0E71             ; gets(input_string); 
1695   0E71             ; --- START FUNCTION CALL
1696   0E71 FA FA FD      lea d, [bp + -518] ; $input_string
1697   0E74 2D            mov b, d
1698   0E75 38 00 00      mov c, 0
1699   0E78 FD AB         swp b
1700   0E7A D8            push b
1701   0E7B 07 A5 14      call gets
1702   0E7E 51 02 00      add sp, 2
1703   0E81             ; --- END FUNCTION CALL
1704   0E81             ; strcpy(*(char **)p, input_string); 
1705   0E81             ; --- START FUNCTION CALL
1706   0E81 FA FA FD      lea d, [bp + -518] ; $input_string
1707   0E84 2D            mov b, d
1708   0E85 38 00 00      mov c, 0
1709   0E88 FD AB         swp b
1710   0E8A D8            push b
1711   0E8B FA FF FF      lea d, [bp + -1] ; $p
1712   0E8E 2A            mov b, [d]
1713   0E8F 38 00 00      mov c, 0
1714   0E92 74            mov d, b
1715   0E93 2A            mov b, [d]
1716   0E94 FD AB         swp b
1717   0E96 D8            push b
1718   0E97 07 12 04      call strcpy
1719   0E9A 51 04 00      add sp, 4
1720   0E9D             ; --- END FUNCTION CALL
1721   0E9D             ; p = p + 2; 
1722   0E9D FA FF FF      lea d, [bp + -1] ; $p
1723   0EA0 DA            push d
1724   0EA1 FA FF FF      lea d, [bp + -1] ; $p
1725   0EA4 2A            mov b, [d]
1726   0EA5 38 00 00      mov c, 0
1727   0EA8             ; --- START TERMS
1728   0EA8 D7            push a
1729   0EA9 11            mov a, b
1730   0EAA FD 2E 02 00   mov32 cb, $00000002
1730   0EAE 00 00 
1731   0EB0 56            add b, a
1732   0EB1 E4            pop a
1733   0EB2             ; --- END TERMS
1734   0EB2 E7            pop d
1735   0EB3 FD 43         mov [d], b
1736   0EB5             ; break; 
1737   0EB5 0A C4 0E      jmp _switch20_exit ; case break
1738   0EB8             _switch20_default:
1739   0EB8             ; print("Error: Unknown argument type.\n"); 
1740   0EB8             ; --- START FUNCTION CALL
1741   0EB8 26 76 21      mov b, _s1 ; "Error: Unknown argument type.\n"
1742   0EBB FD AB         swp b
1743   0EBD D8            push b
1744   0EBE 07 F4 1C      call print
1745   0EC1 51 02 00      add sp, 2
1746   0EC4             ; --- END FUNCTION CALL
1747   0EC4             _switch20_exit:
1748   0EC4             ; format_p++; 
1749   0EC4 FA FD FF      lea d, [bp + -3] ; $format_p
1750   0EC7 2A            mov b, [d]
1751   0EC8 38 00 00      mov c, 0
1752   0ECB FD 77         inc b
1753   0ECD FA FD FF      lea d, [bp + -3] ; $format_p
1754   0ED0 FD 43         mov [d], b
1755   0ED2 FD 7D         dec b
1756   0ED4 0A FC 0E      jmp _if19_exit
1757   0ED7             _if19_else:
1758   0ED7             ; putchar(*format_p); 
1759   0ED7             ; --- START FUNCTION CALL
1760   0ED7 FA FD FF      lea d, [bp + -3] ; $format_p
1761   0EDA 2A            mov b, [d]
1762   0EDB 38 00 00      mov c, 0
1763   0EDE 74            mov d, b
1764   0EDF 32            mov bl, [d]
1765   0EE0 A7 00         mov bh, 0
1766   0EE2 38 00 00      mov c, 0
1767   0EE5 DD            push bl
1768   0EE6 07 A6 1C      call putchar
1769   0EE9 51 01 00      add sp, 1
1770   0EEC             ; --- END FUNCTION CALL
1771   0EEC             ; format_p++; 
1772   0EEC FA FD FF      lea d, [bp + -3] ; $format_p
1773   0EEF 2A            mov b, [d]
1774   0EF0 38 00 00      mov c, 0
1775   0EF3 FD 77         inc b
1776   0EF5 FA FD FF      lea d, [bp + -3] ; $format_p
1777   0EF8 FD 43         mov [d], b
1778   0EFA FD 7D         dec b
1779   0EFC             _if19_exit:
1780   0EFC             _if18_exit:
1781   0EFC             _for17_update:
1782   0EFC 0A 58 0C      jmp _for17_cond
1783   0EFF             _for17_exit:
1784   0EFF F9            leave
1785   0F00 09            ret
1786   0F01             
1787   0F01             sprintf:
1788   0F01 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1789   0F04             ; char *p, *format_p; 
1790   0F04 52 02 00      sub sp, 2
1791   0F07 52 02 00      sub sp, 2
1792   0F0A             ; char *sp; 
1793   0F0A 52 02 00      sub sp, 2
1794   0F0D             ; sp = dest; 
1795   0F0D FA FB FF      lea d, [bp + -5] ; $sp
1796   0F10 DA            push d
1797   0F11 FA 05 00      lea d, [bp + 5] ; $dest
1798   0F14 2A            mov b, [d]
1799   0F15 38 00 00      mov c, 0
1800   0F18 E7            pop d
1801   0F19 FD 43         mov [d], b
1802   0F1B             ; format_p = format; 
1803   0F1B FA FD FF      lea d, [bp + -3] ; $format_p
1804   0F1E DA            push d
1805   0F1F FA 07 00      lea d, [bp + 7] ; $format
1806   0F22 2A            mov b, [d]
1807   0F23 38 00 00      mov c, 0
1808   0F26 E7            pop d
1809   0F27 FD 43         mov [d], b
1810   0F29             ; p = &format + 2; 
1811   0F29 FA FF FF      lea d, [bp + -1] ; $p
1812   0F2C DA            push d
1813   0F2D FA 07 00      lea d, [bp + 7] ; $format
1814   0F30 2D            mov b, d
1815   0F31             ; --- START TERMS
1816   0F31 D7            push a
1817   0F32 11            mov a, b
1818   0F33 FD 2E 02 00   mov32 cb, $00000002
1818   0F37 00 00 
1819   0F39 56            add b, a
1820   0F3A E4            pop a
1821   0F3B             ; --- END TERMS
1822   0F3B E7            pop d
1823   0F3C FD 43         mov [d], b
1824   0F3E             ; for(;;){ 
1825   0F3E             _for24_init:
1826   0F3E             _for24_cond:
1827   0F3E             _for24_block:
1828   0F3E             ; if(!*format_p) break; 
1829   0F3E             _if25_cond:
1830   0F3E FA FD FF      lea d, [bp + -3] ; $format_p
1831   0F41 2A            mov b, [d]
1832   0F42 38 00 00      mov c, 0
1833   0F45 74            mov d, b
1834   0F46 32            mov bl, [d]
1835   0F47 A7 00         mov bh, 0
1836   0F49 38 00 00      mov c, 0
1837   0F4C C0 00 00      cmp b, 0
1838   0F4F FD 71         seq ; !
1839   0F51 C0 00 00      cmp b, 0
1840   0F54 C6 5D 0F      je _if25_else
1841   0F57             _if25_true:
1842   0F57             ; break; 
1843   0F57 0A 93 12      jmp _for24_exit ; for break
1844   0F5A 0A 90 12      jmp _if25_exit
1845   0F5D             _if25_else:
1846   0F5D             ; if(*format_p == '%'){ 
1847   0F5D             _if26_cond:
1848   0F5D FA FD FF      lea d, [bp + -3] ; $format_p
1849   0F60 2A            mov b, [d]
1850   0F61 38 00 00      mov c, 0
1851   0F64 74            mov d, b
1852   0F65 32            mov bl, [d]
1853   0F66 A7 00         mov bh, 0
1854   0F68 38 00 00      mov c, 0
1855   0F6B             ; --- START RELATIONAL
1856   0F6B D7            push a
1857   0F6C 11            mov a, b
1858   0F6D FD 2E 25 00   mov32 cb, $00000025
1858   0F71 00 00 
1859   0F73 B0            cmp a, b
1860   0F74 FD 71         seq ; ==
1861   0F76 E4            pop a
1862   0F77             ; --- END RELATIONAL
1863   0F77 C0 00 00      cmp b, 0
1864   0F7A C6 65 12      je _if26_else
1865   0F7D             _if26_true:
1866   0F7D             ; format_p++; 
1867   0F7D FA FD FF      lea d, [bp + -3] ; $format_p
1868   0F80 2A            mov b, [d]
1869   0F81 38 00 00      mov c, 0
1870   0F84 FD 77         inc b
1871   0F86 FA FD FF      lea d, [bp + -3] ; $format_p
1872   0F89 FD 43         mov [d], b
1873   0F8B FD 7D         dec b
1874   0F8D             ; switch(*format_p){ 
1875   0F8D             _switch27_expr:
1876   0F8D FA FD FF      lea d, [bp + -3] ; $format_p
1877   0F90 2A            mov b, [d]
1878   0F91 38 00 00      mov c, 0
1879   0F94 74            mov d, b
1880   0F95 32            mov bl, [d]
1881   0F96 A7 00         mov bh, 0
1882   0F98 38 00 00      mov c, 0
1883   0F9B             _switch27_comparisons:
1884   0F9B C1 6C         cmp bl, $6c
1885   0F9D C6 C9 0F      je _switch27_case0
1886   0FA0 C1 4C         cmp bl, $4c
1887   0FA2 C6 C9 0F      je _switch27_case1
1888   0FA5 C1 64         cmp bl, $64
1889   0FA7 C6 E1 10      je _switch27_case2
1890   0FAA C1 69         cmp bl, $69
1891   0FAC C6 E1 10      je _switch27_case3
1892   0FAF C1 75         cmp bl, $75
1893   0FB1 C6 2D 11      je _switch27_case4
1894   0FB4 C1 78         cmp bl, $78
1895   0FB6 C6 79 11      je _switch27_case5
1896   0FB9 C1 63         cmp bl, $63
1897   0FBB C6 9D 11      je _switch27_case6
1898   0FBE C1 73         cmp bl, $73
1899   0FC0 C6 DA 11      je _switch27_case7
1900   0FC3 0A 46 12      jmp _switch27_default
1901   0FC6 0A 52 12      jmp _switch27_exit
1902   0FC9             _switch27_case0:
1903   0FC9             _switch27_case1:
1904   0FC9             ; format_p++; 
1905   0FC9 FA FD FF      lea d, [bp + -3] ; $format_p
1906   0FCC 2A            mov b, [d]
1907   0FCD 38 00 00      mov c, 0
1908   0FD0 FD 77         inc b
1909   0FD2 FA FD FF      lea d, [bp + -3] ; $format_p
1910   0FD5 FD 43         mov [d], b
1911   0FD7 FD 7D         dec b
1912   0FD9             ; if(*format_p == 'd' || *format_p == 'i') 
1913   0FD9             _if28_cond:
1914   0FD9 FA FD FF      lea d, [bp + -3] ; $format_p
1915   0FDC 2A            mov b, [d]
1916   0FDD 38 00 00      mov c, 0
1917   0FE0 74            mov d, b
1918   0FE1 32            mov bl, [d]
1919   0FE2 A7 00         mov bh, 0
1920   0FE4 38 00 00      mov c, 0
1921   0FE7             ; --- START RELATIONAL
1922   0FE7 D7            push a
1923   0FE8 11            mov a, b
1924   0FE9 FD 2E 64 00   mov32 cb, $00000064
1924   0FED 00 00 
1925   0FEF B0            cmp a, b
1926   0FF0 FD 71         seq ; ==
1927   0FF2 E4            pop a
1928   0FF3             ; --- END RELATIONAL
1929   0FF3             ; --- START LOGICAL OR
1930   0FF3 D7            push a
1931   0FF4 11            mov a, b
1932   0FF5 FA FD FF      lea d, [bp + -3] ; $format_p
1933   0FF8 2A            mov b, [d]
1934   0FF9 38 00 00      mov c, 0
1935   0FFC 74            mov d, b
1936   0FFD 32            mov bl, [d]
1937   0FFE A7 00         mov bh, 0
1938   1000 38 00 00      mov c, 0
1939   1003             ; --- START RELATIONAL
1940   1003 D7            push a
1941   1004 11            mov a, b
1942   1005 FD 2E 69 00   mov32 cb, $00000069
1942   1009 00 00 
1943   100B B0            cmp a, b
1944   100C FD 71         seq ; ==
1945   100E E4            pop a
1946   100F             ; --- END RELATIONAL
1947   100F FD A8         sor a, b ; ||
1948   1011 E4            pop a
1949   1012             ; --- END LOGICAL OR
1950   1012 C0 00 00      cmp b, 0
1951   1015 C6 39 10      je _if28_else
1952   1018             _if28_true:
1953   1018             ; print_signed_long(*(long *)p); 
1954   1018             ; --- START FUNCTION CALL
1955   1018 FA FF FF      lea d, [bp + -1] ; $p
1956   101B 2A            mov b, [d]
1957   101C 38 00 00      mov c, 0
1958   101F AB            snex b
1959   1020 FD 39         mov c, b
1960   1022 74            mov d, b
1961   1023 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1962   1026 FD 39         mov c, b ; And place it into C
1963   1028 2A            mov b, [d] ; Lower Word in B
1964   1029 12            mov a, c
1965   102A FD AA         swp a
1966   102C D7            push a
1967   102D FD AB         swp b
1968   102F D8            push b
1969   1030 07 FB 15      call print_signed_long
1970   1033 51 04 00      add sp, 4
1971   1036             ; --- END FUNCTION CALL
1972   1036 0A C6 10      jmp _if28_exit
1973   1039             _if28_else:
1974   1039             ; if(*format_p == 'u') 
1975   1039             _if29_cond:
1976   1039 FA FD FF      lea d, [bp + -3] ; $format_p
1977   103C 2A            mov b, [d]
1978   103D 38 00 00      mov c, 0
1979   1040 74            mov d, b
1980   1041 32            mov bl, [d]
1981   1042 A7 00         mov bh, 0
1982   1044 38 00 00      mov c, 0
1983   1047             ; --- START RELATIONAL
1984   1047 D7            push a
1985   1048 11            mov a, b
1986   1049 FD 2E 75 00   mov32 cb, $00000075
1986   104D 00 00 
1987   104F B0            cmp a, b
1988   1050 FD 71         seq ; ==
1989   1052 E4            pop a
1990   1053             ; --- END RELATIONAL
1991   1053 C0 00 00      cmp b, 0
1992   1056 C6 7C 10      je _if29_else
1993   1059             _if29_true:
1994   1059             ; print_unsigned_long(*(unsigned long *)p); 
1995   1059             ; --- START FUNCTION CALL
1996   1059 FA FF FF      lea d, [bp + -1] ; $p
1997   105C 2A            mov b, [d]
1998   105D 38 00 00      mov c, 0
1999   1060 A7 00         mov bh, 0
2000   1062 38 00 00      mov c, 0
2001   1065 74            mov d, b
2002   1066 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2003   1069 FD 39         mov c, b ; And place it into C
2004   106B 2A            mov b, [d] ; Lower Word in B
2005   106C 12            mov a, c
2006   106D FD AA         swp a
2007   106F D7            push a
2008   1070 FD AB         swp b
2009   1072 D8            push b
2010   1073 07 6A 17      call print_unsigned_long
2011   1076 51 04 00      add sp, 4
2012   1079             ; --- END FUNCTION CALL
2013   1079 0A C6 10      jmp _if29_exit
2014   107C             _if29_else:
2015   107C             ; if(*format_p == 'x') 
2016   107C             _if30_cond:
2017   107C FA FD FF      lea d, [bp + -3] ; $format_p
2018   107F 2A            mov b, [d]
2019   1080 38 00 00      mov c, 0
2020   1083 74            mov d, b
2021   1084 32            mov bl, [d]
2022   1085 A7 00         mov bh, 0
2023   1087 38 00 00      mov c, 0
2024   108A             ; --- START RELATIONAL
2025   108A D7            push a
2026   108B 11            mov a, b
2027   108C FD 2E 78 00   mov32 cb, $00000078
2027   1090 00 00 
2028   1092 B0            cmp a, b
2029   1093 FD 71         seq ; ==
2030   1095 E4            pop a
2031   1096             ; --- END RELATIONAL
2032   1096 C0 00 00      cmp b, 0
2033   1099 C6 BA 10      je _if30_else
2034   109C             _if30_true:
2035   109C             ; printx32(*(long int *)p); 
2036   109C             ; --- START FUNCTION CALL
2037   109C FA FF FF      lea d, [bp + -1] ; $p
2038   109F 2A            mov b, [d]
2039   10A0 38 00 00      mov c, 0
2040   10A3 74            mov d, b
2041   10A4 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2042   10A7 FD 39         mov c, b ; And place it into C
2043   10A9 2A            mov b, [d] ; Lower Word in B
2044   10AA 12            mov a, c
2045   10AB FD AA         swp a
2046   10AD D7            push a
2047   10AE FD AB         swp b
2048   10B0 D8            push b
2049   10B1 07 CE 12      call printx32
2050   10B4 51 04 00      add sp, 4
2051   10B7             ; --- END FUNCTION CALL
2052   10B7 0A C6 10      jmp _if30_exit
2053   10BA             _if30_else:
2054   10BA             ; err("Unexpected format in printf."); 
2055   10BA             ; --- START FUNCTION CALL
2056   10BA 26 59 21      mov b, _s0 ; "Unexpected format in printf."
2057   10BD FD AB         swp b
2058   10BF D8            push b
2059   10C0 07 B9 12      call err
2060   10C3 51 02 00      add sp, 2
2061   10C6             ; --- END FUNCTION CALL
2062   10C6             _if30_exit:
2063   10C6             _if29_exit:
2064   10C6             _if28_exit:
2065   10C6             ; p = p + 4; 
2066   10C6 FA FF FF      lea d, [bp + -1] ; $p
2067   10C9 DA            push d
2068   10CA FA FF FF      lea d, [bp + -1] ; $p
2069   10CD 2A            mov b, [d]
2070   10CE 38 00 00      mov c, 0
2071   10D1             ; --- START TERMS
2072   10D1 D7            push a
2073   10D2 11            mov a, b
2074   10D3 FD 2E 04 00   mov32 cb, $00000004
2074   10D7 00 00 
2075   10D9 56            add b, a
2076   10DA E4            pop a
2077   10DB             ; --- END TERMS
2078   10DB E7            pop d
2079   10DC FD 43         mov [d], b
2080   10DE             ; break; 
2081   10DE 0A 52 12      jmp _switch27_exit ; case break
2082   10E1             _switch27_case2:
2083   10E1             _switch27_case3:
2084   10E1             ; sp = sp + sprint_signed(sp, *(int*)p); 
2085   10E1 FA FB FF      lea d, [bp + -5] ; $sp
2086   10E4 DA            push d
2087   10E5 FA FB FF      lea d, [bp + -5] ; $sp
2088   10E8 2A            mov b, [d]
2089   10E9 38 00 00      mov c, 0
2090   10EC             ; --- START TERMS
2091   10EC D7            push a
2092   10ED 11            mov a, b
2093   10EE             ; --- START FUNCTION CALL
2094   10EE FA FF FF      lea d, [bp + -1] ; $p
2095   10F1 2A            mov b, [d]
2096   10F2 38 00 00      mov c, 0
2097   10F5 74            mov d, b
2098   10F6 2A            mov b, [d]
2099   10F7 38 00 00      mov c, 0
2100   10FA FD AB         swp b
2101   10FC D8            push b
2102   10FD FA FB FF      lea d, [bp + -5] ; $sp
2103   1100 2A            mov b, [d]
2104   1101 38 00 00      mov c, 0
2105   1104 FD AB         swp b
2106   1106 D8            push b
2107   1107 07 DE 1A      call sprint_signed
2108   110A 51 04 00      add sp, 4
2109   110D             ; --- END FUNCTION CALL
2110   110D 56            add b, a
2111   110E E4            pop a
2112   110F             ; --- END TERMS
2113   110F E7            pop d
2114   1110 FD 43         mov [d], b
2115   1112             ; p = p + 2; 
2116   1112 FA FF FF      lea d, [bp + -1] ; $p
2117   1115 DA            push d
2118   1116 FA FF FF      lea d, [bp + -1] ; $p
2119   1119 2A            mov b, [d]
2120   111A 38 00 00      mov c, 0
2121   111D             ; --- START TERMS
2122   111D D7            push a
2123   111E 11            mov a, b
2124   111F FD 2E 02 00   mov32 cb, $00000002
2124   1123 00 00 
2125   1125 56            add b, a
2126   1126 E4            pop a
2127   1127             ; --- END TERMS
2128   1127 E7            pop d
2129   1128 FD 43         mov [d], b
2130   112A             ; break; 
2131   112A 0A 52 12      jmp _switch27_exit ; case break
2132   112D             _switch27_case4:
2133   112D             ; sp = sp + sprint_unsigned(sp, *(unsigned int*)p); 
2134   112D FA FB FF      lea d, [bp + -5] ; $sp
2135   1130 DA            push d
2136   1131 FA FB FF      lea d, [bp + -5] ; $sp
2137   1134 2A            mov b, [d]
2138   1135 38 00 00      mov c, 0
2139   1138             ; --- START TERMS
2140   1138 D7            push a
2141   1139 11            mov a, b
2142   113A             ; --- START FUNCTION CALL
2143   113A FA FF FF      lea d, [bp + -1] ; $p
2144   113D 2A            mov b, [d]
2145   113E 38 00 00      mov c, 0
2146   1141 74            mov d, b
2147   1142 2A            mov b, [d]
2148   1143 38 00 00      mov c, 0
2149   1146 FD AB         swp b
2150   1148 D8            push b
2151   1149 FA FB FF      lea d, [bp + -5] ; $sp
2152   114C 2A            mov b, [d]
2153   114D 38 00 00      mov c, 0
2154   1150 FD AB         swp b
2155   1152 D8            push b
2156   1153 07 86 18      call sprint_unsigned
2157   1156 51 04 00      add sp, 4
2158   1159             ; --- END FUNCTION CALL
2159   1159 56            add b, a
2160   115A E4            pop a
2161   115B             ; --- END TERMS
2162   115B E7            pop d
2163   115C FD 43         mov [d], b
2164   115E             ; p = p + 2; 
2165   115E FA FF FF      lea d, [bp + -1] ; $p
2166   1161 DA            push d
2167   1162 FA FF FF      lea d, [bp + -1] ; $p
2168   1165 2A            mov b, [d]
2169   1166 38 00 00      mov c, 0
2170   1169             ; --- START TERMS
2171   1169 D7            push a
2172   116A 11            mov a, b
2173   116B FD 2E 02 00   mov32 cb, $00000002
2173   116F 00 00 
2174   1171 56            add b, a
2175   1172 E4            pop a
2176   1173             ; --- END TERMS
2177   1173 E7            pop d
2178   1174 FD 43         mov [d], b
2179   1176             ; break; 
2180   1176 0A 52 12      jmp _switch27_exit ; case break
2181   1179             _switch27_case5:
2182   1179             
2183   1179             ; --- BEGIN INLINE ASM SEGMENT
2184   1179 FA FF FF      lea d, [bp + -1] ; $p
2185   117C FD 2A         mov d, [d]
2186   117E 2A            mov b, [d]
2187   117F 07 57 20      call print_u16x
2188   1182             ; --- END INLINE ASM SEGMENT
2189   1182             
2190   1182             ; p = p + 2; 
2191   1182 FA FF FF      lea d, [bp + -1] ; $p
2192   1185 DA            push d
2193   1186 FA FF FF      lea d, [bp + -1] ; $p
2194   1189 2A            mov b, [d]
2195   118A 38 00 00      mov c, 0
2196   118D             ; --- START TERMS
2197   118D D7            push a
2198   118E 11            mov a, b
2199   118F FD 2E 02 00   mov32 cb, $00000002
2199   1193 00 00 
2200   1195 56            add b, a
2201   1196 E4            pop a
2202   1197             ; --- END TERMS
2203   1197 E7            pop d
2204   1198 FD 43         mov [d], b
2205   119A             ; break; 
2206   119A 0A 52 12      jmp _switch27_exit ; case break
2207   119D             _switch27_case6:
2208   119D             ; *sp++ = *(char *)p; 
2209   119D FA FB FF      lea d, [bp + -5] ; $sp
2210   11A0 2A            mov b, [d]
2211   11A1 38 00 00      mov c, 0
2212   11A4 FD 77         inc b
2213   11A6 FA FB FF      lea d, [bp + -5] ; $sp
2214   11A9 FD 43         mov [d], b
2215   11AB FD 7D         dec b
2216   11AD D8            push b
2217   11AE FA FF FF      lea d, [bp + -1] ; $p
2218   11B1 2A            mov b, [d]
2219   11B2 38 00 00      mov c, 0
2220   11B5 74            mov d, b
2221   11B6 32            mov bl, [d]
2222   11B7 A7 00         mov bh, 0
2223   11B9 38 00 00      mov c, 0
2224   11BC E7            pop d
2225   11BD FD 3E         mov [d], bl
2226   11BF             ; p = p + 1; 
2227   11BF FA FF FF      lea d, [bp + -1] ; $p
2228   11C2 DA            push d
2229   11C3 FA FF FF      lea d, [bp + -1] ; $p
2230   11C6 2A            mov b, [d]
2231   11C7 38 00 00      mov c, 0
2232   11CA             ; --- START TERMS
2233   11CA D7            push a
2234   11CB 11            mov a, b
2235   11CC FD 2E 01 00   mov32 cb, $00000001
2235   11D0 00 00 
2236   11D2 56            add b, a
2237   11D3 E4            pop a
2238   11D4             ; --- END TERMS
2239   11D4 E7            pop d
2240   11D5 FD 43         mov [d], b
2241   11D7             ; break; 
2242   11D7 0A 52 12      jmp _switch27_exit ; case break
2243   11DA             _switch27_case7:
2244   11DA             ; int len = strlen(*(char **)p); 
2245   11DA 52 02 00      sub sp, 2
2246   11DD             ; --- START LOCAL VAR INITIALIZATION
2247   11DD FA F9 FF      lea d, [bp + -7] ; $len
2248   11E0 DA            push d
2249   11E1             ; --- START FUNCTION CALL
2250   11E1 FA FF FF      lea d, [bp + -1] ; $p
2251   11E4 2A            mov b, [d]
2252   11E5 38 00 00      mov c, 0
2253   11E8 74            mov d, b
2254   11E9 2A            mov b, [d]
2255   11EA FD AB         swp b
2256   11EC D8            push b
2257   11ED 07 F8 05      call strlen
2258   11F0 51 02 00      add sp, 2
2259   11F3             ; --- END FUNCTION CALL
2260   11F3 E7            pop d
2261   11F4 FD 43         mov [d], b
2262   11F6             ; --- END LOCAL VAR INITIALIZATION
2263   11F6             ; strcpy(sp, *(char **)p); 
2264   11F6             ; --- START FUNCTION CALL
2265   11F6 FA FF FF      lea d, [bp + -1] ; $p
2266   11F9 2A            mov b, [d]
2267   11FA 38 00 00      mov c, 0
2268   11FD 74            mov d, b
2269   11FE 2A            mov b, [d]
2270   11FF FD AB         swp b
2271   1201 D8            push b
2272   1202 FA FB FF      lea d, [bp + -5] ; $sp
2273   1205 2A            mov b, [d]
2274   1206 38 00 00      mov c, 0
2275   1209 FD AB         swp b
2276   120B D8            push b
2277   120C 07 12 04      call strcpy
2278   120F 51 04 00      add sp, 4
2279   1212             ; --- END FUNCTION CALL
2280   1212             ; sp = sp + len; 
2281   1212 FA FB FF      lea d, [bp + -5] ; $sp
2282   1215 DA            push d
2283   1216 FA FB FF      lea d, [bp + -5] ; $sp
2284   1219 2A            mov b, [d]
2285   121A 38 00 00      mov c, 0
2286   121D             ; --- START TERMS
2287   121D D7            push a
2288   121E 11            mov a, b
2289   121F FA F9 FF      lea d, [bp + -7] ; $len
2290   1222 2A            mov b, [d]
2291   1223 38 00 00      mov c, 0
2292   1226 56            add b, a
2293   1227 E4            pop a
2294   1228             ; --- END TERMS
2295   1228 E7            pop d
2296   1229 FD 43         mov [d], b
2297   122B             ; p = p + 2; 
2298   122B FA FF FF      lea d, [bp + -1] ; $p
2299   122E DA            push d
2300   122F FA FF FF      lea d, [bp + -1] ; $p
2301   1232 2A            mov b, [d]
2302   1233 38 00 00      mov c, 0
2303   1236             ; --- START TERMS
2304   1236 D7            push a
2305   1237 11            mov a, b
2306   1238 FD 2E 02 00   mov32 cb, $00000002
2306   123C 00 00 
2307   123E 56            add b, a
2308   123F E4            pop a
2309   1240             ; --- END TERMS
2310   1240 E7            pop d
2311   1241 FD 43         mov [d], b
2312   1243             ; break; 
2313   1243 0A 52 12      jmp _switch27_exit ; case break
2314   1246             _switch27_default:
2315   1246             ; print("Error: Unknown argument type.\n"); 
2316   1246             ; --- START FUNCTION CALL
2317   1246 26 76 21      mov b, _s1 ; "Error: Unknown argument type.\n"
2318   1249 FD AB         swp b
2319   124B D8            push b
2320   124C 07 F4 1C      call print
2321   124F 51 02 00      add sp, 2
2322   1252             ; --- END FUNCTION CALL
2323   1252             _switch27_exit:
2324   1252             ; format_p++; 
2325   1252 FA FD FF      lea d, [bp + -3] ; $format_p
2326   1255 2A            mov b, [d]
2327   1256 38 00 00      mov c, 0
2328   1259 FD 77         inc b
2329   125B FA FD FF      lea d, [bp + -3] ; $format_p
2330   125E FD 43         mov [d], b
2331   1260 FD 7D         dec b
2332   1262 0A 90 12      jmp _if26_exit
2333   1265             _if26_else:
2334   1265             ; *sp++ = *format_p++; 
2335   1265 FA FB FF      lea d, [bp + -5] ; $sp
2336   1268 2A            mov b, [d]
2337   1269 38 00 00      mov c, 0
2338   126C FD 77         inc b
2339   126E FA FB FF      lea d, [bp + -5] ; $sp
2340   1271 FD 43         mov [d], b
2341   1273 FD 7D         dec b
2342   1275 D8            push b
2343   1276 FA FD FF      lea d, [bp + -3] ; $format_p
2344   1279 2A            mov b, [d]
2345   127A 38 00 00      mov c, 0
2346   127D FD 77         inc b
2347   127F FA FD FF      lea d, [bp + -3] ; $format_p
2348   1282 FD 43         mov [d], b
2349   1284 FD 7D         dec b
2350   1286 74            mov d, b
2351   1287 32            mov bl, [d]
2352   1288 A7 00         mov bh, 0
2353   128A 38 00 00      mov c, 0
2354   128D E7            pop d
2355   128E FD 3E         mov [d], bl
2356   1290             _if26_exit:
2357   1290             _if25_exit:
2358   1290             _for24_update:
2359   1290 0A 3E 0F      jmp _for24_cond
2360   1293             _for24_exit:
2361   1293             ; *sp = '\0'; 
2362   1293 FA FB FF      lea d, [bp + -5] ; $sp
2363   1296 2A            mov b, [d]
2364   1297 38 00 00      mov c, 0
2365   129A D8            push b
2366   129B FD 2E 00 00   mov32 cb, $00000000
2366   129F 00 00 
2367   12A1 E7            pop d
2368   12A2 FD 3E         mov [d], bl
2369   12A4             ; return sp - dest; // return total number of chars written 
2370   12A4 FA FB FF      lea d, [bp + -5] ; $sp
2371   12A7 2A            mov b, [d]
2372   12A8 38 00 00      mov c, 0
2373   12AB             ; --- START TERMS
2374   12AB D7            push a
2375   12AC 11            mov a, b
2376   12AD FA 05 00      lea d, [bp + 5] ; $dest
2377   12B0 2A            mov b, [d]
2378   12B1 38 00 00      mov c, 0
2379   12B4 60            sub a, b
2380   12B5 27            mov b, a
2381   12B6 E4            pop a
2382   12B7             ; --- END TERMS
2383   12B7 F9            leave
2384   12B8 09            ret
2385   12B9             
2386   12B9             err:
2387   12B9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2388   12BC             ; print(e); 
2389   12BC             ; --- START FUNCTION CALL
2390   12BC FA 05 00      lea d, [bp + 5] ; $e
2391   12BF 2A            mov b, [d]
2392   12C0 38 00 00      mov c, 0
2393   12C3 FD AB         swp b
2394   12C5 D8            push b
2395   12C6 07 F4 1C      call print
2396   12C9 51 02 00      add sp, 2
2397   12CC             ; --- END FUNCTION CALL
2398   12CC F9            leave
2399   12CD 09            ret
2400   12CE             
2401   12CE             printx32:
2402   12CE F8 00 00      enter 0 ; (push bp; mov bp, sp)
2403   12D1             
2404   12D1             ; --- BEGIN INLINE ASM SEGMENT
2405   12D1 FA 05 00      lea d, [bp + 5] ; $hex
2406   12D4 2B 02 00      mov b, [d+2]
2407   12D7 07 57 20      call print_u16x
2408   12DA 2A            mov b, [d]
2409   12DB 07 57 20      call print_u16x
2410   12DE             ; --- END INLINE ASM SEGMENT
2411   12DE             
2412   12DE F9            leave
2413   12DF 09            ret
2414   12E0             
2415   12E0             printx16:
2416   12E0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2417   12E3             
2418   12E3             ; --- BEGIN INLINE ASM SEGMENT
2419   12E3 FA 05 00      lea d, [bp + 5] ; $hex
2420   12E6 2A            mov b, [d]
2421   12E7 07 57 20      call print_u16x
2422   12EA             ; --- END INLINE ASM SEGMENT
2423   12EA             
2424   12EA F9            leave
2425   12EB 09            ret
2426   12EC             
2427   12EC             printx8:
2428   12EC F8 00 00      enter 0 ; (push bp; mov bp, sp)
2429   12EF             
2430   12EF             ; --- BEGIN INLINE ASM SEGMENT
2431   12EF FA 05 00      lea d, [bp + 5] ; $hex
2432   12F2 32            mov bl, [d]
2433   12F3 07 9B 20      call print_u8x
2434   12F6             ; --- END INLINE ASM SEGMENT
2435   12F6             
2436   12F6 F9            leave
2437   12F7 09            ret
2438   12F8             
2439   12F8             hex_str_to_int:
2440   12F8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2441   12FB             ; int value = 0; 
2442   12FB 52 02 00      sub sp, 2
2443   12FE             ; --- START LOCAL VAR INITIALIZATION
2444   12FE FA FF FF      lea d, [bp + -1] ; $value
2445   1301 DA            push d
2446   1302 FD 2E 00 00   mov32 cb, $00000000
2446   1306 00 00 
2447   1308 E7            pop d
2448   1309 FD 43         mov [d], b
2449   130B             ; --- END LOCAL VAR INITIALIZATION
2450   130B             ; int i; 
2451   130B 52 02 00      sub sp, 2
2452   130E             ; char hex_char; 
2453   130E 52 01 00      sub sp, 1
2454   1311             ; int len; 
2455   1311 52 02 00      sub sp, 2
2456   1314             ; len = strlen(hex_string); 
2457   1314 FA FA FF      lea d, [bp + -6] ; $len
2458   1317 DA            push d
2459   1318             ; --- START FUNCTION CALL
2460   1318 FA 05 00      lea d, [bp + 5] ; $hex_string
2461   131B 2A            mov b, [d]
2462   131C 38 00 00      mov c, 0
2463   131F FD AB         swp b
2464   1321 D8            push b
2465   1322 07 F8 05      call strlen
2466   1325 51 02 00      add sp, 2
2467   1328             ; --- END FUNCTION CALL
2468   1328 E7            pop d
2469   1329 FD 43         mov [d], b
2470   132B             ; for (i = 0; i < len; i++) { 
2471   132B             _for31_init:
2472   132B FA FD FF      lea d, [bp + -3] ; $i
2473   132E DA            push d
2474   132F FD 2E 00 00   mov32 cb, $00000000
2474   1333 00 00 
2475   1335 E7            pop d
2476   1336 FD 43         mov [d], b
2477   1338             _for31_cond:
2478   1338 FA FD FF      lea d, [bp + -3] ; $i
2479   133B 2A            mov b, [d]
2480   133C 38 00 00      mov c, 0
2481   133F             ; --- START RELATIONAL
2482   133F D7            push a
2483   1340 11            mov a, b
2484   1341 FA FA FF      lea d, [bp + -6] ; $len
2485   1344 2A            mov b, [d]
2486   1345 38 00 00      mov c, 0
2487   1348 B0            cmp a, b
2488   1349 FD 73         slt ; < (signed)
2489   134B E4            pop a
2490   134C             ; --- END RELATIONAL
2491   134C C0 00 00      cmp b, 0
2492   134F C6 9C 14      je _for31_exit
2493   1352             _for31_block:
2494   1352             ; hex_char = hex_string[i]; 
2495   1352 FA FC FF      lea d, [bp + -4] ; $hex_char
2496   1355 DA            push d
2497   1356 FA 05 00      lea d, [bp + 5] ; $hex_string
2498   1359 FD 2A         mov d, [d]
2499   135B D7            push a
2500   135C DA            push d
2501   135D FA FD FF      lea d, [bp + -3] ; $i
2502   1360 2A            mov b, [d]
2503   1361 38 00 00      mov c, 0
2504   1364 E7            pop d
2505   1365 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
2506   1369 E4            pop a
2507   136A 32            mov bl, [d]
2508   136B A7 00         mov bh, 0
2509   136D 38 00 00      mov c, 0
2510   1370 E7            pop d
2511   1371 FD 3E         mov [d], bl
2512   1373             ; if (hex_char >= 'a' && hex_char <= 'f')  
2513   1373             _if32_cond:
2514   1373 FA FC FF      lea d, [bp + -4] ; $hex_char
2515   1376 32            mov bl, [d]
2516   1377 A7 00         mov bh, 0
2517   1379 38 00 00      mov c, 0
2518   137C             ; --- START RELATIONAL
2519   137C D7            push a
2520   137D 11            mov a, b
2521   137E FD 2E 61 00   mov32 cb, $00000061
2521   1382 00 00 
2522   1384 B0            cmp a, b
2523   1385 FD 80         sge ; >=
2524   1387 E4            pop a
2525   1388             ; --- END RELATIONAL
2526   1388             ; --- START LOGICAL AND
2527   1388 D7            push a
2528   1389 11            mov a, b
2529   138A FA FC FF      lea d, [bp + -4] ; $hex_char
2530   138D 32            mov bl, [d]
2531   138E A7 00         mov bh, 0
2532   1390 38 00 00      mov c, 0
2533   1393             ; --- START RELATIONAL
2534   1393 D7            push a
2535   1394 11            mov a, b
2536   1395 FD 2E 66 00   mov32 cb, $00000066
2536   1399 00 00 
2537   139B B0            cmp a, b
2538   139C FD 74         sle ; <= (signed)
2539   139E E4            pop a
2540   139F             ; --- END RELATIONAL
2541   139F FD A7         sand a, b
2542   13A1 E4            pop a
2543   13A2             ; --- END LOGICAL AND
2544   13A2 C0 00 00      cmp b, 0
2545   13A5 C6 E5 13      je _if32_else
2546   13A8             _if32_true:
2547   13A8             ; value = (value * 16) + (hex_char - 'a' + 10); 
2548   13A8 FA FF FF      lea d, [bp + -1] ; $value
2549   13AB DA            push d
2550   13AC FA FF FF      lea d, [bp + -1] ; $value
2551   13AF 2A            mov b, [d]
2552   13B0 38 00 00      mov c, 0
2553   13B3             ; --- START FACTORS
2554   13B3 D7            push a
2555   13B4 11            mov a, b
2556   13B5 FD 2E 10 00   mov32 cb, $00000010
2556   13B9 00 00 
2557   13BB AC            mul a, b ; *
2558   13BC 11            mov a, b
2559   13BD 27            mov b, a
2560   13BE E4            pop a
2561   13BF             ; --- END FACTORS
2562   13BF             ; --- START TERMS
2563   13BF D7            push a
2564   13C0 11            mov a, b
2565   13C1 FA FC FF      lea d, [bp + -4] ; $hex_char
2566   13C4 32            mov bl, [d]
2567   13C5 A7 00         mov bh, 0
2568   13C7 38 00 00      mov c, 0
2569   13CA             ; --- START TERMS
2570   13CA D7            push a
2571   13CB 11            mov a, b
2572   13CC FD 2E 61 00   mov32 cb, $00000061
2572   13D0 00 00 
2573   13D2 60            sub a, b
2574   13D3 27            mov b, a
2575   13D4 11            mov a, b
2576   13D5 FD 2E 0A 00   mov32 cb, $0000000a
2576   13D9 00 00 
2577   13DB 56            add b, a
2578   13DC E4            pop a
2579   13DD             ; --- END TERMS
2580   13DD 56            add b, a
2581   13DE E4            pop a
2582   13DF             ; --- END TERMS
2583   13DF E7            pop d
2584   13E0 FD 43         mov [d], b
2585   13E2 0A 89 14      jmp _if32_exit
2586   13E5             _if32_else:
2587   13E5             ; if (hex_char >= 'A' && hex_char <= 'F')  
2588   13E5             _if33_cond:
2589   13E5 FA FC FF      lea d, [bp + -4] ; $hex_char
2590   13E8 32            mov bl, [d]
2591   13E9 A7 00         mov bh, 0
2592   13EB 38 00 00      mov c, 0
2593   13EE             ; --- START RELATIONAL
2594   13EE D7            push a
2595   13EF 11            mov a, b
2596   13F0 FD 2E 41 00   mov32 cb, $00000041
2596   13F4 00 00 
2597   13F6 B0            cmp a, b
2598   13F7 FD 80         sge ; >=
2599   13F9 E4            pop a
2600   13FA             ; --- END RELATIONAL
2601   13FA             ; --- START LOGICAL AND
2602   13FA D7            push a
2603   13FB 11            mov a, b
2604   13FC FA FC FF      lea d, [bp + -4] ; $hex_char
2605   13FF 32            mov bl, [d]
2606   1400 A7 00         mov bh, 0
2607   1402 38 00 00      mov c, 0
2608   1405             ; --- START RELATIONAL
2609   1405 D7            push a
2610   1406 11            mov a, b
2611   1407 FD 2E 46 00   mov32 cb, $00000046
2611   140B 00 00 
2612   140D B0            cmp a, b
2613   140E FD 74         sle ; <= (signed)
2614   1410 E4            pop a
2615   1411             ; --- END RELATIONAL
2616   1411 FD A7         sand a, b
2617   1413 E4            pop a
2618   1414             ; --- END LOGICAL AND
2619   1414 C0 00 00      cmp b, 0
2620   1417 C6 57 14      je _if33_else
2621   141A             _if33_true:
2622   141A             ; value = (value * 16) + (hex_char - 'A' + 10); 
2623   141A FA FF FF      lea d, [bp + -1] ; $value
2624   141D DA            push d
2625   141E FA FF FF      lea d, [bp + -1] ; $value
2626   1421 2A            mov b, [d]
2627   1422 38 00 00      mov c, 0
2628   1425             ; --- START FACTORS
2629   1425 D7            push a
2630   1426 11            mov a, b
2631   1427 FD 2E 10 00   mov32 cb, $00000010
2631   142B 00 00 
2632   142D AC            mul a, b ; *
2633   142E 11            mov a, b
2634   142F 27            mov b, a
2635   1430 E4            pop a
2636   1431             ; --- END FACTORS
2637   1431             ; --- START TERMS
2638   1431 D7            push a
2639   1432 11            mov a, b
2640   1433 FA FC FF      lea d, [bp + -4] ; $hex_char
2641   1436 32            mov bl, [d]
2642   1437 A7 00         mov bh, 0
2643   1439 38 00 00      mov c, 0
2644   143C             ; --- START TERMS
2645   143C D7            push a
2646   143D 11            mov a, b
2647   143E FD 2E 41 00   mov32 cb, $00000041
2647   1442 00 00 
2648   1444 60            sub a, b
2649   1445 27            mov b, a
2650   1446 11            mov a, b
2651   1447 FD 2E 0A 00   mov32 cb, $0000000a
2651   144B 00 00 
2652   144D 56            add b, a
2653   144E E4            pop a
2654   144F             ; --- END TERMS
2655   144F 56            add b, a
2656   1450 E4            pop a
2657   1451             ; --- END TERMS
2658   1451 E7            pop d
2659   1452 FD 43         mov [d], b
2660   1454 0A 89 14      jmp _if33_exit
2661   1457             _if33_else:
2662   1457             ; value = (value * 16) + (hex_char - '0'); 
2663   1457 FA FF FF      lea d, [bp + -1] ; $value
2664   145A DA            push d
2665   145B FA FF FF      lea d, [bp + -1] ; $value
2666   145E 2A            mov b, [d]
2667   145F 38 00 00      mov c, 0
2668   1462             ; --- START FACTORS
2669   1462 D7            push a
2670   1463 11            mov a, b
2671   1464 FD 2E 10 00   mov32 cb, $00000010
2671   1468 00 00 
2672   146A AC            mul a, b ; *
2673   146B 11            mov a, b
2674   146C 27            mov b, a
2675   146D E4            pop a
2676   146E             ; --- END FACTORS
2677   146E             ; --- START TERMS
2678   146E D7            push a
2679   146F 11            mov a, b
2680   1470 FA FC FF      lea d, [bp + -4] ; $hex_char
2681   1473 32            mov bl, [d]
2682   1474 A7 00         mov bh, 0
2683   1476 38 00 00      mov c, 0
2684   1479             ; --- START TERMS
2685   1479 D7            push a
2686   147A 11            mov a, b
2687   147B FD 2E 30 00   mov32 cb, $00000030
2687   147F 00 00 
2688   1481 60            sub a, b
2689   1482 27            mov b, a
2690   1483 E4            pop a
2691   1484             ; --- END TERMS
2692   1484 56            add b, a
2693   1485 E4            pop a
2694   1486             ; --- END TERMS
2695   1486 E7            pop d
2696   1487 FD 43         mov [d], b
2697   1489             _if33_exit:
2698   1489             _if32_exit:
2699   1489             _for31_update:
2700   1489 FA FD FF      lea d, [bp + -3] ; $i
2701   148C 2A            mov b, [d]
2702   148D 38 00 00      mov c, 0
2703   1490 FD 77         inc b
2704   1492 FA FD FF      lea d, [bp + -3] ; $i
2705   1495 FD 43         mov [d], b
2706   1497 FD 7D         dec b
2707   1499 0A 38 13      jmp _for31_cond
2708   149C             _for31_exit:
2709   149C             ; return value; 
2710   149C FA FF FF      lea d, [bp + -1] ; $value
2711   149F 2A            mov b, [d]
2712   14A0 38 00 00      mov c, 0
2713   14A3 F9            leave
2714   14A4 09            ret
2715   14A5             
2716   14A5             gets:
2717   14A5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2718   14A8             
2719   14A8             ; --- BEGIN INLINE ASM SEGMENT
2720   14A8 FA 05 00      lea d, [bp + 5] ; $s
2721   14AB 15            mov a, [d]
2722   14AC 3C            mov d, a
2723   14AD 07 BC 1E      call _gets
2724   14B0             ; --- END INLINE ASM SEGMENT
2725   14B0             
2726   14B0             ; return strlen(s); 
2727   14B0             ; --- START FUNCTION CALL
2728   14B0 FA 05 00      lea d, [bp + 5] ; $s
2729   14B3 2A            mov b, [d]
2730   14B4 38 00 00      mov c, 0
2731   14B7 FD AB         swp b
2732   14B9 D8            push b
2733   14BA 07 F8 05      call strlen
2734   14BD 51 02 00      add sp, 2
2735   14C0             ; --- END FUNCTION CALL
2736   14C0 F9            leave
2737   14C1 09            ret
2738   14C2             
2739   14C2             print_signed:
2740   14C2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2741   14C5             ; char digits[5]; 
2742   14C5 52 05 00      sub sp, 5
2743   14C8             ; int i = 0; 
2744   14C8 52 02 00      sub sp, 2
2745   14CB             ; --- START LOCAL VAR INITIALIZATION
2746   14CB FA FA FF      lea d, [bp + -6] ; $i
2747   14CE DA            push d
2748   14CF FD 2E 00 00   mov32 cb, $00000000
2748   14D3 00 00 
2749   14D5 E7            pop d
2750   14D6 FD 43         mov [d], b
2751   14D8             ; --- END LOCAL VAR INITIALIZATION
2752   14D8             ; if (num < 0) { 
2753   14D8             _if34_cond:
2754   14D8 FA 05 00      lea d, [bp + 5] ; $num
2755   14DB 2A            mov b, [d]
2756   14DC 38 00 00      mov c, 0
2757   14DF             ; --- START RELATIONAL
2758   14DF D7            push a
2759   14E0 11            mov a, b
2760   14E1 FD 2E 00 00   mov32 cb, $00000000
2760   14E5 00 00 
2761   14E7 B0            cmp a, b
2762   14E8 FD 73         slt ; < (signed)
2763   14EA E4            pop a
2764   14EB             ; --- END RELATIONAL
2765   14EB C0 00 00      cmp b, 0
2766   14EE C6 11 15      je _if34_else
2767   14F1             _if34_true:
2768   14F1             ; putchar('-'); 
2769   14F1             ; --- START FUNCTION CALL
2770   14F1 FD 2E 2D 00   mov32 cb, $0000002d
2770   14F5 00 00 
2771   14F7 DD            push bl
2772   14F8 07 A6 1C      call putchar
2773   14FB 51 01 00      add sp, 1
2774   14FE             ; --- END FUNCTION CALL
2775   14FE             ; num = -num; 
2776   14FE FA 05 00      lea d, [bp + 5] ; $num
2777   1501 DA            push d
2778   1502 FA 05 00      lea d, [bp + 5] ; $num
2779   1505 2A            mov b, [d]
2780   1506 38 00 00      mov c, 0
2781   1509 FD 97         neg b
2782   150B E7            pop d
2783   150C FD 43         mov [d], b
2784   150E 0A 3C 15      jmp _if34_exit
2785   1511             _if34_else:
2786   1511             ; if (num == 0) { 
2787   1511             _if35_cond:
2788   1511 FA 05 00      lea d, [bp + 5] ; $num
2789   1514 2A            mov b, [d]
2790   1515 38 00 00      mov c, 0
2791   1518             ; --- START RELATIONAL
2792   1518 D7            push a
2793   1519 11            mov a, b
2794   151A FD 2E 00 00   mov32 cb, $00000000
2794   151E 00 00 
2795   1520 B0            cmp a, b
2796   1521 FD 71         seq ; ==
2797   1523 E4            pop a
2798   1524             ; --- END RELATIONAL
2799   1524 C0 00 00      cmp b, 0
2800   1527 C6 3C 15      je _if35_exit
2801   152A             _if35_true:
2802   152A             ; putchar('0'); 
2803   152A             ; --- START FUNCTION CALL
2804   152A FD 2E 30 00   mov32 cb, $00000030
2804   152E 00 00 
2805   1530 DD            push bl
2806   1531 07 A6 1C      call putchar
2807   1534 51 01 00      add sp, 1
2808   1537             ; --- END FUNCTION CALL
2809   1537             ; return; 
2810   1537 F9            leave
2811   1538 09            ret
2812   1539 0A 3C 15      jmp _if35_exit
2813   153C             _if35_exit:
2814   153C             _if34_exit:
2815   153C             ; while (num > 0) { 
2816   153C             _while36_cond:
2817   153C FA 05 00      lea d, [bp + 5] ; $num
2818   153F 2A            mov b, [d]
2819   1540 38 00 00      mov c, 0
2820   1543             ; --- START RELATIONAL
2821   1543 D7            push a
2822   1544 11            mov a, b
2823   1545 FD 2E 00 00   mov32 cb, $00000000
2823   1549 00 00 
2824   154B B0            cmp a, b
2825   154C FD 7F         sgt ; >
2826   154E E4            pop a
2827   154F             ; --- END RELATIONAL
2828   154F C0 00 00      cmp b, 0
2829   1552 C6 B1 15      je _while36_exit
2830   1555             _while36_block:
2831   1555             ; digits[i] = '0' + (num % 10); 
2832   1555 FA FC FF      lea d, [bp + -4] ; $digits
2833   1558 D7            push a
2834   1559 DA            push d
2835   155A FA FA FF      lea d, [bp + -6] ; $i
2836   155D 2A            mov b, [d]
2837   155E 38 00 00      mov c, 0
2838   1561 E7            pop d
2839   1562 5A            add d, b
2840   1563 E4            pop a
2841   1564 DA            push d
2842   1565 FD 2E 30 00   mov32 cb, $00000030
2842   1569 00 00 
2843   156B             ; --- START TERMS
2844   156B D7            push a
2845   156C 11            mov a, b
2846   156D FA 05 00      lea d, [bp + 5] ; $num
2847   1570 2A            mov b, [d]
2848   1571 38 00 00      mov c, 0
2849   1574             ; --- START FACTORS
2850   1574 D7            push a
2851   1575 11            mov a, b
2852   1576 FD 2E 0A 00   mov32 cb, $0000000a
2852   157A 00 00 
2853   157C AE            div a, b ; 
2854   157D 11            mov a, b
2855   157E 27            mov b, a
2856   157F E4            pop a
2857   1580             ; --- END FACTORS
2858   1580 56            add b, a
2859   1581 E4            pop a
2860   1582             ; --- END TERMS
2861   1582 E7            pop d
2862   1583 FD 3E         mov [d], bl
2863   1585             ; num = num / 10; 
2864   1585 FA 05 00      lea d, [bp + 5] ; $num
2865   1588 DA            push d
2866   1589 FA 05 00      lea d, [bp + 5] ; $num
2867   158C 2A            mov b, [d]
2868   158D 38 00 00      mov c, 0
2869   1590             ; --- START FACTORS
2870   1590 D7            push a
2871   1591 11            mov a, b
2872   1592 FD 2E 0A 00   mov32 cb, $0000000a
2872   1596 00 00 
2873   1598 AE            div a, b
2874   1599 27            mov b, a
2875   159A E4            pop a
2876   159B             ; --- END FACTORS
2877   159B E7            pop d
2878   159C FD 43         mov [d], b
2879   159E             ; i++; 
2880   159E FA FA FF      lea d, [bp + -6] ; $i
2881   15A1 2A            mov b, [d]
2882   15A2 38 00 00      mov c, 0
2883   15A5 FD 77         inc b
2884   15A7 FA FA FF      lea d, [bp + -6] ; $i
2885   15AA FD 43         mov [d], b
2886   15AC FD 7D         dec b
2887   15AE 0A 3C 15      jmp _while36_cond
2888   15B1             _while36_exit:
2889   15B1             ; while (i > 0) { 
2890   15B1             _while37_cond:
2891   15B1 FA FA FF      lea d, [bp + -6] ; $i
2892   15B4 2A            mov b, [d]
2893   15B5 38 00 00      mov c, 0
2894   15B8             ; --- START RELATIONAL
2895   15B8 D7            push a
2896   15B9 11            mov a, b
2897   15BA FD 2E 00 00   mov32 cb, $00000000
2897   15BE 00 00 
2898   15C0 B0            cmp a, b
2899   15C1 FD 7F         sgt ; >
2900   15C3 E4            pop a
2901   15C4             ; --- END RELATIONAL
2902   15C4 C0 00 00      cmp b, 0
2903   15C7 C6 F9 15      je _while37_exit
2904   15CA             _while37_block:
2905   15CA             ; i--; 
2906   15CA FA FA FF      lea d, [bp + -6] ; $i
2907   15CD 2A            mov b, [d]
2908   15CE 38 00 00      mov c, 0
2909   15D1 FD 7D         dec b
2910   15D3 FA FA FF      lea d, [bp + -6] ; $i
2911   15D6 FD 43         mov [d], b
2912   15D8 FD 77         inc b
2913   15DA             ; putchar(digits[i]); 
2914   15DA             ; --- START FUNCTION CALL
2915   15DA FA FC FF      lea d, [bp + -4] ; $digits
2916   15DD D7            push a
2917   15DE DA            push d
2918   15DF FA FA FF      lea d, [bp + -6] ; $i
2919   15E2 2A            mov b, [d]
2920   15E3 38 00 00      mov c, 0
2921   15E6 E7            pop d
2922   15E7 5A            add d, b
2923   15E8 E4            pop a
2924   15E9 32            mov bl, [d]
2925   15EA A7 00         mov bh, 0
2926   15EC 38 00 00      mov c, 0
2927   15EF DD            push bl
2928   15F0 07 A6 1C      call putchar
2929   15F3 51 01 00      add sp, 1
2930   15F6             ; --- END FUNCTION CALL
2931   15F6 0A B1 15      jmp _while37_cond
2932   15F9             _while37_exit:
2933   15F9 F9            leave
2934   15FA 09            ret
2935   15FB             
2936   15FB             print_signed_long:
2937   15FB F8 00 00      enter 0 ; (push bp; mov bp, sp)
2938   15FE             ; char digits[10]; 
2939   15FE 52 0A 00      sub sp, 10
2940   1601             ; int i = 0; 
2941   1601 52 02 00      sub sp, 2
2942   1604             ; --- START LOCAL VAR INITIALIZATION
2943   1604 FA F5 FF      lea d, [bp + -11] ; $i
2944   1607 DA            push d
2945   1608 FD 2E 00 00   mov32 cb, $00000000
2945   160C 00 00 
2946   160E E7            pop d
2947   160F FD 43         mov [d], b
2948   1611             ; --- END LOCAL VAR INITIALIZATION
2949   1611             ; if (num < 0) { 
2950   1611             _if38_cond:
2951   1611 FA 05 00      lea d, [bp + 5] ; $num
2952   1614 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2953   1617 FD 39         mov c, b ; And place it into C
2954   1619 2A            mov b, [d] ; Lower Word in B
2955   161A             ; --- START RELATIONAL
2956   161A D7            push a
2957   161B FD D8         push g
2958   161D 11            mov a, b
2959   161E FD 7A         mov g, c
2960   1620 FD 2E 00 00   mov32 cb, $00000000
2960   1624 00 00 
2961   1626 FD AF         cmp32 ga, cb
2962   1628 FD 73         slt ; <
2963   162A FD F1         pop g
2964   162C E4            pop a
2965   162D             ; --- END RELATIONAL
2966   162D C0 00 00      cmp b, 0
2967   1630 C6 64 16      je _if38_else
2968   1633             _if38_true:
2969   1633             ; putchar('-'); 
2970   1633             ; --- START FUNCTION CALL
2971   1633 FD 2E 2D 00   mov32 cb, $0000002d
2971   1637 00 00 
2972   1639 DD            push bl
2973   163A 07 A6 1C      call putchar
2974   163D 51 01 00      add sp, 1
2975   1640             ; --- END FUNCTION CALL
2976   1640             ; num = -num; 
2977   1640 FA 05 00      lea d, [bp + 5] ; $num
2978   1643 DA            push d
2979   1644 FA 05 00      lea d, [bp + 5] ; $num
2980   1647 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2981   164A FD 39         mov c, b ; And place it into C
2982   164C 2A            mov b, [d] ; Lower Word in B
2983   164D 12            mov a, c
2984   164E 95            not a
2985   164F 97            not b
2986   1650 55 01 00      add b, 1
2987   1653 5B 00 00      adc a, 0
2988   1656 39            mov c, a
2989   1657 E7            pop d
2990   1658 FD 43         mov [d], b
2991   165A 26 00 00      mov b, 0
2992   165D FD 44 02 00   mov [d + 2], b
2993   1661 0A 98 16      jmp _if38_exit
2994   1664             _if38_else:
2995   1664             ; if (num == 0) { 
2996   1664             _if39_cond:
2997   1664 FA 05 00      lea d, [bp + 5] ; $num
2998   1667 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2999   166A FD 39         mov c, b ; And place it into C
3000   166C 2A            mov b, [d] ; Lower Word in B
3001   166D             ; --- START RELATIONAL
3002   166D D7            push a
3003   166E FD D8         push g
3004   1670 11            mov a, b
3005   1671 FD 7A         mov g, c
3006   1673 FD 2E 00 00   mov32 cb, $00000000
3006   1677 00 00 
3007   1679 FD AF         cmp32 ga, cb
3008   167B FD 71         seq ; ==
3009   167D FD F1         pop g
3010   167F E4            pop a
3011   1680             ; --- END RELATIONAL
3012   1680 C0 00 00      cmp b, 0
3013   1683 C6 98 16      je _if39_exit
3014   1686             _if39_true:
3015   1686             ; putchar('0'); 
3016   1686             ; --- START FUNCTION CALL
3017   1686 FD 2E 30 00   mov32 cb, $00000030
3017   168A 00 00 
3018   168C DD            push bl
3019   168D 07 A6 1C      call putchar
3020   1690 51 01 00      add sp, 1
3021   1693             ; --- END FUNCTION CALL
3022   1693             ; return; 
3023   1693 F9            leave
3024   1694 09            ret
3025   1695 0A 98 16      jmp _if39_exit
3026   1698             _if39_exit:
3027   1698             _if38_exit:
3028   1698             ; while (num > 0) { 
3029   1698             _while40_cond:
3030   1698 FA 05 00      lea d, [bp + 5] ; $num
3031   169B 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3032   169E FD 39         mov c, b ; And place it into C
3033   16A0 2A            mov b, [d] ; Lower Word in B
3034   16A1             ; --- START RELATIONAL
3035   16A1 D7            push a
3036   16A2 FD D8         push g
3037   16A4 11            mov a, b
3038   16A5 FD 7A         mov g, c
3039   16A7 FD 2E 00 00   mov32 cb, $00000000
3039   16AB 00 00 
3040   16AD FD AF         cmp32 ga, cb
3041   16AF FD 7F         sgt
3042   16B1 FD F1         pop g
3043   16B3 E4            pop a
3044   16B4             ; --- END RELATIONAL
3045   16B4 C0 00 00      cmp b, 0
3046   16B7 C6 20 17      je _while40_exit
3047   16BA             _while40_block:
3048   16BA             ; digits[i] = '0' + (num % 10); 
3049   16BA FA F7 FF      lea d, [bp + -9] ; $digits
3050   16BD D7            push a
3051   16BE DA            push d
3052   16BF FA F5 FF      lea d, [bp + -11] ; $i
3053   16C2 2A            mov b, [d]
3054   16C3 38 00 00      mov c, 0
3055   16C6 E7            pop d
3056   16C7 5A            add d, b
3057   16C8 E4            pop a
3058   16C9 DA            push d
3059   16CA FD 2E 30 00   mov32 cb, $00000030
3059   16CE 00 00 
3060   16D0             ; --- START TERMS
3061   16D0 D7            push a
3062   16D1 11            mov a, b
3063   16D2 FA 05 00      lea d, [bp + 5] ; $num
3064   16D5 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3065   16D8 FD 39         mov c, b ; And place it into C
3066   16DA 2A            mov b, [d] ; Lower Word in B
3067   16DB             ; --- START FACTORS
3068   16DB D7            push a
3069   16DC 11            mov a, b
3070   16DD FD 2E 0A 00   mov32 cb, $0000000a
3070   16E1 00 00 
3071   16E3 AE            div a, b ; 
3072   16E4 11            mov a, b
3073   16E5 27            mov b, a
3074   16E6 E4            pop a
3075   16E7             ; --- END FACTORS
3076   16E7 FD 15         add32 cb, ga
3077   16E9 E4            pop a
3078   16EA             ; --- END TERMS
3079   16EA E7            pop d
3080   16EB FD 3E         mov [d], bl
3081   16ED             ; num = num / 10; 
3082   16ED FA 05 00      lea d, [bp + 5] ; $num
3083   16F0 DA            push d
3084   16F1 FA 05 00      lea d, [bp + 5] ; $num
3085   16F4 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3086   16F7 FD 39         mov c, b ; And place it into C
3087   16F9 2A            mov b, [d] ; Lower Word in B
3088   16FA             ; --- START FACTORS
3089   16FA D7            push a
3090   16FB 11            mov a, b
3091   16FC FD 2E 0A 00   mov32 cb, $0000000a
3091   1700 00 00 
3092   1702 AE            div a, b
3093   1703 27            mov b, a
3094   1704 E4            pop a
3095   1705             ; --- END FACTORS
3096   1705 E7            pop d
3097   1706 FD 43         mov [d], b
3098   1708 28            mov b, c
3099   1709 FD 44 02 00   mov [d + 2], b
3100   170D             ; i++; 
3101   170D FA F5 FF      lea d, [bp + -11] ; $i
3102   1710 2A            mov b, [d]
3103   1711 38 00 00      mov c, 0
3104   1714 FD 77         inc b
3105   1716 FA F5 FF      lea d, [bp + -11] ; $i
3106   1719 FD 43         mov [d], b
3107   171B FD 7D         dec b
3108   171D 0A 98 16      jmp _while40_cond
3109   1720             _while40_exit:
3110   1720             ; while (i > 0) { 
3111   1720             _while41_cond:
3112   1720 FA F5 FF      lea d, [bp + -11] ; $i
3113   1723 2A            mov b, [d]
3114   1724 38 00 00      mov c, 0
3115   1727             ; --- START RELATIONAL
3116   1727 D7            push a
3117   1728 11            mov a, b
3118   1729 FD 2E 00 00   mov32 cb, $00000000
3118   172D 00 00 
3119   172F B0            cmp a, b
3120   1730 FD 7F         sgt ; >
3121   1732 E4            pop a
3122   1733             ; --- END RELATIONAL
3123   1733 C0 00 00      cmp b, 0
3124   1736 C6 68 17      je _while41_exit
3125   1739             _while41_block:
3126   1739             ; i--; 
3127   1739 FA F5 FF      lea d, [bp + -11] ; $i
3128   173C 2A            mov b, [d]
3129   173D 38 00 00      mov c, 0
3130   1740 FD 7D         dec b
3131   1742 FA F5 FF      lea d, [bp + -11] ; $i
3132   1745 FD 43         mov [d], b
3133   1747 FD 77         inc b
3134   1749             ; putchar(digits[i]); 
3135   1749             ; --- START FUNCTION CALL
3136   1749 FA F7 FF      lea d, [bp + -9] ; $digits
3137   174C D7            push a
3138   174D DA            push d
3139   174E FA F5 FF      lea d, [bp + -11] ; $i
3140   1751 2A            mov b, [d]
3141   1752 38 00 00      mov c, 0
3142   1755 E7            pop d
3143   1756 5A            add d, b
3144   1757 E4            pop a
3145   1758 32            mov bl, [d]
3146   1759 A7 00         mov bh, 0
3147   175B 38 00 00      mov c, 0
3148   175E DD            push bl
3149   175F 07 A6 1C      call putchar
3150   1762 51 01 00      add sp, 1
3151   1765             ; --- END FUNCTION CALL
3152   1765 0A 20 17      jmp _while41_cond
3153   1768             _while41_exit:
3154   1768 F9            leave
3155   1769 09            ret
3156   176A             
3157   176A             print_unsigned_long:
3158   176A F8 00 00      enter 0 ; (push bp; mov bp, sp)
3159   176D             ; char digits[10]; 
3160   176D 52 0A 00      sub sp, 10
3161   1770             ; int i; 
3162   1770 52 02 00      sub sp, 2
3163   1773             ; i = 0; 
3164   1773 FA F5 FF      lea d, [bp + -11] ; $i
3165   1776 DA            push d
3166   1777 FD 2E 00 00   mov32 cb, $00000000
3166   177B 00 00 
3167   177D E7            pop d
3168   177E FD 43         mov [d], b
3169   1780             ; if(num == 0){ 
3170   1780             _if42_cond:
3171   1780 FA 05 00      lea d, [bp + 5] ; $num
3172   1783 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3173   1786 FD 39         mov c, b ; And place it into C
3174   1788 2A            mov b, [d] ; Lower Word in B
3175   1789             ; --- START RELATIONAL
3176   1789 D7            push a
3177   178A FD D8         push g
3178   178C 11            mov a, b
3179   178D FD 7A         mov g, c
3180   178F FD 2E 00 00   mov32 cb, $00000000
3180   1793 00 00 
3181   1795 FD AF         cmp32 ga, cb
3182   1797 FD 71         seq ; ==
3183   1799 FD F1         pop g
3184   179B E4            pop a
3185   179C             ; --- END RELATIONAL
3186   179C C0 00 00      cmp b, 0
3187   179F C6 B4 17      je _if42_exit
3188   17A2             _if42_true:
3189   17A2             ; putchar('0'); 
3190   17A2             ; --- START FUNCTION CALL
3191   17A2 FD 2E 30 00   mov32 cb, $00000030
3191   17A6 00 00 
3192   17A8 DD            push bl
3193   17A9 07 A6 1C      call putchar
3194   17AC 51 01 00      add sp, 1
3195   17AF             ; --- END FUNCTION CALL
3196   17AF             ; return; 
3197   17AF F9            leave
3198   17B0 09            ret
3199   17B1 0A B4 17      jmp _if42_exit
3200   17B4             _if42_exit:
3201   17B4             ; while (num > 0) { 
3202   17B4             _while43_cond:
3203   17B4 FA 05 00      lea d, [bp + 5] ; $num
3204   17B7 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3205   17BA FD 39         mov c, b ; And place it into C
3206   17BC 2A            mov b, [d] ; Lower Word in B
3207   17BD             ; --- START RELATIONAL
3208   17BD D7            push a
3209   17BE FD D8         push g
3210   17C0 11            mov a, b
3211   17C1 FD 7A         mov g, c
3212   17C3 FD 2E 00 00   mov32 cb, $00000000
3212   17C7 00 00 
3213   17C9 FD AF         cmp32 ga, cb
3214   17CB FD 81         sgu
3215   17CD FD F1         pop g
3216   17CF E4            pop a
3217   17D0             ; --- END RELATIONAL
3218   17D0 C0 00 00      cmp b, 0
3219   17D3 C6 3C 18      je _while43_exit
3220   17D6             _while43_block:
3221   17D6             ; digits[i] = '0' + (num % 10); 
3222   17D6 FA F7 FF      lea d, [bp + -9] ; $digits
3223   17D9 D7            push a
3224   17DA DA            push d
3225   17DB FA F5 FF      lea d, [bp + -11] ; $i
3226   17DE 2A            mov b, [d]
3227   17DF 38 00 00      mov c, 0
3228   17E2 E7            pop d
3229   17E3 5A            add d, b
3230   17E4 E4            pop a
3231   17E5 DA            push d
3232   17E6 FD 2E 30 00   mov32 cb, $00000030
3232   17EA 00 00 
3233   17EC             ; --- START TERMS
3234   17EC D7            push a
3235   17ED 11            mov a, b
3236   17EE FA 05 00      lea d, [bp + 5] ; $num
3237   17F1 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3238   17F4 FD 39         mov c, b ; And place it into C
3239   17F6 2A            mov b, [d] ; Lower Word in B
3240   17F7             ; --- START FACTORS
3241   17F7 D7            push a
3242   17F8 11            mov a, b
3243   17F9 FD 2E 0A 00   mov32 cb, $0000000a
3243   17FD 00 00 
3244   17FF AE            div a, b ; 
3245   1800 11            mov a, b
3246   1801 27            mov b, a
3247   1802 E4            pop a
3248   1803             ; --- END FACTORS
3249   1803 FD 15         add32 cb, ga
3250   1805 E4            pop a
3251   1806             ; --- END TERMS
3252   1806 E7            pop d
3253   1807 FD 3E         mov [d], bl
3254   1809             ; num = num / 10; 
3255   1809 FA 05 00      lea d, [bp + 5] ; $num
3256   180C DA            push d
3257   180D FA 05 00      lea d, [bp + 5] ; $num
3258   1810 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3259   1813 FD 39         mov c, b ; And place it into C
3260   1815 2A            mov b, [d] ; Lower Word in B
3261   1816             ; --- START FACTORS
3262   1816 D7            push a
3263   1817 11            mov a, b
3264   1818 FD 2E 0A 00   mov32 cb, $0000000a
3264   181C 00 00 
3265   181E AE            div a, b
3266   181F 27            mov b, a
3267   1820 E4            pop a
3268   1821             ; --- END FACTORS
3269   1821 E7            pop d
3270   1822 FD 43         mov [d], b
3271   1824 28            mov b, c
3272   1825 FD 44 02 00   mov [d + 2], b
3273   1829             ; i++; 
3274   1829 FA F5 FF      lea d, [bp + -11] ; $i
3275   182C 2A            mov b, [d]
3276   182D 38 00 00      mov c, 0
3277   1830 FD 77         inc b
3278   1832 FA F5 FF      lea d, [bp + -11] ; $i
3279   1835 FD 43         mov [d], b
3280   1837 FD 7D         dec b
3281   1839 0A B4 17      jmp _while43_cond
3282   183C             _while43_exit:
3283   183C             ; while (i > 0) { 
3284   183C             _while44_cond:
3285   183C FA F5 FF      lea d, [bp + -11] ; $i
3286   183F 2A            mov b, [d]
3287   1840 38 00 00      mov c, 0
3288   1843             ; --- START RELATIONAL
3289   1843 D7            push a
3290   1844 11            mov a, b
3291   1845 FD 2E 00 00   mov32 cb, $00000000
3291   1849 00 00 
3292   184B B0            cmp a, b
3293   184C FD 7F         sgt ; >
3294   184E E4            pop a
3295   184F             ; --- END RELATIONAL
3296   184F C0 00 00      cmp b, 0
3297   1852 C6 84 18      je _while44_exit
3298   1855             _while44_block:
3299   1855             ; i--; 
3300   1855 FA F5 FF      lea d, [bp + -11] ; $i
3301   1858 2A            mov b, [d]
3302   1859 38 00 00      mov c, 0
3303   185C FD 7D         dec b
3304   185E FA F5 FF      lea d, [bp + -11] ; $i
3305   1861 FD 43         mov [d], b
3306   1863 FD 77         inc b
3307   1865             ; putchar(digits[i]); 
3308   1865             ; --- START FUNCTION CALL
3309   1865 FA F7 FF      lea d, [bp + -9] ; $digits
3310   1868 D7            push a
3311   1869 DA            push d
3312   186A FA F5 FF      lea d, [bp + -11] ; $i
3313   186D 2A            mov b, [d]
3314   186E 38 00 00      mov c, 0
3315   1871 E7            pop d
3316   1872 5A            add d, b
3317   1873 E4            pop a
3318   1874 32            mov bl, [d]
3319   1875 A7 00         mov bh, 0
3320   1877 38 00 00      mov c, 0
3321   187A DD            push bl
3322   187B 07 A6 1C      call putchar
3323   187E 51 01 00      add sp, 1
3324   1881             ; --- END FUNCTION CALL
3325   1881 0A 3C 18      jmp _while44_cond
3326   1884             _while44_exit:
3327   1884 F9            leave
3328   1885 09            ret
3329   1886             
3330   1886             sprint_unsigned:
3331   1886 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3332   1889             ; char digits[5]; 
3333   1889 52 05 00      sub sp, 5
3334   188C             ; int i; 
3335   188C 52 02 00      sub sp, 2
3336   188F             ; int len = 0; 
3337   188F 52 02 00      sub sp, 2
3338   1892             ; --- START LOCAL VAR INITIALIZATION
3339   1892 FA F8 FF      lea d, [bp + -8] ; $len
3340   1895 DA            push d
3341   1896 FD 2E 00 00   mov32 cb, $00000000
3341   189A 00 00 
3342   189C E7            pop d
3343   189D FD 43         mov [d], b
3344   189F             ; --- END LOCAL VAR INITIALIZATION
3345   189F             ; i = 0; 
3346   189F FA FA FF      lea d, [bp + -6] ; $i
3347   18A2 DA            push d
3348   18A3 FD 2E 00 00   mov32 cb, $00000000
3348   18A7 00 00 
3349   18A9 E7            pop d
3350   18AA FD 43         mov [d], b
3351   18AC             ; if(num == 0){ 
3352   18AC             _if45_cond:
3353   18AC FA 07 00      lea d, [bp + 7] ; $num
3354   18AF 2A            mov b, [d]
3355   18B0 38 00 00      mov c, 0
3356   18B3             ; --- START RELATIONAL
3357   18B3 D7            push a
3358   18B4 11            mov a, b
3359   18B5 FD 2E 00 00   mov32 cb, $00000000
3359   18B9 00 00 
3360   18BB B0            cmp a, b
3361   18BC FD 71         seq ; ==
3362   18BE E4            pop a
3363   18BF             ; --- END RELATIONAL
3364   18BF C0 00 00      cmp b, 0
3365   18C2 C6 EA 18      je _if45_exit
3366   18C5             _if45_true:
3367   18C5             ; *dest++ = '0'; 
3368   18C5 FA 05 00      lea d, [bp + 5] ; $dest
3369   18C8 2A            mov b, [d]
3370   18C9 38 00 00      mov c, 0
3371   18CC FD 77         inc b
3372   18CE FA 05 00      lea d, [bp + 5] ; $dest
3373   18D1 FD 43         mov [d], b
3374   18D3 FD 7D         dec b
3375   18D5 D8            push b
3376   18D6 FD 2E 30 00   mov32 cb, $00000030
3376   18DA 00 00 
3377   18DC E7            pop d
3378   18DD FD 3E         mov [d], bl
3379   18DF             ; return 1; 
3380   18DF FD 2E 01 00   mov32 cb, $00000001
3380   18E3 00 00 
3381   18E5 F9            leave
3382   18E6 09            ret
3383   18E7 0A EA 18      jmp _if45_exit
3384   18EA             _if45_exit:
3385   18EA             ; while (num > 0) { 
3386   18EA             _while46_cond:
3387   18EA FA 07 00      lea d, [bp + 7] ; $num
3388   18ED 2A            mov b, [d]
3389   18EE 38 00 00      mov c, 0
3390   18F1             ; --- START RELATIONAL
3391   18F1 D7            push a
3392   18F2 11            mov a, b
3393   18F3 FD 2E 00 00   mov32 cb, $00000000
3393   18F7 00 00 
3394   18F9 B0            cmp a, b
3395   18FA FD 81         sgu ; > (unsigned)
3396   18FC E4            pop a
3397   18FD             ; --- END RELATIONAL
3398   18FD C0 00 00      cmp b, 0
3399   1900 C6 5F 19      je _while46_exit
3400   1903             _while46_block:
3401   1903             ; digits[i] = '0' + (num % 10); 
3402   1903 FA FC FF      lea d, [bp + -4] ; $digits
3403   1906 D7            push a
3404   1907 DA            push d
3405   1908 FA FA FF      lea d, [bp + -6] ; $i
3406   190B 2A            mov b, [d]
3407   190C 38 00 00      mov c, 0
3408   190F E7            pop d
3409   1910 5A            add d, b
3410   1911 E4            pop a
3411   1912 DA            push d
3412   1913 FD 2E 30 00   mov32 cb, $00000030
3412   1917 00 00 
3413   1919             ; --- START TERMS
3414   1919 D7            push a
3415   191A 11            mov a, b
3416   191B FA 07 00      lea d, [bp + 7] ; $num
3417   191E 2A            mov b, [d]
3418   191F 38 00 00      mov c, 0
3419   1922             ; --- START FACTORS
3420   1922 D7            push a
3421   1923 11            mov a, b
3422   1924 FD 2E 0A 00   mov32 cb, $0000000a
3422   1928 00 00 
3423   192A AE            div a, b ; 
3424   192B 11            mov a, b
3425   192C 27            mov b, a
3426   192D E4            pop a
3427   192E             ; --- END FACTORS
3428   192E 56            add b, a
3429   192F E4            pop a
3430   1930             ; --- END TERMS
3431   1930 E7            pop d
3432   1931 FD 3E         mov [d], bl
3433   1933             ; num = num / 10; 
3434   1933 FA 07 00      lea d, [bp + 7] ; $num
3435   1936 DA            push d
3436   1937 FA 07 00      lea d, [bp + 7] ; $num
3437   193A 2A            mov b, [d]
3438   193B 38 00 00      mov c, 0
3439   193E             ; --- START FACTORS
3440   193E D7            push a
3441   193F 11            mov a, b
3442   1940 FD 2E 0A 00   mov32 cb, $0000000a
3442   1944 00 00 
3443   1946 AE            div a, b
3444   1947 27            mov b, a
3445   1948 E4            pop a
3446   1949             ; --- END FACTORS
3447   1949 E7            pop d
3448   194A FD 43         mov [d], b
3449   194C             ; i++; 
3450   194C FA FA FF      lea d, [bp + -6] ; $i
3451   194F 2A            mov b, [d]
3452   1950 38 00 00      mov c, 0
3453   1953 FD 77         inc b
3454   1955 FA FA FF      lea d, [bp + -6] ; $i
3455   1958 FD 43         mov [d], b
3456   195A FD 7D         dec b
3457   195C 0A EA 18      jmp _while46_cond
3458   195F             _while46_exit:
3459   195F             ; while (i > 0) { 
3460   195F             _while47_cond:
3461   195F FA FA FF      lea d, [bp + -6] ; $i
3462   1962 2A            mov b, [d]
3463   1963 38 00 00      mov c, 0
3464   1966             ; --- START RELATIONAL
3465   1966 D7            push a
3466   1967 11            mov a, b
3467   1968 FD 2E 00 00   mov32 cb, $00000000
3467   196C 00 00 
3468   196E B0            cmp a, b
3469   196F FD 7F         sgt ; >
3470   1971 E4            pop a
3471   1972             ; --- END RELATIONAL
3472   1972 C0 00 00      cmp b, 0
3473   1975 C6 C4 19      je _while47_exit
3474   1978             _while47_block:
3475   1978             ; i--; 
3476   1978 FA FA FF      lea d, [bp + -6] ; $i
3477   197B 2A            mov b, [d]
3478   197C 38 00 00      mov c, 0
3479   197F FD 7D         dec b
3480   1981 FA FA FF      lea d, [bp + -6] ; $i
3481   1984 FD 43         mov [d], b
3482   1986 FD 77         inc b
3483   1988             ; *dest++ = digits[i]; 
3484   1988 FA 05 00      lea d, [bp + 5] ; $dest
3485   198B 2A            mov b, [d]
3486   198C 38 00 00      mov c, 0
3487   198F FD 77         inc b
3488   1991 FA 05 00      lea d, [bp + 5] ; $dest
3489   1994 FD 43         mov [d], b
3490   1996 FD 7D         dec b
3491   1998 D8            push b
3492   1999 FA FC FF      lea d, [bp + -4] ; $digits
3493   199C D7            push a
3494   199D DA            push d
3495   199E FA FA FF      lea d, [bp + -6] ; $i
3496   19A1 2A            mov b, [d]
3497   19A2 38 00 00      mov c, 0
3498   19A5 E7            pop d
3499   19A6 5A            add d, b
3500   19A7 E4            pop a
3501   19A8 32            mov bl, [d]
3502   19A9 A7 00         mov bh, 0
3503   19AB 38 00 00      mov c, 0
3504   19AE E7            pop d
3505   19AF FD 3E         mov [d], bl
3506   19B1             ; len++; 
3507   19B1 FA F8 FF      lea d, [bp + -8] ; $len
3508   19B4 2A            mov b, [d]
3509   19B5 38 00 00      mov c, 0
3510   19B8 FD 77         inc b
3511   19BA FA F8 FF      lea d, [bp + -8] ; $len
3512   19BD FD 43         mov [d], b
3513   19BF FD 7D         dec b
3514   19C1 0A 5F 19      jmp _while47_cond
3515   19C4             _while47_exit:
3516   19C4             ; *dest = '\0'; 
3517   19C4 FA 05 00      lea d, [bp + 5] ; $dest
3518   19C7 2A            mov b, [d]
3519   19C8 38 00 00      mov c, 0
3520   19CB D8            push b
3521   19CC FD 2E 00 00   mov32 cb, $00000000
3521   19D0 00 00 
3522   19D2 E7            pop d
3523   19D3 FD 3E         mov [d], bl
3524   19D5             ; return len; 
3525   19D5 FA F8 FF      lea d, [bp + -8] ; $len
3526   19D8 2A            mov b, [d]
3527   19D9 38 00 00      mov c, 0
3528   19DC F9            leave
3529   19DD 09            ret
3530   19DE             
3531   19DE             print_unsigned:
3532   19DE F8 00 00      enter 0 ; (push bp; mov bp, sp)
3533   19E1             ; char digits[5]; 
3534   19E1 52 05 00      sub sp, 5
3535   19E4             ; int i; 
3536   19E4 52 02 00      sub sp, 2
3537   19E7             ; i = 0; 
3538   19E7 FA FA FF      lea d, [bp + -6] ; $i
3539   19EA DA            push d
3540   19EB FD 2E 00 00   mov32 cb, $00000000
3540   19EF 00 00 
3541   19F1 E7            pop d
3542   19F2 FD 43         mov [d], b
3543   19F4             ; if(num == 0){ 
3544   19F4             _if48_cond:
3545   19F4 FA 05 00      lea d, [bp + 5] ; $num
3546   19F7 2A            mov b, [d]
3547   19F8 38 00 00      mov c, 0
3548   19FB             ; --- START RELATIONAL
3549   19FB D7            push a
3550   19FC 11            mov a, b
3551   19FD FD 2E 00 00   mov32 cb, $00000000
3551   1A01 00 00 
3552   1A03 B0            cmp a, b
3553   1A04 FD 71         seq ; ==
3554   1A06 E4            pop a
3555   1A07             ; --- END RELATIONAL
3556   1A07 C0 00 00      cmp b, 0
3557   1A0A C6 1F 1A      je _if48_exit
3558   1A0D             _if48_true:
3559   1A0D             ; putchar('0'); 
3560   1A0D             ; --- START FUNCTION CALL
3561   1A0D FD 2E 30 00   mov32 cb, $00000030
3561   1A11 00 00 
3562   1A13 DD            push bl
3563   1A14 07 A6 1C      call putchar
3564   1A17 51 01 00      add sp, 1
3565   1A1A             ; --- END FUNCTION CALL
3566   1A1A             ; return; 
3567   1A1A F9            leave
3568   1A1B 09            ret
3569   1A1C 0A 1F 1A      jmp _if48_exit
3570   1A1F             _if48_exit:
3571   1A1F             ; while (num > 0) { 
3572   1A1F             _while49_cond:
3573   1A1F FA 05 00      lea d, [bp + 5] ; $num
3574   1A22 2A            mov b, [d]
3575   1A23 38 00 00      mov c, 0
3576   1A26             ; --- START RELATIONAL
3577   1A26 D7            push a
3578   1A27 11            mov a, b
3579   1A28 FD 2E 00 00   mov32 cb, $00000000
3579   1A2C 00 00 
3580   1A2E B0            cmp a, b
3581   1A2F FD 81         sgu ; > (unsigned)
3582   1A31 E4            pop a
3583   1A32             ; --- END RELATIONAL
3584   1A32 C0 00 00      cmp b, 0
3585   1A35 C6 94 1A      je _while49_exit
3586   1A38             _while49_block:
3587   1A38             ; digits[i] = '0' + (num % 10); 
3588   1A38 FA FC FF      lea d, [bp + -4] ; $digits
3589   1A3B D7            push a
3590   1A3C DA            push d
3591   1A3D FA FA FF      lea d, [bp + -6] ; $i
3592   1A40 2A            mov b, [d]
3593   1A41 38 00 00      mov c, 0
3594   1A44 E7            pop d
3595   1A45 5A            add d, b
3596   1A46 E4            pop a
3597   1A47 DA            push d
3598   1A48 FD 2E 30 00   mov32 cb, $00000030
3598   1A4C 00 00 
3599   1A4E             ; --- START TERMS
3600   1A4E D7            push a
3601   1A4F 11            mov a, b
3602   1A50 FA 05 00      lea d, [bp + 5] ; $num
3603   1A53 2A            mov b, [d]
3604   1A54 38 00 00      mov c, 0
3605   1A57             ; --- START FACTORS
3606   1A57 D7            push a
3607   1A58 11            mov a, b
3608   1A59 FD 2E 0A 00   mov32 cb, $0000000a
3608   1A5D 00 00 
3609   1A5F AE            div a, b ; 
3610   1A60 11            mov a, b
3611   1A61 27            mov b, a
3612   1A62 E4            pop a
3613   1A63             ; --- END FACTORS
3614   1A63 56            add b, a
3615   1A64 E4            pop a
3616   1A65             ; --- END TERMS
3617   1A65 E7            pop d
3618   1A66 FD 3E         mov [d], bl
3619   1A68             ; num = num / 10; 
3620   1A68 FA 05 00      lea d, [bp + 5] ; $num
3621   1A6B DA            push d
3622   1A6C FA 05 00      lea d, [bp + 5] ; $num
3623   1A6F 2A            mov b, [d]
3624   1A70 38 00 00      mov c, 0
3625   1A73             ; --- START FACTORS
3626   1A73 D7            push a
3627   1A74 11            mov a, b
3628   1A75 FD 2E 0A 00   mov32 cb, $0000000a
3628   1A79 00 00 
3629   1A7B AE            div a, b
3630   1A7C 27            mov b, a
3631   1A7D E4            pop a
3632   1A7E             ; --- END FACTORS
3633   1A7E E7            pop d
3634   1A7F FD 43         mov [d], b
3635   1A81             ; i++; 
3636   1A81 FA FA FF      lea d, [bp + -6] ; $i
3637   1A84 2A            mov b, [d]
3638   1A85 38 00 00      mov c, 0
3639   1A88 FD 77         inc b
3640   1A8A FA FA FF      lea d, [bp + -6] ; $i
3641   1A8D FD 43         mov [d], b
3642   1A8F FD 7D         dec b
3643   1A91 0A 1F 1A      jmp _while49_cond
3644   1A94             _while49_exit:
3645   1A94             ; while (i > 0) { 
3646   1A94             _while50_cond:
3647   1A94 FA FA FF      lea d, [bp + -6] ; $i
3648   1A97 2A            mov b, [d]
3649   1A98 38 00 00      mov c, 0
3650   1A9B             ; --- START RELATIONAL
3651   1A9B D7            push a
3652   1A9C 11            mov a, b
3653   1A9D FD 2E 00 00   mov32 cb, $00000000
3653   1AA1 00 00 
3654   1AA3 B0            cmp a, b
3655   1AA4 FD 7F         sgt ; >
3656   1AA6 E4            pop a
3657   1AA7             ; --- END RELATIONAL
3658   1AA7 C0 00 00      cmp b, 0
3659   1AAA C6 DC 1A      je _while50_exit
3660   1AAD             _while50_block:
3661   1AAD             ; i--; 
3662   1AAD FA FA FF      lea d, [bp + -6] ; $i
3663   1AB0 2A            mov b, [d]
3664   1AB1 38 00 00      mov c, 0
3665   1AB4 FD 7D         dec b
3666   1AB6 FA FA FF      lea d, [bp + -6] ; $i
3667   1AB9 FD 43         mov [d], b
3668   1ABB FD 77         inc b
3669   1ABD             ; putchar(digits[i]); 
3670   1ABD             ; --- START FUNCTION CALL
3671   1ABD FA FC FF      lea d, [bp + -4] ; $digits
3672   1AC0 D7            push a
3673   1AC1 DA            push d
3674   1AC2 FA FA FF      lea d, [bp + -6] ; $i
3675   1AC5 2A            mov b, [d]
3676   1AC6 38 00 00      mov c, 0
3677   1AC9 E7            pop d
3678   1ACA 5A            add d, b
3679   1ACB E4            pop a
3680   1ACC 32            mov bl, [d]
3681   1ACD A7 00         mov bh, 0
3682   1ACF 38 00 00      mov c, 0
3683   1AD2 DD            push bl
3684   1AD3 07 A6 1C      call putchar
3685   1AD6 51 01 00      add sp, 1
3686   1AD9             ; --- END FUNCTION CALL
3687   1AD9 0A 94 1A      jmp _while50_cond
3688   1ADC             _while50_exit:
3689   1ADC F9            leave
3690   1ADD 09            ret
3691   1ADE             
3692   1ADE             sprint_signed:
3693   1ADE F8 00 00      enter 0 ; (push bp; mov bp, sp)
3694   1AE1             ; char digits[5]; 
3695   1AE1 52 05 00      sub sp, 5
3696   1AE4             ; int i = 0; 
3697   1AE4 52 02 00      sub sp, 2
3698   1AE7             ; --- START LOCAL VAR INITIALIZATION
3699   1AE7 FA FA FF      lea d, [bp + -6] ; $i
3700   1AEA DA            push d
3701   1AEB FD 2E 00 00   mov32 cb, $00000000
3701   1AEF 00 00 
3702   1AF1 E7            pop d
3703   1AF2 FD 43         mov [d], b
3704   1AF4             ; --- END LOCAL VAR INITIALIZATION
3705   1AF4             ; int len = 0; 
3706   1AF4 52 02 00      sub sp, 2
3707   1AF7             ; --- START LOCAL VAR INITIALIZATION
3708   1AF7 FA F8 FF      lea d, [bp + -8] ; $len
3709   1AFA DA            push d
3710   1AFB FD 2E 00 00   mov32 cb, $00000000
3710   1AFF 00 00 
3711   1B01 E7            pop d
3712   1B02 FD 43         mov [d], b
3713   1B04             ; --- END LOCAL VAR INITIALIZATION
3714   1B04             ; if (num < 0) { 
3715   1B04             _if51_cond:
3716   1B04 FA 07 00      lea d, [bp + 7] ; $num
3717   1B07 2A            mov b, [d]
3718   1B08 38 00 00      mov c, 0
3719   1B0B             ; --- START RELATIONAL
3720   1B0B D7            push a
3721   1B0C 11            mov a, b
3722   1B0D FD 2E 00 00   mov32 cb, $00000000
3722   1B11 00 00 
3723   1B13 B0            cmp a, b
3724   1B14 FD 73         slt ; < (signed)
3725   1B16 E4            pop a
3726   1B17             ; --- END RELATIONAL
3727   1B17 C0 00 00      cmp b, 0
3728   1B1A C6 5A 1B      je _if51_else
3729   1B1D             _if51_true:
3730   1B1D             ; *dest++ = '-'; 
3731   1B1D FA 05 00      lea d, [bp + 5] ; $dest
3732   1B20 2A            mov b, [d]
3733   1B21 38 00 00      mov c, 0
3734   1B24 FD 77         inc b
3735   1B26 FA 05 00      lea d, [bp + 5] ; $dest
3736   1B29 FD 43         mov [d], b
3737   1B2B FD 7D         dec b
3738   1B2D D8            push b
3739   1B2E FD 2E 2D 00   mov32 cb, $0000002d
3739   1B32 00 00 
3740   1B34 E7            pop d
3741   1B35 FD 3E         mov [d], bl
3742   1B37             ; num = -num; 
3743   1B37 FA 07 00      lea d, [bp + 7] ; $num
3744   1B3A DA            push d
3745   1B3B FA 07 00      lea d, [bp + 7] ; $num
3746   1B3E 2A            mov b, [d]
3747   1B3F 38 00 00      mov c, 0
3748   1B42 FD 97         neg b
3749   1B44 E7            pop d
3750   1B45 FD 43         mov [d], b
3751   1B47             ; len++; 
3752   1B47 FA F8 FF      lea d, [bp + -8] ; $len
3753   1B4A 2A            mov b, [d]
3754   1B4B 38 00 00      mov c, 0
3755   1B4E FD 77         inc b
3756   1B50 FA F8 FF      lea d, [bp + -8] ; $len
3757   1B53 FD 43         mov [d], b
3758   1B55 FD 7D         dec b
3759   1B57 0A A9 1B      jmp _if51_exit
3760   1B5A             _if51_else:
3761   1B5A             ; if (num == 0) { 
3762   1B5A             _if52_cond:
3763   1B5A FA 07 00      lea d, [bp + 7] ; $num
3764   1B5D 2A            mov b, [d]
3765   1B5E 38 00 00      mov c, 0
3766   1B61             ; --- START RELATIONAL
3767   1B61 D7            push a
3768   1B62 11            mov a, b
3769   1B63 FD 2E 00 00   mov32 cb, $00000000
3769   1B67 00 00 
3770   1B69 B0            cmp a, b
3771   1B6A FD 71         seq ; ==
3772   1B6C E4            pop a
3773   1B6D             ; --- END RELATIONAL
3774   1B6D C0 00 00      cmp b, 0
3775   1B70 C6 A9 1B      je _if52_exit
3776   1B73             _if52_true:
3777   1B73             ; *dest++ = '0'; 
3778   1B73 FA 05 00      lea d, [bp + 5] ; $dest
3779   1B76 2A            mov b, [d]
3780   1B77 38 00 00      mov c, 0
3781   1B7A FD 77         inc b
3782   1B7C FA 05 00      lea d, [bp + 5] ; $dest
3783   1B7F FD 43         mov [d], b
3784   1B81 FD 7D         dec b
3785   1B83 D8            push b
3786   1B84 FD 2E 30 00   mov32 cb, $00000030
3786   1B88 00 00 
3787   1B8A E7            pop d
3788   1B8B FD 3E         mov [d], bl
3789   1B8D             ; *dest = '\0'; 
3790   1B8D FA 05 00      lea d, [bp + 5] ; $dest
3791   1B90 2A            mov b, [d]
3792   1B91 38 00 00      mov c, 0
3793   1B94 D8            push b
3794   1B95 FD 2E 00 00   mov32 cb, $00000000
3794   1B99 00 00 
3795   1B9B E7            pop d
3796   1B9C FD 3E         mov [d], bl
3797   1B9E             ; return 1; 
3798   1B9E FD 2E 01 00   mov32 cb, $00000001
3798   1BA2 00 00 
3799   1BA4 F9            leave
3800   1BA5 09            ret
3801   1BA6 0A A9 1B      jmp _if52_exit
3802   1BA9             _if52_exit:
3803   1BA9             _if51_exit:
3804   1BA9             ; while (num > 0) { 
3805   1BA9             _while53_cond:
3806   1BA9 FA 07 00      lea d, [bp + 7] ; $num
3807   1BAC 2A            mov b, [d]
3808   1BAD 38 00 00      mov c, 0
3809   1BB0             ; --- START RELATIONAL
3810   1BB0 D7            push a
3811   1BB1 11            mov a, b
3812   1BB2 FD 2E 00 00   mov32 cb, $00000000
3812   1BB6 00 00 
3813   1BB8 B0            cmp a, b
3814   1BB9 FD 7F         sgt ; >
3815   1BBB E4            pop a
3816   1BBC             ; --- END RELATIONAL
3817   1BBC C0 00 00      cmp b, 0
3818   1BBF C6 1E 1C      je _while53_exit
3819   1BC2             _while53_block:
3820   1BC2             ; digits[i] = '0' + (num % 10); 
3821   1BC2 FA FC FF      lea d, [bp + -4] ; $digits
3822   1BC5 D7            push a
3823   1BC6 DA            push d
3824   1BC7 FA FA FF      lea d, [bp + -6] ; $i
3825   1BCA 2A            mov b, [d]
3826   1BCB 38 00 00      mov c, 0
3827   1BCE E7            pop d
3828   1BCF 5A            add d, b
3829   1BD0 E4            pop a
3830   1BD1 DA            push d
3831   1BD2 FD 2E 30 00   mov32 cb, $00000030
3831   1BD6 00 00 
3832   1BD8             ; --- START TERMS
3833   1BD8 D7            push a
3834   1BD9 11            mov a, b
3835   1BDA FA 07 00      lea d, [bp + 7] ; $num
3836   1BDD 2A            mov b, [d]
3837   1BDE 38 00 00      mov c, 0
3838   1BE1             ; --- START FACTORS
3839   1BE1 D7            push a
3840   1BE2 11            mov a, b
3841   1BE3 FD 2E 0A 00   mov32 cb, $0000000a
3841   1BE7 00 00 
3842   1BE9 AE            div a, b ; 
3843   1BEA 11            mov a, b
3844   1BEB 27            mov b, a
3845   1BEC E4            pop a
3846   1BED             ; --- END FACTORS
3847   1BED 56            add b, a
3848   1BEE E4            pop a
3849   1BEF             ; --- END TERMS
3850   1BEF E7            pop d
3851   1BF0 FD 3E         mov [d], bl
3852   1BF2             ; num = num / 10; 
3853   1BF2 FA 07 00      lea d, [bp + 7] ; $num
3854   1BF5 DA            push d
3855   1BF6 FA 07 00      lea d, [bp + 7] ; $num
3856   1BF9 2A            mov b, [d]
3857   1BFA 38 00 00      mov c, 0
3858   1BFD             ; --- START FACTORS
3859   1BFD D7            push a
3860   1BFE 11            mov a, b
3861   1BFF FD 2E 0A 00   mov32 cb, $0000000a
3861   1C03 00 00 
3862   1C05 AE            div a, b
3863   1C06 27            mov b, a
3864   1C07 E4            pop a
3865   1C08             ; --- END FACTORS
3866   1C08 E7            pop d
3867   1C09 FD 43         mov [d], b
3868   1C0B             ; i++; 
3869   1C0B FA FA FF      lea d, [bp + -6] ; $i
3870   1C0E 2A            mov b, [d]
3871   1C0F 38 00 00      mov c, 0
3872   1C12 FD 77         inc b
3873   1C14 FA FA FF      lea d, [bp + -6] ; $i
3874   1C17 FD 43         mov [d], b
3875   1C19 FD 7D         dec b
3876   1C1B 0A A9 1B      jmp _while53_cond
3877   1C1E             _while53_exit:
3878   1C1E             ; while (i > 0) { 
3879   1C1E             _while54_cond:
3880   1C1E FA FA FF      lea d, [bp + -6] ; $i
3881   1C21 2A            mov b, [d]
3882   1C22 38 00 00      mov c, 0
3883   1C25             ; --- START RELATIONAL
3884   1C25 D7            push a
3885   1C26 11            mov a, b
3886   1C27 FD 2E 00 00   mov32 cb, $00000000
3886   1C2B 00 00 
3887   1C2D B0            cmp a, b
3888   1C2E FD 7F         sgt ; >
3889   1C30 E4            pop a
3890   1C31             ; --- END RELATIONAL
3891   1C31 C0 00 00      cmp b, 0
3892   1C34 C6 83 1C      je _while54_exit
3893   1C37             _while54_block:
3894   1C37             ; i--; 
3895   1C37 FA FA FF      lea d, [bp + -6] ; $i
3896   1C3A 2A            mov b, [d]
3897   1C3B 38 00 00      mov c, 0
3898   1C3E FD 7D         dec b
3899   1C40 FA FA FF      lea d, [bp + -6] ; $i
3900   1C43 FD 43         mov [d], b
3901   1C45 FD 77         inc b
3902   1C47             ; *dest++ = digits[i]; 
3903   1C47 FA 05 00      lea d, [bp + 5] ; $dest
3904   1C4A 2A            mov b, [d]
3905   1C4B 38 00 00      mov c, 0
3906   1C4E FD 77         inc b
3907   1C50 FA 05 00      lea d, [bp + 5] ; $dest
3908   1C53 FD 43         mov [d], b
3909   1C55 FD 7D         dec b
3910   1C57 D8            push b
3911   1C58 FA FC FF      lea d, [bp + -4] ; $digits
3912   1C5B D7            push a
3913   1C5C DA            push d
3914   1C5D FA FA FF      lea d, [bp + -6] ; $i
3915   1C60 2A            mov b, [d]
3916   1C61 38 00 00      mov c, 0
3917   1C64 E7            pop d
3918   1C65 5A            add d, b
3919   1C66 E4            pop a
3920   1C67 32            mov bl, [d]
3921   1C68 A7 00         mov bh, 0
3922   1C6A 38 00 00      mov c, 0
3923   1C6D E7            pop d
3924   1C6E FD 3E         mov [d], bl
3925   1C70             ; len++; 
3926   1C70 FA F8 FF      lea d, [bp + -8] ; $len
3927   1C73 2A            mov b, [d]
3928   1C74 38 00 00      mov c, 0
3929   1C77 FD 77         inc b
3930   1C79 FA F8 FF      lea d, [bp + -8] ; $len
3931   1C7C FD 43         mov [d], b
3932   1C7E FD 7D         dec b
3933   1C80 0A 1E 1C      jmp _while54_cond
3934   1C83             _while54_exit:
3935   1C83             ; *dest = '\0'; 
3936   1C83 FA 05 00      lea d, [bp + 5] ; $dest
3937   1C86 2A            mov b, [d]
3938   1C87 38 00 00      mov c, 0
3939   1C8A D8            push b
3940   1C8B FD 2E 00 00   mov32 cb, $00000000
3940   1C8F 00 00 
3941   1C91 E7            pop d
3942   1C92 FD 3E         mov [d], bl
3943   1C94             ; return len; 
3944   1C94 FA F8 FF      lea d, [bp + -8] ; $len
3945   1C97 2A            mov b, [d]
3946   1C98 38 00 00      mov c, 0
3947   1C9B F9            leave
3948   1C9C 09            ret
3949   1C9D             
3950   1C9D             date:
3951   1C9D F8 00 00      enter 0 ; (push bp; mov bp, sp)
3952   1CA0             
3953   1CA0             ; --- BEGIN INLINE ASM SEGMENT
3954   1CA0 19 00         mov al, 0 
3955   1CA2 05 07         syscall sys_datetime
3956   1CA4             ; --- END INLINE ASM SEGMENT
3957   1CA4             
3958   1CA4 F9            leave
3959   1CA5 09            ret
3960   1CA6             
3961   1CA6             putchar:
3962   1CA6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3963   1CA9             
3964   1CA9             ; --- BEGIN INLINE ASM SEGMENT
3965   1CA9 FA 05 00      lea d, [bp + 5] ; $c
3966   1CAC 1E            mov al, [d]
3967   1CAD 23            mov ah, al
3968   1CAE 07 B5 1E      call _putchar
3969   1CB1             ; --- END INLINE ASM SEGMENT
3970   1CB1             
3971   1CB1 F9            leave
3972   1CB2 09            ret
3973   1CB3             
3974   1CB3             getchar:
3975   1CB3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3976   1CB6             ; char c; 
3977   1CB6 52 01 00      sub sp, 1
3978   1CB9             
3979   1CB9             ; --- BEGIN INLINE ASM SEGMENT
3980   1CB9 07 AE 1E      call getch
3981   1CBC 1A            mov al, ah
3982   1CBD FA 00 00      lea d, [bp + 0] ; $c
3983   1CC0 3E            mov [d], al
3984   1CC1             ; --- END INLINE ASM SEGMENT
3985   1CC1             
3986   1CC1             ; return c; 
3987   1CC1 FA 00 00      lea d, [bp + 0] ; $c
3988   1CC4 32            mov bl, [d]
3989   1CC5 A7 00         mov bh, 0
3990   1CC7 38 00 00      mov c, 0
3991   1CCA F9            leave
3992   1CCB 09            ret
3993   1CCC             
3994   1CCC             scann:
3995   1CCC F8 00 00      enter 0 ; (push bp; mov bp, sp)
3996   1CCF             ; int m; 
3997   1CCF 52 02 00      sub sp, 2
3998   1CD2             
3999   1CD2             ; --- BEGIN INLINE ASM SEGMENT
4000   1CD2 07 F9 20      call scan_u16d
4001   1CD5 FA FF FF      lea d, [bp + -1] ; $m
4002   1CD8 43            mov [d], a
4003   1CD9             ; --- END INLINE ASM SEGMENT
4004   1CD9             
4005   1CD9             ; return m; 
4006   1CD9 FA FF FF      lea d, [bp + -1] ; $m
4007   1CDC 2A            mov b, [d]
4008   1CDD 38 00 00      mov c, 0
4009   1CE0 F9            leave
4010   1CE1 09            ret
4011   1CE2             
4012   1CE2             puts:
4013   1CE2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4014   1CE5             
4015   1CE5             ; --- BEGIN INLINE ASM SEGMENT
4016   1CE5 FA 05 00      lea d, [bp + 5] ; $s
4017   1CE8 15            mov a, [d]
4018   1CE9 3C            mov d, a
4019   1CEA 07 FF 1F      call _puts
4020   1CED 10 00 0A      mov a, $0A00
4021   1CF0 05 03         syscall sys_io
4022   1CF2             ; --- END INLINE ASM SEGMENT
4023   1CF2             
4024   1CF2 F9            leave
4025   1CF3 09            ret
4026   1CF4             
4027   1CF4             print:
4028   1CF4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4029   1CF7             
4030   1CF7             ; --- BEGIN INLINE ASM SEGMENT
4031   1CF7 FA 05 00      lea d, [bp + 5] ; $s
4032   1CFA FD 2A         mov d, [d]
4033   1CFC 07 FF 1F      call _puts
4034   1CFF             ; --- END INLINE ASM SEGMENT
4035   1CFF             
4036   1CFF F9            leave
4037   1D00 09            ret
4038   1D01             
4039   1D01             getparam:
4040   1D01 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4041   1D04             ; char data; 
4042   1D04 52 01 00      sub sp, 1
4043   1D07             
4044   1D07             ; --- BEGIN INLINE ASM SEGMENT
4045   1D07 19 04         mov al, 4
4046   1D09 FA 05 00      lea d, [bp + 5] ; $address
4047   1D0C FD 2A         mov d, [d]
4048   1D0E 05 0C         syscall sys_system
4049   1D10 FA 00 00      lea d, [bp + 0] ; $data
4050   1D13 FD 3E         mov [d], bl
4051   1D15             ; --- END INLINE ASM SEGMENT
4052   1D15             
4053   1D15             ; return data; 
4054   1D15 FA 00 00      lea d, [bp + 0] ; $data
4055   1D18 32            mov bl, [d]
4056   1D19 A7 00         mov bh, 0
4057   1D1B 38 00 00      mov c, 0
4058   1D1E F9            leave
4059   1D1F 09            ret
4060   1D20             
4061   1D20             clear:
4062   1D20 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4063   1D23             ; print("\033[2J\033[H"); 
4064   1D23             ; --- START FUNCTION CALL
4065   1D23 26 95 21      mov b, _s2 ; "\033[2J\033[H"
4066   1D26 FD AB         swp b
4067   1D28 D8            push b
4068   1D29 07 F4 1C      call print
4069   1D2C 51 02 00      add sp, 2
4070   1D2F             ; --- END FUNCTION CALL
4071   1D2F F9            leave
4072   1D30 09            ret
4073   1D31             
4074   1D31             abs:
4075   1D31 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4076   1D34             ; return i < 0 ? -i : i; 
4077   1D34             _ternary55_cond:
4078   1D34 FA 05 00      lea d, [bp + 5] ; $i
4079   1D37 2A            mov b, [d]
4080   1D38 38 00 00      mov c, 0
4081   1D3B             ; --- START RELATIONAL
4082   1D3B D7            push a
4083   1D3C 11            mov a, b
4084   1D3D FD 2E 00 00   mov32 cb, $00000000
4084   1D41 00 00 
4085   1D43 B0            cmp a, b
4086   1D44 FD 73         slt ; < (signed)
4087   1D46 E4            pop a
4088   1D47             ; --- END RELATIONAL
4089   1D47 C0 00 00      cmp b, 0
4090   1D4A C6 59 1D      je _ternary55_false
4091   1D4D             _ternary55_true:
4092   1D4D FA 05 00      lea d, [bp + 5] ; $i
4093   1D50 2A            mov b, [d]
4094   1D51 38 00 00      mov c, 0
4095   1D54 FD 97         neg b
4096   1D56 0A 60 1D      jmp _ternary55_exit
4097   1D59             _ternary55_false:
4098   1D59 FA 05 00      lea d, [bp + 5] ; $i
4099   1D5C 2A            mov b, [d]
4100   1D5D 38 00 00      mov c, 0
4101   1D60             _ternary55_exit:
4102   1D60 F9            leave
4103   1D61 09            ret
4104   1D62             
4105   1D62             loadfile:
4106   1D62 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4107   1D65             
4108   1D65             ; --- BEGIN INLINE ASM SEGMENT
4109   1D65 FA 07 00      lea d, [bp + 7] ; $destination
4110   1D68 15            mov a, [d]
4111   1D69 4F            mov di, a
4112   1D6A FA 05 00      lea d, [bp + 5] ; $filename
4113   1D6D FD 2A         mov d, [d]
4114   1D6F 19 14         mov al, 20
4115   1D71 05 04         syscall sys_filesystem
4116   1D73             ; --- END INLINE ASM SEGMENT
4117   1D73             
4118   1D73 F9            leave
4119   1D74 09            ret
4120   1D75             
4121   1D75             create_file:
4122   1D75 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4123   1D78 F9            leave
4124   1D79 09            ret
4125   1D7A             
4126   1D7A             delete_file:
4127   1D7A F8 00 00      enter 0 ; (push bp; mov bp, sp)
4128   1D7D             
4129   1D7D             ; --- BEGIN INLINE ASM SEGMENT
4130   1D7D FA 05 00      lea d, [bp + 5] ; $filename
4131   1D80 19 0A         mov al, 10
4132   1D82 05 04         syscall sys_filesystem
4133   1D84             ; --- END INLINE ASM SEGMENT
4134   1D84             
4135   1D84 F9            leave
4136   1D85 09            ret
4137   1D86             
4138   1D86             load_hex:
4139   1D86 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4140   1D89             ; char *temp; 
4141   1D89 52 02 00      sub sp, 2
4142   1D8C             ; temp = alloc(32768); 
4143   1D8C FA FF FF      lea d, [bp + -1] ; $temp
4144   1D8F DA            push d
4145   1D90             ; --- START FUNCTION CALL
4146   1D90 FD 2E 00 80   mov32 cb, $00008000
4146   1D94 00 00 
4147   1D96 FD AB         swp b
4148   1D98 D8            push b
4149   1D99 07 55 08      call alloc
4150   1D9C 51 02 00      add sp, 2
4151   1D9F             ; --- END FUNCTION CALL
4152   1D9F E7            pop d
4153   1DA0 FD 43         mov [d], b
4154   1DA2             
4155   1DA2             ; --- BEGIN INLINE ASM SEGMENT
4156   1DA2               
4157   1DA2               
4158   1DA2               
4159   1DA2             _load_hex:
4160   1DA2 FA 05 00      lea d, [bp + 5] ; $destination
4161   1DA5 FD 2A         mov d, [d]
4162   1DA7 FD 50         mov di, d
4163   1DA9 FA FF FF      lea d, [bp + -1] ; $temp
4164   1DAC FD 2A         mov d, [d]
4165   1DAE 38 00 00      mov c, 0
4166   1DB1 48            mov a, sp
4167   1DB2 77            inc a
4168   1DB3 3C            mov d, a          
4169   1DB4 07 BC 1E      call _gets        
4170   1DB7 4D            mov si, a
4171   1DB8             __load_hex_loop:
4172   1DB8 F6            lodsb             
4173   1DB9 B9 00         cmp al, 0         
4174   1DBB C6 C9 1D      jz __load_hex_ret
4175   1DBE 36            mov bh, al
4176   1DBF F6            lodsb
4177   1DC0 2F            mov bl, al
4178   1DC1 07 73 1E      call _atoi        
4179   1DC4 F7            stosb             
4180   1DC5 78            inc c
4181   1DC6 0A B8 1D      jmp __load_hex_loop
4182   1DC9             __load_hex_ret:
4183   1DC9             ; --- END INLINE ASM SEGMENT
4184   1DC9             
4185   1DC9 F9            leave
4186   1DCA 09            ret
4187   1DCB             
4188   1DCB             include_stdio_asm:
4189   1DCB F8 00 00      enter 0 ; (push bp; mov bp, sp)
4190   1DCE             
4191   1DCE             ; --- BEGIN INLINE ASM SEGMENT
4192   1DCE             .include "lib/asm/stdio.asm"
0001+  1DCE             ;-----------------------------------------------------------------------------
0002+  1DCE             ; stdio.s
0003+  1DCE             ;-----------------------------------------------------------------------------
0004+  1DCE             .include "lib/asm/string.asm"
0001++ 1DCE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 1DCE             ; string.s
0003++ 1DCE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 1DCE             
0005++ 1DCE             
0006++ 1DCE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 1DCE             ; _strrev
0008++ 1DCE             ; reverse a string
0009++ 1DCE             ; D = string address
0010++ 1DCE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 1DCE             ; 01234
0012++ 1DCE             _strrev:
0013++ 1DCE 4B          	pusha
0014++ 1DCF 07 15 1E    	call _strlen	; length in C
0015++ 1DD2 12          	mov a, c
0016++ 1DD3 AF 01 00    	cmp a, 1
0017++ 1DD6 D0 F0 1D    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 1DD9 7D          	dec a
0019++ 1DDA FD 4E       	mov si, d	; beginning of string
0020++ 1DDC FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 1DDE 59          	add d, a	; end of string
0022++ 1DDF 12          	mov a, c
0023++ 1DE0 FD 9B       	shr a		; divide by 2
0024++ 1DE2 39          	mov c, a	; C now counts the steps
0025++ 1DE3             _strrev_L0:
0026++ 1DE3 32          	mov bl, [d]	; save load right-side char into BL
0027++ 1DE4 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 1DE5 3E          	mov [d], al	; store left char into right side
0029++ 1DE6 1B          	mov al, bl
0030++ 1DE7 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 1DE8 7E          	dec c
0032++ 1DE9 7F          	dec d
0033++ 1DEA C2 00 00    	cmp c, 0
0034++ 1DED C7 E3 1D    	jne _strrev_L0
0035++ 1DF0             _strrev_end:
0036++ 1DF0 4C          	popa
0037++ 1DF1 09          	ret
0038++ 1DF2             	
0039++ 1DF2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 1DF2             ; _strchr
0041++ 1DF2             ; search string in D for char in AL
0042++ 1DF2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 1DF2             _strchr:
0044++ 1DF2             _strchr_L0:
0045++ 1DF2 32          	mov bl, [d]
0046++ 1DF3 C1 00       	cmp bl, 0
0047++ 1DF5 C6 00 1E    	je _strchr_end
0048++ 1DF8 BA          	cmp al, bl
0049++ 1DF9 C6 00 1E    	je _strchr_end
0050++ 1DFC 79          	inc d
0051++ 1DFD 0A F2 1D    	jmp _strchr_L0
0052++ 1E00             _strchr_end:
0053++ 1E00 1B          	mov al, bl
0054++ 1E01 09          	ret
0055++ 1E02             
0056++ 1E02             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 1E02             ; _strstr
0058++ 1E02             ; find sub-string
0059++ 1E02             ; str1 in SI
0060++ 1E02             ; str2 in DI
0061++ 1E02             ; SI points to end of source string
0062++ 1E02             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 1E02             _strstr:
0064++ 1E02 DB          	push al
0065++ 1E03 DA          	push d
0066++ 1E04 E3          	push di
0067++ 1E05             _strstr_loop:
0068++ 1E05 F3          	cmpsb					; compare a byte of the strings
0069++ 1E06 C7 11 1E    	jne _strstr_ret
0070++ 1E09 FC 00 00    	lea d, [di + 0]
0071++ 1E0C BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1E0E C7 05 1E    	jne _strstr_loop				; equal chars but not at end
0073++ 1E11             _strstr_ret:
0074++ 1E11 F0          	pop di
0075++ 1E12 E7          	pop d
0076++ 1E13 E8          	pop al
0077++ 1E14 09          	ret
0078++ 1E15             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1E15             ; length of null terminated string
0080++ 1E15             ; result in C
0081++ 1E15             ; pointer in D
0082++ 1E15             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1E15             _strlen:
0084++ 1E15 DA          	push d
0085++ 1E16 38 00 00    	mov c, 0
0086++ 1E19             _strlen_L1:
0087++ 1E19 BD 00       	cmp byte [d], 0
0088++ 1E1B C6 23 1E    	je _strlen_ret
0089++ 1E1E 79          	inc d
0090++ 1E1F 78          	inc c
0091++ 1E20 0A 19 1E    	jmp _strlen_L1
0092++ 1E23             _strlen_ret:
0093++ 1E23 E7          	pop d
0094++ 1E24 09          	ret
0095++ 1E25             
0096++ 1E25             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1E25             ; STRCMP
0098++ 1E25             ; compare two strings
0099++ 1E25             ; str1 in SI
0100++ 1E25             ; str2 in DI
0101++ 1E25             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 1E25             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1E25             _strcmp:
0104++ 1E25 DB          	push al
0105++ 1E26 DA          	push d
0106++ 1E27 E3          	push di
0107++ 1E28 E2          	push si
0108++ 1E29             _strcmp_loop:
0109++ 1E29 F3          	cmpsb					; compare a byte of the strings
0110++ 1E2A C7 35 1E    	jne _strcmp_ret
0111++ 1E2D FB FF FF    	lea d, [si +- 1]
0112++ 1E30 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1E32 C7 29 1E    	jne _strcmp_loop				; equal chars but not at end
0114++ 1E35             _strcmp_ret:
0115++ 1E35 EF          	pop si
0116++ 1E36 F0          	pop di
0117++ 1E37 E7          	pop d
0118++ 1E38 E8          	pop al
0119++ 1E39 09          	ret
0120++ 1E3A             
0121++ 1E3A             
0122++ 1E3A             ; STRCPY
0123++ 1E3A             ; copy null terminated string from SI to DI
0124++ 1E3A             ; source in SI
0125++ 1E3A             ; destination in DI
0126++ 1E3A             _strcpy:
0127++ 1E3A E2          	push si
0128++ 1E3B E3          	push di
0129++ 1E3C DB          	push al
0130++ 1E3D             _strcpy_L1:
0131++ 1E3D F6          	lodsb
0132++ 1E3E F7          	stosb
0133++ 1E3F B9 00       	cmp al, 0
0134++ 1E41 C7 3D 1E    	jne _strcpy_L1
0135++ 1E44             _strcpy_end:
0136++ 1E44 E8          	pop al
0137++ 1E45 F0          	pop di
0138++ 1E46 EF          	pop si
0139++ 1E47 09          	ret
0140++ 1E48             
0141++ 1E48             ; STRCAT
0142++ 1E48             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 1E48             ; source in SI
0144++ 1E48             ; destination in DI
0145++ 1E48             _strcat:
0146++ 1E48 E2          	push si
0147++ 1E49 E3          	push di
0148++ 1E4A D7          	push a
0149++ 1E4B DA          	push d
0150++ 1E4C 50          	mov a, di
0151++ 1E4D 3C          	mov d, a
0152++ 1E4E             _strcat_goto_end_L1:
0153++ 1E4E BD 00       	cmp byte[d], 0
0154++ 1E50 C6 57 1E    	je _strcat_start
0155++ 1E53 79          	inc d
0156++ 1E54 0A 4E 1E    	jmp _strcat_goto_end_L1
0157++ 1E57             _strcat_start:
0158++ 1E57 FD 50       	mov di, d
0159++ 1E59             _strcat_L1:
0160++ 1E59 F6          	lodsb
0161++ 1E5A F7          	stosb
0162++ 1E5B B9 00       	cmp al, 0
0163++ 1E5D C7 59 1E    	jne _strcat_L1
0164++ 1E60             _strcat_end:
0165++ 1E60 E7          	pop d
0166++ 1E61 E4          	pop a
0167++ 1E62 F0          	pop di
0168++ 1E63 EF          	pop si
0169++ 1E64 09          	ret
0170++ 1E65             
0171++ 1E65             
0005+  1E65             
0006+  1E65             ;-----------------------------------------------------------------------------
0007+  1E65             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0008+  1E65             ; ASCII in BL
0009+  1E65             ; result in AL
0010+  1E65             ; ascii for F = 0100 0110
0011+  1E65             ; ascii for 9 = 0011 1001
0012+  1E65             ;-----------------------------------------------------------------------------
0013+  1E65             hex_ascii_encode:
0014+  1E65 1B            mov al, bl
0015+  1E66 93 40         test al, $40        ; test if letter or number
0016+  1E68 C7 6E 1E      jnz hex_letter
0017+  1E6B 87 0F         and al, $0F        ; get number
0018+  1E6D 09            ret
0019+  1E6E             hex_letter:
0020+  1E6E 87 0F         and al, $0F        ; get letter
0021+  1E70 6A 09         add al, 9
0022+  1E72 09            ret
0023+  1E73             
0024+  1E73             ;-----------------------------------------------------------------------------
0025+  1E73             ; ATOI
0026+  1E73             ; 2 letter hex string in B
0027+  1E73             ; 8bit integer returned in AL
0028+  1E73             ;-----------------------------------------------------------------------------
0029+  1E73             _atoi:
0030+  1E73 D8            push b
0031+  1E74 07 65 1E      call hex_ascii_encode      ; convert BL to 4bit code in AL
0032+  1E77 30            mov bl, bh
0033+  1E78 DB            push al          ; save a
0034+  1E79 07 65 1E      call hex_ascii_encode
0035+  1E7C EA            pop bl  
0036+  1E7D FD 9E 04      shl al, 4
0037+  1E80 8C            or al, bl
0038+  1E81 E5            pop b
0039+  1E82 09            ret  
0040+  1E83             
0041+  1E83             
0042+  1E83             ;-----------------------------------------------------------------------------
0043+  1E83             ; ITOA
0044+  1E83             ; 8bit value in BL
0045+  1E83             ; 2 byte ASCII result in A
0046+  1E83             ;-----------------------------------------------------------------------------
0047+  1E83             _itoa:
0048+  1E83 DA            push d
0049+  1E84 D8            push b
0050+  1E85 A7 00         mov bh, 0
0051+  1E87 FD A4 04      shr bl, 4  
0052+  1E8A 74            mov d, b
0053+  1E8B 1F 33 21      mov al, [d + s_hex_digits]
0054+  1E8E 23            mov ah, al
0055+  1E8F               
0056+  1E8F E5            pop b
0057+  1E90 D8            push b
0058+  1E91 A7 00         mov bh, 0
0059+  1E93 FD 87 0F      and bl, $0F
0060+  1E96 74            mov d, b
0061+  1E97 1F 33 21      mov al, [d + s_hex_digits]
0062+  1E9A E5            pop b
0063+  1E9B E7            pop d
0064+  1E9C 09            ret
0065+  1E9D             
0066+  1E9D             ;-----------------------------------------------------------------------------
0067+  1E9D             ; HEX STRING TO BINARY
0068+  1E9D             ; di = destination address
0069+  1E9D             ; si = source
0070+  1E9D             ;-----------------------------------------------------------------------------
0071+  1E9D             _hex_to_int:
0072+  1E9D             _hex_to_int_L1:
0073+  1E9D F6            lodsb          ; load from [SI] to AL
0074+  1E9E B9 00         cmp al, 0        ; check if ASCII 0
0075+  1EA0 C6 AD 1E      jz _hex_to_int_ret
0076+  1EA3 36            mov bh, al
0077+  1EA4 F6            lodsb
0078+  1EA5 2F            mov bl, al
0079+  1EA6 07 73 1E      call _atoi        ; convert ASCII byte in B to int (to AL)
0080+  1EA9 F7            stosb          ; store AL to [DI]
0081+  1EAA 0A 9D 1E      jmp _hex_to_int_L1
0082+  1EAD             _hex_to_int_ret:
0083+  1EAD 09            ret    
0084+  1EAE             
0085+  1EAE             ;-----------------------------------------------------------------------------
0086+  1EAE             ; GETCHAR
0087+  1EAE             ; char in ah
0088+  1EAE             ;-----------------------------------------------------------------------------
0089+  1EAE             getch:
0090+  1EAE DB            push al
0091+  1EAF             getch_retry:
0092+  1EAF 19 01         mov al, 1
0093+  1EB1 05 03         syscall sys_io      ; receive in AH
0094+  1EB3 E8            pop al
0095+  1EB4 09            ret
0096+  1EB5             
0097+  1EB5             ;-----------------------------------------------------------------------------
0098+  1EB5             ; PUTCHAR
0099+  1EB5             ; char in ah
0100+  1EB5             ;-----------------------------------------------------------------------------
0101+  1EB5             _putchar:
0102+  1EB5 D7            push a
0103+  1EB6 19 00         mov al, 0
0104+  1EB8 05 03         syscall sys_io      ; char in AH
0105+  1EBA E4            pop a
0106+  1EBB 09            ret
0107+  1EBC             
0108+  1EBC             ;-----------------------------------------------------------------------------
0109+  1EBC             ;; INPUT A STRING
0110+  1EBC             ;; terminates with null
0111+  1EBC             ;; pointer in D
0112+  1EBC             ;-----------------------------------------------------------------------------
0113+  1EBC             _gets:
0114+  1EBC D7            push a
0115+  1EBD DA            push d
0116+  1EBE             _gets_loop:
0117+  1EBE 19 01         mov al, 1
0118+  1EC0 05 03         syscall sys_io      ; receive in AH
0119+  1EC2 B9 00         cmp al, 0        ; check error code (AL)
0120+  1EC4 C6 BE 1E      je _gets_loop      ; if no char received, retry
0121+  1EC7             
0122+  1EC7 76 1B         cmp ah, 27
0123+  1EC9 C6 EA 1E      je _gets_ansi_esc
0124+  1ECC 76 0A         cmp ah, $0A        ; LF
0125+  1ECE C6 55 1F      je _gets_end
0126+  1ED1 76 0D         cmp ah, $0D        ; CR
0127+  1ED3 C6 55 1F      je _gets_end
0128+  1ED6 76 5C         cmp ah, $5C        ; '\\'
0129+  1ED8 C6 16 1F      je _gets_escape
0130+  1EDB               
0131+  1EDB 76 08         cmp ah, $08      ; check for backspace
0132+  1EDD C6 E6 1E      je _gets_backspace
0133+  1EE0             
0134+  1EE0 1A            mov al, ah
0135+  1EE1 3E            mov [d], al
0136+  1EE2 79            inc d
0137+  1EE3 0A BE 1E      jmp _gets_loop
0138+  1EE6             _gets_backspace:
0139+  1EE6 7F            dec d
0140+  1EE7 0A BE 1E      jmp _gets_loop
0141+  1EEA             _gets_ansi_esc:
0142+  1EEA 19 01         mov al, 1
0143+  1EEC 05 03         syscall sys_io        ; receive in AH without echo
0144+  1EEE B9 00         cmp al, 0          ; check error code (AL)
0145+  1EF0 C6 EA 1E      je _gets_ansi_esc    ; if no char received, retry
0146+  1EF3 76 5B         cmp ah, '['
0147+  1EF5 C7 BE 1E      jne _gets_loop
0148+  1EF8             _gets_ansi_esc_2:
0149+  1EF8 19 01         mov al, 1
0150+  1EFA 05 03         syscall sys_io          ; receive in AH without echo
0151+  1EFC B9 00         cmp al, 0            ; check error code (AL)
0152+  1EFE C6 F8 1E      je _gets_ansi_esc_2  ; if no char received, retry
0153+  1F01 76 44         cmp ah, 'D'
0154+  1F03 C6 0E 1F      je _gets_left_arrow
0155+  1F06 76 43         cmp ah, 'C'
0156+  1F08 C6 12 1F      je _gets_right_arrow
0157+  1F0B 0A BE 1E      jmp _gets_loop
0158+  1F0E             _gets_left_arrow:
0159+  1F0E 7F            dec d
0160+  1F0F 0A BE 1E      jmp _gets_loop
0161+  1F12             _gets_right_arrow:
0162+  1F12 79            inc d
0163+  1F13 0A BE 1E      jmp _gets_loop
0164+  1F16             _gets_escape:
0165+  1F16 19 01         mov al, 1
0166+  1F18 05 03         syscall sys_io      ; receive in AH
0167+  1F1A B9 00         cmp al, 0        ; check error code (AL)
0168+  1F1C C6 16 1F      je _gets_escape      ; if no char received, retry
0169+  1F1F 76 6E         cmp ah, 'n'
0170+  1F21 C6 40 1F      je _gets_LF
0171+  1F24 76 72         cmp ah, 'r'
0172+  1F26 C6 47 1F      je _gets_CR
0173+  1F29 76 30         cmp ah, '0'
0174+  1F2B C6 4E 1F      je _gets_NULL
0175+  1F2E 76 5C         cmp ah, $5C  ; '\'
0176+  1F30 C6 39 1F      je _gets_slash
0177+  1F33 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0178+  1F34 3E            mov [d], al
0179+  1F35 79            inc d
0180+  1F36 0A BE 1E      jmp _gets_loop
0181+  1F39             _gets_slash:
0182+  1F39 19 5C         mov al, $5C
0183+  1F3B 3E            mov [d], al
0184+  1F3C 79            inc d
0185+  1F3D 0A BE 1E      jmp _gets_loop
0186+  1F40             _gets_LF:
0187+  1F40 19 0A         mov al, $0A
0188+  1F42 3E            mov [d], al
0189+  1F43 79            inc d
0190+  1F44 0A BE 1E      jmp _gets_loop
0191+  1F47             _gets_CR:
0192+  1F47 19 0D         mov al, $0D
0193+  1F49 3E            mov [d], al
0194+  1F4A 79            inc d
0195+  1F4B 0A BE 1E      jmp _gets_loop
0196+  1F4E             _gets_NULL:
0197+  1F4E 19 00         mov al, $00
0198+  1F50 3E            mov [d], al
0199+  1F51 79            inc d
0200+  1F52 0A BE 1E      jmp _gets_loop
0201+  1F55             _gets_end:
0202+  1F55 19 00         mov al, 0
0203+  1F57 3E            mov [d], al        ; terminate string
0204+  1F58 E7            pop d
0205+  1F59 E4            pop a
0206+  1F5A 09            ret
0207+  1F5B             
0208+  1F5B             ;-----------------------------------------------------------------------------
0209+  1F5B             ;; INPUT TEXT
0210+  1F5B             ;; terminated with CTRL+D
0211+  1F5B             ;; pointer in D
0212+  1F5B             ;-----------------------------------------------------------------------------
0213+  1F5B             _gettxt:
0214+  1F5B D7            push a
0215+  1F5C DA            push d
0216+  1F5D             _gettxt_loop:
0217+  1F5D 19 01         mov al, 1
0218+  1F5F 05 03         syscall sys_io      ; receive in AH
0219+  1F61 B9 00         cmp al, 0        ; check error code (AL)
0220+  1F63 C6 5D 1F      je _gettxt_loop    ; if no char received, retry
0221+  1F66 76 04         cmp ah, 4      ; EOT
0222+  1F68 C6 A6 1F      je _gettxt_end
0223+  1F6B 76 08         cmp ah, $08      ; check for backspace
0224+  1F6D C6 A2 1F      je _gettxt_backspace
0225+  1F70 76 5C         cmp ah, $5C        ; '\'
0226+  1F72 C6 7B 1F      je _gettxt_escape
0227+  1F75 1A            mov al, ah
0228+  1F76 3E            mov [d], al
0229+  1F77 79            inc d
0230+  1F78 0A 5D 1F      jmp _gettxt_loop
0231+  1F7B             _gettxt_escape:
0232+  1F7B 19 01         mov al, 1
0233+  1F7D 05 03         syscall sys_io      ; receive in AH
0234+  1F7F B9 00         cmp al, 0        ; check error code (AL)
0235+  1F81 C6 7B 1F      je _gettxt_escape    ; if no char received, retry
0236+  1F84 76 6E         cmp ah, 'n'
0237+  1F86 C6 94 1F      je _gettxt_LF
0238+  1F89 76 72         cmp ah, 'r'
0239+  1F8B C6 9B 1F      je _gettxt_CR
0240+  1F8E 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0241+  1F8F 3E            mov [d], al
0242+  1F90 79            inc d
0243+  1F91 0A 5D 1F      jmp _gettxt_loop
0244+  1F94             _gettxt_LF:
0245+  1F94 19 0A         mov al, $0A
0246+  1F96 3E            mov [d], al
0247+  1F97 79            inc d
0248+  1F98 0A 5D 1F      jmp _gettxt_loop
0249+  1F9B             _gettxt_CR:
0250+  1F9B 19 0D         mov al, $0D
0251+  1F9D 3E            mov [d], al
0252+  1F9E 79            inc d
0253+  1F9F 0A 5D 1F      jmp _gettxt_loop
0254+  1FA2             _gettxt_backspace:
0255+  1FA2 7F            dec d
0256+  1FA3 0A 5D 1F      jmp _gettxt_loop
0257+  1FA6             _gettxt_end:
0258+  1FA6 19 00         mov al, 0
0259+  1FA8 3E            mov [d], al        ; terminate string
0260+  1FA9 E7            pop d
0261+  1FAA E4            pop a
0262+  1FAB 09            ret
0263+  1FAC             
0264+  1FAC             ;-----------------------------------------------------------------------------
0265+  1FAC             ; PRINT NEW LINE
0266+  1FAC             ;-----------------------------------------------------------------------------
0267+  1FAC             printnl:
0268+  1FAC D7            push a
0269+  1FAD 10 00 0A      mov a, $0A00
0270+  1FB0 05 03         syscall sys_io
0271+  1FB2 10 00 0D      mov a, $0D00
0272+  1FB5 05 03         syscall sys_io
0273+  1FB7 E4            pop a
0274+  1FB8 09            ret
0275+  1FB9             
0276+  1FB9             ;-----------------------------------------------------------------------------
0277+  1FB9             ; _strtoint
0278+  1FB9             ; 4 digit hex string number in d
0279+  1FB9             ; integer returned in A
0280+  1FB9             ;-----------------------------------------------------------------------------
0281+  1FB9             _strtointx:
0282+  1FB9 D8            push b
0283+  1FBA 32            mov bl, [d]
0284+  1FBB 37            mov bh, bl
0285+  1FBC 33 01 00      mov bl, [d + 1]
0286+  1FBF 07 73 1E      call _atoi        ; convert to int in AL
0287+  1FC2 23            mov ah, al        ; move to AH
0288+  1FC3 33 02 00      mov bl, [d + 2]
0289+  1FC6 37            mov bh, bl
0290+  1FC7 33 03 00      mov bl, [d + 3]
0291+  1FCA 07 73 1E      call _atoi        ; convert to int in AL
0292+  1FCD E5            pop b
0293+  1FCE 09            ret
0294+  1FCF             
0295+  1FCF             ;-----------------------------------------------------------------------------
0296+  1FCF             ; _strtoint
0297+  1FCF             ; 5 digit base10 string number in d
0298+  1FCF             ; integer returned in A
0299+  1FCF             ;-----------------------------------------------------------------------------
0300+  1FCF             _strtoint:
0301+  1FCF E2            push si
0302+  1FD0 D8            push b
0303+  1FD1 D9            push c
0304+  1FD2 DA            push d
0305+  1FD3 07 15 1E      call _strlen      ; get string length in C
0306+  1FD6 7E            dec c
0307+  1FD7 FD 4E         mov si, d
0308+  1FD9 12            mov a, c
0309+  1FDA FD 99         shl a
0310+  1FDC 3B 4B 21      mov d, table_power
0311+  1FDF 59            add d, a
0312+  1FE0 38 00 00      mov c, 0
0313+  1FE3             _strtoint_L0:
0314+  1FE3 F6            lodsb      ; load ASCII to al
0315+  1FE4 B9 00         cmp al, 0
0316+  1FE6 C6 F9 1F      je _strtoint_end
0317+  1FE9 6F 30         sub al, $30    ; make into integer
0318+  1FEB 22 00         mov ah, 0
0319+  1FED 2A            mov b, [d]
0320+  1FEE AC            mul a, b      ; result in B since it fits in 16bits
0321+  1FEF 11            mov a, b
0322+  1FF0 28            mov b, c
0323+  1FF1 54            add a, b
0324+  1FF2 39            mov c, a
0325+  1FF3 63 02 00      sub d, 2
0326+  1FF6 0A E3 1F      jmp _strtoint_L0
0327+  1FF9             _strtoint_end:
0328+  1FF9 12            mov a, c
0329+  1FFA E7            pop d
0330+  1FFB E6            pop c
0331+  1FFC E5            pop b
0332+  1FFD EF            pop si
0333+  1FFE 09            ret
0334+  1FFF             
0335+  1FFF             ;-----------------------------------------------------------------------------
0336+  1FFF             ; PRINT NULL TERMINATED STRING
0337+  1FFF             ; pointer in D
0338+  1FFF             ;-----------------------------------------------------------------------------
0339+  1FFF             _puts:
0340+  1FFF D7            push a
0341+  2000 DA            push d
0342+  2001             _puts_L1:
0343+  2001 1E            mov al, [d]
0344+  2002 B9 00         cmp al, 0
0345+  2004 C6 10 20      jz _puts_END
0346+  2007 23            mov ah, al
0347+  2008 19 00         mov al, 0
0348+  200A 05 03         syscall sys_io
0349+  200C 79            inc d
0350+  200D 0A 01 20      jmp _puts_L1
0351+  2010             _puts_END:
0352+  2010 E7            pop d
0353+  2011 E4            pop a
0354+  2012 09            ret
0355+  2013             
0356+  2013             ;-----------------------------------------------------------------------------
0357+  2013             ; PRINT N SIZE STRING
0358+  2013             ; pointer in D
0359+  2013             ; size in C
0360+  2013             ;-----------------------------------------------------------------------------
0361+  2013             _putsn:
0362+  2013 DB            push al
0363+  2014 DA            push d
0364+  2015 D9            push c
0365+  2016             _putsn_L0:
0366+  2016 1E            mov al, [d]
0367+  2017 23            mov ah, al
0368+  2018 19 00         mov al, 0
0369+  201A 05 03         syscall sys_io
0370+  201C 79            inc d
0371+  201D 7E            dec c  
0372+  201E C2 00 00      cmp c, 0
0373+  2021 C7 16 20      jne _putsn_L0
0374+  2024             _putsn_end:
0375+  2024 E6            pop c
0376+  2025 E7            pop d
0377+  2026 E8            pop al
0378+  2027 09            ret
0379+  2028             
0380+  2028             ;-----------------------------------------------------------------------------
0381+  2028             ; print 16bit decimal number
0382+  2028             ; input number in A
0383+  2028             ;-----------------------------------------------------------------------------
0384+  2028             print_u16d:
0385+  2028 D7            push a
0386+  2029 D8            push b
0387+  202A 26 10 27      mov b, 10000
0388+  202D AE            div a, b      ; get 10000's coeff.
0389+  202E 07 50 20      call print_number
0390+  2031 11            mov a, b
0391+  2032 26 E8 03      mov b, 1000
0392+  2035 AE            div a, b      ; get 1000's coeff.
0393+  2036 07 50 20      call print_number
0394+  2039 11            mov a, b
0395+  203A 26 64 00      mov b, 100
0396+  203D AE            div a, b
0397+  203E 07 50 20      call print_number
0398+  2041 11            mov a, b
0399+  2042 26 0A 00      mov b, 10
0400+  2045 AE            div a, b
0401+  2046 07 50 20      call print_number
0402+  2049 1B            mov al, bl      ; 1's coeff in bl
0403+  204A 07 50 20      call print_number
0404+  204D E5            pop b
0405+  204E E4            pop a
0406+  204F 09            ret
0407+  2050             
0408+  2050             ;-----------------------------------------------------------------------------
0409+  2050             ; print AL
0410+  2050             ;-----------------------------------------------------------------------------
0411+  2050             print_number:
0412+  2050 6A 30         add al, $30
0413+  2052 23            mov ah, al
0414+  2053 07 B5 1E      call _putchar
0415+  2056 09            ret
0416+  2057             
0417+  2057             ;-----------------------------------------------------------------------------
0418+  2057             ; PRINT 16BIT HEX INTEGER
0419+  2057             ; integer value in reg B
0420+  2057             ;-----------------------------------------------------------------------------
0421+  2057             print_u16x:
0422+  2057 D7            push a
0423+  2058 D8            push b
0424+  2059 DD            push bl
0425+  205A 30            mov bl, bh
0426+  205B 07 83 1E      call _itoa        ; convert bh to char in A
0427+  205E 2F            mov bl, al        ; save al
0428+  205F 19 00         mov al, 0
0429+  2061 05 03         syscall sys_io        ; display AH
0430+  2063 24            mov ah, bl        ; retrieve al
0431+  2064 19 00         mov al, 0
0432+  2066 05 03         syscall sys_io        ; display AL
0433+  2068             
0434+  2068 EA            pop bl
0435+  2069 07 83 1E      call _itoa        ; convert bh to char in A
0436+  206C 2F            mov bl, al        ; save al
0437+  206D 19 00         mov al, 0
0438+  206F 05 03         syscall sys_io        ; display AH
0439+  2071 24            mov ah, bl        ; retrieve al
0440+  2072 19 00         mov al, 0
0441+  2074 05 03         syscall sys_io        ; display AL
0442+  2076             
0443+  2076 E5            pop b
0444+  2077 E4            pop a
0445+  2078 09            ret
0446+  2079             
0447+  2079             ;-----------------------------------------------------------------------------
0448+  2079             ; INPUT 16BIT HEX INTEGER
0449+  2079             ; read 16bit integer into A
0450+  2079             ;-----------------------------------------------------------------------------
0451+  2079             scan_u16x:
0452+  2079 F8 10 00      enter 16
0453+  207C D8            push b
0454+  207D DA            push d
0455+  207E             
0456+  207E FA F1 FF      lea d, [bp + -15]
0457+  2081 07 BC 1E      call _gets        ; get number
0458+  2084             
0459+  2084 32            mov bl, [d]
0460+  2085 37            mov bh, bl
0461+  2086 33 01 00      mov bl, [d + 1]
0462+  2089 07 73 1E      call _atoi        ; convert to int in AL
0463+  208C 23            mov ah, al        ; move to AH
0464+  208D             
0465+  208D 33 02 00      mov bl, [d + 2]
0466+  2090 37            mov bh, bl
0467+  2091 33 03 00      mov bl, [d + 3]
0468+  2094 07 73 1E      call _atoi        ; convert to int in AL
0469+  2097             
0470+  2097 E7            pop d
0471+  2098 E5            pop b
0472+  2099 F9            leave
0473+  209A 09            ret
0474+  209B             
0475+  209B             ;-----------------------------------------------------------------------------
0476+  209B             ; PRINT 8bit HEX INTEGER
0477+  209B             ; integer value in reg bl
0478+  209B             ;-----------------------------------------------------------------------------
0479+  209B             print_u8x:
0480+  209B D7            push a
0481+  209C DD            push bl
0482+  209D             
0483+  209D 07 83 1E      call _itoa        ; convert bl to char in A
0484+  20A0 2F            mov bl, al        ; save al
0485+  20A1 19 00         mov al, 0
0486+  20A3 05 03         syscall sys_io        ; display AH
0487+  20A5 24            mov ah, bl        ; retrieve al
0488+  20A6 19 00         mov al, 0
0489+  20A8 05 03         syscall sys_io        ; display AL
0490+  20AA             
0491+  20AA EA            pop bl
0492+  20AB E4            pop a
0493+  20AC 09            ret
0494+  20AD             
0495+  20AD             ;-----------------------------------------------------------------------------
0496+  20AD             ; print 8bit decimal unsigned number
0497+  20AD             ; input number in AL
0498+  20AD             ;-----------------------------------------------------------------------------
0499+  20AD             print_u8d:
0500+  20AD D7            push a
0501+  20AE D8            push b
0502+  20AF             
0503+  20AF 22 00         mov ah, 0
0504+  20B1 26 64 00      mov b, 100
0505+  20B4 AE            div a, b
0506+  20B5 D8            push b      ; save remainder
0507+  20B6 B9 00         cmp al, 0
0508+  20B8 C6 C2 20      je skip100
0509+  20BB 6A 30         add al, $30
0510+  20BD 23            mov ah, al
0511+  20BE 19 00         mov al, 0
0512+  20C0 05 03         syscall sys_io  ; print coeff
0513+  20C2             skip100:
0514+  20C2 E4            pop a
0515+  20C3 22 00         mov ah, 0
0516+  20C5 26 0A 00      mov b, 10
0517+  20C8 AE            div a, b
0518+  20C9 D8            push b      ; save remainder
0519+  20CA B9 00         cmp al, 0
0520+  20CC C6 D6 20      je skip10
0521+  20CF 6A 30         add al, $30
0522+  20D1 23            mov ah, al
0523+  20D2 19 00         mov al, 0
0524+  20D4 05 03         syscall sys_io  ; print coeff
0525+  20D6             skip10:
0526+  20D6 E4            pop a
0527+  20D7 1B            mov al, bl
0528+  20D8 6A 30         add al, $30
0529+  20DA 23            mov ah, al
0530+  20DB 19 00         mov al, 0
0531+  20DD 05 03         syscall sys_io  ; print coeff
0532+  20DF E5            pop b
0533+  20E0 E4            pop a
0534+  20E1 09            ret
0535+  20E2             
0536+  20E2             ;-----------------------------------------------------------------------------
0537+  20E2             ; INPUT 8BIT HEX INTEGER
0538+  20E2             ; read 8bit integer into AL
0539+  20E2             ;-----------------------------------------------------------------------------
0540+  20E2             scan_u8x:
0541+  20E2 F8 04 00      enter 4
0542+  20E5 D8            push b
0543+  20E6 DA            push d
0544+  20E7             
0545+  20E7 FA FD FF      lea d, [bp + -3]
0546+  20EA 07 BC 1E      call _gets        ; get number
0547+  20ED             
0548+  20ED 32            mov bl, [d]
0549+  20EE 37            mov bh, bl
0550+  20EF 33 01 00      mov bl, [d + 1]
0551+  20F2 07 73 1E      call _atoi        ; convert to int in AL
0552+  20F5             
0553+  20F5 E7            pop d
0554+  20F6 E5            pop b
0555+  20F7 F9            leave
0556+  20F8 09            ret
0557+  20F9             
0558+  20F9             ;-----------------------------------------------------------------------------
0559+  20F9             ; input decimal number
0560+  20F9             ; result in A
0561+  20F9             ; 655'\0'
0562+  20F9             ; low--------high
0563+  20F9             ;-----------------------------------------------------------------------------
0564+  20F9             scan_u16d:
0565+  20F9 F8 08 00      enter 8
0566+  20FC E2            push si
0567+  20FD D8            push b
0568+  20FE D9            push c
0569+  20FF DA            push d
0570+  2100 FA F9 FF      lea d, [bp +- 7]
0571+  2103 07 BC 1E      call _gets
0572+  2106 07 15 1E      call _strlen      ; get string length in C
0573+  2109 7E            dec c
0574+  210A FD 4E         mov si, d
0575+  210C 12            mov a, c
0576+  210D FD 99         shl a
0577+  210F 3B 4B 21      mov d, table_power
0578+  2112 59            add d, a
0579+  2113 38 00 00      mov c, 0
0580+  2116             mul_loop:
0581+  2116 F6            lodsb      ; load ASCII to al
0582+  2117 B9 00         cmp al, 0
0583+  2119 C6 2C 21      je mul_exit
0584+  211C 6F 30         sub al, $30    ; make into integer
0585+  211E 22 00         mov ah, 0
0586+  2120 2A            mov b, [d]
0587+  2121 AC            mul a, b      ; result in B since it fits in 16bits
0588+  2122 11            mov a, b
0589+  2123 28            mov b, c
0590+  2124 54            add a, b
0591+  2125 39            mov c, a
0592+  2126 63 02 00      sub d, 2
0593+  2129 0A 16 21      jmp mul_loop
0594+  212C             mul_exit:
0595+  212C 12            mov a, c
0596+  212D E7            pop d
0597+  212E E6            pop c
0598+  212F E5            pop b
0599+  2130 EF            pop si
0600+  2131 F9            leave
0601+  2132 09            ret
0602+  2133             
0603+  2133 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0603+  2137 34 35 36 37 
0603+  213B 38 39 41 42 
0603+  213F 43 44 45 46 
0604+  2143 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0604+  2147 1B 5B 48 00 
0605+  214B             
0606+  214B             table_power:
0607+  214B 01 00         .dw 1
0608+  214D 0A 00         .dw 10
0609+  214F 64 00         .dw 100
0610+  2151 E8 03         .dw 1000
0611+  2153 10 27         .dw 100004193   2155             ; --- END INLINE ASM SEGMENT
4194   2155             
4195   2155 F9            leave
4196   2156 09            ret
4197   2157             ; --- END TEXT SEGMENT
4198   2157             
4199   2157             ; --- BEGIN DATA SEGMENT
4200   2157 00 00       st_fopen_max_handle: .dw 0
4201   2159 55 6E 65 78 _s0: .db "Unexpected format in printf.", 0
4201   215D 70 65 63 74 
4201   2161 65 64 20 66 
4201   2165 6F 72 6D 61 
4201   2169 74 20 69 6E 
4201   216D 20 70 72 69 
4201   2171 6E 74 66 2E 
4201   2175 00 
4202   2176 45 72 72 6F _s1: .db "Error: Unknown argument type.\n", 0
4202   217A 72 3A 20 55 
4202   217E 6E 6B 6E 6F 
4202   2182 77 6E 20 61 
4202   2186 72 67 75 6D 
4202   218A 65 6E 74 20 
4202   218E 74 79 70 65 
4202   2192 2E 0A 00 
4203   2195 1B 5B 32 4A _s2: .db "\033[2J\033[H", 0
4203   2199 1B 5B 48 00 
4204   219D             
4205   219D 9F 21       _heap_top: .dw _heap
4206   219F 00          _heap: .db 0
4207   21A0             ; --- END DATA SEGMENT
4208   21A0             
4209   21A0             .end
tasm: Number of errors = 1
