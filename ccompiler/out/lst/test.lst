0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT SEGMENT
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; printf("\n%lx\n", ii); 
0011   0408                            
0012   0408             ; --- START FUNCTION CALL
0013   0408                            
0014   0408 3B 42 0D      mov d, _ii ; $ii
0015   040B 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0016   040E FD 39         mov c, b ; And place it into C
0017   0410 2A            mov b, [d] ; Lower Word in B
0018   0411 12            mov a, c
0019   0412 FD AA         swp a
0020   0414 D7            push a
0021   0415 FD AB         swp b
0022   0417 D8            push b
0023   0418                            
0024   0418 26 46 0D      mov b, _s0 ; "\n%lx\n"
0025   041B FD AB         swp b
0026   041D D8            push b
0027   041E 07 26 04      call printf
0028   0421 51 06 00      add sp, 6
0029   0424             ; --- END FUNCTION CALL
0030   0424 05 0B         syscall sys_terminate_proc
0031   0426             
0032   0426             printf:
0033   0426 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0034   0429             ; char *p, *format_p; 
0035   0429 52 02 00      sub sp, 2
0036   042C 52 02 00      sub sp, 2
0037   042F             ; format_p = format; 
0038   042F FA FD FF      lea d, [bp + -3] ; $format_p
0039   0432 DA            push d
0040   0433                            
0041   0433 FA 05 00      lea d, [bp + 5] ; $format
0042   0436 2A            mov b, [d]
0043   0437 38 00 00      mov c, 0
0044   043A E7            pop d
0045   043B FD 43         mov [d], b
0046   043D             ; p = &format + 2; 
0047   043D FA FF FF      lea d, [bp + -1] ; $p
0048   0440 DA            push d
0049   0441                            
0050   0441 FA 05 00      lea d, [bp + 5] ; $format
0051   0444 2D            mov b, d
0052   0445             ; --- START TERMS
0053   0445 D7            push a
0054   0446 11            mov a, b
0055   0447 FD 2E 02 00   mov32 cb, $00000002
0055   044B 00 00 
0056   044D 56            add b, a
0057   044E E4            pop a
0058   044F             ; --- END TERMS
0059   044F E7            pop d
0060   0450 FD 43         mov [d], b
0061   0452             ; for(;;){ 
0062   0452             _for1_init:
0063   0452             _for1_cond:
0064   0452             _for1_block:
0065   0452             ; if(!*format_p) break; 
0066   0452             _if2_cond:
0067   0452                            
0068   0452 FA FD FF      lea d, [bp + -3] ; $format_p
0069   0455 2A            mov b, [d]
0070   0456 38 00 00      mov c, 0
0071   0459 74            mov d, b
0072   045A 32            mov bl, [d]
0073   045B A7 00         mov bh, 0
0074   045D 38 00 00      mov c, 0
0075   0460 C0 00 00      cmp b, 0
0076   0463 FD 71         seq ; !
0077   0465 C0 00 00      cmp b, 0
0078   0468 C6 71 04      je _if2_else
0079   046B             _if2_TRUE:
0080   046B             ; break; 
0081   046B 0A 21 07      jmp _for1_exit ; for break
0082   046E 0A 1E 07      jmp _if2_exit
0083   0471             _if2_else:
0084   0471             ; if(*format_p == '%'){ 
0085   0471             _if3_cond:
0086   0471                            
0087   0471 FA FD FF      lea d, [bp + -3] ; $format_p
0088   0474 2A            mov b, [d]
0089   0475 38 00 00      mov c, 0
0090   0478 74            mov d, b
0091   0479 32            mov bl, [d]
0092   047A A7 00         mov bh, 0
0093   047C 38 00 00      mov c, 0
0094   047F             ; --- START RELATIONAL
0095   047F D7            push a
0096   0480 11            mov a, b
0097   0481 FD 2E 25 00   mov32 cb, $00000025
0097   0485 00 00 
0098   0487 B0            cmp a, b
0099   0488 FD 71         seq ; ==
0100   048A E4            pop a
0101   048B             ; --- END RELATIONAL
0102   048B C0 00 00      cmp b, 0
0103   048E C6 F9 06      je _if3_else
0104   0491             _if3_TRUE:
0105   0491             ; format_p++; 
0106   0491                            
0107   0491 FA FD FF      lea d, [bp + -3] ; $format_p
0108   0494 2A            mov b, [d]
0109   0495 38 00 00      mov c, 0
0110   0498 FD 77         inc b
0111   049A FA FD FF      lea d, [bp + -3] ; $format_p
0112   049D FD 43         mov [d], b
0113   049F FD 7D         dec b
0114   04A1             ; switch(*format_p){ 
0115   04A1             _switch4_expr:
0116   04A1                            
0117   04A1 FA FD FF      lea d, [bp + -3] ; $format_p
0118   04A4 2A            mov b, [d]
0119   04A5 38 00 00      mov c, 0
0120   04A8 74            mov d, b
0121   04A9 32            mov bl, [d]
0122   04AA A7 00         mov bh, 0
0123   04AC 38 00 00      mov c, 0
0124   04AF             _switch4_comparisons:
0125   04AF C1 6C         cmp bl, $6c
0126   04B1 C6 DD 04      je _switch4_case0
0127   04B4 C1 4C         cmp bl, $4c
0128   04B6 C6 DD 04      je _switch4_case1
0129   04B9 C1 64         cmp bl, $64
0130   04BB C6 ED 05      je _switch4_case2
0131   04BE C1 69         cmp bl, $69
0132   04C0 C6 ED 05      je _switch4_case3
0133   04C3 C1 75         cmp bl, $75
0134   04C5 C6 1D 06      je _switch4_case4
0135   04C8 C1 78         cmp bl, $78
0136   04CA C6 4D 06      je _switch4_case5
0137   04CD C1 63         cmp bl, $63
0138   04CF C6 7D 06      je _switch4_case6
0139   04D2 C1 73         cmp bl, $73
0140   04D4 C6 AD 06      je _switch4_case7
0141   04D7 0A DA 06      jmp _switch4_default
0142   04DA 0A E6 06      jmp _switch4_exit
0143   04DD             _switch4_case0:
0144   04DD             _switch4_case1:
0145   04DD             ; format_p++; 
0146   04DD                            
0147   04DD FA FD FF      lea d, [bp + -3] ; $format_p
0148   04E0 2A            mov b, [d]
0149   04E1 38 00 00      mov c, 0
0150   04E4 FD 77         inc b
0151   04E6 FA FD FF      lea d, [bp + -3] ; $format_p
0152   04E9 FD 43         mov [d], b
0153   04EB FD 7D         dec b
0154   04ED             ; if(*format_p == 'd' || *format_p == 'i') 
0155   04ED             _if5_cond:
0156   04ED                            
0157   04ED FA FD FF      lea d, [bp + -3] ; $format_p
0158   04F0 2A            mov b, [d]
0159   04F1 38 00 00      mov c, 0
0160   04F4 74            mov d, b
0161   04F5 32            mov bl, [d]
0162   04F6 A7 00         mov bh, 0
0163   04F8 38 00 00      mov c, 0
0164   04FB             ; --- START RELATIONAL
0165   04FB D7            push a
0166   04FC 11            mov a, b
0167   04FD FD 2E 64 00   mov32 cb, $00000064
0167   0501 00 00 
0168   0503 B0            cmp a, b
0169   0504 FD 71         seq ; ==
0170   0506 E4            pop a
0171   0507             ; --- END RELATIONAL
0172   0507             ; --- START LOGICAL OR
0173   0507 D7            push a
0174   0508 11            mov a, b
0175   0509 FA FD FF      lea d, [bp + -3] ; $format_p
0176   050C 2A            mov b, [d]
0177   050D 38 00 00      mov c, 0
0178   0510 74            mov d, b
0179   0511 32            mov bl, [d]
0180   0512 A7 00         mov bh, 0
0181   0514 38 00 00      mov c, 0
0182   0517             ; --- START RELATIONAL
0183   0517 D7            push a
0184   0518 11            mov a, b
0185   0519 FD 2E 69 00   mov32 cb, $00000069
0185   051D 00 00 
0186   051F B0            cmp a, b
0187   0520 FD 71         seq ; ==
0188   0522 E4            pop a
0189   0523             ; --- END RELATIONAL
0190   0523 FD A8         sor a, b ; ||
0191   0525 E4            pop a
0192   0526             ; --- END LOGICAL OR
0193   0526 C0 00 00      cmp b, 0
0194   0529 C6 4A 05      je _if5_else
0195   052C             _if5_TRUE:
0196   052C             ; print_signed_long(*(long *)p); 
0197   052C                            
0198   052C             ; --- START FUNCTION CALL
0199   052C                            
0200   052C FA FF FF      lea d, [bp + -1] ; $p
0201   052F 2A            mov b, [d]
0202   0530 38 00 00      mov c, 0
0203   0533 74            mov d, b
0204   0534 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0205   0537 FD 39         mov c, b ; And place it into C
0206   0539 2A            mov b, [d] ; Lower Word in B
0207   053A 12            mov a, c
0208   053B FD AA         swp a
0209   053D D7            push a
0210   053E FD AB         swp b
0211   0540 D8            push b
0212   0541 07 23 07      call print_signed_long
0213   0544 51 04 00      add sp, 4
0214   0547             ; --- END FUNCTION CALL
0215   0547 0A D2 05      jmp _if5_exit
0216   054A             _if5_else:
0217   054A             ; if(*format_p == 'u') 
0218   054A             _if6_cond:
0219   054A                            
0220   054A FA FD FF      lea d, [bp + -3] ; $format_p
0221   054D 2A            mov b, [d]
0222   054E 38 00 00      mov c, 0
0223   0551 74            mov d, b
0224   0552 32            mov bl, [d]
0225   0553 A7 00         mov bh, 0
0226   0555 38 00 00      mov c, 0
0227   0558             ; --- START RELATIONAL
0228   0558 D7            push a
0229   0559 11            mov a, b
0230   055A FD 2E 75 00   mov32 cb, $00000075
0230   055E 00 00 
0231   0560 B0            cmp a, b
0232   0561 FD 71         seq ; ==
0233   0563 E4            pop a
0234   0564             ; --- END RELATIONAL
0235   0564 C0 00 00      cmp b, 0
0236   0567 C6 88 05      je _if6_else
0237   056A             _if6_TRUE:
0238   056A             ; print_unsigned_long(*(unsigned long *)p); 
0239   056A                            
0240   056A             ; --- START FUNCTION CALL
0241   056A                            
0242   056A FA FF FF      lea d, [bp + -1] ; $p
0243   056D 2A            mov b, [d]
0244   056E 38 00 00      mov c, 0
0245   0571 74            mov d, b
0246   0572 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0247   0575 FD 39         mov c, b ; And place it into C
0248   0577 2A            mov b, [d] ; Lower Word in B
0249   0578 12            mov a, c
0250   0579 FD AA         swp a
0251   057B D7            push a
0252   057C FD AB         swp b
0253   057E D8            push b
0254   057F 07 B6 08      call print_unsigned_long
0255   0582 51 04 00      add sp, 4
0256   0585             ; --- END FUNCTION CALL
0257   0585 0A D2 05      jmp _if6_exit
0258   0588             _if6_else:
0259   0588             ; if(*format_p == 'x') 
0260   0588             _if7_cond:
0261   0588                            
0262   0588 FA FD FF      lea d, [bp + -3] ; $format_p
0263   058B 2A            mov b, [d]
0264   058C 38 00 00      mov c, 0
0265   058F 74            mov d, b
0266   0590 32            mov bl, [d]
0267   0591 A7 00         mov bh, 0
0268   0593 38 00 00      mov c, 0
0269   0596             ; --- START RELATIONAL
0270   0596 D7            push a
0271   0597 11            mov a, b
0272   0598 FD 2E 78 00   mov32 cb, $00000078
0272   059C 00 00 
0273   059E B0            cmp a, b
0274   059F FD 71         seq ; ==
0275   05A1 E4            pop a
0276   05A2             ; --- END RELATIONAL
0277   05A2 C0 00 00      cmp b, 0
0278   05A5 C6 C6 05      je _if7_else
0279   05A8             _if7_TRUE:
0280   05A8             ; printx32(*(long int *)p); 
0281   05A8                            
0282   05A8             ; --- START FUNCTION CALL
0283   05A8                            
0284   05A8 FA FF FF      lea d, [bp + -1] ; $p
0285   05AB 2A            mov b, [d]
0286   05AC 38 00 00      mov c, 0
0287   05AF 74            mov d, b
0288   05B0 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0289   05B3 FD 39         mov c, b ; And place it into C
0290   05B5 2A            mov b, [d] ; Lower Word in B
0291   05B6 12            mov a, c
0292   05B7 FD AA         swp a
0293   05B9 D7            push a
0294   05BA FD AB         swp b
0295   05BC D8            push b
0296   05BD 07 EA 09      call printx32
0297   05C0 51 04 00      add sp, 4
0298   05C3             ; --- END FUNCTION CALL
0299   05C3 0A D2 05      jmp _if7_exit
0300   05C6             _if7_else:
0301   05C6             ; err("Unexpected format in printf."); 
0302   05C6                            
0303   05C6             ; --- START FUNCTION CALL
0304   05C6                            
0305   05C6 26 4C 0D      mov b, _s1 ; "Unexpected format in printf."
0306   05C9 FD AB         swp b
0307   05CB D8            push b
0308   05CC 07 4A 0A      call err
0309   05CF 51 02 00      add sp, 2
0310   05D2             ; --- END FUNCTION CALL
0311   05D2             _if7_exit:
0312   05D2             _if6_exit:
0313   05D2             _if5_exit:
0314   05D2             ; p = p + 4; 
0315   05D2 FA FF FF      lea d, [bp + -1] ; $p
0316   05D5 DA            push d
0317   05D6                            
0318   05D6 FA FF FF      lea d, [bp + -1] ; $p
0319   05D9 2A            mov b, [d]
0320   05DA 38 00 00      mov c, 0
0321   05DD             ; --- START TERMS
0322   05DD D7            push a
0323   05DE 11            mov a, b
0324   05DF FD 2E 04 00   mov32 cb, $00000004
0324   05E3 00 00 
0325   05E5 56            add b, a
0326   05E6 E4            pop a
0327   05E7             ; --- END TERMS
0328   05E7 E7            pop d
0329   05E8 FD 43         mov [d], b
0330   05EA             ; break; 
0331   05EA 0A E6 06      jmp _switch4_exit ; case break
0332   05ED             _switch4_case2:
0333   05ED             _switch4_case3:
0334   05ED             ; print_signed(*(int*)p); 
0335   05ED                            
0336   05ED             ; --- START FUNCTION CALL
0337   05ED                            
0338   05ED FA FF FF      lea d, [bp + -1] ; $p
0339   05F0 2A            mov b, [d]
0340   05F1 38 00 00      mov c, 0
0341   05F4 74            mov d, b
0342   05F5 2A            mov b, [d]
0343   05F6 38 00 00      mov c, 0
0344   05F9 FD AB         swp b
0345   05FB D8            push b
0346   05FC 07 78 0A      call print_signed
0347   05FF 51 02 00      add sp, 2
0348   0602             ; --- END FUNCTION CALL
0349   0602             ; p = p + 2; 
0350   0602 FA FF FF      lea d, [bp + -1] ; $p
0351   0605 DA            push d
0352   0606                            
0353   0606 FA FF FF      lea d, [bp + -1] ; $p
0354   0609 2A            mov b, [d]
0355   060A 38 00 00      mov c, 0
0356   060D             ; --- START TERMS
0357   060D D7            push a
0358   060E 11            mov a, b
0359   060F FD 2E 02 00   mov32 cb, $00000002
0359   0613 00 00 
0360   0615 56            add b, a
0361   0616 E4            pop a
0362   0617             ; --- END TERMS
0363   0617 E7            pop d
0364   0618 FD 43         mov [d], b
0365   061A             ; break; 
0366   061A 0A E6 06      jmp _switch4_exit ; case break
0367   061D             _switch4_case4:
0368   061D             ; print_unsigned(*(unsigned int*)p); 
0369   061D                            
0370   061D             ; --- START FUNCTION CALL
0371   061D                            
0372   061D FA FF FF      lea d, [bp + -1] ; $p
0373   0620 2A            mov b, [d]
0374   0621 38 00 00      mov c, 0
0375   0624 74            mov d, b
0376   0625 2A            mov b, [d]
0377   0626 38 00 00      mov c, 0
0378   0629 FD AB         swp b
0379   062B D8            push b
0380   062C 07 C9 0B      call print_unsigned
0381   062F 51 02 00      add sp, 2
0382   0632             ; --- END FUNCTION CALL
0383   0632             ; p = p + 2; 
0384   0632 FA FF FF      lea d, [bp + -1] ; $p
0385   0635 DA            push d
0386   0636                            
0387   0636 FA FF FF      lea d, [bp + -1] ; $p
0388   0639 2A            mov b, [d]
0389   063A 38 00 00      mov c, 0
0390   063D             ; --- START TERMS
0391   063D D7            push a
0392   063E 11            mov a, b
0393   063F FD 2E 02 00   mov32 cb, $00000002
0393   0643 00 00 
0394   0645 56            add b, a
0395   0646 E4            pop a
0396   0647             ; --- END TERMS
0397   0647 E7            pop d
0398   0648 FD 43         mov [d], b
0399   064A             ; break; 
0400   064A 0A E6 06      jmp _switch4_exit ; case break
0401   064D             _switch4_case5:
0402   064D             ; printx16(*(int*)p); 
0403   064D                            
0404   064D             ; --- START FUNCTION CALL
0405   064D                            
0406   064D FA FF FF      lea d, [bp + -1] ; $p
0407   0650 2A            mov b, [d]
0408   0651 38 00 00      mov c, 0
0409   0654 74            mov d, b
0410   0655 2A            mov b, [d]
0411   0656 38 00 00      mov c, 0
0412   0659 FD AB         swp b
0413   065B D8            push b
0414   065C 07 E1 0C      call printx16
0415   065F 51 02 00      add sp, 2
0416   0662             ; --- END FUNCTION CALL
0417   0662             ; p = p + 2; 
0418   0662 FA FF FF      lea d, [bp + -1] ; $p
0419   0665 DA            push d
0420   0666                            
0421   0666 FA FF FF      lea d, [bp + -1] ; $p
0422   0669 2A            mov b, [d]
0423   066A 38 00 00      mov c, 0
0424   066D             ; --- START TERMS
0425   066D D7            push a
0426   066E 11            mov a, b
0427   066F FD 2E 02 00   mov32 cb, $00000002
0427   0673 00 00 
0428   0675 56            add b, a
0429   0676 E4            pop a
0430   0677             ; --- END TERMS
0431   0677 E7            pop d
0432   0678 FD 43         mov [d], b
0433   067A             ; break; 
0434   067A 0A E6 06      jmp _switch4_exit ; case break
0435   067D             _switch4_case6:
0436   067D             ; putchar(*(char*)p); 
0437   067D                            
0438   067D             ; --- START FUNCTION CALL
0439   067D                            
0440   067D FA FF FF      lea d, [bp + -1] ; $p
0441   0680 2A            mov b, [d]
0442   0681 38 00 00      mov c, 0
0443   0684 74            mov d, b
0444   0685 32            mov bl, [d]
0445   0686 A7 00         mov bh, 0
0446   0688 38 00 00      mov c, 0
0447   068B DD            push bl
0448   068C 07 A8 08      call putchar
0449   068F 51 01 00      add sp, 1
0450   0692             ; --- END FUNCTION CALL
0451   0692             ; p = p + 1; 
0452   0692 FA FF FF      lea d, [bp + -1] ; $p
0453   0695 DA            push d
0454   0696                            
0455   0696 FA FF FF      lea d, [bp + -1] ; $p
0456   0699 2A            mov b, [d]
0457   069A 38 00 00      mov c, 0
0458   069D             ; --- START TERMS
0459   069D D7            push a
0460   069E 11            mov a, b
0461   069F FD 2E 01 00   mov32 cb, $00000001
0461   06A3 00 00 
0462   06A5 56            add b, a
0463   06A6 E4            pop a
0464   06A7             ; --- END TERMS
0465   06A7 E7            pop d
0466   06A8 FD 43         mov [d], b
0467   06AA             ; break; 
0468   06AA 0A E6 06      jmp _switch4_exit ; case break
0469   06AD             _switch4_case7:
0470   06AD             ; print(*(char**)p); 
0471   06AD                            
0472   06AD             ; --- START FUNCTION CALL
0473   06AD                            
0474   06AD FA FF FF      lea d, [bp + -1] ; $p
0475   06B0 2A            mov b, [d]
0476   06B1 38 00 00      mov c, 0
0477   06B4 74            mov d, b
0478   06B5 2A            mov b, [d]
0479   06B6 FD AB         swp b
0480   06B8 D8            push b
0481   06B9 07 5F 0A      call print
0482   06BC 51 02 00      add sp, 2
0483   06BF             ; --- END FUNCTION CALL
0484   06BF             ; p = p + 2; 
0485   06BF FA FF FF      lea d, [bp + -1] ; $p
0486   06C2 DA            push d
0487   06C3                            
0488   06C3 FA FF FF      lea d, [bp + -1] ; $p
0489   06C6 2A            mov b, [d]
0490   06C7 38 00 00      mov c, 0
0491   06CA             ; --- START TERMS
0492   06CA D7            push a
0493   06CB 11            mov a, b
0494   06CC FD 2E 02 00   mov32 cb, $00000002
0494   06D0 00 00 
0495   06D2 56            add b, a
0496   06D3 E4            pop a
0497   06D4             ; --- END TERMS
0498   06D4 E7            pop d
0499   06D5 FD 43         mov [d], b
0500   06D7             ; break; 
0501   06D7 0A E6 06      jmp _switch4_exit ; case break
0502   06DA             _switch4_default:
0503   06DA             ; print("Error: Unknown argument type.\n"); 
0504   06DA                            
0505   06DA             ; --- START FUNCTION CALL
0506   06DA                            
0507   06DA 26 69 0D      mov b, _s2 ; "Error: Unknown argument type.\n"
0508   06DD FD AB         swp b
0509   06DF D8            push b
0510   06E0 07 5F 0A      call print
0511   06E3 51 02 00      add sp, 2
0512   06E6             ; --- END FUNCTION CALL
0513   06E6             _switch4_exit:
0514   06E6             ; format_p++; 
0515   06E6                            
0516   06E6 FA FD FF      lea d, [bp + -3] ; $format_p
0517   06E9 2A            mov b, [d]
0518   06EA 38 00 00      mov c, 0
0519   06ED FD 77         inc b
0520   06EF FA FD FF      lea d, [bp + -3] ; $format_p
0521   06F2 FD 43         mov [d], b
0522   06F4 FD 7D         dec b
0523   06F6 0A 1E 07      jmp _if3_exit
0524   06F9             _if3_else:
0525   06F9             ; putchar(*format_p); 
0526   06F9                            
0527   06F9             ; --- START FUNCTION CALL
0528   06F9                            
0529   06F9 FA FD FF      lea d, [bp + -3] ; $format_p
0530   06FC 2A            mov b, [d]
0531   06FD 38 00 00      mov c, 0
0532   0700 74            mov d, b
0533   0701 32            mov bl, [d]
0534   0702 A7 00         mov bh, 0
0535   0704 38 00 00      mov c, 0
0536   0707 DD            push bl
0537   0708 07 A8 08      call putchar
0538   070B 51 01 00      add sp, 1
0539   070E             ; --- END FUNCTION CALL
0540   070E             ; format_p++; 
0541   070E                            
0542   070E FA FD FF      lea d, [bp + -3] ; $format_p
0543   0711 2A            mov b, [d]
0544   0712 38 00 00      mov c, 0
0545   0715 FD 77         inc b
0546   0717 FA FD FF      lea d, [bp + -3] ; $format_p
0547   071A FD 43         mov [d], b
0548   071C FD 7D         dec b
0549   071E             _if3_exit:
0550   071E             _if2_exit:
0551   071E             _for1_update:
0552   071E 0A 52 04      jmp _for1_cond
0553   0721             _for1_exit:
0554   0721 F9            leave
0555   0722 09            ret
0556   0723             
0557   0723             print_signed_long:
0558   0723 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0559   0726             ; char digits[10]; 
0560   0726 52 0A 00      sub sp, 10
0561   0729             ; int i = 0; 
0562   0729 52 02 00      sub sp, 2
0563   072C             ; --- START LOCAL VAR INITIALIZATION
0564   072C FA F5 FF      lea d, [bp + -11] ; $i
0565   072F DA            push d
0566   0730                            
0567   0730 FD 2E 00 00   mov32 cb, $00000000
0567   0734 00 00 
0568   0736 E7            pop d
0569   0737 FD 43         mov [d], b
0570   0739             ; --- END LOCAL VAR INITIALIZATION
0571   0739             ; if (num < 0) { 
0572   0739             _if8_cond:
0573   0739                            
0574   0739 FA 05 00      lea d, [bp + 5] ; $num
0575   073C 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0576   073F FD 39         mov c, b ; And place it into C
0577   0741 2A            mov b, [d] ; Lower Word in B
0578   0742             ; --- START RELATIONAL
0579   0742 D7            push a
0580   0743 FD D8         push g
0581   0745 11            mov a, b
0582   0746 FD 7A         mov g, c
0583   0748 FD 2E 00 00   mov32 cb, $00000000
0583   074C 00 00 
0584   074E FD AF         cmp32 ga, cb
0585   0750 FD 73         slt ; <
0586   0752 FD F1         pop g
0587   0754 E4            pop a
0588   0755             ; --- END RELATIONAL
0589   0755 C0 00 00      cmp b, 0
0590   0758 C6 8A 07      je _if8_else
0591   075B             _if8_TRUE:
0592   075B             ; putchar('-'); 
0593   075B                            
0594   075B             ; --- START FUNCTION CALL
0595   075B                            
0596   075B FD 2E 2D 00   mov32 cb, $0000002d
0596   075F 00 00 
0597   0761 DD            push bl
0598   0762 07 A8 08      call putchar
0599   0765 51 01 00      add sp, 1
0600   0768             ; --- END FUNCTION CALL
0601   0768             ; num = -num; 
0602   0768 FA 05 00      lea d, [bp + 5] ; $num
0603   076B DA            push d
0604   076C                            
0605   076C FA 05 00      lea d, [bp + 5] ; $num
0606   076F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0607   0772 FD 39         mov c, b ; And place it into C
0608   0774 2A            mov b, [d] ; Lower Word in B
0609   0775 12            mov a, c
0610   0776 95            not a
0611   0777 97            not b
0612   0778 55 01 00      add b, 1
0613   077B 5B 00 00      adc a, 0
0614   077E 39            mov c, a
0615   077F E7            pop d
0616   0780 FD 43         mov [d], b
0617   0782 28            mov b, c
0618   0783 FD 44 02 00   mov [d + 2], b
0619   0787 0A BE 07      jmp _if8_exit
0620   078A             _if8_else:
0621   078A             ; if (num == 0) { 
0622   078A             _if9_cond:
0623   078A                             
0624   078A FA 05 00      lea d, [bp + 5] ; $num
0625   078D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0626   0790 FD 39         mov c, b ; And place it into C
0627   0792 2A            mov b, [d] ; Lower Word in B
0628   0793             ; --- START RELATIONAL
0629   0793 D7            push a
0630   0794 FD D8         push g
0631   0796 11            mov a, b
0632   0797 FD 7A         mov g, c
0633   0799 FD 2E 00 00   mov32 cb, $00000000
0633   079D 00 00 
0634   079F FD AF         cmp32 ga, cb
0635   07A1 FD 71         seq ; ==
0636   07A3 FD F1         pop g
0637   07A5 E4            pop a
0638   07A6             ; --- END RELATIONAL
0639   07A6 C0 00 00      cmp b, 0
0640   07A9 C6 BE 07      je _if9_exit
0641   07AC             _if9_TRUE:
0642   07AC             ; putchar('0'); 
0643   07AC                             
0644   07AC             ; --- START FUNCTION CALL
0645   07AC                             
0646   07AC FD 2E 30 00   mov32 cb, $00000030
0646   07B0 00 00 
0647   07B2 DD            push bl
0648   07B3 07 A8 08      call putchar
0649   07B6 51 01 00      add sp, 1
0650   07B9             ; --- END FUNCTION CALL
0651   07B9             ; return; 
0652   07B9 F9            leave
0653   07BA 09            ret
0654   07BB 0A BE 07      jmp _if9_exit
0655   07BE             _if9_exit:
0656   07BE             _if8_exit:
0657   07BE             ; while (num > 0) { 
0658   07BE             _while10_cond:
0659   07BE                             
0660   07BE FA 05 00      lea d, [bp + 5] ; $num
0661   07C1 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0662   07C4 FD 39         mov c, b ; And place it into C
0663   07C6 2A            mov b, [d] ; Lower Word in B
0664   07C7             ; --- START RELATIONAL
0665   07C7 D7            push a
0666   07C8 FD D8         push g
0667   07CA 11            mov a, b
0668   07CB FD 7A         mov g, c
0669   07CD FD 2E 00 00   mov32 cb, $00000000
0669   07D1 00 00 
0670   07D3 FD AF         cmp32 ga, cb
0671   07D5 FD 7F         sgt
0672   07D7 FD F1         pop g
0673   07D9 E4            pop a
0674   07DA             ; --- END RELATIONAL
0675   07DA C0 00 00      cmp b, 0
0676   07DD C6 5E 08      je _while10_exit
0677   07E0             _while10_block:
0678   07E0             ; digits[i] = '0' + (num % 10); 
0679   07E0 FA F7 FF      lea d, [bp + -9] ; $digits
0680   07E3 D7            push a
0681   07E4 DA            push d
0682   07E5                             
0683   07E5 FA F5 FF      lea d, [bp + -11] ; $i
0684   07E8 2A            mov b, [d]
0685   07E9 38 00 00      mov c, 0
0686   07EC E7            pop d
0687   07ED 5A            add d, b
0688   07EE E4            pop a
0689   07EF DA            push d
0690   07F0                             
0691   07F0 FD 2E 30 00   mov32 cb, $00000030
0691   07F4 00 00 
0692   07F6             ; --- START TERMS
0693   07F6 D7            push a
0694   07F7 11            mov a, b
0695   07F8                             
0696   07F8 FA 05 00      lea d, [bp + 5] ; $num
0697   07FB 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0698   07FE FD 39         mov c, b ; And place it into C
0699   0800 2A            mov b, [d] ; Lower Word in B
0700   0801             ; --- START FACTORS
0701   0801 D7            push a
0702   0802 FD D8         push g
0703   0804 11            mov a, b
0704   0805 FD 7A         mov g, c
0705   0807 FD 2E 0A 00   mov32 cb, $0000000a
0705   080B 00 00 
0706   080D FD D8         push g ; save 'g' as the div instruction uses it
0707   080F AE            div a, b ; %, a: quotient, b: remainder
0708   0810 11            mov a, b
0709   0811 FD F1         pop g
0710   0813 FD 38         mov c, g
0711   0815 27            mov b, a
0712   0816 FD F1         pop g
0713   0818 E4            pop a
0714   0819             ; --- END FACTORS
0715   0819 FD 15         add32 cb, ga
0716   081B E4            pop a
0717   081C             ; --- END TERMS
0718   081C E7            pop d
0719   081D FD 3E         mov [d], bl
0720   081F             ; num = num / 10; 
0721   081F FA 05 00      lea d, [bp + 5] ; $num
0722   0822 DA            push d
0723   0823                             
0724   0823 FA 05 00      lea d, [bp + 5] ; $num
0725   0826 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0726   0829 FD 39         mov c, b ; And place it into C
0727   082B 2A            mov b, [d] ; Lower Word in B
0728   082C             ; --- START FACTORS
0729   082C D7            push a
0730   082D FD D8         push g
0731   082F 11            mov a, b
0732   0830 FD 7A         mov g, c
0733   0832 FD 2E 0A 00   mov32 cb, $0000000a
0733   0836 00 00 
0734   0838 FD D8         push g ; save 'g' as the div instruction uses it
0735   083A AE            div a, b ; /, a: quotient, b: remainder
0736   083B FD F1         pop g
0737   083D FD 38         mov c, g
0738   083F 27            mov b, a
0739   0840 FD F1         pop g
0740   0842 E4            pop a
0741   0843             ; --- END FACTORS
0742   0843 E7            pop d
0743   0844 FD 43         mov [d], b
0744   0846 28            mov b, c
0745   0847 FD 44 02 00   mov [d + 2], b
0746   084B             ; i++; 
0747   084B                             
0748   084B FA F5 FF      lea d, [bp + -11] ; $i
0749   084E 2A            mov b, [d]
0750   084F 38 00 00      mov c, 0
0751   0852 11            mov a, b
0752   0853 FD 77         inc b
0753   0855 FA F5 FF      lea d, [bp + -11] ; $i
0754   0858 FD 43         mov [d], b
0755   085A 27            mov b, a
0756   085B 0A BE 07      jmp _while10_cond
0757   085E             _while10_exit:
0758   085E             ; while (i > 0) { 
0759   085E             _while13_cond:
0760   085E                             
0761   085E FA F5 FF      lea d, [bp + -11] ; $i
0762   0861 2A            mov b, [d]
0763   0862 38 00 00      mov c, 0
0764   0865             ; --- START RELATIONAL
0765   0865 D7            push a
0766   0866 11            mov a, b
0767   0867 FD 2E 00 00   mov32 cb, $00000000
0767   086B 00 00 
0768   086D B0            cmp a, b
0769   086E FD 7F         sgt ; >
0770   0870 E4            pop a
0771   0871             ; --- END RELATIONAL
0772   0871 C0 00 00      cmp b, 0
0773   0874 C6 A6 08      je _while13_exit
0774   0877             _while13_block:
0775   0877             ; i--; 
0776   0877                             
0777   0877 FA F5 FF      lea d, [bp + -11] ; $i
0778   087A 2A            mov b, [d]
0779   087B 38 00 00      mov c, 0
0780   087E 11            mov a, b
0781   087F FD 7D         dec b
0782   0881 FA F5 FF      lea d, [bp + -11] ; $i
0783   0884 FD 43         mov [d], b
0784   0886 27            mov b, a
0785   0887             ; putchar(digits[i]); 
0786   0887                             
0787   0887             ; --- START FUNCTION CALL
0788   0887                             
0789   0887 FA F7 FF      lea d, [bp + -9] ; $digits
0790   088A D7            push a
0791   088B DA            push d
0792   088C                             
0793   088C FA F5 FF      lea d, [bp + -11] ; $i
0794   088F 2A            mov b, [d]
0795   0890 38 00 00      mov c, 0
0796   0893 E7            pop d
0797   0894 5A            add d, b
0798   0895 E4            pop a
0799   0896 32            mov bl, [d]
0800   0897 A7 00         mov bh, 0
0801   0899 38 00 00      mov c, 0
0802   089C DD            push bl
0803   089D 07 A8 08      call putchar
0804   08A0 51 01 00      add sp, 1
0805   08A3             ; --- END FUNCTION CALL
0806   08A3 0A 5E 08      jmp _while13_cond
0807   08A6             _while13_exit:
0808   08A6 F9            leave
0809   08A7 09            ret
0810   08A8             
0811   08A8             putchar:
0812   08A8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0813   08AB             ; --- BEGIN INLINE ASM SEGMENT
0814   08AB FA 05 00      lea d, [bp + 5] ; $c
0815   08AE 1E            mov al, [d]
0816   08AF 23            mov ah, al
0817   08B0 19 00         mov al, 0
0818   08B2 05 03         syscall sys_io      ; char in AH
0819   08B4             ; --- END INLINE ASM SEGMENT
0820   08B4 F9            leave
0821   08B5 09            ret
0822   08B6             
0823   08B6             print_unsigned_long:
0824   08B6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0825   08B9             ; char digits[10]; 
0826   08B9 52 0A 00      sub sp, 10
0827   08BC             ; int i; 
0828   08BC 52 02 00      sub sp, 2
0829   08BF             ; i = 0; 
0830   08BF FA F5 FF      lea d, [bp + -11] ; $i
0831   08C2 DA            push d
0832   08C3                             
0833   08C3 FD 2E 00 00   mov32 cb, $00000000
0833   08C7 00 00 
0834   08C9 E7            pop d
0835   08CA FD 43         mov [d], b
0836   08CC             ; if(num == 0){ 
0837   08CC             _if14_cond:
0838   08CC                             
0839   08CC FA 05 00      lea d, [bp + 5] ; $num
0840   08CF 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0841   08D2 FD 39         mov c, b ; And place it into C
0842   08D4 2A            mov b, [d] ; Lower Word in B
0843   08D5             ; --- START RELATIONAL
0844   08D5 D7            push a
0845   08D6 FD D8         push g
0846   08D8 11            mov a, b
0847   08D9 FD 7A         mov g, c
0848   08DB FD 2E 00 00   mov32 cb, $00000000
0848   08DF 00 00 
0849   08E1 FD AF         cmp32 ga, cb
0850   08E3 FD 71         seq ; ==
0851   08E5 FD F1         pop g
0852   08E7 E4            pop a
0853   08E8             ; --- END RELATIONAL
0854   08E8 C0 00 00      cmp b, 0
0855   08EB C6 00 09      je _if14_exit
0856   08EE             _if14_TRUE:
0857   08EE             ; putchar('0'); 
0858   08EE                             
0859   08EE             ; --- START FUNCTION CALL
0860   08EE                             
0861   08EE FD 2E 30 00   mov32 cb, $00000030
0861   08F2 00 00 
0862   08F4 DD            push bl
0863   08F5 07 A8 08      call putchar
0864   08F8 51 01 00      add sp, 1
0865   08FB             ; --- END FUNCTION CALL
0866   08FB             ; return; 
0867   08FB F9            leave
0868   08FC 09            ret
0869   08FD 0A 00 09      jmp _if14_exit
0870   0900             _if14_exit:
0871   0900             ; while (num > 0) { 
0872   0900             _while15_cond:
0873   0900                             
0874   0900 FA 05 00      lea d, [bp + 5] ; $num
0875   0903 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0876   0906 FD 39         mov c, b ; And place it into C
0877   0908 2A            mov b, [d] ; Lower Word in B
0878   0909             ; --- START RELATIONAL
0879   0909 D7            push a
0880   090A FD D8         push g
0881   090C 11            mov a, b
0882   090D FD 7A         mov g, c
0883   090F FD 2E 00 00   mov32 cb, $00000000
0883   0913 00 00 
0884   0915 FD AF         cmp32 ga, cb
0885   0917 FD 81         sgu
0886   0919 FD F1         pop g
0887   091B E4            pop a
0888   091C             ; --- END RELATIONAL
0889   091C C0 00 00      cmp b, 0
0890   091F C6 A0 09      je _while15_exit
0891   0922             _while15_block:
0892   0922             ; digits[i] = '0' + (num % 10); 
0893   0922 FA F7 FF      lea d, [bp + -9] ; $digits
0894   0925 D7            push a
0895   0926 DA            push d
0896   0927                             
0897   0927 FA F5 FF      lea d, [bp + -11] ; $i
0898   092A 2A            mov b, [d]
0899   092B 38 00 00      mov c, 0
0900   092E E7            pop d
0901   092F 5A            add d, b
0902   0930 E4            pop a
0903   0931 DA            push d
0904   0932                             
0905   0932 FD 2E 30 00   mov32 cb, $00000030
0905   0936 00 00 
0906   0938             ; --- START TERMS
0907   0938 D7            push a
0908   0939 11            mov a, b
0909   093A                             
0910   093A FA 05 00      lea d, [bp + 5] ; $num
0911   093D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0912   0940 FD 39         mov c, b ; And place it into C
0913   0942 2A            mov b, [d] ; Lower Word in B
0914   0943             ; --- START FACTORS
0915   0943 D7            push a
0916   0944 FD D8         push g
0917   0946 11            mov a, b
0918   0947 FD 7A         mov g, c
0919   0949 FD 2E 0A 00   mov32 cb, $0000000a
0919   094D 00 00 
0920   094F FD D8         push g ; save 'g' as the div instruction uses it
0921   0951 AE            div a, b ; %, a: quotient, b: remainder
0922   0952 11            mov a, b
0923   0953 FD F1         pop g
0924   0955 FD 38         mov c, g
0925   0957 27            mov b, a
0926   0958 FD F1         pop g
0927   095A E4            pop a
0928   095B             ; --- END FACTORS
0929   095B FD 15         add32 cb, ga
0930   095D E4            pop a
0931   095E             ; --- END TERMS
0932   095E E7            pop d
0933   095F FD 3E         mov [d], bl
0934   0961             ; num = num / 10; 
0935   0961 FA 05 00      lea d, [bp + 5] ; $num
0936   0964 DA            push d
0937   0965                             
0938   0965 FA 05 00      lea d, [bp + 5] ; $num
0939   0968 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0940   096B FD 39         mov c, b ; And place it into C
0941   096D 2A            mov b, [d] ; Lower Word in B
0942   096E             ; --- START FACTORS
0943   096E D7            push a
0944   096F FD D8         push g
0945   0971 11            mov a, b
0946   0972 FD 7A         mov g, c
0947   0974 FD 2E 0A 00   mov32 cb, $0000000a
0947   0978 00 00 
0948   097A FD D8         push g ; save 'g' as the div instruction uses it
0949   097C AE            div a, b ; /, a: quotient, b: remainder
0950   097D FD F1         pop g
0951   097F FD 38         mov c, g
0952   0981 27            mov b, a
0953   0982 FD F1         pop g
0954   0984 E4            pop a
0955   0985             ; --- END FACTORS
0956   0985 E7            pop d
0957   0986 FD 43         mov [d], b
0958   0988 28            mov b, c
0959   0989 FD 44 02 00   mov [d + 2], b
0960   098D             ; i++; 
0961   098D                             
0962   098D FA F5 FF      lea d, [bp + -11] ; $i
0963   0990 2A            mov b, [d]
0964   0991 38 00 00      mov c, 0
0965   0994 11            mov a, b
0966   0995 FD 77         inc b
0967   0997 FA F5 FF      lea d, [bp + -11] ; $i
0968   099A FD 43         mov [d], b
0969   099C 27            mov b, a
0970   099D 0A 00 09      jmp _while15_cond
0971   09A0             _while15_exit:
0972   09A0             ; while (i > 0) { 
0973   09A0             _while18_cond:
0974   09A0                             
0975   09A0 FA F5 FF      lea d, [bp + -11] ; $i
0976   09A3 2A            mov b, [d]
0977   09A4 38 00 00      mov c, 0
0978   09A7             ; --- START RELATIONAL
0979   09A7 D7            push a
0980   09A8 11            mov a, b
0981   09A9 FD 2E 00 00   mov32 cb, $00000000
0981   09AD 00 00 
0982   09AF B0            cmp a, b
0983   09B0 FD 7F         sgt ; >
0984   09B2 E4            pop a
0985   09B3             ; --- END RELATIONAL
0986   09B3 C0 00 00      cmp b, 0
0987   09B6 C6 E8 09      je _while18_exit
0988   09B9             _while18_block:
0989   09B9             ; i--; 
0990   09B9                             
0991   09B9 FA F5 FF      lea d, [bp + -11] ; $i
0992   09BC 2A            mov b, [d]
0993   09BD 38 00 00      mov c, 0
0994   09C0 11            mov a, b
0995   09C1 FD 7D         dec b
0996   09C3 FA F5 FF      lea d, [bp + -11] ; $i
0997   09C6 FD 43         mov [d], b
0998   09C8 27            mov b, a
0999   09C9             ; putchar(digits[i]); 
1000   09C9                             
1001   09C9             ; --- START FUNCTION CALL
1002   09C9                             
1003   09C9 FA F7 FF      lea d, [bp + -9] ; $digits
1004   09CC D7            push a
1005   09CD DA            push d
1006   09CE                             
1007   09CE FA F5 FF      lea d, [bp + -11] ; $i
1008   09D1 2A            mov b, [d]
1009   09D2 38 00 00      mov c, 0
1010   09D5 E7            pop d
1011   09D6 5A            add d, b
1012   09D7 E4            pop a
1013   09D8 32            mov bl, [d]
1014   09D9 A7 00         mov bh, 0
1015   09DB 38 00 00      mov c, 0
1016   09DE DD            push bl
1017   09DF 07 A8 08      call putchar
1018   09E2 51 01 00      add sp, 1
1019   09E5             ; --- END FUNCTION CALL
1020   09E5 0A A0 09      jmp _while18_cond
1021   09E8             _while18_exit:
1022   09E8 F9            leave
1023   09E9 09            ret
1024   09EA             
1025   09EA             printx32:
1026   09EA F8 00 00      enter 0 ; (push bp; mov bp, sp)
1027   09ED             ; --- BEGIN INLINE ASM SEGMENT
1028   09ED FA 05 00      lea d, [bp + 5] ; $hex
1029   09F0 2B 02 00      mov b, [d+2]
1030   09F3 07 FC 09      call print_u16x_printx32
1031   09F6 2A            mov b, [d]
1032   09F7 07 FC 09      call print_u16x_printx32
1033   09FA             ; --- END INLINE ASM SEGMENT
1034   09FA             ; return; 
1035   09FA F9            leave
1036   09FB 09            ret
1037   09FC             ; --- BEGIN INLINE ASM SEGMENT
1038   09FC             print_u16x_printx32:
1039   09FC D7            push a
1040   09FD D8            push b
1041   09FE DD            push bl
1042   09FF 30            mov bl, bh
1043   0A00 07 1E 0A      call _itoa_printx32        ; convert bh to char in A
1044   0A03 2F            mov bl, al        ; save al
1045   0A04 19 00         mov al, 0
1046   0A06 05 03         syscall sys_io        ; display AH
1047   0A08 24            mov ah, bl        ; retrieve al
1048   0A09 19 00         mov al, 0
1049   0A0B 05 03         syscall sys_io        ; display AL
1050   0A0D EA            pop bl
1051   0A0E 07 1E 0A      call _itoa_printx32        ; convert bh to char in A
1052   0A11 2F            mov bl, al        ; save al
1053   0A12 19 00         mov al, 0
1054   0A14 05 03         syscall sys_io        ; display AH
1055   0A16 24            mov ah, bl        ; retrieve al
1056   0A17 19 00         mov al, 0
1057   0A19 05 03         syscall sys_io        ; display AL
1058   0A1B E5            pop b
1059   0A1C E4            pop a
1060   0A1D 09            ret
1061   0A1E             _itoa_printx32:
1062   0A1E DA            push d
1063   0A1F D8            push b
1064   0A20 A7 00         mov bh, 0
1065   0A22 FD A4 04      shr bl, 4  
1066   0A25 74            mov d, b
1067   0A26 1F 38 0A      mov al, [d + s_hex_digits_printx32]
1068   0A29 23            mov ah, al
1069   0A2A E5            pop b
1070   0A2B D8            push b
1071   0A2C A7 00         mov bh, 0
1072   0A2E FD 87 0F      and bl, $0F
1073   0A31 74            mov d, b
1074   0A32 1F 38 0A      mov al, [d + s_hex_digits_printx32]
1075   0A35 E5            pop b
1076   0A36 E7            pop d
1077   0A37 09            ret
1078   0A38 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
1078   0A3C 34 35 36 37 
1078   0A40 38 39 41 42 
1078   0A44 43 44 45 46 
1079   0A48             ; --- END INLINE ASM SEGMENT
1080   0A48 F9            leave
1081   0A49 09            ret
1082   0A4A             
1083   0A4A             err:
1084   0A4A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1085   0A4D             ; print(e); 
1086   0A4D                             
1087   0A4D             ; --- START FUNCTION CALL
1088   0A4D                             
1089   0A4D FA 05 00      lea d, [bp + 5] ; $e
1090   0A50 2A            mov b, [d]
1091   0A51 38 00 00      mov c, 0
1092   0A54 FD AB         swp b
1093   0A56 D8            push b
1094   0A57 07 5F 0A      call print
1095   0A5A 51 02 00      add sp, 2
1096   0A5D             ; --- END FUNCTION CALL
1097   0A5D F9            leave
1098   0A5E 09            ret
1099   0A5F             
1100   0A5F             print:
1101   0A5F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1102   0A62             ; --- BEGIN INLINE ASM SEGMENT
1103   0A62 FA 05 00      lea d, [bp + 5] ; $s
1104   0A65 FD 2A         mov d, [d]
1105   0A67             _puts_L1_print:
1106   0A67 1E            mov al, [d]
1107   0A68 B9 00         cmp al, 0
1108   0A6A C6 76 0A      jz _puts_END_print
1109   0A6D 23            mov ah, al
1110   0A6E 19 00         mov al, 0
1111   0A70 05 03         syscall sys_io
1112   0A72 79            inc d
1113   0A73 0A 67 0A      jmp _puts_L1_print
1114   0A76             _puts_END_print:
1115   0A76             ; --- END INLINE ASM SEGMENT
1116   0A76 F9            leave
1117   0A77 09            ret
1118   0A78             
1119   0A78             print_signed:
1120   0A78 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1121   0A7B             ; char digits[5]; 
1122   0A7B 52 05 00      sub sp, 5
1123   0A7E             ; int i = 0; 
1124   0A7E 52 02 00      sub sp, 2
1125   0A81             ; --- START LOCAL VAR INITIALIZATION
1126   0A81 FA FA FF      lea d, [bp + -6] ; $i
1127   0A84 DA            push d
1128   0A85                             
1129   0A85 FD 2E 00 00   mov32 cb, $00000000
1129   0A89 00 00 
1130   0A8B E7            pop d
1131   0A8C FD 43         mov [d], b
1132   0A8E             ; --- END LOCAL VAR INITIALIZATION
1133   0A8E             ; if (num < 0) { 
1134   0A8E             _if19_cond:
1135   0A8E                             
1136   0A8E FA 05 00      lea d, [bp + 5] ; $num
1137   0A91 2A            mov b, [d]
1138   0A92 38 00 00      mov c, 0
1139   0A95             ; --- START RELATIONAL
1140   0A95 D7            push a
1141   0A96 11            mov a, b
1142   0A97 FD 2E 00 00   mov32 cb, $00000000
1142   0A9B 00 00 
1143   0A9D B0            cmp a, b
1144   0A9E FD 73         slt ; < (signed)
1145   0AA0 E4            pop a
1146   0AA1             ; --- END RELATIONAL
1147   0AA1 C0 00 00      cmp b, 0
1148   0AA4 C6 C7 0A      je _if19_else
1149   0AA7             _if19_TRUE:
1150   0AA7             ; putchar('-'); 
1151   0AA7                             
1152   0AA7             ; --- START FUNCTION CALL
1153   0AA7                             
1154   0AA7 FD 2E 2D 00   mov32 cb, $0000002d
1154   0AAB 00 00 
1155   0AAD DD            push bl
1156   0AAE 07 A8 08      call putchar
1157   0AB1 51 01 00      add sp, 1
1158   0AB4             ; --- END FUNCTION CALL
1159   0AB4             ; num = -num; 
1160   0AB4 FA 05 00      lea d, [bp + 5] ; $num
1161   0AB7 DA            push d
1162   0AB8                             
1163   0AB8 FA 05 00      lea d, [bp + 5] ; $num
1164   0ABB 2A            mov b, [d]
1165   0ABC 38 00 00      mov c, 0
1166   0ABF FD 97         neg b
1167   0AC1 E7            pop d
1168   0AC2 FD 43         mov [d], b
1169   0AC4 0A F2 0A      jmp _if19_exit
1170   0AC7             _if19_else:
1171   0AC7             ; if (num == 0) { 
1172   0AC7             _if20_cond:
1173   0AC7                             
1174   0AC7 FA 05 00      lea d, [bp + 5] ; $num
1175   0ACA 2A            mov b, [d]
1176   0ACB 38 00 00      mov c, 0
1177   0ACE             ; --- START RELATIONAL
1178   0ACE D7            push a
1179   0ACF 11            mov a, b
1180   0AD0 FD 2E 00 00   mov32 cb, $00000000
1180   0AD4 00 00 
1181   0AD6 B0            cmp a, b
1182   0AD7 FD 71         seq ; ==
1183   0AD9 E4            pop a
1184   0ADA             ; --- END RELATIONAL
1185   0ADA C0 00 00      cmp b, 0
1186   0ADD C6 F2 0A      je _if20_exit
1187   0AE0             _if20_TRUE:
1188   0AE0             ; putchar('0'); 
1189   0AE0                             
1190   0AE0             ; --- START FUNCTION CALL
1191   0AE0                             
1192   0AE0 FD 2E 30 00   mov32 cb, $00000030
1192   0AE4 00 00 
1193   0AE6 DD            push bl
1194   0AE7 07 A8 08      call putchar
1195   0AEA 51 01 00      add sp, 1
1196   0AED             ; --- END FUNCTION CALL
1197   0AED             ; return; 
1198   0AED F9            leave
1199   0AEE 09            ret
1200   0AEF 0A F2 0A      jmp _if20_exit
1201   0AF2             _if20_exit:
1202   0AF2             _if19_exit:
1203   0AF2             ; while (num > 0) { 
1204   0AF2             _while21_cond:
1205   0AF2                             
1206   0AF2 FA 05 00      lea d, [bp + 5] ; $num
1207   0AF5 2A            mov b, [d]
1208   0AF6 38 00 00      mov c, 0
1209   0AF9             ; --- START RELATIONAL
1210   0AF9 D7            push a
1211   0AFA 11            mov a, b
1212   0AFB FD 2E 00 00   mov32 cb, $00000000
1212   0AFF 00 00 
1213   0B01 B0            cmp a, b
1214   0B02 FD 7F         sgt ; >
1215   0B04 E4            pop a
1216   0B05             ; --- END RELATIONAL
1217   0B05 C0 00 00      cmp b, 0
1218   0B08 C6 7F 0B      je _while21_exit
1219   0B0B             _while21_block:
1220   0B0B             ; digits[i] = '0' + (num % 10); 
1221   0B0B FA FC FF      lea d, [bp + -4] ; $digits
1222   0B0E D7            push a
1223   0B0F DA            push d
1224   0B10                             
1225   0B10 FA FA FF      lea d, [bp + -6] ; $i
1226   0B13 2A            mov b, [d]
1227   0B14 38 00 00      mov c, 0
1228   0B17 E7            pop d
1229   0B18 5A            add d, b
1230   0B19 E4            pop a
1231   0B1A DA            push d
1232   0B1B                             
1233   0B1B FD 2E 30 00   mov32 cb, $00000030
1233   0B1F 00 00 
1234   0B21             ; --- START TERMS
1235   0B21 D7            push a
1236   0B22 11            mov a, b
1237   0B23                             
1238   0B23 FA 05 00      lea d, [bp + 5] ; $num
1239   0B26 2A            mov b, [d]
1240   0B27 38 00 00      mov c, 0
1241   0B2A             ; --- START FACTORS
1242   0B2A D7            push a
1243   0B2B FD D8         push g
1244   0B2D 11            mov a, b
1245   0B2E FD 7A         mov g, c
1246   0B30 FD 2E 0A 00   mov32 cb, $0000000a
1246   0B34 00 00 
1247   0B36 FD D8         push g ; save 'g' as the div instruction uses it
1248   0B38 AE            div a, b ; %, a: quotient, b: remainder
1249   0B39 11            mov a, b
1250   0B3A FD F1         pop g
1251   0B3C FD 38         mov c, g
1252   0B3E 27            mov b, a
1253   0B3F FD F1         pop g
1254   0B41 E4            pop a
1255   0B42             ; --- END FACTORS
1256   0B42 56            add b, a
1257   0B43 E4            pop a
1258   0B44             ; --- END TERMS
1259   0B44 E7            pop d
1260   0B45 FD 3E         mov [d], bl
1261   0B47             ; num = num / 10; 
1262   0B47 FA 05 00      lea d, [bp + 5] ; $num
1263   0B4A DA            push d
1264   0B4B                             
1265   0B4B FA 05 00      lea d, [bp + 5] ; $num
1266   0B4E 2A            mov b, [d]
1267   0B4F 38 00 00      mov c, 0
1268   0B52             ; --- START FACTORS
1269   0B52 D7            push a
1270   0B53 FD D8         push g
1271   0B55 11            mov a, b
1272   0B56 FD 7A         mov g, c
1273   0B58 FD 2E 0A 00   mov32 cb, $0000000a
1273   0B5C 00 00 
1274   0B5E FD D8         push g ; save 'g' as the div instruction uses it
1275   0B60 AE            div a, b ; /, a: quotient, b: remainder
1276   0B61 FD F1         pop g
1277   0B63 FD 38         mov c, g
1278   0B65 27            mov b, a
1279   0B66 FD F1         pop g
1280   0B68 E4            pop a
1281   0B69             ; --- END FACTORS
1282   0B69 E7            pop d
1283   0B6A FD 43         mov [d], b
1284   0B6C             ; i++; 
1285   0B6C                             
1286   0B6C FA FA FF      lea d, [bp + -6] ; $i
1287   0B6F 2A            mov b, [d]
1288   0B70 38 00 00      mov c, 0
1289   0B73 11            mov a, b
1290   0B74 FD 77         inc b
1291   0B76 FA FA FF      lea d, [bp + -6] ; $i
1292   0B79 FD 43         mov [d], b
1293   0B7B 27            mov b, a
1294   0B7C 0A F2 0A      jmp _while21_cond
1295   0B7F             _while21_exit:
1296   0B7F             ; while (i > 0) { 
1297   0B7F             _while24_cond:
1298   0B7F                             
1299   0B7F FA FA FF      lea d, [bp + -6] ; $i
1300   0B82 2A            mov b, [d]
1301   0B83 38 00 00      mov c, 0
1302   0B86             ; --- START RELATIONAL
1303   0B86 D7            push a
1304   0B87 11            mov a, b
1305   0B88 FD 2E 00 00   mov32 cb, $00000000
1305   0B8C 00 00 
1306   0B8E B0            cmp a, b
1307   0B8F FD 7F         sgt ; >
1308   0B91 E4            pop a
1309   0B92             ; --- END RELATIONAL
1310   0B92 C0 00 00      cmp b, 0
1311   0B95 C6 C7 0B      je _while24_exit
1312   0B98             _while24_block:
1313   0B98             ; i--; 
1314   0B98                             
1315   0B98 FA FA FF      lea d, [bp + -6] ; $i
1316   0B9B 2A            mov b, [d]
1317   0B9C 38 00 00      mov c, 0
1318   0B9F 11            mov a, b
1319   0BA0 FD 7D         dec b
1320   0BA2 FA FA FF      lea d, [bp + -6] ; $i
1321   0BA5 FD 43         mov [d], b
1322   0BA7 27            mov b, a
1323   0BA8             ; putchar(digits[i]); 
1324   0BA8                             
1325   0BA8             ; --- START FUNCTION CALL
1326   0BA8                             
1327   0BA8 FA FC FF      lea d, [bp + -4] ; $digits
1328   0BAB D7            push a
1329   0BAC DA            push d
1330   0BAD                             
1331   0BAD FA FA FF      lea d, [bp + -6] ; $i
1332   0BB0 2A            mov b, [d]
1333   0BB1 38 00 00      mov c, 0
1334   0BB4 E7            pop d
1335   0BB5 5A            add d, b
1336   0BB6 E4            pop a
1337   0BB7 32            mov bl, [d]
1338   0BB8 A7 00         mov bh, 0
1339   0BBA 38 00 00      mov c, 0
1340   0BBD DD            push bl
1341   0BBE 07 A8 08      call putchar
1342   0BC1 51 01 00      add sp, 1
1343   0BC4             ; --- END FUNCTION CALL
1344   0BC4 0A 7F 0B      jmp _while24_cond
1345   0BC7             _while24_exit:
1346   0BC7 F9            leave
1347   0BC8 09            ret
1348   0BC9             
1349   0BC9             print_unsigned:
1350   0BC9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1351   0BCC             ; char digits[5]; 
1352   0BCC 52 05 00      sub sp, 5
1353   0BCF             ; int i; 
1354   0BCF 52 02 00      sub sp, 2
1355   0BD2             ; i = 0; 
1356   0BD2 FA FA FF      lea d, [bp + -6] ; $i
1357   0BD5 DA            push d
1358   0BD6                             
1359   0BD6 FD 2E 00 00   mov32 cb, $00000000
1359   0BDA 00 00 
1360   0BDC E7            pop d
1361   0BDD FD 43         mov [d], b
1362   0BDF             ; if(num == 0){ 
1363   0BDF             _if25_cond:
1364   0BDF                             
1365   0BDF FA 05 00      lea d, [bp + 5] ; $num
1366   0BE2 2A            mov b, [d]
1367   0BE3 38 00 00      mov c, 0
1368   0BE6             ; --- START RELATIONAL
1369   0BE6 D7            push a
1370   0BE7 11            mov a, b
1371   0BE8 FD 2E 00 00   mov32 cb, $00000000
1371   0BEC 00 00 
1372   0BEE B0            cmp a, b
1373   0BEF FD 71         seq ; ==
1374   0BF1 E4            pop a
1375   0BF2             ; --- END RELATIONAL
1376   0BF2 C0 00 00      cmp b, 0
1377   0BF5 C6 0A 0C      je _if25_exit
1378   0BF8             _if25_TRUE:
1379   0BF8             ; putchar('0'); 
1380   0BF8                             
1381   0BF8             ; --- START FUNCTION CALL
1382   0BF8                             
1383   0BF8 FD 2E 30 00   mov32 cb, $00000030
1383   0BFC 00 00 
1384   0BFE DD            push bl
1385   0BFF 07 A8 08      call putchar
1386   0C02 51 01 00      add sp, 1
1387   0C05             ; --- END FUNCTION CALL
1388   0C05             ; return; 
1389   0C05 F9            leave
1390   0C06 09            ret
1391   0C07 0A 0A 0C      jmp _if25_exit
1392   0C0A             _if25_exit:
1393   0C0A             ; while (num > 0) { 
1394   0C0A             _while26_cond:
1395   0C0A                             
1396   0C0A FA 05 00      lea d, [bp + 5] ; $num
1397   0C0D 2A            mov b, [d]
1398   0C0E 38 00 00      mov c, 0
1399   0C11             ; --- START RELATIONAL
1400   0C11 D7            push a
1401   0C12 11            mov a, b
1402   0C13 FD 2E 00 00   mov32 cb, $00000000
1402   0C17 00 00 
1403   0C19 B0            cmp a, b
1404   0C1A FD 81         sgu ; > (unsigned)
1405   0C1C E4            pop a
1406   0C1D             ; --- END RELATIONAL
1407   0C1D C0 00 00      cmp b, 0
1408   0C20 C6 97 0C      je _while26_exit
1409   0C23             _while26_block:
1410   0C23             ; digits[i] = '0' + (num % 10); 
1411   0C23 FA FC FF      lea d, [bp + -4] ; $digits
1412   0C26 D7            push a
1413   0C27 DA            push d
1414   0C28                             
1415   0C28 FA FA FF      lea d, [bp + -6] ; $i
1416   0C2B 2A            mov b, [d]
1417   0C2C 38 00 00      mov c, 0
1418   0C2F E7            pop d
1419   0C30 5A            add d, b
1420   0C31 E4            pop a
1421   0C32 DA            push d
1422   0C33                             
1423   0C33 FD 2E 30 00   mov32 cb, $00000030
1423   0C37 00 00 
1424   0C39             ; --- START TERMS
1425   0C39 D7            push a
1426   0C3A 11            mov a, b
1427   0C3B                             
1428   0C3B FA 05 00      lea d, [bp + 5] ; $num
1429   0C3E 2A            mov b, [d]
1430   0C3F 38 00 00      mov c, 0
1431   0C42             ; --- START FACTORS
1432   0C42 D7            push a
1433   0C43 FD D8         push g
1434   0C45 11            mov a, b
1435   0C46 FD 7A         mov g, c
1436   0C48 FD 2E 0A 00   mov32 cb, $0000000a
1436   0C4C 00 00 
1437   0C4E FD D8         push g ; save 'g' as the div instruction uses it
1438   0C50 AE            div a, b ; %, a: quotient, b: remainder
1439   0C51 11            mov a, b
1440   0C52 FD F1         pop g
1441   0C54 FD 38         mov c, g
1442   0C56 27            mov b, a
1443   0C57 FD F1         pop g
1444   0C59 E4            pop a
1445   0C5A             ; --- END FACTORS
1446   0C5A 56            add b, a
1447   0C5B E4            pop a
1448   0C5C             ; --- END TERMS
1449   0C5C E7            pop d
1450   0C5D FD 3E         mov [d], bl
1451   0C5F             ; num = num / 10; 
1452   0C5F FA 05 00      lea d, [bp + 5] ; $num
1453   0C62 DA            push d
1454   0C63                             
1455   0C63 FA 05 00      lea d, [bp + 5] ; $num
1456   0C66 2A            mov b, [d]
1457   0C67 38 00 00      mov c, 0
1458   0C6A             ; --- START FACTORS
1459   0C6A D7            push a
1460   0C6B FD D8         push g
1461   0C6D 11            mov a, b
1462   0C6E FD 7A         mov g, c
1463   0C70 FD 2E 0A 00   mov32 cb, $0000000a
1463   0C74 00 00 
1464   0C76 FD D8         push g ; save 'g' as the div instruction uses it
1465   0C78 AE            div a, b ; /, a: quotient, b: remainder
1466   0C79 FD F1         pop g
1467   0C7B FD 38         mov c, g
1468   0C7D 27            mov b, a
1469   0C7E FD F1         pop g
1470   0C80 E4            pop a
1471   0C81             ; --- END FACTORS
1472   0C81 E7            pop d
1473   0C82 FD 43         mov [d], b
1474   0C84             ; i++; 
1475   0C84                             
1476   0C84 FA FA FF      lea d, [bp + -6] ; $i
1477   0C87 2A            mov b, [d]
1478   0C88 38 00 00      mov c, 0
1479   0C8B 11            mov a, b
1480   0C8C FD 77         inc b
1481   0C8E FA FA FF      lea d, [bp + -6] ; $i
1482   0C91 FD 43         mov [d], b
1483   0C93 27            mov b, a
1484   0C94 0A 0A 0C      jmp _while26_cond
1485   0C97             _while26_exit:
1486   0C97             ; while (i > 0) { 
1487   0C97             _while29_cond:
1488   0C97                             
1489   0C97 FA FA FF      lea d, [bp + -6] ; $i
1490   0C9A 2A            mov b, [d]
1491   0C9B 38 00 00      mov c, 0
1492   0C9E             ; --- START RELATIONAL
1493   0C9E D7            push a
1494   0C9F 11            mov a, b
1495   0CA0 FD 2E 00 00   mov32 cb, $00000000
1495   0CA4 00 00 
1496   0CA6 B0            cmp a, b
1497   0CA7 FD 7F         sgt ; >
1498   0CA9 E4            pop a
1499   0CAA             ; --- END RELATIONAL
1500   0CAA C0 00 00      cmp b, 0
1501   0CAD C6 DF 0C      je _while29_exit
1502   0CB0             _while29_block:
1503   0CB0             ; i--; 
1504   0CB0                             
1505   0CB0 FA FA FF      lea d, [bp + -6] ; $i
1506   0CB3 2A            mov b, [d]
1507   0CB4 38 00 00      mov c, 0
1508   0CB7 11            mov a, b
1509   0CB8 FD 7D         dec b
1510   0CBA FA FA FF      lea d, [bp + -6] ; $i
1511   0CBD FD 43         mov [d], b
1512   0CBF 27            mov b, a
1513   0CC0             ; putchar(digits[i]); 
1514   0CC0                             
1515   0CC0             ; --- START FUNCTION CALL
1516   0CC0                             
1517   0CC0 FA FC FF      lea d, [bp + -4] ; $digits
1518   0CC3 D7            push a
1519   0CC4 DA            push d
1520   0CC5                             
1521   0CC5 FA FA FF      lea d, [bp + -6] ; $i
1522   0CC8 2A            mov b, [d]
1523   0CC9 38 00 00      mov c, 0
1524   0CCC E7            pop d
1525   0CCD 5A            add d, b
1526   0CCE E4            pop a
1527   0CCF 32            mov bl, [d]
1528   0CD0 A7 00         mov bh, 0
1529   0CD2 38 00 00      mov c, 0
1530   0CD5 DD            push bl
1531   0CD6 07 A8 08      call putchar
1532   0CD9 51 01 00      add sp, 1
1533   0CDC             ; --- END FUNCTION CALL
1534   0CDC 0A 97 0C      jmp _while29_cond
1535   0CDF             _while29_exit:
1536   0CDF F9            leave
1537   0CE0 09            ret
1538   0CE1             
1539   0CE1             printx16:
1540   0CE1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1541   0CE4             ; --- BEGIN INLINE ASM SEGMENT
1542   0CE4 FA 05 00      lea d, [bp + 5] ; $hex
1543   0CE7 2A            mov b, [d]
1544   0CE8             print_u16x_printx16:
1545   0CE8 DD            push bl
1546   0CE9 30            mov bl, bh
1547   0CEA 07 07 0D      call _itoa_printx16        ; convert bh to char in A
1548   0CED 2F            mov bl, al        ; save al
1549   0CEE 19 00         mov al, 0
1550   0CF0 05 03         syscall sys_io        ; display AH
1551   0CF2 24            mov ah, bl        ; retrieve al
1552   0CF3 19 00         mov al, 0
1553   0CF5 05 03         syscall sys_io        ; display AL
1554   0CF7 EA            pop bl
1555   0CF8 07 07 0D      call _itoa_printx16        ; convert bh to char in A
1556   0CFB 2F            mov bl, al        ; save al
1557   0CFC 19 00         mov al, 0
1558   0CFE 05 03         syscall sys_io        ; display AH
1559   0D00 24            mov ah, bl        ; retrieve al
1560   0D01 19 00         mov al, 0
1561   0D03 05 03         syscall sys_io        ; display AL
1562   0D05             ; --- END INLINE ASM SEGMENT
1563   0D05             ; return; 
1564   0D05 F9            leave
1565   0D06 09            ret
1566   0D07             ; --- BEGIN INLINE ASM SEGMENT
1567   0D07             _itoa_printx16:
1568   0D07 DA            push d
1569   0D08 D8            push b
1570   0D09 A7 00         mov bh, 0
1571   0D0B FD A4 04      shr bl, 4  
1572   0D0E 74            mov d, b
1573   0D0F 1F 21 0D      mov al, [d + s_hex_digits_printx16]
1574   0D12 23            mov ah, al
1575   0D13 E5            pop b
1576   0D14 D8            push b
1577   0D15 A7 00         mov bh, 0
1578   0D17 FD 87 0F      and bl, $0F
1579   0D1A 74            mov d, b
1580   0D1B 1F 21 0D      mov al, [d + s_hex_digits_printx16]
1581   0D1E E5            pop b
1582   0D1F E7            pop d
1583   0D20 09            ret
1584   0D21 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
1584   0D25 34 35 36 37 
1584   0D29 38 39 41 42 
1584   0D2D 43 44 45 46 
1585   0D31             ; --- END INLINE ASM SEGMENT
1586   0D31 F9            leave
1587   0D32 09            ret
1588   0D33             ; --- END TEXT SEGMENT
1589   0D33             
1590   0D33             ; --- BEGIN DATA SEGMENT
1591   0D33 00          _f: .fill 1, 0
1592   0D34 00 00       _i: .fill 2, 0
1593   0D36 00 00 00 00 _c_data: .fill 10, 0
1593   0D3A 00 00 00 00 
1593   0D3E 00 00 
1594   0D40 36 0D       _m: .dw _c_data
1595   0D42 12 EF       _ii: .dw $ef12
1596   0D44 CD AB       .dw $abcd
1597   0D46 0A 25 6C 78 _s0: .db "\n%lx\n", 0
1597   0D4A 0A 00 
1598   0D4C 55 6E 65 78 _s1: .db "Unexpected format in printf.", 0
1598   0D50 70 65 63 74 
1598   0D54 65 64 20 66 
1598   0D58 6F 72 6D 61 
1598   0D5C 74 20 69 6E 
1598   0D60 20 70 72 69 
1598   0D64 6E 74 66 2E 
1598   0D68 00 
1599   0D69 45 72 72 6F _s2: .db "Error: Unknown argument type.\n", 0
1599   0D6D 72 3A 20 55 
1599   0D71 6E 6B 6E 6F 
1599   0D75 77 6E 20 61 
1599   0D79 72 67 75 6D 
1599   0D7D 65 6E 74 20 
1599   0D81 74 79 70 65 
1599   0D85 2E 0A 00 
1600   0D88             
1601   0D88 8A 0D       _heap_top: .dw _heap
1602   0D8A 00          _heap: .db 0
1603   0D8B             ; --- END DATA SEGMENT
1604   0D8B             
1605   0D8B             .end
tasm: Number of errors = 0
