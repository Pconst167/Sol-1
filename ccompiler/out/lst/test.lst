0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0000             ; --- BEGIN SYSTEM SEGMENT
0005   0000 10 01 00      mov a, 1
0006   0003 01          .db 1
0007   0004             ; --- END SYSTEM SEGMENT
0008   0004             
0009   0004             ; --- BEGIN TEXT SEGMENT
0010   0400             .org text_org
0011   0400             main:
0012   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0013   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0014   0408             ; printf("Hello World" 
0015   0408             ; --- START FUNCTION CALL
0016   0408 26 25 0D      mov b, _s0 ; "Hello WorldMy name is Sol-1And this is a multi-line string"
0017   040B FD AB         swp b
0018   040D D8            push b
0019   040E 07 16 04      call printf
0020   0411 51 02 00      add sp, 2
0021   0414             ; --- END FUNCTION CALL
0022   0414 05 0B         syscall sys_terminate_proc
0023   0416             
0024   0416             printf:
0025   0416 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0026   0419             ; char *p, *format_p; 
0027   0419 52 02 00      sub sp, 2
0028   041C 52 02 00      sub sp, 2
0029   041F             ; format_p = format; 
0030   041F FA FD FF      lea d, [bp + -3] ; $format_p
0031   0422 DA            push d
0032   0423 FA 05 00      lea d, [bp + 5] ; $format
0033   0426 2A            mov b, [d]
0034   0427 38 00 00      mov c, 0
0035   042A E7            pop d
0036   042B FD 43         mov [d], b
0037   042D             ; p = &format + 2; 
0038   042D FA FF FF      lea d, [bp + -1] ; $p
0039   0430 DA            push d
0040   0431 FA 05 00      lea d, [bp + 5] ; $format
0041   0434 2D            mov b, d
0042   0435             ; --- START TERMS
0043   0435 D7            push a
0044   0436 11            mov a, b
0045   0437 FD 2E 02 00   mov32 cb, $00000002
0045   043B 00 00 
0046   043D 56            add b, a
0047   043E E4            pop a
0048   043F             ; --- END TERMS
0049   043F E7            pop d
0050   0440 FD 43         mov [d], b
0051   0442             ; for(;;){ 
0052   0442             _for1_init:
0053   0442             _for1_cond:
0054   0442             _for1_block:
0055   0442             ; if(!*format_p) break; 
0056   0442             _if2_cond:
0057   0442 FA FD FF      lea d, [bp + -3] ; $format_p
0058   0445 2A            mov b, [d]
0059   0446 38 00 00      mov c, 0
0060   0449 74            mov d, b
0061   044A 32            mov bl, [d]
0062   044B A7 00         mov bh, 0
0063   044D 38 00 00      mov c, 0
0064   0450 C0 00 00      cmp b, 0
0065   0453 FD 71         seq ; !
0066   0455 C0 00 00      cmp b, 0
0067   0458 C6 61 04      je _if2_else
0068   045B             _if2_TRUE:
0069   045B             ; break; 
0070   045B 0A 11 07      jmp _for1_exit ; for break
0071   045E 0A 0E 07      jmp _if2_exit
0072   0461             _if2_else:
0073   0461             ; if(*format_p == '%'){ 
0074   0461             _if3_cond:
0075   0461 FA FD FF      lea d, [bp + -3] ; $format_p
0076   0464 2A            mov b, [d]
0077   0465 38 00 00      mov c, 0
0078   0468 74            mov d, b
0079   0469 32            mov bl, [d]
0080   046A A7 00         mov bh, 0
0081   046C 38 00 00      mov c, 0
0082   046F             ; --- START RELATIONAL
0083   046F D7            push a
0084   0470 11            mov a, b
0085   0471 FD 2E 25 00   mov32 cb, $00000025
0085   0475 00 00 
0086   0477 B0            cmp a, b
0087   0478 FD 71         seq ; ==
0088   047A E4            pop a
0089   047B             ; --- END RELATIONAL
0090   047B C0 00 00      cmp b, 0
0091   047E C6 E9 06      je _if3_else
0092   0481             _if3_TRUE:
0093   0481             ; format_p++; 
0094   0481 FA FD FF      lea d, [bp + -3] ; $format_p
0095   0484 2A            mov b, [d]
0096   0485 38 00 00      mov c, 0
0097   0488 FD 77         inc b
0098   048A FA FD FF      lea d, [bp + -3] ; $format_p
0099   048D FD 43         mov [d], b
0100   048F FD 7D         dec b
0101   0491             ; switch(*format_p){ 
0102   0491             _switch4_expr:
0103   0491 FA FD FF      lea d, [bp + -3] ; $format_p
0104   0494 2A            mov b, [d]
0105   0495 38 00 00      mov c, 0
0106   0498 74            mov d, b
0107   0499 32            mov bl, [d]
0108   049A A7 00         mov bh, 0
0109   049C 38 00 00      mov c, 0
0110   049F             _switch4_comparisons:
0111   049F C1 6C         cmp bl, $6c
0112   04A1 C6 CD 04      je _switch4_case0
0113   04A4 C1 4C         cmp bl, $4c
0114   04A6 C6 CD 04      je _switch4_case1
0115   04A9 C1 64         cmp bl, $64
0116   04AB C6 DD 05      je _switch4_case2
0117   04AE C1 69         cmp bl, $69
0118   04B0 C6 DD 05      je _switch4_case3
0119   04B3 C1 75         cmp bl, $75
0120   04B5 C6 0D 06      je _switch4_case4
0121   04B8 C1 78         cmp bl, $78
0122   04BA C6 3D 06      je _switch4_case5
0123   04BD C1 63         cmp bl, $63
0124   04BF C6 6D 06      je _switch4_case6
0125   04C2 C1 73         cmp bl, $73
0126   04C4 C6 9D 06      je _switch4_case7
0127   04C7 0A CA 06      jmp _switch4_default
0128   04CA 0A D6 06      jmp _switch4_exit
0129   04CD             _switch4_case0:
0130   04CD             _switch4_case1:
0131   04CD             ; format_p++; 
0132   04CD FA FD FF      lea d, [bp + -3] ; $format_p
0133   04D0 2A            mov b, [d]
0134   04D1 38 00 00      mov c, 0
0135   04D4 FD 77         inc b
0136   04D6 FA FD FF      lea d, [bp + -3] ; $format_p
0137   04D9 FD 43         mov [d], b
0138   04DB FD 7D         dec b
0139   04DD             ; if(*format_p == 'd' || *format_p == 'i') 
0140   04DD             _if5_cond:
0141   04DD FA FD FF      lea d, [bp + -3] ; $format_p
0142   04E0 2A            mov b, [d]
0143   04E1 38 00 00      mov c, 0
0144   04E4 74            mov d, b
0145   04E5 32            mov bl, [d]
0146   04E6 A7 00         mov bh, 0
0147   04E8 38 00 00      mov c, 0
0148   04EB             ; --- START RELATIONAL
0149   04EB D7            push a
0150   04EC 11            mov a, b
0151   04ED FD 2E 64 00   mov32 cb, $00000064
0151   04F1 00 00 
0152   04F3 B0            cmp a, b
0153   04F4 FD 71         seq ; ==
0154   04F6 E4            pop a
0155   04F7             ; --- END RELATIONAL
0156   04F7             ; --- START LOGICAL OR
0157   04F7 D7            push a
0158   04F8 11            mov a, b
0159   04F9 FA FD FF      lea d, [bp + -3] ; $format_p
0160   04FC 2A            mov b, [d]
0161   04FD 38 00 00      mov c, 0
0162   0500 74            mov d, b
0163   0501 32            mov bl, [d]
0164   0502 A7 00         mov bh, 0
0165   0504 38 00 00      mov c, 0
0166   0507             ; --- START RELATIONAL
0167   0507 D7            push a
0168   0508 11            mov a, b
0169   0509 FD 2E 69 00   mov32 cb, $00000069
0169   050D 00 00 
0170   050F B0            cmp a, b
0171   0510 FD 71         seq ; ==
0172   0512 E4            pop a
0173   0513             ; --- END RELATIONAL
0174   0513 FD A8         sor a, b ; ||
0175   0515 E4            pop a
0176   0516             ; --- END LOGICAL OR
0177   0516 C0 00 00      cmp b, 0
0178   0519 C6 3A 05      je _if5_else
0179   051C             _if5_TRUE:
0180   051C             ; print_signed_long(*(long *)p); 
0181   051C             ; --- START FUNCTION CALL
0182   051C FA FF FF      lea d, [bp + -1] ; $p
0183   051F 2A            mov b, [d]
0184   0520 38 00 00      mov c, 0
0185   0523 74            mov d, b
0186   0524 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0187   0527 FD 39         mov c, b ; And place it into C
0188   0529 2A            mov b, [d] ; Lower Word in B
0189   052A 12            mov a, c
0190   052B FD AA         swp a
0191   052D D7            push a
0192   052E FD AB         swp b
0193   0530 D8            push b
0194   0531 07 13 07      call print_signed_long
0195   0534 51 04 00      add sp, 4
0196   0537             ; --- END FUNCTION CALL
0197   0537 0A C2 05      jmp _if5_exit
0198   053A             _if5_else:
0199   053A             ; if(*format_p == 'u') 
0200   053A             _if6_cond:
0201   053A FA FD FF      lea d, [bp + -3] ; $format_p
0202   053D 2A            mov b, [d]
0203   053E 38 00 00      mov c, 0
0204   0541 74            mov d, b
0205   0542 32            mov bl, [d]
0206   0543 A7 00         mov bh, 0
0207   0545 38 00 00      mov c, 0
0208   0548             ; --- START RELATIONAL
0209   0548 D7            push a
0210   0549 11            mov a, b
0211   054A FD 2E 75 00   mov32 cb, $00000075
0211   054E 00 00 
0212   0550 B0            cmp a, b
0213   0551 FD 71         seq ; ==
0214   0553 E4            pop a
0215   0554             ; --- END RELATIONAL
0216   0554 C0 00 00      cmp b, 0
0217   0557 C6 78 05      je _if6_else
0218   055A             _if6_TRUE:
0219   055A             ; print_unsigned_long(*(unsigned long *)p); 
0220   055A             ; --- START FUNCTION CALL
0221   055A FA FF FF      lea d, [bp + -1] ; $p
0222   055D 2A            mov b, [d]
0223   055E 38 00 00      mov c, 0
0224   0561 74            mov d, b
0225   0562 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0226   0565 FD 39         mov c, b ; And place it into C
0227   0567 2A            mov b, [d] ; Lower Word in B
0228   0568 12            mov a, c
0229   0569 FD AA         swp a
0230   056B D7            push a
0231   056C FD AB         swp b
0232   056E D8            push b
0233   056F 07 A6 08      call print_unsigned_long
0234   0572 51 04 00      add sp, 4
0235   0575             ; --- END FUNCTION CALL
0236   0575 0A C2 05      jmp _if6_exit
0237   0578             _if6_else:
0238   0578             ; if(*format_p == 'x') 
0239   0578             _if7_cond:
0240   0578 FA FD FF      lea d, [bp + -3] ; $format_p
0241   057B 2A            mov b, [d]
0242   057C 38 00 00      mov c, 0
0243   057F 74            mov d, b
0244   0580 32            mov bl, [d]
0245   0581 A7 00         mov bh, 0
0246   0583 38 00 00      mov c, 0
0247   0586             ; --- START RELATIONAL
0248   0586 D7            push a
0249   0587 11            mov a, b
0250   0588 FD 2E 78 00   mov32 cb, $00000078
0250   058C 00 00 
0251   058E B0            cmp a, b
0252   058F FD 71         seq ; ==
0253   0591 E4            pop a
0254   0592             ; --- END RELATIONAL
0255   0592 C0 00 00      cmp b, 0
0256   0595 C6 B6 05      je _if7_else
0257   0598             _if7_TRUE:
0258   0598             ; printx32(*(long int *)p); 
0259   0598             ; --- START FUNCTION CALL
0260   0598 FA FF FF      lea d, [bp + -1] ; $p
0261   059B 2A            mov b, [d]
0262   059C 38 00 00      mov c, 0
0263   059F 74            mov d, b
0264   05A0 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0265   05A3 FD 39         mov c, b ; And place it into C
0266   05A5 2A            mov b, [d] ; Lower Word in B
0267   05A6 12            mov a, c
0268   05A7 FD AA         swp a
0269   05A9 D7            push a
0270   05AA FD AB         swp b
0271   05AC D8            push b
0272   05AD 07 DA 09      call printx32
0273   05B0 51 04 00      add sp, 4
0274   05B3             ; --- END FUNCTION CALL
0275   05B3 0A C2 05      jmp _if7_exit
0276   05B6             _if7_else:
0277   05B6             ; err("Unexpected format in printf."); 
0278   05B6             ; --- START FUNCTION CALL
0279   05B6 26 60 0D      mov b, _s1 ; "Unexpected format in printf."
0280   05B9 FD AB         swp b
0281   05BB D8            push b
0282   05BC 07 3A 0A      call err
0283   05BF 51 02 00      add sp, 2
0284   05C2             ; --- END FUNCTION CALL
0285   05C2             _if7_exit:
0286   05C2             _if6_exit:
0287   05C2             _if5_exit:
0288   05C2             ; p = p + 4; 
0289   05C2 FA FF FF      lea d, [bp + -1] ; $p
0290   05C5 DA            push d
0291   05C6 FA FF FF      lea d, [bp + -1] ; $p
0292   05C9 2A            mov b, [d]
0293   05CA 38 00 00      mov c, 0
0294   05CD             ; --- START TERMS
0295   05CD D7            push a
0296   05CE 11            mov a, b
0297   05CF FD 2E 04 00   mov32 cb, $00000004
0297   05D3 00 00 
0298   05D5 56            add b, a
0299   05D6 E4            pop a
0300   05D7             ; --- END TERMS
0301   05D7 E7            pop d
0302   05D8 FD 43         mov [d], b
0303   05DA             ; break; 
0304   05DA 0A D6 06      jmp _switch4_exit ; case break
0305   05DD             _switch4_case2:
0306   05DD             _switch4_case3:
0307   05DD             ; print_signed(*(int*)p); 
0308   05DD             ; --- START FUNCTION CALL
0309   05DD FA FF FF      lea d, [bp + -1] ; $p
0310   05E0 2A            mov b, [d]
0311   05E1 38 00 00      mov c, 0
0312   05E4 74            mov d, b
0313   05E5 2A            mov b, [d]
0314   05E6 38 00 00      mov c, 0
0315   05E9 FD AB         swp b
0316   05EB D8            push b
0317   05EC 07 68 0A      call print_signed
0318   05EF 51 02 00      add sp, 2
0319   05F2             ; --- END FUNCTION CALL
0320   05F2             ; p = p + 2; 
0321   05F2 FA FF FF      lea d, [bp + -1] ; $p
0322   05F5 DA            push d
0323   05F6 FA FF FF      lea d, [bp + -1] ; $p
0324   05F9 2A            mov b, [d]
0325   05FA 38 00 00      mov c, 0
0326   05FD             ; --- START TERMS
0327   05FD D7            push a
0328   05FE 11            mov a, b
0329   05FF FD 2E 02 00   mov32 cb, $00000002
0329   0603 00 00 
0330   0605 56            add b, a
0331   0606 E4            pop a
0332   0607             ; --- END TERMS
0333   0607 E7            pop d
0334   0608 FD 43         mov [d], b
0335   060A             ; break; 
0336   060A 0A D6 06      jmp _switch4_exit ; case break
0337   060D             _switch4_case4:
0338   060D             ; print_unsigned(*(unsigned int*)p); 
0339   060D             ; --- START FUNCTION CALL
0340   060D FA FF FF      lea d, [bp + -1] ; $p
0341   0610 2A            mov b, [d]
0342   0611 38 00 00      mov c, 0
0343   0614 74            mov d, b
0344   0615 2A            mov b, [d]
0345   0616 38 00 00      mov c, 0
0346   0619 FD AB         swp b
0347   061B D8            push b
0348   061C 07 B9 0B      call print_unsigned
0349   061F 51 02 00      add sp, 2
0350   0622             ; --- END FUNCTION CALL
0351   0622             ; p = p + 2; 
0352   0622 FA FF FF      lea d, [bp + -1] ; $p
0353   0625 DA            push d
0354   0626 FA FF FF      lea d, [bp + -1] ; $p
0355   0629 2A            mov b, [d]
0356   062A 38 00 00      mov c, 0
0357   062D             ; --- START TERMS
0358   062D D7            push a
0359   062E 11            mov a, b
0360   062F FD 2E 02 00   mov32 cb, $00000002
0360   0633 00 00 
0361   0635 56            add b, a
0362   0636 E4            pop a
0363   0637             ; --- END TERMS
0364   0637 E7            pop d
0365   0638 FD 43         mov [d], b
0366   063A             ; break; 
0367   063A 0A D6 06      jmp _switch4_exit ; case break
0368   063D             _switch4_case5:
0369   063D             ; printx16(*(int*)p); 
0370   063D             ; --- START FUNCTION CALL
0371   063D FA FF FF      lea d, [bp + -1] ; $p
0372   0640 2A            mov b, [d]
0373   0641 38 00 00      mov c, 0
0374   0644 74            mov d, b
0375   0645 2A            mov b, [d]
0376   0646 38 00 00      mov c, 0
0377   0649 FD AB         swp b
0378   064B D8            push b
0379   064C 07 D1 0C      call printx16
0380   064F 51 02 00      add sp, 2
0381   0652             ; --- END FUNCTION CALL
0382   0652             ; p = p + 2; 
0383   0652 FA FF FF      lea d, [bp + -1] ; $p
0384   0655 DA            push d
0385   0656 FA FF FF      lea d, [bp + -1] ; $p
0386   0659 2A            mov b, [d]
0387   065A 38 00 00      mov c, 0
0388   065D             ; --- START TERMS
0389   065D D7            push a
0390   065E 11            mov a, b
0391   065F FD 2E 02 00   mov32 cb, $00000002
0391   0663 00 00 
0392   0665 56            add b, a
0393   0666 E4            pop a
0394   0667             ; --- END TERMS
0395   0667 E7            pop d
0396   0668 FD 43         mov [d], b
0397   066A             ; break; 
0398   066A 0A D6 06      jmp _switch4_exit ; case break
0399   066D             _switch4_case6:
0400   066D             ; putchar(*(char*)p); 
0401   066D             ; --- START FUNCTION CALL
0402   066D FA FF FF      lea d, [bp + -1] ; $p
0403   0670 2A            mov b, [d]
0404   0671 38 00 00      mov c, 0
0405   0674 74            mov d, b
0406   0675 32            mov bl, [d]
0407   0676 A7 00         mov bh, 0
0408   0678 38 00 00      mov c, 0
0409   067B DD            push bl
0410   067C 07 98 08      call putchar
0411   067F 51 01 00      add sp, 1
0412   0682             ; --- END FUNCTION CALL
0413   0682             ; p = p + 2; 
0414   0682 FA FF FF      lea d, [bp + -1] ; $p
0415   0685 DA            push d
0416   0686 FA FF FF      lea d, [bp + -1] ; $p
0417   0689 2A            mov b, [d]
0418   068A 38 00 00      mov c, 0
0419   068D             ; --- START TERMS
0420   068D D7            push a
0421   068E 11            mov a, b
0422   068F FD 2E 02 00   mov32 cb, $00000002
0422   0693 00 00 
0423   0695 56            add b, a
0424   0696 E4            pop a
0425   0697             ; --- END TERMS
0426   0697 E7            pop d
0427   0698 FD 43         mov [d], b
0428   069A             ; break; 
0429   069A 0A D6 06      jmp _switch4_exit ; case break
0430   069D             _switch4_case7:
0431   069D             ; print(*(char**)p); 
0432   069D             ; --- START FUNCTION CALL
0433   069D FA FF FF      lea d, [bp + -1] ; $p
0434   06A0 2A            mov b, [d]
0435   06A1 38 00 00      mov c, 0
0436   06A4 74            mov d, b
0437   06A5 2A            mov b, [d]
0438   06A6 FD AB         swp b
0439   06A8 D8            push b
0440   06A9 07 4F 0A      call print
0441   06AC 51 02 00      add sp, 2
0442   06AF             ; --- END FUNCTION CALL
0443   06AF             ; p = p + 2; 
0444   06AF FA FF FF      lea d, [bp + -1] ; $p
0445   06B2 DA            push d
0446   06B3 FA FF FF      lea d, [bp + -1] ; $p
0447   06B6 2A            mov b, [d]
0448   06B7 38 00 00      mov c, 0
0449   06BA             ; --- START TERMS
0450   06BA D7            push a
0451   06BB 11            mov a, b
0452   06BC FD 2E 02 00   mov32 cb, $00000002
0452   06C0 00 00 
0453   06C2 56            add b, a
0454   06C3 E4            pop a
0455   06C4             ; --- END TERMS
0456   06C4 E7            pop d
0457   06C5 FD 43         mov [d], b
0458   06C7             ; break; 
0459   06C7 0A D6 06      jmp _switch4_exit ; case break
0460   06CA             _switch4_default:
0461   06CA             ; print("Error: Unknown argument type.\n"); 
0462   06CA             ; --- START FUNCTION CALL
0463   06CA 26 7D 0D      mov b, _s2 ; "Error: Unknown argument type.\n"
0464   06CD FD AB         swp b
0465   06CF D8            push b
0466   06D0 07 4F 0A      call print
0467   06D3 51 02 00      add sp, 2
0468   06D6             ; --- END FUNCTION CALL
0469   06D6             _switch4_exit:
0470   06D6             ; format_p++; 
0471   06D6 FA FD FF      lea d, [bp + -3] ; $format_p
0472   06D9 2A            mov b, [d]
0473   06DA 38 00 00      mov c, 0
0474   06DD FD 77         inc b
0475   06DF FA FD FF      lea d, [bp + -3] ; $format_p
0476   06E2 FD 43         mov [d], b
0477   06E4 FD 7D         dec b
0478   06E6 0A 0E 07      jmp _if3_exit
0479   06E9             _if3_else:
0480   06E9             ; putchar(*format_p); 
0481   06E9             ; --- START FUNCTION CALL
0482   06E9 FA FD FF      lea d, [bp + -3] ; $format_p
0483   06EC 2A            mov b, [d]
0484   06ED 38 00 00      mov c, 0
0485   06F0 74            mov d, b
0486   06F1 32            mov bl, [d]
0487   06F2 A7 00         mov bh, 0
0488   06F4 38 00 00      mov c, 0
0489   06F7 DD            push bl
0490   06F8 07 98 08      call putchar
0491   06FB 51 01 00      add sp, 1
0492   06FE             ; --- END FUNCTION CALL
0493   06FE             ; format_p++; 
0494   06FE FA FD FF      lea d, [bp + -3] ; $format_p
0495   0701 2A            mov b, [d]
0496   0702 38 00 00      mov c, 0
0497   0705 FD 77         inc b
0498   0707 FA FD FF      lea d, [bp + -3] ; $format_p
0499   070A FD 43         mov [d], b
0500   070C FD 7D         dec b
0501   070E             _if3_exit:
0502   070E             _if2_exit:
0503   070E             _for1_update:
0504   070E 0A 42 04      jmp _for1_cond
0505   0711             _for1_exit:
0506   0711 F9            leave
0507   0712 09            ret
0508   0713             
0509   0713             print_signed_long:
0510   0713 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0511   0716             ; char digits[10]; 
0512   0716 52 0A 00      sub sp, 10
0513   0719             ; int i = 0; 
0514   0719 52 02 00      sub sp, 2
0515   071C             ; --- START LOCAL VAR INITIALIZATION
0516   071C FA F5 FF      lea d, [bp + -11] ; $i
0517   071F DA            push d
0518   0720 FD 2E 00 00   mov32 cb, $00000000
0518   0724 00 00 
0519   0726 E7            pop d
0520   0727 FD 43         mov [d], b
0521   0729             ; --- END LOCAL VAR INITIALIZATION
0522   0729             ; if (num < 0) { 
0523   0729             _if8_cond:
0524   0729 FA 05 00      lea d, [bp + 5] ; $num
0525   072C 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0526   072F FD 39         mov c, b ; And place it into C
0527   0731 2A            mov b, [d] ; Lower Word in B
0528   0732             ; --- START RELATIONAL
0529   0732 D7            push a
0530   0733 FD D8         push g
0531   0735 11            mov a, b
0532   0736 FD 7A         mov g, c
0533   0738 FD 2E 00 00   mov32 cb, $00000000
0533   073C 00 00 
0534   073E FD AF         cmp32 ga, cb
0535   0740 FD 73         slt ; <
0536   0742 FD F1         pop g
0537   0744 E4            pop a
0538   0745             ; --- END RELATIONAL
0539   0745 C0 00 00      cmp b, 0
0540   0748 C6 7A 07      je _if8_else
0541   074B             _if8_TRUE:
0542   074B             ; putchar('-'); 
0543   074B             ; --- START FUNCTION CALL
0544   074B FD 2E 2D 00   mov32 cb, $0000002d
0544   074F 00 00 
0545   0751 DD            push bl
0546   0752 07 98 08      call putchar
0547   0755 51 01 00      add sp, 1
0548   0758             ; --- END FUNCTION CALL
0549   0758             ; num = -num; 
0550   0758 FA 05 00      lea d, [bp + 5] ; $num
0551   075B DA            push d
0552   075C FA 05 00      lea d, [bp + 5] ; $num
0553   075F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0554   0762 FD 39         mov c, b ; And place it into C
0555   0764 2A            mov b, [d] ; Lower Word in B
0556   0765 12            mov a, c
0557   0766 95            not a
0558   0767 97            not b
0559   0768 55 01 00      add b, 1
0560   076B 5B 00 00      adc a, 0
0561   076E 39            mov c, a
0562   076F E7            pop d
0563   0770 FD 43         mov [d], b
0564   0772 28            mov b, c
0565   0773 FD 44 02 00   mov [d + 2], b
0566   0777 0A AE 07      jmp _if8_exit
0567   077A             _if8_else:
0568   077A             ; if (num == 0) { 
0569   077A             _if9_cond:
0570   077A FA 05 00      lea d, [bp + 5] ; $num
0571   077D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0572   0780 FD 39         mov c, b ; And place it into C
0573   0782 2A            mov b, [d] ; Lower Word in B
0574   0783             ; --- START RELATIONAL
0575   0783 D7            push a
0576   0784 FD D8         push g
0577   0786 11            mov a, b
0578   0787 FD 7A         mov g, c
0579   0789 FD 2E 00 00   mov32 cb, $00000000
0579   078D 00 00 
0580   078F FD AF         cmp32 ga, cb
0581   0791 FD 71         seq ; ==
0582   0793 FD F1         pop g
0583   0795 E4            pop a
0584   0796             ; --- END RELATIONAL
0585   0796 C0 00 00      cmp b, 0
0586   0799 C6 AE 07      je _if9_exit
0587   079C             _if9_TRUE:
0588   079C             ; putchar('0'); 
0589   079C             ; --- START FUNCTION CALL
0590   079C FD 2E 30 00   mov32 cb, $00000030
0590   07A0 00 00 
0591   07A2 DD            push bl
0592   07A3 07 98 08      call putchar
0593   07A6 51 01 00      add sp, 1
0594   07A9             ; --- END FUNCTION CALL
0595   07A9             ; return; 
0596   07A9 F9            leave
0597   07AA 09            ret
0598   07AB 0A AE 07      jmp _if9_exit
0599   07AE             _if9_exit:
0600   07AE             _if8_exit:
0601   07AE             ; while (num > 0) { 
0602   07AE             _while10_cond:
0603   07AE FA 05 00      lea d, [bp + 5] ; $num
0604   07B1 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0605   07B4 FD 39         mov c, b ; And place it into C
0606   07B6 2A            mov b, [d] ; Lower Word in B
0607   07B7             ; --- START RELATIONAL
0608   07B7 D7            push a
0609   07B8 FD D8         push g
0610   07BA 11            mov a, b
0611   07BB FD 7A         mov g, c
0612   07BD FD 2E 00 00   mov32 cb, $00000000
0612   07C1 00 00 
0613   07C3 FD AF         cmp32 ga, cb
0614   07C5 FD 7F         sgt
0615   07C7 FD F1         pop g
0616   07C9 E4            pop a
0617   07CA             ; --- END RELATIONAL
0618   07CA C0 00 00      cmp b, 0
0619   07CD C6 4E 08      je _while10_exit
0620   07D0             _while10_block:
0621   07D0             ; digits[i] = '0' + (num % 10); 
0622   07D0 FA F7 FF      lea d, [bp + -9] ; $digits
0623   07D3 D7            push a
0624   07D4 DA            push d
0625   07D5 FA F5 FF      lea d, [bp + -11] ; $i
0626   07D8 2A            mov b, [d]
0627   07D9 38 00 00      mov c, 0
0628   07DC E7            pop d
0629   07DD 5A            add d, b
0630   07DE E4            pop a
0631   07DF DA            push d
0632   07E0 FD 2E 30 00   mov32 cb, $00000030
0632   07E4 00 00 
0633   07E6             ; --- START TERMS
0634   07E6 D7            push a
0635   07E7 11            mov a, b
0636   07E8 FA 05 00      lea d, [bp + 5] ; $num
0637   07EB 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0638   07EE FD 39         mov c, b ; And place it into C
0639   07F0 2A            mov b, [d] ; Lower Word in B
0640   07F1             ; --- START FACTORS
0641   07F1 D7            push a
0642   07F2 FD D8         push g
0643   07F4 11            mov a, b
0644   07F5 FD 7A         mov g, c
0645   07F7 FD 2E 0A 00   mov32 cb, $0000000a
0645   07FB 00 00 
0646   07FD FD D8         push g ; save 'g' as the div instruction uses it
0647   07FF AE            div a, b ; %, a: quotient, b: remainder
0648   0800 11            mov a, b
0649   0801 FD F1         pop g
0650   0803 FD 38         mov c, g
0651   0805 27            mov b, a
0652   0806 FD F1         pop g
0653   0808 E4            pop a
0654   0809             ; --- END FACTORS
0655   0809 FD 15         add32 cb, ga
0656   080B E4            pop a
0657   080C             ; --- END TERMS
0658   080C E7            pop d
0659   080D FD 3E         mov [d], bl
0660   080F             ; num = num / 10; 
0661   080F FA 05 00      lea d, [bp + 5] ; $num
0662   0812 DA            push d
0663   0813 FA 05 00      lea d, [bp + 5] ; $num
0664   0816 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0665   0819 FD 39         mov c, b ; And place it into C
0666   081B 2A            mov b, [d] ; Lower Word in B
0667   081C             ; --- START FACTORS
0668   081C D7            push a
0669   081D FD D8         push g
0670   081F 11            mov a, b
0671   0820 FD 7A         mov g, c
0672   0822 FD 2E 0A 00   mov32 cb, $0000000a
0672   0826 00 00 
0673   0828 FD D8         push g ; save 'g' as the div instruction uses it
0674   082A AE            div a, b ; /, a: quotient, b: remainder
0675   082B FD F1         pop g
0676   082D FD 38         mov c, g
0677   082F 27            mov b, a
0678   0830 FD F1         pop g
0679   0832 E4            pop a
0680   0833             ; --- END FACTORS
0681   0833 E7            pop d
0682   0834 FD 43         mov [d], b
0683   0836 28            mov b, c
0684   0837 FD 44 02 00   mov [d + 2], b
0685   083B             ; i++; 
0686   083B FA F5 FF      lea d, [bp + -11] ; $i
0687   083E 2A            mov b, [d]
0688   083F 38 00 00      mov c, 0
0689   0842 11            mov a, b
0690   0843 FD 77         inc b
0691   0845 FA F5 FF      lea d, [bp + -11] ; $i
0692   0848 FD 43         mov [d], b
0693   084A 27            mov b, a
0694   084B 0A AE 07      jmp _while10_cond
0695   084E             _while10_exit:
0696   084E             ; while (i > 0) { 
0697   084E             _while17_cond:
0698   084E FA F5 FF      lea d, [bp + -11] ; $i
0699   0851 2A            mov b, [d]
0700   0852 38 00 00      mov c, 0
0701   0855             ; --- START RELATIONAL
0702   0855 D7            push a
0703   0856 11            mov a, b
0704   0857 FD 2E 00 00   mov32 cb, $00000000
0704   085B 00 00 
0705   085D B0            cmp a, b
0706   085E FD 7F         sgt ; >
0707   0860 E4            pop a
0708   0861             ; --- END RELATIONAL
0709   0861 C0 00 00      cmp b, 0
0710   0864 C6 96 08      je _while17_exit
0711   0867             _while17_block:
0712   0867             ; i--; 
0713   0867 FA F5 FF      lea d, [bp + -11] ; $i
0714   086A 2A            mov b, [d]
0715   086B 38 00 00      mov c, 0
0716   086E 11            mov a, b
0717   086F FD 7D         dec b
0718   0871 FA F5 FF      lea d, [bp + -11] ; $i
0719   0874 FD 43         mov [d], b
0720   0876 27            mov b, a
0721   0877             ; putchar(digits[i]); 
0722   0877             ; --- START FUNCTION CALL
0723   0877 FA F7 FF      lea d, [bp + -9] ; $digits
0724   087A D7            push a
0725   087B DA            push d
0726   087C FA F5 FF      lea d, [bp + -11] ; $i
0727   087F 2A            mov b, [d]
0728   0880 38 00 00      mov c, 0
0729   0883 E7            pop d
0730   0884 5A            add d, b
0731   0885 E4            pop a
0732   0886 32            mov bl, [d]
0733   0887 A7 00         mov bh, 0
0734   0889 38 00 00      mov c, 0
0735   088C DD            push bl
0736   088D 07 98 08      call putchar
0737   0890 51 01 00      add sp, 1
0738   0893             ; --- END FUNCTION CALL
0739   0893 0A 4E 08      jmp _while17_cond
0740   0896             _while17_exit:
0741   0896 F9            leave
0742   0897 09            ret
0743   0898             
0744   0898             putchar:
0745   0898 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0746   089B             ; --- BEGIN INLINE ASM SEGMENT
0747   089B FA 05 00      lea d, [bp + 5] ; $c
0748   089E 1E            mov al, [d]
0749   089F 23            mov ah, al
0750   08A0 19 00         mov al, 0
0751   08A2 05 03         syscall sys_io      ; char in AH
0752   08A4             ; --- END INLINE ASM SEGMENT
0753   08A4 F9            leave
0754   08A5 09            ret
0755   08A6             
0756   08A6             print_unsigned_long:
0757   08A6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0758   08A9             ; char digits[10]; 
0759   08A9 52 0A 00      sub sp, 10
0760   08AC             ; int i; 
0761   08AC 52 02 00      sub sp, 2
0762   08AF             ; i = 0; 
0763   08AF FA F5 FF      lea d, [bp + -11] ; $i
0764   08B2 DA            push d
0765   08B3 FD 2E 00 00   mov32 cb, $00000000
0765   08B7 00 00 
0766   08B9 E7            pop d
0767   08BA FD 43         mov [d], b
0768   08BC             ; if(num == 0){ 
0769   08BC             _if18_cond:
0770   08BC FA 05 00      lea d, [bp + 5] ; $num
0771   08BF 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0772   08C2 FD 39         mov c, b ; And place it into C
0773   08C4 2A            mov b, [d] ; Lower Word in B
0774   08C5             ; --- START RELATIONAL
0775   08C5 D7            push a
0776   08C6 FD D8         push g
0777   08C8 11            mov a, b
0778   08C9 FD 7A         mov g, c
0779   08CB FD 2E 00 00   mov32 cb, $00000000
0779   08CF 00 00 
0780   08D1 FD AF         cmp32 ga, cb
0781   08D3 FD 71         seq ; ==
0782   08D5 FD F1         pop g
0783   08D7 E4            pop a
0784   08D8             ; --- END RELATIONAL
0785   08D8 C0 00 00      cmp b, 0
0786   08DB C6 F0 08      je _if18_exit
0787   08DE             _if18_TRUE:
0788   08DE             ; putchar('0'); 
0789   08DE             ; --- START FUNCTION CALL
0790   08DE FD 2E 30 00   mov32 cb, $00000030
0790   08E2 00 00 
0791   08E4 DD            push bl
0792   08E5 07 98 08      call putchar
0793   08E8 51 01 00      add sp, 1
0794   08EB             ; --- END FUNCTION CALL
0795   08EB             ; return; 
0796   08EB F9            leave
0797   08EC 09            ret
0798   08ED 0A F0 08      jmp _if18_exit
0799   08F0             _if18_exit:
0800   08F0             ; while (num > 0) { 
0801   08F0             _while19_cond:
0802   08F0 FA 05 00      lea d, [bp + 5] ; $num
0803   08F3 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0804   08F6 FD 39         mov c, b ; And place it into C
0805   08F8 2A            mov b, [d] ; Lower Word in B
0806   08F9             ; --- START RELATIONAL
0807   08F9 D7            push a
0808   08FA FD D8         push g
0809   08FC 11            mov a, b
0810   08FD FD 7A         mov g, c
0811   08FF FD 2E 00 00   mov32 cb, $00000000
0811   0903 00 00 
0812   0905 FD AF         cmp32 ga, cb
0813   0907 FD 81         sgu
0814   0909 FD F1         pop g
0815   090B E4            pop a
0816   090C             ; --- END RELATIONAL
0817   090C C0 00 00      cmp b, 0
0818   090F C6 90 09      je _while19_exit
0819   0912             _while19_block:
0820   0912             ; digits[i] = '0' + (num % 10); 
0821   0912 FA F7 FF      lea d, [bp + -9] ; $digits
0822   0915 D7            push a
0823   0916 DA            push d
0824   0917 FA F5 FF      lea d, [bp + -11] ; $i
0825   091A 2A            mov b, [d]
0826   091B 38 00 00      mov c, 0
0827   091E E7            pop d
0828   091F 5A            add d, b
0829   0920 E4            pop a
0830   0921 DA            push d
0831   0922 FD 2E 30 00   mov32 cb, $00000030
0831   0926 00 00 
0832   0928             ; --- START TERMS
0833   0928 D7            push a
0834   0929 11            mov a, b
0835   092A FA 05 00      lea d, [bp + 5] ; $num
0836   092D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0837   0930 FD 39         mov c, b ; And place it into C
0838   0932 2A            mov b, [d] ; Lower Word in B
0839   0933             ; --- START FACTORS
0840   0933 D7            push a
0841   0934 FD D8         push g
0842   0936 11            mov a, b
0843   0937 FD 7A         mov g, c
0844   0939 FD 2E 0A 00   mov32 cb, $0000000a
0844   093D 00 00 
0845   093F FD D8         push g ; save 'g' as the div instruction uses it
0846   0941 AE            div a, b ; %, a: quotient, b: remainder
0847   0942 11            mov a, b
0848   0943 FD F1         pop g
0849   0945 FD 38         mov c, g
0850   0947 27            mov b, a
0851   0948 FD F1         pop g
0852   094A E4            pop a
0853   094B             ; --- END FACTORS
0854   094B FD 15         add32 cb, ga
0855   094D E4            pop a
0856   094E             ; --- END TERMS
0857   094E E7            pop d
0858   094F FD 3E         mov [d], bl
0859   0951             ; num = num / 10; 
0860   0951 FA 05 00      lea d, [bp + 5] ; $num
0861   0954 DA            push d
0862   0955 FA 05 00      lea d, [bp + 5] ; $num
0863   0958 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0864   095B FD 39         mov c, b ; And place it into C
0865   095D 2A            mov b, [d] ; Lower Word in B
0866   095E             ; --- START FACTORS
0867   095E D7            push a
0868   095F FD D8         push g
0869   0961 11            mov a, b
0870   0962 FD 7A         mov g, c
0871   0964 FD 2E 0A 00   mov32 cb, $0000000a
0871   0968 00 00 
0872   096A FD D8         push g ; save 'g' as the div instruction uses it
0873   096C AE            div a, b ; /, a: quotient, b: remainder
0874   096D FD F1         pop g
0875   096F FD 38         mov c, g
0876   0971 27            mov b, a
0877   0972 FD F1         pop g
0878   0974 E4            pop a
0879   0975             ; --- END FACTORS
0880   0975 E7            pop d
0881   0976 FD 43         mov [d], b
0882   0978 28            mov b, c
0883   0979 FD 44 02 00   mov [d + 2], b
0884   097D             ; i++; 
0885   097D FA F5 FF      lea d, [bp + -11] ; $i
0886   0980 2A            mov b, [d]
0887   0981 38 00 00      mov c, 0
0888   0984 11            mov a, b
0889   0985 FD 77         inc b
0890   0987 FA F5 FF      lea d, [bp + -11] ; $i
0891   098A FD 43         mov [d], b
0892   098C 27            mov b, a
0893   098D 0A F0 08      jmp _while19_cond
0894   0990             _while19_exit:
0895   0990             ; while (i > 0) { 
0896   0990             _while26_cond:
0897   0990 FA F5 FF      lea d, [bp + -11] ; $i
0898   0993 2A            mov b, [d]
0899   0994 38 00 00      mov c, 0
0900   0997             ; --- START RELATIONAL
0901   0997 D7            push a
0902   0998 11            mov a, b
0903   0999 FD 2E 00 00   mov32 cb, $00000000
0903   099D 00 00 
0904   099F B0            cmp a, b
0905   09A0 FD 7F         sgt ; >
0906   09A2 E4            pop a
0907   09A3             ; --- END RELATIONAL
0908   09A3 C0 00 00      cmp b, 0
0909   09A6 C6 D8 09      je _while26_exit
0910   09A9             _while26_block:
0911   09A9             ; i--; 
0912   09A9 FA F5 FF      lea d, [bp + -11] ; $i
0913   09AC 2A            mov b, [d]
0914   09AD 38 00 00      mov c, 0
0915   09B0 11            mov a, b
0916   09B1 FD 7D         dec b
0917   09B3 FA F5 FF      lea d, [bp + -11] ; $i
0918   09B6 FD 43         mov [d], b
0919   09B8 27            mov b, a
0920   09B9             ; putchar(digits[i]); 
0921   09B9             ; --- START FUNCTION CALL
0922   09B9 FA F7 FF      lea d, [bp + -9] ; $digits
0923   09BC D7            push a
0924   09BD DA            push d
0925   09BE FA F5 FF      lea d, [bp + -11] ; $i
0926   09C1 2A            mov b, [d]
0927   09C2 38 00 00      mov c, 0
0928   09C5 E7            pop d
0929   09C6 5A            add d, b
0930   09C7 E4            pop a
0931   09C8 32            mov bl, [d]
0932   09C9 A7 00         mov bh, 0
0933   09CB 38 00 00      mov c, 0
0934   09CE DD            push bl
0935   09CF 07 98 08      call putchar
0936   09D2 51 01 00      add sp, 1
0937   09D5             ; --- END FUNCTION CALL
0938   09D5 0A 90 09      jmp _while26_cond
0939   09D8             _while26_exit:
0940   09D8 F9            leave
0941   09D9 09            ret
0942   09DA             
0943   09DA             printx32:
0944   09DA F8 00 00      enter 0 ; (push bp; mov bp, sp)
0945   09DD             ; --- BEGIN INLINE ASM SEGMENT
0946   09DD FA 05 00      lea d, [bp + 5] ; $hex
0947   09E0 2B 02 00      mov b, [d+2]
0948   09E3 07 EC 09      call print_u16x_printx32
0949   09E6 2A            mov b, [d]
0950   09E7 07 EC 09      call print_u16x_printx32
0951   09EA             ; --- END INLINE ASM SEGMENT
0952   09EA             ; return; 
0953   09EA F9            leave
0954   09EB 09            ret
0955   09EC             ; --- BEGIN INLINE ASM SEGMENT
0956   09EC             print_u16x_printx32:
0957   09EC D7            push a
0958   09ED D8            push b
0959   09EE DD            push bl
0960   09EF 30            mov bl, bh
0961   09F0 07 0E 0A      call _itoa_printx32        ; convert bh to char in A
0962   09F3 2F            mov bl, al        ; save al
0963   09F4 19 00         mov al, 0
0964   09F6 05 03         syscall sys_io        ; display AH
0965   09F8 24            mov ah, bl        ; retrieve al
0966   09F9 19 00         mov al, 0
0967   09FB 05 03         syscall sys_io        ; display AL
0968   09FD EA            pop bl
0969   09FE 07 0E 0A      call _itoa_printx32        ; convert bh to char in A
0970   0A01 2F            mov bl, al        ; save al
0971   0A02 19 00         mov al, 0
0972   0A04 05 03         syscall sys_io        ; display AH
0973   0A06 24            mov ah, bl        ; retrieve al
0974   0A07 19 00         mov al, 0
0975   0A09 05 03         syscall sys_io        ; display AL
0976   0A0B E5            pop b
0977   0A0C E4            pop a
0978   0A0D 09            ret
0979   0A0E             _itoa_printx32:
0980   0A0E DA            push d
0981   0A0F D8            push b
0982   0A10 A7 00         mov bh, 0
0983   0A12 FD A4 04      shr bl, 4  
0984   0A15 74            mov d, b
0985   0A16 1F 28 0A      mov al, [d + s_hex_digits_printx32]
0986   0A19 23            mov ah, al
0987   0A1A E5            pop b
0988   0A1B D8            push b
0989   0A1C A7 00         mov bh, 0
0990   0A1E FD 87 0F      and bl, $0F
0991   0A21 74            mov d, b
0992   0A22 1F 28 0A      mov al, [d + s_hex_digits_printx32]
0993   0A25 E5            pop b
0994   0A26 E7            pop d
0995   0A27 09            ret
0996   0A28 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
0996   0A2C 34 35 36 37 
0996   0A30 38 39 41 42 
0996   0A34 43 44 45 46 
0997   0A38             ; --- END INLINE ASM SEGMENT
0998   0A38 F9            leave
0999   0A39 09            ret
1000   0A3A             
1001   0A3A             err:
1002   0A3A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1003   0A3D             ; print(e); 
1004   0A3D             ; --- START FUNCTION CALL
1005   0A3D FA 05 00      lea d, [bp + 5] ; $e
1006   0A40 2A            mov b, [d]
1007   0A41 38 00 00      mov c, 0
1008   0A44 FD AB         swp b
1009   0A46 D8            push b
1010   0A47 07 4F 0A      call print
1011   0A4A 51 02 00      add sp, 2
1012   0A4D             ; --- END FUNCTION CALL
1013   0A4D F9            leave
1014   0A4E 09            ret
1015   0A4F             
1016   0A4F             print:
1017   0A4F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1018   0A52             ; --- BEGIN INLINE ASM SEGMENT
1019   0A52 FA 05 00      lea d, [bp + 5] ; $s
1020   0A55 FD 2A         mov d, [d]
1021   0A57             _puts_L1_print:
1022   0A57 1E            mov al, [d]
1023   0A58 B9 00         cmp al, 0
1024   0A5A C6 66 0A      jz _puts_END_print
1025   0A5D 23            mov ah, al
1026   0A5E 19 00         mov al, 0
1027   0A60 05 03         syscall sys_io
1028   0A62 79            inc d
1029   0A63 0A 57 0A      jmp _puts_L1_print
1030   0A66             _puts_END_print:
1031   0A66             ; --- END INLINE ASM SEGMENT
1032   0A66 F9            leave
1033   0A67 09            ret
1034   0A68             
1035   0A68             print_signed:
1036   0A68 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1037   0A6B             ; char digits[5]; 
1038   0A6B 52 05 00      sub sp, 5
1039   0A6E             ; int i = 0; 
1040   0A6E 52 02 00      sub sp, 2
1041   0A71             ; --- START LOCAL VAR INITIALIZATION
1042   0A71 FA FA FF      lea d, [bp + -6] ; $i
1043   0A74 DA            push d
1044   0A75 FD 2E 00 00   mov32 cb, $00000000
1044   0A79 00 00 
1045   0A7B E7            pop d
1046   0A7C FD 43         mov [d], b
1047   0A7E             ; --- END LOCAL VAR INITIALIZATION
1048   0A7E             ; if (num < 0) { 
1049   0A7E             _if27_cond:
1050   0A7E FA 05 00      lea d, [bp + 5] ; $num
1051   0A81 2A            mov b, [d]
1052   0A82 38 00 00      mov c, 0
1053   0A85             ; --- START RELATIONAL
1054   0A85 D7            push a
1055   0A86 11            mov a, b
1056   0A87 FD 2E 00 00   mov32 cb, $00000000
1056   0A8B 00 00 
1057   0A8D B0            cmp a, b
1058   0A8E FD 73         slt ; < (signed)
1059   0A90 E4            pop a
1060   0A91             ; --- END RELATIONAL
1061   0A91 C0 00 00      cmp b, 0
1062   0A94 C6 B7 0A      je _if27_else
1063   0A97             _if27_TRUE:
1064   0A97             ; putchar('-'); 
1065   0A97             ; --- START FUNCTION CALL
1066   0A97 FD 2E 2D 00   mov32 cb, $0000002d
1066   0A9B 00 00 
1067   0A9D DD            push bl
1068   0A9E 07 98 08      call putchar
1069   0AA1 51 01 00      add sp, 1
1070   0AA4             ; --- END FUNCTION CALL
1071   0AA4             ; num = -num; 
1072   0AA4 FA 05 00      lea d, [bp + 5] ; $num
1073   0AA7 DA            push d
1074   0AA8 FA 05 00      lea d, [bp + 5] ; $num
1075   0AAB 2A            mov b, [d]
1076   0AAC 38 00 00      mov c, 0
1077   0AAF FD 97         neg b
1078   0AB1 E7            pop d
1079   0AB2 FD 43         mov [d], b
1080   0AB4 0A E2 0A      jmp _if27_exit
1081   0AB7             _if27_else:
1082   0AB7             ; if (num == 0) { 
1083   0AB7             _if28_cond:
1084   0AB7 FA 05 00      lea d, [bp + 5] ; $num
1085   0ABA 2A            mov b, [d]
1086   0ABB 38 00 00      mov c, 0
1087   0ABE             ; --- START RELATIONAL
1088   0ABE D7            push a
1089   0ABF 11            mov a, b
1090   0AC0 FD 2E 00 00   mov32 cb, $00000000
1090   0AC4 00 00 
1091   0AC6 B0            cmp a, b
1092   0AC7 FD 71         seq ; ==
1093   0AC9 E4            pop a
1094   0ACA             ; --- END RELATIONAL
1095   0ACA C0 00 00      cmp b, 0
1096   0ACD C6 E2 0A      je _if28_exit
1097   0AD0             _if28_TRUE:
1098   0AD0             ; putchar('0'); 
1099   0AD0             ; --- START FUNCTION CALL
1100   0AD0 FD 2E 30 00   mov32 cb, $00000030
1100   0AD4 00 00 
1101   0AD6 DD            push bl
1102   0AD7 07 98 08      call putchar
1103   0ADA 51 01 00      add sp, 1
1104   0ADD             ; --- END FUNCTION CALL
1105   0ADD             ; return; 
1106   0ADD F9            leave
1107   0ADE 09            ret
1108   0ADF 0A E2 0A      jmp _if28_exit
1109   0AE2             _if28_exit:
1110   0AE2             _if27_exit:
1111   0AE2             ; while (num > 0) { 
1112   0AE2             _while29_cond:
1113   0AE2 FA 05 00      lea d, [bp + 5] ; $num
1114   0AE5 2A            mov b, [d]
1115   0AE6 38 00 00      mov c, 0
1116   0AE9             ; --- START RELATIONAL
1117   0AE9 D7            push a
1118   0AEA 11            mov a, b
1119   0AEB FD 2E 00 00   mov32 cb, $00000000
1119   0AEF 00 00 
1120   0AF1 B0            cmp a, b
1121   0AF2 FD 7F         sgt ; >
1122   0AF4 E4            pop a
1123   0AF5             ; --- END RELATIONAL
1124   0AF5 C0 00 00      cmp b, 0
1125   0AF8 C6 6F 0B      je _while29_exit
1126   0AFB             _while29_block:
1127   0AFB             ; digits[i] = '0' + (num % 10); 
1128   0AFB FA FC FF      lea d, [bp + -4] ; $digits
1129   0AFE D7            push a
1130   0AFF DA            push d
1131   0B00 FA FA FF      lea d, [bp + -6] ; $i
1132   0B03 2A            mov b, [d]
1133   0B04 38 00 00      mov c, 0
1134   0B07 E7            pop d
1135   0B08 5A            add d, b
1136   0B09 E4            pop a
1137   0B0A DA            push d
1138   0B0B FD 2E 30 00   mov32 cb, $00000030
1138   0B0F 00 00 
1139   0B11             ; --- START TERMS
1140   0B11 D7            push a
1141   0B12 11            mov a, b
1142   0B13 FA 05 00      lea d, [bp + 5] ; $num
1143   0B16 2A            mov b, [d]
1144   0B17 38 00 00      mov c, 0
1145   0B1A             ; --- START FACTORS
1146   0B1A D7            push a
1147   0B1B FD D8         push g
1148   0B1D 11            mov a, b
1149   0B1E FD 7A         mov g, c
1150   0B20 FD 2E 0A 00   mov32 cb, $0000000a
1150   0B24 00 00 
1151   0B26 FD D8         push g ; save 'g' as the div instruction uses it
1152   0B28 AE            div a, b ; %, a: quotient, b: remainder
1153   0B29 11            mov a, b
1154   0B2A FD F1         pop g
1155   0B2C FD 38         mov c, g
1156   0B2E 27            mov b, a
1157   0B2F FD F1         pop g
1158   0B31 E4            pop a
1159   0B32             ; --- END FACTORS
1160   0B32 56            add b, a
1161   0B33 E4            pop a
1162   0B34             ; --- END TERMS
1163   0B34 E7            pop d
1164   0B35 FD 3E         mov [d], bl
1165   0B37             ; num = num / 10; 
1166   0B37 FA 05 00      lea d, [bp + 5] ; $num
1167   0B3A DA            push d
1168   0B3B FA 05 00      lea d, [bp + 5] ; $num
1169   0B3E 2A            mov b, [d]
1170   0B3F 38 00 00      mov c, 0
1171   0B42             ; --- START FACTORS
1172   0B42 D7            push a
1173   0B43 FD D8         push g
1174   0B45 11            mov a, b
1175   0B46 FD 7A         mov g, c
1176   0B48 FD 2E 0A 00   mov32 cb, $0000000a
1176   0B4C 00 00 
1177   0B4E FD D8         push g ; save 'g' as the div instruction uses it
1178   0B50 AE            div a, b ; /, a: quotient, b: remainder
1179   0B51 FD F1         pop g
1180   0B53 FD 38         mov c, g
1181   0B55 27            mov b, a
1182   0B56 FD F1         pop g
1183   0B58 E4            pop a
1184   0B59             ; --- END FACTORS
1185   0B59 E7            pop d
1186   0B5A FD 43         mov [d], b
1187   0B5C             ; i++; 
1188   0B5C FA FA FF      lea d, [bp + -6] ; $i
1189   0B5F 2A            mov b, [d]
1190   0B60 38 00 00      mov c, 0
1191   0B63 11            mov a, b
1192   0B64 FD 77         inc b
1193   0B66 FA FA FF      lea d, [bp + -6] ; $i
1194   0B69 FD 43         mov [d], b
1195   0B6B 27            mov b, a
1196   0B6C 0A E2 0A      jmp _while29_cond
1197   0B6F             _while29_exit:
1198   0B6F             ; while (i > 0) { 
1199   0B6F             _while36_cond:
1200   0B6F FA FA FF      lea d, [bp + -6] ; $i
1201   0B72 2A            mov b, [d]
1202   0B73 38 00 00      mov c, 0
1203   0B76             ; --- START RELATIONAL
1204   0B76 D7            push a
1205   0B77 11            mov a, b
1206   0B78 FD 2E 00 00   mov32 cb, $00000000
1206   0B7C 00 00 
1207   0B7E B0            cmp a, b
1208   0B7F FD 7F         sgt ; >
1209   0B81 E4            pop a
1210   0B82             ; --- END RELATIONAL
1211   0B82 C0 00 00      cmp b, 0
1212   0B85 C6 B7 0B      je _while36_exit
1213   0B88             _while36_block:
1214   0B88             ; i--; 
1215   0B88 FA FA FF      lea d, [bp + -6] ; $i
1216   0B8B 2A            mov b, [d]
1217   0B8C 38 00 00      mov c, 0
1218   0B8F 11            mov a, b
1219   0B90 FD 7D         dec b
1220   0B92 FA FA FF      lea d, [bp + -6] ; $i
1221   0B95 FD 43         mov [d], b
1222   0B97 27            mov b, a
1223   0B98             ; putchar(digits[i]); 
1224   0B98             ; --- START FUNCTION CALL
1225   0B98 FA FC FF      lea d, [bp + -4] ; $digits
1226   0B9B D7            push a
1227   0B9C DA            push d
1228   0B9D FA FA FF      lea d, [bp + -6] ; $i
1229   0BA0 2A            mov b, [d]
1230   0BA1 38 00 00      mov c, 0
1231   0BA4 E7            pop d
1232   0BA5 5A            add d, b
1233   0BA6 E4            pop a
1234   0BA7 32            mov bl, [d]
1235   0BA8 A7 00         mov bh, 0
1236   0BAA 38 00 00      mov c, 0
1237   0BAD DD            push bl
1238   0BAE 07 98 08      call putchar
1239   0BB1 51 01 00      add sp, 1
1240   0BB4             ; --- END FUNCTION CALL
1241   0BB4 0A 6F 0B      jmp _while36_cond
1242   0BB7             _while36_exit:
1243   0BB7 F9            leave
1244   0BB8 09            ret
1245   0BB9             
1246   0BB9             print_unsigned:
1247   0BB9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1248   0BBC             ; char digits[5]; 
1249   0BBC 52 05 00      sub sp, 5
1250   0BBF             ; int i; 
1251   0BBF 52 02 00      sub sp, 2
1252   0BC2             ; i = 0; 
1253   0BC2 FA FA FF      lea d, [bp + -6] ; $i
1254   0BC5 DA            push d
1255   0BC6 FD 2E 00 00   mov32 cb, $00000000
1255   0BCA 00 00 
1256   0BCC E7            pop d
1257   0BCD FD 43         mov [d], b
1258   0BCF             ; if(num == 0){ 
1259   0BCF             _if37_cond:
1260   0BCF FA 05 00      lea d, [bp + 5] ; $num
1261   0BD2 2A            mov b, [d]
1262   0BD3 38 00 00      mov c, 0
1263   0BD6             ; --- START RELATIONAL
1264   0BD6 D7            push a
1265   0BD7 11            mov a, b
1266   0BD8 FD 2E 00 00   mov32 cb, $00000000
1266   0BDC 00 00 
1267   0BDE B0            cmp a, b
1268   0BDF FD 71         seq ; ==
1269   0BE1 E4            pop a
1270   0BE2             ; --- END RELATIONAL
1271   0BE2 C0 00 00      cmp b, 0
1272   0BE5 C6 FA 0B      je _if37_exit
1273   0BE8             _if37_TRUE:
1274   0BE8             ; putchar('0'); 
1275   0BE8             ; --- START FUNCTION CALL
1276   0BE8 FD 2E 30 00   mov32 cb, $00000030
1276   0BEC 00 00 
1277   0BEE DD            push bl
1278   0BEF 07 98 08      call putchar
1279   0BF2 51 01 00      add sp, 1
1280   0BF5             ; --- END FUNCTION CALL
1281   0BF5             ; return; 
1282   0BF5 F9            leave
1283   0BF6 09            ret
1284   0BF7 0A FA 0B      jmp _if37_exit
1285   0BFA             _if37_exit:
1286   0BFA             ; while (num > 0) { 
1287   0BFA             _while38_cond:
1288   0BFA FA 05 00      lea d, [bp + 5] ; $num
1289   0BFD 2A            mov b, [d]
1290   0BFE 38 00 00      mov c, 0
1291   0C01             ; --- START RELATIONAL
1292   0C01 D7            push a
1293   0C02 11            mov a, b
1294   0C03 FD 2E 00 00   mov32 cb, $00000000
1294   0C07 00 00 
1295   0C09 B0            cmp a, b
1296   0C0A FD 81         sgu ; > (unsigned)
1297   0C0C E4            pop a
1298   0C0D             ; --- END RELATIONAL
1299   0C0D C0 00 00      cmp b, 0
1300   0C10 C6 87 0C      je _while38_exit
1301   0C13             _while38_block:
1302   0C13             ; digits[i] = '0' + (num % 10); 
1303   0C13 FA FC FF      lea d, [bp + -4] ; $digits
1304   0C16 D7            push a
1305   0C17 DA            push d
1306   0C18 FA FA FF      lea d, [bp + -6] ; $i
1307   0C1B 2A            mov b, [d]
1308   0C1C 38 00 00      mov c, 0
1309   0C1F E7            pop d
1310   0C20 5A            add d, b
1311   0C21 E4            pop a
1312   0C22 DA            push d
1313   0C23 FD 2E 30 00   mov32 cb, $00000030
1313   0C27 00 00 
1314   0C29             ; --- START TERMS
1315   0C29 D7            push a
1316   0C2A 11            mov a, b
1317   0C2B FA 05 00      lea d, [bp + 5] ; $num
1318   0C2E 2A            mov b, [d]
1319   0C2F 38 00 00      mov c, 0
1320   0C32             ; --- START FACTORS
1321   0C32 D7            push a
1322   0C33 FD D8         push g
1323   0C35 11            mov a, b
1324   0C36 FD 7A         mov g, c
1325   0C38 FD 2E 0A 00   mov32 cb, $0000000a
1325   0C3C 00 00 
1326   0C3E FD D8         push g ; save 'g' as the div instruction uses it
1327   0C40 AE            div a, b ; %, a: quotient, b: remainder
1328   0C41 11            mov a, b
1329   0C42 FD F1         pop g
1330   0C44 FD 38         mov c, g
1331   0C46 27            mov b, a
1332   0C47 FD F1         pop g
1333   0C49 E4            pop a
1334   0C4A             ; --- END FACTORS
1335   0C4A 56            add b, a
1336   0C4B E4            pop a
1337   0C4C             ; --- END TERMS
1338   0C4C E7            pop d
1339   0C4D FD 3E         mov [d], bl
1340   0C4F             ; num = num / 10; 
1341   0C4F FA 05 00      lea d, [bp + 5] ; $num
1342   0C52 DA            push d
1343   0C53 FA 05 00      lea d, [bp + 5] ; $num
1344   0C56 2A            mov b, [d]
1345   0C57 38 00 00      mov c, 0
1346   0C5A             ; --- START FACTORS
1347   0C5A D7            push a
1348   0C5B FD D8         push g
1349   0C5D 11            mov a, b
1350   0C5E FD 7A         mov g, c
1351   0C60 FD 2E 0A 00   mov32 cb, $0000000a
1351   0C64 00 00 
1352   0C66 FD D8         push g ; save 'g' as the div instruction uses it
1353   0C68 AE            div a, b ; /, a: quotient, b: remainder
1354   0C69 FD F1         pop g
1355   0C6B FD 38         mov c, g
1356   0C6D 27            mov b, a
1357   0C6E FD F1         pop g
1358   0C70 E4            pop a
1359   0C71             ; --- END FACTORS
1360   0C71 E7            pop d
1361   0C72 FD 43         mov [d], b
1362   0C74             ; i++; 
1363   0C74 FA FA FF      lea d, [bp + -6] ; $i
1364   0C77 2A            mov b, [d]
1365   0C78 38 00 00      mov c, 0
1366   0C7B 11            mov a, b
1367   0C7C FD 77         inc b
1368   0C7E FA FA FF      lea d, [bp + -6] ; $i
1369   0C81 FD 43         mov [d], b
1370   0C83 27            mov b, a
1371   0C84 0A FA 0B      jmp _while38_cond
1372   0C87             _while38_exit:
1373   0C87             ; while (i > 0) { 
1374   0C87             _while45_cond:
1375   0C87 FA FA FF      lea d, [bp + -6] ; $i
1376   0C8A 2A            mov b, [d]
1377   0C8B 38 00 00      mov c, 0
1378   0C8E             ; --- START RELATIONAL
1379   0C8E D7            push a
1380   0C8F 11            mov a, b
1381   0C90 FD 2E 00 00   mov32 cb, $00000000
1381   0C94 00 00 
1382   0C96 B0            cmp a, b
1383   0C97 FD 7F         sgt ; >
1384   0C99 E4            pop a
1385   0C9A             ; --- END RELATIONAL
1386   0C9A C0 00 00      cmp b, 0
1387   0C9D C6 CF 0C      je _while45_exit
1388   0CA0             _while45_block:
1389   0CA0             ; i--; 
1390   0CA0 FA FA FF      lea d, [bp + -6] ; $i
1391   0CA3 2A            mov b, [d]
1392   0CA4 38 00 00      mov c, 0
1393   0CA7 11            mov a, b
1394   0CA8 FD 7D         dec b
1395   0CAA FA FA FF      lea d, [bp + -6] ; $i
1396   0CAD FD 43         mov [d], b
1397   0CAF 27            mov b, a
1398   0CB0             ; putchar(digits[i]); 
1399   0CB0             ; --- START FUNCTION CALL
1400   0CB0 FA FC FF      lea d, [bp + -4] ; $digits
1401   0CB3 D7            push a
1402   0CB4 DA            push d
1403   0CB5 FA FA FF      lea d, [bp + -6] ; $i
1404   0CB8 2A            mov b, [d]
1405   0CB9 38 00 00      mov c, 0
1406   0CBC E7            pop d
1407   0CBD 5A            add d, b
1408   0CBE E4            pop a
1409   0CBF 32            mov bl, [d]
1410   0CC0 A7 00         mov bh, 0
1411   0CC2 38 00 00      mov c, 0
1412   0CC5 DD            push bl
1413   0CC6 07 98 08      call putchar
1414   0CC9 51 01 00      add sp, 1
1415   0CCC             ; --- END FUNCTION CALL
1416   0CCC 0A 87 0C      jmp _while45_cond
1417   0CCF             _while45_exit:
1418   0CCF F9            leave
1419   0CD0 09            ret
1420   0CD1             
1421   0CD1             printx16:
1422   0CD1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1423   0CD4             ; --- BEGIN INLINE ASM SEGMENT
1424   0CD4 FA 05 00      lea d, [bp + 5] ; $hex
1425   0CD7 2A            mov b, [d]
1426   0CD8             print_u16x_printx16:
1427   0CD8 DD            push bl
1428   0CD9 30            mov bl, bh
1429   0CDA 07 F7 0C      call _itoa_printx16        ; convert bh to char in A
1430   0CDD 2F            mov bl, al        ; save al
1431   0CDE 19 00         mov al, 0
1432   0CE0 05 03         syscall sys_io        ; display AH
1433   0CE2 24            mov ah, bl        ; retrieve al
1434   0CE3 19 00         mov al, 0
1435   0CE5 05 03         syscall sys_io        ; display AL
1436   0CE7 EA            pop bl
1437   0CE8 07 F7 0C      call _itoa_printx16        ; convert bh to char in A
1438   0CEB 2F            mov bl, al        ; save al
1439   0CEC 19 00         mov al, 0
1440   0CEE 05 03         syscall sys_io        ; display AH
1441   0CF0 24            mov ah, bl        ; retrieve al
1442   0CF1 19 00         mov al, 0
1443   0CF3 05 03         syscall sys_io        ; display AL
1444   0CF5             ; --- END INLINE ASM SEGMENT
1445   0CF5             ; return; 
1446   0CF5 F9            leave
1447   0CF6 09            ret
1448   0CF7             ; --- BEGIN INLINE ASM SEGMENT
1449   0CF7             _itoa_printx16:
1450   0CF7 DA            push d
1451   0CF8 D8            push b
1452   0CF9 A7 00         mov bh, 0
1453   0CFB FD A4 04      shr bl, 4  
1454   0CFE 74            mov d, b
1455   0CFF 1F 11 0D      mov al, [d + s_hex_digits_printx16]
1456   0D02 23            mov ah, al
1457   0D03 E5            pop b
1458   0D04 D8            push b
1459   0D05 A7 00         mov bh, 0
1460   0D07 FD 87 0F      and bl, $0F
1461   0D0A 74            mov d, b
1462   0D0B 1F 11 0D      mov al, [d + s_hex_digits_printx16]
1463   0D0E E5            pop b
1464   0D0F E7            pop d
1465   0D10 09            ret
1466   0D11 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
1466   0D15 34 35 36 37 
1466   0D19 38 39 41 42 
1466   0D1D 43 44 45 46 
1467   0D21             ; --- END INLINE ASM SEGMENT
1468   0D21 F9            leave
1469   0D22 09            ret
1470   0D23             ; --- END TEXT SEGMENT
1471   0D23             
1472   0D23             ; --- BEGIN DATA SEGMENT
1473   0D23 02 00       _a: .dw $0002
1474   0D25 48 65 6C 6C _s0: .db "Hello WorldMy name is Sol-1And this is a multi-line string", 0
1474   0D29 6F 20 57 6F 
1474   0D2D 72 6C 64 4D 
1474   0D31 79 20 6E 61 
1474   0D35 6D 65 20 69 
1474   0D39 73 20 53 6F 
1474   0D3D 6C 2D 31 41 
1474   0D41 6E 64 20 74 
1474   0D45 68 69 73 20 
1474   0D49 69 73 20 61 
1474   0D4D 20 6D 75 6C 
1474   0D51 74 69 2D 6C 
1474   0D55 69 6E 65 20 
1474   0D59 73 74 72 69 
1474   0D5D 6E 67 00 
1475   0D60 55 6E 65 78 _s1: .db "Unexpected format in printf.", 0
1475   0D64 70 65 63 74 
1475   0D68 65 64 20 66 
1475   0D6C 6F 72 6D 61 
1475   0D70 74 20 69 6E 
1475   0D74 20 70 72 69 
1475   0D78 6E 74 66 2E 
1475   0D7C 00 
1476   0D7D 45 72 72 6F _s2: .db "Error: Unknown argument type.\n", 0
1476   0D81 72 3A 20 55 
1476   0D85 6E 6B 6E 6F 
1476   0D89 77 6E 20 61 
1476   0D8D 72 67 75 6D 
1476   0D91 65 6E 74 20 
1476   0D95 74 79 70 65 
1476   0D99 2E 0A 00 
1477   0D9C             
1478   0D9C 9E 0D       _heap_top: .dw _heap
1479   0D9E 00          _heap: .db 0
1480   0D9F             ; --- END DATA SEGMENT
1481   0D9F             
1482   0D9F             .end
tasm: Number of errors = 0
