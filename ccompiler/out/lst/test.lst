0001   0000             ; --- FILENAME: test
0002   0000             .include "lib/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ;; printf("Hello: %c %d %s", 'A', 123, "Paulo");   
0011   0408 26 F3 0A      mov b, __s0 ; "Paulo"
0012   040B FD AB         swp b
0013   040D D8            push b
0014   040E 26 7B 00      mov b, $7b
0015   0411 FD AB         swp b
0016   0413 D8            push b
0017   0414 26 41 00      mov b, $41
0018   0417 FD AB         swp b
0019   0419 D8            push b
0020   041A 26 F3 0A      mov b, __s0 ; "Paulo"
0021   041D FD AB         swp b
0022   041F D8            push b
0023   0420 07 2C 04      call printf
0024   0423 51 08 00      add sp, 8
0025   0426             ;; return 0; 
0026   0426 26 00 00      mov b, $0
0027   0429 F9            leave
0028   042A 05 0B         syscall sys_terminate_proc
0029   042C             
0030   042C             printf:
0031   042C F8 00 00      enter 0 ; (push bp; mov bp, sp)
0032   042F             ; $p 
0033   042F             ; $fp 
0034   042F             ; $i 
0035   042F 52 06 00      sub sp, 6
0036   0432             ;; fp = format; 
0037   0432 FA FD FF      lea d, [bp + -3] ; $fp
0038   0435 DA            push d
0039   0436 FA 05 00      lea d, [bp + 5] ; $format
0040   0439 2A            mov b, [d]
0041   043A E7            pop d
0042   043B FD 43         mov [d], b
0043   043D             ;; p = &format + 2; 
0044   043D FA FF FF      lea d, [bp + -1] ; $p
0045   0440 DA            push d
0046   0441 FA 05 00      lea d, [bp + 5] ; $format
0047   0444 2D            mov b, d
0048   0445             ; START TERMS
0049   0445 D7            push a
0050   0446 11            mov a, b
0051   0447 26 02 00      mov b, $2
0052   044A 54            add a, b
0053   044B 27            mov b, a
0054   044C E4            pop a
0055   044D             ; END TERMS
0056   044D E7            pop d
0057   044E FD 43         mov [d], b
0058   0450             ;; for(;;){ 
0059   0450             _for1_init:
0060   0450             _for1_cond:
0061   0450             _for1_block:
0062   0450             ;; if(!*fp) break; 
0063   0450             _if2_cond:
0064   0450 FA FD FF      lea d, [bp + -3] ; $fp
0065   0453 2A            mov b, [d]
0066   0454 74            mov d, b
0067   0455 32            mov bl, [d]
0068   0456 A7 00         mov bh, 0
0069   0458 C0 00 00      cmp b, 0
0070   045B FD 71         seq ; !
0071   045D C0 00 00      cmp b, 0
0072   0460 C6 69 04      je _if2_else
0073   0463             _if2_true:
0074   0463             ;; break; 
0075   0463 0A 89 05      jmp _for1_exit ; for break
0076   0466 0A 86 05      jmp _if2_exit
0077   0469             _if2_else:
0078   0469             ;; if(*fp == '%'){ 
0079   0469             _if3_cond:
0080   0469 FA FD FF      lea d, [bp + -3] ; $fp
0081   046C 2A            mov b, [d]
0082   046D 74            mov d, b
0083   046E 32            mov bl, [d]
0084   046F A7 00         mov bh, 0
0085   0471             ; START RELATIONAL
0086   0471 D7            push a
0087   0472 11            mov a, b
0088   0473 26 25 00      mov b, $25
0089   0476 B0            cmp a, b
0090   0477 FD 71         seq ; ==
0091   0479 E4            pop a
0092   047A             ; END RELATIONAL
0093   047A C0 00 00      cmp b, 0
0094   047D C6 68 05      je _if3_else
0095   0480             _if3_true:
0096   0480             ;; fp++; 
0097   0480 FA FD FF      lea d, [bp + -3] ; $fp
0098   0483 2A            mov b, [d]
0099   0484 FD 79         mov g, b
0100   0486 FD 77         inc b
0101   0488 FA FD FF      lea d, [bp + -3] ; $fp
0102   048B FD 43         mov [d], b
0103   048D FD 27         mov b, g
0104   048F             ;; switch(*fp){ 
0105   048F             _switch4_expr:
0106   048F FA FD FF      lea d, [bp + -3] ; $fp
0107   0492 2A            mov b, [d]
0108   0493 74            mov d, b
0109   0494 32            mov bl, [d]
0110   0495 A7 00         mov bh, 0
0111   0497             _switch4_comparisons:
0112   0497 C1 64         cmp bl, $64
0113   0499 C6 B6 04      je _switch4_case0
0114   049C C1 69         cmp bl, $69
0115   049E C6 B6 04      je _switch4_case1
0116   04A1 C1 75         cmp bl, $75
0117   04A3 C6 DB 04      je _switch4_case2
0118   04A6 C1 63         cmp bl, $63
0119   04A8 C6 00 05      je _switch4_case3
0120   04AB C1 73         cmp bl, $73
0121   04AD C6 25 05      je _switch4_case4
0122   04B0 0A 4A 05      jmp _switch4_default
0123   04B3 0A 56 05      jmp _switch4_exit
0124   04B6             _switch4_case0:
0125   04B6             _switch4_case1:
0126   04B6             ;; prints(*(int*)p); 
0127   04B6 FA FF FF      lea d, [bp + -1] ; $p
0128   04B9 2A            mov b, [d]
0129   04BA 74            mov d, b
0130   04BB 2A            mov b, [d]
0131   04BC FD AB         swp b
0132   04BE D8            push b
0133   04BF 07 8B 05      call prints
0134   04C2 51 02 00      add sp, 2
0135   04C5             ;; p = p + 2; 
0136   04C5 FA FF FF      lea d, [bp + -1] ; $p
0137   04C8 DA            push d
0138   04C9 FA FF FF      lea d, [bp + -1] ; $p
0139   04CC 2A            mov b, [d]
0140   04CD             ; START TERMS
0141   04CD D7            push a
0142   04CE 11            mov a, b
0143   04CF 26 02 00      mov b, $2
0144   04D2 54            add a, b
0145   04D3 27            mov b, a
0146   04D4 E4            pop a
0147   04D5             ; END TERMS
0148   04D5 E7            pop d
0149   04D6 FD 43         mov [d], b
0150   04D8             ;; break; 
0151   04D8 0A 56 05      jmp _switch4_exit ; case break
0152   04DB             _switch4_case2:
0153   04DB             ;; printu(*(unsigned int*)p); 
0154   04DB FA FF FF      lea d, [bp + -1] ; $p
0155   04DE 2A            mov b, [d]
0156   04DF 74            mov d, b
0157   04E0 2A            mov b, [d]
0158   04E1 FD AB         swp b
0159   04E3 D8            push b
0160   04E4 07 80 06      call printu
0161   04E7 51 02 00      add sp, 2
0162   04EA             ;; p = p + 2; 
0163   04EA FA FF FF      lea d, [bp + -1] ; $p
0164   04ED DA            push d
0165   04EE FA FF FF      lea d, [bp + -1] ; $p
0166   04F1 2A            mov b, [d]
0167   04F2             ; START TERMS
0168   04F2 D7            push a
0169   04F3 11            mov a, b
0170   04F4 26 02 00      mov b, $2
0171   04F7 54            add a, b
0172   04F8 27            mov b, a
0173   04F9 E4            pop a
0174   04FA             ; END TERMS
0175   04FA E7            pop d
0176   04FB FD 43         mov [d], b
0177   04FD             ;; break; 
0178   04FD 0A 56 05      jmp _switch4_exit ; case break
0179   0500             _switch4_case3:
0180   0500             ;; putchar(*(char*)p); 
0181   0500 FA FF FF      lea d, [bp + -1] ; $p
0182   0503 2A            mov b, [d]
0183   0504 74            mov d, b
0184   0505 32            mov bl, [d]
0185   0506 A7 00         mov bh, 0
0186   0508 DD            push bl
0187   0509 07 D9 0A      call putchar
0188   050C 51 01 00      add sp, 1
0189   050F             ;; p = p + 2; 
0190   050F FA FF FF      lea d, [bp + -1] ; $p
0191   0512 DA            push d
0192   0513 FA FF FF      lea d, [bp + -1] ; $p
0193   0516 2A            mov b, [d]
0194   0517             ; START TERMS
0195   0517 D7            push a
0196   0518 11            mov a, b
0197   0519 26 02 00      mov b, $2
0198   051C 54            add a, b
0199   051D 27            mov b, a
0200   051E E4            pop a
0201   051F             ; END TERMS
0202   051F E7            pop d
0203   0520 FD 43         mov [d], b
0204   0522             ;; break; 
0205   0522 0A 56 05      jmp _switch4_exit ; case break
0206   0525             _switch4_case4:
0207   0525             ;; print(*(char**)p); 
0208   0525 FA FF FF      lea d, [bp + -1] ; $p
0209   0528 2A            mov b, [d]
0210   0529 74            mov d, b
0211   052A 2A            mov b, [d]
0212   052B FD AB         swp b
0213   052D D8            push b
0214   052E 07 E6 0A      call print
0215   0531 51 02 00      add sp, 2
0216   0534             ;; p = p + 2; 
0217   0534 FA FF FF      lea d, [bp + -1] ; $p
0218   0537 DA            push d
0219   0538 FA FF FF      lea d, [bp + -1] ; $p
0220   053B 2A            mov b, [d]
0221   053C             ; START TERMS
0222   053C D7            push a
0223   053D 11            mov a, b
0224   053E 26 02 00      mov b, $2
0225   0541 54            add a, b
0226   0542 27            mov b, a
0227   0543 E4            pop a
0228   0544             ; END TERMS
0229   0544 E7            pop d
0230   0545 FD 43         mov [d], b
0231   0547             ;; break; 
0232   0547 0A 56 05      jmp _switch4_exit ; case break
0233   054A             _switch4_default:
0234   054A             ;; print("Error: Unknown argument type.\n"); 
0235   054A 26 F9 0A      mov b, __s1 ; "Error: Unknown argument type.\n"
0236   054D FD AB         swp b
0237   054F D8            push b
0238   0550 07 E6 0A      call print
0239   0553 51 02 00      add sp, 2
0240   0556             _switch4_exit:
0241   0556             ;; fp++; 
0242   0556 FA FD FF      lea d, [bp + -3] ; $fp
0243   0559 2A            mov b, [d]
0244   055A FD 79         mov g, b
0245   055C FD 77         inc b
0246   055E FA FD FF      lea d, [bp + -3] ; $fp
0247   0561 FD 43         mov [d], b
0248   0563 FD 27         mov b, g
0249   0565 0A 86 05      jmp _if3_exit
0250   0568             _if3_else:
0251   0568             ;; putchar(*fp); 
0252   0568 FA FD FF      lea d, [bp + -3] ; $fp
0253   056B 2A            mov b, [d]
0254   056C 74            mov d, b
0255   056D 32            mov bl, [d]
0256   056E A7 00         mov bh, 0
0257   0570 DD            push bl
0258   0571 07 D9 0A      call putchar
0259   0574 51 01 00      add sp, 1
0260   0577             ;; fp++; 
0261   0577 FA FD FF      lea d, [bp + -3] ; $fp
0262   057A 2A            mov b, [d]
0263   057B FD 79         mov g, b
0264   057D FD 77         inc b
0265   057F FA FD FF      lea d, [bp + -3] ; $fp
0266   0582 FD 43         mov [d], b
0267   0584 FD 27         mov b, g
0268   0586             _if3_exit:
0269   0586             _if2_exit:
0270   0586             _for1_update:
0271   0586 0A 50 04      jmp _for1_cond
0272   0589             _for1_exit:
0273   0589 F9            leave
0274   058A 09            ret
0275   058B             
0276   058B             prints:
0277   058B F8 00 00      enter 0 ; (push bp; mov bp, sp)
0278   058E             ; $digits 
0279   058E             ; $i 
0280   058E 10 00 00      mov a, $0
0281   0591 45 FA FF      mov [bp + -6], a
0282   0594 52 07 00      sub sp, 7
0283   0597             ;; if (num < 0) { 
0284   0597             _if5_cond:
0285   0597 FA 05 00      lea d, [bp + 5] ; $num
0286   059A 2A            mov b, [d]
0287   059B             ; START RELATIONAL
0288   059B D7            push a
0289   059C 11            mov a, b
0290   059D 26 00 00      mov b, $0
0291   05A0 B0            cmp a, b
0292   05A1 FD 73         slt ; < 
0293   05A3 E4            pop a
0294   05A4             ; END RELATIONAL
0295   05A4 C0 00 00      cmp b, 0
0296   05A7 C6 C4 05      je _if5_else
0297   05AA             _if5_true:
0298   05AA             ;; putchar('-'); 
0299   05AA 26 2D 00      mov b, $2d
0300   05AD DD            push bl
0301   05AE 07 D9 0A      call putchar
0302   05B1 51 01 00      add sp, 1
0303   05B4             ;; num = -num; 
0304   05B4 FA 05 00      lea d, [bp + 5] ; $num
0305   05B7 DA            push d
0306   05B8 FA 05 00      lea d, [bp + 5] ; $num
0307   05BB 2A            mov b, [d]
0308   05BC FD 97         neg b
0309   05BE E7            pop d
0310   05BF FD 43         mov [d], b
0311   05C1 0A E6 05      jmp _if5_exit
0312   05C4             _if5_else:
0313   05C4             ;; if (num == 0) { 
0314   05C4             _if6_cond:
0315   05C4 FA 05 00      lea d, [bp + 5] ; $num
0316   05C7 2A            mov b, [d]
0317   05C8             ; START RELATIONAL
0318   05C8 D7            push a
0319   05C9 11            mov a, b
0320   05CA 26 00 00      mov b, $0
0321   05CD B0            cmp a, b
0322   05CE FD 71         seq ; ==
0323   05D0 E4            pop a
0324   05D1             ; END RELATIONAL
0325   05D1 C0 00 00      cmp b, 0
0326   05D4 C6 E6 05      je _if6_exit
0327   05D7             _if6_true:
0328   05D7             ;; putchar('0'); 
0329   05D7 26 30 00      mov b, $30
0330   05DA DD            push bl
0331   05DB 07 D9 0A      call putchar
0332   05DE 51 01 00      add sp, 1
0333   05E1             ;; return; 
0334   05E1 F9            leave
0335   05E2 09            ret
0336   05E3 0A E6 05      jmp _if6_exit
0337   05E6             _if6_exit:
0338   05E6             _if5_exit:
0339   05E6             ;; while (num > 0) { 
0340   05E6             _while7_cond:
0341   05E6 FA 05 00      lea d, [bp + 5] ; $num
0342   05E9 2A            mov b, [d]
0343   05EA             ; START RELATIONAL
0344   05EA D7            push a
0345   05EB 11            mov a, b
0346   05EC 26 00 00      mov b, $0
0347   05EF B0            cmp a, b
0348   05F0 FD 7F         sgt ; >
0349   05F2 E4            pop a
0350   05F3             ; END RELATIONAL
0351   05F3 C0 00 00      cmp b, 0
0352   05F6 C6 43 06      je _while7_exit
0353   05F9             _while7_block:
0354   05F9             ;; digits[i] = '0' + (num % 10); 
0355   05F9 FA FC FF      lea d, [bp + -4] ; $digits
0356   05FC D7            push a
0357   05FD DA            push d
0358   05FE FA FA FF      lea d, [bp + -6] ; $i
0359   0601 2A            mov b, [d]
0360   0602 E7            pop d
0361   0603 5A            add d, b
0362   0604 E4            pop a
0363   0605 DA            push d
0364   0606 26 30 00      mov b, $30
0365   0609             ; START TERMS
0366   0609 D7            push a
0367   060A 11            mov a, b
0368   060B FA 05 00      lea d, [bp + 5] ; $num
0369   060E 2A            mov b, [d]
0370   060F             ; START FACTORS
0371   060F D7            push a
0372   0610 11            mov a, b
0373   0611 26 0A 00      mov b, $a
0374   0614 AE            div a, b ; 
0375   0615 11            mov a, b
0376   0616 27            mov b, a
0377   0617 E4            pop a
0378   0618             ; END FACTORS
0379   0618 54            add a, b
0380   0619 27            mov b, a
0381   061A E4            pop a
0382   061B             ; END TERMS
0383   061B E7            pop d
0384   061C FD 3E         mov [d], bl
0385   061E             ;; num = num / 10; 
0386   061E FA 05 00      lea d, [bp + 5] ; $num
0387   0621 DA            push d
0388   0622 FA 05 00      lea d, [bp + 5] ; $num
0389   0625 2A            mov b, [d]
0390   0626             ; START FACTORS
0391   0626 D7            push a
0392   0627 11            mov a, b
0393   0628 26 0A 00      mov b, $a
0394   062B AE            div a, b
0395   062C 27            mov b, a
0396   062D E4            pop a
0397   062E             ; END FACTORS
0398   062E E7            pop d
0399   062F FD 43         mov [d], b
0400   0631             ;; i++; 
0401   0631 FA FA FF      lea d, [bp + -6] ; $i
0402   0634 2A            mov b, [d]
0403   0635 FD 79         mov g, b
0404   0637 FD 77         inc b
0405   0639 FA FA FF      lea d, [bp + -6] ; $i
0406   063C FD 43         mov [d], b
0407   063E FD 27         mov b, g
0408   0640 0A E6 05      jmp _while7_cond
0409   0643             _while7_exit:
0410   0643             ;; while (i > 0) { 
0411   0643             _while8_cond:
0412   0643 FA FA FF      lea d, [bp + -6] ; $i
0413   0646 2A            mov b, [d]
0414   0647             ; START RELATIONAL
0415   0647 D7            push a
0416   0648 11            mov a, b
0417   0649 26 00 00      mov b, $0
0418   064C B0            cmp a, b
0419   064D FD 7F         sgt ; >
0420   064F E4            pop a
0421   0650             ; END RELATIONAL
0422   0650 C0 00 00      cmp b, 0
0423   0653 C6 7E 06      je _while8_exit
0424   0656             _while8_block:
0425   0656             ;; i--; 
0426   0656 FA FA FF      lea d, [bp + -6] ; $i
0427   0659 2A            mov b, [d]
0428   065A FD 79         mov g, b
0429   065C FD 7D         dec b
0430   065E FA FA FF      lea d, [bp + -6] ; $i
0431   0661 FD 43         mov [d], b
0432   0663 FD 27         mov b, g
0433   0665             ;; putchar(digits[i]); 
0434   0665 FA FC FF      lea d, [bp + -4] ; $digits
0435   0668 D7            push a
0436   0669 DA            push d
0437   066A FA FA FF      lea d, [bp + -6] ; $i
0438   066D 2A            mov b, [d]
0439   066E E7            pop d
0440   066F 5A            add d, b
0441   0670 E4            pop a
0442   0671 32            mov bl, [d]
0443   0672 A7 00         mov bh, 0
0444   0674 DD            push bl
0445   0675 07 D9 0A      call putchar
0446   0678 51 01 00      add sp, 1
0447   067B 0A 43 06      jmp _while8_cond
0448   067E             _while8_exit:
0449   067E F9            leave
0450   067F 09            ret
0451   0680             
0452   0680             printu:
0453   0680 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0454   0683             ; $digits 
0455   0683             ; $i 
0456   0683 52 07 00      sub sp, 7
0457   0686             ;; i = 0; 
0458   0686 FA FA FF      lea d, [bp + -6] ; $i
0459   0689 DA            push d
0460   068A 26 00 00      mov b, $0
0461   068D E7            pop d
0462   068E FD 43         mov [d], b
0463   0690             ;; if(num == 0){ 
0464   0690             _if9_cond:
0465   0690 FA 05 00      lea d, [bp + 5] ; $num
0466   0693 2A            mov b, [d]
0467   0694             ; START RELATIONAL
0468   0694 D7            push a
0469   0695 11            mov a, b
0470   0696 26 00 00      mov b, $0
0471   0699 B0            cmp a, b
0472   069A FD 71         seq ; ==
0473   069C E4            pop a
0474   069D             ; END RELATIONAL
0475   069D C0 00 00      cmp b, 0
0476   06A0 C6 B2 06      je _if9_exit
0477   06A3             _if9_true:
0478   06A3             ;; putchar('0'); 
0479   06A3 26 30 00      mov b, $30
0480   06A6 DD            push bl
0481   06A7 07 D9 0A      call putchar
0482   06AA 51 01 00      add sp, 1
0483   06AD             ;; return; 
0484   06AD F9            leave
0485   06AE 09            ret
0486   06AF 0A B2 06      jmp _if9_exit
0487   06B2             _if9_exit:
0488   06B2             ;; while (num > 0) { 
0489   06B2             _while10_cond:
0490   06B2 FA 05 00      lea d, [bp + 5] ; $num
0491   06B5 2A            mov b, [d]
0492   06B6             ; START RELATIONAL
0493   06B6 D7            push a
0494   06B7 11            mov a, b
0495   06B8 26 00 00      mov b, $0
0496   06BB B0            cmp a, b
0497   06BC FD 81         sgu ; > (unsigned)
0498   06BE E4            pop a
0499   06BF             ; END RELATIONAL
0500   06BF C0 00 00      cmp b, 0
0501   06C2 C6 0F 07      je _while10_exit
0502   06C5             _while10_block:
0503   06C5             ;; digits[i] = '0' + (num % 10); 
0504   06C5 FA FC FF      lea d, [bp + -4] ; $digits
0505   06C8 D7            push a
0506   06C9 DA            push d
0507   06CA FA FA FF      lea d, [bp + -6] ; $i
0508   06CD 2A            mov b, [d]
0509   06CE E7            pop d
0510   06CF 5A            add d, b
0511   06D0 E4            pop a
0512   06D1 DA            push d
0513   06D2 26 30 00      mov b, $30
0514   06D5             ; START TERMS
0515   06D5 D7            push a
0516   06D6 11            mov a, b
0517   06D7 FA 05 00      lea d, [bp + 5] ; $num
0518   06DA 2A            mov b, [d]
0519   06DB             ; START FACTORS
0520   06DB D7            push a
0521   06DC 11            mov a, b
0522   06DD 26 0A 00      mov b, $a
0523   06E0 AE            div a, b ; 
0524   06E1 11            mov a, b
0525   06E2 27            mov b, a
0526   06E3 E4            pop a
0527   06E4             ; END FACTORS
0528   06E4 54            add a, b
0529   06E5 27            mov b, a
0530   06E6 E4            pop a
0531   06E7             ; END TERMS
0532   06E7 E7            pop d
0533   06E8 FD 3E         mov [d], bl
0534   06EA             ;; num = num / 10; 
0535   06EA FA 05 00      lea d, [bp + 5] ; $num
0536   06ED DA            push d
0537   06EE FA 05 00      lea d, [bp + 5] ; $num
0538   06F1 2A            mov b, [d]
0539   06F2             ; START FACTORS
0540   06F2 D7            push a
0541   06F3 11            mov a, b
0542   06F4 26 0A 00      mov b, $a
0543   06F7 AE            div a, b
0544   06F8 27            mov b, a
0545   06F9 E4            pop a
0546   06FA             ; END FACTORS
0547   06FA E7            pop d
0548   06FB FD 43         mov [d], b
0549   06FD             ;; i++; 
0550   06FD FA FA FF      lea d, [bp + -6] ; $i
0551   0700 2A            mov b, [d]
0552   0701 FD 79         mov g, b
0553   0703 FD 77         inc b
0554   0705 FA FA FF      lea d, [bp + -6] ; $i
0555   0708 FD 43         mov [d], b
0556   070A FD 27         mov b, g
0557   070C 0A B2 06      jmp _while10_cond
0558   070F             _while10_exit:
0559   070F             ;; while (i > 0) { 
0560   070F             _while11_cond:
0561   070F FA FA FF      lea d, [bp + -6] ; $i
0562   0712 2A            mov b, [d]
0563   0713             ; START RELATIONAL
0564   0713 D7            push a
0565   0714 11            mov a, b
0566   0715 26 00 00      mov b, $0
0567   0718 B0            cmp a, b
0568   0719 FD 7F         sgt ; >
0569   071B E4            pop a
0570   071C             ; END RELATIONAL
0571   071C C0 00 00      cmp b, 0
0572   071F C6 4A 07      je _while11_exit
0573   0722             _while11_block:
0574   0722             ;; i--; 
0575   0722 FA FA FF      lea d, [bp + -6] ; $i
0576   0725 2A            mov b, [d]
0577   0726 FD 79         mov g, b
0578   0728 FD 7D         dec b
0579   072A FA FA FF      lea d, [bp + -6] ; $i
0580   072D FD 43         mov [d], b
0581   072F FD 27         mov b, g
0582   0731             ;; putchar(digits[i]); 
0583   0731 FA FC FF      lea d, [bp + -4] ; $digits
0584   0734 D7            push a
0585   0735 DA            push d
0586   0736 FA FA FF      lea d, [bp + -6] ; $i
0587   0739 2A            mov b, [d]
0588   073A E7            pop d
0589   073B 5A            add d, b
0590   073C E4            pop a
0591   073D 32            mov bl, [d]
0592   073E A7 00         mov bh, 0
0593   0740 DD            push bl
0594   0741 07 D9 0A      call putchar
0595   0744 51 01 00      add sp, 1
0596   0747 0A 0F 07      jmp _while11_cond
0597   074A             _while11_exit:
0598   074A F9            leave
0599   074B 09            ret
0600   074C             
0601   074C             include_stdio_asm:
0602   074C F8 00 00      enter 0 ; (push bp; mov bp, sp)
0603   074F             
0604   074F             ; --- BEGIN INLINE ASM BLOCK
0605   074F             .include "lib/stdio.asm"
0001+  074F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  074F             ; stdio.s
0003+  074F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  074F             .include "lib/string.asm"
0001++ 074F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 074F             ; string.s
0003++ 074F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 074F             
0005++ 074F             
0006++ 074F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 074F             ; _strrev
0008++ 074F             ; reverse a string
0009++ 074F             ; D = string address
0010++ 074F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 074F             ; 01234
0012++ 074F             _strrev:
0013++ 074F 4B          	pusha
0014++ 0750 07 96 07    	call _strlen	; length in C
0015++ 0753 12          	mov a, c
0016++ 0754 AF 01 00    	cmp a, 1
0017++ 0757 D0 71 07    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 075A 7D          	dec a
0019++ 075B FD 4E       	mov si, d	; beginning of string
0020++ 075D FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 075F 59          	add d, a	; end of string
0022++ 0760 12          	mov a, c
0023++ 0761 FD 9B       	shr a		; divide by 2
0024++ 0763 39          	mov c, a	; C now counts the steps
0025++ 0764             _strrev_L0:
0026++ 0764 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0765 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0766 3E          	mov [d], al	; store left char into right side
0029++ 0767 1B          	mov al, bl
0030++ 0768 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0769 7E          	dec c
0032++ 076A 7F          	dec d
0033++ 076B C2 00 00    	cmp c, 0
0034++ 076E C7 64 07    	jne _strrev_L0
0035++ 0771             _strrev_end:
0036++ 0771 4C          	popa
0037++ 0772 09          	ret
0038++ 0773             	
0039++ 0773             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0773             ; _strchr
0041++ 0773             ; search string in D for char in AL
0042++ 0773             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0773             _strchr:
0044++ 0773             _strchr_L0:
0045++ 0773 32          	mov bl, [d]
0046++ 0774 C1 00       	cmp bl, 0
0047++ 0776 C6 81 07    	je _strchr_end
0048++ 0779 BA          	cmp al, bl
0049++ 077A C6 81 07    	je _strchr_end
0050++ 077D 79          	inc d
0051++ 077E 0A 73 07    	jmp _strchr_L0
0052++ 0781             _strchr_end:
0053++ 0781 1B          	mov al, bl
0054++ 0782 09          	ret
0055++ 0783             
0056++ 0783             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0783             ; _strstr
0058++ 0783             ; find sub-string
0059++ 0783             ; str1 in SI
0060++ 0783             ; str2 in DI
0061++ 0783             ; SI points to end of source string
0062++ 0783             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0783             _strstr:
0064++ 0783 DB          	push al
0065++ 0784 DA          	push d
0066++ 0785 E3          	push di
0067++ 0786             _strstr_loop:
0068++ 0786 F3          	cmpsb					; compare a byte of the strings
0069++ 0787 C7 92 07    	jne _strstr_ret
0070++ 078A FC 00 00    	lea d, [di + 0]
0071++ 078D BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 078F C7 86 07    	jne _strstr_loop				; equal chars but not at end
0073++ 0792             _strstr_ret:
0074++ 0792 F0          	pop di
0075++ 0793 E7          	pop d
0076++ 0794 E8          	pop al
0077++ 0795 09          	ret
0078++ 0796             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0796             ; length of null terminated string
0080++ 0796             ; result in C
0081++ 0796             ; pointer in D
0082++ 0796             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0796             _strlen:
0084++ 0796 DA          	push d
0085++ 0797 38 00 00    	mov c, 0
0086++ 079A             _strlen_L1:
0087++ 079A BD 00       	cmp byte [d], 0
0088++ 079C C6 A4 07    	je _strlen_ret
0089++ 079F 79          	inc d
0090++ 07A0 78          	inc c
0091++ 07A1 0A 9A 07    	jmp _strlen_L1
0092++ 07A4             _strlen_ret:
0093++ 07A4 E7          	pop d
0094++ 07A5 09          	ret
0095++ 07A6             
0096++ 07A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 07A6             ; STRCMP
0098++ 07A6             ; compare two strings
0099++ 07A6             ; str1 in SI
0100++ 07A6             ; str2 in DI
0101++ 07A6             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 07A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 07A6             _strcmp:
0104++ 07A6 DB          	push al
0105++ 07A7 DA          	push d
0106++ 07A8 E3          	push di
0107++ 07A9 E2          	push si
0108++ 07AA             _strcmp_loop:
0109++ 07AA F3          	cmpsb					; compare a byte of the strings
0110++ 07AB C7 B6 07    	jne _strcmp_ret
0111++ 07AE FB FF FF    	lea d, [si +- 1]
0112++ 07B1 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 07B3 C7 AA 07    	jne _strcmp_loop				; equal chars but not at end
0114++ 07B6             _strcmp_ret:
0115++ 07B6 EF          	pop si
0116++ 07B7 F0          	pop di
0117++ 07B8 E7          	pop d
0118++ 07B9 E8          	pop al
0119++ 07BA 09          	ret
0120++ 07BB             
0121++ 07BB             
0122++ 07BB             ; STRCPY
0123++ 07BB             ; copy null terminated string from SI to DI
0124++ 07BB             ; source in SI
0125++ 07BB             ; destination in DI
0126++ 07BB             _strcpy:
0127++ 07BB E2          	push si
0128++ 07BC E3          	push di
0129++ 07BD DB          	push al
0130++ 07BE             _strcpy_L1:
0131++ 07BE F6          	lodsb
0132++ 07BF F7          	stosb
0133++ 07C0 B9 00       	cmp al, 0
0134++ 07C2 C7 BE 07    	jne _strcpy_L1
0135++ 07C5             _strcpy_end:
0136++ 07C5 E8          	pop al
0137++ 07C6 F0          	pop di
0138++ 07C7 EF          	pop si
0139++ 07C8 09          	ret
0140++ 07C9             
0141++ 07C9             ; STRCAT
0142++ 07C9             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 07C9             ; source in SI
0144++ 07C9             ; destination in DI
0145++ 07C9             _strcat:
0146++ 07C9 E2          	push si
0147++ 07CA E3          	push di
0148++ 07CB D7          	push a
0149++ 07CC DA          	push d
0150++ 07CD 50          	mov a, di
0151++ 07CE 3C          	mov d, a
0152++ 07CF             _strcat_goto_end_L1:
0153++ 07CF BD 00       	cmp byte[d], 0
0154++ 07D1 C6 D8 07    	je _strcat_start
0155++ 07D4 79          	inc d
0156++ 07D5 0A CF 07    	jmp _strcat_goto_end_L1
0157++ 07D8             _strcat_start:
0158++ 07D8 FD 50       	mov di, d
0159++ 07DA             _strcat_L1:
0160++ 07DA F6          	lodsb
0161++ 07DB F7          	stosb
0162++ 07DC B9 00       	cmp al, 0
0163++ 07DE C7 DA 07    	jne _strcat_L1
0164++ 07E1             _strcat_end:
0165++ 07E1 E7          	pop d
0166++ 07E2 E4          	pop a
0167++ 07E3 F0          	pop di
0168++ 07E4 EF          	pop si
0169++ 07E5 09          	ret
0170++ 07E6             
0171++ 07E6             
0005+  07E6             
0006+  07E6             
0007+  07E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  07E6             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  07E6             ; ASCII in BL
0010+  07E6             ; result in AL
0011+  07E6             ; ascii for F = 0100 0110
0012+  07E6             ; ascii for 9 = 0011 1001
0013+  07E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  07E6             hex_ascii_encode:
0015+  07E6 1B            mov al, bl
0016+  07E7 93 40         test al, $40        ; test if letter or number
0017+  07E9 C7 EF 07      jnz hex_letter
0018+  07EC 87 0F         and al, $0F        ; get number
0019+  07EE 09            ret
0020+  07EF             hex_letter:
0021+  07EF 87 0F         and al, $0F        ; get letter
0022+  07F1 6A 09         add al, 9
0023+  07F3 09            ret
0024+  07F4             
0025+  07F4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  07F4             ; ATOI
0027+  07F4             ; 2 letter hex string in B
0028+  07F4             ; 8bit integer returned in AL
0029+  07F4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  07F4             _atoi:
0031+  07F4 D8            push b
0032+  07F5 07 E6 07      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  07F8 30            mov bl, bh
0034+  07F9 DB            push al          ; save a
0035+  07FA 07 E6 07      call hex_ascii_encode
0036+  07FD EA            pop bl  
0037+  07FE FD 9E 04      shl al, 4
0038+  0801 8C            or al, bl
0039+  0802 E5            pop b
0040+  0803 09            ret  
0041+  0804             
0042+  0804             
0043+  0804             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  0804             ; scanf
0045+  0804             ; no need for explanations!
0046+  0804             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  0804             scanf:
0048+  0804 09            ret
0049+  0805             
0050+  0805             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0805             ; ITOA
0052+  0805             ; 8bit value in BL
0053+  0805             ; 2 byte ASCII result in A
0054+  0805             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0805             _itoa:
0056+  0805 DA            push d
0057+  0806 D8            push b
0058+  0807 A7 00         mov bh, 0
0059+  0809 FD A4 04      shr bl, 4  
0060+  080C 74            mov d, b
0061+  080D 1F B5 0A      mov al, [d + s_hex_digits]
0062+  0810 23            mov ah, al
0063+  0811               
0064+  0811 E5            pop b
0065+  0812 D8            push b
0066+  0813 A7 00         mov bh, 0
0067+  0815 FD 87 0F      and bl, $0F
0068+  0818 74            mov d, b
0069+  0819 1F B5 0A      mov al, [d + s_hex_digits]
0070+  081C E5            pop b
0071+  081D E7            pop d
0072+  081E 09            ret
0073+  081F             
0074+  081F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  081F             ; HEX STRING TO BINARY
0076+  081F             ; di = destination address
0077+  081F             ; si = source
0078+  081F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  081F             _hex_to_int:
0080+  081F             _hex_to_int_L1:
0081+  081F F6            lodsb          ; load from [SI] to AL
0082+  0820 B9 00         cmp al, 0        ; check if ASCII 0
0083+  0822 C6 2F 08      jz _hex_to_int_ret
0084+  0825 36            mov bh, al
0085+  0826 F6            lodsb
0086+  0827 2F            mov bl, al
0087+  0828 07 F4 07      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  082B F7            stosb          ; store AL to [DI]
0089+  082C 0A 1F 08      jmp _hex_to_int_L1
0090+  082F             _hex_to_int_ret:
0091+  082F 09            ret    
0092+  0830             
0093+  0830             
0094+  0830             
0095+  0830             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  0830             ; GETCHAR
0097+  0830             ; char in ah
0098+  0830             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  0830             getch:
0100+  0830 DB            push al
0101+  0831             getch_retry:
0102+  0831 19 01         mov al, 1
0103+  0833 05 03         syscall sys_io      ; receive in AH
0104+  0835 E8            pop al
0105+  0836 09            ret
0106+  0837             
0107+  0837             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  0837             ; PUTCHAR
0109+  0837             ; char in ah
0110+  0837             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0837             _putchar:
0112+  0837 D7            push a
0113+  0838 19 00         mov al, 0
0114+  083A 05 03         syscall sys_io      ; char in AH
0115+  083C E4            pop a
0116+  083D 09            ret
0117+  083E             
0118+  083E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  083E             ;; INPUT A STRING
0120+  083E             ;; terminates with null
0121+  083E             ;; pointer in D
0122+  083E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  083E             _gets:
0124+  083E D7            push a
0125+  083F DA            push d
0126+  0840             _gets_loop:
0127+  0840 19 01         mov al, 1
0128+  0842 05 03         syscall sys_io      ; receive in AH
0129+  0844 B9 00         cmp al, 0        ; check error code (AL)
0130+  0846 C6 40 08      je _gets_loop      ; if no char received, retry
0131+  0849             
0132+  0849 76 1B         cmp ah, 27
0133+  084B C6 6C 08      je _gets_ansi_esc
0134+  084E 76 0A         cmp ah, $0A        ; LF
0135+  0850 C6 D7 08      je _gets_end
0136+  0853 76 0D         cmp ah, $0D        ; CR
0137+  0855 C6 D7 08      je _gets_end
0138+  0858 76 5C         cmp ah, $5C        ; '\\'
0139+  085A C6 98 08      je _gets_escape
0140+  085D               
0141+  085D 76 08         cmp ah, $08      ; check for backspace
0142+  085F C6 68 08      je _gets_backspace
0143+  0862             
0144+  0862 1A            mov al, ah
0145+  0863 3E            mov [d], al
0146+  0864 79            inc d
0147+  0865 0A 40 08      jmp _gets_loop
0148+  0868             _gets_backspace:
0149+  0868 7F            dec d
0150+  0869 0A 40 08      jmp _gets_loop
0151+  086C             _gets_ansi_esc:
0152+  086C 19 01         mov al, 1
0153+  086E 05 03         syscall sys_io        ; receive in AH without echo
0154+  0870 B9 00         cmp al, 0          ; check error code (AL)
0155+  0872 C6 6C 08      je _gets_ansi_esc    ; if no char received, retry
0156+  0875 76 5B         cmp ah, '['
0157+  0877 C7 40 08      jne _gets_loop
0158+  087A             _gets_ansi_esc_2:
0159+  087A 19 01         mov al, 1
0160+  087C 05 03         syscall sys_io          ; receive in AH without echo
0161+  087E B9 00         cmp al, 0            ; check error code (AL)
0162+  0880 C6 7A 08      je _gets_ansi_esc_2  ; if no char received, retry
0163+  0883 76 44         cmp ah, 'D'
0164+  0885 C6 90 08      je _gets_left_arrow
0165+  0888 76 43         cmp ah, 'C'
0166+  088A C6 94 08      je _gets_right_arrow
0167+  088D 0A 40 08      jmp _gets_loop
0168+  0890             _gets_left_arrow:
0169+  0890 7F            dec d
0170+  0891 0A 40 08      jmp _gets_loop
0171+  0894             _gets_right_arrow:
0172+  0894 79            inc d
0173+  0895 0A 40 08      jmp _gets_loop
0174+  0898             _gets_escape:
0175+  0898 19 01         mov al, 1
0176+  089A 05 03         syscall sys_io      ; receive in AH
0177+  089C B9 00         cmp al, 0        ; check error code (AL)
0178+  089E C6 98 08      je _gets_escape      ; if no char received, retry
0179+  08A1 76 6E         cmp ah, 'n'
0180+  08A3 C6 C2 08      je _gets_LF
0181+  08A6 76 72         cmp ah, 'r'
0182+  08A8 C6 C9 08      je _gets_CR
0183+  08AB 76 30         cmp ah, '0'
0184+  08AD C6 D0 08      je _gets_NULL
0185+  08B0 76 5C         cmp ah, $5C  ; '\'
0186+  08B2 C6 BB 08      je _gets_slash
0187+  08B5 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0188+  08B6 3E            mov [d], al
0189+  08B7 79            inc d
0190+  08B8 0A 40 08      jmp _gets_loop
0191+  08BB             _gets_slash:
0192+  08BB 19 5C         mov al, $5C
0193+  08BD 3E            mov [d], al
0194+  08BE 79            inc d
0195+  08BF 0A 40 08      jmp _gets_loop
0196+  08C2             _gets_LF:
0197+  08C2 19 0A         mov al, $0A
0198+  08C4 3E            mov [d], al
0199+  08C5 79            inc d
0200+  08C6 0A 40 08      jmp _gets_loop
0201+  08C9             _gets_CR:
0202+  08C9 19 0D         mov al, $0D
0203+  08CB 3E            mov [d], al
0204+  08CC 79            inc d
0205+  08CD 0A 40 08      jmp _gets_loop
0206+  08D0             _gets_NULL:
0207+  08D0 19 00         mov al, $00
0208+  08D2 3E            mov [d], al
0209+  08D3 79            inc d
0210+  08D4 0A 40 08      jmp _gets_loop
0211+  08D7             _gets_end:
0212+  08D7 19 00         mov al, 0
0213+  08D9 3E            mov [d], al        ; terminate string
0214+  08DA E7            pop d
0215+  08DB E4            pop a
0216+  08DC 09            ret
0217+  08DD             
0218+  08DD             
0219+  08DD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0220+  08DD             ;; INPUT TEXT
0221+  08DD             ;; terminated with CTRL+D
0222+  08DD             ;; pointer in D
0223+  08DD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0224+  08DD             _gettxt:
0225+  08DD D7            push a
0226+  08DE DA            push d
0227+  08DF             _gettxt_loop:
0228+  08DF 19 01         mov al, 1
0229+  08E1 05 03         syscall sys_io      ; receive in AH
0230+  08E3 B9 00         cmp al, 0        ; check error code (AL)
0231+  08E5 C6 DF 08      je _gettxt_loop    ; if no char received, retry
0232+  08E8 76 04         cmp ah, 4      ; EOT
0233+  08EA C6 28 09      je _gettxt_end
0234+  08ED 76 08         cmp ah, $08      ; check for backspace
0235+  08EF C6 24 09      je _gettxt_backspace
0236+  08F2 76 5C         cmp ah, $5C        ; '\'
0237+  08F4 C6 FD 08      je _gettxt_escape
0238+  08F7 1A            mov al, ah
0239+  08F8 3E            mov [d], al
0240+  08F9 79            inc d
0241+  08FA 0A DF 08      jmp _gettxt_loop
0242+  08FD             _gettxt_escape:
0243+  08FD 19 01         mov al, 1
0244+  08FF 05 03         syscall sys_io      ; receive in AH
0245+  0901 B9 00         cmp al, 0        ; check error code (AL)
0246+  0903 C6 FD 08      je _gettxt_escape    ; if no char received, retry
0247+  0906 76 6E         cmp ah, 'n'
0248+  0908 C6 16 09      je _gettxt_LF
0249+  090B 76 72         cmp ah, 'r'
0250+  090D C6 1D 09      je _gettxt_CR
0251+  0910 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0252+  0911 3E            mov [d], al
0253+  0912 79            inc d
0254+  0913 0A DF 08      jmp _gettxt_loop
0255+  0916             _gettxt_LF:
0256+  0916 19 0A         mov al, $0A
0257+  0918 3E            mov [d], al
0258+  0919 79            inc d
0259+  091A 0A DF 08      jmp _gettxt_loop
0260+  091D             _gettxt_CR:
0261+  091D 19 0D         mov al, $0D
0262+  091F 3E            mov [d], al
0263+  0920 79            inc d
0264+  0921 0A DF 08      jmp _gettxt_loop
0265+  0924             _gettxt_backspace:
0266+  0924 7F            dec d
0267+  0925 0A DF 08      jmp _gettxt_loop
0268+  0928             _gettxt_end:
0269+  0928 19 00         mov al, 0
0270+  092A 3E            mov [d], al        ; terminate string
0271+  092B E7            pop d
0272+  092C E4            pop a
0273+  092D 09            ret
0274+  092E             
0275+  092E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  092E             ; PRINT NEW LINE
0277+  092E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0278+  092E             printnl:
0279+  092E D7            push a
0280+  092F 10 00 0A      mov a, $0A00
0281+  0932 05 03         syscall sys_io
0282+  0934 10 00 0D      mov a, $0D00
0283+  0937 05 03         syscall sys_io
0284+  0939 E4            pop a
0285+  093A 09            ret
0286+  093B             
0287+  093B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  093B             ; _strtoint
0289+  093B             ; 4 digit hex string number in d
0290+  093B             ; integer returned in A
0291+  093B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0292+  093B             _strtointx:
0293+  093B D8            push b
0294+  093C 32            mov bl, [d]
0295+  093D 37            mov bh, bl
0296+  093E 33 01 00      mov bl, [d + 1]
0297+  0941 07 F4 07      call _atoi        ; convert to int in AL
0298+  0944 23            mov ah, al        ; move to AH
0299+  0945 33 02 00      mov bl, [d + 2]
0300+  0948 37            mov bh, bl
0301+  0949 33 03 00      mov bl, [d + 3]
0302+  094C 07 F4 07      call _atoi        ; convert to int in AL
0303+  094F E5            pop b
0304+  0950 09            ret
0305+  0951             
0306+  0951             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0307+  0951             ; _strtoint
0308+  0951             ; 5 digit base10 string number in d
0309+  0951             ; integer returned in A
0310+  0951             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0311+  0951             _strtoint:
0312+  0951 E2            push si
0313+  0952 D8            push b
0314+  0953 D9            push c
0315+  0954 DA            push d
0316+  0955 07 96 07      call _strlen      ; get string length in C
0317+  0958 7E            dec c
0318+  0959 FD 4E         mov si, d
0319+  095B 12            mov a, c
0320+  095C FD 99         shl a
0321+  095E 3B CD 0A      mov d, table_power
0322+  0961 59            add d, a
0323+  0962 38 00 00      mov c, 0
0324+  0965             _strtoint_L0:
0325+  0965 F6            lodsb      ; load ASCII to al
0326+  0966 B9 00         cmp al, 0
0327+  0968 C6 7B 09      je _strtoint_end
0328+  096B 6F 30         sub al, $30    ; make into integer
0329+  096D 22 00         mov ah, 0
0330+  096F 2A            mov b, [d]
0331+  0970 AC            mul a, b      ; result in B since it fits in 16bits
0332+  0971 11            mov a, b
0333+  0972 28            mov b, c
0334+  0973 54            add a, b
0335+  0974 39            mov c, a
0336+  0975 63 02 00      sub d, 2
0337+  0978 0A 65 09      jmp _strtoint_L0
0338+  097B             _strtoint_end:
0339+  097B 12            mov a, c
0340+  097C E7            pop d
0341+  097D E6            pop c
0342+  097E E5            pop b
0343+  097F EF            pop si
0344+  0980 09            ret
0345+  0981             
0346+  0981             
0347+  0981             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0348+  0981             ; PRINT NULL TERMINATED STRING
0349+  0981             ; pointer in D
0350+  0981             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0351+  0981             _puts:
0352+  0981 D7            push a
0353+  0982 DA            push d
0354+  0983             _puts_L1:
0355+  0983 1E            mov al, [d]
0356+  0984 B9 00         cmp al, 0
0357+  0986 C6 92 09      jz _puts_END
0358+  0989 23            mov ah, al
0359+  098A 19 00         mov al, 0
0360+  098C 05 03         syscall sys_io
0361+  098E 79            inc d
0362+  098F 0A 83 09      jmp _puts_L1
0363+  0992             _puts_END:
0364+  0992 E7            pop d
0365+  0993 E4            pop a
0366+  0994 09            ret
0367+  0995             
0368+  0995             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0369+  0995             ; PRINT N SIZE STRING
0370+  0995             ; pointer in D
0371+  0995             ; size in C
0372+  0995             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0373+  0995             _putsn:
0374+  0995 DB            push al
0375+  0996 DA            push d
0376+  0997 D9            push c
0377+  0998             _putsn_L0:
0378+  0998 1E            mov al, [d]
0379+  0999 23            mov ah, al
0380+  099A 19 00         mov al, 0
0381+  099C 05 03         syscall sys_io
0382+  099E 79            inc d
0383+  099F 7E            dec c  
0384+  09A0 C2 00 00      cmp c, 0
0385+  09A3 C7 98 09      jne _putsn_L0
0386+  09A6             _putsn_end:
0387+  09A6 E6            pop c
0388+  09A7 E7            pop d
0389+  09A8 E8            pop al
0390+  09A9 09            ret
0391+  09AA             
0392+  09AA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0393+  09AA             ; print 16bit decimal number
0394+  09AA             ; input number in A
0395+  09AA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0396+  09AA             print_u16d:
0397+  09AA D7            push a
0398+  09AB D8            push b
0399+  09AC 26 10 27      mov b, 10000
0400+  09AF AE            div a, b      ; get 10000's coeff.
0401+  09B0 07 D2 09      call print_number
0402+  09B3 11            mov a, b
0403+  09B4 26 E8 03      mov b, 1000
0404+  09B7 AE            div a, b      ; get 1000's coeff.
0405+  09B8 07 D2 09      call print_number
0406+  09BB 11            mov a, b
0407+  09BC 26 64 00      mov b, 100
0408+  09BF AE            div a, b
0409+  09C0 07 D2 09      call print_number
0410+  09C3 11            mov a, b
0411+  09C4 26 0A 00      mov b, 10
0412+  09C7 AE            div a, b
0413+  09C8 07 D2 09      call print_number
0414+  09CB 1B            mov al, bl      ; 1's coeff in bl
0415+  09CC 07 D2 09      call print_number
0416+  09CF E5            pop b
0417+  09D0 E4            pop a
0418+  09D1 09            ret
0419+  09D2             
0420+  09D2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0421+  09D2             ; print AL
0422+  09D2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0423+  09D2             print_number:
0424+  09D2 6A 30         add al, $30
0425+  09D4 23            mov ah, al
0426+  09D5 07 37 08      call _putchar
0427+  09D8 09            ret
0428+  09D9             
0429+  09D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0430+  09D9             ; PRINT 16BIT HEX INTEGER
0431+  09D9             ; integer value in reg B
0432+  09D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  09D9             print_u16x:
0434+  09D9 D7            push a
0435+  09DA D8            push b
0436+  09DB DD            push bl
0437+  09DC 30            mov bl, bh
0438+  09DD 07 05 08      call _itoa        ; convert bh to char in A
0439+  09E0 2F            mov bl, al        ; save al
0440+  09E1 19 00         mov al, 0
0441+  09E3 05 03         syscall sys_io        ; display AH
0442+  09E5 24            mov ah, bl        ; retrieve al
0443+  09E6 19 00         mov al, 0
0444+  09E8 05 03         syscall sys_io        ; display AL
0445+  09EA             
0446+  09EA EA            pop bl
0447+  09EB 07 05 08      call _itoa        ; convert bh to char in A
0448+  09EE 2F            mov bl, al        ; save al
0449+  09EF 19 00         mov al, 0
0450+  09F1 05 03         syscall sys_io        ; display AH
0451+  09F3 24            mov ah, bl        ; retrieve al
0452+  09F4 19 00         mov al, 0
0453+  09F6 05 03         syscall sys_io        ; display AL
0454+  09F8             
0455+  09F8 E5            pop b
0456+  09F9 E4            pop a
0457+  09FA 09            ret
0458+  09FB             
0459+  09FB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0460+  09FB             ; INPUT 16BIT HEX INTEGER
0461+  09FB             ; read 16bit integer into A
0462+  09FB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0463+  09FB             scan_u16x:
0464+  09FB F8 10 00      enter 16
0465+  09FE D8            push b
0466+  09FF DA            push d
0467+  0A00             
0468+  0A00 FA F1 FF      lea d, [bp + -15]
0469+  0A03 07 3E 08      call _gets        ; get number
0470+  0A06             
0471+  0A06 32            mov bl, [d]
0472+  0A07 37            mov bh, bl
0473+  0A08 33 01 00      mov bl, [d + 1]
0474+  0A0B 07 F4 07      call _atoi        ; convert to int in AL
0475+  0A0E 23            mov ah, al        ; move to AH
0476+  0A0F             
0477+  0A0F 33 02 00      mov bl, [d + 2]
0478+  0A12 37            mov bh, bl
0479+  0A13 33 03 00      mov bl, [d + 3]
0480+  0A16 07 F4 07      call _atoi        ; convert to int in AL
0481+  0A19             
0482+  0A19 E7            pop d
0483+  0A1A E5            pop b
0484+  0A1B F9            leave
0485+  0A1C 09            ret
0486+  0A1D             
0487+  0A1D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0488+  0A1D             ; PRINT 8bit HEX INTEGER
0489+  0A1D             ; integer value in reg bl
0490+  0A1D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0491+  0A1D             print_u8x:
0492+  0A1D D7            push a
0493+  0A1E DD            push bl
0494+  0A1F             
0495+  0A1F 07 05 08      call _itoa        ; convert bl to char in A
0496+  0A22 2F            mov bl, al        ; save al
0497+  0A23 19 00         mov al, 0
0498+  0A25 05 03         syscall sys_io        ; display AH
0499+  0A27 24            mov ah, bl        ; retrieve al
0500+  0A28 19 00         mov al, 0
0501+  0A2A 05 03         syscall sys_io        ; display AL
0502+  0A2C             
0503+  0A2C EA            pop bl
0504+  0A2D E4            pop a
0505+  0A2E 09            ret
0506+  0A2F             
0507+  0A2F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0508+  0A2F             ; print 8bit decimal unsigned number
0509+  0A2F             ; input number in AL
0510+  0A2F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0511+  0A2F             print_u8d:
0512+  0A2F D7            push a
0513+  0A30 D8            push b
0514+  0A31             
0515+  0A31 22 00         mov ah, 0
0516+  0A33 26 64 00      mov b, 100
0517+  0A36 AE            div a, b
0518+  0A37 D8            push b      ; save remainder
0519+  0A38 B9 00         cmp al, 0
0520+  0A3A C6 44 0A      je skip100
0521+  0A3D 6A 30         add al, $30
0522+  0A3F 23            mov ah, al
0523+  0A40 19 00         mov al, 0
0524+  0A42 05 03         syscall sys_io  ; print coeff
0525+  0A44             skip100:
0526+  0A44 E4            pop a
0527+  0A45 22 00         mov ah, 0
0528+  0A47 26 0A 00      mov b, 10
0529+  0A4A AE            div a, b
0530+  0A4B D8            push b      ; save remainder
0531+  0A4C B9 00         cmp al, 0
0532+  0A4E C6 58 0A      je skip10
0533+  0A51 6A 30         add al, $30
0534+  0A53 23            mov ah, al
0535+  0A54 19 00         mov al, 0
0536+  0A56 05 03         syscall sys_io  ; print coeff
0537+  0A58             skip10:
0538+  0A58 E4            pop a
0539+  0A59 1B            mov al, bl
0540+  0A5A 6A 30         add al, $30
0541+  0A5C 23            mov ah, al
0542+  0A5D 19 00         mov al, 0
0543+  0A5F 05 03         syscall sys_io  ; print coeff
0544+  0A61 E5            pop b
0545+  0A62 E4            pop a
0546+  0A63 09            ret
0547+  0A64             
0548+  0A64             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0549+  0A64             ; INPUT 8BIT HEX INTEGER
0550+  0A64             ; read 8bit integer into AL
0551+  0A64             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0552+  0A64             scan_u8x:
0553+  0A64 F8 04 00      enter 4
0554+  0A67 D8            push b
0555+  0A68 DA            push d
0556+  0A69             
0557+  0A69 FA FD FF      lea d, [bp + -3]
0558+  0A6C 07 3E 08      call _gets        ; get number
0559+  0A6F             
0560+  0A6F 32            mov bl, [d]
0561+  0A70 37            mov bh, bl
0562+  0A71 33 01 00      mov bl, [d + 1]
0563+  0A74 07 F4 07      call _atoi        ; convert to int in AL
0564+  0A77             
0565+  0A77 E7            pop d
0566+  0A78 E5            pop b
0567+  0A79 F9            leave
0568+  0A7A 09            ret
0569+  0A7B             
0570+  0A7B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  0A7B             ; input decimal number
0572+  0A7B             ; result in A
0573+  0A7B             ; 655'\0'
0574+  0A7B             ; low--------high
0575+  0A7B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0576+  0A7B             scan_u16d:
0577+  0A7B F8 08 00      enter 8
0578+  0A7E E2            push si
0579+  0A7F D8            push b
0580+  0A80 D9            push c
0581+  0A81 DA            push d
0582+  0A82 FA F9 FF      lea d, [bp +- 7]
0583+  0A85 07 3E 08      call _gets
0584+  0A88 07 96 07      call _strlen      ; get string length in C
0585+  0A8B 7E            dec c
0586+  0A8C FD 4E         mov si, d
0587+  0A8E 12            mov a, c
0588+  0A8F FD 99         shl a
0589+  0A91 3B CD 0A      mov d, table_power
0590+  0A94 59            add d, a
0591+  0A95 38 00 00      mov c, 0
0592+  0A98             mul_loop:
0593+  0A98 F6            lodsb      ; load ASCII to al
0594+  0A99 B9 00         cmp al, 0
0595+  0A9B C6 AE 0A      je mul_exit
0596+  0A9E 6F 30         sub al, $30    ; make into integer
0597+  0AA0 22 00         mov ah, 0
0598+  0AA2 2A            mov b, [d]
0599+  0AA3 AC            mul a, b      ; result in B since it fits in 16bits
0600+  0AA4 11            mov a, b
0601+  0AA5 28            mov b, c
0602+  0AA6 54            add a, b
0603+  0AA7 39            mov c, a
0604+  0AA8 63 02 00      sub d, 2
0605+  0AAB 0A 98 0A      jmp mul_loop
0606+  0AAE             mul_exit:
0607+  0AAE 12            mov a, c
0608+  0AAF E7            pop d
0609+  0AB0 E6            pop c
0610+  0AB1 E5            pop b
0611+  0AB2 EF            pop si
0612+  0AB3 F9            leave
0613+  0AB4 09            ret
0614+  0AB5             
0615+  0AB5             
0616+  0AB5 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0616+  0AB9 34 35 36 37 
0616+  0ABD 38 39 41 42 
0616+  0AC1 43 44 45 46 
0617+  0AC5 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0617+  0AC9 1B 5B 48 00 
0618+  0ACD             
0619+  0ACD             table_power:
0620+  0ACD 01 00         .dw 1
0621+  0ACF 0A 00         .dw 10
0622+  0AD1 64 00         .dw 100
0623+  0AD3 E8 03         .dw 1000
0624+  0AD5 10 27         .dw 100000606   0AD7             ; --- END INLINE ASM BLOCK
0607   0AD7             
0608   0AD7 F9            leave
0609   0AD8 09            ret
0610   0AD9             
0611   0AD9             putchar:
0612   0AD9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0613   0ADC             
0614   0ADC             ; --- BEGIN INLINE ASM BLOCK
0615   0ADC FA 05 00      lea d, [bp + 5] ; $c
0616   0ADF 1E            mov al, [d]
0617   0AE0 23            mov ah, al
0618   0AE1 07 37 08      call _putchar
0619   0AE4             ; --- END INLINE ASM BLOCK
0620   0AE4             
0621   0AE4 F9            leave
0622   0AE5 09            ret
0623   0AE6             
0624   0AE6             print:
0625   0AE6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0626   0AE9             
0627   0AE9             ; --- BEGIN INLINE ASM BLOCK
0628   0AE9 FA 05 00      lea d, [bp + 5] ; $s
0629   0AEC FD 2A         mov d, [d]
0630   0AEE 07 81 09      call _puts
0631   0AF1             ; --- END INLINE ASM BLOCK
0632   0AF1             
0633   0AF1 F9            leave
0634   0AF2 09            ret
0635   0AF3             ; --- END TEXT BLOCK
0636   0AF3             
0637   0AF3             ; --- BEGIN DATA BLOCK
0638   0AF3 50 61 75 6C __s0: .db "Paulo", 0
0638   0AF7 6F 00 
0639   0AF9 45 72 72 6F __s1: .db "Error: Unknown argument type.\n", 0
0639   0AFD 72 3A 20 55 
0639   0B01 6E 6B 6E 6F 
0639   0B05 77 6E 20 61 
0639   0B09 72 67 75 6D 
0639   0B0D 65 6E 74 20 
0639   0B11 74 79 70 65 
0639   0B15 2E 0A 00 
0640   0B18             
0641   0B18 1A 0B       _heap_top: .dw _heap
0642   0B1A 00          _heap: .db 0
0643   0B1B             ; --- END DATA BLOCK
0644   0B1B             
0645   0B1B             .end
tasm: Number of errors = 0
