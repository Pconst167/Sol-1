0001   0000             ; --- FILENAME: test
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ;; test_globalvars(); 
0011   0408 07 FD 13      call test_globalvars
0012   040B 05 0B         syscall sys_terminate_proc
0013   040D             
0014   040D             strcpy:
0015   040D F8 00 00      enter 0 ; (push bp; mov bp, sp)
0016   0410             ; $psrc 
0017   0410             ; $pdest 
0018   0410 52 04 00      sub sp, 4
0019   0413             ;; psrc = src; 
0020   0413 FA FF FF      lea d, [bp + -1] ; $psrc
0021   0416 DA            push d
0022   0417 FA 07 00      lea d, [bp + 7] ; $src
0023   041A 2A            mov b, [d]
0024   041B E7            pop d
0025   041C FD 43         mov [d], b
0026   041E             ;; pdest = dest; 
0027   041E FA FD FF      lea d, [bp + -3] ; $pdest
0028   0421 DA            push d
0029   0422 FA 05 00      lea d, [bp + 5] ; $dest
0030   0425 2A            mov b, [d]
0031   0426 E7            pop d
0032   0427 FD 43         mov [d], b
0033   0429             ;; while(*psrc) *pdest++ = *psrc++; 
0034   0429             _while1_cond:
0035   0429 FA FF FF      lea d, [bp + -1] ; $psrc
0036   042C 2A            mov b, [d]
0037   042D 74            mov d, b
0038   042E 32            mov bl, [d]
0039   042F A7 00         mov bh, 0
0040   0431 C0 00 00      cmp b, 0
0041   0434 C6 5C 04      je _while1_exit
0042   0437             _while1_block:
0043   0437             ;; *pdest++ = *psrc++; 
0044   0437 FA FD FF      lea d, [bp + -3] ; $pdest
0045   043A 2A            mov b, [d]
0046   043B D8            push b
0047   043C FD 77         inc b
0048   043E FA FD FF      lea d, [bp + -3] ; $pdest
0049   0441 FD 43         mov [d], b
0050   0443 E5            pop b
0051   0444 D8            push b
0052   0445 FA FF FF      lea d, [bp + -1] ; $psrc
0053   0448 2A            mov b, [d]
0054   0449 D8            push b
0055   044A FD 77         inc b
0056   044C FA FF FF      lea d, [bp + -1] ; $psrc
0057   044F FD 43         mov [d], b
0058   0451 E5            pop b
0059   0452 74            mov d, b
0060   0453 32            mov bl, [d]
0061   0454 A7 00         mov bh, 0
0062   0456 E7            pop d
0063   0457 FD 3E         mov [d], bl
0064   0459 0A 29 04      jmp _while1_cond
0065   045C             _while1_exit:
0066   045C             ;; *pdest = '\0'; 
0067   045C FA FD FF      lea d, [bp + -3] ; $pdest
0068   045F 2A            mov b, [d]
0069   0460 D8            push b
0070   0461 26 00 00      mov b, $0
0071   0464 E7            pop d
0072   0465 FD 3E         mov [d], bl
0073   0467 F9            leave
0074   0468 09            ret
0075   0469             
0076   0469             strcmp:
0077   0469 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0078   046C             ;; while (*s1 && (*s1 == *s2)) { 
0079   046C             _while2_cond:
0080   046C FA 05 00      lea d, [bp + 5] ; $s1
0081   046F 2A            mov b, [d]
0082   0470 74            mov d, b
0083   0471 32            mov bl, [d]
0084   0472 A7 00         mov bh, 0
0085   0474 D7            push a
0086   0475 11            mov a, b
0087   0476 FA 05 00      lea d, [bp + 5] ; $s1
0088   0479 2A            mov b, [d]
0089   047A 74            mov d, b
0090   047B 32            mov bl, [d]
0091   047C A7 00         mov bh, 0
0092   047E             ; START RELATIONAL
0093   047E D7            push a
0094   047F 11            mov a, b
0095   0480 FA 07 00      lea d, [bp + 7] ; $s2
0096   0483 2A            mov b, [d]
0097   0484 74            mov d, b
0098   0485 32            mov bl, [d]
0099   0486 A7 00         mov bh, 0
0100   0488 B0            cmp a, b
0101   0489 FD 71         seq ; ==
0102   048B E4            pop a
0103   048C             ; END RELATIONAL
0104   048C FD A7         sand a, b ; &&
0105   048E E4            pop a
0106   048F C0 00 00      cmp b, 0
0107   0492 C6 B2 04      je _while2_exit
0108   0495             _while2_block:
0109   0495             ;; s1++; 
0110   0495 FA 05 00      lea d, [bp + 5] ; $s1
0111   0498 2A            mov b, [d]
0112   0499 D8            push b
0113   049A FD 77         inc b
0114   049C FA 05 00      lea d, [bp + 5] ; $s1
0115   049F FD 43         mov [d], b
0116   04A1 E5            pop b
0117   04A2             ;; s2++; 
0118   04A2 FA 07 00      lea d, [bp + 7] ; $s2
0119   04A5 2A            mov b, [d]
0120   04A6 D8            push b
0121   04A7 FD 77         inc b
0122   04A9 FA 07 00      lea d, [bp + 7] ; $s2
0123   04AC FD 43         mov [d], b
0124   04AE E5            pop b
0125   04AF 0A 6C 04      jmp _while2_cond
0126   04B2             _while2_exit:
0127   04B2             ;; return *s1 - *s2; 
0128   04B2 FA 05 00      lea d, [bp + 5] ; $s1
0129   04B5 2A            mov b, [d]
0130   04B6 74            mov d, b
0131   04B7 32            mov bl, [d]
0132   04B8 A7 00         mov bh, 0
0133   04BA             ; START TERMS
0134   04BA D7            push a
0135   04BB 11            mov a, b
0136   04BC FA 07 00      lea d, [bp + 7] ; $s2
0137   04BF 2A            mov b, [d]
0138   04C0 74            mov d, b
0139   04C1 32            mov bl, [d]
0140   04C2 A7 00         mov bh, 0
0141   04C4 60            sub a, b
0142   04C5 27            mov b, a
0143   04C6 E4            pop a
0144   04C7             ; END TERMS
0145   04C7 F9            leave
0146   04C8 09            ret
0147   04C9             
0148   04C9             strcat:
0149   04C9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0150   04CC             ; $dest_len 
0151   04CC             ; $i 
0152   04CC 52 04 00      sub sp, 4
0153   04CF             ;; dest_len = strlen(dest); 
0154   04CF FA FF FF      lea d, [bp + -1] ; $dest_len
0155   04D2 DA            push d
0156   04D3 FA 05 00      lea d, [bp + 5] ; $dest
0157   04D6 2A            mov b, [d]
0158   04D7 FD AB         swp b
0159   04D9 D8            push b
0160   04DA 07 7C 05      call strlen
0161   04DD 51 02 00      add sp, 2
0162   04E0 E7            pop d
0163   04E1 FD 43         mov [d], b
0164   04E3             ;; for (i = 0; src[i] != 0; i=i+1) { 
0165   04E3             _for3_init:
0166   04E3 FA FD FF      lea d, [bp + -3] ; $i
0167   04E6 DA            push d
0168   04E7 26 00 00      mov b, $0
0169   04EA E7            pop d
0170   04EB FD 43         mov [d], b
0171   04ED             _for3_cond:
0172   04ED FA 07 00      lea d, [bp + 7] ; $src
0173   04F0 FD 2A         mov d, [d]
0174   04F2 D7            push a
0175   04F3 DA            push d
0176   04F4 FA FD FF      lea d, [bp + -3] ; $i
0177   04F7 2A            mov b, [d]
0178   04F8 E7            pop d
0179   04F9 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0180   04FD E4            pop a
0181   04FE 32            mov bl, [d]
0182   04FF A7 00         mov bh, 0
0183   0501             ; START RELATIONAL
0184   0501 D7            push a
0185   0502 11            mov a, b
0186   0503 26 00 00      mov b, $0
0187   0506 B0            cmp a, b
0188   0507 FD 72         sneq ; !=
0189   0509 E4            pop a
0190   050A             ; END RELATIONAL
0191   050A C0 00 00      cmp b, 0
0192   050D C6 56 05      je _for3_exit
0193   0510             _for3_block:
0194   0510             ;; dest[dest_len + i] = src[i]; 
0195   0510 FA 05 00      lea d, [bp + 5] ; $dest
0196   0513 FD 2A         mov d, [d]
0197   0515 D7            push a
0198   0516 DA            push d
0199   0517 FA FF FF      lea d, [bp + -1] ; $dest_len
0200   051A 2A            mov b, [d]
0201   051B             ; START TERMS
0202   051B D7            push a
0203   051C 11            mov a, b
0204   051D FA FD FF      lea d, [bp + -3] ; $i
0205   0520 2A            mov b, [d]
0206   0521 56            add b, a
0207   0522 E4            pop a
0208   0523             ; END TERMS
0209   0523 E7            pop d
0210   0524 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0211   0528 E4            pop a
0212   0529 DA            push d
0213   052A FA 07 00      lea d, [bp + 7] ; $src
0214   052D FD 2A         mov d, [d]
0215   052F D7            push a
0216   0530 DA            push d
0217   0531 FA FD FF      lea d, [bp + -3] ; $i
0218   0534 2A            mov b, [d]
0219   0535 E7            pop d
0220   0536 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0221   053A E4            pop a
0222   053B 32            mov bl, [d]
0223   053C A7 00         mov bh, 0
0224   053E E7            pop d
0225   053F FD 3E         mov [d], bl
0226   0541             _for3_update:
0227   0541 FA FD FF      lea d, [bp + -3] ; $i
0228   0544 DA            push d
0229   0545 FA FD FF      lea d, [bp + -3] ; $i
0230   0548 2A            mov b, [d]
0231   0549             ; START TERMS
0232   0549 D7            push a
0233   054A 11            mov a, b
0234   054B 26 01 00      mov b, $1
0235   054E 56            add b, a
0236   054F E4            pop a
0237   0550             ; END TERMS
0238   0550 E7            pop d
0239   0551 FD 43         mov [d], b
0240   0553 0A ED 04      jmp _for3_cond
0241   0556             _for3_exit:
0242   0556             ;; dest[dest_len + i] = 0; 
0243   0556 FA 05 00      lea d, [bp + 5] ; $dest
0244   0559 FD 2A         mov d, [d]
0245   055B D7            push a
0246   055C DA            push d
0247   055D FA FF FF      lea d, [bp + -1] ; $dest_len
0248   0560 2A            mov b, [d]
0249   0561             ; START TERMS
0250   0561 D7            push a
0251   0562 11            mov a, b
0252   0563 FA FD FF      lea d, [bp + -3] ; $i
0253   0566 2A            mov b, [d]
0254   0567 56            add b, a
0255   0568 E4            pop a
0256   0569             ; END TERMS
0257   0569 E7            pop d
0258   056A FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0259   056E E4            pop a
0260   056F DA            push d
0261   0570 26 00 00      mov b, $0
0262   0573 E7            pop d
0263   0574 FD 3E         mov [d], bl
0264   0576             ;; return dest; 
0265   0576 FA 05 00      lea d, [bp + 5] ; $dest
0266   0579 2A            mov b, [d]
0267   057A F9            leave
0268   057B 09            ret
0269   057C             
0270   057C             strlen:
0271   057C F8 00 00      enter 0 ; (push bp; mov bp, sp)
0272   057F             ; $length 
0273   057F 52 02 00      sub sp, 2
0274   0582             ;; length = 0; 
0275   0582 FA FF FF      lea d, [bp + -1] ; $length
0276   0585 DA            push d
0277   0586 26 00 00      mov b, $0
0278   0589 E7            pop d
0279   058A FD 43         mov [d], b
0280   058C             ;; while (str[length] != 0) { 
0281   058C             _while4_cond:
0282   058C FA 05 00      lea d, [bp + 5] ; $str
0283   058F FD 2A         mov d, [d]
0284   0591 D7            push a
0285   0592 DA            push d
0286   0593 FA FF FF      lea d, [bp + -1] ; $length
0287   0596 2A            mov b, [d]
0288   0597 E7            pop d
0289   0598 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0290   059C E4            pop a
0291   059D 32            mov bl, [d]
0292   059E A7 00         mov bh, 0
0293   05A0             ; START RELATIONAL
0294   05A0 D7            push a
0295   05A1 11            mov a, b
0296   05A2 26 00 00      mov b, $0
0297   05A5 B0            cmp a, b
0298   05A6 FD 72         sneq ; !=
0299   05A8 E4            pop a
0300   05A9             ; END RELATIONAL
0301   05A9 C0 00 00      cmp b, 0
0302   05AC C6 BF 05      je _while4_exit
0303   05AF             _while4_block:
0304   05AF             ;; length++; 
0305   05AF FA FF FF      lea d, [bp + -1] ; $length
0306   05B2 2A            mov b, [d]
0307   05B3 D8            push b
0308   05B4 FD 77         inc b
0309   05B6 FA FF FF      lea d, [bp + -1] ; $length
0310   05B9 FD 43         mov [d], b
0311   05BB E5            pop b
0312   05BC 0A 8C 05      jmp _while4_cond
0313   05BF             _while4_exit:
0314   05BF             ;; return length; 
0315   05BF FA FF FF      lea d, [bp + -1] ; $length
0316   05C2 2A            mov b, [d]
0317   05C3 F9            leave
0318   05C4 09            ret
0319   05C5             
0320   05C5             scanf:
0321   05C5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0322   05C8             ; $p 
0323   05C8             ; $format_p 
0324   05C8             ; $c 
0325   05C8             ; $i 
0326   05C8             ; $input_string 
0327   05C8 52 07 02      sub sp, 519
0328   05CB             ;; format_p = format; 
0329   05CB FA FD FF      lea d, [bp + -3] ; $format_p
0330   05CE DA            push d
0331   05CF FA 05 00      lea d, [bp + 5] ; $format
0332   05D2 2A            mov b, [d]
0333   05D3 E7            pop d
0334   05D4 FD 43         mov [d], b
0335   05D6             ;; p = &format + 2; 
0336   05D6 FA FF FF      lea d, [bp + -1] ; $p
0337   05D9 DA            push d
0338   05DA FA 05 00      lea d, [bp + 5] ; $format
0339   05DD 2D            mov b, d
0340   05DE             ; START TERMS
0341   05DE D7            push a
0342   05DF 11            mov a, b
0343   05E0 26 02 00      mov b, $2
0344   05E3 56            add b, a
0345   05E4 E4            pop a
0346   05E5             ; END TERMS
0347   05E5 E7            pop d
0348   05E6 FD 43         mov [d], b
0349   05E8             ;; for(;;){ 
0350   05E8             _for5_init:
0351   05E8             _for5_cond:
0352   05E8             _for5_block:
0353   05E8             ;; if(!*format_p) break; 
0354   05E8             _if6_cond:
0355   05E8 FA FD FF      lea d, [bp + -3] ; $format_p
0356   05EB 2A            mov b, [d]
0357   05EC 74            mov d, b
0358   05ED 32            mov bl, [d]
0359   05EE A7 00         mov bh, 0
0360   05F0 C0 00 00      cmp b, 0
0361   05F3 FD 71         seq ; !
0362   05F5 C0 00 00      cmp b, 0
0363   05F8 C6 01 06      je _if6_else
0364   05FB             _if6_true:
0365   05FB             ;; break; 
0366   05FB 0A FE 07      jmp _for5_exit ; for break
0367   05FE 0A FB 07      jmp _if6_exit
0368   0601             _if6_else:
0369   0601             ;; if(*format_p == '%'){ 
0370   0601             _if7_cond:
0371   0601 FA FD FF      lea d, [bp + -3] ; $format_p
0372   0604 2A            mov b, [d]
0373   0605 74            mov d, b
0374   0606 32            mov bl, [d]
0375   0607 A7 00         mov bh, 0
0376   0609             ; START RELATIONAL
0377   0609 D7            push a
0378   060A 11            mov a, b
0379   060B 26 25 00      mov b, $25
0380   060E B0            cmp a, b
0381   060F FD 71         seq ; ==
0382   0611 E4            pop a
0383   0612             ; END RELATIONAL
0384   0612 C0 00 00      cmp b, 0
0385   0615 C6 DF 07      je _if7_else
0386   0618             _if7_true:
0387   0618             ;; format_p++; 
0388   0618 FA FD FF      lea d, [bp + -3] ; $format_p
0389   061B 2A            mov b, [d]
0390   061C D8            push b
0391   061D FD 77         inc b
0392   061F FA FD FF      lea d, [bp + -3] ; $format_p
0393   0622 FD 43         mov [d], b
0394   0624 E5            pop b
0395   0625             ;; switch(*format_p){ 
0396   0625             _switch8_expr:
0397   0625 FA FD FF      lea d, [bp + -3] ; $format_p
0398   0628 2A            mov b, [d]
0399   0629 74            mov d, b
0400   062A 32            mov bl, [d]
0401   062B A7 00         mov bh, 0
0402   062D             _switch8_comparisons:
0403   062D C1 6C         cmp bl, $6c
0404   062F C6 5B 06      je _switch8_case0
0405   0632 C1 4C         cmp bl, $4c
0406   0634 C6 5B 06      je _switch8_case1
0407   0637 C1 64         cmp bl, $64
0408   0639 C6 ED 06      je _switch8_case2
0409   063C C1 69         cmp bl, $69
0410   063E C6 ED 06      je _switch8_case3
0411   0641 C1 75         cmp bl, $75
0412   0643 C6 1A 07      je _switch8_case4
0413   0646 C1 78         cmp bl, $78
0414   0648 C6 47 07      je _switch8_case5
0415   064B C1 63         cmp bl, $63
0416   064D C6 5C 07      je _switch8_case6
0417   0650 C1 73         cmp bl, $73
0418   0652 C6 8B 07      je _switch8_case7
0419   0655 0A C3 07      jmp _switch8_default
0420   0658 0A CF 07      jmp _switch8_exit
0421   065B             _switch8_case0:
0422   065B             _switch8_case1:
0423   065B             ;; format_p++; 
0424   065B FA FD FF      lea d, [bp + -3] ; $format_p
0425   065E 2A            mov b, [d]
0426   065F D8            push b
0427   0660 FD 77         inc b
0428   0662 FA FD FF      lea d, [bp + -3] ; $format_p
0429   0665 FD 43         mov [d], b
0430   0667 E5            pop b
0431   0668             ;; if(*format_p == 'd' || *format_p == 'i'); 
0432   0668             _if9_cond:
0433   0668 FA FD FF      lea d, [bp + -3] ; $format_p
0434   066B 2A            mov b, [d]
0435   066C 74            mov d, b
0436   066D 32            mov bl, [d]
0437   066E A7 00         mov bh, 0
0438   0670             ; START RELATIONAL
0439   0670 D7            push a
0440   0671 11            mov a, b
0441   0672 26 64 00      mov b, $64
0442   0675 B0            cmp a, b
0443   0676 FD 71         seq ; ==
0444   0678 E4            pop a
0445   0679             ; END RELATIONAL
0446   0679 D7            push a
0447   067A 11            mov a, b
0448   067B FA FD FF      lea d, [bp + -3] ; $format_p
0449   067E 2A            mov b, [d]
0450   067F 74            mov d, b
0451   0680 32            mov bl, [d]
0452   0681 A7 00         mov bh, 0
0453   0683             ; START RELATIONAL
0454   0683 D7            push a
0455   0684 11            mov a, b
0456   0685 26 69 00      mov b, $69
0457   0688 B0            cmp a, b
0458   0689 FD 71         seq ; ==
0459   068B E4            pop a
0460   068C             ; END RELATIONAL
0461   068C FD A8         sor a, b ; ||
0462   068E E4            pop a
0463   068F C0 00 00      cmp b, 0
0464   0692 C6 98 06      je _if9_else
0465   0695             _if9_true:
0466   0695             ;; ; 
0467   0695 0A D8 06      jmp _if9_exit
0468   0698             _if9_else:
0469   0698             ;; if(*format_p == 'u'); 
0470   0698             _if10_cond:
0471   0698 FA FD FF      lea d, [bp + -3] ; $format_p
0472   069B 2A            mov b, [d]
0473   069C 74            mov d, b
0474   069D 32            mov bl, [d]
0475   069E A7 00         mov bh, 0
0476   06A0             ; START RELATIONAL
0477   06A0 D7            push a
0478   06A1 11            mov a, b
0479   06A2 26 75 00      mov b, $75
0480   06A5 B0            cmp a, b
0481   06A6 FD 71         seq ; ==
0482   06A8 E4            pop a
0483   06A9             ; END RELATIONAL
0484   06A9 C0 00 00      cmp b, 0
0485   06AC C6 B2 06      je _if10_else
0486   06AF             _if10_true:
0487   06AF             ;; ; 
0488   06AF 0A D8 06      jmp _if10_exit
0489   06B2             _if10_else:
0490   06B2             ;; if(*format_p == 'x'); 
0491   06B2             _if11_cond:
0492   06B2 FA FD FF      lea d, [bp + -3] ; $format_p
0493   06B5 2A            mov b, [d]
0494   06B6 74            mov d, b
0495   06B7 32            mov bl, [d]
0496   06B8 A7 00         mov bh, 0
0497   06BA             ; START RELATIONAL
0498   06BA D7            push a
0499   06BB 11            mov a, b
0500   06BC 26 78 00      mov b, $78
0501   06BF B0            cmp a, b
0502   06C0 FD 71         seq ; ==
0503   06C2 E4            pop a
0504   06C3             ; END RELATIONAL
0505   06C3 C0 00 00      cmp b, 0
0506   06C6 C6 CC 06      je _if11_else
0507   06C9             _if11_true:
0508   06C9             ;; ; 
0509   06C9 0A D8 06      jmp _if11_exit
0510   06CC             _if11_else:
0511   06CC             ;; err("Unexpected format in printf."); 
0512   06CC 26 BF 14      mov b, __s0 ; "Unexpected format in printf."
0513   06CF FD AB         swp b
0514   06D1 D8            push b
0515   06D2 07 47 0A      call err
0516   06D5 51 02 00      add sp, 2
0517   06D8             _if11_exit:
0518   06D8             _if10_exit:
0519   06D8             _if9_exit:
0520   06D8             ;; p = p + 4; 
0521   06D8 FA FF FF      lea d, [bp + -1] ; $p
0522   06DB DA            push d
0523   06DC FA FF FF      lea d, [bp + -1] ; $p
0524   06DF 2A            mov b, [d]
0525   06E0             ; START TERMS
0526   06E0 D7            push a
0527   06E1 11            mov a, b
0528   06E2 26 04 00      mov b, $4
0529   06E5 56            add b, a
0530   06E6 E4            pop a
0531   06E7             ; END TERMS
0532   06E7 E7            pop d
0533   06E8 FD 43         mov [d], b
0534   06EA             ;; break; 
0535   06EA 0A CF 07      jmp _switch8_exit ; case break
0536   06ED             _switch8_case2:
0537   06ED             _switch8_case3:
0538   06ED             ;; i = scann(); 
0539   06ED FA FA FF      lea d, [bp + -6] ; $i
0540   06F0 DA            push d
0541   06F1 07 12 10      call scann
0542   06F4 E7            pop d
0543   06F5 FD 43         mov [d], b
0544   06F7             ;; **(int **)p = i; 
0545   06F7 FA FF FF      lea d, [bp + -1] ; $p
0546   06FA 2A            mov b, [d]
0547   06FB 74            mov d, b
0548   06FC 2A            mov b, [d]
0549   06FD D8            push b
0550   06FE FA FA FF      lea d, [bp + -6] ; $i
0551   0701 2A            mov b, [d]
0552   0702 E7            pop d
0553   0703 FD 43         mov [d], b
0554   0705             ;; p = p + 2; 
0555   0705 FA FF FF      lea d, [bp + -1] ; $p
0556   0708 DA            push d
0557   0709 FA FF FF      lea d, [bp + -1] ; $p
0558   070C 2A            mov b, [d]
0559   070D             ; START TERMS
0560   070D D7            push a
0561   070E 11            mov a, b
0562   070F 26 02 00      mov b, $2
0563   0712 56            add b, a
0564   0713 E4            pop a
0565   0714             ; END TERMS
0566   0714 E7            pop d
0567   0715 FD 43         mov [d], b
0568   0717             ;; break; 
0569   0717 0A CF 07      jmp _switch8_exit ; case break
0570   071A             _switch8_case4:
0571   071A             ;; i = scann(); 
0572   071A FA FA FF      lea d, [bp + -6] ; $i
0573   071D DA            push d
0574   071E 07 12 10      call scann
0575   0721 E7            pop d
0576   0722 FD 43         mov [d], b
0577   0724             ;; **(int **)p = i; 
0578   0724 FA FF FF      lea d, [bp + -1] ; $p
0579   0727 2A            mov b, [d]
0580   0728 74            mov d, b
0581   0729 2A            mov b, [d]
0582   072A D8            push b
0583   072B FA FA FF      lea d, [bp + -6] ; $i
0584   072E 2A            mov b, [d]
0585   072F E7            pop d
0586   0730 FD 43         mov [d], b
0587   0732             ;; p = p + 2; 
0588   0732 FA FF FF      lea d, [bp + -1] ; $p
0589   0735 DA            push d
0590   0736 FA FF FF      lea d, [bp + -1] ; $p
0591   0739 2A            mov b, [d]
0592   073A             ; START TERMS
0593   073A D7            push a
0594   073B 11            mov a, b
0595   073C 26 02 00      mov b, $2
0596   073F 56            add b, a
0597   0740 E4            pop a
0598   0741             ; END TERMS
0599   0741 E7            pop d
0600   0742 FD 43         mov [d], b
0601   0744             ;; break; 
0602   0744 0A CF 07      jmp _switch8_exit ; case break
0603   0747             _switch8_case5:
0604   0747             ;; p = p + 2; 
0605   0747 FA FF FF      lea d, [bp + -1] ; $p
0606   074A DA            push d
0607   074B FA FF FF      lea d, [bp + -1] ; $p
0608   074E 2A            mov b, [d]
0609   074F             ; START TERMS
0610   074F D7            push a
0611   0750 11            mov a, b
0612   0751 26 02 00      mov b, $2
0613   0754 56            add b, a
0614   0755 E4            pop a
0615   0756             ; END TERMS
0616   0756 E7            pop d
0617   0757 FD 43         mov [d], b
0618   0759             ;; break; 
0619   0759 0A CF 07      jmp _switch8_exit ; case break
0620   075C             _switch8_case6:
0621   075C             ;; c = getchar(); 
0622   075C FA FC FF      lea d, [bp + -4] ; $c
0623   075F DA            push d
0624   0760 07 FC 0F      call getchar
0625   0763 E7            pop d
0626   0764 FD 3E         mov [d], bl
0627   0766             ;; **(char **)p = c; 
0628   0766 FA FF FF      lea d, [bp + -1] ; $p
0629   0769 2A            mov b, [d]
0630   076A 74            mov d, b
0631   076B 2A            mov b, [d]
0632   076C D8            push b
0633   076D FA FC FF      lea d, [bp + -4] ; $c
0634   0770 32            mov bl, [d]
0635   0771 A7 00         mov bh, 0
0636   0773 E7            pop d
0637   0774 FD 43         mov [d], b
0638   0776             ;; p = p + 2; 
0639   0776 FA FF FF      lea d, [bp + -1] ; $p
0640   0779 DA            push d
0641   077A FA FF FF      lea d, [bp + -1] ; $p
0642   077D 2A            mov b, [d]
0643   077E             ; START TERMS
0644   077E D7            push a
0645   077F 11            mov a, b
0646   0780 26 02 00      mov b, $2
0647   0783 56            add b, a
0648   0784 E4            pop a
0649   0785             ; END TERMS
0650   0785 E7            pop d
0651   0786 FD 43         mov [d], b
0652   0788             ;; break; 
0653   0788 0A CF 07      jmp _switch8_exit ; case break
0654   078B             _switch8_case7:
0655   078B             ;; gets(input_string); 
0656   078B FA FA FD      lea d, [bp + -518] ; $input_string
0657   078E 2D            mov b, d
0658   078F FD AB         swp b
0659   0791 D8            push b
0660   0792 07 C6 0B      call gets
0661   0795 51 02 00      add sp, 2
0662   0798             ;; strcpy(*(char **)p, input_string); 
0663   0798 FA FA FD      lea d, [bp + -518] ; $input_string
0664   079B 2D            mov b, d
0665   079C FD AB         swp b
0666   079E D8            push b
0667   079F FA FF FF      lea d, [bp + -1] ; $p
0668   07A2 2A            mov b, [d]
0669   07A3 74            mov d, b
0670   07A4 2A            mov b, [d]
0671   07A5 FD AB         swp b
0672   07A7 D8            push b
0673   07A8 07 0D 04      call strcpy
0674   07AB 51 04 00      add sp, 4
0675   07AE             ;; p = p + 2; 
0676   07AE FA FF FF      lea d, [bp + -1] ; $p
0677   07B1 DA            push d
0678   07B2 FA FF FF      lea d, [bp + -1] ; $p
0679   07B5 2A            mov b, [d]
0680   07B6             ; START TERMS
0681   07B6 D7            push a
0682   07B7 11            mov a, b
0683   07B8 26 02 00      mov b, $2
0684   07BB 56            add b, a
0685   07BC E4            pop a
0686   07BD             ; END TERMS
0687   07BD E7            pop d
0688   07BE FD 43         mov [d], b
0689   07C0             ;; break; 
0690   07C0 0A CF 07      jmp _switch8_exit ; case break
0691   07C3             _switch8_default:
0692   07C3             ;; print("Error: Unknown argument type.\n"); 
0693   07C3 26 DC 14      mov b, __s1 ; "Error: Unknown argument type.\n"
0694   07C6 FD AB         swp b
0695   07C8 D8            push b
0696   07C9 07 37 10      call print
0697   07CC 51 02 00      add sp, 2
0698   07CF             _switch8_exit:
0699   07CF             ;; format_p++; 
0700   07CF FA FD FF      lea d, [bp + -3] ; $format_p
0701   07D2 2A            mov b, [d]
0702   07D3 D8            push b
0703   07D4 FD 77         inc b
0704   07D6 FA FD FF      lea d, [bp + -3] ; $format_p
0705   07D9 FD 43         mov [d], b
0706   07DB E5            pop b
0707   07DC 0A FB 07      jmp _if7_exit
0708   07DF             _if7_else:
0709   07DF             ;; putchar(*format_p); 
0710   07DF FA FD FF      lea d, [bp + -3] ; $format_p
0711   07E2 2A            mov b, [d]
0712   07E3 74            mov d, b
0713   07E4 32            mov bl, [d]
0714   07E5 A7 00         mov bh, 0
0715   07E7 DD            push bl
0716   07E8 07 EF 0F      call putchar
0717   07EB 51 01 00      add sp, 1
0718   07EE             ;; format_p++; 
0719   07EE FA FD FF      lea d, [bp + -3] ; $format_p
0720   07F1 2A            mov b, [d]
0721   07F2 D8            push b
0722   07F3 FD 77         inc b
0723   07F5 FA FD FF      lea d, [bp + -3] ; $format_p
0724   07F8 FD 43         mov [d], b
0725   07FA E5            pop b
0726   07FB             _if7_exit:
0727   07FB             _if6_exit:
0728   07FB             _for5_update:
0729   07FB 0A E8 05      jmp _for5_cond
0730   07FE             _for5_exit:
0731   07FE F9            leave
0732   07FF 09            ret
0733   0800             
0734   0800             printf:
0735   0800 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0736   0803             ; $p 
0737   0803             ; $format_p 
0738   0803 52 04 00      sub sp, 4
0739   0806             ;; format_p = format; 
0740   0806 FA FD FF      lea d, [bp + -3] ; $format_p
0741   0809 DA            push d
0742   080A FA 05 00      lea d, [bp + 5] ; $format
0743   080D 2A            mov b, [d]
0744   080E E7            pop d
0745   080F FD 43         mov [d], b
0746   0811             ;; p = &format + 2; 
0747   0811 FA FF FF      lea d, [bp + -1] ; $p
0748   0814 DA            push d
0749   0815 FA 05 00      lea d, [bp + 5] ; $format
0750   0818 2D            mov b, d
0751   0819             ; START TERMS
0752   0819 D7            push a
0753   081A 11            mov a, b
0754   081B 26 02 00      mov b, $2
0755   081E 56            add b, a
0756   081F E4            pop a
0757   0820             ; END TERMS
0758   0820 E7            pop d
0759   0821 FD 43         mov [d], b
0760   0823             ;; for(;;){ 
0761   0823             _for12_init:
0762   0823             _for12_cond:
0763   0823             _for12_block:
0764   0823             ;; if(!*format_p) break; 
0765   0823             _if13_cond:
0766   0823 FA FD FF      lea d, [bp + -3] ; $format_p
0767   0826 2A            mov b, [d]
0768   0827 74            mov d, b
0769   0828 32            mov bl, [d]
0770   0829 A7 00         mov bh, 0
0771   082B C0 00 00      cmp b, 0
0772   082E FD 71         seq ; !
0773   0830 C0 00 00      cmp b, 0
0774   0833 C6 3C 08      je _if13_else
0775   0836             _if13_true:
0776   0836             ;; break; 
0777   0836 0A 45 0A      jmp _for12_exit ; for break
0778   0839 0A 42 0A      jmp _if13_exit
0779   083C             _if13_else:
0780   083C             ;; if(*format_p == '%'){ 
0781   083C             _if14_cond:
0782   083C FA FD FF      lea d, [bp + -3] ; $format_p
0783   083F 2A            mov b, [d]
0784   0840 74            mov d, b
0785   0841 32            mov bl, [d]
0786   0842 A7 00         mov bh, 0
0787   0844             ; START RELATIONAL
0788   0844 D7            push a
0789   0845 11            mov a, b
0790   0846 26 25 00      mov b, $25
0791   0849 B0            cmp a, b
0792   084A FD 71         seq ; ==
0793   084C E4            pop a
0794   084D             ; END RELATIONAL
0795   084D C0 00 00      cmp b, 0
0796   0850 C6 26 0A      je _if14_else
0797   0853             _if14_true:
0798   0853             ;; format_p++; 
0799   0853 FA FD FF      lea d, [bp + -3] ; $format_p
0800   0856 2A            mov b, [d]
0801   0857 D8            push b
0802   0858 FD 77         inc b
0803   085A FA FD FF      lea d, [bp + -3] ; $format_p
0804   085D FD 43         mov [d], b
0805   085F E5            pop b
0806   0860             ;; switch(*format_p){ 
0807   0860             _switch15_expr:
0808   0860 FA FD FF      lea d, [bp + -3] ; $format_p
0809   0863 2A            mov b, [d]
0810   0864 74            mov d, b
0811   0865 32            mov bl, [d]
0812   0866 A7 00         mov bh, 0
0813   0868             _switch15_comparisons:
0814   0868 C1 6C         cmp bl, $6c
0815   086A C6 96 08      je _switch15_case0
0816   086D C1 4C         cmp bl, $4c
0817   086F C6 96 08      je _switch15_case1
0818   0872 C1 64         cmp bl, $64
0819   0874 C6 66 09      je _switch15_case2
0820   0877 C1 69         cmp bl, $69
0821   0879 C6 66 09      je _switch15_case3
0822   087C C1 75         cmp bl, $75
0823   087E C6 8A 09      je _switch15_case4
0824   0881 C1 78         cmp bl, $78
0825   0883 C6 AE 09      je _switch15_case5
0826   0886 C1 63         cmp bl, $63
0827   0888 C6 CC 09      je _switch15_case6
0828   088B C1 73         cmp bl, $73
0829   088D C6 EB 09      je _switch15_case7
0830   0890 0A 0A 0A      jmp _switch15_default
0831   0893 0A 16 0A      jmp _switch15_exit
0832   0896             _switch15_case0:
0833   0896             _switch15_case1:
0834   0896             ;; format_p++; 
0835   0896 FA FD FF      lea d, [bp + -3] ; $format_p
0836   0899 2A            mov b, [d]
0837   089A D8            push b
0838   089B FD 77         inc b
0839   089D FA FD FF      lea d, [bp + -3] ; $format_p
0840   08A0 FD 43         mov [d], b
0841   08A2 E5            pop b
0842   08A3             ;; if(*format_p == 'd' || *format_p == 'i') 
0843   08A3             _if16_cond:
0844   08A3 FA FD FF      lea d, [bp + -3] ; $format_p
0845   08A6 2A            mov b, [d]
0846   08A7 74            mov d, b
0847   08A8 32            mov bl, [d]
0848   08A9 A7 00         mov bh, 0
0849   08AB             ; START RELATIONAL
0850   08AB D7            push a
0851   08AC 11            mov a, b
0852   08AD 26 64 00      mov b, $64
0853   08B0 B0            cmp a, b
0854   08B1 FD 71         seq ; ==
0855   08B3 E4            pop a
0856   08B4             ; END RELATIONAL
0857   08B4 D7            push a
0858   08B5 11            mov a, b
0859   08B6 FA FD FF      lea d, [bp + -3] ; $format_p
0860   08B9 2A            mov b, [d]
0861   08BA 74            mov d, b
0862   08BB 32            mov bl, [d]
0863   08BC A7 00         mov bh, 0
0864   08BE             ; START RELATIONAL
0865   08BE D7            push a
0866   08BF 11            mov a, b
0867   08C0 26 69 00      mov b, $69
0868   08C3 B0            cmp a, b
0869   08C4 FD 71         seq ; ==
0870   08C6 E4            pop a
0871   08C7             ; END RELATIONAL
0872   08C7 FD A8         sor a, b ; ||
0873   08C9 E4            pop a
0874   08CA C0 00 00      cmp b, 0
0875   08CD C6 E4 08      je _if16_else
0876   08D0             _if16_true:
0877   08D0             ;; print_signed_long(*(long *)p); 
0878   08D0 FD 79         mov g, b
0879   08D2 28            mov b, c
0880   08D3 FD AB         swp b
0881   08D5 D8            push b
0882   08D6 FD 27         mov b, g
0883   08D8 FD AB         swp b
0884   08DA D8            push b
0885   08DB 07 D0 0C      call print_signed_long
0886   08DE 51 04 00      add sp, 4
0887   08E1 0A 51 09      jmp _if16_exit
0888   08E4             _if16_else:
0889   08E4             ;; if(*format_p == 'u') 
0890   08E4             _if17_cond:
0891   08E4 FA FD FF      lea d, [bp + -3] ; $format_p
0892   08E7 2A            mov b, [d]
0893   08E8 74            mov d, b
0894   08E9 32            mov bl, [d]
0895   08EA A7 00         mov bh, 0
0896   08EC             ; START RELATIONAL
0897   08EC D7            push a
0898   08ED 11            mov a, b
0899   08EE 26 75 00      mov b, $75
0900   08F1 B0            cmp a, b
0901   08F2 FD 71         seq ; ==
0902   08F4 E4            pop a
0903   08F5             ; END RELATIONAL
0904   08F5 C0 00 00      cmp b, 0
0905   08F8 C6 0F 09      je _if17_else
0906   08FB             _if17_true:
0907   08FB             ;; print_unsigned_long(*(unsigned long *)p); 
0908   08FB FD 79         mov g, b
0909   08FD 28            mov b, c
0910   08FE FD AB         swp b
0911   0900 D8            push b
0912   0901 FD 27         mov b, g
0913   0903 FD AB         swp b
0914   0905 D8            push b
0915   0906 07 22 0E      call print_unsigned_long
0916   0909 51 04 00      add sp, 4
0917   090C 0A 51 09      jmp _if17_exit
0918   090F             _if17_else:
0919   090F             ;; if(*format_p == 'x') 
0920   090F             _if18_cond:
0921   090F FA FD FF      lea d, [bp + -3] ; $format_p
0922   0912 2A            mov b, [d]
0923   0913 74            mov d, b
0924   0914 32            mov bl, [d]
0925   0915 A7 00         mov bh, 0
0926   0917             ; START RELATIONAL
0927   0917 D7            push a
0928   0918 11            mov a, b
0929   0919 26 78 00      mov b, $78
0930   091C B0            cmp a, b
0931   091D FD 71         seq ; ==
0932   091F E4            pop a
0933   0920             ; END RELATIONAL
0934   0920 C0 00 00      cmp b, 0
0935   0923 C6 45 09      je _if18_else
0936   0926             _if18_true:
0937   0926             ;; printx32(*(long int *)p); 
0938   0926 FA FF FF      lea d, [bp + -1] ; $p
0939   0929 2A            mov b, [d]
0940   092A 74            mov d, b
0941   092B 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0942   092E FD 39         mov c, b ; And place it into C
0943   0930 2A            mov b, [d] ; Lower Word in B
0944   0931 FD 79         mov g, b
0945   0933 28            mov b, c
0946   0934 FD AB         swp b
0947   0936 D8            push b
0948   0937 FD 27         mov b, g
0949   0939 FD AB         swp b
0950   093B D8            push b
0951   093C 07 59 0A      call printx32
0952   093F 51 04 00      add sp, 4
0953   0942 0A 51 09      jmp _if18_exit
0954   0945             _if18_else:
0955   0945             ;; err("Unexpected format in printf."); 
0956   0945 26 BF 14      mov b, __s0 ; "Unexpected format in printf."
0957   0948 FD AB         swp b
0958   094A D8            push b
0959   094B 07 47 0A      call err
0960   094E 51 02 00      add sp, 2
0961   0951             _if18_exit:
0962   0951             _if17_exit:
0963   0951             _if16_exit:
0964   0951             ;; p = p + 4; 
0965   0951 FA FF FF      lea d, [bp + -1] ; $p
0966   0954 DA            push d
0967   0955 FA FF FF      lea d, [bp + -1] ; $p
0968   0958 2A            mov b, [d]
0969   0959             ; START TERMS
0970   0959 D7            push a
0971   095A 11            mov a, b
0972   095B 26 04 00      mov b, $4
0973   095E 56            add b, a
0974   095F E4            pop a
0975   0960             ; END TERMS
0976   0960 E7            pop d
0977   0961 FD 43         mov [d], b
0978   0963             ;; break; 
0979   0963 0A 16 0A      jmp _switch15_exit ; case break
0980   0966             _switch15_case2:
0981   0966             _switch15_case3:
0982   0966             ;; print_signed(*(int*)p); 
0983   0966 FA FF FF      lea d, [bp + -1] ; $p
0984   0969 2A            mov b, [d]
0985   096A 74            mov d, b
0986   096B 2A            mov b, [d]
0987   096C FD AB         swp b
0988   096E D8            push b
0989   096F 07 E0 0B      call print_signed
0990   0972 51 02 00      add sp, 2
0991   0975             ;; p = p + 2; 
0992   0975 FA FF FF      lea d, [bp + -1] ; $p
0993   0978 DA            push d
0994   0979 FA FF FF      lea d, [bp + -1] ; $p
0995   097C 2A            mov b, [d]
0996   097D             ; START TERMS
0997   097D D7            push a
0998   097E 11            mov a, b
0999   097F 26 02 00      mov b, $2
1000   0982 56            add b, a
1001   0983 E4            pop a
1002   0984             ; END TERMS
1003   0984 E7            pop d
1004   0985 FD 43         mov [d], b
1005   0987             ;; break; 
1006   0987 0A 16 0A      jmp _switch15_exit ; case break
1007   098A             _switch15_case4:
1008   098A             ;; print_unsigned(*(unsigned int*)p); 
1009   098A FA FF FF      lea d, [bp + -1] ; $p
1010   098D 2A            mov b, [d]
1011   098E 74            mov d, b
1012   098F 2A            mov b, [d]
1013   0990 FD AB         swp b
1014   0992 D8            push b
1015   0993 07 1F 0F      call print_unsigned
1016   0996 51 02 00      add sp, 2
1017   0999             ;; p = p + 2; 
1018   0999 FA FF FF      lea d, [bp + -1] ; $p
1019   099C DA            push d
1020   099D FA FF FF      lea d, [bp + -1] ; $p
1021   09A0 2A            mov b, [d]
1022   09A1             ; START TERMS
1023   09A1 D7            push a
1024   09A2 11            mov a, b
1025   09A3 26 02 00      mov b, $2
1026   09A6 56            add b, a
1027   09A7 E4            pop a
1028   09A8             ; END TERMS
1029   09A8 E7            pop d
1030   09A9 FD 43         mov [d], b
1031   09AB             ;; break; 
1032   09AB 0A 16 0A      jmp _switch15_exit ; case break
1033   09AE             _switch15_case5:
1034   09AE             
1035   09AE             ; --- BEGIN INLINE ASM BLOCK
1036   09AE FA FF FF      lea d, [bp + -1] ; $p
1037   09B1 FD 2A         mov d, [d]
1038   09B3 2A            mov b, [d]
1039   09B4 07 FD 12      call print_u16x
1040   09B7             ; --- END INLINE ASM BLOCK
1041   09B7             
1042   09B7             ;; p = p + 2; 
1043   09B7 FA FF FF      lea d, [bp + -1] ; $p
1044   09BA DA            push d
1045   09BB FA FF FF      lea d, [bp + -1] ; $p
1046   09BE 2A            mov b, [d]
1047   09BF             ; START TERMS
1048   09BF D7            push a
1049   09C0 11            mov a, b
1050   09C1 26 02 00      mov b, $2
1051   09C4 56            add b, a
1052   09C5 E4            pop a
1053   09C6             ; END TERMS
1054   09C6 E7            pop d
1055   09C7 FD 43         mov [d], b
1056   09C9             ;; break; 
1057   09C9 0A 16 0A      jmp _switch15_exit ; case break
1058   09CC             _switch15_case6:
1059   09CC             
1060   09CC             ; --- BEGIN INLINE ASM BLOCK
1061   09CC FA FF FF      lea d, [bp + -1] ; $p
1062   09CF FD 2A         mov d, [d]
1063   09D1 1E            mov al, [d]
1064   09D2 23            mov ah, al
1065   09D3 07 5B 11      call _putchar
1066   09D6             ; --- END INLINE ASM BLOCK
1067   09D6             
1068   09D6             ;; p = p + 2; 
1069   09D6 FA FF FF      lea d, [bp + -1] ; $p
1070   09D9 DA            push d
1071   09DA FA FF FF      lea d, [bp + -1] ; $p
1072   09DD 2A            mov b, [d]
1073   09DE             ; START TERMS
1074   09DE D7            push a
1075   09DF 11            mov a, b
1076   09E0 26 02 00      mov b, $2
1077   09E3 56            add b, a
1078   09E4 E4            pop a
1079   09E5             ; END TERMS
1080   09E5 E7            pop d
1081   09E6 FD 43         mov [d], b
1082   09E8             ;; break; 
1083   09E8 0A 16 0A      jmp _switch15_exit ; case break
1084   09EB             _switch15_case7:
1085   09EB             
1086   09EB             ; --- BEGIN INLINE ASM BLOCK
1087   09EB FA FF FF      lea d, [bp + -1] ; $p
1088   09EE FD 2A         mov d, [d]
1089   09F0 FD 2A         mov d, [d]
1090   09F2 07 A5 12      call _puts
1091   09F5             ; --- END INLINE ASM BLOCK
1092   09F5             
1093   09F5             ;; p = p + 2; 
1094   09F5 FA FF FF      lea d, [bp + -1] ; $p
1095   09F8 DA            push d
1096   09F9 FA FF FF      lea d, [bp + -1] ; $p
1097   09FC 2A            mov b, [d]
1098   09FD             ; START TERMS
1099   09FD D7            push a
1100   09FE 11            mov a, b
1101   09FF 26 02 00      mov b, $2
1102   0A02 56            add b, a
1103   0A03 E4            pop a
1104   0A04             ; END TERMS
1105   0A04 E7            pop d
1106   0A05 FD 43         mov [d], b
1107   0A07             ;; break; 
1108   0A07 0A 16 0A      jmp _switch15_exit ; case break
1109   0A0A             _switch15_default:
1110   0A0A             ;; print("Error: Unknown argument type.\n"); 
1111   0A0A 26 DC 14      mov b, __s1 ; "Error: Unknown argument type.\n"
1112   0A0D FD AB         swp b
1113   0A0F D8            push b
1114   0A10 07 37 10      call print
1115   0A13 51 02 00      add sp, 2
1116   0A16             _switch15_exit:
1117   0A16             ;; format_p++; 
1118   0A16 FA FD FF      lea d, [bp + -3] ; $format_p
1119   0A19 2A            mov b, [d]
1120   0A1A D8            push b
1121   0A1B FD 77         inc b
1122   0A1D FA FD FF      lea d, [bp + -3] ; $format_p
1123   0A20 FD 43         mov [d], b
1124   0A22 E5            pop b
1125   0A23 0A 42 0A      jmp _if14_exit
1126   0A26             _if14_else:
1127   0A26             ;; putchar(*format_p); 
1128   0A26 FA FD FF      lea d, [bp + -3] ; $format_p
1129   0A29 2A            mov b, [d]
1130   0A2A 74            mov d, b
1131   0A2B 32            mov bl, [d]
1132   0A2C A7 00         mov bh, 0
1133   0A2E DD            push bl
1134   0A2F 07 EF 0F      call putchar
1135   0A32 51 01 00      add sp, 1
1136   0A35             ;; format_p++; 
1137   0A35 FA FD FF      lea d, [bp + -3] ; $format_p
1138   0A38 2A            mov b, [d]
1139   0A39 D8            push b
1140   0A3A FD 77         inc b
1141   0A3C FA FD FF      lea d, [bp + -3] ; $format_p
1142   0A3F FD 43         mov [d], b
1143   0A41 E5            pop b
1144   0A42             _if14_exit:
1145   0A42             _if13_exit:
1146   0A42             _for12_update:
1147   0A42 0A 23 08      jmp _for12_cond
1148   0A45             _for12_exit:
1149   0A45 F9            leave
1150   0A46 09            ret
1151   0A47             
1152   0A47             err:
1153   0A47 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1154   0A4A             ;; print(e); 
1155   0A4A FA 05 00      lea d, [bp + 5] ; $e
1156   0A4D 2A            mov b, [d]
1157   0A4E FD AB         swp b
1158   0A50 D8            push b
1159   0A51 07 37 10      call print
1160   0A54 51 02 00      add sp, 2
1161   0A57 F9            leave
1162   0A58 09            ret
1163   0A59             
1164   0A59             printx32:
1165   0A59 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1166   0A5C             
1167   0A5C             ; --- BEGIN INLINE ASM BLOCK
1168   0A5C FA 05 00      lea d, [bp + 5] ; $hex
1169   0A5F 2B 02 00      mov b, [d+2]
1170   0A62 07 FD 12      call print_u16x
1171   0A65 2A            mov b, [d]
1172   0A66 07 FD 12      call print_u16x
1173   0A69             ; --- END INLINE ASM BLOCK
1174   0A69             
1175   0A69 F9            leave
1176   0A6A 09            ret
1177   0A6B             
1178   0A6B             printx16:
1179   0A6B F8 00 00      enter 0 ; (push bp; mov bp, sp)
1180   0A6E             
1181   0A6E             ; --- BEGIN INLINE ASM BLOCK
1182   0A6E FA 05 00      lea d, [bp + 5] ; $hex
1183   0A71 2A            mov b, [d]
1184   0A72 07 FD 12      call print_u16x
1185   0A75             ; --- END INLINE ASM BLOCK
1186   0A75             
1187   0A75 F9            leave
1188   0A76 09            ret
1189   0A77             
1190   0A77             printx8:
1191   0A77 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1192   0A7A             
1193   0A7A             ; --- BEGIN INLINE ASM BLOCK
1194   0A7A FA 05 00      lea d, [bp + 5] ; $hex
1195   0A7D 32            mov bl, [d]
1196   0A7E 07 41 13      call print_u8x
1197   0A81             ; --- END INLINE ASM BLOCK
1198   0A81             
1199   0A81 F9            leave
1200   0A82 09            ret
1201   0A83             
1202   0A83             hex_str_to_int:
1203   0A83 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1204   0A86             ; $value 
1205   0A86 10 00 00      mov a, $0
1206   0A89 45 FF FF      mov [bp + -1], a
1207   0A8C             ; $i 
1208   0A8C             ; $hex_char 
1209   0A8C             ; $len 
1210   0A8C 52 07 00      sub sp, 7
1211   0A8F             ;; len = strlen(hex_string); 
1212   0A8F FA FA FF      lea d, [bp + -6] ; $len
1213   0A92 DA            push d
1214   0A93 FA 05 00      lea d, [bp + 5] ; $hex_string
1215   0A96 2A            mov b, [d]
1216   0A97 FD AB         swp b
1217   0A99 D8            push b
1218   0A9A 07 7C 05      call strlen
1219   0A9D 51 02 00      add sp, 2
1220   0AA0 E7            pop d
1221   0AA1 FD 43         mov [d], b
1222   0AA3             ;; for (i = 0; i < len; i++) { 
1223   0AA3             _for19_init:
1224   0AA3 FA FD FF      lea d, [bp + -3] ; $i
1225   0AA6 DA            push d
1226   0AA7 26 00 00      mov b, $0
1227   0AAA E7            pop d
1228   0AAB FD 43         mov [d], b
1229   0AAD             _for19_cond:
1230   0AAD FA FD FF      lea d, [bp + -3] ; $i
1231   0AB0 2A            mov b, [d]
1232   0AB1             ; START RELATIONAL
1233   0AB1 D7            push a
1234   0AB2 11            mov a, b
1235   0AB3 FA FA FF      lea d, [bp + -6] ; $len
1236   0AB6 2A            mov b, [d]
1237   0AB7 B0            cmp a, b
1238   0AB8 FD 73         slt ; <= (signed)
1239   0ABA E4            pop a
1240   0ABB             ; END RELATIONAL
1241   0ABB C0 00 00      cmp b, 0
1242   0ABE C6 C0 0B      je _for19_exit
1243   0AC1             _for19_block:
1244   0AC1             ;; hex_char = hex_string[i]; 
1245   0AC1 FA FC FF      lea d, [bp + -4] ; $hex_char
1246   0AC4 DA            push d
1247   0AC5 FA 05 00      lea d, [bp + 5] ; $hex_string
1248   0AC8 FD 2A         mov d, [d]
1249   0ACA D7            push a
1250   0ACB DA            push d
1251   0ACC FA FD FF      lea d, [bp + -3] ; $i
1252   0ACF 2A            mov b, [d]
1253   0AD0 E7            pop d
1254   0AD1 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
1255   0AD5 E4            pop a
1256   0AD6 32            mov bl, [d]
1257   0AD7 A7 00         mov bh, 0
1258   0AD9 E7            pop d
1259   0ADA FD 3E         mov [d], bl
1260   0ADC             ;; if (hex_char >= 'a' && hex_char <= 'f')  
1261   0ADC             _if20_cond:
1262   0ADC FA FC FF      lea d, [bp + -4] ; $hex_char
1263   0ADF 32            mov bl, [d]
1264   0AE0 A7 00         mov bh, 0
1265   0AE2             ; START RELATIONAL
1266   0AE2 D7            push a
1267   0AE3 11            mov a, b
1268   0AE4 26 61 00      mov b, $61
1269   0AE7 B0            cmp a, b
1270   0AE8 FD 80         sge ; >=
1271   0AEA E4            pop a
1272   0AEB             ; END RELATIONAL
1273   0AEB D7            push a
1274   0AEC 11            mov a, b
1275   0AED FA FC FF      lea d, [bp + -4] ; $hex_char
1276   0AF0 32            mov bl, [d]
1277   0AF1 A7 00         mov bh, 0
1278   0AF3             ; START RELATIONAL
1279   0AF3 D7            push a
1280   0AF4 11            mov a, b
1281   0AF5 26 66 00      mov b, $66
1282   0AF8 B0            cmp a, b
1283   0AF9 FD 74         sle ; <=
1284   0AFB E4            pop a
1285   0AFC             ; END RELATIONAL
1286   0AFC FD A7         sand a, b ; &&
1287   0AFE E4            pop a
1288   0AFF C0 00 00      cmp b, 0
1289   0B02 C6 33 0B      je _if20_else
1290   0B05             _if20_true:
1291   0B05             ;; value = (value * 16) + (hex_char - 'a' + 10); 
1292   0B05 FA FF FF      lea d, [bp + -1] ; $value
1293   0B08 DA            push d
1294   0B09 FA FF FF      lea d, [bp + -1] ; $value
1295   0B0C 2A            mov b, [d]
1296   0B0D             ; START FACTORS
1297   0B0D D7            push a
1298   0B0E 11            mov a, b
1299   0B0F 26 10 00      mov b, $10
1300   0B12 AC            mul a, b ; *
1301   0B13 11            mov a, b
1302   0B14 27            mov b, a
1303   0B15 E4            pop a
1304   0B16             ; END FACTORS
1305   0B16             ; START TERMS
1306   0B16 D7            push a
1307   0B17 11            mov a, b
1308   0B18 FA FC FF      lea d, [bp + -4] ; $hex_char
1309   0B1B 32            mov bl, [d]
1310   0B1C A7 00         mov bh, 0
1311   0B1E             ; START TERMS
1312   0B1E D7            push a
1313   0B1F 11            mov a, b
1314   0B20 26 61 00      mov b, $61
1315   0B23 60            sub a, b
1316   0B24 27            mov b, a
1317   0B25 11            mov a, b
1318   0B26 26 0A 00      mov b, $a
1319   0B29 56            add b, a
1320   0B2A E4            pop a
1321   0B2B             ; END TERMS
1322   0B2B 56            add b, a
1323   0B2C E4            pop a
1324   0B2D             ; END TERMS
1325   0B2D E7            pop d
1326   0B2E FD 43         mov [d], b
1327   0B30 0A B0 0B      jmp _if20_exit
1328   0B33             _if20_else:
1329   0B33             ;; if (hex_char >= 'A' && hex_char <= 'F')  
1330   0B33             _if21_cond:
1331   0B33 FA FC FF      lea d, [bp + -4] ; $hex_char
1332   0B36 32            mov bl, [d]
1333   0B37 A7 00         mov bh, 0
1334   0B39             ; START RELATIONAL
1335   0B39 D7            push a
1336   0B3A 11            mov a, b
1337   0B3B 26 41 00      mov b, $41
1338   0B3E B0            cmp a, b
1339   0B3F FD 80         sge ; >=
1340   0B41 E4            pop a
1341   0B42             ; END RELATIONAL
1342   0B42 D7            push a
1343   0B43 11            mov a, b
1344   0B44 FA FC FF      lea d, [bp + -4] ; $hex_char
1345   0B47 32            mov bl, [d]
1346   0B48 A7 00         mov bh, 0
1347   0B4A             ; START RELATIONAL
1348   0B4A D7            push a
1349   0B4B 11            mov a, b
1350   0B4C 26 46 00      mov b, $46
1351   0B4F B0            cmp a, b
1352   0B50 FD 74         sle ; <=
1353   0B52 E4            pop a
1354   0B53             ; END RELATIONAL
1355   0B53 FD A7         sand a, b ; &&
1356   0B55 E4            pop a
1357   0B56 C0 00 00      cmp b, 0
1358   0B59 C6 8A 0B      je _if21_else
1359   0B5C             _if21_true:
1360   0B5C             ;; value = (value * 16) + (hex_char - 'A' + 10); 
1361   0B5C FA FF FF      lea d, [bp + -1] ; $value
1362   0B5F DA            push d
1363   0B60 FA FF FF      lea d, [bp + -1] ; $value
1364   0B63 2A            mov b, [d]
1365   0B64             ; START FACTORS
1366   0B64 D7            push a
1367   0B65 11            mov a, b
1368   0B66 26 10 00      mov b, $10
1369   0B69 AC            mul a, b ; *
1370   0B6A 11            mov a, b
1371   0B6B 27            mov b, a
1372   0B6C E4            pop a
1373   0B6D             ; END FACTORS
1374   0B6D             ; START TERMS
1375   0B6D D7            push a
1376   0B6E 11            mov a, b
1377   0B6F FA FC FF      lea d, [bp + -4] ; $hex_char
1378   0B72 32            mov bl, [d]
1379   0B73 A7 00         mov bh, 0
1380   0B75             ; START TERMS
1381   0B75 D7            push a
1382   0B76 11            mov a, b
1383   0B77 26 41 00      mov b, $41
1384   0B7A 60            sub a, b
1385   0B7B 27            mov b, a
1386   0B7C 11            mov a, b
1387   0B7D 26 0A 00      mov b, $a
1388   0B80 56            add b, a
1389   0B81 E4            pop a
1390   0B82             ; END TERMS
1391   0B82 56            add b, a
1392   0B83 E4            pop a
1393   0B84             ; END TERMS
1394   0B84 E7            pop d
1395   0B85 FD 43         mov [d], b
1396   0B87 0A B0 0B      jmp _if21_exit
1397   0B8A             _if21_else:
1398   0B8A             ;; value = (value * 16) + (hex_char - '0'); 
1399   0B8A FA FF FF      lea d, [bp + -1] ; $value
1400   0B8D DA            push d
1401   0B8E FA FF FF      lea d, [bp + -1] ; $value
1402   0B91 2A            mov b, [d]
1403   0B92             ; START FACTORS
1404   0B92 D7            push a
1405   0B93 11            mov a, b
1406   0B94 26 10 00      mov b, $10
1407   0B97 AC            mul a, b ; *
1408   0B98 11            mov a, b
1409   0B99 27            mov b, a
1410   0B9A E4            pop a
1411   0B9B             ; END FACTORS
1412   0B9B             ; START TERMS
1413   0B9B D7            push a
1414   0B9C 11            mov a, b
1415   0B9D FA FC FF      lea d, [bp + -4] ; $hex_char
1416   0BA0 32            mov bl, [d]
1417   0BA1 A7 00         mov bh, 0
1418   0BA3             ; START TERMS
1419   0BA3 D7            push a
1420   0BA4 11            mov a, b
1421   0BA5 26 30 00      mov b, $30
1422   0BA8 60            sub a, b
1423   0BA9 27            mov b, a
1424   0BAA E4            pop a
1425   0BAB             ; END TERMS
1426   0BAB 56            add b, a
1427   0BAC E4            pop a
1428   0BAD             ; END TERMS
1429   0BAD E7            pop d
1430   0BAE FD 43         mov [d], b
1431   0BB0             _if21_exit:
1432   0BB0             _if20_exit:
1433   0BB0             _for19_update:
1434   0BB0 FA FD FF      lea d, [bp + -3] ; $i
1435   0BB3 2A            mov b, [d]
1436   0BB4 D8            push b
1437   0BB5 FD 77         inc b
1438   0BB7 FA FD FF      lea d, [bp + -3] ; $i
1439   0BBA FD 43         mov [d], b
1440   0BBC E5            pop b
1441   0BBD 0A AD 0A      jmp _for19_cond
1442   0BC0             _for19_exit:
1443   0BC0             ;; return value; 
1444   0BC0 FA FF FF      lea d, [bp + -1] ; $value
1445   0BC3 2A            mov b, [d]
1446   0BC4 F9            leave
1447   0BC5 09            ret
1448   0BC6             
1449   0BC6             gets:
1450   0BC6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1451   0BC9             
1452   0BC9             ; --- BEGIN INLINE ASM BLOCK
1453   0BC9 FA 05 00      lea d, [bp + 5] ; $s
1454   0BCC 15            mov a, [d]
1455   0BCD 3C            mov d, a
1456   0BCE 07 62 11      call _gets
1457   0BD1             ; --- END INLINE ASM BLOCK
1458   0BD1             
1459   0BD1             ;; return strlen(s); 
1460   0BD1 FA 05 00      lea d, [bp + 5] ; $s
1461   0BD4 2A            mov b, [d]
1462   0BD5 FD AB         swp b
1463   0BD7 D8            push b
1464   0BD8 07 7C 05      call strlen
1465   0BDB 51 02 00      add sp, 2
1466   0BDE F9            leave
1467   0BDF 09            ret
1468   0BE0             
1469   0BE0             print_signed:
1470   0BE0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1471   0BE3             ; $digits 
1472   0BE3             ; $i 
1473   0BE3 10 00 00      mov a, $0
1474   0BE6 45 FA FF      mov [bp + -6], a
1475   0BE9 52 07 00      sub sp, 7
1476   0BEC             ;; if (num < 0) { 
1477   0BEC             _if22_cond:
1478   0BEC FA 05 00      lea d, [bp + 5] ; $num
1479   0BEF 2A            mov b, [d]
1480   0BF0             ; START RELATIONAL
1481   0BF0 D7            push a
1482   0BF1 11            mov a, b
1483   0BF2 26 00 00      mov b, $0
1484   0BF5 B0            cmp a, b
1485   0BF6 FD 73         slt ; <= (signed)
1486   0BF8 E4            pop a
1487   0BF9             ; END RELATIONAL
1488   0BF9 C0 00 00      cmp b, 0
1489   0BFC C6 19 0C      je _if22_else
1490   0BFF             _if22_true:
1491   0BFF             ;; putchar('-'); 
1492   0BFF 26 2D 00      mov b, $2d
1493   0C02 DD            push bl
1494   0C03 07 EF 0F      call putchar
1495   0C06 51 01 00      add sp, 1
1496   0C09             ;; num = -num; 
1497   0C09 FA 05 00      lea d, [bp + 5] ; $num
1498   0C0C DA            push d
1499   0C0D FA 05 00      lea d, [bp + 5] ; $num
1500   0C10 2A            mov b, [d]
1501   0C11 FD 97         neg b
1502   0C13 E7            pop d
1503   0C14 FD 43         mov [d], b
1504   0C16 0A 3B 0C      jmp _if22_exit
1505   0C19             _if22_else:
1506   0C19             ;; if (num == 0) { 
1507   0C19             _if23_cond:
1508   0C19 FA 05 00      lea d, [bp + 5] ; $num
1509   0C1C 2A            mov b, [d]
1510   0C1D             ; START RELATIONAL
1511   0C1D D7            push a
1512   0C1E 11            mov a, b
1513   0C1F 26 00 00      mov b, $0
1514   0C22 B0            cmp a, b
1515   0C23 FD 71         seq ; ==
1516   0C25 E4            pop a
1517   0C26             ; END RELATIONAL
1518   0C26 C0 00 00      cmp b, 0
1519   0C29 C6 3B 0C      je _if23_exit
1520   0C2C             _if23_true:
1521   0C2C             ;; putchar('0'); 
1522   0C2C 26 30 00      mov b, $30
1523   0C2F DD            push bl
1524   0C30 07 EF 0F      call putchar
1525   0C33 51 01 00      add sp, 1
1526   0C36             ;; return; 
1527   0C36 F9            leave
1528   0C37 09            ret
1529   0C38 0A 3B 0C      jmp _if23_exit
1530   0C3B             _if23_exit:
1531   0C3B             _if22_exit:
1532   0C3B             ;; while (num > 0) { 
1533   0C3B             _while24_cond:
1534   0C3B FA 05 00      lea d, [bp + 5] ; $num
1535   0C3E 2A            mov b, [d]
1536   0C3F             ; START RELATIONAL
1537   0C3F D7            push a
1538   0C40 11            mov a, b
1539   0C41 26 00 00      mov b, $0
1540   0C44 B0            cmp a, b
1541   0C45 FD 7F         sgt ; >
1542   0C47 E4            pop a
1543   0C48             ; END RELATIONAL
1544   0C48 C0 00 00      cmp b, 0
1545   0C4B C6 95 0C      je _while24_exit
1546   0C4E             _while24_block:
1547   0C4E             ;; digits[i] = '0' + (num % 10); 
1548   0C4E FA FC FF      lea d, [bp + -4] ; $digits
1549   0C51 D7            push a
1550   0C52 DA            push d
1551   0C53 FA FA FF      lea d, [bp + -6] ; $i
1552   0C56 2A            mov b, [d]
1553   0C57 E7            pop d
1554   0C58 5A            add d, b
1555   0C59 E4            pop a
1556   0C5A DA            push d
1557   0C5B 26 30 00      mov b, $30
1558   0C5E             ; START TERMS
1559   0C5E D7            push a
1560   0C5F 11            mov a, b
1561   0C60 FA 05 00      lea d, [bp + 5] ; $num
1562   0C63 2A            mov b, [d]
1563   0C64             ; START FACTORS
1564   0C64 D7            push a
1565   0C65 11            mov a, b
1566   0C66 26 0A 00      mov b, $a
1567   0C69 AE            div a, b ; 
1568   0C6A 11            mov a, b
1569   0C6B 27            mov b, a
1570   0C6C E4            pop a
1571   0C6D             ; END FACTORS
1572   0C6D 56            add b, a
1573   0C6E E4            pop a
1574   0C6F             ; END TERMS
1575   0C6F E7            pop d
1576   0C70 FD 3E         mov [d], bl
1577   0C72             ;; num = num / 10; 
1578   0C72 FA 05 00      lea d, [bp + 5] ; $num
1579   0C75 DA            push d
1580   0C76 FA 05 00      lea d, [bp + 5] ; $num
1581   0C79 2A            mov b, [d]
1582   0C7A             ; START FACTORS
1583   0C7A D7            push a
1584   0C7B 11            mov a, b
1585   0C7C 26 0A 00      mov b, $a
1586   0C7F AE            div a, b
1587   0C80 27            mov b, a
1588   0C81 E4            pop a
1589   0C82             ; END FACTORS
1590   0C82 E7            pop d
1591   0C83 FD 43         mov [d], b
1592   0C85             ;; i++; 
1593   0C85 FA FA FF      lea d, [bp + -6] ; $i
1594   0C88 2A            mov b, [d]
1595   0C89 D8            push b
1596   0C8A FD 77         inc b
1597   0C8C FA FA FF      lea d, [bp + -6] ; $i
1598   0C8F FD 43         mov [d], b
1599   0C91 E5            pop b
1600   0C92 0A 3B 0C      jmp _while24_cond
1601   0C95             _while24_exit:
1602   0C95             ;; while (i > 0) { 
1603   0C95             _while25_cond:
1604   0C95 FA FA FF      lea d, [bp + -6] ; $i
1605   0C98 2A            mov b, [d]
1606   0C99             ; START RELATIONAL
1607   0C99 D7            push a
1608   0C9A 11            mov a, b
1609   0C9B 26 00 00      mov b, $0
1610   0C9E B0            cmp a, b
1611   0C9F FD 7F         sgt ; >
1612   0CA1 E4            pop a
1613   0CA2             ; END RELATIONAL
1614   0CA2 C0 00 00      cmp b, 0
1615   0CA5 C6 CE 0C      je _while25_exit
1616   0CA8             _while25_block:
1617   0CA8             ;; i--; 
1618   0CA8 FA FA FF      lea d, [bp + -6] ; $i
1619   0CAB 2A            mov b, [d]
1620   0CAC D8            push b
1621   0CAD FD 7D         dec b
1622   0CAF FA FA FF      lea d, [bp + -6] ; $i
1623   0CB2 FD 43         mov [d], b
1624   0CB4 E5            pop b
1625   0CB5             ;; putchar(digits[i]); 
1626   0CB5 FA FC FF      lea d, [bp + -4] ; $digits
1627   0CB8 D7            push a
1628   0CB9 DA            push d
1629   0CBA FA FA FF      lea d, [bp + -6] ; $i
1630   0CBD 2A            mov b, [d]
1631   0CBE E7            pop d
1632   0CBF 5A            add d, b
1633   0CC0 E4            pop a
1634   0CC1 32            mov bl, [d]
1635   0CC2 A7 00         mov bh, 0
1636   0CC4 DD            push bl
1637   0CC5 07 EF 0F      call putchar
1638   0CC8 51 01 00      add sp, 1
1639   0CCB 0A 95 0C      jmp _while25_cond
1640   0CCE             _while25_exit:
1641   0CCE F9            leave
1642   0CCF 09            ret
1643   0CD0             
1644   0CD0             print_signed_long:
1645   0CD0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1646   0CD3             ; $digits 
1647   0CD3             ; $i 
1648   0CD3 10 00 00      mov a, $0
1649   0CD6 45 F5 FF      mov [bp + -11], a
1650   0CD9 52 0C 00      sub sp, 12
1651   0CDC             ;; if (num < 0) { 
1652   0CDC             _if26_cond:
1653   0CDC FA 05 00      lea d, [bp + 5] ; $num
1654   0CDF 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1655   0CE2 FD 39         mov c, b ; And place it into C
1656   0CE4 2A            mov b, [d] ; Lower Word in B
1657   0CE5             ; START RELATIONAL
1658   0CE5 D7            push a
1659   0CE6 FD D8         push g
1660   0CE8 11            mov a, b
1661   0CE9 FD 7A         mov g, c
1662   0CEB 26 00 00      mov b, $0
1663   0CEE 4D            mov si, a
1664   0CEF 11            mov a, b
1665   0CF0 4F            mov di, a
1666   0CF1 FD 12         mov a, g
1667   0CF3 28            mov b, c
1668   0CF4 B0            cmp a, b
1669   0CF5 FD 75         slu ; <
1670   0CF7 D8            push b
1671   0CF8 28            mov b, c
1672   0CF9 FD 71         seq ; ==
1673   0CFB D8            push b
1674   0CFC 50            mov a, di
1675   0CFD 27            mov b, a
1676   0CFE 4E            mov a, si
1677   0CFF B0            cmp a, b
1678   0D00 FD 75         slu ; <
1679   0D02 E4            pop a
1680   0D03 FD 92         and b, a
1681   0D05 E4            pop a
1682   0D06 FD 70         or b, a
1683   0D08               
1684   0D08 FD F1         pop g
1685   0D0A E4            pop a
1686   0D0B             ; END RELATIONAL
1687   0D0B C0 00 00      cmp b, 0
1688   0D0E C6 35 0D      je _if26_else
1689   0D11             _if26_true:
1690   0D11             ;; putchar('-'); 
1691   0D11 26 2D 00      mov b, $2d
1692   0D14 DD            push bl
1693   0D15 07 EF 0F      call putchar
1694   0D18 51 01 00      add sp, 1
1695   0D1B             ;; num = -num; 
1696   0D1B FA 05 00      lea d, [bp + 5] ; $num
1697   0D1E DA            push d
1698   0D1F FA 05 00      lea d, [bp + 5] ; $num
1699   0D22 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1700   0D25 FD 39         mov c, b ; And place it into C
1701   0D27 2A            mov b, [d] ; Lower Word in B
1702   0D28 FD 97         neg b
1703   0D2A E7            pop d
1704   0D2B FD 43         mov [d], b
1705   0D2D 28            mov b, c
1706   0D2E FD 44 02 00   mov [d + 2], b
1707   0D32 0A 6C 0D      jmp _if26_exit
1708   0D35             _if26_else:
1709   0D35             ;; if (num == 0) { 
1710   0D35             _if27_cond:
1711   0D35 FA 05 00      lea d, [bp + 5] ; $num
1712   0D38 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1713   0D3B FD 39         mov c, b ; And place it into C
1714   0D3D 2A            mov b, [d] ; Lower Word in B
1715   0D3E             ; START RELATIONAL
1716   0D3E D7            push a
1717   0D3F FD D8         push g
1718   0D41 11            mov a, b
1719   0D42 FD 7A         mov g, c
1720   0D44 26 00 00      mov b, $0
1721   0D47 B0            cmp a, b
1722   0D48 FD 71         seq ; ==
1723   0D4A D8            push b
1724   0D4B 12            mov a, c
1725   0D4C FD 27         mov b, g
1726   0D4E B0            cmp a, b
1727   0D4F FD 71         seq ; ==
1728   0D51 E4            pop a
1729   0D52 FD A7         sand a, b
1730   0D54 FD F1         pop g
1731   0D56 E4            pop a
1732   0D57             ; END RELATIONAL
1733   0D57 C0 00 00      cmp b, 0
1734   0D5A C6 6C 0D      je _if27_exit
1735   0D5D             _if27_true:
1736   0D5D             ;; putchar('0'); 
1737   0D5D 26 30 00      mov b, $30
1738   0D60 DD            push bl
1739   0D61 07 EF 0F      call putchar
1740   0D64 51 01 00      add sp, 1
1741   0D67             ;; return; 
1742   0D67 F9            leave
1743   0D68 09            ret
1744   0D69 0A 6C 0D      jmp _if27_exit
1745   0D6C             _if27_exit:
1746   0D6C             _if26_exit:
1747   0D6C             ;; while (num > 0) { 
1748   0D6C             _while28_cond:
1749   0D6C FA 05 00      lea d, [bp + 5] ; $num
1750   0D6F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1751   0D72 FD 39         mov c, b ; And place it into C
1752   0D74 2A            mov b, [d] ; Lower Word in B
1753   0D75             ; START RELATIONAL
1754   0D75 D7            push a
1755   0D76 FD D8         push g
1756   0D78 11            mov a, b
1757   0D79 FD 7A         mov g, c
1758   0D7B 26 00 00      mov b, $0
1759   0D7E B0            cmp a, b
1760   0D7F FD 7F         sgt ; >
1761   0D81 FD F1         pop g
1762   0D83 E4            pop a
1763   0D84             ; END RELATIONAL
1764   0D84 C0 00 00      cmp b, 0
1765   0D87 C6 E7 0D      je _while28_exit
1766   0D8A             _while28_block:
1767   0D8A             ;; digits[i] = '0' + (num % 10); 
1768   0D8A FA F7 FF      lea d, [bp + -9] ; $digits
1769   0D8D D7            push a
1770   0D8E DA            push d
1771   0D8F FA F5 FF      lea d, [bp + -11] ; $i
1772   0D92 2A            mov b, [d]
1773   0D93 E7            pop d
1774   0D94 5A            add d, b
1775   0D95 E4            pop a
1776   0D96 DA            push d
1777   0D97 26 30 00      mov b, $30
1778   0D9A             ; START TERMS
1779   0D9A D7            push a
1780   0D9B 11            mov a, b
1781   0D9C FA 05 00      lea d, [bp + 5] ; $num
1782   0D9F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1783   0DA2 FD 39         mov c, b ; And place it into C
1784   0DA4 2A            mov b, [d] ; Lower Word in B
1785   0DA5             ; START FACTORS
1786   0DA5 D7            push a
1787   0DA6 11            mov a, b
1788   0DA7 26 0A 00      mov b, $a
1789   0DAA AE            div a, b ; 
1790   0DAB 11            mov a, b
1791   0DAC 27            mov b, a
1792   0DAD E4            pop a
1793   0DAE             ; END FACTORS
1794   0DAE 54            add a, b
1795   0DAF D7            push a
1796   0DB0 FD 12         mov a, g
1797   0DB2 28            mov b, c
1798   0DB3 5C            adc a, b
1799   0DB4 39            mov c, a
1800   0DB5 E5            pop b
1801   0DB6 E4            pop a
1802   0DB7             ; END TERMS
1803   0DB7 E7            pop d
1804   0DB8 FD 3E         mov [d], bl
1805   0DBA             ;; num = num / 10; 
1806   0DBA FA 05 00      lea d, [bp + 5] ; $num
1807   0DBD DA            push d
1808   0DBE FA 05 00      lea d, [bp + 5] ; $num
1809   0DC1 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1810   0DC4 FD 39         mov c, b ; And place it into C
1811   0DC6 2A            mov b, [d] ; Lower Word in B
1812   0DC7             ; START FACTORS
1813   0DC7 D7            push a
1814   0DC8 11            mov a, b
1815   0DC9 26 0A 00      mov b, $a
1816   0DCC AE            div a, b
1817   0DCD 27            mov b, a
1818   0DCE E4            pop a
1819   0DCF             ; END FACTORS
1820   0DCF E7            pop d
1821   0DD0 FD 43         mov [d], b
1822   0DD2 28            mov b, c
1823   0DD3 FD 44 02 00   mov [d + 2], b
1824   0DD7             ;; i++; 
1825   0DD7 FA F5 FF      lea d, [bp + -11] ; $i
1826   0DDA 2A            mov b, [d]
1827   0DDB D8            push b
1828   0DDC FD 77         inc b
1829   0DDE FA F5 FF      lea d, [bp + -11] ; $i
1830   0DE1 FD 43         mov [d], b
1831   0DE3 E5            pop b
1832   0DE4 0A 6C 0D      jmp _while28_cond
1833   0DE7             _while28_exit:
1834   0DE7             ;; while (i > 0) { 
1835   0DE7             _while29_cond:
1836   0DE7 FA F5 FF      lea d, [bp + -11] ; $i
1837   0DEA 2A            mov b, [d]
1838   0DEB             ; START RELATIONAL
1839   0DEB D7            push a
1840   0DEC 11            mov a, b
1841   0DED 26 00 00      mov b, $0
1842   0DF0 B0            cmp a, b
1843   0DF1 FD 7F         sgt ; >
1844   0DF3 E4            pop a
1845   0DF4             ; END RELATIONAL
1846   0DF4 C0 00 00      cmp b, 0
1847   0DF7 C6 20 0E      je _while29_exit
1848   0DFA             _while29_block:
1849   0DFA             ;; i--; 
1850   0DFA FA F5 FF      lea d, [bp + -11] ; $i
1851   0DFD 2A            mov b, [d]
1852   0DFE D8            push b
1853   0DFF FD 7D         dec b
1854   0E01 FA F5 FF      lea d, [bp + -11] ; $i
1855   0E04 FD 43         mov [d], b
1856   0E06 E5            pop b
1857   0E07             ;; putchar(digits[i]); 
1858   0E07 FA F7 FF      lea d, [bp + -9] ; $digits
1859   0E0A D7            push a
1860   0E0B DA            push d
1861   0E0C FA F5 FF      lea d, [bp + -11] ; $i
1862   0E0F 2A            mov b, [d]
1863   0E10 E7            pop d
1864   0E11 5A            add d, b
1865   0E12 E4            pop a
1866   0E13 32            mov bl, [d]
1867   0E14 A7 00         mov bh, 0
1868   0E16 DD            push bl
1869   0E17 07 EF 0F      call putchar
1870   0E1A 51 01 00      add sp, 1
1871   0E1D 0A E7 0D      jmp _while29_cond
1872   0E20             _while29_exit:
1873   0E20 F9            leave
1874   0E21 09            ret
1875   0E22             
1876   0E22             print_unsigned_long:
1877   0E22 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1878   0E25             ; $digits 
1879   0E25             ; $i 
1880   0E25 52 0C 00      sub sp, 12
1881   0E28             ;; i = 0; 
1882   0E28 FA F5 FF      lea d, [bp + -11] ; $i
1883   0E2B DA            push d
1884   0E2C 26 00 00      mov b, $0
1885   0E2F E7            pop d
1886   0E30 FD 43         mov [d], b
1887   0E32             ;; if(num == 0){ 
1888   0E32             _if30_cond:
1889   0E32 FA 05 00      lea d, [bp + 5] ; $num
1890   0E35 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1891   0E38 FD 39         mov c, b ; And place it into C
1892   0E3A 2A            mov b, [d] ; Lower Word in B
1893   0E3B             ; START RELATIONAL
1894   0E3B D7            push a
1895   0E3C FD D8         push g
1896   0E3E 11            mov a, b
1897   0E3F FD 7A         mov g, c
1898   0E41 26 00 00      mov b, $0
1899   0E44 B0            cmp a, b
1900   0E45 FD 71         seq ; ==
1901   0E47 D8            push b
1902   0E48 12            mov a, c
1903   0E49 FD 27         mov b, g
1904   0E4B B0            cmp a, b
1905   0E4C FD 71         seq ; ==
1906   0E4E E4            pop a
1907   0E4F FD A7         sand a, b
1908   0E51 FD F1         pop g
1909   0E53 E4            pop a
1910   0E54             ; END RELATIONAL
1911   0E54 C0 00 00      cmp b, 0
1912   0E57 C6 69 0E      je _if30_exit
1913   0E5A             _if30_true:
1914   0E5A             ;; putchar('0'); 
1915   0E5A 26 30 00      mov b, $30
1916   0E5D DD            push bl
1917   0E5E 07 EF 0F      call putchar
1918   0E61 51 01 00      add sp, 1
1919   0E64             ;; return; 
1920   0E64 F9            leave
1921   0E65 09            ret
1922   0E66 0A 69 0E      jmp _if30_exit
1923   0E69             _if30_exit:
1924   0E69             ;; while (num > 0) { 
1925   0E69             _while31_cond:
1926   0E69 FA 05 00      lea d, [bp + 5] ; $num
1927   0E6C 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1928   0E6F FD 39         mov c, b ; And place it into C
1929   0E71 2A            mov b, [d] ; Lower Word in B
1930   0E72             ; START RELATIONAL
1931   0E72 D7            push a
1932   0E73 FD D8         push g
1933   0E75 11            mov a, b
1934   0E76 FD 7A         mov g, c
1935   0E78 26 00 00      mov b, $0
1936   0E7B B0            cmp a, b
1937   0E7C FD 81         sgu ; > (unsigned)
1938   0E7E FD F1         pop g
1939   0E80 E4            pop a
1940   0E81             ; END RELATIONAL
1941   0E81 C0 00 00      cmp b, 0
1942   0E84 C6 E4 0E      je _while31_exit
1943   0E87             _while31_block:
1944   0E87             ;; digits[i] = '0' + (num % 10); 
1945   0E87 FA F7 FF      lea d, [bp + -9] ; $digits
1946   0E8A D7            push a
1947   0E8B DA            push d
1948   0E8C FA F5 FF      lea d, [bp + -11] ; $i
1949   0E8F 2A            mov b, [d]
1950   0E90 E7            pop d
1951   0E91 5A            add d, b
1952   0E92 E4            pop a
1953   0E93 DA            push d
1954   0E94 26 30 00      mov b, $30
1955   0E97             ; START TERMS
1956   0E97 D7            push a
1957   0E98 11            mov a, b
1958   0E99 FA 05 00      lea d, [bp + 5] ; $num
1959   0E9C 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1960   0E9F FD 39         mov c, b ; And place it into C
1961   0EA1 2A            mov b, [d] ; Lower Word in B
1962   0EA2             ; START FACTORS
1963   0EA2 D7            push a
1964   0EA3 11            mov a, b
1965   0EA4 26 0A 00      mov b, $a
1966   0EA7 AE            div a, b ; 
1967   0EA8 11            mov a, b
1968   0EA9 27            mov b, a
1969   0EAA E4            pop a
1970   0EAB             ; END FACTORS
1971   0EAB 54            add a, b
1972   0EAC D7            push a
1973   0EAD FD 12         mov a, g
1974   0EAF 28            mov b, c
1975   0EB0 5C            adc a, b
1976   0EB1 39            mov c, a
1977   0EB2 E5            pop b
1978   0EB3 E4            pop a
1979   0EB4             ; END TERMS
1980   0EB4 E7            pop d
1981   0EB5 FD 3E         mov [d], bl
1982   0EB7             ;; num = num / 10; 
1983   0EB7 FA 05 00      lea d, [bp + 5] ; $num
1984   0EBA DA            push d
1985   0EBB FA 05 00      lea d, [bp + 5] ; $num
1986   0EBE 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1987   0EC1 FD 39         mov c, b ; And place it into C
1988   0EC3 2A            mov b, [d] ; Lower Word in B
1989   0EC4             ; START FACTORS
1990   0EC4 D7            push a
1991   0EC5 11            mov a, b
1992   0EC6 26 0A 00      mov b, $a
1993   0EC9 AE            div a, b
1994   0ECA 27            mov b, a
1995   0ECB E4            pop a
1996   0ECC             ; END FACTORS
1997   0ECC E7            pop d
1998   0ECD FD 43         mov [d], b
1999   0ECF 28            mov b, c
2000   0ED0 FD 44 02 00   mov [d + 2], b
2001   0ED4             ;; i++; 
2002   0ED4 FA F5 FF      lea d, [bp + -11] ; $i
2003   0ED7 2A            mov b, [d]
2004   0ED8 D8            push b
2005   0ED9 FD 77         inc b
2006   0EDB FA F5 FF      lea d, [bp + -11] ; $i
2007   0EDE FD 43         mov [d], b
2008   0EE0 E5            pop b
2009   0EE1 0A 69 0E      jmp _while31_cond
2010   0EE4             _while31_exit:
2011   0EE4             ;; while (i > 0) { 
2012   0EE4             _while32_cond:
2013   0EE4 FA F5 FF      lea d, [bp + -11] ; $i
2014   0EE7 2A            mov b, [d]
2015   0EE8             ; START RELATIONAL
2016   0EE8 D7            push a
2017   0EE9 11            mov a, b
2018   0EEA 26 00 00      mov b, $0
2019   0EED B0            cmp a, b
2020   0EEE FD 7F         sgt ; >
2021   0EF0 E4            pop a
2022   0EF1             ; END RELATIONAL
2023   0EF1 C0 00 00      cmp b, 0
2024   0EF4 C6 1D 0F      je _while32_exit
2025   0EF7             _while32_block:
2026   0EF7             ;; i--; 
2027   0EF7 FA F5 FF      lea d, [bp + -11] ; $i
2028   0EFA 2A            mov b, [d]
2029   0EFB D8            push b
2030   0EFC FD 7D         dec b
2031   0EFE FA F5 FF      lea d, [bp + -11] ; $i
2032   0F01 FD 43         mov [d], b
2033   0F03 E5            pop b
2034   0F04             ;; putchar(digits[i]); 
2035   0F04 FA F7 FF      lea d, [bp + -9] ; $digits
2036   0F07 D7            push a
2037   0F08 DA            push d
2038   0F09 FA F5 FF      lea d, [bp + -11] ; $i
2039   0F0C 2A            mov b, [d]
2040   0F0D E7            pop d
2041   0F0E 5A            add d, b
2042   0F0F E4            pop a
2043   0F10 32            mov bl, [d]
2044   0F11 A7 00         mov bh, 0
2045   0F13 DD            push bl
2046   0F14 07 EF 0F      call putchar
2047   0F17 51 01 00      add sp, 1
2048   0F1A 0A E4 0E      jmp _while32_cond
2049   0F1D             _while32_exit:
2050   0F1D F9            leave
2051   0F1E 09            ret
2052   0F1F             
2053   0F1F             print_unsigned:
2054   0F1F F8 00 00      enter 0 ; (push bp; mov bp, sp)
2055   0F22             ; $digits 
2056   0F22             ; $i 
2057   0F22 52 07 00      sub sp, 7
2058   0F25             ;; i = 0; 
2059   0F25 FA FA FF      lea d, [bp + -6] ; $i
2060   0F28 DA            push d
2061   0F29 26 00 00      mov b, $0
2062   0F2C E7            pop d
2063   0F2D FD 43         mov [d], b
2064   0F2F             ;; if(num == 0){ 
2065   0F2F             _if33_cond:
2066   0F2F FA 05 00      lea d, [bp + 5] ; $num
2067   0F32 2A            mov b, [d]
2068   0F33             ; START RELATIONAL
2069   0F33 D7            push a
2070   0F34 11            mov a, b
2071   0F35 26 00 00      mov b, $0
2072   0F38 B0            cmp a, b
2073   0F39 FD 71         seq ; ==
2074   0F3B E4            pop a
2075   0F3C             ; END RELATIONAL
2076   0F3C C0 00 00      cmp b, 0
2077   0F3F C6 51 0F      je _if33_exit
2078   0F42             _if33_true:
2079   0F42             ;; putchar('0'); 
2080   0F42 26 30 00      mov b, $30
2081   0F45 DD            push bl
2082   0F46 07 EF 0F      call putchar
2083   0F49 51 01 00      add sp, 1
2084   0F4C             ;; return; 
2085   0F4C F9            leave
2086   0F4D 09            ret
2087   0F4E 0A 51 0F      jmp _if33_exit
2088   0F51             _if33_exit:
2089   0F51             ;; while (num > 0) { 
2090   0F51             _while34_cond:
2091   0F51 FA 05 00      lea d, [bp + 5] ; $num
2092   0F54 2A            mov b, [d]
2093   0F55             ; START RELATIONAL
2094   0F55 D7            push a
2095   0F56 11            mov a, b
2096   0F57 26 00 00      mov b, $0
2097   0F5A B0            cmp a, b
2098   0F5B FD 81         sgu ; > (unsigned)
2099   0F5D E4            pop a
2100   0F5E             ; END RELATIONAL
2101   0F5E C0 00 00      cmp b, 0
2102   0F61 C6 AB 0F      je _while34_exit
2103   0F64             _while34_block:
2104   0F64             ;; digits[i] = '0' + (num % 10); 
2105   0F64 FA FC FF      lea d, [bp + -4] ; $digits
2106   0F67 D7            push a
2107   0F68 DA            push d
2108   0F69 FA FA FF      lea d, [bp + -6] ; $i
2109   0F6C 2A            mov b, [d]
2110   0F6D E7            pop d
2111   0F6E 5A            add d, b
2112   0F6F E4            pop a
2113   0F70 DA            push d
2114   0F71 26 30 00      mov b, $30
2115   0F74             ; START TERMS
2116   0F74 D7            push a
2117   0F75 11            mov a, b
2118   0F76 FA 05 00      lea d, [bp + 5] ; $num
2119   0F79 2A            mov b, [d]
2120   0F7A             ; START FACTORS
2121   0F7A D7            push a
2122   0F7B 11            mov a, b
2123   0F7C 26 0A 00      mov b, $a
2124   0F7F AE            div a, b ; 
2125   0F80 11            mov a, b
2126   0F81 27            mov b, a
2127   0F82 E4            pop a
2128   0F83             ; END FACTORS
2129   0F83 56            add b, a
2130   0F84 E4            pop a
2131   0F85             ; END TERMS
2132   0F85 E7            pop d
2133   0F86 FD 3E         mov [d], bl
2134   0F88             ;; num = num / 10; 
2135   0F88 FA 05 00      lea d, [bp + 5] ; $num
2136   0F8B DA            push d
2137   0F8C FA 05 00      lea d, [bp + 5] ; $num
2138   0F8F 2A            mov b, [d]
2139   0F90             ; START FACTORS
2140   0F90 D7            push a
2141   0F91 11            mov a, b
2142   0F92 26 0A 00      mov b, $a
2143   0F95 AE            div a, b
2144   0F96 27            mov b, a
2145   0F97 E4            pop a
2146   0F98             ; END FACTORS
2147   0F98 E7            pop d
2148   0F99 FD 43         mov [d], b
2149   0F9B             ;; i++; 
2150   0F9B FA FA FF      lea d, [bp + -6] ; $i
2151   0F9E 2A            mov b, [d]
2152   0F9F D8            push b
2153   0FA0 FD 77         inc b
2154   0FA2 FA FA FF      lea d, [bp + -6] ; $i
2155   0FA5 FD 43         mov [d], b
2156   0FA7 E5            pop b
2157   0FA8 0A 51 0F      jmp _while34_cond
2158   0FAB             _while34_exit:
2159   0FAB             ;; while (i > 0) { 
2160   0FAB             _while35_cond:
2161   0FAB FA FA FF      lea d, [bp + -6] ; $i
2162   0FAE 2A            mov b, [d]
2163   0FAF             ; START RELATIONAL
2164   0FAF D7            push a
2165   0FB0 11            mov a, b
2166   0FB1 26 00 00      mov b, $0
2167   0FB4 B0            cmp a, b
2168   0FB5 FD 7F         sgt ; >
2169   0FB7 E4            pop a
2170   0FB8             ; END RELATIONAL
2171   0FB8 C0 00 00      cmp b, 0
2172   0FBB C6 E4 0F      je _while35_exit
2173   0FBE             _while35_block:
2174   0FBE             ;; i--; 
2175   0FBE FA FA FF      lea d, [bp + -6] ; $i
2176   0FC1 2A            mov b, [d]
2177   0FC2 D8            push b
2178   0FC3 FD 7D         dec b
2179   0FC5 FA FA FF      lea d, [bp + -6] ; $i
2180   0FC8 FD 43         mov [d], b
2181   0FCA E5            pop b
2182   0FCB             ;; putchar(digits[i]); 
2183   0FCB FA FC FF      lea d, [bp + -4] ; $digits
2184   0FCE D7            push a
2185   0FCF DA            push d
2186   0FD0 FA FA FF      lea d, [bp + -6] ; $i
2187   0FD3 2A            mov b, [d]
2188   0FD4 E7            pop d
2189   0FD5 5A            add d, b
2190   0FD6 E4            pop a
2191   0FD7 32            mov bl, [d]
2192   0FD8 A7 00         mov bh, 0
2193   0FDA DD            push bl
2194   0FDB 07 EF 0F      call putchar
2195   0FDE 51 01 00      add sp, 1
2196   0FE1 0A AB 0F      jmp _while35_cond
2197   0FE4             _while35_exit:
2198   0FE4 F9            leave
2199   0FE5 09            ret
2200   0FE6             
2201   0FE6             date:
2202   0FE6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2203   0FE9             
2204   0FE9             ; --- BEGIN INLINE ASM BLOCK
2205   0FE9 19 00         mov al, 0 
2206   0FEB 05 07         syscall sys_datetime
2207   0FED             ; --- END INLINE ASM BLOCK
2208   0FED             
2209   0FED F9            leave
2210   0FEE 09            ret
2211   0FEF             
2212   0FEF             putchar:
2213   0FEF F8 00 00      enter 0 ; (push bp; mov bp, sp)
2214   0FF2             
2215   0FF2             ; --- BEGIN INLINE ASM BLOCK
2216   0FF2 FA 05 00      lea d, [bp + 5] ; $c
2217   0FF5 1E            mov al, [d]
2218   0FF6 23            mov ah, al
2219   0FF7 07 5B 11      call _putchar
2220   0FFA             ; --- END INLINE ASM BLOCK
2221   0FFA             
2222   0FFA F9            leave
2223   0FFB 09            ret
2224   0FFC             
2225   0FFC             getchar:
2226   0FFC F8 00 00      enter 0 ; (push bp; mov bp, sp)
2227   0FFF             ; $c 
2228   0FFF 52 01 00      sub sp, 1
2229   1002             
2230   1002             ; --- BEGIN INLINE ASM BLOCK
2231   1002 07 54 11      call getch
2232   1005 1A            mov al, ah
2233   1006 FA 00 00      lea d, [bp + 0] ; $c
2234   1009 3E            mov [d], al
2235   100A             ; --- END INLINE ASM BLOCK
2236   100A             
2237   100A             ;; return c; 
2238   100A FA 00 00      lea d, [bp + 0] ; $c
2239   100D 32            mov bl, [d]
2240   100E A7 00         mov bh, 0
2241   1010 F9            leave
2242   1011 09            ret
2243   1012             
2244   1012             scann:
2245   1012 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2246   1015             ; $m 
2247   1015 52 02 00      sub sp, 2
2248   1018             
2249   1018             ; --- BEGIN INLINE ASM BLOCK
2250   1018 07 9F 13      call scan_u16d
2251   101B FA FF FF      lea d, [bp + -1] ; $m
2252   101E 43            mov [d], a
2253   101F             ; --- END INLINE ASM BLOCK
2254   101F             
2255   101F             ;; return m; 
2256   101F FA FF FF      lea d, [bp + -1] ; $m
2257   1022 2A            mov b, [d]
2258   1023 F9            leave
2259   1024 09            ret
2260   1025             
2261   1025             puts:
2262   1025 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2263   1028             
2264   1028             ; --- BEGIN INLINE ASM BLOCK
2265   1028 FA 05 00      lea d, [bp + 5] ; $s
2266   102B 15            mov a, [d]
2267   102C 3C            mov d, a
2268   102D 07 A5 12      call _puts
2269   1030 10 00 0A      mov a, $0A00
2270   1033 05 03         syscall sys_io
2271   1035             ; --- END INLINE ASM BLOCK
2272   1035             
2273   1035 F9            leave
2274   1036 09            ret
2275   1037             
2276   1037             print:
2277   1037 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2278   103A             
2279   103A             ; --- BEGIN INLINE ASM BLOCK
2280   103A FA 05 00      lea d, [bp + 5] ; $s
2281   103D FD 2A         mov d, [d]
2282   103F 07 A5 12      call _puts
2283   1042             ; --- END INLINE ASM BLOCK
2284   1042             
2285   1042 F9            leave
2286   1043 09            ret
2287   1044             
2288   1044             getparam:
2289   1044 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2290   1047             ; $data 
2291   1047 52 01 00      sub sp, 1
2292   104A             
2293   104A             ; --- BEGIN INLINE ASM BLOCK
2294   104A 19 04         mov al, 4
2295   104C FA 05 00      lea d, [bp + 5] ; $address
2296   104F FD 2A         mov d, [d]
2297   1051 05 0C         syscall sys_system
2298   1053 FA 00 00      lea d, [bp + 0] ; $data
2299   1056 FD 3E         mov [d], bl
2300   1058             ; --- END INLINE ASM BLOCK
2301   1058             
2302   1058             ;; return data; 
2303   1058 FA 00 00      lea d, [bp + 0] ; $data
2304   105B 32            mov bl, [d]
2305   105C A7 00         mov bh, 0
2306   105E F9            leave
2307   105F 09            ret
2308   1060             
2309   1060             clear:
2310   1060 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2311   1063             ;; print("\033[2J\033[H"); 
2312   1063 26 FB 14      mov b, __s2 ; "\033[2J\033[H"
2313   1066 FD AB         swp b
2314   1068 D8            push b
2315   1069 07 37 10      call print
2316   106C 51 02 00      add sp, 2
2317   106F F9            leave
2318   1070 09            ret
2319   1071             
2320   1071             include_stdio_asm:
2321   1071 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2322   1074             
2323   1074             ; --- BEGIN INLINE ASM BLOCK
2324   1074             .include "lib/asm/stdio.asm"
0001+  1074             ;-----------------------------------------------------------------------------
0002+  1074             ; stdio.s
0003+  1074             ;-----------------------------------------------------------------------------
0004+  1074             .include "lib/asm/string.asm"
0001++ 1074             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 1074             ; string.s
0003++ 1074             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 1074             
0005++ 1074             
0006++ 1074             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 1074             ; _strrev
0008++ 1074             ; reverse a string
0009++ 1074             ; D = string address
0010++ 1074             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 1074             ; 01234
0012++ 1074             _strrev:
0013++ 1074 4B          	pusha
0014++ 1075 07 BB 10    	call _strlen	; length in C
0015++ 1078 12          	mov a, c
0016++ 1079 AF 01 00    	cmp a, 1
0017++ 107C D0 96 10    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 107F 7D          	dec a
0019++ 1080 FD 4E       	mov si, d	; beginning of string
0020++ 1082 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 1084 59          	add d, a	; end of string
0022++ 1085 12          	mov a, c
0023++ 1086 FD 9B       	shr a		; divide by 2
0024++ 1088 39          	mov c, a	; C now counts the steps
0025++ 1089             _strrev_L0:
0026++ 1089 32          	mov bl, [d]	; save load right-side char into BL
0027++ 108A F6          	lodsb		; load left-side char into AL; increase SI
0028++ 108B 3E          	mov [d], al	; store left char into right side
0029++ 108C 1B          	mov al, bl
0030++ 108D F7          	stosb		; store right-side char into left-side; increase DI
0031++ 108E 7E          	dec c
0032++ 108F 7F          	dec d
0033++ 1090 C2 00 00    	cmp c, 0
0034++ 1093 C7 89 10    	jne _strrev_L0
0035++ 1096             _strrev_end:
0036++ 1096 4C          	popa
0037++ 1097 09          	ret
0038++ 1098             	
0039++ 1098             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 1098             ; _strchr
0041++ 1098             ; search string in D for char in AL
0042++ 1098             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 1098             _strchr:
0044++ 1098             _strchr_L0:
0045++ 1098 32          	mov bl, [d]
0046++ 1099 C1 00       	cmp bl, 0
0047++ 109B C6 A6 10    	je _strchr_end
0048++ 109E BA          	cmp al, bl
0049++ 109F C6 A6 10    	je _strchr_end
0050++ 10A2 79          	inc d
0051++ 10A3 0A 98 10    	jmp _strchr_L0
0052++ 10A6             _strchr_end:
0053++ 10A6 1B          	mov al, bl
0054++ 10A7 09          	ret
0055++ 10A8             
0056++ 10A8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 10A8             ; _strstr
0058++ 10A8             ; find sub-string
0059++ 10A8             ; str1 in SI
0060++ 10A8             ; str2 in DI
0061++ 10A8             ; SI points to end of source string
0062++ 10A8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 10A8             _strstr:
0064++ 10A8 DB          	push al
0065++ 10A9 DA          	push d
0066++ 10AA E3          	push di
0067++ 10AB             _strstr_loop:
0068++ 10AB F3          	cmpsb					; compare a byte of the strings
0069++ 10AC C7 B7 10    	jne _strstr_ret
0070++ 10AF FC 00 00    	lea d, [di + 0]
0071++ 10B2 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 10B4 C7 AB 10    	jne _strstr_loop				; equal chars but not at end
0073++ 10B7             _strstr_ret:
0074++ 10B7 F0          	pop di
0075++ 10B8 E7          	pop d
0076++ 10B9 E8          	pop al
0077++ 10BA 09          	ret
0078++ 10BB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 10BB             ; length of null terminated string
0080++ 10BB             ; result in C
0081++ 10BB             ; pointer in D
0082++ 10BB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 10BB             _strlen:
0084++ 10BB DA          	push d
0085++ 10BC 38 00 00    	mov c, 0
0086++ 10BF             _strlen_L1:
0087++ 10BF BD 00       	cmp byte [d], 0
0088++ 10C1 C6 C9 10    	je _strlen_ret
0089++ 10C4 79          	inc d
0090++ 10C5 78          	inc c
0091++ 10C6 0A BF 10    	jmp _strlen_L1
0092++ 10C9             _strlen_ret:
0093++ 10C9 E7          	pop d
0094++ 10CA 09          	ret
0095++ 10CB             
0096++ 10CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 10CB             ; STRCMP
0098++ 10CB             ; compare two strings
0099++ 10CB             ; str1 in SI
0100++ 10CB             ; str2 in DI
0101++ 10CB             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 10CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 10CB             _strcmp:
0104++ 10CB DB          	push al
0105++ 10CC DA          	push d
0106++ 10CD E3          	push di
0107++ 10CE E2          	push si
0108++ 10CF             _strcmp_loop:
0109++ 10CF F3          	cmpsb					; compare a byte of the strings
0110++ 10D0 C7 DB 10    	jne _strcmp_ret
0111++ 10D3 FB FF FF    	lea d, [si +- 1]
0112++ 10D6 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 10D8 C7 CF 10    	jne _strcmp_loop				; equal chars but not at end
0114++ 10DB             _strcmp_ret:
0115++ 10DB EF          	pop si
0116++ 10DC F0          	pop di
0117++ 10DD E7          	pop d
0118++ 10DE E8          	pop al
0119++ 10DF 09          	ret
0120++ 10E0             
0121++ 10E0             
0122++ 10E0             ; STRCPY
0123++ 10E0             ; copy null terminated string from SI to DI
0124++ 10E0             ; source in SI
0125++ 10E0             ; destination in DI
0126++ 10E0             _strcpy:
0127++ 10E0 E2          	push si
0128++ 10E1 E3          	push di
0129++ 10E2 DB          	push al
0130++ 10E3             _strcpy_L1:
0131++ 10E3 F6          	lodsb
0132++ 10E4 F7          	stosb
0133++ 10E5 B9 00       	cmp al, 0
0134++ 10E7 C7 E3 10    	jne _strcpy_L1
0135++ 10EA             _strcpy_end:
0136++ 10EA E8          	pop al
0137++ 10EB F0          	pop di
0138++ 10EC EF          	pop si
0139++ 10ED 09          	ret
0140++ 10EE             
0141++ 10EE             ; STRCAT
0142++ 10EE             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 10EE             ; source in SI
0144++ 10EE             ; destination in DI
0145++ 10EE             _strcat:
0146++ 10EE E2          	push si
0147++ 10EF E3          	push di
0148++ 10F0 D7          	push a
0149++ 10F1 DA          	push d
0150++ 10F2 50          	mov a, di
0151++ 10F3 3C          	mov d, a
0152++ 10F4             _strcat_goto_end_L1:
0153++ 10F4 BD 00       	cmp byte[d], 0
0154++ 10F6 C6 FD 10    	je _strcat_start
0155++ 10F9 79          	inc d
0156++ 10FA 0A F4 10    	jmp _strcat_goto_end_L1
0157++ 10FD             _strcat_start:
0158++ 10FD FD 50       	mov di, d
0159++ 10FF             _strcat_L1:
0160++ 10FF F6          	lodsb
0161++ 1100 F7          	stosb
0162++ 1101 B9 00       	cmp al, 0
0163++ 1103 C7 FF 10    	jne _strcat_L1
0164++ 1106             _strcat_end:
0165++ 1106 E7          	pop d
0166++ 1107 E4          	pop a
0167++ 1108 F0          	pop di
0168++ 1109 EF          	pop si
0169++ 110A 09          	ret
0170++ 110B             
0171++ 110B             
0005+  110B             
0006+  110B             ;-----------------------------------------------------------------------------
0007+  110B             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0008+  110B             ; ASCII in BL
0009+  110B             ; result in AL
0010+  110B             ; ascii for F = 0100 0110
0011+  110B             ; ascii for 9 = 0011 1001
0012+  110B             ;-----------------------------------------------------------------------------
0013+  110B             hex_ascii_encode:
0014+  110B 1B            mov al, bl
0015+  110C 93 40         test al, $40        ; test if letter or number
0016+  110E C7 14 11      jnz hex_letter
0017+  1111 87 0F         and al, $0F        ; get number
0018+  1113 09            ret
0019+  1114             hex_letter:
0020+  1114 87 0F         and al, $0F        ; get letter
0021+  1116 6A 09         add al, 9
0022+  1118 09            ret
0023+  1119             
0024+  1119             ;-----------------------------------------------------------------------------
0025+  1119             ; ATOI
0026+  1119             ; 2 letter hex string in B
0027+  1119             ; 8bit integer returned in AL
0028+  1119             ;-----------------------------------------------------------------------------
0029+  1119             _atoi:
0030+  1119 D8            push b
0031+  111A 07 0B 11      call hex_ascii_encode      ; convert BL to 4bit code in AL
0032+  111D 30            mov bl, bh
0033+  111E DB            push al          ; save a
0034+  111F 07 0B 11      call hex_ascii_encode
0035+  1122 EA            pop bl  
0036+  1123 FD 9E 04      shl al, 4
0037+  1126 8C            or al, bl
0038+  1127 E5            pop b
0039+  1128 09            ret  
0040+  1129             
0041+  1129             
0042+  1129             ;-----------------------------------------------------------------------------
0043+  1129             ; ITOA
0044+  1129             ; 8bit value in BL
0045+  1129             ; 2 byte ASCII result in A
0046+  1129             ;-----------------------------------------------------------------------------
0047+  1129             _itoa:
0048+  1129 DA            push d
0049+  112A D8            push b
0050+  112B A7 00         mov bh, 0
0051+  112D FD A4 04      shr bl, 4  
0052+  1130 74            mov d, b
0053+  1131 1F D9 13      mov al, [d + s_hex_digits]
0054+  1134 23            mov ah, al
0055+  1135               
0056+  1135 E5            pop b
0057+  1136 D8            push b
0058+  1137 A7 00         mov bh, 0
0059+  1139 FD 87 0F      and bl, $0F
0060+  113C 74            mov d, b
0061+  113D 1F D9 13      mov al, [d + s_hex_digits]
0062+  1140 E5            pop b
0063+  1141 E7            pop d
0064+  1142 09            ret
0065+  1143             
0066+  1143             ;-----------------------------------------------------------------------------
0067+  1143             ; HEX STRING TO BINARY
0068+  1143             ; di = destination address
0069+  1143             ; si = source
0070+  1143             ;-----------------------------------------------------------------------------
0071+  1143             _hex_to_int:
0072+  1143             _hex_to_int_L1:
0073+  1143 F6            lodsb          ; load from [SI] to AL
0074+  1144 B9 00         cmp al, 0        ; check if ASCII 0
0075+  1146 C6 53 11      jz _hex_to_int_ret
0076+  1149 36            mov bh, al
0077+  114A F6            lodsb
0078+  114B 2F            mov bl, al
0079+  114C 07 19 11      call _atoi        ; convert ASCII byte in B to int (to AL)
0080+  114F F7            stosb          ; store AL to [DI]
0081+  1150 0A 43 11      jmp _hex_to_int_L1
0082+  1153             _hex_to_int_ret:
0083+  1153 09            ret    
0084+  1154             
0085+  1154             ;-----------------------------------------------------------------------------
0086+  1154             ; GETCHAR
0087+  1154             ; char in ah
0088+  1154             ;-----------------------------------------------------------------------------
0089+  1154             getch:
0090+  1154 DB            push al
0091+  1155             getch_retry:
0092+  1155 19 01         mov al, 1
0093+  1157 05 03         syscall sys_io      ; receive in AH
0094+  1159 E8            pop al
0095+  115A 09            ret
0096+  115B             
0097+  115B             ;-----------------------------------------------------------------------------
0098+  115B             ; PUTCHAR
0099+  115B             ; char in ah
0100+  115B             ;-----------------------------------------------------------------------------
0101+  115B             _putchar:
0102+  115B D7            push a
0103+  115C 19 00         mov al, 0
0104+  115E 05 03         syscall sys_io      ; char in AH
0105+  1160 E4            pop a
0106+  1161 09            ret
0107+  1162             
0108+  1162             ;-----------------------------------------------------------------------------
0109+  1162             ;; INPUT A STRING
0110+  1162             ;; terminates with null
0111+  1162             ;; pointer in D
0112+  1162             ;-----------------------------------------------------------------------------
0113+  1162             _gets:
0114+  1162 D7            push a
0115+  1163 DA            push d
0116+  1164             _gets_loop:
0117+  1164 19 01         mov al, 1
0118+  1166 05 03         syscall sys_io      ; receive in AH
0119+  1168 B9 00         cmp al, 0        ; check error code (AL)
0120+  116A C6 64 11      je _gets_loop      ; if no char received, retry
0121+  116D             
0122+  116D 76 1B         cmp ah, 27
0123+  116F C6 90 11      je _gets_ansi_esc
0124+  1172 76 0A         cmp ah, $0A        ; LF
0125+  1174 C6 FB 11      je _gets_end
0126+  1177 76 0D         cmp ah, $0D        ; CR
0127+  1179 C6 FB 11      je _gets_end
0128+  117C 76 5C         cmp ah, $5C        ; '\\'
0129+  117E C6 BC 11      je _gets_escape
0130+  1181               
0131+  1181 76 08         cmp ah, $08      ; check for backspace
0132+  1183 C6 8C 11      je _gets_backspace
0133+  1186             
0134+  1186 1A            mov al, ah
0135+  1187 3E            mov [d], al
0136+  1188 79            inc d
0137+  1189 0A 64 11      jmp _gets_loop
0138+  118C             _gets_backspace:
0139+  118C 7F            dec d
0140+  118D 0A 64 11      jmp _gets_loop
0141+  1190             _gets_ansi_esc:
0142+  1190 19 01         mov al, 1
0143+  1192 05 03         syscall sys_io        ; receive in AH without echo
0144+  1194 B9 00         cmp al, 0          ; check error code (AL)
0145+  1196 C6 90 11      je _gets_ansi_esc    ; if no char received, retry
0146+  1199 76 5B         cmp ah, '['
0147+  119B C7 64 11      jne _gets_loop
0148+  119E             _gets_ansi_esc_2:
0149+  119E 19 01         mov al, 1
0150+  11A0 05 03         syscall sys_io          ; receive in AH without echo
0151+  11A2 B9 00         cmp al, 0            ; check error code (AL)
0152+  11A4 C6 9E 11      je _gets_ansi_esc_2  ; if no char received, retry
0153+  11A7 76 44         cmp ah, 'D'
0154+  11A9 C6 B4 11      je _gets_left_arrow
0155+  11AC 76 43         cmp ah, 'C'
0156+  11AE C6 B8 11      je _gets_right_arrow
0157+  11B1 0A 64 11      jmp _gets_loop
0158+  11B4             _gets_left_arrow:
0159+  11B4 7F            dec d
0160+  11B5 0A 64 11      jmp _gets_loop
0161+  11B8             _gets_right_arrow:
0162+  11B8 79            inc d
0163+  11B9 0A 64 11      jmp _gets_loop
0164+  11BC             _gets_escape:
0165+  11BC 19 01         mov al, 1
0166+  11BE 05 03         syscall sys_io      ; receive in AH
0167+  11C0 B9 00         cmp al, 0        ; check error code (AL)
0168+  11C2 C6 BC 11      je _gets_escape      ; if no char received, retry
0169+  11C5 76 6E         cmp ah, 'n'
0170+  11C7 C6 E6 11      je _gets_LF
0171+  11CA 76 72         cmp ah, 'r'
0172+  11CC C6 ED 11      je _gets_CR
0173+  11CF 76 30         cmp ah, '0'
0174+  11D1 C6 F4 11      je _gets_NULL
0175+  11D4 76 5C         cmp ah, $5C  ; '\'
0176+  11D6 C6 DF 11      je _gets_slash
0177+  11D9 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0178+  11DA 3E            mov [d], al
0179+  11DB 79            inc d
0180+  11DC 0A 64 11      jmp _gets_loop
0181+  11DF             _gets_slash:
0182+  11DF 19 5C         mov al, $5C
0183+  11E1 3E            mov [d], al
0184+  11E2 79            inc d
0185+  11E3 0A 64 11      jmp _gets_loop
0186+  11E6             _gets_LF:
0187+  11E6 19 0A         mov al, $0A
0188+  11E8 3E            mov [d], al
0189+  11E9 79            inc d
0190+  11EA 0A 64 11      jmp _gets_loop
0191+  11ED             _gets_CR:
0192+  11ED 19 0D         mov al, $0D
0193+  11EF 3E            mov [d], al
0194+  11F0 79            inc d
0195+  11F1 0A 64 11      jmp _gets_loop
0196+  11F4             _gets_NULL:
0197+  11F4 19 00         mov al, $00
0198+  11F6 3E            mov [d], al
0199+  11F7 79            inc d
0200+  11F8 0A 64 11      jmp _gets_loop
0201+  11FB             _gets_end:
0202+  11FB 19 00         mov al, 0
0203+  11FD 3E            mov [d], al        ; terminate string
0204+  11FE E7            pop d
0205+  11FF E4            pop a
0206+  1200 09            ret
0207+  1201             
0208+  1201             ;-----------------------------------------------------------------------------
0209+  1201             ;; INPUT TEXT
0210+  1201             ;; terminated with CTRL+D
0211+  1201             ;; pointer in D
0212+  1201             ;-----------------------------------------------------------------------------
0213+  1201             _gettxt:
0214+  1201 D7            push a
0215+  1202 DA            push d
0216+  1203             _gettxt_loop:
0217+  1203 19 01         mov al, 1
0218+  1205 05 03         syscall sys_io      ; receive in AH
0219+  1207 B9 00         cmp al, 0        ; check error code (AL)
0220+  1209 C6 03 12      je _gettxt_loop    ; if no char received, retry
0221+  120C 76 04         cmp ah, 4      ; EOT
0222+  120E C6 4C 12      je _gettxt_end
0223+  1211 76 08         cmp ah, $08      ; check for backspace
0224+  1213 C6 48 12      je _gettxt_backspace
0225+  1216 76 5C         cmp ah, $5C        ; '\'
0226+  1218 C6 21 12      je _gettxt_escape
0227+  121B 1A            mov al, ah
0228+  121C 3E            mov [d], al
0229+  121D 79            inc d
0230+  121E 0A 03 12      jmp _gettxt_loop
0231+  1221             _gettxt_escape:
0232+  1221 19 01         mov al, 1
0233+  1223 05 03         syscall sys_io      ; receive in AH
0234+  1225 B9 00         cmp al, 0        ; check error code (AL)
0235+  1227 C6 21 12      je _gettxt_escape    ; if no char received, retry
0236+  122A 76 6E         cmp ah, 'n'
0237+  122C C6 3A 12      je _gettxt_LF
0238+  122F 76 72         cmp ah, 'r'
0239+  1231 C6 41 12      je _gettxt_CR
0240+  1234 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0241+  1235 3E            mov [d], al
0242+  1236 79            inc d
0243+  1237 0A 03 12      jmp _gettxt_loop
0244+  123A             _gettxt_LF:
0245+  123A 19 0A         mov al, $0A
0246+  123C 3E            mov [d], al
0247+  123D 79            inc d
0248+  123E 0A 03 12      jmp _gettxt_loop
0249+  1241             _gettxt_CR:
0250+  1241 19 0D         mov al, $0D
0251+  1243 3E            mov [d], al
0252+  1244 79            inc d
0253+  1245 0A 03 12      jmp _gettxt_loop
0254+  1248             _gettxt_backspace:
0255+  1248 7F            dec d
0256+  1249 0A 03 12      jmp _gettxt_loop
0257+  124C             _gettxt_end:
0258+  124C 19 00         mov al, 0
0259+  124E 3E            mov [d], al        ; terminate string
0260+  124F E7            pop d
0261+  1250 E4            pop a
0262+  1251 09            ret
0263+  1252             
0264+  1252             ;-----------------------------------------------------------------------------
0265+  1252             ; PRINT NEW LINE
0266+  1252             ;-----------------------------------------------------------------------------
0267+  1252             printnl:
0268+  1252 D7            push a
0269+  1253 10 00 0A      mov a, $0A00
0270+  1256 05 03         syscall sys_io
0271+  1258 10 00 0D      mov a, $0D00
0272+  125B 05 03         syscall sys_io
0273+  125D E4            pop a
0274+  125E 09            ret
0275+  125F             
0276+  125F             ;-----------------------------------------------------------------------------
0277+  125F             ; _strtoint
0278+  125F             ; 4 digit hex string number in d
0279+  125F             ; integer returned in A
0280+  125F             ;-----------------------------------------------------------------------------
0281+  125F             _strtointx:
0282+  125F D8            push b
0283+  1260 32            mov bl, [d]
0284+  1261 37            mov bh, bl
0285+  1262 33 01 00      mov bl, [d + 1]
0286+  1265 07 19 11      call _atoi        ; convert to int in AL
0287+  1268 23            mov ah, al        ; move to AH
0288+  1269 33 02 00      mov bl, [d + 2]
0289+  126C 37            mov bh, bl
0290+  126D 33 03 00      mov bl, [d + 3]
0291+  1270 07 19 11      call _atoi        ; convert to int in AL
0292+  1273 E5            pop b
0293+  1274 09            ret
0294+  1275             
0295+  1275             ;-----------------------------------------------------------------------------
0296+  1275             ; _strtoint
0297+  1275             ; 5 digit base10 string number in d
0298+  1275             ; integer returned in A
0299+  1275             ;-----------------------------------------------------------------------------
0300+  1275             _strtoint:
0301+  1275 E2            push si
0302+  1276 D8            push b
0303+  1277 D9            push c
0304+  1278 DA            push d
0305+  1279 07 BB 10      call _strlen      ; get string length in C
0306+  127C 7E            dec c
0307+  127D FD 4E         mov si, d
0308+  127F 12            mov a, c
0309+  1280 FD 99         shl a
0310+  1282 3B F1 13      mov d, table_power
0311+  1285 59            add d, a
0312+  1286 38 00 00      mov c, 0
0313+  1289             _strtoint_L0:
0314+  1289 F6            lodsb      ; load ASCII to al
0315+  128A B9 00         cmp al, 0
0316+  128C C6 9F 12      je _strtoint_end
0317+  128F 6F 30         sub al, $30    ; make into integer
0318+  1291 22 00         mov ah, 0
0319+  1293 2A            mov b, [d]
0320+  1294 AC            mul a, b      ; result in B since it fits in 16bits
0321+  1295 11            mov a, b
0322+  1296 28            mov b, c
0323+  1297 54            add a, b
0324+  1298 39            mov c, a
0325+  1299 63 02 00      sub d, 2
0326+  129C 0A 89 12      jmp _strtoint_L0
0327+  129F             _strtoint_end:
0328+  129F 12            mov a, c
0329+  12A0 E7            pop d
0330+  12A1 E6            pop c
0331+  12A2 E5            pop b
0332+  12A3 EF            pop si
0333+  12A4 09            ret
0334+  12A5             
0335+  12A5             ;-----------------------------------------------------------------------------
0336+  12A5             ; PRINT NULL TERMINATED STRING
0337+  12A5             ; pointer in D
0338+  12A5             ;-----------------------------------------------------------------------------
0339+  12A5             _puts:
0340+  12A5 D7            push a
0341+  12A6 DA            push d
0342+  12A7             _puts_L1:
0343+  12A7 1E            mov al, [d]
0344+  12A8 B9 00         cmp al, 0
0345+  12AA C6 B6 12      jz _puts_END
0346+  12AD 23            mov ah, al
0347+  12AE 19 00         mov al, 0
0348+  12B0 05 03         syscall sys_io
0349+  12B2 79            inc d
0350+  12B3 0A A7 12      jmp _puts_L1
0351+  12B6             _puts_END:
0352+  12B6 E7            pop d
0353+  12B7 E4            pop a
0354+  12B8 09            ret
0355+  12B9             
0356+  12B9             ;-----------------------------------------------------------------------------
0357+  12B9             ; PRINT N SIZE STRING
0358+  12B9             ; pointer in D
0359+  12B9             ; size in C
0360+  12B9             ;-----------------------------------------------------------------------------
0361+  12B9             _putsn:
0362+  12B9 DB            push al
0363+  12BA DA            push d
0364+  12BB D9            push c
0365+  12BC             _putsn_L0:
0366+  12BC 1E            mov al, [d]
0367+  12BD 23            mov ah, al
0368+  12BE 19 00         mov al, 0
0369+  12C0 05 03         syscall sys_io
0370+  12C2 79            inc d
0371+  12C3 7E            dec c  
0372+  12C4 C2 00 00      cmp c, 0
0373+  12C7 C7 BC 12      jne _putsn_L0
0374+  12CA             _putsn_end:
0375+  12CA E6            pop c
0376+  12CB E7            pop d
0377+  12CC E8            pop al
0378+  12CD 09            ret
0379+  12CE             
0380+  12CE             ;-----------------------------------------------------------------------------
0381+  12CE             ; print 16bit decimal number
0382+  12CE             ; input number in A
0383+  12CE             ;-----------------------------------------------------------------------------
0384+  12CE             print_u16d:
0385+  12CE D7            push a
0386+  12CF D8            push b
0387+  12D0 26 10 27      mov b, 10000
0388+  12D3 AE            div a, b      ; get 10000's coeff.
0389+  12D4 07 F6 12      call print_number
0390+  12D7 11            mov a, b
0391+  12D8 26 E8 03      mov b, 1000
0392+  12DB AE            div a, b      ; get 1000's coeff.
0393+  12DC 07 F6 12      call print_number
0394+  12DF 11            mov a, b
0395+  12E0 26 64 00      mov b, 100
0396+  12E3 AE            div a, b
0397+  12E4 07 F6 12      call print_number
0398+  12E7 11            mov a, b
0399+  12E8 26 0A 00      mov b, 10
0400+  12EB AE            div a, b
0401+  12EC 07 F6 12      call print_number
0402+  12EF 1B            mov al, bl      ; 1's coeff in bl
0403+  12F0 07 F6 12      call print_number
0404+  12F3 E5            pop b
0405+  12F4 E4            pop a
0406+  12F5 09            ret
0407+  12F6             
0408+  12F6             ;-----------------------------------------------------------------------------
0409+  12F6             ; print AL
0410+  12F6             ;-----------------------------------------------------------------------------
0411+  12F6             print_number:
0412+  12F6 6A 30         add al, $30
0413+  12F8 23            mov ah, al
0414+  12F9 07 5B 11      call _putchar
0415+  12FC 09            ret
0416+  12FD             
0417+  12FD             ;-----------------------------------------------------------------------------
0418+  12FD             ; PRINT 16BIT HEX INTEGER
0419+  12FD             ; integer value in reg B
0420+  12FD             ;-----------------------------------------------------------------------------
0421+  12FD             print_u16x:
0422+  12FD D7            push a
0423+  12FE D8            push b
0424+  12FF DD            push bl
0425+  1300 30            mov bl, bh
0426+  1301 07 29 11      call _itoa        ; convert bh to char in A
0427+  1304 2F            mov bl, al        ; save al
0428+  1305 19 00         mov al, 0
0429+  1307 05 03         syscall sys_io        ; display AH
0430+  1309 24            mov ah, bl        ; retrieve al
0431+  130A 19 00         mov al, 0
0432+  130C 05 03         syscall sys_io        ; display AL
0433+  130E             
0434+  130E EA            pop bl
0435+  130F 07 29 11      call _itoa        ; convert bh to char in A
0436+  1312 2F            mov bl, al        ; save al
0437+  1313 19 00         mov al, 0
0438+  1315 05 03         syscall sys_io        ; display AH
0439+  1317 24            mov ah, bl        ; retrieve al
0440+  1318 19 00         mov al, 0
0441+  131A 05 03         syscall sys_io        ; display AL
0442+  131C             
0443+  131C E5            pop b
0444+  131D E4            pop a
0445+  131E 09            ret
0446+  131F             
0447+  131F             ;-----------------------------------------------------------------------------
0448+  131F             ; INPUT 16BIT HEX INTEGER
0449+  131F             ; read 16bit integer into A
0450+  131F             ;-----------------------------------------------------------------------------
0451+  131F             scan_u16x:
0452+  131F F8 10 00      enter 16
0453+  1322 D8            push b
0454+  1323 DA            push d
0455+  1324             
0456+  1324 FA F1 FF      lea d, [bp + -15]
0457+  1327 07 62 11      call _gets        ; get number
0458+  132A             
0459+  132A 32            mov bl, [d]
0460+  132B 37            mov bh, bl
0461+  132C 33 01 00      mov bl, [d + 1]
0462+  132F 07 19 11      call _atoi        ; convert to int in AL
0463+  1332 23            mov ah, al        ; move to AH
0464+  1333             
0465+  1333 33 02 00      mov bl, [d + 2]
0466+  1336 37            mov bh, bl
0467+  1337 33 03 00      mov bl, [d + 3]
0468+  133A 07 19 11      call _atoi        ; convert to int in AL
0469+  133D             
0470+  133D E7            pop d
0471+  133E E5            pop b
0472+  133F F9            leave
0473+  1340 09            ret
0474+  1341             
0475+  1341             ;-----------------------------------------------------------------------------
0476+  1341             ; PRINT 8bit HEX INTEGER
0477+  1341             ; integer value in reg bl
0478+  1341             ;-----------------------------------------------------------------------------
0479+  1341             print_u8x:
0480+  1341 D7            push a
0481+  1342 DD            push bl
0482+  1343             
0483+  1343 07 29 11      call _itoa        ; convert bl to char in A
0484+  1346 2F            mov bl, al        ; save al
0485+  1347 19 00         mov al, 0
0486+  1349 05 03         syscall sys_io        ; display AH
0487+  134B 24            mov ah, bl        ; retrieve al
0488+  134C 19 00         mov al, 0
0489+  134E 05 03         syscall sys_io        ; display AL
0490+  1350             
0491+  1350 EA            pop bl
0492+  1351 E4            pop a
0493+  1352 09            ret
0494+  1353             
0495+  1353             ;-----------------------------------------------------------------------------
0496+  1353             ; print 8bit decimal unsigned number
0497+  1353             ; input number in AL
0498+  1353             ;-----------------------------------------------------------------------------
0499+  1353             print_u8d:
0500+  1353 D7            push a
0501+  1354 D8            push b
0502+  1355             
0503+  1355 22 00         mov ah, 0
0504+  1357 26 64 00      mov b, 100
0505+  135A AE            div a, b
0506+  135B D8            push b      ; save remainder
0507+  135C B9 00         cmp al, 0
0508+  135E C6 68 13      je skip100
0509+  1361 6A 30         add al, $30
0510+  1363 23            mov ah, al
0511+  1364 19 00         mov al, 0
0512+  1366 05 03         syscall sys_io  ; print coeff
0513+  1368             skip100:
0514+  1368 E4            pop a
0515+  1369 22 00         mov ah, 0
0516+  136B 26 0A 00      mov b, 10
0517+  136E AE            div a, b
0518+  136F D8            push b      ; save remainder
0519+  1370 B9 00         cmp al, 0
0520+  1372 C6 7C 13      je skip10
0521+  1375 6A 30         add al, $30
0522+  1377 23            mov ah, al
0523+  1378 19 00         mov al, 0
0524+  137A 05 03         syscall sys_io  ; print coeff
0525+  137C             skip10:
0526+  137C E4            pop a
0527+  137D 1B            mov al, bl
0528+  137E 6A 30         add al, $30
0529+  1380 23            mov ah, al
0530+  1381 19 00         mov al, 0
0531+  1383 05 03         syscall sys_io  ; print coeff
0532+  1385 E5            pop b
0533+  1386 E4            pop a
0534+  1387 09            ret
0535+  1388             
0536+  1388             ;-----------------------------------------------------------------------------
0537+  1388             ; INPUT 8BIT HEX INTEGER
0538+  1388             ; read 8bit integer into AL
0539+  1388             ;-----------------------------------------------------------------------------
0540+  1388             scan_u8x:
0541+  1388 F8 04 00      enter 4
0542+  138B D8            push b
0543+  138C DA            push d
0544+  138D             
0545+  138D FA FD FF      lea d, [bp + -3]
0546+  1390 07 62 11      call _gets        ; get number
0547+  1393             
0548+  1393 32            mov bl, [d]
0549+  1394 37            mov bh, bl
0550+  1395 33 01 00      mov bl, [d + 1]
0551+  1398 07 19 11      call _atoi        ; convert to int in AL
0552+  139B             
0553+  139B E7            pop d
0554+  139C E5            pop b
0555+  139D F9            leave
0556+  139E 09            ret
0557+  139F             
0558+  139F             ;-----------------------------------------------------------------------------
0559+  139F             ; input decimal number
0560+  139F             ; result in A
0561+  139F             ; 655'\0'
0562+  139F             ; low--------high
0563+  139F             ;-----------------------------------------------------------------------------
0564+  139F             scan_u16d:
0565+  139F F8 08 00      enter 8
0566+  13A2 E2            push si
0567+  13A3 D8            push b
0568+  13A4 D9            push c
0569+  13A5 DA            push d
0570+  13A6 FA F9 FF      lea d, [bp +- 7]
0571+  13A9 07 62 11      call _gets
0572+  13AC 07 BB 10      call _strlen      ; get string length in C
0573+  13AF 7E            dec c
0574+  13B0 FD 4E         mov si, d
0575+  13B2 12            mov a, c
0576+  13B3 FD 99         shl a
0577+  13B5 3B F1 13      mov d, table_power
0578+  13B8 59            add d, a
0579+  13B9 38 00 00      mov c, 0
0580+  13BC             mul_loop:
0581+  13BC F6            lodsb      ; load ASCII to al
0582+  13BD B9 00         cmp al, 0
0583+  13BF C6 D2 13      je mul_exit
0584+  13C2 6F 30         sub al, $30    ; make into integer
0585+  13C4 22 00         mov ah, 0
0586+  13C6 2A            mov b, [d]
0587+  13C7 AC            mul a, b      ; result in B since it fits in 16bits
0588+  13C8 11            mov a, b
0589+  13C9 28            mov b, c
0590+  13CA 54            add a, b
0591+  13CB 39            mov c, a
0592+  13CC 63 02 00      sub d, 2
0593+  13CF 0A BC 13      jmp mul_loop
0594+  13D2             mul_exit:
0595+  13D2 12            mov a, c
0596+  13D3 E7            pop d
0597+  13D4 E6            pop c
0598+  13D5 E5            pop b
0599+  13D6 EF            pop si
0600+  13D7 F9            leave
0601+  13D8 09            ret
0602+  13D9             
0603+  13D9 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0603+  13DD 34 35 36 37 
0603+  13E1 38 39 41 42 
0603+  13E5 43 44 45 46 
0604+  13E9 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0604+  13ED 1B 5B 48 00 
0605+  13F1             
0606+  13F1             table_power:
0607+  13F1 01 00         .dw 1
0608+  13F3 0A 00         .dw 10
0609+  13F5 64 00         .dw 100
0610+  13F7 E8 03         .dw 1000
0611+  13F9 10 27         .dw 100002325   13FB             ; --- END INLINE ASM BLOCK
2326   13FB             
2327   13FB F9            leave
2328   13FC 09            ret
2329   13FD             
2330   13FD             test_globalvars:
2331   13FD F8 00 00      enter 0 ; (push bp; mov bp, sp)
2332   1400             ; $pass 
2333   1400 19 01         mov al, $1
2334   1402 40 00 00      mov [bp + 0], al
2335   1405 52 01 00      sub sp, 1
2336   1408             ;; c0 = 'A'; 
2337   1408 3B 35 14      mov d, _c0 ; $c0
2338   140B DA            push d
2339   140C 26 41 00      mov b, $41
2340   140F E7            pop d
2341   1410 FD 3E         mov [d], bl
2342   1412             ;; pass = pass && c0 == 'A'; 
2343   1412 FA 00 00      lea d, [bp + 0] ; $pass
2344   1415 DA            push d
2345   1416 FA 00 00      lea d, [bp + 0] ; $pass
2346   1419 32            mov bl, [d]
2347   141A A7 00         mov bh, 0
2348   141C D7            push a
2349   141D 11            mov a, b
2350   141E 3B 35 14      mov d, _c0 ; $c0
2351   1421 32            mov bl, [d]
2352   1422 A7 00         mov bh, 0
2353   1424             ; START RELATIONAL
2354   1424 D7            push a
2355   1425 11            mov a, b
2356   1426 26 41 00      mov b, $41
2357   1429 B0            cmp a, b
2358   142A FD 71         seq ; ==
2359   142C E4            pop a
2360   142D             ; END RELATIONAL
2361   142D FD A7         sand a, b ; &&
2362   142F E4            pop a
2363   1430 E7            pop d
2364   1431 FD 3E         mov [d], bl
2365   1433 F9            leave
2366   1434 09            ret
2367   1435             ; --- END TEXT BLOCK
2368   1435             
2369   1435             ; --- BEGIN DATA BLOCK
2370   1435 00          _c0: .fill 1, 0
2371   1436 00 00       _i0: .fill 2, 0
2372   1438 00 00       _c_array0_data: .fill 2, 0
2373   143A 00 00 00 00 _i_array0_data: .fill 4, 0
2374   143E 00 00 00 00 _cp_array0_data: .fill 4, 0
2375   1442 00 00 00 00 _ip_array0_data: .fill 4, 0
2376   1446 00 00 00 00 _cpp_array0_data: .fill 4, 0
2377   144A 00 00 00 00 _ipp_array0_data: .fill 4, 0
2378   144E 00 00 00 00 _cc_array0_data: .fill 4, 0
2379   1452 00 00 00 00 _ii_array0_data: .fill 8, 0
2379   1456 00 00 00 00 
2380   145A 00 00 00 00 _ccp_array0_data: .fill 8, 0
2380   145E 00 00 00 00 
2381   1462 00 00 00 00 _iip_array0_data: .fill 8, 0
2381   1466 00 00 00 00 
2382   146A 00 00 00 00 _ccpp_array0_data: .fill 8, 0
2382   146E 00 00 00 00 
2383   1472 00 00 00 00 _iipp_array0_data: .fill 8, 0
2383   1476 00 00 00 00 
2384   147A 00 00 00 00 _st0_data: .fill 69, 0
2384   147E 00 00 00 00 
2384   1482 00 00 00 00 
2384   1486 00 00 00 00 
2384   148A 00 00 00 00 
2384   148E 00 00 00 00 
2384   1492 00 00 00 00 
2384   1496 00 00 00 00 
2384   149A 00 00 00 00 
2384   149E 00 00 00 00 
2384   14A2 00 00 00 00 
2384   14A6 00 00 00 00 
2384   14AA 00 00 00 00 
2384   14AE 00 00 00 00 
2384   14B2 00 00 00 00 
2384   14B6 00 00 00 00 
2384   14BA 00 00 00 00 
2384   14BE 00 
2385   14BF 55 6E 65 78 __s0: .db "Unexpected format in printf.", 0
2385   14C3 70 65 63 74 
2385   14C7 65 64 20 66 
2385   14CB 6F 72 6D 61 
2385   14CF 74 20 69 6E 
2385   14D3 20 70 72 69 
2385   14D7 6E 74 66 2E 
2385   14DB 00 
2386   14DC 45 72 72 6F __s1: .db "Error: Unknown argument type.\n", 0
2386   14E0 72 3A 20 55 
2386   14E4 6E 6B 6E 6F 
2386   14E8 77 6E 20 61 
2386   14EC 72 67 75 6D 
2386   14F0 65 6E 74 20 
2386   14F4 74 79 70 65 
2386   14F8 2E 0A 00 
2387   14FB 1B 5B 32 4A __s2: .db "\033[2J\033[H", 0
2387   14FF 1B 5B 48 00 
2388   1503             
2389   1503 05 15       _heap_top: .dw _heap
2390   1505 00          _heap: .db 0
2391   1506             ; --- END DATA BLOCK
2392   1506             
2393   1506             .end
tasm: Number of errors = 0
