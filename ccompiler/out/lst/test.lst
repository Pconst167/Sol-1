0001   0000             ; --- FILENAME: test
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; $i 
0011   0408             ; $j 
0012   0408 52 04 00      sub sp, 4
0013   040B             ;; i + j + (i&&j); 
0014   040B FA FF FF      lea d, [bp + -1] ; $i
0015   040E 2A            mov b, [d]
0016   040F             ; START TERMS
0017   040F D7            push a
0018   0410 11            mov a, b
0019   0411 FA FD FF      lea d, [bp + -3] ; $j
0020   0414 2A            mov b, [d]
0021   0415 54            add a, b
0022   0416 11            mov a, b
0023   0417 FA FF FF      lea d, [bp + -1] ; $i
0024   041A 2A            mov b, [d]
0025   041B D7            push a
0026   041C 11            mov a, b
0027   041D FA FD FF      lea d, [bp + -3] ; $j
0028   0420 2A            mov b, [d]
0029   0421 FD A7         sand a, b ; &&
0030   0423 E4            pop a
0031   0424 54            add a, b
0032   0425 27            mov b, a
0033   0426 E4            pop a
0034   0427             ; END TERMS
0035   0427 05 0B         syscall sys_terminate_proc
0036   0429             
0037   0429             strcpy:
0038   0429 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0039   042C             ; $psrc 
0040   042C             ; $pdest 
0041   042C 52 04 00      sub sp, 4
0042   042F             ;; psrc = src; 
0043   042F FA FF FF      lea d, [bp + -1] ; $psrc
0044   0432 DA            push d
0045   0433 FA 07 00      lea d, [bp + 7] ; $src
0046   0436 2A            mov b, [d]
0047   0437 E7            pop d
0048   0438 FD 43         mov [d], b
0049   043A             ;; pdest = dest; 
0050   043A FA FD FF      lea d, [bp + -3] ; $pdest
0051   043D DA            push d
0052   043E FA 05 00      lea d, [bp + 5] ; $dest
0053   0441 2A            mov b, [d]
0054   0442 E7            pop d
0055   0443 FD 43         mov [d], b
0056   0445             ;; while(*psrc) *pdest++ = *psrc++; 
0057   0445             _while1_cond:
0058   0445 FA FF FF      lea d, [bp + -1] ; $psrc
0059   0448 2A            mov b, [d]
0060   0449 74            mov d, b
0061   044A 32            mov bl, [d]
0062   044B A7 00         mov bh, 0
0063   044D C0 00 00      cmp b, 0
0064   0450 C6 78 04      je _while1_exit
0065   0453             _while1_block:
0066   0453             ;; *pdest++ = *psrc++; 
0067   0453 FA FD FF      lea d, [bp + -3] ; $pdest
0068   0456 2A            mov b, [d]
0069   0457 D8            push b
0070   0458 FD 77         inc b
0071   045A FA FD FF      lea d, [bp + -3] ; $pdest
0072   045D FD 43         mov [d], b
0073   045F E5            pop b
0074   0460 D8            push b
0075   0461 FA FF FF      lea d, [bp + -1] ; $psrc
0076   0464 2A            mov b, [d]
0077   0465 D8            push b
0078   0466 FD 77         inc b
0079   0468 FA FF FF      lea d, [bp + -1] ; $psrc
0080   046B FD 43         mov [d], b
0081   046D E5            pop b
0082   046E 74            mov d, b
0083   046F 32            mov bl, [d]
0084   0470 A7 00         mov bh, 0
0085   0472 E7            pop d
0086   0473 FD 3E         mov [d], bl
0087   0475 0A 45 04      jmp _while1_cond
0088   0478             _while1_exit:
0089   0478             ;; *pdest = '\0'; 
0090   0478 FA FD FF      lea d, [bp + -3] ; $pdest
0091   047B 2A            mov b, [d]
0092   047C D8            push b
0093   047D 26 00 00      mov b, $0
0094   0480 E7            pop d
0095   0481 FD 3E         mov [d], bl
0096   0483 F9            leave
0097   0484 09            ret
0098   0485             
0099   0485             strcmp:
0100   0485 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0101   0488             ;; while (*s1 && (*s1 == *s2)) { 
0102   0488             _while2_cond:
0103   0488 FA 05 00      lea d, [bp + 5] ; $s1
0104   048B 2A            mov b, [d]
0105   048C 74            mov d, b
0106   048D 32            mov bl, [d]
0107   048E A7 00         mov bh, 0
0108   0490 D7            push a
0109   0491 11            mov a, b
0110   0492 FA 05 00      lea d, [bp + 5] ; $s1
0111   0495 2A            mov b, [d]
0112   0496 74            mov d, b
0113   0497 32            mov bl, [d]
0114   0498 A7 00         mov bh, 0
0115   049A             ; START RELATIONAL
0116   049A D7            push a
0117   049B 11            mov a, b
0118   049C FA 07 00      lea d, [bp + 7] ; $s2
0119   049F 2A            mov b, [d]
0120   04A0 74            mov d, b
0121   04A1 32            mov bl, [d]
0122   04A2 A7 00         mov bh, 0
0123   04A4 B0            cmp a, b
0124   04A5 FD 71         seq ; ==
0125   04A7 E4            pop a
0126   04A8             ; END RELATIONAL
0127   04A8 FD A7         sand a, b ; &&
0128   04AA E4            pop a
0129   04AB C0 00 00      cmp b, 0
0130   04AE C6 CE 04      je _while2_exit
0131   04B1             _while2_block:
0132   04B1             ;; s1++; 
0133   04B1 FA 05 00      lea d, [bp + 5] ; $s1
0134   04B4 2A            mov b, [d]
0135   04B5 D8            push b
0136   04B6 FD 77         inc b
0137   04B8 FA 05 00      lea d, [bp + 5] ; $s1
0138   04BB FD 43         mov [d], b
0139   04BD E5            pop b
0140   04BE             ;; s2++; 
0141   04BE FA 07 00      lea d, [bp + 7] ; $s2
0142   04C1 2A            mov b, [d]
0143   04C2 D8            push b
0144   04C3 FD 77         inc b
0145   04C5 FA 07 00      lea d, [bp + 7] ; $s2
0146   04C8 FD 43         mov [d], b
0147   04CA E5            pop b
0148   04CB 0A 88 04      jmp _while2_cond
0149   04CE             _while2_exit:
0150   04CE             ;; return *s1 - *s2; 
0151   04CE FA 05 00      lea d, [bp + 5] ; $s1
0152   04D1 2A            mov b, [d]
0153   04D2 74            mov d, b
0154   04D3 32            mov bl, [d]
0155   04D4 A7 00         mov bh, 0
0156   04D6             ; START TERMS
0157   04D6 D7            push a
0158   04D7 11            mov a, b
0159   04D8 FA 07 00      lea d, [bp + 7] ; $s2
0160   04DB 2A            mov b, [d]
0161   04DC 74            mov d, b
0162   04DD 32            mov bl, [d]
0163   04DE A7 00         mov bh, 0
0164   04E0 60            sub a, b
0165   04E1 27            mov b, a
0166   04E2 E4            pop a
0167   04E3             ; END TERMS
0168   04E3 F9            leave
0169   04E4 09            ret
0170   04E5             
0171   04E5             strcat:
0172   04E5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0173   04E8             ; $dest_len 
0174   04E8             ; $i 
0175   04E8 52 04 00      sub sp, 4
0176   04EB             ;; dest_len = strlen(dest); 
0177   04EB FA FF FF      lea d, [bp + -1] ; $dest_len
0178   04EE DA            push d
0179   04EF FA 05 00      lea d, [bp + 5] ; $dest
0180   04F2 2A            mov b, [d]
0181   04F3 FD AB         swp b
0182   04F5 D8            push b
0183   04F6 07 9B 05      call strlen
0184   04F9 51 02 00      add sp, 2
0185   04FC E7            pop d
0186   04FD FD 43         mov [d], b
0187   04FF             ;; for (i = 0; src[i] != 0; i=i+1) { 
0188   04FF             _for3_init:
0189   04FF FA FD FF      lea d, [bp + -3] ; $i
0190   0502 DA            push d
0191   0503 26 00 00      mov b, $0
0192   0506 E7            pop d
0193   0507 FD 43         mov [d], b
0194   0509             _for3_cond:
0195   0509 FA 07 00      lea d, [bp + 7] ; $src
0196   050C FD 2A         mov d, [d]
0197   050E D7            push a
0198   050F DA            push d
0199   0510 FA FD FF      lea d, [bp + -3] ; $i
0200   0513 2A            mov b, [d]
0201   0514 E7            pop d
0202   0515 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0203   0519 E4            pop a
0204   051A 32            mov bl, [d]
0205   051B A7 00         mov bh, 0
0206   051D             ; START RELATIONAL
0207   051D D7            push a
0208   051E 11            mov a, b
0209   051F 26 00 00      mov b, $0
0210   0522 B0            cmp a, b
0211   0523 FD 72         sneq ; !=
0212   0525 E4            pop a
0213   0526             ; END RELATIONAL
0214   0526 C0 00 00      cmp b, 0
0215   0529 C6 74 05      je _for3_exit
0216   052C             _for3_block:
0217   052C             ;; dest[dest_len + i] = src[i]; 
0218   052C FA 05 00      lea d, [bp + 5] ; $dest
0219   052F FD 2A         mov d, [d]
0220   0531 D7            push a
0221   0532 DA            push d
0222   0533 FA FF FF      lea d, [bp + -1] ; $dest_len
0223   0536 2A            mov b, [d]
0224   0537             ; START TERMS
0225   0537 D7            push a
0226   0538 11            mov a, b
0227   0539 FA FD FF      lea d, [bp + -3] ; $i
0228   053C 2A            mov b, [d]
0229   053D 54            add a, b
0230   053E 27            mov b, a
0231   053F E4            pop a
0232   0540             ; END TERMS
0233   0540 E7            pop d
0234   0541 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0235   0545 E4            pop a
0236   0546 DA            push d
0237   0547 FA 07 00      lea d, [bp + 7] ; $src
0238   054A FD 2A         mov d, [d]
0239   054C D7            push a
0240   054D DA            push d
0241   054E FA FD FF      lea d, [bp + -3] ; $i
0242   0551 2A            mov b, [d]
0243   0552 E7            pop d
0244   0553 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0245   0557 E4            pop a
0246   0558 32            mov bl, [d]
0247   0559 A7 00         mov bh, 0
0248   055B E7            pop d
0249   055C FD 3E         mov [d], bl
0250   055E             _for3_update:
0251   055E FA FD FF      lea d, [bp + -3] ; $i
0252   0561 DA            push d
0253   0562 FA FD FF      lea d, [bp + -3] ; $i
0254   0565 2A            mov b, [d]
0255   0566             ; START TERMS
0256   0566 D7            push a
0257   0567 11            mov a, b
0258   0568 26 01 00      mov b, $1
0259   056B 54            add a, b
0260   056C 27            mov b, a
0261   056D E4            pop a
0262   056E             ; END TERMS
0263   056E E7            pop d
0264   056F FD 43         mov [d], b
0265   0571 0A 09 05      jmp _for3_cond
0266   0574             _for3_exit:
0267   0574             ;; dest[dest_len + i] = 0; 
0268   0574 FA 05 00      lea d, [bp + 5] ; $dest
0269   0577 FD 2A         mov d, [d]
0270   0579 D7            push a
0271   057A DA            push d
0272   057B FA FF FF      lea d, [bp + -1] ; $dest_len
0273   057E 2A            mov b, [d]
0274   057F             ; START TERMS
0275   057F D7            push a
0276   0580 11            mov a, b
0277   0581 FA FD FF      lea d, [bp + -3] ; $i
0278   0584 2A            mov b, [d]
0279   0585 54            add a, b
0280   0586 27            mov b, a
0281   0587 E4            pop a
0282   0588             ; END TERMS
0283   0588 E7            pop d
0284   0589 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0285   058D E4            pop a
0286   058E DA            push d
0287   058F 26 00 00      mov b, $0
0288   0592 E7            pop d
0289   0593 FD 3E         mov [d], bl
0290   0595             ;; return dest; 
0291   0595 FA 05 00      lea d, [bp + 5] ; $dest
0292   0598 2A            mov b, [d]
0293   0599 F9            leave
0294   059A 09            ret
0295   059B             
0296   059B             strlen:
0297   059B F8 00 00      enter 0 ; (push bp; mov bp, sp)
0298   059E             ; $length 
0299   059E 52 02 00      sub sp, 2
0300   05A1             ;; length = 0; 
0301   05A1 FA FF FF      lea d, [bp + -1] ; $length
0302   05A4 DA            push d
0303   05A5 26 00 00      mov b, $0
0304   05A8 E7            pop d
0305   05A9 FD 43         mov [d], b
0306   05AB             ;; while (str[length] != 0) { 
0307   05AB             _while4_cond:
0308   05AB FA 05 00      lea d, [bp + 5] ; $str
0309   05AE FD 2A         mov d, [d]
0310   05B0 D7            push a
0311   05B1 DA            push d
0312   05B2 FA FF FF      lea d, [bp + -1] ; $length
0313   05B5 2A            mov b, [d]
0314   05B6 E7            pop d
0315   05B7 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0316   05BB E4            pop a
0317   05BC 32            mov bl, [d]
0318   05BD A7 00         mov bh, 0
0319   05BF             ; START RELATIONAL
0320   05BF D7            push a
0321   05C0 11            mov a, b
0322   05C1 26 00 00      mov b, $0
0323   05C4 B0            cmp a, b
0324   05C5 FD 72         sneq ; !=
0325   05C7 E4            pop a
0326   05C8             ; END RELATIONAL
0327   05C8 C0 00 00      cmp b, 0
0328   05CB C6 DE 05      je _while4_exit
0329   05CE             _while4_block:
0330   05CE             ;; length++; 
0331   05CE FA FF FF      lea d, [bp + -1] ; $length
0332   05D1 2A            mov b, [d]
0333   05D2 D8            push b
0334   05D3 FD 77         inc b
0335   05D5 FA FF FF      lea d, [bp + -1] ; $length
0336   05D8 FD 43         mov [d], b
0337   05DA E5            pop b
0338   05DB 0A AB 05      jmp _while4_cond
0339   05DE             _while4_exit:
0340   05DE             ;; return length; 
0341   05DE FA FF FF      lea d, [bp + -1] ; $length
0342   05E1 2A            mov b, [d]
0343   05E2 F9            leave
0344   05E3 09            ret
0345   05E4             
0346   05E4             exit:
0347   05E4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0348   05E7             
0349   05E7             ; --- BEGIN INLINE ASM BLOCK
0350   05E7 05 0B         syscall sys_terminate_proc
0351   05E9             ; --- END INLINE ASM BLOCK
0352   05E9             
0353   05E9 F9            leave
0354   05EA 09            ret
0355   05EB             
0356   05EB             atoi:
0357   05EB F8 00 00      enter 0 ; (push bp; mov bp, sp)
0358   05EE             ; $result 
0359   05EE 10 00 00      mov a, $0
0360   05F1 45 FF FF      mov [bp + -1], a
0361   05F4             ; $sign 
0362   05F4 10 01 00      mov a, $1
0363   05F7 45 FD FF      mov [bp + -3], a
0364   05FA 52 04 00      sub sp, 4
0365   05FD             ;; while (*str == ' ') str++; 
0366   05FD             _while5_cond:
0367   05FD FA 05 00      lea d, [bp + 5] ; $str
0368   0600 2A            mov b, [d]
0369   0601 74            mov d, b
0370   0602 32            mov bl, [d]
0371   0603 A7 00         mov bh, 0
0372   0605             ; START RELATIONAL
0373   0605 D7            push a
0374   0606 11            mov a, b
0375   0607 26 20 00      mov b, $20
0376   060A B0            cmp a, b
0377   060B FD 71         seq ; ==
0378   060D E4            pop a
0379   060E             ; END RELATIONAL
0380   060E C0 00 00      cmp b, 0
0381   0611 C6 24 06      je _while5_exit
0382   0614             _while5_block:
0383   0614             ;; str++; 
0384   0614 FA 05 00      lea d, [bp + 5] ; $str
0385   0617 2A            mov b, [d]
0386   0618 D8            push b
0387   0619 FD 77         inc b
0388   061B FA 05 00      lea d, [bp + 5] ; $str
0389   061E FD 43         mov [d], b
0390   0620 E5            pop b
0391   0621 0A FD 05      jmp _while5_cond
0392   0624             _while5_exit:
0393   0624             ;; if (*str == '-' || *str == '+') { 
0394   0624             _if6_cond:
0395   0624 FA 05 00      lea d, [bp + 5] ; $str
0396   0627 2A            mov b, [d]
0397   0628 74            mov d, b
0398   0629 32            mov bl, [d]
0399   062A A7 00         mov bh, 0
0400   062C             ; START RELATIONAL
0401   062C D7            push a
0402   062D 11            mov a, b
0403   062E 26 2D 00      mov b, $2d
0404   0631 B0            cmp a, b
0405   0632 FD 71         seq ; ==
0406   0634 E4            pop a
0407   0635             ; END RELATIONAL
0408   0635 D7            push a
0409   0636 11            mov a, b
0410   0637 FA 05 00      lea d, [bp + 5] ; $str
0411   063A 2A            mov b, [d]
0412   063B 74            mov d, b
0413   063C 32            mov bl, [d]
0414   063D A7 00         mov bh, 0
0415   063F             ; START RELATIONAL
0416   063F D7            push a
0417   0640 11            mov a, b
0418   0641 26 2B 00      mov b, $2b
0419   0644 B0            cmp a, b
0420   0645 FD 71         seq ; ==
0421   0647 E4            pop a
0422   0648             ; END RELATIONAL
0423   0648 FD A8         sor a, b ; ||
0424   064A E4            pop a
0425   064B C0 00 00      cmp b, 0
0426   064E C6 85 06      je _if6_exit
0427   0651             _if6_true:
0428   0651             ;; if (*str == '-') sign = -1; 
0429   0651             _if7_cond:
0430   0651 FA 05 00      lea d, [bp + 5] ; $str
0431   0654 2A            mov b, [d]
0432   0655 74            mov d, b
0433   0656 32            mov bl, [d]
0434   0657 A7 00         mov bh, 0
0435   0659             ; START RELATIONAL
0436   0659 D7            push a
0437   065A 11            mov a, b
0438   065B 26 2D 00      mov b, $2d
0439   065E B0            cmp a, b
0440   065F FD 71         seq ; ==
0441   0661 E4            pop a
0442   0662             ; END RELATIONAL
0443   0662 C0 00 00      cmp b, 0
0444   0665 C6 75 06      je _if7_exit
0445   0668             _if7_true:
0446   0668             ;; sign = -1; 
0447   0668 FA FD FF      lea d, [bp + -3] ; $sign
0448   066B DA            push d
0449   066C 26 FF FF      mov b, $ffff
0450   066F E7            pop d
0451   0670 FD 43         mov [d], b
0452   0672 0A 75 06      jmp _if7_exit
0453   0675             _if7_exit:
0454   0675             ;; str++; 
0455   0675 FA 05 00      lea d, [bp + 5] ; $str
0456   0678 2A            mov b, [d]
0457   0679 D8            push b
0458   067A FD 77         inc b
0459   067C FA 05 00      lea d, [bp + 5] ; $str
0460   067F FD 43         mov [d], b
0461   0681 E5            pop b
0462   0682 0A 85 06      jmp _if6_exit
0463   0685             _if6_exit:
0464   0685             ;; while (*str >= '0' && *str <= '9') { 
0465   0685             _while8_cond:
0466   0685 FA 05 00      lea d, [bp + 5] ; $str
0467   0688 2A            mov b, [d]
0468   0689 74            mov d, b
0469   068A 32            mov bl, [d]
0470   068B A7 00         mov bh, 0
0471   068D             ; START RELATIONAL
0472   068D D7            push a
0473   068E 11            mov a, b
0474   068F 26 30 00      mov b, $30
0475   0692 B0            cmp a, b
0476   0693 FD 82         sgeu ; >= (unsigned)
0477   0695 E4            pop a
0478   0696             ; END RELATIONAL
0479   0696 D7            push a
0480   0697 11            mov a, b
0481   0698 FA 05 00      lea d, [bp + 5] ; $str
0482   069B 2A            mov b, [d]
0483   069C 74            mov d, b
0484   069D 32            mov bl, [d]
0485   069E A7 00         mov bh, 0
0486   06A0             ; START RELATIONAL
0487   06A0 D7            push a
0488   06A1 11            mov a, b
0489   06A2 26 39 00      mov b, $39
0490   06A5 B0            cmp a, b
0491   06A6 FD 76         sleu ; <= (unsigned)
0492   06A8 E4            pop a
0493   06A9             ; END RELATIONAL
0494   06A9 FD A7         sand a, b ; &&
0495   06AB E4            pop a
0496   06AC C0 00 00      cmp b, 0
0497   06AF C6 EB 06      je _while8_exit
0498   06B2             _while8_block:
0499   06B2             ;; result = result * 10 + (*str - '0'); 
0500   06B2 FA FF FF      lea d, [bp + -1] ; $result
0501   06B5 DA            push d
0502   06B6 FA FF FF      lea d, [bp + -1] ; $result
0503   06B9 2A            mov b, [d]
0504   06BA             ; START FACTORS
0505   06BA D7            push a
0506   06BB 11            mov a, b
0507   06BC 26 0A 00      mov b, $a
0508   06BF AC            mul a, b ; *
0509   06C0 11            mov a, b
0510   06C1 27            mov b, a
0511   06C2 E4            pop a
0512   06C3             ; END FACTORS
0513   06C3             ; START TERMS
0514   06C3 D7            push a
0515   06C4 11            mov a, b
0516   06C5 FA 05 00      lea d, [bp + 5] ; $str
0517   06C8 2A            mov b, [d]
0518   06C9 74            mov d, b
0519   06CA 32            mov bl, [d]
0520   06CB A7 00         mov bh, 0
0521   06CD             ; START TERMS
0522   06CD D7            push a
0523   06CE 11            mov a, b
0524   06CF 26 30 00      mov b, $30
0525   06D2 60            sub a, b
0526   06D3 27            mov b, a
0527   06D4 E4            pop a
0528   06D5             ; END TERMS
0529   06D5 54            add a, b
0530   06D6 27            mov b, a
0531   06D7 E4            pop a
0532   06D8             ; END TERMS
0533   06D8 E7            pop d
0534   06D9 FD 43         mov [d], b
0535   06DB             ;; str++; 
0536   06DB FA 05 00      lea d, [bp + 5] ; $str
0537   06DE 2A            mov b, [d]
0538   06DF D8            push b
0539   06E0 FD 77         inc b
0540   06E2 FA 05 00      lea d, [bp + 5] ; $str
0541   06E5 FD 43         mov [d], b
0542   06E7 E5            pop b
0543   06E8 0A 85 06      jmp _while8_cond
0544   06EB             _while8_exit:
0545   06EB             ;; return sign * result; 
0546   06EB FA FD FF      lea d, [bp + -3] ; $sign
0547   06EE 2A            mov b, [d]
0548   06EF             ; START FACTORS
0549   06EF D7            push a
0550   06F0 11            mov a, b
0551   06F1 FA FF FF      lea d, [bp + -1] ; $result
0552   06F4 2A            mov b, [d]
0553   06F5 AC            mul a, b ; *
0554   06F6 11            mov a, b
0555   06F7 27            mov b, a
0556   06F8 E4            pop a
0557   06F9             ; END FACTORS
0558   06F9 F9            leave
0559   06FA 09            ret
0560   06FB             
0561   06FB             rand:
0562   06FB F8 00 00      enter 0 ; (push bp; mov bp, sp)
0563   06FE             ; $sec 
0564   06FE 52 02 00      sub sp, 2
0565   0701             
0566   0701             ; --- BEGIN INLINE ASM BLOCK
0567   0701 19 00         mov al, 0
0568   0703 05 01         syscall sys_rtc					
0569   0705 1A            mov al, ah
0570   0706 FA FF FF      lea d, [bp + -1] ; $sec
0571   0709 1E            mov al, [d]
0572   070A 22 00         mov ah, 0
0573   070C             ; --- END INLINE ASM BLOCK
0574   070C             
0575   070C             ;; return sec; 
0576   070C FA FF FF      lea d, [bp + -1] ; $sec
0577   070F 2A            mov b, [d]
0578   0710 F9            leave
0579   0711 09            ret
0580   0712             
0581   0712             srand:
0582   0712 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0583   0715 F9            leave
0584   0716 09            ret
0585   0717             
0586   0717             malloc:
0587   0717 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0588   071A F9            leave
0589   071B 09            ret
0590   071C             
0591   071C             calloc:
0592   071C F8 00 00      enter 0 ; (push bp; mov bp, sp)
0593   071F F9            leave
0594   0720 09            ret
0595   0721             
0596   0721             realloc:
0597   0721 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0598   0724 F9            leave
0599   0725 09            ret
0600   0726             
0601   0726             alloc:
0602   0726 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0603   0729             ;; heap_top = heap_top + bytes; 
0604   0729 3B 94 14      mov d, _heap_top ; $heap_top
0605   072C DA            push d
0606   072D 3B 94 14      mov d, _heap_top ; $heap_top
0607   0730 2A            mov b, [d]
0608   0731             ; START TERMS
0609   0731 D7            push a
0610   0732 11            mov a, b
0611   0733 FA 05 00      lea d, [bp + 5] ; $bytes
0612   0736 2A            mov b, [d]
0613   0737 54            add a, b
0614   0738 27            mov b, a
0615   0739 E4            pop a
0616   073A             ; END TERMS
0617   073A E7            pop d
0618   073B FD 43         mov [d], b
0619   073D             ;; return heap_top - bytes; 
0620   073D 3B 94 14      mov d, _heap_top ; $heap_top
0621   0740 2A            mov b, [d]
0622   0741             ; START TERMS
0623   0741 D7            push a
0624   0742 11            mov a, b
0625   0743 FA 05 00      lea d, [bp + 5] ; $bytes
0626   0746 2A            mov b, [d]
0627   0747 60            sub a, b
0628   0748 27            mov b, a
0629   0749 E4            pop a
0630   074A             ; END TERMS
0631   074A F9            leave
0632   074B 09            ret
0633   074C             
0634   074C             free:
0635   074C F8 00 00      enter 0 ; (push bp; mov bp, sp)
0636   074F             ;; return heap_top = heap_top - bytes; 
0637   074F 3B 94 14      mov d, _heap_top ; $heap_top
0638   0752 DA            push d
0639   0753 3B 94 14      mov d, _heap_top ; $heap_top
0640   0756 2A            mov b, [d]
0641   0757             ; START TERMS
0642   0757 D7            push a
0643   0758 11            mov a, b
0644   0759 FA 05 00      lea d, [bp + 5] ; $bytes
0645   075C 2A            mov b, [d]
0646   075D 60            sub a, b
0647   075E 27            mov b, a
0648   075F E4            pop a
0649   0760             ; END TERMS
0650   0760 E7            pop d
0651   0761 FD 43         mov [d], b
0652   0763 F9            leave
0653   0764 09            ret
0654   0765             
0655   0765             va_start:
0656   0765 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0657   0768             ;; argp->current_arg = first_fixed_param + sizeof(first_fixed_param); 
0658   0768 FA 05 00      lea d, [bp + 5] ; $argp
0659   076B FD 2A         mov d, [d]
0660   076D 58 00 00      add d, 0
0661   0770 DA            push d
0662   0771 FA 07 00      lea d, [bp + 7] ; $first_fixed_param
0663   0774 2A            mov b, [d]
0664   0775             ; START TERMS
0665   0775 D7            push a
0666   0776 11            mov a, b
0667   0777 26 02 00      mov b, 2
0668   077A 54            add a, b
0669   077B 27            mov b, a
0670   077C E4            pop a
0671   077D             ; END TERMS
0672   077D E7            pop d
0673   077E FD 43         mov [d], b
0674   0780 F9            leave
0675   0781 09            ret
0676   0782             
0677   0782             va_arg:
0678   0782 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0679   0785             ; $p 
0680   0785 52 02 00      sub sp, 2
0681   0788             ;; p = argp->current_arg; 
0682   0788 FA FF FF      lea d, [bp + -1] ; $p
0683   078B DA            push d
0684   078C FA 05 00      lea d, [bp + 5] ; $argp
0685   078F FD 2A         mov d, [d]
0686   0791 58 00 00      add d, 0
0687   0794 2A            mov b, [d]
0688   0795 E7            pop d
0689   0796 FD 43         mov [d], b
0690   0798             ;; argp->current_arg = argp->current_arg + size; 
0691   0798 FA 05 00      lea d, [bp + 5] ; $argp
0692   079B FD 2A         mov d, [d]
0693   079D 58 00 00      add d, 0
0694   07A0 DA            push d
0695   07A1 FA 05 00      lea d, [bp + 5] ; $argp
0696   07A4 FD 2A         mov d, [d]
0697   07A6 58 00 00      add d, 0
0698   07A9 2A            mov b, [d]
0699   07AA             ; START TERMS
0700   07AA D7            push a
0701   07AB 11            mov a, b
0702   07AC FA 07 00      lea d, [bp + 7] ; $size
0703   07AF 2A            mov b, [d]
0704   07B0 54            add a, b
0705   07B1 27            mov b, a
0706   07B2 E4            pop a
0707   07B3             ; END TERMS
0708   07B3 E7            pop d
0709   07B4 FD 43         mov [d], b
0710   07B6             ;; return p; 
0711   07B6 FA FF FF      lea d, [bp + -1] ; $p
0712   07B9 2A            mov b, [d]
0713   07BA F9            leave
0714   07BB 09            ret
0715   07BC             
0716   07BC             va_end:
0717   07BC F8 00 00      enter 0 ; (push bp; mov bp, sp)
0718   07BF             ;; argp->current_arg =   0   ; 
0719   07BF FA 05 00      lea d, [bp + 5] ; $argp
0720   07C2 FD 2A         mov d, [d]
0721   07C4 58 00 00      add d, 0
0722   07C7 DA            push d
0723   07C8 26 00 00      mov b, $0
0724   07CB E7            pop d
0725   07CC FD 43         mov [d], b
0726   07CE F9            leave
0727   07CF 09            ret
0728   07D0             
0729   07D0             printf:
0730   07D0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0731   07D3             ; $p 
0732   07D3             ; $fp 
0733   07D3             ; $i 
0734   07D3 52 06 00      sub sp, 6
0735   07D6             ;; fp = format; 
0736   07D6 FA FD FF      lea d, [bp + -3] ; $fp
0737   07D9 DA            push d
0738   07DA FA 05 00      lea d, [bp + 5] ; $format
0739   07DD 2A            mov b, [d]
0740   07DE E7            pop d
0741   07DF FD 43         mov [d], b
0742   07E1             ;; p = &format + 2; 
0743   07E1 FA FF FF      lea d, [bp + -1] ; $p
0744   07E4 DA            push d
0745   07E5 FA 05 00      lea d, [bp + 5] ; $format
0746   07E8 2D            mov b, d
0747   07E9             ; START TERMS
0748   07E9 D7            push a
0749   07EA 11            mov a, b
0750   07EB 26 02 00      mov b, $2
0751   07EE 54            add a, b
0752   07EF 27            mov b, a
0753   07F0 E4            pop a
0754   07F1             ; END TERMS
0755   07F1 E7            pop d
0756   07F2 FD 43         mov [d], b
0757   07F4             ;; for(;;){ 
0758   07F4             _for9_init:
0759   07F4             _for9_cond:
0760   07F4             _for9_block:
0761   07F4             ;; if(!*fp) break; 
0762   07F4             _if10_cond:
0763   07F4 FA FD FF      lea d, [bp + -3] ; $fp
0764   07F7 2A            mov b, [d]
0765   07F8 74            mov d, b
0766   07F9 32            mov bl, [d]
0767   07FA A7 00         mov bh, 0
0768   07FC C0 00 00      cmp b, 0
0769   07FF FD 71         seq ; !
0770   0801 C0 00 00      cmp b, 0
0771   0804 C6 0D 08      je _if10_else
0772   0807             _if10_true:
0773   0807             ;; break; 
0774   0807 0A 19 0A      jmp _for9_exit ; for break
0775   080A 0A 16 0A      jmp _if10_exit
0776   080D             _if10_else:
0777   080D             ;; if(*fp == '%'){ 
0778   080D             _if11_cond:
0779   080D FA FD FF      lea d, [bp + -3] ; $fp
0780   0810 2A            mov b, [d]
0781   0811 74            mov d, b
0782   0812 32            mov bl, [d]
0783   0813 A7 00         mov bh, 0
0784   0815             ; START RELATIONAL
0785   0815 D7            push a
0786   0816 11            mov a, b
0787   0817 26 25 00      mov b, $25
0788   081A B0            cmp a, b
0789   081B FD 71         seq ; ==
0790   081D E4            pop a
0791   081E             ; END RELATIONAL
0792   081E C0 00 00      cmp b, 0
0793   0821 C6 FA 09      je _if11_else
0794   0824             _if11_true:
0795   0824             ;; fp++; 
0796   0824 FA FD FF      lea d, [bp + -3] ; $fp
0797   0827 2A            mov b, [d]
0798   0828 D8            push b
0799   0829 FD 77         inc b
0800   082B FA FD FF      lea d, [bp + -3] ; $fp
0801   082E FD 43         mov [d], b
0802   0830 E5            pop b
0803   0831             ;; switch(*fp){ 
0804   0831             _switch12_expr:
0805   0831 FA FD FF      lea d, [bp + -3] ; $fp
0806   0834 2A            mov b, [d]
0807   0835 74            mov d, b
0808   0836 32            mov bl, [d]
0809   0837 A7 00         mov bh, 0
0810   0839             _switch12_comparisons:
0811   0839 C1 6C         cmp bl, $6c
0812   083B C6 67 08      je _switch12_case0
0813   083E C1 4C         cmp bl, $4c
0814   0840 C6 67 08      je _switch12_case1
0815   0843 C1 64         cmp bl, $64
0816   0845 C6 35 09      je _switch12_case2
0817   0848 C1 69         cmp bl, $69
0818   084A C6 35 09      je _switch12_case3
0819   084D C1 75         cmp bl, $75
0820   084F C6 5A 09      je _switch12_case4
0821   0852 C1 78         cmp bl, $78
0822   0854 C6 7F 09      je _switch12_case5
0823   0857 C1 63         cmp bl, $63
0824   0859 C6 9E 09      je _switch12_case6
0825   085C C1 73         cmp bl, $73
0826   085E C6 BE 09      je _switch12_case7
0827   0861 0A DE 09      jmp _switch12_default
0828   0864 0A EA 09      jmp _switch12_exit
0829   0867             _switch12_case0:
0830   0867             _switch12_case1:
0831   0867             ;; fp++; 
0832   0867 FA FD FF      lea d, [bp + -3] ; $fp
0833   086A 2A            mov b, [d]
0834   086B D8            push b
0835   086C FD 77         inc b
0836   086E FA FD FF      lea d, [bp + -3] ; $fp
0837   0871 FD 43         mov [d], b
0838   0873 E5            pop b
0839   0874             ;; if(*fp == 'd' || *fp == 'i') 
0840   0874             _if13_cond:
0841   0874 FA FD FF      lea d, [bp + -3] ; $fp
0842   0877 2A            mov b, [d]
0843   0878 74            mov d, b
0844   0879 32            mov bl, [d]
0845   087A A7 00         mov bh, 0
0846   087C             ; START RELATIONAL
0847   087C D7            push a
0848   087D 11            mov a, b
0849   087E 26 64 00      mov b, $64
0850   0881 B0            cmp a, b
0851   0882 FD 71         seq ; ==
0852   0884 E4            pop a
0853   0885             ; END RELATIONAL
0854   0885 D7            push a
0855   0886 11            mov a, b
0856   0887 FA FD FF      lea d, [bp + -3] ; $fp
0857   088A 2A            mov b, [d]
0858   088B 74            mov d, b
0859   088C 32            mov bl, [d]
0860   088D A7 00         mov bh, 0
0861   088F             ; START RELATIONAL
0862   088F D7            push a
0863   0890 11            mov a, b
0864   0891 26 69 00      mov b, $69
0865   0894 B0            cmp a, b
0866   0895 FD 71         seq ; ==
0867   0897 E4            pop a
0868   0898             ; END RELATIONAL
0869   0898 FD A8         sor a, b ; ||
0870   089A E4            pop a
0871   089B C0 00 00      cmp b, 0
0872   089E C6 B5 08      je _if13_else
0873   08A1             _if13_true:
0874   08A1             ;; print_signed_long(*(long *)p); 
0875   08A1 FD 79         mov g, b
0876   08A3 28            mov b, c
0877   08A4 FD AB         swp b
0878   08A6 D8            push b
0879   08A7 FD 27         mov b, g
0880   08A9 FD AB         swp b
0881   08AB D8            push b
0882   08AC 07 AB 0C      call print_signed_long
0883   08AF 51 04 00      add sp, 4
0884   08B2 0A 1F 09      jmp _if13_exit
0885   08B5             _if13_else:
0886   08B5             ;; if(*fp == 'u') 
0887   08B5             _if14_cond:
0888   08B5 FA FD FF      lea d, [bp + -3] ; $fp
0889   08B8 2A            mov b, [d]
0890   08B9 74            mov d, b
0891   08BA 32            mov bl, [d]
0892   08BB A7 00         mov bh, 0
0893   08BD             ; START RELATIONAL
0894   08BD D7            push a
0895   08BE 11            mov a, b
0896   08BF 26 75 00      mov b, $75
0897   08C2 B0            cmp a, b
0898   08C3 FD 71         seq ; ==
0899   08C5 E4            pop a
0900   08C6             ; END RELATIONAL
0901   08C6 C0 00 00      cmp b, 0
0902   08C9 C6 E0 08      je _if14_else
0903   08CC             _if14_true:
0904   08CC             ;; print_unsigned_long(*(unsigned long *)p); 
0905   08CC FD 79         mov g, b
0906   08CE 28            mov b, c
0907   08CF FD AB         swp b
0908   08D1 D8            push b
0909   08D2 FD 27         mov b, g
0910   08D4 FD AB         swp b
0911   08D6 D8            push b
0912   08D7 07 FE 0D      call print_unsigned_long
0913   08DA 51 04 00      add sp, 4
0914   08DD 0A 1F 09      jmp _if14_exit
0915   08E0             _if14_else:
0916   08E0             ;; if(*fp == 'x') 
0917   08E0             _if15_cond:
0918   08E0 FA FD FF      lea d, [bp + -3] ; $fp
0919   08E3 2A            mov b, [d]
0920   08E4 74            mov d, b
0921   08E5 32            mov bl, [d]
0922   08E6 A7 00         mov bh, 0
0923   08E8             ; START RELATIONAL
0924   08E8 D7            push a
0925   08E9 11            mov a, b
0926   08EA 26 78 00      mov b, $78
0927   08ED B0            cmp a, b
0928   08EE FD 71         seq ; ==
0929   08F0 E4            pop a
0930   08F1             ; END RELATIONAL
0931   08F1 C0 00 00      cmp b, 0
0932   08F4 C6 16 09      je _if15_else
0933   08F7             _if15_true:
0934   08F7             ;; printx32(*(long int *)p); 
0935   08F7 FA FF FF      lea d, [bp + -1] ; $p
0936   08FA 2A            mov b, [d]
0937   08FB 74            mov d, b
0938   08FC 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0939   08FF FD 39         mov c, b ; And place it into C
0940   0901 2A            mov b, [d] ; Lower Word in B
0941   0902 FD 79         mov g, b
0942   0904 28            mov b, c
0943   0905 FD AB         swp b
0944   0907 D8            push b
0945   0908 FD 27         mov b, g
0946   090A FD AB         swp b
0947   090C D8            push b
0948   090D 07 30 0A      call printx32
0949   0910 51 04 00      add sp, 4
0950   0913 0A 1F 09      jmp _if15_exit
0951   0916             _if15_else:
0952   0916             ;; err("Unexpected format in printf."); 
0953   0916 26 50 14      mov b, __s0 ; "Unexpected format in printf."
0954   0919 FD AB         swp b
0955   091B D8            push b
0956   091C 07 1B 0A      call err
0957   091F             _if15_exit:
0958   091F             _if14_exit:
0959   091F             _if13_exit:
0960   091F             ;; p = p + 4; 
0961   091F FA FF FF      lea d, [bp + -1] ; $p
0962   0922 DA            push d
0963   0923 FA FF FF      lea d, [bp + -1] ; $p
0964   0926 2A            mov b, [d]
0965   0927             ; START TERMS
0966   0927 D7            push a
0967   0928 11            mov a, b
0968   0929 26 04 00      mov b, $4
0969   092C 54            add a, b
0970   092D 27            mov b, a
0971   092E E4            pop a
0972   092F             ; END TERMS
0973   092F E7            pop d
0974   0930 FD 43         mov [d], b
0975   0932             ;; break; 
0976   0932 0A EA 09      jmp _switch12_exit ; case break
0977   0935             _switch12_case2:
0978   0935             _switch12_case3:
0979   0935             ;; print_signed(*(int*)p); 
0980   0935 FA FF FF      lea d, [bp + -1] ; $p
0981   0938 2A            mov b, [d]
0982   0939 74            mov d, b
0983   093A 2A            mov b, [d]
0984   093B FD AB         swp b
0985   093D D8            push b
0986   093E 07 BA 0B      call print_signed
0987   0941 51 02 00      add sp, 2
0988   0944             ;; p = p + 2; 
0989   0944 FA FF FF      lea d, [bp + -1] ; $p
0990   0947 DA            push d
0991   0948 FA FF FF      lea d, [bp + -1] ; $p
0992   094B 2A            mov b, [d]
0993   094C             ; START TERMS
0994   094C D7            push a
0995   094D 11            mov a, b
0996   094E 26 02 00      mov b, $2
0997   0951 54            add a, b
0998   0952 27            mov b, a
0999   0953 E4            pop a
1000   0954             ; END TERMS
1001   0954 E7            pop d
1002   0955 FD 43         mov [d], b
1003   0957             ;; break; 
1004   0957 0A EA 09      jmp _switch12_exit ; case break
1005   095A             _switch12_case4:
1006   095A             ;; print_unsigned(*(unsigned int*)p); 
1007   095A FA FF FF      lea d, [bp + -1] ; $p
1008   095D 2A            mov b, [d]
1009   095E 74            mov d, b
1010   095F 2A            mov b, [d]
1011   0960 FD AB         swp b
1012   0962 D8            push b
1013   0963 07 FC 0E      call print_unsigned
1014   0966 51 02 00      add sp, 2
1015   0969             ;; p = p + 2; 
1016   0969 FA FF FF      lea d, [bp + -1] ; $p
1017   096C DA            push d
1018   096D FA FF FF      lea d, [bp + -1] ; $p
1019   0970 2A            mov b, [d]
1020   0971             ; START TERMS
1021   0971 D7            push a
1022   0972 11            mov a, b
1023   0973 26 02 00      mov b, $2
1024   0976 54            add a, b
1025   0977 27            mov b, a
1026   0978 E4            pop a
1027   0979             ; END TERMS
1028   0979 E7            pop d
1029   097A FD 43         mov [d], b
1030   097C             ;; break; 
1031   097C 0A EA 09      jmp _switch12_exit ; case break
1032   097F             _switch12_case5:
1033   097F             
1034   097F             ; --- BEGIN INLINE ASM BLOCK
1035   097F FA FF FF      lea d, [bp + -1] ; $p
1036   0982 FD 2A         mov d, [d]
1037   0984 2A            mov b, [d]
1038   0985 07 50 13      call print_u16x
1039   0988             ; --- END INLINE ASM BLOCK
1040   0988             
1041   0988             ;; p = p + 2; 
1042   0988 FA FF FF      lea d, [bp + -1] ; $p
1043   098B DA            push d
1044   098C FA FF FF      lea d, [bp + -1] ; $p
1045   098F 2A            mov b, [d]
1046   0990             ; START TERMS
1047   0990 D7            push a
1048   0991 11            mov a, b
1049   0992 26 02 00      mov b, $2
1050   0995 54            add a, b
1051   0996 27            mov b, a
1052   0997 E4            pop a
1053   0998             ; END TERMS
1054   0998 E7            pop d
1055   0999 FD 43         mov [d], b
1056   099B             ;; break; 
1057   099B 0A EA 09      jmp _switch12_exit ; case break
1058   099E             _switch12_case6:
1059   099E             
1060   099E             ; --- BEGIN INLINE ASM BLOCK
1061   099E FA FF FF      lea d, [bp + -1] ; $p
1062   09A1 FD 2A         mov d, [d]
1063   09A3 1E            mov al, [d]
1064   09A4 23            mov ah, al
1065   09A5 07 AE 11      call _putchar
1066   09A8             ; --- END INLINE ASM BLOCK
1067   09A8             
1068   09A8             ;; p = p + 2; 
1069   09A8 FA FF FF      lea d, [bp + -1] ; $p
1070   09AB DA            push d
1071   09AC FA FF FF      lea d, [bp + -1] ; $p
1072   09AF 2A            mov b, [d]
1073   09B0             ; START TERMS
1074   09B0 D7            push a
1075   09B1 11            mov a, b
1076   09B2 26 02 00      mov b, $2
1077   09B5 54            add a, b
1078   09B6 27            mov b, a
1079   09B7 E4            pop a
1080   09B8             ; END TERMS
1081   09B8 E7            pop d
1082   09B9 FD 43         mov [d], b
1083   09BB             ;; break; 
1084   09BB 0A EA 09      jmp _switch12_exit ; case break
1085   09BE             _switch12_case7:
1086   09BE             
1087   09BE             ; --- BEGIN INLINE ASM BLOCK
1088   09BE FA FF FF      lea d, [bp + -1] ; $p
1089   09C1 FD 2A         mov d, [d]
1090   09C3 FD 2A         mov d, [d]
1091   09C5 07 F8 12      call _puts
1092   09C8             ; --- END INLINE ASM BLOCK
1093   09C8             
1094   09C8             ;; p = p + 2; 
1095   09C8 FA FF FF      lea d, [bp + -1] ; $p
1096   09CB DA            push d
1097   09CC FA FF FF      lea d, [bp + -1] ; $p
1098   09CF 2A            mov b, [d]
1099   09D0             ; START TERMS
1100   09D0 D7            push a
1101   09D1 11            mov a, b
1102   09D2 26 02 00      mov b, $2
1103   09D5 54            add a, b
1104   09D6 27            mov b, a
1105   09D7 E4            pop a
1106   09D8             ; END TERMS
1107   09D8 E7            pop d
1108   09D9 FD 43         mov [d], b
1109   09DB             ;; break; 
1110   09DB 0A EA 09      jmp _switch12_exit ; case break
1111   09DE             _switch12_default:
1112   09DE             ;; print("Error: Unknown argument type.\n"); 
1113   09DE 26 6D 14      mov b, __s1 ; "Error: Unknown argument type.\n"
1114   09E1 FD AB         swp b
1115   09E3 D8            push b
1116   09E4 07 15 10      call print
1117   09E7 51 02 00      add sp, 2
1118   09EA             _switch12_exit:
1119   09EA             ;; fp++; 
1120   09EA FA FD FF      lea d, [bp + -3] ; $fp
1121   09ED 2A            mov b, [d]
1122   09EE D8            push b
1123   09EF FD 77         inc b
1124   09F1 FA FD FF      lea d, [bp + -3] ; $fp
1125   09F4 FD 43         mov [d], b
1126   09F6 E5            pop b
1127   09F7 0A 16 0A      jmp _if11_exit
1128   09FA             _if11_else:
1129   09FA             ;; putchar(*fp); 
1130   09FA FA FD FF      lea d, [bp + -3] ; $fp
1131   09FD 2A            mov b, [d]
1132   09FE 74            mov d, b
1133   09FF 32            mov bl, [d]
1134   0A00 A7 00         mov bh, 0
1135   0A02 DD            push bl
1136   0A03 07 CD 0F      call putchar
1137   0A06 51 01 00      add sp, 1
1138   0A09             ;; fp++; 
1139   0A09 FA FD FF      lea d, [bp + -3] ; $fp
1140   0A0C 2A            mov b, [d]
1141   0A0D D8            push b
1142   0A0E FD 77         inc b
1143   0A10 FA FD FF      lea d, [bp + -3] ; $fp
1144   0A13 FD 43         mov [d], b
1145   0A15 E5            pop b
1146   0A16             _if11_exit:
1147   0A16             _if10_exit:
1148   0A16             _for9_update:
1149   0A16 0A F4 07      jmp _for9_cond
1150   0A19             _for9_exit:
1151   0A19 F9            leave
1152   0A1A 09            ret
1153   0A1B             
1154   0A1B             err:
1155   0A1B F8 00 00      enter 0 ; (push bp; mov bp, sp)
1156   0A1E             ;; print(e); 
1157   0A1E FA 05 00      lea d, [bp + 5] ; $e
1158   0A21 2A            mov b, [d]
1159   0A22 FD AB         swp b
1160   0A24 D8            push b
1161   0A25 07 15 10      call print
1162   0A28 51 02 00      add sp, 2
1163   0A2B             ;; exit(); 
1164   0A2B 07 E4 05      call exit
1165   0A2E F9            leave
1166   0A2F 09            ret
1167   0A30             
1168   0A30             printx32:
1169   0A30 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1170   0A33             
1171   0A33             ; --- BEGIN INLINE ASM BLOCK
1172   0A33 FA 05 00      lea d, [bp + 5] ; $hex
1173   0A36 2B 02 00      mov b, [d+2]
1174   0A39 07 50 13      call print_u16x
1175   0A3C 2A            mov b, [d]
1176   0A3D 07 50 13      call print_u16x
1177   0A40             ; --- END INLINE ASM BLOCK
1178   0A40             
1179   0A40 F9            leave
1180   0A41 09            ret
1181   0A42             
1182   0A42             printx16:
1183   0A42 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1184   0A45             
1185   0A45             ; --- BEGIN INLINE ASM BLOCK
1186   0A45 FA 05 00      lea d, [bp + 5] ; $hex
1187   0A48 2A            mov b, [d]
1188   0A49 07 50 13      call print_u16x
1189   0A4C             ; --- END INLINE ASM BLOCK
1190   0A4C             
1191   0A4C F9            leave
1192   0A4D 09            ret
1193   0A4E             
1194   0A4E             printx8:
1195   0A4E F8 00 00      enter 0 ; (push bp; mov bp, sp)
1196   0A51             
1197   0A51             ; --- BEGIN INLINE ASM BLOCK
1198   0A51 FA 05 00      lea d, [bp + 5] ; $hex
1199   0A54 32            mov bl, [d]
1200   0A55 07 94 13      call print_u8x
1201   0A58             ; --- END INLINE ASM BLOCK
1202   0A58             
1203   0A58 F9            leave
1204   0A59 09            ret
1205   0A5A             
1206   0A5A             hex_to_int:
1207   0A5A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1208   0A5D             ; $value 
1209   0A5D 10 00 00      mov a, $0
1210   0A60 45 FF FF      mov [bp + -1], a
1211   0A63             ; $i 
1212   0A63             ; $hex_char 
1213   0A63             ; $len 
1214   0A63 52 07 00      sub sp, 7
1215   0A66             ;; len = strlen(hex_string); 
1216   0A66 FA FA FF      lea d, [bp + -6] ; $len
1217   0A69 DA            push d
1218   0A6A FA 05 00      lea d, [bp + 5] ; $hex_string
1219   0A6D 2A            mov b, [d]
1220   0A6E FD AB         swp b
1221   0A70 D8            push b
1222   0A71 07 9B 05      call strlen
1223   0A74 51 02 00      add sp, 2
1224   0A77 E7            pop d
1225   0A78 FD 43         mov [d], b
1226   0A7A             ;; for (i = 0; i < len; i++) { 
1227   0A7A             _for16_init:
1228   0A7A FA FD FF      lea d, [bp + -3] ; $i
1229   0A7D DA            push d
1230   0A7E 26 00 00      mov b, $0
1231   0A81 E7            pop d
1232   0A82 FD 43         mov [d], b
1233   0A84             _for16_cond:
1234   0A84 FA FD FF      lea d, [bp + -3] ; $i
1235   0A87 2A            mov b, [d]
1236   0A88             ; START RELATIONAL
1237   0A88 D7            push a
1238   0A89 11            mov a, b
1239   0A8A FA FA FF      lea d, [bp + -6] ; $len
1240   0A8D 2A            mov b, [d]
1241   0A8E B0            cmp a, b
1242   0A8F FD 75         slu ; <= (unsigned)
1243   0A91 E4            pop a
1244   0A92             ; END RELATIONAL
1245   0A92 C0 00 00      cmp b, 0
1246   0A95 C6 9A 0B      je _for16_exit
1247   0A98             _for16_block:
1248   0A98             ;; hex_char = hex_string[i]; 
1249   0A98 FA FC FF      lea d, [bp + -4] ; $hex_char
1250   0A9B DA            push d
1251   0A9C FA 05 00      lea d, [bp + 5] ; $hex_string
1252   0A9F FD 2A         mov d, [d]
1253   0AA1 D7            push a
1254   0AA2 DA            push d
1255   0AA3 FA FD FF      lea d, [bp + -3] ; $i
1256   0AA6 2A            mov b, [d]
1257   0AA7 E7            pop d
1258   0AA8 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
1259   0AAC E4            pop a
1260   0AAD 32            mov bl, [d]
1261   0AAE A7 00         mov bh, 0
1262   0AB0 E7            pop d
1263   0AB1 FD 3E         mov [d], bl
1264   0AB3             ;; if (hex_char >= 'a' && hex_char <= 'f')  
1265   0AB3             _if17_cond:
1266   0AB3 FA FC FF      lea d, [bp + -4] ; $hex_char
1267   0AB6 32            mov bl, [d]
1268   0AB7 A7 00         mov bh, 0
1269   0AB9             ; START RELATIONAL
1270   0AB9 D7            push a
1271   0ABA 11            mov a, b
1272   0ABB 26 61 00      mov b, $61
1273   0ABE B0            cmp a, b
1274   0ABF FD 80         sge ; >=
1275   0AC1 E4            pop a
1276   0AC2             ; END RELATIONAL
1277   0AC2 D7            push a
1278   0AC3 11            mov a, b
1279   0AC4 FA FC FF      lea d, [bp + -4] ; $hex_char
1280   0AC7 32            mov bl, [d]
1281   0AC8 A7 00         mov bh, 0
1282   0ACA             ; START RELATIONAL
1283   0ACA D7            push a
1284   0ACB 11            mov a, b
1285   0ACC 26 66 00      mov b, $66
1286   0ACF B0            cmp a, b
1287   0AD0 FD 74         sle ; <=
1288   0AD2 E4            pop a
1289   0AD3             ; END RELATIONAL
1290   0AD3 FD A7         sand a, b ; &&
1291   0AD5 E4            pop a
1292   0AD6 C0 00 00      cmp b, 0
1293   0AD9 C6 0B 0B      je _if17_else
1294   0ADC             _if17_true:
1295   0ADC             ;; value = (value * 16) + (hex_char - 'a' + 10); 
1296   0ADC FA FF FF      lea d, [bp + -1] ; $value
1297   0ADF DA            push d
1298   0AE0 FA FF FF      lea d, [bp + -1] ; $value
1299   0AE3 2A            mov b, [d]
1300   0AE4             ; START FACTORS
1301   0AE4 D7            push a
1302   0AE5 11            mov a, b
1303   0AE6 26 10 00      mov b, $10
1304   0AE9 AC            mul a, b ; *
1305   0AEA 11            mov a, b
1306   0AEB 27            mov b, a
1307   0AEC E4            pop a
1308   0AED             ; END FACTORS
1309   0AED             ; START TERMS
1310   0AED D7            push a
1311   0AEE 11            mov a, b
1312   0AEF FA FC FF      lea d, [bp + -4] ; $hex_char
1313   0AF2 32            mov bl, [d]
1314   0AF3 A7 00         mov bh, 0
1315   0AF5             ; START TERMS
1316   0AF5 D7            push a
1317   0AF6 11            mov a, b
1318   0AF7 26 61 00      mov b, $61
1319   0AFA 60            sub a, b
1320   0AFB 11            mov a, b
1321   0AFC 26 0A 00      mov b, $a
1322   0AFF 54            add a, b
1323   0B00 27            mov b, a
1324   0B01 E4            pop a
1325   0B02             ; END TERMS
1326   0B02 54            add a, b
1327   0B03 27            mov b, a
1328   0B04 E4            pop a
1329   0B05             ; END TERMS
1330   0B05 E7            pop d
1331   0B06 FD 43         mov [d], b
1332   0B08 0A 8A 0B      jmp _if17_exit
1333   0B0B             _if17_else:
1334   0B0B             ;; if (hex_char >= 'A' && hex_char <= 'F')  
1335   0B0B             _if18_cond:
1336   0B0B FA FC FF      lea d, [bp + -4] ; $hex_char
1337   0B0E 32            mov bl, [d]
1338   0B0F A7 00         mov bh, 0
1339   0B11             ; START RELATIONAL
1340   0B11 D7            push a
1341   0B12 11            mov a, b
1342   0B13 26 41 00      mov b, $41
1343   0B16 B0            cmp a, b
1344   0B17 FD 80         sge ; >=
1345   0B19 E4            pop a
1346   0B1A             ; END RELATIONAL
1347   0B1A D7            push a
1348   0B1B 11            mov a, b
1349   0B1C FA FC FF      lea d, [bp + -4] ; $hex_char
1350   0B1F 32            mov bl, [d]
1351   0B20 A7 00         mov bh, 0
1352   0B22             ; START RELATIONAL
1353   0B22 D7            push a
1354   0B23 11            mov a, b
1355   0B24 26 46 00      mov b, $46
1356   0B27 B0            cmp a, b
1357   0B28 FD 74         sle ; <=
1358   0B2A E4            pop a
1359   0B2B             ; END RELATIONAL
1360   0B2B FD A7         sand a, b ; &&
1361   0B2D E4            pop a
1362   0B2E C0 00 00      cmp b, 0
1363   0B31 C6 63 0B      je _if18_else
1364   0B34             _if18_true:
1365   0B34             ;; value = (value * 16) + (hex_char - 'A' + 10); 
1366   0B34 FA FF FF      lea d, [bp + -1] ; $value
1367   0B37 DA            push d
1368   0B38 FA FF FF      lea d, [bp + -1] ; $value
1369   0B3B 2A            mov b, [d]
1370   0B3C             ; START FACTORS
1371   0B3C D7            push a
1372   0B3D 11            mov a, b
1373   0B3E 26 10 00      mov b, $10
1374   0B41 AC            mul a, b ; *
1375   0B42 11            mov a, b
1376   0B43 27            mov b, a
1377   0B44 E4            pop a
1378   0B45             ; END FACTORS
1379   0B45             ; START TERMS
1380   0B45 D7            push a
1381   0B46 11            mov a, b
1382   0B47 FA FC FF      lea d, [bp + -4] ; $hex_char
1383   0B4A 32            mov bl, [d]
1384   0B4B A7 00         mov bh, 0
1385   0B4D             ; START TERMS
1386   0B4D D7            push a
1387   0B4E 11            mov a, b
1388   0B4F 26 41 00      mov b, $41
1389   0B52 60            sub a, b
1390   0B53 11            mov a, b
1391   0B54 26 0A 00      mov b, $a
1392   0B57 54            add a, b
1393   0B58 27            mov b, a
1394   0B59 E4            pop a
1395   0B5A             ; END TERMS
1396   0B5A 54            add a, b
1397   0B5B 27            mov b, a
1398   0B5C E4            pop a
1399   0B5D             ; END TERMS
1400   0B5D E7            pop d
1401   0B5E FD 43         mov [d], b
1402   0B60 0A 8A 0B      jmp _if18_exit
1403   0B63             _if18_else:
1404   0B63             ;; value = (value * 16) + (hex_char - '0'); 
1405   0B63 FA FF FF      lea d, [bp + -1] ; $value
1406   0B66 DA            push d
1407   0B67 FA FF FF      lea d, [bp + -1] ; $value
1408   0B6A 2A            mov b, [d]
1409   0B6B             ; START FACTORS
1410   0B6B D7            push a
1411   0B6C 11            mov a, b
1412   0B6D 26 10 00      mov b, $10
1413   0B70 AC            mul a, b ; *
1414   0B71 11            mov a, b
1415   0B72 27            mov b, a
1416   0B73 E4            pop a
1417   0B74             ; END FACTORS
1418   0B74             ; START TERMS
1419   0B74 D7            push a
1420   0B75 11            mov a, b
1421   0B76 FA FC FF      lea d, [bp + -4] ; $hex_char
1422   0B79 32            mov bl, [d]
1423   0B7A A7 00         mov bh, 0
1424   0B7C             ; START TERMS
1425   0B7C D7            push a
1426   0B7D 11            mov a, b
1427   0B7E 26 30 00      mov b, $30
1428   0B81 60            sub a, b
1429   0B82 27            mov b, a
1430   0B83 E4            pop a
1431   0B84             ; END TERMS
1432   0B84 54            add a, b
1433   0B85 27            mov b, a
1434   0B86 E4            pop a
1435   0B87             ; END TERMS
1436   0B87 E7            pop d
1437   0B88 FD 43         mov [d], b
1438   0B8A             _if18_exit:
1439   0B8A             _if17_exit:
1440   0B8A             _for16_update:
1441   0B8A FA FD FF      lea d, [bp + -3] ; $i
1442   0B8D 2A            mov b, [d]
1443   0B8E D8            push b
1444   0B8F FD 77         inc b
1445   0B91 FA FD FF      lea d, [bp + -3] ; $i
1446   0B94 FD 43         mov [d], b
1447   0B96 E5            pop b
1448   0B97 0A 84 0A      jmp _for16_cond
1449   0B9A             _for16_exit:
1450   0B9A             ;; return value; 
1451   0B9A FA FF FF      lea d, [bp + -1] ; $value
1452   0B9D 2A            mov b, [d]
1453   0B9E F9            leave
1454   0B9F 09            ret
1455   0BA0             
1456   0BA0             gets:
1457   0BA0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1458   0BA3             
1459   0BA3             ; --- BEGIN INLINE ASM BLOCK
1460   0BA3 FA 05 00      lea d, [bp + 5] ; $s
1461   0BA6 15            mov a, [d]
1462   0BA7 3C            mov d, a
1463   0BA8 07 B5 11      call _gets
1464   0BAB             ; --- END INLINE ASM BLOCK
1465   0BAB             
1466   0BAB             ;; return strlen(s); 
1467   0BAB FA 05 00      lea d, [bp + 5] ; $s
1468   0BAE 2A            mov b, [d]
1469   0BAF FD AB         swp b
1470   0BB1 D8            push b
1471   0BB2 07 9B 05      call strlen
1472   0BB5 51 02 00      add sp, 2
1473   0BB8 F9            leave
1474   0BB9 09            ret
1475   0BBA             
1476   0BBA             print_signed:
1477   0BBA F8 00 00      enter 0 ; (push bp; mov bp, sp)
1478   0BBD             ; $digits 
1479   0BBD             ; $i 
1480   0BBD 10 00 00      mov a, $0
1481   0BC0 45 FA FF      mov [bp + -6], a
1482   0BC3 52 07 00      sub sp, 7
1483   0BC6             ;; if (num < 0) { 
1484   0BC6             _if19_cond:
1485   0BC6 FA 05 00      lea d, [bp + 5] ; $num
1486   0BC9 2A            mov b, [d]
1487   0BCA             ; START RELATIONAL
1488   0BCA D7            push a
1489   0BCB 11            mov a, b
1490   0BCC 26 00 00      mov b, $0
1491   0BCF B0            cmp a, b
1492   0BD0 FD 75         slu ; <= (unsigned)
1493   0BD2 E4            pop a
1494   0BD3             ; END RELATIONAL
1495   0BD3 C0 00 00      cmp b, 0
1496   0BD6 C6 F3 0B      je _if19_else
1497   0BD9             _if19_true:
1498   0BD9             ;; putchar('-'); 
1499   0BD9 26 2D 00      mov b, $2d
1500   0BDC DD            push bl
1501   0BDD 07 CD 0F      call putchar
1502   0BE0 51 01 00      add sp, 1
1503   0BE3             ;; num = -num; 
1504   0BE3 FA 05 00      lea d, [bp + 5] ; $num
1505   0BE6 DA            push d
1506   0BE7 FA 05 00      lea d, [bp + 5] ; $num
1507   0BEA 2A            mov b, [d]
1508   0BEB FD 97         neg b
1509   0BED E7            pop d
1510   0BEE FD 43         mov [d], b
1511   0BF0 0A 15 0C      jmp _if19_exit
1512   0BF3             _if19_else:
1513   0BF3             ;; if (num == 0) { 
1514   0BF3             _if20_cond:
1515   0BF3 FA 05 00      lea d, [bp + 5] ; $num
1516   0BF6 2A            mov b, [d]
1517   0BF7             ; START RELATIONAL
1518   0BF7 D7            push a
1519   0BF8 11            mov a, b
1520   0BF9 26 00 00      mov b, $0
1521   0BFC B0            cmp a, b
1522   0BFD FD 71         seq ; ==
1523   0BFF E4            pop a
1524   0C00             ; END RELATIONAL
1525   0C00 C0 00 00      cmp b, 0
1526   0C03 C6 15 0C      je _if20_exit
1527   0C06             _if20_true:
1528   0C06             ;; putchar('0'); 
1529   0C06 26 30 00      mov b, $30
1530   0C09 DD            push bl
1531   0C0A 07 CD 0F      call putchar
1532   0C0D 51 01 00      add sp, 1
1533   0C10             ;; return; 
1534   0C10 F9            leave
1535   0C11 09            ret
1536   0C12 0A 15 0C      jmp _if20_exit
1537   0C15             _if20_exit:
1538   0C15             _if19_exit:
1539   0C15             ;; while (num > 0) { 
1540   0C15             _while21_cond:
1541   0C15 FA 05 00      lea d, [bp + 5] ; $num
1542   0C18 2A            mov b, [d]
1543   0C19             ; START RELATIONAL
1544   0C19 D7            push a
1545   0C1A 11            mov a, b
1546   0C1B 26 00 00      mov b, $0
1547   0C1E B0            cmp a, b
1548   0C1F FD 7F         sgt ; >
1549   0C21 E4            pop a
1550   0C22             ; END RELATIONAL
1551   0C22 C0 00 00      cmp b, 0
1552   0C25 C6 70 0C      je _while21_exit
1553   0C28             _while21_block:
1554   0C28             ;; digits[i] = '0' + (num % 10); 
1555   0C28 FA FC FF      lea d, [bp + -4] ; $digits
1556   0C2B D7            push a
1557   0C2C DA            push d
1558   0C2D FA FA FF      lea d, [bp + -6] ; $i
1559   0C30 2A            mov b, [d]
1560   0C31 E7            pop d
1561   0C32 5A            add d, b
1562   0C33 E4            pop a
1563   0C34 DA            push d
1564   0C35 26 30 00      mov b, $30
1565   0C38             ; START TERMS
1566   0C38 D7            push a
1567   0C39 11            mov a, b
1568   0C3A FA 05 00      lea d, [bp + 5] ; $num
1569   0C3D 2A            mov b, [d]
1570   0C3E             ; START FACTORS
1571   0C3E D7            push a
1572   0C3F 11            mov a, b
1573   0C40 26 0A 00      mov b, $a
1574   0C43 AE            div a, b ; 
1575   0C44 11            mov a, b
1576   0C45 27            mov b, a
1577   0C46 E4            pop a
1578   0C47             ; END FACTORS
1579   0C47 54            add a, b
1580   0C48 27            mov b, a
1581   0C49 E4            pop a
1582   0C4A             ; END TERMS
1583   0C4A E7            pop d
1584   0C4B FD 3E         mov [d], bl
1585   0C4D             ;; num = num / 10; 
1586   0C4D FA 05 00      lea d, [bp + 5] ; $num
1587   0C50 DA            push d
1588   0C51 FA 05 00      lea d, [bp + 5] ; $num
1589   0C54 2A            mov b, [d]
1590   0C55             ; START FACTORS
1591   0C55 D7            push a
1592   0C56 11            mov a, b
1593   0C57 26 0A 00      mov b, $a
1594   0C5A AE            div a, b
1595   0C5B 27            mov b, a
1596   0C5C E4            pop a
1597   0C5D             ; END FACTORS
1598   0C5D E7            pop d
1599   0C5E FD 43         mov [d], b
1600   0C60             ;; i++; 
1601   0C60 FA FA FF      lea d, [bp + -6] ; $i
1602   0C63 2A            mov b, [d]
1603   0C64 D8            push b
1604   0C65 FD 77         inc b
1605   0C67 FA FA FF      lea d, [bp + -6] ; $i
1606   0C6A FD 43         mov [d], b
1607   0C6C E5            pop b
1608   0C6D 0A 15 0C      jmp _while21_cond
1609   0C70             _while21_exit:
1610   0C70             ;; while (i > 0) { 
1611   0C70             _while22_cond:
1612   0C70 FA FA FF      lea d, [bp + -6] ; $i
1613   0C73 2A            mov b, [d]
1614   0C74             ; START RELATIONAL
1615   0C74 D7            push a
1616   0C75 11            mov a, b
1617   0C76 26 00 00      mov b, $0
1618   0C79 B0            cmp a, b
1619   0C7A FD 7F         sgt ; >
1620   0C7C E4            pop a
1621   0C7D             ; END RELATIONAL
1622   0C7D C0 00 00      cmp b, 0
1623   0C80 C6 A9 0C      je _while22_exit
1624   0C83             _while22_block:
1625   0C83             ;; i--; 
1626   0C83 FA FA FF      lea d, [bp + -6] ; $i
1627   0C86 2A            mov b, [d]
1628   0C87 D8            push b
1629   0C88 FD 7D         dec b
1630   0C8A FA FA FF      lea d, [bp + -6] ; $i
1631   0C8D FD 43         mov [d], b
1632   0C8F E5            pop b
1633   0C90             ;; putchar(digits[i]); 
1634   0C90 FA FC FF      lea d, [bp + -4] ; $digits
1635   0C93 D7            push a
1636   0C94 DA            push d
1637   0C95 FA FA FF      lea d, [bp + -6] ; $i
1638   0C98 2A            mov b, [d]
1639   0C99 E7            pop d
1640   0C9A 5A            add d, b
1641   0C9B E4            pop a
1642   0C9C 32            mov bl, [d]
1643   0C9D A7 00         mov bh, 0
1644   0C9F DD            push bl
1645   0CA0 07 CD 0F      call putchar
1646   0CA3 51 01 00      add sp, 1
1647   0CA6 0A 70 0C      jmp _while22_cond
1648   0CA9             _while22_exit:
1649   0CA9 F9            leave
1650   0CAA 09            ret
1651   0CAB             
1652   0CAB             print_signed_long:
1653   0CAB F8 00 00      enter 0 ; (push bp; mov bp, sp)
1654   0CAE             ; $digits 
1655   0CAE             ; $i 
1656   0CAE 10 00 00      mov a, $0
1657   0CB1 45 F5 FF      mov [bp + -11], a
1658   0CB4 52 0C 00      sub sp, 12
1659   0CB7             ;; if (num < 0) { 
1660   0CB7             _if23_cond:
1661   0CB7 FA 05 00      lea d, [bp + 5] ; $num
1662   0CBA 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1663   0CBD FD 39         mov c, b ; And place it into C
1664   0CBF 2A            mov b, [d] ; Lower Word in B
1665   0CC0             ; START RELATIONAL
1666   0CC0 D7            push a
1667   0CC1 FD D8         push g
1668   0CC3 11            mov a, b
1669   0CC4 FD 7A         mov g, c
1670   0CC6 26 00 00      mov b, $0
1671   0CC9 4D            mov si, a
1672   0CCA 11            mov a, b
1673   0CCB 4F            mov di, a
1674   0CCC FD 12         mov a, g
1675   0CCE 28            mov b, c
1676   0CCF B0            cmp a, b
1677   0CD0 FD 75         slu ; <
1678   0CD2 D8            push b
1679   0CD3 28            mov b, c
1680   0CD4 FD 71         seq ; ==
1681   0CD6 D8            push b
1682   0CD7 50            mov a, di
1683   0CD8 27            mov b, a
1684   0CD9 4E            mov a, si
1685   0CDA B0            cmp a, b
1686   0CDB FD 75         slu ; <
1687   0CDD E4            pop a
1688   0CDE FD 92         and b, a
1689   0CE0 E4            pop a
1690   0CE1 FD 70         or b, a
1691   0CE3               
1692   0CE3 FD F1         pop g
1693   0CE5 E4            pop a
1694   0CE6             ; END RELATIONAL
1695   0CE6 C0 00 00      cmp b, 0
1696   0CE9 C6 10 0D      je _if23_else
1697   0CEC             _if23_true:
1698   0CEC             ;; putchar('-'); 
1699   0CEC 26 2D 00      mov b, $2d
1700   0CEF DD            push bl
1701   0CF0 07 CD 0F      call putchar
1702   0CF3 51 01 00      add sp, 1
1703   0CF6             ;; num = -num; 
1704   0CF6 FA 05 00      lea d, [bp + 5] ; $num
1705   0CF9 DA            push d
1706   0CFA FA 05 00      lea d, [bp + 5] ; $num
1707   0CFD 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1708   0D00 FD 39         mov c, b ; And place it into C
1709   0D02 2A            mov b, [d] ; Lower Word in B
1710   0D03 FD 97         neg b
1711   0D05 E7            pop d
1712   0D06 FD 43         mov [d], b
1713   0D08 28            mov b, c
1714   0D09 FD 44 02 00   mov [d + 2], b
1715   0D0D 0A 47 0D      jmp _if23_exit
1716   0D10             _if23_else:
1717   0D10             ;; if (num == 0) { 
1718   0D10             _if24_cond:
1719   0D10 FA 05 00      lea d, [bp + 5] ; $num
1720   0D13 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1721   0D16 FD 39         mov c, b ; And place it into C
1722   0D18 2A            mov b, [d] ; Lower Word in B
1723   0D19             ; START RELATIONAL
1724   0D19 D7            push a
1725   0D1A FD D8         push g
1726   0D1C 11            mov a, b
1727   0D1D FD 7A         mov g, c
1728   0D1F 26 00 00      mov b, $0
1729   0D22 B0            cmp a, b
1730   0D23 FD 71         seq ; ==
1731   0D25 D8            push b
1732   0D26 12            mov a, c
1733   0D27 FD 27         mov b, g
1734   0D29 B0            cmp a, b
1735   0D2A FD 71         seq ; ==
1736   0D2C E4            pop a
1737   0D2D FD A7         sand a, b
1738   0D2F FD F1         pop g
1739   0D31 E4            pop a
1740   0D32             ; END RELATIONAL
1741   0D32 C0 00 00      cmp b, 0
1742   0D35 C6 47 0D      je _if24_exit
1743   0D38             _if24_true:
1744   0D38             ;; putchar('0'); 
1745   0D38 26 30 00      mov b, $30
1746   0D3B DD            push bl
1747   0D3C 07 CD 0F      call putchar
1748   0D3F 51 01 00      add sp, 1
1749   0D42             ;; return; 
1750   0D42 F9            leave
1751   0D43 09            ret
1752   0D44 0A 47 0D      jmp _if24_exit
1753   0D47             _if24_exit:
1754   0D47             _if23_exit:
1755   0D47             ;; while (num > 0) { 
1756   0D47             _while25_cond:
1757   0D47 FA 05 00      lea d, [bp + 5] ; $num
1758   0D4A 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1759   0D4D FD 39         mov c, b ; And place it into C
1760   0D4F 2A            mov b, [d] ; Lower Word in B
1761   0D50             ; START RELATIONAL
1762   0D50 D7            push a
1763   0D51 FD D8         push g
1764   0D53 11            mov a, b
1765   0D54 FD 7A         mov g, c
1766   0D56 26 00 00      mov b, $0
1767   0D59 B0            cmp a, b
1768   0D5A FD 7F         sgt ; >
1769   0D5C FD F1         pop g
1770   0D5E E4            pop a
1771   0D5F             ; END RELATIONAL
1772   0D5F C0 00 00      cmp b, 0
1773   0D62 C6 C3 0D      je _while25_exit
1774   0D65             _while25_block:
1775   0D65             ;; digits[i] = '0' + (num % 10); 
1776   0D65 FA F7 FF      lea d, [bp + -9] ; $digits
1777   0D68 D7            push a
1778   0D69 DA            push d
1779   0D6A FA F5 FF      lea d, [bp + -11] ; $i
1780   0D6D 2A            mov b, [d]
1781   0D6E E7            pop d
1782   0D6F 5A            add d, b
1783   0D70 E4            pop a
1784   0D71 DA            push d
1785   0D72 26 30 00      mov b, $30
1786   0D75             ; START TERMS
1787   0D75 D7            push a
1788   0D76 11            mov a, b
1789   0D77 FA 05 00      lea d, [bp + 5] ; $num
1790   0D7A 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1791   0D7D FD 39         mov c, b ; And place it into C
1792   0D7F 2A            mov b, [d] ; Lower Word in B
1793   0D80             ; START FACTORS
1794   0D80 D7            push a
1795   0D81 11            mov a, b
1796   0D82 26 0A 00      mov b, $a
1797   0D85 AE            div a, b ; 
1798   0D86 11            mov a, b
1799   0D87 27            mov b, a
1800   0D88 E4            pop a
1801   0D89             ; END FACTORS
1802   0D89 54            add a, b
1803   0D8A D7            push a
1804   0D8B FD 12         mov a, g
1805   0D8D 28            mov b, c
1806   0D8E 5C            adc a, b
1807   0D8F 39            mov c, a
1808   0D90 E5            pop b
1809   0D91 27            mov b, a
1810   0D92 E4            pop a
1811   0D93             ; END TERMS
1812   0D93 E7            pop d
1813   0D94 FD 3E         mov [d], bl
1814   0D96             ;; num = num / 10; 
1815   0D96 FA 05 00      lea d, [bp + 5] ; $num
1816   0D99 DA            push d
1817   0D9A FA 05 00      lea d, [bp + 5] ; $num
1818   0D9D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1819   0DA0 FD 39         mov c, b ; And place it into C
1820   0DA2 2A            mov b, [d] ; Lower Word in B
1821   0DA3             ; START FACTORS
1822   0DA3 D7            push a
1823   0DA4 11            mov a, b
1824   0DA5 26 0A 00      mov b, $a
1825   0DA8 AE            div a, b
1826   0DA9 27            mov b, a
1827   0DAA E4            pop a
1828   0DAB             ; END FACTORS
1829   0DAB E7            pop d
1830   0DAC FD 43         mov [d], b
1831   0DAE 28            mov b, c
1832   0DAF FD 44 02 00   mov [d + 2], b
1833   0DB3             ;; i++; 
1834   0DB3 FA F5 FF      lea d, [bp + -11] ; $i
1835   0DB6 2A            mov b, [d]
1836   0DB7 D8            push b
1837   0DB8 FD 77         inc b
1838   0DBA FA F5 FF      lea d, [bp + -11] ; $i
1839   0DBD FD 43         mov [d], b
1840   0DBF E5            pop b
1841   0DC0 0A 47 0D      jmp _while25_cond
1842   0DC3             _while25_exit:
1843   0DC3             ;; while (i > 0) { 
1844   0DC3             _while26_cond:
1845   0DC3 FA F5 FF      lea d, [bp + -11] ; $i
1846   0DC6 2A            mov b, [d]
1847   0DC7             ; START RELATIONAL
1848   0DC7 D7            push a
1849   0DC8 11            mov a, b
1850   0DC9 26 00 00      mov b, $0
1851   0DCC B0            cmp a, b
1852   0DCD FD 7F         sgt ; >
1853   0DCF E4            pop a
1854   0DD0             ; END RELATIONAL
1855   0DD0 C0 00 00      cmp b, 0
1856   0DD3 C6 FC 0D      je _while26_exit
1857   0DD6             _while26_block:
1858   0DD6             ;; i--; 
1859   0DD6 FA F5 FF      lea d, [bp + -11] ; $i
1860   0DD9 2A            mov b, [d]
1861   0DDA D8            push b
1862   0DDB FD 7D         dec b
1863   0DDD FA F5 FF      lea d, [bp + -11] ; $i
1864   0DE0 FD 43         mov [d], b
1865   0DE2 E5            pop b
1866   0DE3             ;; putchar(digits[i]); 
1867   0DE3 FA F7 FF      lea d, [bp + -9] ; $digits
1868   0DE6 D7            push a
1869   0DE7 DA            push d
1870   0DE8 FA F5 FF      lea d, [bp + -11] ; $i
1871   0DEB 2A            mov b, [d]
1872   0DEC E7            pop d
1873   0DED 5A            add d, b
1874   0DEE E4            pop a
1875   0DEF 32            mov bl, [d]
1876   0DF0 A7 00         mov bh, 0
1877   0DF2 DD            push bl
1878   0DF3 07 CD 0F      call putchar
1879   0DF6 51 01 00      add sp, 1
1880   0DF9 0A C3 0D      jmp _while26_cond
1881   0DFC             _while26_exit:
1882   0DFC F9            leave
1883   0DFD 09            ret
1884   0DFE             
1885   0DFE             print_unsigned_long:
1886   0DFE F8 00 00      enter 0 ; (push bp; mov bp, sp)
1887   0E01             ; $digits 
1888   0E01             ; $i 
1889   0E01 52 0C 00      sub sp, 12
1890   0E04             ;; i = 0; 
1891   0E04 FA F5 FF      lea d, [bp + -11] ; $i
1892   0E07 DA            push d
1893   0E08 26 00 00      mov b, $0
1894   0E0B E7            pop d
1895   0E0C FD 43         mov [d], b
1896   0E0E             ;; if(num == 0){ 
1897   0E0E             _if27_cond:
1898   0E0E FA 05 00      lea d, [bp + 5] ; $num
1899   0E11 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1900   0E14 FD 39         mov c, b ; And place it into C
1901   0E16 2A            mov b, [d] ; Lower Word in B
1902   0E17             ; START RELATIONAL
1903   0E17 D7            push a
1904   0E18 FD D8         push g
1905   0E1A 11            mov a, b
1906   0E1B FD 7A         mov g, c
1907   0E1D 26 00 00      mov b, $0
1908   0E20 B0            cmp a, b
1909   0E21 FD 71         seq ; ==
1910   0E23 D8            push b
1911   0E24 12            mov a, c
1912   0E25 FD 27         mov b, g
1913   0E27 B0            cmp a, b
1914   0E28 FD 71         seq ; ==
1915   0E2A E4            pop a
1916   0E2B FD A7         sand a, b
1917   0E2D FD F1         pop g
1918   0E2F E4            pop a
1919   0E30             ; END RELATIONAL
1920   0E30 C0 00 00      cmp b, 0
1921   0E33 C6 45 0E      je _if27_exit
1922   0E36             _if27_true:
1923   0E36             ;; putchar('0'); 
1924   0E36 26 30 00      mov b, $30
1925   0E39 DD            push bl
1926   0E3A 07 CD 0F      call putchar
1927   0E3D 51 01 00      add sp, 1
1928   0E40             ;; return; 
1929   0E40 F9            leave
1930   0E41 09            ret
1931   0E42 0A 45 0E      jmp _if27_exit
1932   0E45             _if27_exit:
1933   0E45             ;; while (num > 0) { 
1934   0E45             _while28_cond:
1935   0E45 FA 05 00      lea d, [bp + 5] ; $num
1936   0E48 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1937   0E4B FD 39         mov c, b ; And place it into C
1938   0E4D 2A            mov b, [d] ; Lower Word in B
1939   0E4E             ; START RELATIONAL
1940   0E4E D7            push a
1941   0E4F FD D8         push g
1942   0E51 11            mov a, b
1943   0E52 FD 7A         mov g, c
1944   0E54 26 00 00      mov b, $0
1945   0E57 B0            cmp a, b
1946   0E58 FD 81         sgu ; > (unsigned)
1947   0E5A FD F1         pop g
1948   0E5C E4            pop a
1949   0E5D             ; END RELATIONAL
1950   0E5D C0 00 00      cmp b, 0
1951   0E60 C6 C1 0E      je _while28_exit
1952   0E63             _while28_block:
1953   0E63             ;; digits[i] = '0' + (num % 10); 
1954   0E63 FA F7 FF      lea d, [bp + -9] ; $digits
1955   0E66 D7            push a
1956   0E67 DA            push d
1957   0E68 FA F5 FF      lea d, [bp + -11] ; $i
1958   0E6B 2A            mov b, [d]
1959   0E6C E7            pop d
1960   0E6D 5A            add d, b
1961   0E6E E4            pop a
1962   0E6F DA            push d
1963   0E70 26 30 00      mov b, $30
1964   0E73             ; START TERMS
1965   0E73 D7            push a
1966   0E74 11            mov a, b
1967   0E75 FA 05 00      lea d, [bp + 5] ; $num
1968   0E78 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1969   0E7B FD 39         mov c, b ; And place it into C
1970   0E7D 2A            mov b, [d] ; Lower Word in B
1971   0E7E             ; START FACTORS
1972   0E7E D7            push a
1973   0E7F 11            mov a, b
1974   0E80 26 0A 00      mov b, $a
1975   0E83 AE            div a, b ; 
1976   0E84 11            mov a, b
1977   0E85 27            mov b, a
1978   0E86 E4            pop a
1979   0E87             ; END FACTORS
1980   0E87 54            add a, b
1981   0E88 D7            push a
1982   0E89 FD 12         mov a, g
1983   0E8B 28            mov b, c
1984   0E8C 5C            adc a, b
1985   0E8D 39            mov c, a
1986   0E8E E5            pop b
1987   0E8F 27            mov b, a
1988   0E90 E4            pop a
1989   0E91             ; END TERMS
1990   0E91 E7            pop d
1991   0E92 FD 3E         mov [d], bl
1992   0E94             ;; num = num / 10; 
1993   0E94 FA 05 00      lea d, [bp + 5] ; $num
1994   0E97 DA            push d
1995   0E98 FA 05 00      lea d, [bp + 5] ; $num
1996   0E9B 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1997   0E9E FD 39         mov c, b ; And place it into C
1998   0EA0 2A            mov b, [d] ; Lower Word in B
1999   0EA1             ; START FACTORS
2000   0EA1 D7            push a
2001   0EA2 11            mov a, b
2002   0EA3 26 0A 00      mov b, $a
2003   0EA6 AE            div a, b
2004   0EA7 27            mov b, a
2005   0EA8 E4            pop a
2006   0EA9             ; END FACTORS
2007   0EA9 E7            pop d
2008   0EAA FD 43         mov [d], b
2009   0EAC 28            mov b, c
2010   0EAD FD 44 02 00   mov [d + 2], b
2011   0EB1             ;; i++; 
2012   0EB1 FA F5 FF      lea d, [bp + -11] ; $i
2013   0EB4 2A            mov b, [d]
2014   0EB5 D8            push b
2015   0EB6 FD 77         inc b
2016   0EB8 FA F5 FF      lea d, [bp + -11] ; $i
2017   0EBB FD 43         mov [d], b
2018   0EBD E5            pop b
2019   0EBE 0A 45 0E      jmp _while28_cond
2020   0EC1             _while28_exit:
2021   0EC1             ;; while (i > 0) { 
2022   0EC1             _while29_cond:
2023   0EC1 FA F5 FF      lea d, [bp + -11] ; $i
2024   0EC4 2A            mov b, [d]
2025   0EC5             ; START RELATIONAL
2026   0EC5 D7            push a
2027   0EC6 11            mov a, b
2028   0EC7 26 00 00      mov b, $0
2029   0ECA B0            cmp a, b
2030   0ECB FD 7F         sgt ; >
2031   0ECD E4            pop a
2032   0ECE             ; END RELATIONAL
2033   0ECE C0 00 00      cmp b, 0
2034   0ED1 C6 FA 0E      je _while29_exit
2035   0ED4             _while29_block:
2036   0ED4             ;; i--; 
2037   0ED4 FA F5 FF      lea d, [bp + -11] ; $i
2038   0ED7 2A            mov b, [d]
2039   0ED8 D8            push b
2040   0ED9 FD 7D         dec b
2041   0EDB FA F5 FF      lea d, [bp + -11] ; $i
2042   0EDE FD 43         mov [d], b
2043   0EE0 E5            pop b
2044   0EE1             ;; putchar(digits[i]); 
2045   0EE1 FA F7 FF      lea d, [bp + -9] ; $digits
2046   0EE4 D7            push a
2047   0EE5 DA            push d
2048   0EE6 FA F5 FF      lea d, [bp + -11] ; $i
2049   0EE9 2A            mov b, [d]
2050   0EEA E7            pop d
2051   0EEB 5A            add d, b
2052   0EEC E4            pop a
2053   0EED 32            mov bl, [d]
2054   0EEE A7 00         mov bh, 0
2055   0EF0 DD            push bl
2056   0EF1 07 CD 0F      call putchar
2057   0EF4 51 01 00      add sp, 1
2058   0EF7 0A C1 0E      jmp _while29_cond
2059   0EFA             _while29_exit:
2060   0EFA F9            leave
2061   0EFB 09            ret
2062   0EFC             
2063   0EFC             print_unsigned:
2064   0EFC F8 00 00      enter 0 ; (push bp; mov bp, sp)
2065   0EFF             ; $digits 
2066   0EFF             ; $i 
2067   0EFF 52 07 00      sub sp, 7
2068   0F02             ;; i = 0; 
2069   0F02 FA FA FF      lea d, [bp + -6] ; $i
2070   0F05 DA            push d
2071   0F06 26 00 00      mov b, $0
2072   0F09 E7            pop d
2073   0F0A FD 43         mov [d], b
2074   0F0C             ;; if(num == 0){ 
2075   0F0C             _if30_cond:
2076   0F0C FA 05 00      lea d, [bp + 5] ; $num
2077   0F0F 2A            mov b, [d]
2078   0F10             ; START RELATIONAL
2079   0F10 D7            push a
2080   0F11 11            mov a, b
2081   0F12 26 00 00      mov b, $0
2082   0F15 B0            cmp a, b
2083   0F16 FD 71         seq ; ==
2084   0F18 E4            pop a
2085   0F19             ; END RELATIONAL
2086   0F19 C0 00 00      cmp b, 0
2087   0F1C C6 2E 0F      je _if30_exit
2088   0F1F             _if30_true:
2089   0F1F             ;; putchar('0'); 
2090   0F1F 26 30 00      mov b, $30
2091   0F22 DD            push bl
2092   0F23 07 CD 0F      call putchar
2093   0F26 51 01 00      add sp, 1
2094   0F29             ;; return; 
2095   0F29 F9            leave
2096   0F2A 09            ret
2097   0F2B 0A 2E 0F      jmp _if30_exit
2098   0F2E             _if30_exit:
2099   0F2E             ;; while (num > 0) { 
2100   0F2E             _while31_cond:
2101   0F2E FA 05 00      lea d, [bp + 5] ; $num
2102   0F31 2A            mov b, [d]
2103   0F32             ; START RELATIONAL
2104   0F32 D7            push a
2105   0F33 11            mov a, b
2106   0F34 26 00 00      mov b, $0
2107   0F37 B0            cmp a, b
2108   0F38 FD 81         sgu ; > (unsigned)
2109   0F3A E4            pop a
2110   0F3B             ; END RELATIONAL
2111   0F3B C0 00 00      cmp b, 0
2112   0F3E C6 89 0F      je _while31_exit
2113   0F41             _while31_block:
2114   0F41             ;; digits[i] = '0' + (num % 10); 
2115   0F41 FA FC FF      lea d, [bp + -4] ; $digits
2116   0F44 D7            push a
2117   0F45 DA            push d
2118   0F46 FA FA FF      lea d, [bp + -6] ; $i
2119   0F49 2A            mov b, [d]
2120   0F4A E7            pop d
2121   0F4B 5A            add d, b
2122   0F4C E4            pop a
2123   0F4D DA            push d
2124   0F4E 26 30 00      mov b, $30
2125   0F51             ; START TERMS
2126   0F51 D7            push a
2127   0F52 11            mov a, b
2128   0F53 FA 05 00      lea d, [bp + 5] ; $num
2129   0F56 2A            mov b, [d]
2130   0F57             ; START FACTORS
2131   0F57 D7            push a
2132   0F58 11            mov a, b
2133   0F59 26 0A 00      mov b, $a
2134   0F5C AE            div a, b ; 
2135   0F5D 11            mov a, b
2136   0F5E 27            mov b, a
2137   0F5F E4            pop a
2138   0F60             ; END FACTORS
2139   0F60 54            add a, b
2140   0F61 27            mov b, a
2141   0F62 E4            pop a
2142   0F63             ; END TERMS
2143   0F63 E7            pop d
2144   0F64 FD 3E         mov [d], bl
2145   0F66             ;; num = num / 10; 
2146   0F66 FA 05 00      lea d, [bp + 5] ; $num
2147   0F69 DA            push d
2148   0F6A FA 05 00      lea d, [bp + 5] ; $num
2149   0F6D 2A            mov b, [d]
2150   0F6E             ; START FACTORS
2151   0F6E D7            push a
2152   0F6F 11            mov a, b
2153   0F70 26 0A 00      mov b, $a
2154   0F73 AE            div a, b
2155   0F74 27            mov b, a
2156   0F75 E4            pop a
2157   0F76             ; END FACTORS
2158   0F76 E7            pop d
2159   0F77 FD 43         mov [d], b
2160   0F79             ;; i++; 
2161   0F79 FA FA FF      lea d, [bp + -6] ; $i
2162   0F7C 2A            mov b, [d]
2163   0F7D D8            push b
2164   0F7E FD 77         inc b
2165   0F80 FA FA FF      lea d, [bp + -6] ; $i
2166   0F83 FD 43         mov [d], b
2167   0F85 E5            pop b
2168   0F86 0A 2E 0F      jmp _while31_cond
2169   0F89             _while31_exit:
2170   0F89             ;; while (i > 0) { 
2171   0F89             _while32_cond:
2172   0F89 FA FA FF      lea d, [bp + -6] ; $i
2173   0F8C 2A            mov b, [d]
2174   0F8D             ; START RELATIONAL
2175   0F8D D7            push a
2176   0F8E 11            mov a, b
2177   0F8F 26 00 00      mov b, $0
2178   0F92 B0            cmp a, b
2179   0F93 FD 7F         sgt ; >
2180   0F95 E4            pop a
2181   0F96             ; END RELATIONAL
2182   0F96 C0 00 00      cmp b, 0
2183   0F99 C6 C2 0F      je _while32_exit
2184   0F9C             _while32_block:
2185   0F9C             ;; i--; 
2186   0F9C FA FA FF      lea d, [bp + -6] ; $i
2187   0F9F 2A            mov b, [d]
2188   0FA0 D8            push b
2189   0FA1 FD 7D         dec b
2190   0FA3 FA FA FF      lea d, [bp + -6] ; $i
2191   0FA6 FD 43         mov [d], b
2192   0FA8 E5            pop b
2193   0FA9             ;; putchar(digits[i]); 
2194   0FA9 FA FC FF      lea d, [bp + -4] ; $digits
2195   0FAC D7            push a
2196   0FAD DA            push d
2197   0FAE FA FA FF      lea d, [bp + -6] ; $i
2198   0FB1 2A            mov b, [d]
2199   0FB2 E7            pop d
2200   0FB3 5A            add d, b
2201   0FB4 E4            pop a
2202   0FB5 32            mov bl, [d]
2203   0FB6 A7 00         mov bh, 0
2204   0FB8 DD            push bl
2205   0FB9 07 CD 0F      call putchar
2206   0FBC 51 01 00      add sp, 1
2207   0FBF 0A 89 0F      jmp _while32_cond
2208   0FC2             _while32_exit:
2209   0FC2 F9            leave
2210   0FC3 09            ret
2211   0FC4             
2212   0FC4             date:
2213   0FC4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2214   0FC7             
2215   0FC7             ; --- BEGIN INLINE ASM BLOCK
2216   0FC7 19 00         mov al, 0 
2217   0FC9 05 07         syscall sys_datetime
2218   0FCB             ; --- END INLINE ASM BLOCK
2219   0FCB             
2220   0FCB F9            leave
2221   0FCC 09            ret
2222   0FCD             
2223   0FCD             putchar:
2224   0FCD F8 00 00      enter 0 ; (push bp; mov bp, sp)
2225   0FD0             
2226   0FD0             ; --- BEGIN INLINE ASM BLOCK
2227   0FD0 FA 05 00      lea d, [bp + 5] ; $c
2228   0FD3 1E            mov al, [d]
2229   0FD4 23            mov ah, al
2230   0FD5 07 AE 11      call _putchar
2231   0FD8             ; --- END INLINE ASM BLOCK
2232   0FD8             
2233   0FD8 F9            leave
2234   0FD9 09            ret
2235   0FDA             
2236   0FDA             getchar:
2237   0FDA F8 00 00      enter 0 ; (push bp; mov bp, sp)
2238   0FDD             ; $c 
2239   0FDD 52 01 00      sub sp, 1
2240   0FE0             
2241   0FE0             ; --- BEGIN INLINE ASM BLOCK
2242   0FE0 07 A7 11      call getch
2243   0FE3 1A            mov al, ah
2244   0FE4 FA 00 00      lea d, [bp + 0] ; $c
2245   0FE7 3E            mov [d], al
2246   0FE8             ; --- END INLINE ASM BLOCK
2247   0FE8             
2248   0FE8             ;; return c; 
2249   0FE8 FA 00 00      lea d, [bp + 0] ; $c
2250   0FEB 32            mov bl, [d]
2251   0FEC A7 00         mov bh, 0
2252   0FEE F9            leave
2253   0FEF 09            ret
2254   0FF0             
2255   0FF0             scann:
2256   0FF0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2257   0FF3             ; $m 
2258   0FF3 52 02 00      sub sp, 2
2259   0FF6             
2260   0FF6             ; --- BEGIN INLINE ASM BLOCK
2261   0FF6 07 F2 13      call scan_u16d
2262   0FF9 FA FF FF      lea d, [bp + -1] ; $m
2263   0FFC 43            mov [d], a
2264   0FFD             ; --- END INLINE ASM BLOCK
2265   0FFD             
2266   0FFD             ;; return m; 
2267   0FFD FA FF FF      lea d, [bp + -1] ; $m
2268   1000 2A            mov b, [d]
2269   1001 F9            leave
2270   1002 09            ret
2271   1003             
2272   1003             puts:
2273   1003 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2274   1006             
2275   1006             ; --- BEGIN INLINE ASM BLOCK
2276   1006 FA 05 00      lea d, [bp + 5] ; $s
2277   1009 15            mov a, [d]
2278   100A 3C            mov d, a
2279   100B 07 F8 12      call _puts
2280   100E 10 00 0A      mov a, $0A00
2281   1011 05 03         syscall sys_io
2282   1013             ; --- END INLINE ASM BLOCK
2283   1013             
2284   1013 F9            leave
2285   1014 09            ret
2286   1015             
2287   1015             print:
2288   1015 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2289   1018             
2290   1018             ; --- BEGIN INLINE ASM BLOCK
2291   1018 FA 05 00      lea d, [bp + 5] ; $s
2292   101B FD 2A         mov d, [d]
2293   101D 07 F8 12      call _puts
2294   1020             ; --- END INLINE ASM BLOCK
2295   1020             
2296   1020 F9            leave
2297   1021 09            ret
2298   1022             
2299   1022             loadfile:
2300   1022 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2301   1025             
2302   1025             ; --- BEGIN INLINE ASM BLOCK
2303   1025 FA 07 00      lea d, [bp + 7] ; $destination
2304   1028 15            mov a, [d]
2305   1029 4F            mov di, a
2306   102A FA 05 00      lea d, [bp + 5] ; $filename
2307   102D FD 2A         mov d, [d]
2308   102F 19 14         mov al, 20
2309   1031 05 04         syscall sys_filesystem
2310   1033             ; --- END INLINE ASM BLOCK
2311   1033             
2312   1033 F9            leave
2313   1034 09            ret
2314   1035             
2315   1035             create_file:
2316   1035 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2317   1038 F9            leave
2318   1039 09            ret
2319   103A             
2320   103A             delete_file:
2321   103A F8 00 00      enter 0 ; (push bp; mov bp, sp)
2322   103D             
2323   103D             ; --- BEGIN INLINE ASM BLOCK
2324   103D FA 05 00      lea d, [bp + 5] ; $filename
2325   1040 19 0A         mov al, 10
2326   1042 05 04         syscall sys_filesystem
2327   1044             ; --- END INLINE ASM BLOCK
2328   1044             
2329   1044 F9            leave
2330   1045 09            ret
2331   1046             
2332   1046             fopen:
2333   1046 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2334   1049 F9            leave
2335   104A 09            ret
2336   104B             
2337   104B             fclose:
2338   104B F8 00 00      enter 0 ; (push bp; mov bp, sp)
2339   104E F9            leave
2340   104F 09            ret
2341   1050             
2342   1050             load_hex:
2343   1050 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2344   1053             ; $temp 
2345   1053 52 02 00      sub sp, 2
2346   1056             ;; temp = alloc(32768); 
2347   1056 FA FF FF      lea d, [bp + -1] ; $temp
2348   1059 DA            push d
2349   105A 26 00 80      mov b, $8000
2350   105D FD AB         swp b
2351   105F D8            push b
2352   1060 07 26 07      call alloc
2353   1063 51 02 00      add sp, 2
2354   1066 E7            pop d
2355   1067 FD 43         mov [d], b
2356   1069             
2357   1069             ; --- BEGIN INLINE ASM BLOCK
2358   1069               
2359   1069               
2360   1069               
2361   1069               
2362   1069               
2363   1069             _load_hex:
2364   1069 D7            push a
2365   106A D8            push b
2366   106B DA            push d
2367   106C E2            push si
2368   106D E3            push di
2369   106E 52 00 80      sub sp, $8000      
2370   1071 38 00 00      mov c, 0
2371   1074 48            mov a, sp
2372   1075 77            inc a
2373   1076 3C            mov d, a          
2374   1077 07 B5 11      call _gets        
2375   107A 4D            mov si, a
2376   107B             __load_hex_loop:
2377   107B F6            lodsb             
2378   107C B9 00         cmp al, 0         
2379   107E C6 8C 10      jz __load_hex_ret
2380   1081 36            mov bh, al
2381   1082 F6            lodsb
2382   1083 2F            mov bl, al
2383   1084 07 6B 11      call _atoi        
2384   1087 F7            stosb             
2385   1088 78            inc c
2386   1089 0A 7B 10      jmp __load_hex_loop
2387   108C             __load_hex_ret:
2388   108C 51 00 80      add sp, $8000
2389   108F F0            pop di
2390   1090 EF            pop si
2391   1091 E7            pop d
2392   1092 E5            pop b
2393   1093 E4            pop a
2394   1094             ; --- END INLINE ASM BLOCK
2395   1094             
2396   1094 F9            leave
2397   1095 09            ret
2398   1096             
2399   1096             getparam:
2400   1096 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2401   1099             ; $data 
2402   1099 52 01 00      sub sp, 1
2403   109C             
2404   109C             ; --- BEGIN INLINE ASM BLOCK
2405   109C 19 04         mov al, 4
2406   109E FA 05 00      lea d, [bp + 5] ; $address
2407   10A1 FD 2A         mov d, [d]
2408   10A3 05 0C         syscall sys_system
2409   10A5 FA 00 00      lea d, [bp + 0] ; $data
2410   10A8 FD 3E         mov [d], bl
2411   10AA             ; --- END INLINE ASM BLOCK
2412   10AA             
2413   10AA             ;; return data; 
2414   10AA FA 00 00      lea d, [bp + 0] ; $data
2415   10AD 32            mov bl, [d]
2416   10AE A7 00         mov bh, 0
2417   10B0 F9            leave
2418   10B1 09            ret
2419   10B2             
2420   10B2             clear:
2421   10B2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2422   10B5             ;; print("\033[2J\033[H"); 
2423   10B5 26 8C 14      mov b, __s2 ; "\033[2J\033[H"
2424   10B8 FD AB         swp b
2425   10BA D8            push b
2426   10BB 07 15 10      call print
2427   10BE 51 02 00      add sp, 2
2428   10C1 F9            leave
2429   10C2 09            ret
2430   10C3             
2431   10C3             include_stdio_asm:
2432   10C3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2433   10C6             
2434   10C6             ; --- BEGIN INLINE ASM BLOCK
2435   10C6             .include "lib/asm/stdio.asm"
0001+  10C6             ;-----------------------------------------------------------------------------
0002+  10C6             ; stdio.s
0003+  10C6             ;-----------------------------------------------------------------------------
0004+  10C6             .include "lib/asm/string.asm"
0001++ 10C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 10C6             ; string.s
0003++ 10C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 10C6             
0005++ 10C6             
0006++ 10C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 10C6             ; _strrev
0008++ 10C6             ; reverse a string
0009++ 10C6             ; D = string address
0010++ 10C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 10C6             ; 01234
0012++ 10C6             _strrev:
0013++ 10C6 4B          	pusha
0014++ 10C7 07 0D 11    	call _strlen	; length in C
0015++ 10CA 12          	mov a, c
0016++ 10CB AF 01 00    	cmp a, 1
0017++ 10CE D0 E8 10    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 10D1 7D          	dec a
0019++ 10D2 FD 4E       	mov si, d	; beginning of string
0020++ 10D4 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 10D6 59          	add d, a	; end of string
0022++ 10D7 12          	mov a, c
0023++ 10D8 FD 9B       	shr a		; divide by 2
0024++ 10DA 39          	mov c, a	; C now counts the steps
0025++ 10DB             _strrev_L0:
0026++ 10DB 32          	mov bl, [d]	; save load right-side char into BL
0027++ 10DC F6          	lodsb		; load left-side char into AL; increase SI
0028++ 10DD 3E          	mov [d], al	; store left char into right side
0029++ 10DE 1B          	mov al, bl
0030++ 10DF F7          	stosb		; store right-side char into left-side; increase DI
0031++ 10E0 7E          	dec c
0032++ 10E1 7F          	dec d
0033++ 10E2 C2 00 00    	cmp c, 0
0034++ 10E5 C7 DB 10    	jne _strrev_L0
0035++ 10E8             _strrev_end:
0036++ 10E8 4C          	popa
0037++ 10E9 09          	ret
0038++ 10EA             	
0039++ 10EA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 10EA             ; _strchr
0041++ 10EA             ; search string in D for char in AL
0042++ 10EA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 10EA             _strchr:
0044++ 10EA             _strchr_L0:
0045++ 10EA 32          	mov bl, [d]
0046++ 10EB C1 00       	cmp bl, 0
0047++ 10ED C6 F8 10    	je _strchr_end
0048++ 10F0 BA          	cmp al, bl
0049++ 10F1 C6 F8 10    	je _strchr_end
0050++ 10F4 79          	inc d
0051++ 10F5 0A EA 10    	jmp _strchr_L0
0052++ 10F8             _strchr_end:
0053++ 10F8 1B          	mov al, bl
0054++ 10F9 09          	ret
0055++ 10FA             
0056++ 10FA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 10FA             ; _strstr
0058++ 10FA             ; find sub-string
0059++ 10FA             ; str1 in SI
0060++ 10FA             ; str2 in DI
0061++ 10FA             ; SI points to end of source string
0062++ 10FA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 10FA             _strstr:
0064++ 10FA DB          	push al
0065++ 10FB DA          	push d
0066++ 10FC E3          	push di
0067++ 10FD             _strstr_loop:
0068++ 10FD F3          	cmpsb					; compare a byte of the strings
0069++ 10FE C7 09 11    	jne _strstr_ret
0070++ 1101 FC 00 00    	lea d, [di + 0]
0071++ 1104 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1106 C7 FD 10    	jne _strstr_loop				; equal chars but not at end
0073++ 1109             _strstr_ret:
0074++ 1109 F0          	pop di
0075++ 110A E7          	pop d
0076++ 110B E8          	pop al
0077++ 110C 09          	ret
0078++ 110D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 110D             ; length of null terminated string
0080++ 110D             ; result in C
0081++ 110D             ; pointer in D
0082++ 110D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 110D             _strlen:
0084++ 110D DA          	push d
0085++ 110E 38 00 00    	mov c, 0
0086++ 1111             _strlen_L1:
0087++ 1111 BD 00       	cmp byte [d], 0
0088++ 1113 C6 1B 11    	je _strlen_ret
0089++ 1116 79          	inc d
0090++ 1117 78          	inc c
0091++ 1118 0A 11 11    	jmp _strlen_L1
0092++ 111B             _strlen_ret:
0093++ 111B E7          	pop d
0094++ 111C 09          	ret
0095++ 111D             
0096++ 111D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 111D             ; STRCMP
0098++ 111D             ; compare two strings
0099++ 111D             ; str1 in SI
0100++ 111D             ; str2 in DI
0101++ 111D             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 111D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 111D             _strcmp:
0104++ 111D DB          	push al
0105++ 111E DA          	push d
0106++ 111F E3          	push di
0107++ 1120 E2          	push si
0108++ 1121             _strcmp_loop:
0109++ 1121 F3          	cmpsb					; compare a byte of the strings
0110++ 1122 C7 2D 11    	jne _strcmp_ret
0111++ 1125 FB FF FF    	lea d, [si +- 1]
0112++ 1128 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 112A C7 21 11    	jne _strcmp_loop				; equal chars but not at end
0114++ 112D             _strcmp_ret:
0115++ 112D EF          	pop si
0116++ 112E F0          	pop di
0117++ 112F E7          	pop d
0118++ 1130 E8          	pop al
0119++ 1131 09          	ret
0120++ 1132             
0121++ 1132             
0122++ 1132             ; STRCPY
0123++ 1132             ; copy null terminated string from SI to DI
0124++ 1132             ; source in SI
0125++ 1132             ; destination in DI
0126++ 1132             _strcpy:
0127++ 1132 E2          	push si
0128++ 1133 E3          	push di
0129++ 1134 DB          	push al
0130++ 1135             _strcpy_L1:
0131++ 1135 F6          	lodsb
0132++ 1136 F7          	stosb
0133++ 1137 B9 00       	cmp al, 0
0134++ 1139 C7 35 11    	jne _strcpy_L1
0135++ 113C             _strcpy_end:
0136++ 113C E8          	pop al
0137++ 113D F0          	pop di
0138++ 113E EF          	pop si
0139++ 113F 09          	ret
0140++ 1140             
0141++ 1140             ; STRCAT
0142++ 1140             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 1140             ; source in SI
0144++ 1140             ; destination in DI
0145++ 1140             _strcat:
0146++ 1140 E2          	push si
0147++ 1141 E3          	push di
0148++ 1142 D7          	push a
0149++ 1143 DA          	push d
0150++ 1144 50          	mov a, di
0151++ 1145 3C          	mov d, a
0152++ 1146             _strcat_goto_end_L1:
0153++ 1146 BD 00       	cmp byte[d], 0
0154++ 1148 C6 4F 11    	je _strcat_start
0155++ 114B 79          	inc d
0156++ 114C 0A 46 11    	jmp _strcat_goto_end_L1
0157++ 114F             _strcat_start:
0158++ 114F FD 50       	mov di, d
0159++ 1151             _strcat_L1:
0160++ 1151 F6          	lodsb
0161++ 1152 F7          	stosb
0162++ 1153 B9 00       	cmp al, 0
0163++ 1155 C7 51 11    	jne _strcat_L1
0164++ 1158             _strcat_end:
0165++ 1158 E7          	pop d
0166++ 1159 E4          	pop a
0167++ 115A F0          	pop di
0168++ 115B EF          	pop si
0169++ 115C 09          	ret
0170++ 115D             
0171++ 115D             
0005+  115D             
0006+  115D             ;-----------------------------------------------------------------------------
0007+  115D             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0008+  115D             ; ASCII in BL
0009+  115D             ; result in AL
0010+  115D             ; ascii for F = 0100 0110
0011+  115D             ; ascii for 9 = 0011 1001
0012+  115D             ;-----------------------------------------------------------------------------
0013+  115D             hex_ascii_encode:
0014+  115D 1B            mov al, bl
0015+  115E 93 40         test al, $40        ; test if letter or number
0016+  1160 C7 66 11      jnz hex_letter
0017+  1163 87 0F         and al, $0F        ; get number
0018+  1165 09            ret
0019+  1166             hex_letter:
0020+  1166 87 0F         and al, $0F        ; get letter
0021+  1168 6A 09         add al, 9
0022+  116A 09            ret
0023+  116B             
0024+  116B             ;-----------------------------------------------------------------------------
0025+  116B             ; ATOI
0026+  116B             ; 2 letter hex string in B
0027+  116B             ; 8bit integer returned in AL
0028+  116B             ;-----------------------------------------------------------------------------
0029+  116B             _atoi:
0030+  116B D8            push b
0031+  116C 07 5D 11      call hex_ascii_encode      ; convert BL to 4bit code in AL
0032+  116F 30            mov bl, bh
0033+  1170 DB            push al          ; save a
0034+  1171 07 5D 11      call hex_ascii_encode
0035+  1174 EA            pop bl  
0036+  1175 FD 9E 04      shl al, 4
0037+  1178 8C            or al, bl
0038+  1179 E5            pop b
0039+  117A 09            ret  
0040+  117B             
0041+  117B             ;-----------------------------------------------------------------------------
0042+  117B             ; scanf
0043+  117B             ; no need for explanations!
0044+  117B             ;-----------------------------------------------------------------------------
0045+  117B             scanf:
0046+  117B 09            ret
0047+  117C             
0048+  117C             ;-----------------------------------------------------------------------------
0049+  117C             ; ITOA
0050+  117C             ; 8bit value in BL
0051+  117C             ; 2 byte ASCII result in A
0052+  117C             ;-----------------------------------------------------------------------------
0053+  117C             _itoa:
0054+  117C DA            push d
0055+  117D D8            push b
0056+  117E A7 00         mov bh, 0
0057+  1180 FD A4 04      shr bl, 4  
0058+  1183 74            mov d, b
0059+  1184 1F 2C 14      mov al, [d + s_hex_digits]
0060+  1187 23            mov ah, al
0061+  1188               
0062+  1188 E5            pop b
0063+  1189 D8            push b
0064+  118A A7 00         mov bh, 0
0065+  118C FD 87 0F      and bl, $0F
0066+  118F 74            mov d, b
0067+  1190 1F 2C 14      mov al, [d + s_hex_digits]
0068+  1193 E5            pop b
0069+  1194 E7            pop d
0070+  1195 09            ret
0071+  1196             
0072+  1196             ;-----------------------------------------------------------------------------
0073+  1196             ; HEX STRING TO BINARY
0074+  1196             ; di = destination address
0075+  1196             ; si = source
0076+  1196             ;-----------------------------------------------------------------------------
0077+  1196             _hex_to_int:
0078+  1196             _hex_to_int_L1:
0079+  1196 F6            lodsb          ; load from [SI] to AL
0080+  1197 B9 00         cmp al, 0        ; check if ASCII 0
0081+  1199 C6 A6 11      jz _hex_to_int_ret
0082+  119C 36            mov bh, al
0083+  119D F6            lodsb
0084+  119E 2F            mov bl, al
0085+  119F 07 6B 11      call _atoi        ; convert ASCII byte in B to int (to AL)
0086+  11A2 F7            stosb          ; store AL to [DI]
0087+  11A3 0A 96 11      jmp _hex_to_int_L1
0088+  11A6             _hex_to_int_ret:
0089+  11A6 09            ret    
0090+  11A7             
0091+  11A7             ;-----------------------------------------------------------------------------
0092+  11A7             ; GETCHAR
0093+  11A7             ; char in ah
0094+  11A7             ;-----------------------------------------------------------------------------
0095+  11A7             getch:
0096+  11A7 DB            push al
0097+  11A8             getch_retry:
0098+  11A8 19 01         mov al, 1
0099+  11AA 05 03         syscall sys_io      ; receive in AH
0100+  11AC E8            pop al
0101+  11AD 09            ret
0102+  11AE             
0103+  11AE             ;-----------------------------------------------------------------------------
0104+  11AE             ; PUTCHAR
0105+  11AE             ; char in ah
0106+  11AE             ;-----------------------------------------------------------------------------
0107+  11AE             _putchar:
0108+  11AE D7            push a
0109+  11AF 19 00         mov al, 0
0110+  11B1 05 03         syscall sys_io      ; char in AH
0111+  11B3 E4            pop a
0112+  11B4 09            ret
0113+  11B5             
0114+  11B5             ;-----------------------------------------------------------------------------
0115+  11B5             ;; INPUT A STRING
0116+  11B5             ;; terminates with null
0117+  11B5             ;; pointer in D
0118+  11B5             ;-----------------------------------------------------------------------------
0119+  11B5             _gets:
0120+  11B5 D7            push a
0121+  11B6 DA            push d
0122+  11B7             _gets_loop:
0123+  11B7 19 01         mov al, 1
0124+  11B9 05 03         syscall sys_io      ; receive in AH
0125+  11BB B9 00         cmp al, 0        ; check error code (AL)
0126+  11BD C6 B7 11      je _gets_loop      ; if no char received, retry
0127+  11C0             
0128+  11C0 76 1B         cmp ah, 27
0129+  11C2 C6 E3 11      je _gets_ansi_esc
0130+  11C5 76 0A         cmp ah, $0A        ; LF
0131+  11C7 C6 4E 12      je _gets_end
0132+  11CA 76 0D         cmp ah, $0D        ; CR
0133+  11CC C6 4E 12      je _gets_end
0134+  11CF 76 5C         cmp ah, $5C        ; '\\'
0135+  11D1 C6 0F 12      je _gets_escape
0136+  11D4               
0137+  11D4 76 08         cmp ah, $08      ; check for backspace
0138+  11D6 C6 DF 11      je _gets_backspace
0139+  11D9             
0140+  11D9 1A            mov al, ah
0141+  11DA 3E            mov [d], al
0142+  11DB 79            inc d
0143+  11DC 0A B7 11      jmp _gets_loop
0144+  11DF             _gets_backspace:
0145+  11DF 7F            dec d
0146+  11E0 0A B7 11      jmp _gets_loop
0147+  11E3             _gets_ansi_esc:
0148+  11E3 19 01         mov al, 1
0149+  11E5 05 03         syscall sys_io        ; receive in AH without echo
0150+  11E7 B9 00         cmp al, 0          ; check error code (AL)
0151+  11E9 C6 E3 11      je _gets_ansi_esc    ; if no char received, retry
0152+  11EC 76 5B         cmp ah, '['
0153+  11EE C7 B7 11      jne _gets_loop
0154+  11F1             _gets_ansi_esc_2:
0155+  11F1 19 01         mov al, 1
0156+  11F3 05 03         syscall sys_io          ; receive in AH without echo
0157+  11F5 B9 00         cmp al, 0            ; check error code (AL)
0158+  11F7 C6 F1 11      je _gets_ansi_esc_2  ; if no char received, retry
0159+  11FA 76 44         cmp ah, 'D'
0160+  11FC C6 07 12      je _gets_left_arrow
0161+  11FF 76 43         cmp ah, 'C'
0162+  1201 C6 0B 12      je _gets_right_arrow
0163+  1204 0A B7 11      jmp _gets_loop
0164+  1207             _gets_left_arrow:
0165+  1207 7F            dec d
0166+  1208 0A B7 11      jmp _gets_loop
0167+  120B             _gets_right_arrow:
0168+  120B 79            inc d
0169+  120C 0A B7 11      jmp _gets_loop
0170+  120F             _gets_escape:
0171+  120F 19 01         mov al, 1
0172+  1211 05 03         syscall sys_io      ; receive in AH
0173+  1213 B9 00         cmp al, 0        ; check error code (AL)
0174+  1215 C6 0F 12      je _gets_escape      ; if no char received, retry
0175+  1218 76 6E         cmp ah, 'n'
0176+  121A C6 39 12      je _gets_LF
0177+  121D 76 72         cmp ah, 'r'
0178+  121F C6 40 12      je _gets_CR
0179+  1222 76 30         cmp ah, '0'
0180+  1224 C6 47 12      je _gets_NULL
0181+  1227 76 5C         cmp ah, $5C  ; '\'
0182+  1229 C6 32 12      je _gets_slash
0183+  122C 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0184+  122D 3E            mov [d], al
0185+  122E 79            inc d
0186+  122F 0A B7 11      jmp _gets_loop
0187+  1232             _gets_slash:
0188+  1232 19 5C         mov al, $5C
0189+  1234 3E            mov [d], al
0190+  1235 79            inc d
0191+  1236 0A B7 11      jmp _gets_loop
0192+  1239             _gets_LF:
0193+  1239 19 0A         mov al, $0A
0194+  123B 3E            mov [d], al
0195+  123C 79            inc d
0196+  123D 0A B7 11      jmp _gets_loop
0197+  1240             _gets_CR:
0198+  1240 19 0D         mov al, $0D
0199+  1242 3E            mov [d], al
0200+  1243 79            inc d
0201+  1244 0A B7 11      jmp _gets_loop
0202+  1247             _gets_NULL:
0203+  1247 19 00         mov al, $00
0204+  1249 3E            mov [d], al
0205+  124A 79            inc d
0206+  124B 0A B7 11      jmp _gets_loop
0207+  124E             _gets_end:
0208+  124E 19 00         mov al, 0
0209+  1250 3E            mov [d], al        ; terminate string
0210+  1251 E7            pop d
0211+  1252 E4            pop a
0212+  1253 09            ret
0213+  1254             
0214+  1254             ;-----------------------------------------------------------------------------
0215+  1254             ;; INPUT TEXT
0216+  1254             ;; terminated with CTRL+D
0217+  1254             ;; pointer in D
0218+  1254             ;-----------------------------------------------------------------------------
0219+  1254             _gettxt:
0220+  1254 D7            push a
0221+  1255 DA            push d
0222+  1256             _gettxt_loop:
0223+  1256 19 01         mov al, 1
0224+  1258 05 03         syscall sys_io      ; receive in AH
0225+  125A B9 00         cmp al, 0        ; check error code (AL)
0226+  125C C6 56 12      je _gettxt_loop    ; if no char received, retry
0227+  125F 76 04         cmp ah, 4      ; EOT
0228+  1261 C6 9F 12      je _gettxt_end
0229+  1264 76 08         cmp ah, $08      ; check for backspace
0230+  1266 C6 9B 12      je _gettxt_backspace
0231+  1269 76 5C         cmp ah, $5C        ; '\'
0232+  126B C6 74 12      je _gettxt_escape
0233+  126E 1A            mov al, ah
0234+  126F 3E            mov [d], al
0235+  1270 79            inc d
0236+  1271 0A 56 12      jmp _gettxt_loop
0237+  1274             _gettxt_escape:
0238+  1274 19 01         mov al, 1
0239+  1276 05 03         syscall sys_io      ; receive in AH
0240+  1278 B9 00         cmp al, 0        ; check error code (AL)
0241+  127A C6 74 12      je _gettxt_escape    ; if no char received, retry
0242+  127D 76 6E         cmp ah, 'n'
0243+  127F C6 8D 12      je _gettxt_LF
0244+  1282 76 72         cmp ah, 'r'
0245+  1284 C6 94 12      je _gettxt_CR
0246+  1287 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0247+  1288 3E            mov [d], al
0248+  1289 79            inc d
0249+  128A 0A 56 12      jmp _gettxt_loop
0250+  128D             _gettxt_LF:
0251+  128D 19 0A         mov al, $0A
0252+  128F 3E            mov [d], al
0253+  1290 79            inc d
0254+  1291 0A 56 12      jmp _gettxt_loop
0255+  1294             _gettxt_CR:
0256+  1294 19 0D         mov al, $0D
0257+  1296 3E            mov [d], al
0258+  1297 79            inc d
0259+  1298 0A 56 12      jmp _gettxt_loop
0260+  129B             _gettxt_backspace:
0261+  129B 7F            dec d
0262+  129C 0A 56 12      jmp _gettxt_loop
0263+  129F             _gettxt_end:
0264+  129F 19 00         mov al, 0
0265+  12A1 3E            mov [d], al        ; terminate string
0266+  12A2 E7            pop d
0267+  12A3 E4            pop a
0268+  12A4 09            ret
0269+  12A5             
0270+  12A5             ;-----------------------------------------------------------------------------
0271+  12A5             ; PRINT NEW LINE
0272+  12A5             ;-----------------------------------------------------------------------------
0273+  12A5             printnl:
0274+  12A5 D7            push a
0275+  12A6 10 00 0A      mov a, $0A00
0276+  12A9 05 03         syscall sys_io
0277+  12AB 10 00 0D      mov a, $0D00
0278+  12AE 05 03         syscall sys_io
0279+  12B0 E4            pop a
0280+  12B1 09            ret
0281+  12B2             
0282+  12B2             ;-----------------------------------------------------------------------------
0283+  12B2             ; _strtoint
0284+  12B2             ; 4 digit hex string number in d
0285+  12B2             ; integer returned in A
0286+  12B2             ;-----------------------------------------------------------------------------
0287+  12B2             _strtointx:
0288+  12B2 D8            push b
0289+  12B3 32            mov bl, [d]
0290+  12B4 37            mov bh, bl
0291+  12B5 33 01 00      mov bl, [d + 1]
0292+  12B8 07 6B 11      call _atoi        ; convert to int in AL
0293+  12BB 23            mov ah, al        ; move to AH
0294+  12BC 33 02 00      mov bl, [d + 2]
0295+  12BF 37            mov bh, bl
0296+  12C0 33 03 00      mov bl, [d + 3]
0297+  12C3 07 6B 11      call _atoi        ; convert to int in AL
0298+  12C6 E5            pop b
0299+  12C7 09            ret
0300+  12C8             
0301+  12C8             ;-----------------------------------------------------------------------------
0302+  12C8             ; _strtoint
0303+  12C8             ; 5 digit base10 string number in d
0304+  12C8             ; integer returned in A
0305+  12C8             ;-----------------------------------------------------------------------------
0306+  12C8             _strtoint:
0307+  12C8 E2            push si
0308+  12C9 D8            push b
0309+  12CA D9            push c
0310+  12CB DA            push d
0311+  12CC 07 0D 11      call _strlen      ; get string length in C
0312+  12CF 7E            dec c
0313+  12D0 FD 4E         mov si, d
0314+  12D2 12            mov a, c
0315+  12D3 FD 99         shl a
0316+  12D5 3B 44 14      mov d, table_power
0317+  12D8 59            add d, a
0318+  12D9 38 00 00      mov c, 0
0319+  12DC             _strtoint_L0:
0320+  12DC F6            lodsb      ; load ASCII to al
0321+  12DD B9 00         cmp al, 0
0322+  12DF C6 F2 12      je _strtoint_end
0323+  12E2 6F 30         sub al, $30    ; make into integer
0324+  12E4 22 00         mov ah, 0
0325+  12E6 2A            mov b, [d]
0326+  12E7 AC            mul a, b      ; result in B since it fits in 16bits
0327+  12E8 11            mov a, b
0328+  12E9 28            mov b, c
0329+  12EA 54            add a, b
0330+  12EB 39            mov c, a
0331+  12EC 63 02 00      sub d, 2
0332+  12EF 0A DC 12      jmp _strtoint_L0
0333+  12F2             _strtoint_end:
0334+  12F2 12            mov a, c
0335+  12F3 E7            pop d
0336+  12F4 E6            pop c
0337+  12F5 E5            pop b
0338+  12F6 EF            pop si
0339+  12F7 09            ret
0340+  12F8             
0341+  12F8             ;-----------------------------------------------------------------------------
0342+  12F8             ; PRINT NULL TERMINATED STRING
0343+  12F8             ; pointer in D
0344+  12F8             ;-----------------------------------------------------------------------------
0345+  12F8             _puts:
0346+  12F8 D7            push a
0347+  12F9 DA            push d
0348+  12FA             _puts_L1:
0349+  12FA 1E            mov al, [d]
0350+  12FB B9 00         cmp al, 0
0351+  12FD C6 09 13      jz _puts_END
0352+  1300 23            mov ah, al
0353+  1301 19 00         mov al, 0
0354+  1303 05 03         syscall sys_io
0355+  1305 79            inc d
0356+  1306 0A FA 12      jmp _puts_L1
0357+  1309             _puts_END:
0358+  1309 E7            pop d
0359+  130A E4            pop a
0360+  130B 09            ret
0361+  130C             
0362+  130C             ;-----------------------------------------------------------------------------
0363+  130C             ; PRINT N SIZE STRING
0364+  130C             ; pointer in D
0365+  130C             ; size in C
0366+  130C             ;-----------------------------------------------------------------------------
0367+  130C             _putsn:
0368+  130C DB            push al
0369+  130D DA            push d
0370+  130E D9            push c
0371+  130F             _putsn_L0:
0372+  130F 1E            mov al, [d]
0373+  1310 23            mov ah, al
0374+  1311 19 00         mov al, 0
0375+  1313 05 03         syscall sys_io
0376+  1315 79            inc d
0377+  1316 7E            dec c  
0378+  1317 C2 00 00      cmp c, 0
0379+  131A C7 0F 13      jne _putsn_L0
0380+  131D             _putsn_end:
0381+  131D E6            pop c
0382+  131E E7            pop d
0383+  131F E8            pop al
0384+  1320 09            ret
0385+  1321             
0386+  1321             ;-----------------------------------------------------------------------------
0387+  1321             ; print 16bit decimal number
0388+  1321             ; input number in A
0389+  1321             ;-----------------------------------------------------------------------------
0390+  1321             print_u16d:
0391+  1321 D7            push a
0392+  1322 D8            push b
0393+  1323 26 10 27      mov b, 10000
0394+  1326 AE            div a, b      ; get 10000's coeff.
0395+  1327 07 49 13      call print_number
0396+  132A 11            mov a, b
0397+  132B 26 E8 03      mov b, 1000
0398+  132E AE            div a, b      ; get 1000's coeff.
0399+  132F 07 49 13      call print_number
0400+  1332 11            mov a, b
0401+  1333 26 64 00      mov b, 100
0402+  1336 AE            div a, b
0403+  1337 07 49 13      call print_number
0404+  133A 11            mov a, b
0405+  133B 26 0A 00      mov b, 10
0406+  133E AE            div a, b
0407+  133F 07 49 13      call print_number
0408+  1342 1B            mov al, bl      ; 1's coeff in bl
0409+  1343 07 49 13      call print_number
0410+  1346 E5            pop b
0411+  1347 E4            pop a
0412+  1348 09            ret
0413+  1349             
0414+  1349             ;-----------------------------------------------------------------------------
0415+  1349             ; print AL
0416+  1349             ;-----------------------------------------------------------------------------
0417+  1349             print_number:
0418+  1349 6A 30         add al, $30
0419+  134B 23            mov ah, al
0420+  134C 07 AE 11      call _putchar
0421+  134F 09            ret
0422+  1350             
0423+  1350             ;-----------------------------------------------------------------------------
0424+  1350             ; PRINT 16BIT HEX INTEGER
0425+  1350             ; integer value in reg B
0426+  1350             ;-----------------------------------------------------------------------------
0427+  1350             print_u16x:
0428+  1350 D7            push a
0429+  1351 D8            push b
0430+  1352 DD            push bl
0431+  1353 30            mov bl, bh
0432+  1354 07 7C 11      call _itoa        ; convert bh to char in A
0433+  1357 2F            mov bl, al        ; save al
0434+  1358 19 00         mov al, 0
0435+  135A 05 03         syscall sys_io        ; display AH
0436+  135C 24            mov ah, bl        ; retrieve al
0437+  135D 19 00         mov al, 0
0438+  135F 05 03         syscall sys_io        ; display AL
0439+  1361             
0440+  1361 EA            pop bl
0441+  1362 07 7C 11      call _itoa        ; convert bh to char in A
0442+  1365 2F            mov bl, al        ; save al
0443+  1366 19 00         mov al, 0
0444+  1368 05 03         syscall sys_io        ; display AH
0445+  136A 24            mov ah, bl        ; retrieve al
0446+  136B 19 00         mov al, 0
0447+  136D 05 03         syscall sys_io        ; display AL
0448+  136F             
0449+  136F E5            pop b
0450+  1370 E4            pop a
0451+  1371 09            ret
0452+  1372             
0453+  1372             ;-----------------------------------------------------------------------------
0454+  1372             ; INPUT 16BIT HEX INTEGER
0455+  1372             ; read 16bit integer into A
0456+  1372             ;-----------------------------------------------------------------------------
0457+  1372             scan_u16x:
0458+  1372 F8 10 00      enter 16
0459+  1375 D8            push b
0460+  1376 DA            push d
0461+  1377             
0462+  1377 FA F1 FF      lea d, [bp + -15]
0463+  137A 07 B5 11      call _gets        ; get number
0464+  137D             
0465+  137D 32            mov bl, [d]
0466+  137E 37            mov bh, bl
0467+  137F 33 01 00      mov bl, [d + 1]
0468+  1382 07 6B 11      call _atoi        ; convert to int in AL
0469+  1385 23            mov ah, al        ; move to AH
0470+  1386             
0471+  1386 33 02 00      mov bl, [d + 2]
0472+  1389 37            mov bh, bl
0473+  138A 33 03 00      mov bl, [d + 3]
0474+  138D 07 6B 11      call _atoi        ; convert to int in AL
0475+  1390             
0476+  1390 E7            pop d
0477+  1391 E5            pop b
0478+  1392 F9            leave
0479+  1393 09            ret
0480+  1394             
0481+  1394             ;-----------------------------------------------------------------------------
0482+  1394             ; PRINT 8bit HEX INTEGER
0483+  1394             ; integer value in reg bl
0484+  1394             ;-----------------------------------------------------------------------------
0485+  1394             print_u8x:
0486+  1394 D7            push a
0487+  1395 DD            push bl
0488+  1396             
0489+  1396 07 7C 11      call _itoa        ; convert bl to char in A
0490+  1399 2F            mov bl, al        ; save al
0491+  139A 19 00         mov al, 0
0492+  139C 05 03         syscall sys_io        ; display AH
0493+  139E 24            mov ah, bl        ; retrieve al
0494+  139F 19 00         mov al, 0
0495+  13A1 05 03         syscall sys_io        ; display AL
0496+  13A3             
0497+  13A3 EA            pop bl
0498+  13A4 E4            pop a
0499+  13A5 09            ret
0500+  13A6             
0501+  13A6             ;-----------------------------------------------------------------------------
0502+  13A6             ; print 8bit decimal unsigned number
0503+  13A6             ; input number in AL
0504+  13A6             ;-----------------------------------------------------------------------------
0505+  13A6             print_u8d:
0506+  13A6 D7            push a
0507+  13A7 D8            push b
0508+  13A8             
0509+  13A8 22 00         mov ah, 0
0510+  13AA 26 64 00      mov b, 100
0511+  13AD AE            div a, b
0512+  13AE D8            push b      ; save remainder
0513+  13AF B9 00         cmp al, 0
0514+  13B1 C6 BB 13      je skip100
0515+  13B4 6A 30         add al, $30
0516+  13B6 23            mov ah, al
0517+  13B7 19 00         mov al, 0
0518+  13B9 05 03         syscall sys_io  ; print coeff
0519+  13BB             skip100:
0520+  13BB E4            pop a
0521+  13BC 22 00         mov ah, 0
0522+  13BE 26 0A 00      mov b, 10
0523+  13C1 AE            div a, b
0524+  13C2 D8            push b      ; save remainder
0525+  13C3 B9 00         cmp al, 0
0526+  13C5 C6 CF 13      je skip10
0527+  13C8 6A 30         add al, $30
0528+  13CA 23            mov ah, al
0529+  13CB 19 00         mov al, 0
0530+  13CD 05 03         syscall sys_io  ; print coeff
0531+  13CF             skip10:
0532+  13CF E4            pop a
0533+  13D0 1B            mov al, bl
0534+  13D1 6A 30         add al, $30
0535+  13D3 23            mov ah, al
0536+  13D4 19 00         mov al, 0
0537+  13D6 05 03         syscall sys_io  ; print coeff
0538+  13D8 E5            pop b
0539+  13D9 E4            pop a
0540+  13DA 09            ret
0541+  13DB             
0542+  13DB             ;-----------------------------------------------------------------------------
0543+  13DB             ; INPUT 8BIT HEX INTEGER
0544+  13DB             ; read 8bit integer into AL
0545+  13DB             ;-----------------------------------------------------------------------------
0546+  13DB             scan_u8x:
0547+  13DB F8 04 00      enter 4
0548+  13DE D8            push b
0549+  13DF DA            push d
0550+  13E0             
0551+  13E0 FA FD FF      lea d, [bp + -3]
0552+  13E3 07 B5 11      call _gets        ; get number
0553+  13E6             
0554+  13E6 32            mov bl, [d]
0555+  13E7 37            mov bh, bl
0556+  13E8 33 01 00      mov bl, [d + 1]
0557+  13EB 07 6B 11      call _atoi        ; convert to int in AL
0558+  13EE             
0559+  13EE E7            pop d
0560+  13EF E5            pop b
0561+  13F0 F9            leave
0562+  13F1 09            ret
0563+  13F2             
0564+  13F2             ;-----------------------------------------------------------------------------
0565+  13F2             ; input decimal number
0566+  13F2             ; result in A
0567+  13F2             ; 655'\0'
0568+  13F2             ; low--------high
0569+  13F2             ;-----------------------------------------------------------------------------
0570+  13F2             scan_u16d:
0571+  13F2 F8 08 00      enter 8
0572+  13F5 E2            push si
0573+  13F6 D8            push b
0574+  13F7 D9            push c
0575+  13F8 DA            push d
0576+  13F9 FA F9 FF      lea d, [bp +- 7]
0577+  13FC 07 B5 11      call _gets
0578+  13FF 07 0D 11      call _strlen      ; get string length in C
0579+  1402 7E            dec c
0580+  1403 FD 4E         mov si, d
0581+  1405 12            mov a, c
0582+  1406 FD 99         shl a
0583+  1408 3B 44 14      mov d, table_power
0584+  140B 59            add d, a
0585+  140C 38 00 00      mov c, 0
0586+  140F             mul_loop:
0587+  140F F6            lodsb      ; load ASCII to al
0588+  1410 B9 00         cmp al, 0
0589+  1412 C6 25 14      je mul_exit
0590+  1415 6F 30         sub al, $30    ; make into integer
0591+  1417 22 00         mov ah, 0
0592+  1419 2A            mov b, [d]
0593+  141A AC            mul a, b      ; result in B since it fits in 16bits
0594+  141B 11            mov a, b
0595+  141C 28            mov b, c
0596+  141D 54            add a, b
0597+  141E 39            mov c, a
0598+  141F 63 02 00      sub d, 2
0599+  1422 0A 0F 14      jmp mul_loop
0600+  1425             mul_exit:
0601+  1425 12            mov a, c
0602+  1426 E7            pop d
0603+  1427 E6            pop c
0604+  1428 E5            pop b
0605+  1429 EF            pop si
0606+  142A F9            leave
0607+  142B 09            ret
0608+  142C             
0609+  142C 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0609+  1430 34 35 36 37 
0609+  1434 38 39 41 42 
0609+  1438 43 44 45 46 
0610+  143C 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0610+  1440 1B 5B 48 00 
0611+  1444             
0612+  1444             table_power:
0613+  1444 01 00         .dw 1
0614+  1446 0A 00         .dw 10
0615+  1448 64 00         .dw 100
0616+  144A E8 03         .dw 1000
0617+  144C 10 27         .dw 100002436   144E             ; --- END INLINE ASM BLOCK
2437   144E             
2438   144E F9            leave
2439   144F 09            ret
2440   1450             ; --- END TEXT BLOCK
2441   1450             
2442   1450             ; --- BEGIN DATA BLOCK
2443   1450 55 6E 65 78 __s0: .db "Unexpected format in printf.", 0
2443   1454 70 65 63 74 
2443   1458 65 64 20 66 
2443   145C 6F 72 6D 61 
2443   1460 74 20 69 6E 
2443   1464 20 70 72 69 
2443   1468 6E 74 66 2E 
2443   146C 00 
2444   146D 45 72 72 6F __s1: .db "Error: Unknown argument type.\n", 0
2444   1471 72 3A 20 55 
2444   1475 6E 6B 6E 6F 
2444   1479 77 6E 20 61 
2444   147D 72 67 75 6D 
2444   1481 65 6E 74 20 
2444   1485 74 79 70 65 
2444   1489 2E 0A 00 
2445   148C 1B 5B 32 4A __s2: .db "\033[2J\033[H", 0
2445   1490 1B 5B 48 00 
2446   1494             
2447   1494 96 14       _heap_top: .dw _heap
2448   1496 00          _heap: .db 0
2449   1497             ; --- END DATA BLOCK
2450   1497             
2451   1497             .end
tasm: Number of errors = 0
