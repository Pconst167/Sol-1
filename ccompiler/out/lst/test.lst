0001   0000             ; --- FILENAME: test
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; $a 
0011   0408             ; $b 
0012   0408 52 08 00      sub sp, 8
0013   040B             ;; a = 0xF0000000; 
0014   040B FA FD FF      lea d, [bp + -3] ; $a
0015   040E DA            push d
0016   040F 26 00 00      mov b, 0
0017   0412 38 00 F0      mov c, 61440
0018   0415 E7            pop d
0019   0416 FD 43         mov [d], b
0020   0418 28            mov b, c
0021   0419 FD 44 02 00   mov [d + 2], b
0022   041D             ;; b = 1; 
0023   041D FA F9 FF      lea d, [bp + -7] ; $b
0024   0420 DA            push d
0025   0421 26 01 00      mov b, $1
0026   0424 E7            pop d
0027   0425 FD 43         mov [d], b
0028   0427 28            mov b, c
0029   0428 FD 44 02 00   mov [d + 2], b
0030   042C             ;; printf("Result: %d\n", a || b); 
0031   042C FA FD FF      lea d, [bp + -3] ; $a
0032   042F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0033   0432 FD 39         mov c, b ; And place it into C
0034   0434 2A            mov b, [d] ; Lower Word in B
0035   0435 D7            push a
0036   0436 FD D8         push g
0037   0438 11            mov a, b
0038   0439 FD 7A         mov g, c
0039   043B FA F9 FF      lea d, [bp + -7] ; $b
0040   043E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0041   0441 FD 39         mov c, b ; And place it into C
0042   0443 2A            mov b, [d] ; Lower Word in B
0043   0444 FD A8         sor a, b ; ||
0044   0446 D8            push b
0045   0447 FD 27         mov b, g
0046   0449 12            mov a, c
0047   044A FD A8         sor a, b ; ||
0048   044C E4            pop a
0049   044D FD A8         sor a, b ; ||
0050   044F FD F1         pop g
0051   0451 E4            pop a
0052   0452 FD 79         mov g, b
0053   0454 28            mov b, c
0054   0455 FD AB         swp b
0055   0457 D8            push b
0056   0458 FD 27         mov b, g
0057   045A FD AB         swp b
0058   045C D8            push b
0059   045D 26 3C 15      mov b, __s0 ; "Result: %d\n"
0060   0460 FD AB         swp b
0061   0462 D8            push b
0062   0463 07 B5 08      call printf
0063   0466 51 06 00      add sp, 6
0064   0469             ;; printf("Result: %d\n", a && b); 
0065   0469 FA FD FF      lea d, [bp + -3] ; $a
0066   046C 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0067   046F FD 39         mov c, b ; And place it into C
0068   0471 2A            mov b, [d] ; Lower Word in B
0069   0472 D7            push a
0070   0473 FD D8         push g
0071   0475 11            mov a, b
0072   0476 FD 7A         mov g, c
0073   0478 FA F9 FF      lea d, [bp + -7] ; $b
0074   047B 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0075   047E FD 39         mov c, b ; And place it into C
0076   0480 2A            mov b, [d] ; Lower Word in B
0077   0481 D7            push a
0078   0482 FD D8         push g
0079   0484 C0 00 00      cmp b, 0
0080   0487 FD 72         sneq
0081   0489 DD            push bl
0082   048A C2 00 00      cmp c, 0
0083   048D FD 72         sneq
0084   048F E8            pop al
0085   0490 8C            or al, bl
0086   0491 E6            pop c
0087   0492 E5            pop b
0088   0493 DB            push al
0089   0494 C0 00 00      cmp b, 0
0090   0497 FD 72         sneq
0091   0499 DD            push bl
0092   049A C2 00 00      cmp c, 0
0093   049D FD 72         sneq
0094   049F E8            pop al
0095   04A0 8C            or al, bl
0096   04A1 EA            pop bl
0097   04A2 22 00         mov ah, 0
0098   04A4 FD A7         sand a, b
0099   04A6 FD F1         pop g
0100   04A8 E4            pop a
0101   04A9 FD 79         mov g, b
0102   04AB 28            mov b, c
0103   04AC FD AB         swp b
0104   04AE D8            push b
0105   04AF FD 27         mov b, g
0106   04B1 FD AB         swp b
0107   04B3 D8            push b
0108   04B4 26 3C 15      mov b, __s0 ; "Result: %d\n"
0109   04B7 FD AB         swp b
0110   04B9 D8            push b
0111   04BA 07 B5 08      call printf
0112   04BD 51 06 00      add sp, 6
0113   04C0 05 0B         syscall sys_terminate_proc
0114   04C2             
0115   04C2             strcpy:
0116   04C2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0117   04C5             ; $psrc 
0118   04C5             ; $pdest 
0119   04C5 52 04 00      sub sp, 4
0120   04C8             ;; psrc = src; 
0121   04C8 FA FF FF      lea d, [bp + -1] ; $psrc
0122   04CB DA            push d
0123   04CC FA 07 00      lea d, [bp + 7] ; $src
0124   04CF 2A            mov b, [d]
0125   04D0 E7            pop d
0126   04D1 FD 43         mov [d], b
0127   04D3             ;; pdest = dest; 
0128   04D3 FA FD FF      lea d, [bp + -3] ; $pdest
0129   04D6 DA            push d
0130   04D7 FA 05 00      lea d, [bp + 5] ; $dest
0131   04DA 2A            mov b, [d]
0132   04DB E7            pop d
0133   04DC FD 43         mov [d], b
0134   04DE             ;; while(*psrc) *pdest++ = *psrc++; 
0135   04DE             _while1_cond:
0136   04DE FA FF FF      lea d, [bp + -1] ; $psrc
0137   04E1 2A            mov b, [d]
0138   04E2 74            mov d, b
0139   04E3 32            mov bl, [d]
0140   04E4 A7 00         mov bh, 0
0141   04E6 C0 00 00      cmp b, 0
0142   04E9 C6 11 05      je _while1_exit
0143   04EC             _while1_block:
0144   04EC             ;; *pdest++ = *psrc++; 
0145   04EC FA FD FF      lea d, [bp + -3] ; $pdest
0146   04EF 2A            mov b, [d]
0147   04F0 D8            push b
0148   04F1 FD 77         inc b
0149   04F3 FA FD FF      lea d, [bp + -3] ; $pdest
0150   04F6 FD 43         mov [d], b
0151   04F8 E5            pop b
0152   04F9 D8            push b
0153   04FA FA FF FF      lea d, [bp + -1] ; $psrc
0154   04FD 2A            mov b, [d]
0155   04FE D8            push b
0156   04FF FD 77         inc b
0157   0501 FA FF FF      lea d, [bp + -1] ; $psrc
0158   0504 FD 43         mov [d], b
0159   0506 E5            pop b
0160   0507 74            mov d, b
0161   0508 32            mov bl, [d]
0162   0509 A7 00         mov bh, 0
0163   050B E7            pop d
0164   050C FD 3E         mov [d], bl
0165   050E 0A DE 04      jmp _while1_cond
0166   0511             _while1_exit:
0167   0511             ;; *pdest = '\0'; 
0168   0511 FA FD FF      lea d, [bp + -3] ; $pdest
0169   0514 2A            mov b, [d]
0170   0515 D8            push b
0171   0516 26 00 00      mov b, $0
0172   0519 E7            pop d
0173   051A FD 3E         mov [d], bl
0174   051C F9            leave
0175   051D 09            ret
0176   051E             
0177   051E             strcmp:
0178   051E F8 00 00      enter 0 ; (push bp; mov bp, sp)
0179   0521             ;; while (*s1 && (*s1 == *s2)) { 
0180   0521             _while2_cond:
0181   0521 FA 05 00      lea d, [bp + 5] ; $s1
0182   0524 2A            mov b, [d]
0183   0525 74            mov d, b
0184   0526 32            mov bl, [d]
0185   0527 A7 00         mov bh, 0
0186   0529 D7            push a
0187   052A 11            mov a, b
0188   052B FA 05 00      lea d, [bp + 5] ; $s1
0189   052E 2A            mov b, [d]
0190   052F 74            mov d, b
0191   0530 32            mov bl, [d]
0192   0531 A7 00         mov bh, 0
0193   0533             ; START RELATIONAL
0194   0533 D7            push a
0195   0534 11            mov a, b
0196   0535 FA 07 00      lea d, [bp + 7] ; $s2
0197   0538 2A            mov b, [d]
0198   0539 74            mov d, b
0199   053A 32            mov bl, [d]
0200   053B A7 00         mov bh, 0
0201   053D B0            cmp a, b
0202   053E FD 71         seq ; ==
0203   0540 E4            pop a
0204   0541             ; END RELATIONAL
0205   0541 FD A7         sand a, b ; &&
0206   0543 E4            pop a
0207   0544 C0 00 00      cmp b, 0
0208   0547 C6 67 05      je _while2_exit
0209   054A             _while2_block:
0210   054A             ;; s1++; 
0211   054A FA 05 00      lea d, [bp + 5] ; $s1
0212   054D 2A            mov b, [d]
0213   054E D8            push b
0214   054F FD 77         inc b
0215   0551 FA 05 00      lea d, [bp + 5] ; $s1
0216   0554 FD 43         mov [d], b
0217   0556 E5            pop b
0218   0557             ;; s2++; 
0219   0557 FA 07 00      lea d, [bp + 7] ; $s2
0220   055A 2A            mov b, [d]
0221   055B D8            push b
0222   055C FD 77         inc b
0223   055E FA 07 00      lea d, [bp + 7] ; $s2
0224   0561 FD 43         mov [d], b
0225   0563 E5            pop b
0226   0564 0A 21 05      jmp _while2_cond
0227   0567             _while2_exit:
0228   0567             ;; return *s1 - *s2; 
0229   0567 FA 05 00      lea d, [bp + 5] ; $s1
0230   056A 2A            mov b, [d]
0231   056B 74            mov d, b
0232   056C 32            mov bl, [d]
0233   056D A7 00         mov bh, 0
0234   056F             ; START TERMS
0235   056F D7            push a
0236   0570 11            mov a, b
0237   0571 FA 07 00      lea d, [bp + 7] ; $s2
0238   0574 2A            mov b, [d]
0239   0575 74            mov d, b
0240   0576 32            mov bl, [d]
0241   0577 A7 00         mov bh, 0
0242   0579 60            sub a, b
0243   057A 27            mov b, a
0244   057B E4            pop a
0245   057C             ; END TERMS
0246   057C F9            leave
0247   057D 09            ret
0248   057E             
0249   057E             strcat:
0250   057E F8 00 00      enter 0 ; (push bp; mov bp, sp)
0251   0581             ; $dest_len 
0252   0581             ; $i 
0253   0581 52 04 00      sub sp, 4
0254   0584             ;; dest_len = strlen(dest); 
0255   0584 FA FF FF      lea d, [bp + -1] ; $dest_len
0256   0587 DA            push d
0257   0588 FA 05 00      lea d, [bp + 5] ; $dest
0258   058B 2A            mov b, [d]
0259   058C FD AB         swp b
0260   058E D8            push b
0261   058F 07 31 06      call strlen
0262   0592 51 02 00      add sp, 2
0263   0595 E7            pop d
0264   0596 FD 43         mov [d], b
0265   0598             ;; for (i = 0; src[i] != 0; i=i+1) { 
0266   0598             _for3_init:
0267   0598 FA FD FF      lea d, [bp + -3] ; $i
0268   059B DA            push d
0269   059C 26 00 00      mov b, $0
0270   059F E7            pop d
0271   05A0 FD 43         mov [d], b
0272   05A2             _for3_cond:
0273   05A2 FA 07 00      lea d, [bp + 7] ; $src
0274   05A5 FD 2A         mov d, [d]
0275   05A7 D7            push a
0276   05A8 DA            push d
0277   05A9 FA FD FF      lea d, [bp + -3] ; $i
0278   05AC 2A            mov b, [d]
0279   05AD E7            pop d
0280   05AE FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0281   05B2 E4            pop a
0282   05B3 32            mov bl, [d]
0283   05B4 A7 00         mov bh, 0
0284   05B6             ; START RELATIONAL
0285   05B6 D7            push a
0286   05B7 11            mov a, b
0287   05B8 26 00 00      mov b, $0
0288   05BB B0            cmp a, b
0289   05BC FD 72         sneq ; !=
0290   05BE E4            pop a
0291   05BF             ; END RELATIONAL
0292   05BF C0 00 00      cmp b, 0
0293   05C2 C6 0B 06      je _for3_exit
0294   05C5             _for3_block:
0295   05C5             ;; dest[dest_len + i] = src[i]; 
0296   05C5 FA 05 00      lea d, [bp + 5] ; $dest
0297   05C8 FD 2A         mov d, [d]
0298   05CA D7            push a
0299   05CB DA            push d
0300   05CC FA FF FF      lea d, [bp + -1] ; $dest_len
0301   05CF 2A            mov b, [d]
0302   05D0             ; START TERMS
0303   05D0 D7            push a
0304   05D1 11            mov a, b
0305   05D2 FA FD FF      lea d, [bp + -3] ; $i
0306   05D5 2A            mov b, [d]
0307   05D6 56            add b, a
0308   05D7 E4            pop a
0309   05D8             ; END TERMS
0310   05D8 E7            pop d
0311   05D9 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0312   05DD E4            pop a
0313   05DE DA            push d
0314   05DF FA 07 00      lea d, [bp + 7] ; $src
0315   05E2 FD 2A         mov d, [d]
0316   05E4 D7            push a
0317   05E5 DA            push d
0318   05E6 FA FD FF      lea d, [bp + -3] ; $i
0319   05E9 2A            mov b, [d]
0320   05EA E7            pop d
0321   05EB FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0322   05EF E4            pop a
0323   05F0 32            mov bl, [d]
0324   05F1 A7 00         mov bh, 0
0325   05F3 E7            pop d
0326   05F4 FD 3E         mov [d], bl
0327   05F6             _for3_update:
0328   05F6 FA FD FF      lea d, [bp + -3] ; $i
0329   05F9 DA            push d
0330   05FA FA FD FF      lea d, [bp + -3] ; $i
0331   05FD 2A            mov b, [d]
0332   05FE             ; START TERMS
0333   05FE D7            push a
0334   05FF 11            mov a, b
0335   0600 26 01 00      mov b, $1
0336   0603 56            add b, a
0337   0604 E4            pop a
0338   0605             ; END TERMS
0339   0605 E7            pop d
0340   0606 FD 43         mov [d], b
0341   0608 0A A2 05      jmp _for3_cond
0342   060B             _for3_exit:
0343   060B             ;; dest[dest_len + i] = 0; 
0344   060B FA 05 00      lea d, [bp + 5] ; $dest
0345   060E FD 2A         mov d, [d]
0346   0610 D7            push a
0347   0611 DA            push d
0348   0612 FA FF FF      lea d, [bp + -1] ; $dest_len
0349   0615 2A            mov b, [d]
0350   0616             ; START TERMS
0351   0616 D7            push a
0352   0617 11            mov a, b
0353   0618 FA FD FF      lea d, [bp + -3] ; $i
0354   061B 2A            mov b, [d]
0355   061C 56            add b, a
0356   061D E4            pop a
0357   061E             ; END TERMS
0358   061E E7            pop d
0359   061F FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0360   0623 E4            pop a
0361   0624 DA            push d
0362   0625 26 00 00      mov b, $0
0363   0628 E7            pop d
0364   0629 FD 3E         mov [d], bl
0365   062B             ;; return dest; 
0366   062B FA 05 00      lea d, [bp + 5] ; $dest
0367   062E 2A            mov b, [d]
0368   062F F9            leave
0369   0630 09            ret
0370   0631             
0371   0631             strlen:
0372   0631 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0373   0634             ; $length 
0374   0634 52 02 00      sub sp, 2
0375   0637             ;; length = 0; 
0376   0637 FA FF FF      lea d, [bp + -1] ; $length
0377   063A DA            push d
0378   063B 26 00 00      mov b, $0
0379   063E E7            pop d
0380   063F FD 43         mov [d], b
0381   0641             ;; while (str[length] != 0) { 
0382   0641             _while4_cond:
0383   0641 FA 05 00      lea d, [bp + 5] ; $str
0384   0644 FD 2A         mov d, [d]
0385   0646 D7            push a
0386   0647 DA            push d
0387   0648 FA FF FF      lea d, [bp + -1] ; $length
0388   064B 2A            mov b, [d]
0389   064C E7            pop d
0390   064D FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0391   0651 E4            pop a
0392   0652 32            mov bl, [d]
0393   0653 A7 00         mov bh, 0
0394   0655             ; START RELATIONAL
0395   0655 D7            push a
0396   0656 11            mov a, b
0397   0657 26 00 00      mov b, $0
0398   065A B0            cmp a, b
0399   065B FD 72         sneq ; !=
0400   065D E4            pop a
0401   065E             ; END RELATIONAL
0402   065E C0 00 00      cmp b, 0
0403   0661 C6 74 06      je _while4_exit
0404   0664             _while4_block:
0405   0664             ;; length++; 
0406   0664 FA FF FF      lea d, [bp + -1] ; $length
0407   0667 2A            mov b, [d]
0408   0668 D8            push b
0409   0669 FD 77         inc b
0410   066B FA FF FF      lea d, [bp + -1] ; $length
0411   066E FD 43         mov [d], b
0412   0670 E5            pop b
0413   0671 0A 41 06      jmp _while4_cond
0414   0674             _while4_exit:
0415   0674             ;; return length; 
0416   0674 FA FF FF      lea d, [bp + -1] ; $length
0417   0677 2A            mov b, [d]
0418   0678 F9            leave
0419   0679 09            ret
0420   067A             
0421   067A             scanf:
0422   067A F8 00 00      enter 0 ; (push bp; mov bp, sp)
0423   067D             ; $p 
0424   067D             ; $format_p 
0425   067D             ; $c 
0426   067D             ; $i 
0427   067D             ; $input_string 
0428   067D 52 07 02      sub sp, 519
0429   0680             ;; format_p = format; 
0430   0680 FA FD FF      lea d, [bp + -3] ; $format_p
0431   0683 DA            push d
0432   0684 FA 05 00      lea d, [bp + 5] ; $format
0433   0687 2A            mov b, [d]
0434   0688 E7            pop d
0435   0689 FD 43         mov [d], b
0436   068B             ;; p = &format + 2; 
0437   068B FA FF FF      lea d, [bp + -1] ; $p
0438   068E DA            push d
0439   068F FA 05 00      lea d, [bp + 5] ; $format
0440   0692 2D            mov b, d
0441   0693             ; START TERMS
0442   0693 D7            push a
0443   0694 11            mov a, b
0444   0695 26 02 00      mov b, $2
0445   0698 56            add b, a
0446   0699 E4            pop a
0447   069A             ; END TERMS
0448   069A E7            pop d
0449   069B FD 43         mov [d], b
0450   069D             ;; for(;;){ 
0451   069D             _for5_init:
0452   069D             _for5_cond:
0453   069D             _for5_block:
0454   069D             ;; if(!*format_p) break; 
0455   069D             _if6_cond:
0456   069D FA FD FF      lea d, [bp + -3] ; $format_p
0457   06A0 2A            mov b, [d]
0458   06A1 74            mov d, b
0459   06A2 32            mov bl, [d]
0460   06A3 A7 00         mov bh, 0
0461   06A5 C0 00 00      cmp b, 0
0462   06A8 FD 71         seq ; !
0463   06AA C0 00 00      cmp b, 0
0464   06AD C6 B6 06      je _if6_else
0465   06B0             _if6_true:
0466   06B0             ;; break; 
0467   06B0 0A B3 08      jmp _for5_exit ; for break
0468   06B3 0A B0 08      jmp _if6_exit
0469   06B6             _if6_else:
0470   06B6             ;; if(*format_p == '%'){ 
0471   06B6             _if7_cond:
0472   06B6 FA FD FF      lea d, [bp + -3] ; $format_p
0473   06B9 2A            mov b, [d]
0474   06BA 74            mov d, b
0475   06BB 32            mov bl, [d]
0476   06BC A7 00         mov bh, 0
0477   06BE             ; START RELATIONAL
0478   06BE D7            push a
0479   06BF 11            mov a, b
0480   06C0 26 25 00      mov b, $25
0481   06C3 B0            cmp a, b
0482   06C4 FD 71         seq ; ==
0483   06C6 E4            pop a
0484   06C7             ; END RELATIONAL
0485   06C7 C0 00 00      cmp b, 0
0486   06CA C6 94 08      je _if7_else
0487   06CD             _if7_true:
0488   06CD             ;; format_p++; 
0489   06CD FA FD FF      lea d, [bp + -3] ; $format_p
0490   06D0 2A            mov b, [d]
0491   06D1 D8            push b
0492   06D2 FD 77         inc b
0493   06D4 FA FD FF      lea d, [bp + -3] ; $format_p
0494   06D7 FD 43         mov [d], b
0495   06D9 E5            pop b
0496   06DA             ;; switch(*format_p){ 
0497   06DA             _switch8_expr:
0498   06DA FA FD FF      lea d, [bp + -3] ; $format_p
0499   06DD 2A            mov b, [d]
0500   06DE 74            mov d, b
0501   06DF 32            mov bl, [d]
0502   06E0 A7 00         mov bh, 0
0503   06E2             _switch8_comparisons:
0504   06E2 C1 6C         cmp bl, $6c
0505   06E4 C6 10 07      je _switch8_case0
0506   06E7 C1 4C         cmp bl, $4c
0507   06E9 C6 10 07      je _switch8_case1
0508   06EC C1 64         cmp bl, $64
0509   06EE C6 A2 07      je _switch8_case2
0510   06F1 C1 69         cmp bl, $69
0511   06F3 C6 A2 07      je _switch8_case3
0512   06F6 C1 75         cmp bl, $75
0513   06F8 C6 CF 07      je _switch8_case4
0514   06FB C1 78         cmp bl, $78
0515   06FD C6 FC 07      je _switch8_case5
0516   0700 C1 63         cmp bl, $63
0517   0702 C6 11 08      je _switch8_case6
0518   0705 C1 73         cmp bl, $73
0519   0707 C6 40 08      je _switch8_case7
0520   070A 0A 78 08      jmp _switch8_default
0521   070D 0A 84 08      jmp _switch8_exit
0522   0710             _switch8_case0:
0523   0710             _switch8_case1:
0524   0710             ;; format_p++; 
0525   0710 FA FD FF      lea d, [bp + -3] ; $format_p
0526   0713 2A            mov b, [d]
0527   0714 D8            push b
0528   0715 FD 77         inc b
0529   0717 FA FD FF      lea d, [bp + -3] ; $format_p
0530   071A FD 43         mov [d], b
0531   071C E5            pop b
0532   071D             ;; if(*format_p == 'd' || *format_p == 'i'); 
0533   071D             _if9_cond:
0534   071D FA FD FF      lea d, [bp + -3] ; $format_p
0535   0720 2A            mov b, [d]
0536   0721 74            mov d, b
0537   0722 32            mov bl, [d]
0538   0723 A7 00         mov bh, 0
0539   0725             ; START RELATIONAL
0540   0725 D7            push a
0541   0726 11            mov a, b
0542   0727 26 64 00      mov b, $64
0543   072A B0            cmp a, b
0544   072B FD 71         seq ; ==
0545   072D E4            pop a
0546   072E             ; END RELATIONAL
0547   072E D7            push a
0548   072F 11            mov a, b
0549   0730 FA FD FF      lea d, [bp + -3] ; $format_p
0550   0733 2A            mov b, [d]
0551   0734 74            mov d, b
0552   0735 32            mov bl, [d]
0553   0736 A7 00         mov bh, 0
0554   0738             ; START RELATIONAL
0555   0738 D7            push a
0556   0739 11            mov a, b
0557   073A 26 69 00      mov b, $69
0558   073D B0            cmp a, b
0559   073E FD 71         seq ; ==
0560   0740 E4            pop a
0561   0741             ; END RELATIONAL
0562   0741 FD A8         sor a, b ; ||
0563   0743 E4            pop a
0564   0744 C0 00 00      cmp b, 0
0565   0747 C6 4D 07      je _if9_else
0566   074A             _if9_true:
0567   074A             ;; ; 
0568   074A 0A 8D 07      jmp _if9_exit
0569   074D             _if9_else:
0570   074D             ;; if(*format_p == 'u'); 
0571   074D             _if10_cond:
0572   074D FA FD FF      lea d, [bp + -3] ; $format_p
0573   0750 2A            mov b, [d]
0574   0751 74            mov d, b
0575   0752 32            mov bl, [d]
0576   0753 A7 00         mov bh, 0
0577   0755             ; START RELATIONAL
0578   0755 D7            push a
0579   0756 11            mov a, b
0580   0757 26 75 00      mov b, $75
0581   075A B0            cmp a, b
0582   075B FD 71         seq ; ==
0583   075D E4            pop a
0584   075E             ; END RELATIONAL
0585   075E C0 00 00      cmp b, 0
0586   0761 C6 67 07      je _if10_else
0587   0764             _if10_true:
0588   0764             ;; ; 
0589   0764 0A 8D 07      jmp _if10_exit
0590   0767             _if10_else:
0591   0767             ;; if(*format_p == 'x'); 
0592   0767             _if11_cond:
0593   0767 FA FD FF      lea d, [bp + -3] ; $format_p
0594   076A 2A            mov b, [d]
0595   076B 74            mov d, b
0596   076C 32            mov bl, [d]
0597   076D A7 00         mov bh, 0
0598   076F             ; START RELATIONAL
0599   076F D7            push a
0600   0770 11            mov a, b
0601   0771 26 78 00      mov b, $78
0602   0774 B0            cmp a, b
0603   0775 FD 71         seq ; ==
0604   0777 E4            pop a
0605   0778             ; END RELATIONAL
0606   0778 C0 00 00      cmp b, 0
0607   077B C6 81 07      je _if11_else
0608   077E             _if11_true:
0609   077E             ;; ; 
0610   077E 0A 8D 07      jmp _if11_exit
0611   0781             _if11_else:
0612   0781             ;; err("Unexpected format in printf."); 
0613   0781 26 48 15      mov b, __s1 ; "Unexpected format in printf."
0614   0784 FD AB         swp b
0615   0786 D8            push b
0616   0787 07 FC 0A      call err
0617   078A 51 02 00      add sp, 2
0618   078D             _if11_exit:
0619   078D             _if10_exit:
0620   078D             _if9_exit:
0621   078D             ;; p = p + 4; 
0622   078D FA FF FF      lea d, [bp + -1] ; $p
0623   0790 DA            push d
0624   0791 FA FF FF      lea d, [bp + -1] ; $p
0625   0794 2A            mov b, [d]
0626   0795             ; START TERMS
0627   0795 D7            push a
0628   0796 11            mov a, b
0629   0797 26 04 00      mov b, $4
0630   079A 56            add b, a
0631   079B E4            pop a
0632   079C             ; END TERMS
0633   079C E7            pop d
0634   079D FD 43         mov [d], b
0635   079F             ;; break; 
0636   079F 0A 84 08      jmp _switch8_exit ; case break
0637   07A2             _switch8_case2:
0638   07A2             _switch8_case3:
0639   07A2             ;; i = scann(); 
0640   07A2 FA FA FF      lea d, [bp + -6] ; $i
0641   07A5 DA            push d
0642   07A6 07 C7 10      call scann
0643   07A9 E7            pop d
0644   07AA FD 43         mov [d], b
0645   07AC             ;; **(int **)p = i; 
0646   07AC FA FF FF      lea d, [bp + -1] ; $p
0647   07AF 2A            mov b, [d]
0648   07B0 74            mov d, b
0649   07B1 2A            mov b, [d]
0650   07B2 D8            push b
0651   07B3 FA FA FF      lea d, [bp + -6] ; $i
0652   07B6 2A            mov b, [d]
0653   07B7 E7            pop d
0654   07B8 FD 43         mov [d], b
0655   07BA             ;; p = p + 2; 
0656   07BA FA FF FF      lea d, [bp + -1] ; $p
0657   07BD DA            push d
0658   07BE FA FF FF      lea d, [bp + -1] ; $p
0659   07C1 2A            mov b, [d]
0660   07C2             ; START TERMS
0661   07C2 D7            push a
0662   07C3 11            mov a, b
0663   07C4 26 02 00      mov b, $2
0664   07C7 56            add b, a
0665   07C8 E4            pop a
0666   07C9             ; END TERMS
0667   07C9 E7            pop d
0668   07CA FD 43         mov [d], b
0669   07CC             ;; break; 
0670   07CC 0A 84 08      jmp _switch8_exit ; case break
0671   07CF             _switch8_case4:
0672   07CF             ;; i = scann(); 
0673   07CF FA FA FF      lea d, [bp + -6] ; $i
0674   07D2 DA            push d
0675   07D3 07 C7 10      call scann
0676   07D6 E7            pop d
0677   07D7 FD 43         mov [d], b
0678   07D9             ;; **(int **)p = i; 
0679   07D9 FA FF FF      lea d, [bp + -1] ; $p
0680   07DC 2A            mov b, [d]
0681   07DD 74            mov d, b
0682   07DE 2A            mov b, [d]
0683   07DF D8            push b
0684   07E0 FA FA FF      lea d, [bp + -6] ; $i
0685   07E3 2A            mov b, [d]
0686   07E4 E7            pop d
0687   07E5 FD 43         mov [d], b
0688   07E7             ;; p = p + 2; 
0689   07E7 FA FF FF      lea d, [bp + -1] ; $p
0690   07EA DA            push d
0691   07EB FA FF FF      lea d, [bp + -1] ; $p
0692   07EE 2A            mov b, [d]
0693   07EF             ; START TERMS
0694   07EF D7            push a
0695   07F0 11            mov a, b
0696   07F1 26 02 00      mov b, $2
0697   07F4 56            add b, a
0698   07F5 E4            pop a
0699   07F6             ; END TERMS
0700   07F6 E7            pop d
0701   07F7 FD 43         mov [d], b
0702   07F9             ;; break; 
0703   07F9 0A 84 08      jmp _switch8_exit ; case break
0704   07FC             _switch8_case5:
0705   07FC             ;; p = p + 2; 
0706   07FC FA FF FF      lea d, [bp + -1] ; $p
0707   07FF DA            push d
0708   0800 FA FF FF      lea d, [bp + -1] ; $p
0709   0803 2A            mov b, [d]
0710   0804             ; START TERMS
0711   0804 D7            push a
0712   0805 11            mov a, b
0713   0806 26 02 00      mov b, $2
0714   0809 56            add b, a
0715   080A E4            pop a
0716   080B             ; END TERMS
0717   080B E7            pop d
0718   080C FD 43         mov [d], b
0719   080E             ;; break; 
0720   080E 0A 84 08      jmp _switch8_exit ; case break
0721   0811             _switch8_case6:
0722   0811             ;; c = getchar(); 
0723   0811 FA FC FF      lea d, [bp + -4] ; $c
0724   0814 DA            push d
0725   0815 07 B1 10      call getchar
0726   0818 E7            pop d
0727   0819 FD 3E         mov [d], bl
0728   081B             ;; **(char **)p = c; 
0729   081B FA FF FF      lea d, [bp + -1] ; $p
0730   081E 2A            mov b, [d]
0731   081F 74            mov d, b
0732   0820 2A            mov b, [d]
0733   0821 D8            push b
0734   0822 FA FC FF      lea d, [bp + -4] ; $c
0735   0825 32            mov bl, [d]
0736   0826 A7 00         mov bh, 0
0737   0828 E7            pop d
0738   0829 FD 43         mov [d], b
0739   082B             ;; p = p + 2; 
0740   082B FA FF FF      lea d, [bp + -1] ; $p
0741   082E DA            push d
0742   082F FA FF FF      lea d, [bp + -1] ; $p
0743   0832 2A            mov b, [d]
0744   0833             ; START TERMS
0745   0833 D7            push a
0746   0834 11            mov a, b
0747   0835 26 02 00      mov b, $2
0748   0838 56            add b, a
0749   0839 E4            pop a
0750   083A             ; END TERMS
0751   083A E7            pop d
0752   083B FD 43         mov [d], b
0753   083D             ;; break; 
0754   083D 0A 84 08      jmp _switch8_exit ; case break
0755   0840             _switch8_case7:
0756   0840             ;; gets(input_string); 
0757   0840 FA FA FD      lea d, [bp + -518] ; $input_string
0758   0843 2D            mov b, d
0759   0844 FD AB         swp b
0760   0846 D8            push b
0761   0847 07 7B 0C      call gets
0762   084A 51 02 00      add sp, 2
0763   084D             ;; strcpy(*(char **)p, input_string); 
0764   084D FA FA FD      lea d, [bp + -518] ; $input_string
0765   0850 2D            mov b, d
0766   0851 FD AB         swp b
0767   0853 D8            push b
0768   0854 FA FF FF      lea d, [bp + -1] ; $p
0769   0857 2A            mov b, [d]
0770   0858 74            mov d, b
0771   0859 2A            mov b, [d]
0772   085A FD AB         swp b
0773   085C D8            push b
0774   085D 07 C2 04      call strcpy
0775   0860 51 04 00      add sp, 4
0776   0863             ;; p = p + 2; 
0777   0863 FA FF FF      lea d, [bp + -1] ; $p
0778   0866 DA            push d
0779   0867 FA FF FF      lea d, [bp + -1] ; $p
0780   086A 2A            mov b, [d]
0781   086B             ; START TERMS
0782   086B D7            push a
0783   086C 11            mov a, b
0784   086D 26 02 00      mov b, $2
0785   0870 56            add b, a
0786   0871 E4            pop a
0787   0872             ; END TERMS
0788   0872 E7            pop d
0789   0873 FD 43         mov [d], b
0790   0875             ;; break; 
0791   0875 0A 84 08      jmp _switch8_exit ; case break
0792   0878             _switch8_default:
0793   0878             ;; print("Error: Unknown argument type.\n"); 
0794   0878 26 65 15      mov b, __s2 ; "Error: Unknown argument type.\n"
0795   087B FD AB         swp b
0796   087D D8            push b
0797   087E 07 EC 10      call print
0798   0881 51 02 00      add sp, 2
0799   0884             _switch8_exit:
0800   0884             ;; format_p++; 
0801   0884 FA FD FF      lea d, [bp + -3] ; $format_p
0802   0887 2A            mov b, [d]
0803   0888 D8            push b
0804   0889 FD 77         inc b
0805   088B FA FD FF      lea d, [bp + -3] ; $format_p
0806   088E FD 43         mov [d], b
0807   0890 E5            pop b
0808   0891 0A B0 08      jmp _if7_exit
0809   0894             _if7_else:
0810   0894             ;; putchar(*format_p); 
0811   0894 FA FD FF      lea d, [bp + -3] ; $format_p
0812   0897 2A            mov b, [d]
0813   0898 74            mov d, b
0814   0899 32            mov bl, [d]
0815   089A A7 00         mov bh, 0
0816   089C DD            push bl
0817   089D 07 A4 10      call putchar
0818   08A0 51 01 00      add sp, 1
0819   08A3             ;; format_p++; 
0820   08A3 FA FD FF      lea d, [bp + -3] ; $format_p
0821   08A6 2A            mov b, [d]
0822   08A7 D8            push b
0823   08A8 FD 77         inc b
0824   08AA FA FD FF      lea d, [bp + -3] ; $format_p
0825   08AD FD 43         mov [d], b
0826   08AF E5            pop b
0827   08B0             _if7_exit:
0828   08B0             _if6_exit:
0829   08B0             _for5_update:
0830   08B0 0A 9D 06      jmp _for5_cond
0831   08B3             _for5_exit:
0832   08B3 F9            leave
0833   08B4 09            ret
0834   08B5             
0835   08B5             printf:
0836   08B5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0837   08B8             ; $p 
0838   08B8             ; $format_p 
0839   08B8 52 04 00      sub sp, 4
0840   08BB             ;; format_p = format; 
0841   08BB FA FD FF      lea d, [bp + -3] ; $format_p
0842   08BE DA            push d
0843   08BF FA 05 00      lea d, [bp + 5] ; $format
0844   08C2 2A            mov b, [d]
0845   08C3 E7            pop d
0846   08C4 FD 43         mov [d], b
0847   08C6             ;; p = &format + 2; 
0848   08C6 FA FF FF      lea d, [bp + -1] ; $p
0849   08C9 DA            push d
0850   08CA FA 05 00      lea d, [bp + 5] ; $format
0851   08CD 2D            mov b, d
0852   08CE             ; START TERMS
0853   08CE D7            push a
0854   08CF 11            mov a, b
0855   08D0 26 02 00      mov b, $2
0856   08D3 56            add b, a
0857   08D4 E4            pop a
0858   08D5             ; END TERMS
0859   08D5 E7            pop d
0860   08D6 FD 43         mov [d], b
0861   08D8             ;; for(;;){ 
0862   08D8             _for12_init:
0863   08D8             _for12_cond:
0864   08D8             _for12_block:
0865   08D8             ;; if(!*format_p) break; 
0866   08D8             _if13_cond:
0867   08D8 FA FD FF      lea d, [bp + -3] ; $format_p
0868   08DB 2A            mov b, [d]
0869   08DC 74            mov d, b
0870   08DD 32            mov bl, [d]
0871   08DE A7 00         mov bh, 0
0872   08E0 C0 00 00      cmp b, 0
0873   08E3 FD 71         seq ; !
0874   08E5 C0 00 00      cmp b, 0
0875   08E8 C6 F1 08      je _if13_else
0876   08EB             _if13_true:
0877   08EB             ;; break; 
0878   08EB 0A FA 0A      jmp _for12_exit ; for break
0879   08EE 0A F7 0A      jmp _if13_exit
0880   08F1             _if13_else:
0881   08F1             ;; if(*format_p == '%'){ 
0882   08F1             _if14_cond:
0883   08F1 FA FD FF      lea d, [bp + -3] ; $format_p
0884   08F4 2A            mov b, [d]
0885   08F5 74            mov d, b
0886   08F6 32            mov bl, [d]
0887   08F7 A7 00         mov bh, 0
0888   08F9             ; START RELATIONAL
0889   08F9 D7            push a
0890   08FA 11            mov a, b
0891   08FB 26 25 00      mov b, $25
0892   08FE B0            cmp a, b
0893   08FF FD 71         seq ; ==
0894   0901 E4            pop a
0895   0902             ; END RELATIONAL
0896   0902 C0 00 00      cmp b, 0
0897   0905 C6 DB 0A      je _if14_else
0898   0908             _if14_true:
0899   0908             ;; format_p++; 
0900   0908 FA FD FF      lea d, [bp + -3] ; $format_p
0901   090B 2A            mov b, [d]
0902   090C D8            push b
0903   090D FD 77         inc b
0904   090F FA FD FF      lea d, [bp + -3] ; $format_p
0905   0912 FD 43         mov [d], b
0906   0914 E5            pop b
0907   0915             ;; switch(*format_p){ 
0908   0915             _switch15_expr:
0909   0915 FA FD FF      lea d, [bp + -3] ; $format_p
0910   0918 2A            mov b, [d]
0911   0919 74            mov d, b
0912   091A 32            mov bl, [d]
0913   091B A7 00         mov bh, 0
0914   091D             _switch15_comparisons:
0915   091D C1 6C         cmp bl, $6c
0916   091F C6 4B 09      je _switch15_case0
0917   0922 C1 4C         cmp bl, $4c
0918   0924 C6 4B 09      je _switch15_case1
0919   0927 C1 64         cmp bl, $64
0920   0929 C6 1B 0A      je _switch15_case2
0921   092C C1 69         cmp bl, $69
0922   092E C6 1B 0A      je _switch15_case3
0923   0931 C1 75         cmp bl, $75
0924   0933 C6 3F 0A      je _switch15_case4
0925   0936 C1 78         cmp bl, $78
0926   0938 C6 63 0A      je _switch15_case5
0927   093B C1 63         cmp bl, $63
0928   093D C6 81 0A      je _switch15_case6
0929   0940 C1 73         cmp bl, $73
0930   0942 C6 A0 0A      je _switch15_case7
0931   0945 0A BF 0A      jmp _switch15_default
0932   0948 0A CB 0A      jmp _switch15_exit
0933   094B             _switch15_case0:
0934   094B             _switch15_case1:
0935   094B             ;; format_p++; 
0936   094B FA FD FF      lea d, [bp + -3] ; $format_p
0937   094E 2A            mov b, [d]
0938   094F D8            push b
0939   0950 FD 77         inc b
0940   0952 FA FD FF      lea d, [bp + -3] ; $format_p
0941   0955 FD 43         mov [d], b
0942   0957 E5            pop b
0943   0958             ;; if(*format_p == 'd' || *format_p == 'i') 
0944   0958             _if16_cond:
0945   0958 FA FD FF      lea d, [bp + -3] ; $format_p
0946   095B 2A            mov b, [d]
0947   095C 74            mov d, b
0948   095D 32            mov bl, [d]
0949   095E A7 00         mov bh, 0
0950   0960             ; START RELATIONAL
0951   0960 D7            push a
0952   0961 11            mov a, b
0953   0962 26 64 00      mov b, $64
0954   0965 B0            cmp a, b
0955   0966 FD 71         seq ; ==
0956   0968 E4            pop a
0957   0969             ; END RELATIONAL
0958   0969 D7            push a
0959   096A 11            mov a, b
0960   096B FA FD FF      lea d, [bp + -3] ; $format_p
0961   096E 2A            mov b, [d]
0962   096F 74            mov d, b
0963   0970 32            mov bl, [d]
0964   0971 A7 00         mov bh, 0
0965   0973             ; START RELATIONAL
0966   0973 D7            push a
0967   0974 11            mov a, b
0968   0975 26 69 00      mov b, $69
0969   0978 B0            cmp a, b
0970   0979 FD 71         seq ; ==
0971   097B E4            pop a
0972   097C             ; END RELATIONAL
0973   097C FD A8         sor a, b ; ||
0974   097E E4            pop a
0975   097F C0 00 00      cmp b, 0
0976   0982 C6 99 09      je _if16_else
0977   0985             _if16_true:
0978   0985             ;; print_signed_long(*(long *)p); 
0979   0985 FD 79         mov g, b
0980   0987 28            mov b, c
0981   0988 FD AB         swp b
0982   098A D8            push b
0983   098B FD 27         mov b, g
0984   098D FD AB         swp b
0985   098F D8            push b
0986   0990 07 85 0D      call print_signed_long
0987   0993 51 04 00      add sp, 4
0988   0996 0A 06 0A      jmp _if16_exit
0989   0999             _if16_else:
0990   0999             ;; if(*format_p == 'u') 
0991   0999             _if17_cond:
0992   0999 FA FD FF      lea d, [bp + -3] ; $format_p
0993   099C 2A            mov b, [d]
0994   099D 74            mov d, b
0995   099E 32            mov bl, [d]
0996   099F A7 00         mov bh, 0
0997   09A1             ; START RELATIONAL
0998   09A1 D7            push a
0999   09A2 11            mov a, b
1000   09A3 26 75 00      mov b, $75
1001   09A6 B0            cmp a, b
1002   09A7 FD 71         seq ; ==
1003   09A9 E4            pop a
1004   09AA             ; END RELATIONAL
1005   09AA C0 00 00      cmp b, 0
1006   09AD C6 C4 09      je _if17_else
1007   09B0             _if17_true:
1008   09B0             ;; print_unsigned_long(*(unsigned long *)p); 
1009   09B0 FD 79         mov g, b
1010   09B2 28            mov b, c
1011   09B3 FD AB         swp b
1012   09B5 D8            push b
1013   09B6 FD 27         mov b, g
1014   09B8 FD AB         swp b
1015   09BA D8            push b
1016   09BB 07 D7 0E      call print_unsigned_long
1017   09BE 51 04 00      add sp, 4
1018   09C1 0A 06 0A      jmp _if17_exit
1019   09C4             _if17_else:
1020   09C4             ;; if(*format_p == 'x') 
1021   09C4             _if18_cond:
1022   09C4 FA FD FF      lea d, [bp + -3] ; $format_p
1023   09C7 2A            mov b, [d]
1024   09C8 74            mov d, b
1025   09C9 32            mov bl, [d]
1026   09CA A7 00         mov bh, 0
1027   09CC             ; START RELATIONAL
1028   09CC D7            push a
1029   09CD 11            mov a, b
1030   09CE 26 78 00      mov b, $78
1031   09D1 B0            cmp a, b
1032   09D2 FD 71         seq ; ==
1033   09D4 E4            pop a
1034   09D5             ; END RELATIONAL
1035   09D5 C0 00 00      cmp b, 0
1036   09D8 C6 FA 09      je _if18_else
1037   09DB             _if18_true:
1038   09DB             ;; printx32(*(long int *)p); 
1039   09DB FA FF FF      lea d, [bp + -1] ; $p
1040   09DE 2A            mov b, [d]
1041   09DF 74            mov d, b
1042   09E0 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1043   09E3 FD 39         mov c, b ; And place it into C
1044   09E5 2A            mov b, [d] ; Lower Word in B
1045   09E6 FD 79         mov g, b
1046   09E8 28            mov b, c
1047   09E9 FD AB         swp b
1048   09EB D8            push b
1049   09EC FD 27         mov b, g
1050   09EE FD AB         swp b
1051   09F0 D8            push b
1052   09F1 07 0E 0B      call printx32
1053   09F4 51 04 00      add sp, 4
1054   09F7 0A 06 0A      jmp _if18_exit
1055   09FA             _if18_else:
1056   09FA             ;; err("Unexpected format in printf."); 
1057   09FA 26 48 15      mov b, __s1 ; "Unexpected format in printf."
1058   09FD FD AB         swp b
1059   09FF D8            push b
1060   0A00 07 FC 0A      call err
1061   0A03 51 02 00      add sp, 2
1062   0A06             _if18_exit:
1063   0A06             _if17_exit:
1064   0A06             _if16_exit:
1065   0A06             ;; p = p + 4; 
1066   0A06 FA FF FF      lea d, [bp + -1] ; $p
1067   0A09 DA            push d
1068   0A0A FA FF FF      lea d, [bp + -1] ; $p
1069   0A0D 2A            mov b, [d]
1070   0A0E             ; START TERMS
1071   0A0E D7            push a
1072   0A0F 11            mov a, b
1073   0A10 26 04 00      mov b, $4
1074   0A13 56            add b, a
1075   0A14 E4            pop a
1076   0A15             ; END TERMS
1077   0A15 E7            pop d
1078   0A16 FD 43         mov [d], b
1079   0A18             ;; break; 
1080   0A18 0A CB 0A      jmp _switch15_exit ; case break
1081   0A1B             _switch15_case2:
1082   0A1B             _switch15_case3:
1083   0A1B             ;; print_signed(*(int*)p); 
1084   0A1B FA FF FF      lea d, [bp + -1] ; $p
1085   0A1E 2A            mov b, [d]
1086   0A1F 74            mov d, b
1087   0A20 2A            mov b, [d]
1088   0A21 FD AB         swp b
1089   0A23 D8            push b
1090   0A24 07 95 0C      call print_signed
1091   0A27 51 02 00      add sp, 2
1092   0A2A             ;; p = p + 2; 
1093   0A2A FA FF FF      lea d, [bp + -1] ; $p
1094   0A2D DA            push d
1095   0A2E FA FF FF      lea d, [bp + -1] ; $p
1096   0A31 2A            mov b, [d]
1097   0A32             ; START TERMS
1098   0A32 D7            push a
1099   0A33 11            mov a, b
1100   0A34 26 02 00      mov b, $2
1101   0A37 56            add b, a
1102   0A38 E4            pop a
1103   0A39             ; END TERMS
1104   0A39 E7            pop d
1105   0A3A FD 43         mov [d], b
1106   0A3C             ;; break; 
1107   0A3C 0A CB 0A      jmp _switch15_exit ; case break
1108   0A3F             _switch15_case4:
1109   0A3F             ;; print_unsigned(*(unsigned int*)p); 
1110   0A3F FA FF FF      lea d, [bp + -1] ; $p
1111   0A42 2A            mov b, [d]
1112   0A43 74            mov d, b
1113   0A44 2A            mov b, [d]
1114   0A45 FD AB         swp b
1115   0A47 D8            push b
1116   0A48 07 D4 0F      call print_unsigned
1117   0A4B 51 02 00      add sp, 2
1118   0A4E             ;; p = p + 2; 
1119   0A4E FA FF FF      lea d, [bp + -1] ; $p
1120   0A51 DA            push d
1121   0A52 FA FF FF      lea d, [bp + -1] ; $p
1122   0A55 2A            mov b, [d]
1123   0A56             ; START TERMS
1124   0A56 D7            push a
1125   0A57 11            mov a, b
1126   0A58 26 02 00      mov b, $2
1127   0A5B 56            add b, a
1128   0A5C E4            pop a
1129   0A5D             ; END TERMS
1130   0A5D E7            pop d
1131   0A5E FD 43         mov [d], b
1132   0A60             ;; break; 
1133   0A60 0A CB 0A      jmp _switch15_exit ; case break
1134   0A63             _switch15_case5:
1135   0A63             
1136   0A63             ; --- BEGIN INLINE ASM BLOCK
1137   0A63 FA FF FF      lea d, [bp + -1] ; $p
1138   0A66 FD 2A         mov d, [d]
1139   0A68 2A            mov b, [d]
1140   0A69 07 B2 13      call print_u16x
1141   0A6C             ; --- END INLINE ASM BLOCK
1142   0A6C             
1143   0A6C             ;; p = p + 2; 
1144   0A6C FA FF FF      lea d, [bp + -1] ; $p
1145   0A6F DA            push d
1146   0A70 FA FF FF      lea d, [bp + -1] ; $p
1147   0A73 2A            mov b, [d]
1148   0A74             ; START TERMS
1149   0A74 D7            push a
1150   0A75 11            mov a, b
1151   0A76 26 02 00      mov b, $2
1152   0A79 56            add b, a
1153   0A7A E4            pop a
1154   0A7B             ; END TERMS
1155   0A7B E7            pop d
1156   0A7C FD 43         mov [d], b
1157   0A7E             ;; break; 
1158   0A7E 0A CB 0A      jmp _switch15_exit ; case break
1159   0A81             _switch15_case6:
1160   0A81             
1161   0A81             ; --- BEGIN INLINE ASM BLOCK
1162   0A81 FA FF FF      lea d, [bp + -1] ; $p
1163   0A84 FD 2A         mov d, [d]
1164   0A86 1E            mov al, [d]
1165   0A87 23            mov ah, al
1166   0A88 07 10 12      call _putchar
1167   0A8B             ; --- END INLINE ASM BLOCK
1168   0A8B             
1169   0A8B             ;; p = p + 2; 
1170   0A8B FA FF FF      lea d, [bp + -1] ; $p
1171   0A8E DA            push d
1172   0A8F FA FF FF      lea d, [bp + -1] ; $p
1173   0A92 2A            mov b, [d]
1174   0A93             ; START TERMS
1175   0A93 D7            push a
1176   0A94 11            mov a, b
1177   0A95 26 02 00      mov b, $2
1178   0A98 56            add b, a
1179   0A99 E4            pop a
1180   0A9A             ; END TERMS
1181   0A9A E7            pop d
1182   0A9B FD 43         mov [d], b
1183   0A9D             ;; break; 
1184   0A9D 0A CB 0A      jmp _switch15_exit ; case break
1185   0AA0             _switch15_case7:
1186   0AA0             
1187   0AA0             ; --- BEGIN INLINE ASM BLOCK
1188   0AA0 FA FF FF      lea d, [bp + -1] ; $p
1189   0AA3 FD 2A         mov d, [d]
1190   0AA5 FD 2A         mov d, [d]
1191   0AA7 07 5A 13      call _puts
1192   0AAA             ; --- END INLINE ASM BLOCK
1193   0AAA             
1194   0AAA             ;; p = p + 2; 
1195   0AAA FA FF FF      lea d, [bp + -1] ; $p
1196   0AAD DA            push d
1197   0AAE FA FF FF      lea d, [bp + -1] ; $p
1198   0AB1 2A            mov b, [d]
1199   0AB2             ; START TERMS
1200   0AB2 D7            push a
1201   0AB3 11            mov a, b
1202   0AB4 26 02 00      mov b, $2
1203   0AB7 56            add b, a
1204   0AB8 E4            pop a
1205   0AB9             ; END TERMS
1206   0AB9 E7            pop d
1207   0ABA FD 43         mov [d], b
1208   0ABC             ;; break; 
1209   0ABC 0A CB 0A      jmp _switch15_exit ; case break
1210   0ABF             _switch15_default:
1211   0ABF             ;; print("Error: Unknown argument type.\n"); 
1212   0ABF 26 65 15      mov b, __s2 ; "Error: Unknown argument type.\n"
1213   0AC2 FD AB         swp b
1214   0AC4 D8            push b
1215   0AC5 07 EC 10      call print
1216   0AC8 51 02 00      add sp, 2
1217   0ACB             _switch15_exit:
1218   0ACB             ;; format_p++; 
1219   0ACB FA FD FF      lea d, [bp + -3] ; $format_p
1220   0ACE 2A            mov b, [d]
1221   0ACF D8            push b
1222   0AD0 FD 77         inc b
1223   0AD2 FA FD FF      lea d, [bp + -3] ; $format_p
1224   0AD5 FD 43         mov [d], b
1225   0AD7 E5            pop b
1226   0AD8 0A F7 0A      jmp _if14_exit
1227   0ADB             _if14_else:
1228   0ADB             ;; putchar(*format_p); 
1229   0ADB FA FD FF      lea d, [bp + -3] ; $format_p
1230   0ADE 2A            mov b, [d]
1231   0ADF 74            mov d, b
1232   0AE0 32            mov bl, [d]
1233   0AE1 A7 00         mov bh, 0
1234   0AE3 DD            push bl
1235   0AE4 07 A4 10      call putchar
1236   0AE7 51 01 00      add sp, 1
1237   0AEA             ;; format_p++; 
1238   0AEA FA FD FF      lea d, [bp + -3] ; $format_p
1239   0AED 2A            mov b, [d]
1240   0AEE D8            push b
1241   0AEF FD 77         inc b
1242   0AF1 FA FD FF      lea d, [bp + -3] ; $format_p
1243   0AF4 FD 43         mov [d], b
1244   0AF6 E5            pop b
1245   0AF7             _if14_exit:
1246   0AF7             _if13_exit:
1247   0AF7             _for12_update:
1248   0AF7 0A D8 08      jmp _for12_cond
1249   0AFA             _for12_exit:
1250   0AFA F9            leave
1251   0AFB 09            ret
1252   0AFC             
1253   0AFC             err:
1254   0AFC F8 00 00      enter 0 ; (push bp; mov bp, sp)
1255   0AFF             ;; print(e); 
1256   0AFF FA 05 00      lea d, [bp + 5] ; $e
1257   0B02 2A            mov b, [d]
1258   0B03 FD AB         swp b
1259   0B05 D8            push b
1260   0B06 07 EC 10      call print
1261   0B09 51 02 00      add sp, 2
1262   0B0C F9            leave
1263   0B0D 09            ret
1264   0B0E             
1265   0B0E             printx32:
1266   0B0E F8 00 00      enter 0 ; (push bp; mov bp, sp)
1267   0B11             
1268   0B11             ; --- BEGIN INLINE ASM BLOCK
1269   0B11 FA 05 00      lea d, [bp + 5] ; $hex
1270   0B14 2B 02 00      mov b, [d+2]
1271   0B17 07 B2 13      call print_u16x
1272   0B1A 2A            mov b, [d]
1273   0B1B 07 B2 13      call print_u16x
1274   0B1E             ; --- END INLINE ASM BLOCK
1275   0B1E             
1276   0B1E F9            leave
1277   0B1F 09            ret
1278   0B20             
1279   0B20             printx16:
1280   0B20 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1281   0B23             
1282   0B23             ; --- BEGIN INLINE ASM BLOCK
1283   0B23 FA 05 00      lea d, [bp + 5] ; $hex
1284   0B26 2A            mov b, [d]
1285   0B27 07 B2 13      call print_u16x
1286   0B2A             ; --- END INLINE ASM BLOCK
1287   0B2A             
1288   0B2A F9            leave
1289   0B2B 09            ret
1290   0B2C             
1291   0B2C             printx8:
1292   0B2C F8 00 00      enter 0 ; (push bp; mov bp, sp)
1293   0B2F             
1294   0B2F             ; --- BEGIN INLINE ASM BLOCK
1295   0B2F FA 05 00      lea d, [bp + 5] ; $hex
1296   0B32 32            mov bl, [d]
1297   0B33 07 F6 13      call print_u8x
1298   0B36             ; --- END INLINE ASM BLOCK
1299   0B36             
1300   0B36 F9            leave
1301   0B37 09            ret
1302   0B38             
1303   0B38             hex_str_to_int:
1304   0B38 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1305   0B3B             ; $value 
1306   0B3B 10 00 00      mov a, $0
1307   0B3E 45 FF FF      mov [bp + -1], a
1308   0B41             ; $i 
1309   0B41             ; $hex_char 
1310   0B41             ; $len 
1311   0B41 52 07 00      sub sp, 7
1312   0B44             ;; len = strlen(hex_string); 
1313   0B44 FA FA FF      lea d, [bp + -6] ; $len
1314   0B47 DA            push d
1315   0B48 FA 05 00      lea d, [bp + 5] ; $hex_string
1316   0B4B 2A            mov b, [d]
1317   0B4C FD AB         swp b
1318   0B4E D8            push b
1319   0B4F 07 31 06      call strlen
1320   0B52 51 02 00      add sp, 2
1321   0B55 E7            pop d
1322   0B56 FD 43         mov [d], b
1323   0B58             ;; for (i = 0; i < len; i++) { 
1324   0B58             _for19_init:
1325   0B58 FA FD FF      lea d, [bp + -3] ; $i
1326   0B5B DA            push d
1327   0B5C 26 00 00      mov b, $0
1328   0B5F E7            pop d
1329   0B60 FD 43         mov [d], b
1330   0B62             _for19_cond:
1331   0B62 FA FD FF      lea d, [bp + -3] ; $i
1332   0B65 2A            mov b, [d]
1333   0B66             ; START RELATIONAL
1334   0B66 D7            push a
1335   0B67 11            mov a, b
1336   0B68 FA FA FF      lea d, [bp + -6] ; $len
1337   0B6B 2A            mov b, [d]
1338   0B6C B0            cmp a, b
1339   0B6D FD 73         slt ; <= (signed)
1340   0B6F E4            pop a
1341   0B70             ; END RELATIONAL
1342   0B70 C0 00 00      cmp b, 0
1343   0B73 C6 75 0C      je _for19_exit
1344   0B76             _for19_block:
1345   0B76             ;; hex_char = hex_string[i]; 
1346   0B76 FA FC FF      lea d, [bp + -4] ; $hex_char
1347   0B79 DA            push d
1348   0B7A FA 05 00      lea d, [bp + 5] ; $hex_string
1349   0B7D FD 2A         mov d, [d]
1350   0B7F D7            push a
1351   0B80 DA            push d
1352   0B81 FA FD FF      lea d, [bp + -3] ; $i
1353   0B84 2A            mov b, [d]
1354   0B85 E7            pop d
1355   0B86 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
1356   0B8A E4            pop a
1357   0B8B 32            mov bl, [d]
1358   0B8C A7 00         mov bh, 0
1359   0B8E E7            pop d
1360   0B8F FD 3E         mov [d], bl
1361   0B91             ;; if (hex_char >= 'a' && hex_char <= 'f')  
1362   0B91             _if20_cond:
1363   0B91 FA FC FF      lea d, [bp + -4] ; $hex_char
1364   0B94 32            mov bl, [d]
1365   0B95 A7 00         mov bh, 0
1366   0B97             ; START RELATIONAL
1367   0B97 D7            push a
1368   0B98 11            mov a, b
1369   0B99 26 61 00      mov b, $61
1370   0B9C B0            cmp a, b
1371   0B9D FD 80         sge ; >=
1372   0B9F E4            pop a
1373   0BA0             ; END RELATIONAL
1374   0BA0 D7            push a
1375   0BA1 11            mov a, b
1376   0BA2 FA FC FF      lea d, [bp + -4] ; $hex_char
1377   0BA5 32            mov bl, [d]
1378   0BA6 A7 00         mov bh, 0
1379   0BA8             ; START RELATIONAL
1380   0BA8 D7            push a
1381   0BA9 11            mov a, b
1382   0BAA 26 66 00      mov b, $66
1383   0BAD B0            cmp a, b
1384   0BAE FD 74         sle ; <=
1385   0BB0 E4            pop a
1386   0BB1             ; END RELATIONAL
1387   0BB1 FD A7         sand a, b ; &&
1388   0BB3 E4            pop a
1389   0BB4 C0 00 00      cmp b, 0
1390   0BB7 C6 E8 0B      je _if20_else
1391   0BBA             _if20_true:
1392   0BBA             ;; value = (value * 16) + (hex_char - 'a' + 10); 
1393   0BBA FA FF FF      lea d, [bp + -1] ; $value
1394   0BBD DA            push d
1395   0BBE FA FF FF      lea d, [bp + -1] ; $value
1396   0BC1 2A            mov b, [d]
1397   0BC2             ; START FACTORS
1398   0BC2 D7            push a
1399   0BC3 11            mov a, b
1400   0BC4 26 10 00      mov b, $10
1401   0BC7 AC            mul a, b ; *
1402   0BC8 11            mov a, b
1403   0BC9 27            mov b, a
1404   0BCA E4            pop a
1405   0BCB             ; END FACTORS
1406   0BCB             ; START TERMS
1407   0BCB D7            push a
1408   0BCC 11            mov a, b
1409   0BCD FA FC FF      lea d, [bp + -4] ; $hex_char
1410   0BD0 32            mov bl, [d]
1411   0BD1 A7 00         mov bh, 0
1412   0BD3             ; START TERMS
1413   0BD3 D7            push a
1414   0BD4 11            mov a, b
1415   0BD5 26 61 00      mov b, $61
1416   0BD8 60            sub a, b
1417   0BD9 27            mov b, a
1418   0BDA 11            mov a, b
1419   0BDB 26 0A 00      mov b, $a
1420   0BDE 56            add b, a
1421   0BDF E4            pop a
1422   0BE0             ; END TERMS
1423   0BE0 56            add b, a
1424   0BE1 E4            pop a
1425   0BE2             ; END TERMS
1426   0BE2 E7            pop d
1427   0BE3 FD 43         mov [d], b
1428   0BE5 0A 65 0C      jmp _if20_exit
1429   0BE8             _if20_else:
1430   0BE8             ;; if (hex_char >= 'A' && hex_char <= 'F')  
1431   0BE8             _if21_cond:
1432   0BE8 FA FC FF      lea d, [bp + -4] ; $hex_char
1433   0BEB 32            mov bl, [d]
1434   0BEC A7 00         mov bh, 0
1435   0BEE             ; START RELATIONAL
1436   0BEE D7            push a
1437   0BEF 11            mov a, b
1438   0BF0 26 41 00      mov b, $41
1439   0BF3 B0            cmp a, b
1440   0BF4 FD 80         sge ; >=
1441   0BF6 E4            pop a
1442   0BF7             ; END RELATIONAL
1443   0BF7 D7            push a
1444   0BF8 11            mov a, b
1445   0BF9 FA FC FF      lea d, [bp + -4] ; $hex_char
1446   0BFC 32            mov bl, [d]
1447   0BFD A7 00         mov bh, 0
1448   0BFF             ; START RELATIONAL
1449   0BFF D7            push a
1450   0C00 11            mov a, b
1451   0C01 26 46 00      mov b, $46
1452   0C04 B0            cmp a, b
1453   0C05 FD 74         sle ; <=
1454   0C07 E4            pop a
1455   0C08             ; END RELATIONAL
1456   0C08 FD A7         sand a, b ; &&
1457   0C0A E4            pop a
1458   0C0B C0 00 00      cmp b, 0
1459   0C0E C6 3F 0C      je _if21_else
1460   0C11             _if21_true:
1461   0C11             ;; value = (value * 16) + (hex_char - 'A' + 10); 
1462   0C11 FA FF FF      lea d, [bp + -1] ; $value
1463   0C14 DA            push d
1464   0C15 FA FF FF      lea d, [bp + -1] ; $value
1465   0C18 2A            mov b, [d]
1466   0C19             ; START FACTORS
1467   0C19 D7            push a
1468   0C1A 11            mov a, b
1469   0C1B 26 10 00      mov b, $10
1470   0C1E AC            mul a, b ; *
1471   0C1F 11            mov a, b
1472   0C20 27            mov b, a
1473   0C21 E4            pop a
1474   0C22             ; END FACTORS
1475   0C22             ; START TERMS
1476   0C22 D7            push a
1477   0C23 11            mov a, b
1478   0C24 FA FC FF      lea d, [bp + -4] ; $hex_char
1479   0C27 32            mov bl, [d]
1480   0C28 A7 00         mov bh, 0
1481   0C2A             ; START TERMS
1482   0C2A D7            push a
1483   0C2B 11            mov a, b
1484   0C2C 26 41 00      mov b, $41
1485   0C2F 60            sub a, b
1486   0C30 27            mov b, a
1487   0C31 11            mov a, b
1488   0C32 26 0A 00      mov b, $a
1489   0C35 56            add b, a
1490   0C36 E4            pop a
1491   0C37             ; END TERMS
1492   0C37 56            add b, a
1493   0C38 E4            pop a
1494   0C39             ; END TERMS
1495   0C39 E7            pop d
1496   0C3A FD 43         mov [d], b
1497   0C3C 0A 65 0C      jmp _if21_exit
1498   0C3F             _if21_else:
1499   0C3F             ;; value = (value * 16) + (hex_char - '0'); 
1500   0C3F FA FF FF      lea d, [bp + -1] ; $value
1501   0C42 DA            push d
1502   0C43 FA FF FF      lea d, [bp + -1] ; $value
1503   0C46 2A            mov b, [d]
1504   0C47             ; START FACTORS
1505   0C47 D7            push a
1506   0C48 11            mov a, b
1507   0C49 26 10 00      mov b, $10
1508   0C4C AC            mul a, b ; *
1509   0C4D 11            mov a, b
1510   0C4E 27            mov b, a
1511   0C4F E4            pop a
1512   0C50             ; END FACTORS
1513   0C50             ; START TERMS
1514   0C50 D7            push a
1515   0C51 11            mov a, b
1516   0C52 FA FC FF      lea d, [bp + -4] ; $hex_char
1517   0C55 32            mov bl, [d]
1518   0C56 A7 00         mov bh, 0
1519   0C58             ; START TERMS
1520   0C58 D7            push a
1521   0C59 11            mov a, b
1522   0C5A 26 30 00      mov b, $30
1523   0C5D 60            sub a, b
1524   0C5E 27            mov b, a
1525   0C5F E4            pop a
1526   0C60             ; END TERMS
1527   0C60 56            add b, a
1528   0C61 E4            pop a
1529   0C62             ; END TERMS
1530   0C62 E7            pop d
1531   0C63 FD 43         mov [d], b
1532   0C65             _if21_exit:
1533   0C65             _if20_exit:
1534   0C65             _for19_update:
1535   0C65 FA FD FF      lea d, [bp + -3] ; $i
1536   0C68 2A            mov b, [d]
1537   0C69 D8            push b
1538   0C6A FD 77         inc b
1539   0C6C FA FD FF      lea d, [bp + -3] ; $i
1540   0C6F FD 43         mov [d], b
1541   0C71 E5            pop b
1542   0C72 0A 62 0B      jmp _for19_cond
1543   0C75             _for19_exit:
1544   0C75             ;; return value; 
1545   0C75 FA FF FF      lea d, [bp + -1] ; $value
1546   0C78 2A            mov b, [d]
1547   0C79 F9            leave
1548   0C7A 09            ret
1549   0C7B             
1550   0C7B             gets:
1551   0C7B F8 00 00      enter 0 ; (push bp; mov bp, sp)
1552   0C7E             
1553   0C7E             ; --- BEGIN INLINE ASM BLOCK
1554   0C7E FA 05 00      lea d, [bp + 5] ; $s
1555   0C81 15            mov a, [d]
1556   0C82 3C            mov d, a
1557   0C83 07 17 12      call _gets
1558   0C86             ; --- END INLINE ASM BLOCK
1559   0C86             
1560   0C86             ;; return strlen(s); 
1561   0C86 FA 05 00      lea d, [bp + 5] ; $s
1562   0C89 2A            mov b, [d]
1563   0C8A FD AB         swp b
1564   0C8C D8            push b
1565   0C8D 07 31 06      call strlen
1566   0C90 51 02 00      add sp, 2
1567   0C93 F9            leave
1568   0C94 09            ret
1569   0C95             
1570   0C95             print_signed:
1571   0C95 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1572   0C98             ; $digits 
1573   0C98             ; $i 
1574   0C98 10 00 00      mov a, $0
1575   0C9B 45 FA FF      mov [bp + -6], a
1576   0C9E 52 07 00      sub sp, 7
1577   0CA1             ;; if (num < 0) { 
1578   0CA1             _if22_cond:
1579   0CA1 FA 05 00      lea d, [bp + 5] ; $num
1580   0CA4 2A            mov b, [d]
1581   0CA5             ; START RELATIONAL
1582   0CA5 D7            push a
1583   0CA6 11            mov a, b
1584   0CA7 26 00 00      mov b, $0
1585   0CAA B0            cmp a, b
1586   0CAB FD 73         slt ; <= (signed)
1587   0CAD E4            pop a
1588   0CAE             ; END RELATIONAL
1589   0CAE C0 00 00      cmp b, 0
1590   0CB1 C6 CE 0C      je _if22_else
1591   0CB4             _if22_true:
1592   0CB4             ;; putchar('-'); 
1593   0CB4 26 2D 00      mov b, $2d
1594   0CB7 DD            push bl
1595   0CB8 07 A4 10      call putchar
1596   0CBB 51 01 00      add sp, 1
1597   0CBE             ;; num = -num; 
1598   0CBE FA 05 00      lea d, [bp + 5] ; $num
1599   0CC1 DA            push d
1600   0CC2 FA 05 00      lea d, [bp + 5] ; $num
1601   0CC5 2A            mov b, [d]
1602   0CC6 FD 97         neg b
1603   0CC8 E7            pop d
1604   0CC9 FD 43         mov [d], b
1605   0CCB 0A F0 0C      jmp _if22_exit
1606   0CCE             _if22_else:
1607   0CCE             ;; if (num == 0) { 
1608   0CCE             _if23_cond:
1609   0CCE FA 05 00      lea d, [bp + 5] ; $num
1610   0CD1 2A            mov b, [d]
1611   0CD2             ; START RELATIONAL
1612   0CD2 D7            push a
1613   0CD3 11            mov a, b
1614   0CD4 26 00 00      mov b, $0
1615   0CD7 B0            cmp a, b
1616   0CD8 FD 71         seq ; ==
1617   0CDA E4            pop a
1618   0CDB             ; END RELATIONAL
1619   0CDB C0 00 00      cmp b, 0
1620   0CDE C6 F0 0C      je _if23_exit
1621   0CE1             _if23_true:
1622   0CE1             ;; putchar('0'); 
1623   0CE1 26 30 00      mov b, $30
1624   0CE4 DD            push bl
1625   0CE5 07 A4 10      call putchar
1626   0CE8 51 01 00      add sp, 1
1627   0CEB             ;; return; 
1628   0CEB F9            leave
1629   0CEC 09            ret
1630   0CED 0A F0 0C      jmp _if23_exit
1631   0CF0             _if23_exit:
1632   0CF0             _if22_exit:
1633   0CF0             ;; while (num > 0) { 
1634   0CF0             _while24_cond:
1635   0CF0 FA 05 00      lea d, [bp + 5] ; $num
1636   0CF3 2A            mov b, [d]
1637   0CF4             ; START RELATIONAL
1638   0CF4 D7            push a
1639   0CF5 11            mov a, b
1640   0CF6 26 00 00      mov b, $0
1641   0CF9 B0            cmp a, b
1642   0CFA FD 7F         sgt ; >
1643   0CFC E4            pop a
1644   0CFD             ; END RELATIONAL
1645   0CFD C0 00 00      cmp b, 0
1646   0D00 C6 4A 0D      je _while24_exit
1647   0D03             _while24_block:
1648   0D03             ;; digits[i] = '0' + (num % 10); 
1649   0D03 FA FC FF      lea d, [bp + -4] ; $digits
1650   0D06 D7            push a
1651   0D07 DA            push d
1652   0D08 FA FA FF      lea d, [bp + -6] ; $i
1653   0D0B 2A            mov b, [d]
1654   0D0C E7            pop d
1655   0D0D 5A            add d, b
1656   0D0E E4            pop a
1657   0D0F DA            push d
1658   0D10 26 30 00      mov b, $30
1659   0D13             ; START TERMS
1660   0D13 D7            push a
1661   0D14 11            mov a, b
1662   0D15 FA 05 00      lea d, [bp + 5] ; $num
1663   0D18 2A            mov b, [d]
1664   0D19             ; START FACTORS
1665   0D19 D7            push a
1666   0D1A 11            mov a, b
1667   0D1B 26 0A 00      mov b, $a
1668   0D1E AE            div a, b ; 
1669   0D1F 11            mov a, b
1670   0D20 27            mov b, a
1671   0D21 E4            pop a
1672   0D22             ; END FACTORS
1673   0D22 56            add b, a
1674   0D23 E4            pop a
1675   0D24             ; END TERMS
1676   0D24 E7            pop d
1677   0D25 FD 3E         mov [d], bl
1678   0D27             ;; num = num / 10; 
1679   0D27 FA 05 00      lea d, [bp + 5] ; $num
1680   0D2A DA            push d
1681   0D2B FA 05 00      lea d, [bp + 5] ; $num
1682   0D2E 2A            mov b, [d]
1683   0D2F             ; START FACTORS
1684   0D2F D7            push a
1685   0D30 11            mov a, b
1686   0D31 26 0A 00      mov b, $a
1687   0D34 AE            div a, b
1688   0D35 27            mov b, a
1689   0D36 E4            pop a
1690   0D37             ; END FACTORS
1691   0D37 E7            pop d
1692   0D38 FD 43         mov [d], b
1693   0D3A             ;; i++; 
1694   0D3A FA FA FF      lea d, [bp + -6] ; $i
1695   0D3D 2A            mov b, [d]
1696   0D3E D8            push b
1697   0D3F FD 77         inc b
1698   0D41 FA FA FF      lea d, [bp + -6] ; $i
1699   0D44 FD 43         mov [d], b
1700   0D46 E5            pop b
1701   0D47 0A F0 0C      jmp _while24_cond
1702   0D4A             _while24_exit:
1703   0D4A             ;; while (i > 0) { 
1704   0D4A             _while25_cond:
1705   0D4A FA FA FF      lea d, [bp + -6] ; $i
1706   0D4D 2A            mov b, [d]
1707   0D4E             ; START RELATIONAL
1708   0D4E D7            push a
1709   0D4F 11            mov a, b
1710   0D50 26 00 00      mov b, $0
1711   0D53 B0            cmp a, b
1712   0D54 FD 7F         sgt ; >
1713   0D56 E4            pop a
1714   0D57             ; END RELATIONAL
1715   0D57 C0 00 00      cmp b, 0
1716   0D5A C6 83 0D      je _while25_exit
1717   0D5D             _while25_block:
1718   0D5D             ;; i--; 
1719   0D5D FA FA FF      lea d, [bp + -6] ; $i
1720   0D60 2A            mov b, [d]
1721   0D61 D8            push b
1722   0D62 FD 7D         dec b
1723   0D64 FA FA FF      lea d, [bp + -6] ; $i
1724   0D67 FD 43         mov [d], b
1725   0D69 E5            pop b
1726   0D6A             ;; putchar(digits[i]); 
1727   0D6A FA FC FF      lea d, [bp + -4] ; $digits
1728   0D6D D7            push a
1729   0D6E DA            push d
1730   0D6F FA FA FF      lea d, [bp + -6] ; $i
1731   0D72 2A            mov b, [d]
1732   0D73 E7            pop d
1733   0D74 5A            add d, b
1734   0D75 E4            pop a
1735   0D76 32            mov bl, [d]
1736   0D77 A7 00         mov bh, 0
1737   0D79 DD            push bl
1738   0D7A 07 A4 10      call putchar
1739   0D7D 51 01 00      add sp, 1
1740   0D80 0A 4A 0D      jmp _while25_cond
1741   0D83             _while25_exit:
1742   0D83 F9            leave
1743   0D84 09            ret
1744   0D85             
1745   0D85             print_signed_long:
1746   0D85 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1747   0D88             ; $digits 
1748   0D88             ; $i 
1749   0D88 10 00 00      mov a, $0
1750   0D8B 45 F5 FF      mov [bp + -11], a
1751   0D8E 52 0C 00      sub sp, 12
1752   0D91             ;; if (num < 0) { 
1753   0D91             _if26_cond:
1754   0D91 FA 05 00      lea d, [bp + 5] ; $num
1755   0D94 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1756   0D97 FD 39         mov c, b ; And place it into C
1757   0D99 2A            mov b, [d] ; Lower Word in B
1758   0D9A             ; START RELATIONAL
1759   0D9A D7            push a
1760   0D9B FD D8         push g
1761   0D9D 11            mov a, b
1762   0D9E FD 7A         mov g, c
1763   0DA0 26 00 00      mov b, $0
1764   0DA3 4D            mov si, a
1765   0DA4 11            mov a, b
1766   0DA5 4F            mov di, a
1767   0DA6 FD 12         mov a, g
1768   0DA8 28            mov b, c
1769   0DA9 B0            cmp a, b
1770   0DAA FD 75         slu ; <
1771   0DAC D8            push b
1772   0DAD 28            mov b, c
1773   0DAE FD 71         seq ; ==
1774   0DB0 D8            push b
1775   0DB1 50            mov a, di
1776   0DB2 27            mov b, a
1777   0DB3 4E            mov a, si
1778   0DB4 B0            cmp a, b
1779   0DB5 FD 75         slu ; <
1780   0DB7 E4            pop a
1781   0DB8 FD 92         and b, a
1782   0DBA E4            pop a
1783   0DBB FD 70         or b, a
1784   0DBD               
1785   0DBD FD F1         pop g
1786   0DBF E4            pop a
1787   0DC0             ; END RELATIONAL
1788   0DC0 C0 00 00      cmp b, 0
1789   0DC3 C6 EA 0D      je _if26_else
1790   0DC6             _if26_true:
1791   0DC6             ;; putchar('-'); 
1792   0DC6 26 2D 00      mov b, $2d
1793   0DC9 DD            push bl
1794   0DCA 07 A4 10      call putchar
1795   0DCD 51 01 00      add sp, 1
1796   0DD0             ;; num = -num; 
1797   0DD0 FA 05 00      lea d, [bp + 5] ; $num
1798   0DD3 DA            push d
1799   0DD4 FA 05 00      lea d, [bp + 5] ; $num
1800   0DD7 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1801   0DDA FD 39         mov c, b ; And place it into C
1802   0DDC 2A            mov b, [d] ; Lower Word in B
1803   0DDD FD 97         neg b
1804   0DDF E7            pop d
1805   0DE0 FD 43         mov [d], b
1806   0DE2 28            mov b, c
1807   0DE3 FD 44 02 00   mov [d + 2], b
1808   0DE7 0A 21 0E      jmp _if26_exit
1809   0DEA             _if26_else:
1810   0DEA             ;; if (num == 0) { 
1811   0DEA             _if27_cond:
1812   0DEA FA 05 00      lea d, [bp + 5] ; $num
1813   0DED 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1814   0DF0 FD 39         mov c, b ; And place it into C
1815   0DF2 2A            mov b, [d] ; Lower Word in B
1816   0DF3             ; START RELATIONAL
1817   0DF3 D7            push a
1818   0DF4 FD D8         push g
1819   0DF6 11            mov a, b
1820   0DF7 FD 7A         mov g, c
1821   0DF9 26 00 00      mov b, $0
1822   0DFC B0            cmp a, b
1823   0DFD FD 71         seq ; ==
1824   0DFF D8            push b
1825   0E00 12            mov a, c
1826   0E01 FD 27         mov b, g
1827   0E03 B0            cmp a, b
1828   0E04 FD 71         seq ; ==
1829   0E06 E4            pop a
1830   0E07 FD A7         sand a, b
1831   0E09 FD F1         pop g
1832   0E0B E4            pop a
1833   0E0C             ; END RELATIONAL
1834   0E0C C0 00 00      cmp b, 0
1835   0E0F C6 21 0E      je _if27_exit
1836   0E12             _if27_true:
1837   0E12             ;; putchar('0'); 
1838   0E12 26 30 00      mov b, $30
1839   0E15 DD            push bl
1840   0E16 07 A4 10      call putchar
1841   0E19 51 01 00      add sp, 1
1842   0E1C             ;; return; 
1843   0E1C F9            leave
1844   0E1D 09            ret
1845   0E1E 0A 21 0E      jmp _if27_exit
1846   0E21             _if27_exit:
1847   0E21             _if26_exit:
1848   0E21             ;; while (num > 0) { 
1849   0E21             _while28_cond:
1850   0E21 FA 05 00      lea d, [bp + 5] ; $num
1851   0E24 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1852   0E27 FD 39         mov c, b ; And place it into C
1853   0E29 2A            mov b, [d] ; Lower Word in B
1854   0E2A             ; START RELATIONAL
1855   0E2A D7            push a
1856   0E2B FD D8         push g
1857   0E2D 11            mov a, b
1858   0E2E FD 7A         mov g, c
1859   0E30 26 00 00      mov b, $0
1860   0E33 B0            cmp a, b
1861   0E34 FD 7F         sgt ; >
1862   0E36 FD F1         pop g
1863   0E38 E4            pop a
1864   0E39             ; END RELATIONAL
1865   0E39 C0 00 00      cmp b, 0
1866   0E3C C6 9C 0E      je _while28_exit
1867   0E3F             _while28_block:
1868   0E3F             ;; digits[i] = '0' + (num % 10); 
1869   0E3F FA F7 FF      lea d, [bp + -9] ; $digits
1870   0E42 D7            push a
1871   0E43 DA            push d
1872   0E44 FA F5 FF      lea d, [bp + -11] ; $i
1873   0E47 2A            mov b, [d]
1874   0E48 E7            pop d
1875   0E49 5A            add d, b
1876   0E4A E4            pop a
1877   0E4B DA            push d
1878   0E4C 26 30 00      mov b, $30
1879   0E4F             ; START TERMS
1880   0E4F D7            push a
1881   0E50 11            mov a, b
1882   0E51 FA 05 00      lea d, [bp + 5] ; $num
1883   0E54 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1884   0E57 FD 39         mov c, b ; And place it into C
1885   0E59 2A            mov b, [d] ; Lower Word in B
1886   0E5A             ; START FACTORS
1887   0E5A D7            push a
1888   0E5B 11            mov a, b
1889   0E5C 26 0A 00      mov b, $a
1890   0E5F AE            div a, b ; 
1891   0E60 11            mov a, b
1892   0E61 27            mov b, a
1893   0E62 E4            pop a
1894   0E63             ; END FACTORS
1895   0E63 54            add a, b
1896   0E64 D7            push a
1897   0E65 FD 12         mov a, g
1898   0E67 28            mov b, c
1899   0E68 5C            adc a, b
1900   0E69 39            mov c, a
1901   0E6A E5            pop b
1902   0E6B E4            pop a
1903   0E6C             ; END TERMS
1904   0E6C E7            pop d
1905   0E6D FD 3E         mov [d], bl
1906   0E6F             ;; num = num / 10; 
1907   0E6F FA 05 00      lea d, [bp + 5] ; $num
1908   0E72 DA            push d
1909   0E73 FA 05 00      lea d, [bp + 5] ; $num
1910   0E76 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1911   0E79 FD 39         mov c, b ; And place it into C
1912   0E7B 2A            mov b, [d] ; Lower Word in B
1913   0E7C             ; START FACTORS
1914   0E7C D7            push a
1915   0E7D 11            mov a, b
1916   0E7E 26 0A 00      mov b, $a
1917   0E81 AE            div a, b
1918   0E82 27            mov b, a
1919   0E83 E4            pop a
1920   0E84             ; END FACTORS
1921   0E84 E7            pop d
1922   0E85 FD 43         mov [d], b
1923   0E87 28            mov b, c
1924   0E88 FD 44 02 00   mov [d + 2], b
1925   0E8C             ;; i++; 
1926   0E8C FA F5 FF      lea d, [bp + -11] ; $i
1927   0E8F 2A            mov b, [d]
1928   0E90 D8            push b
1929   0E91 FD 77         inc b
1930   0E93 FA F5 FF      lea d, [bp + -11] ; $i
1931   0E96 FD 43         mov [d], b
1932   0E98 E5            pop b
1933   0E99 0A 21 0E      jmp _while28_cond
1934   0E9C             _while28_exit:
1935   0E9C             ;; while (i > 0) { 
1936   0E9C             _while29_cond:
1937   0E9C FA F5 FF      lea d, [bp + -11] ; $i
1938   0E9F 2A            mov b, [d]
1939   0EA0             ; START RELATIONAL
1940   0EA0 D7            push a
1941   0EA1 11            mov a, b
1942   0EA2 26 00 00      mov b, $0
1943   0EA5 B0            cmp a, b
1944   0EA6 FD 7F         sgt ; >
1945   0EA8 E4            pop a
1946   0EA9             ; END RELATIONAL
1947   0EA9 C0 00 00      cmp b, 0
1948   0EAC C6 D5 0E      je _while29_exit
1949   0EAF             _while29_block:
1950   0EAF             ;; i--; 
1951   0EAF FA F5 FF      lea d, [bp + -11] ; $i
1952   0EB2 2A            mov b, [d]
1953   0EB3 D8            push b
1954   0EB4 FD 7D         dec b
1955   0EB6 FA F5 FF      lea d, [bp + -11] ; $i
1956   0EB9 FD 43         mov [d], b
1957   0EBB E5            pop b
1958   0EBC             ;; putchar(digits[i]); 
1959   0EBC FA F7 FF      lea d, [bp + -9] ; $digits
1960   0EBF D7            push a
1961   0EC0 DA            push d
1962   0EC1 FA F5 FF      lea d, [bp + -11] ; $i
1963   0EC4 2A            mov b, [d]
1964   0EC5 E7            pop d
1965   0EC6 5A            add d, b
1966   0EC7 E4            pop a
1967   0EC8 32            mov bl, [d]
1968   0EC9 A7 00         mov bh, 0
1969   0ECB DD            push bl
1970   0ECC 07 A4 10      call putchar
1971   0ECF 51 01 00      add sp, 1
1972   0ED2 0A 9C 0E      jmp _while29_cond
1973   0ED5             _while29_exit:
1974   0ED5 F9            leave
1975   0ED6 09            ret
1976   0ED7             
1977   0ED7             print_unsigned_long:
1978   0ED7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1979   0EDA             ; $digits 
1980   0EDA             ; $i 
1981   0EDA 52 0C 00      sub sp, 12
1982   0EDD             ;; i = 0; 
1983   0EDD FA F5 FF      lea d, [bp + -11] ; $i
1984   0EE0 DA            push d
1985   0EE1 26 00 00      mov b, $0
1986   0EE4 E7            pop d
1987   0EE5 FD 43         mov [d], b
1988   0EE7             ;; if(num == 0){ 
1989   0EE7             _if30_cond:
1990   0EE7 FA 05 00      lea d, [bp + 5] ; $num
1991   0EEA 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1992   0EED FD 39         mov c, b ; And place it into C
1993   0EEF 2A            mov b, [d] ; Lower Word in B
1994   0EF0             ; START RELATIONAL
1995   0EF0 D7            push a
1996   0EF1 FD D8         push g
1997   0EF3 11            mov a, b
1998   0EF4 FD 7A         mov g, c
1999   0EF6 26 00 00      mov b, $0
2000   0EF9 B0            cmp a, b
2001   0EFA FD 71         seq ; ==
2002   0EFC D8            push b
2003   0EFD 12            mov a, c
2004   0EFE FD 27         mov b, g
2005   0F00 B0            cmp a, b
2006   0F01 FD 71         seq ; ==
2007   0F03 E4            pop a
2008   0F04 FD A7         sand a, b
2009   0F06 FD F1         pop g
2010   0F08 E4            pop a
2011   0F09             ; END RELATIONAL
2012   0F09 C0 00 00      cmp b, 0
2013   0F0C C6 1E 0F      je _if30_exit
2014   0F0F             _if30_true:
2015   0F0F             ;; putchar('0'); 
2016   0F0F 26 30 00      mov b, $30
2017   0F12 DD            push bl
2018   0F13 07 A4 10      call putchar
2019   0F16 51 01 00      add sp, 1
2020   0F19             ;; return; 
2021   0F19 F9            leave
2022   0F1A 09            ret
2023   0F1B 0A 1E 0F      jmp _if30_exit
2024   0F1E             _if30_exit:
2025   0F1E             ;; while (num > 0) { 
2026   0F1E             _while31_cond:
2027   0F1E FA 05 00      lea d, [bp + 5] ; $num
2028   0F21 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2029   0F24 FD 39         mov c, b ; And place it into C
2030   0F26 2A            mov b, [d] ; Lower Word in B
2031   0F27             ; START RELATIONAL
2032   0F27 D7            push a
2033   0F28 FD D8         push g
2034   0F2A 11            mov a, b
2035   0F2B FD 7A         mov g, c
2036   0F2D 26 00 00      mov b, $0
2037   0F30 B0            cmp a, b
2038   0F31 FD 81         sgu ; > (unsigned)
2039   0F33 FD F1         pop g
2040   0F35 E4            pop a
2041   0F36             ; END RELATIONAL
2042   0F36 C0 00 00      cmp b, 0
2043   0F39 C6 99 0F      je _while31_exit
2044   0F3C             _while31_block:
2045   0F3C             ;; digits[i] = '0' + (num % 10); 
2046   0F3C FA F7 FF      lea d, [bp + -9] ; $digits
2047   0F3F D7            push a
2048   0F40 DA            push d
2049   0F41 FA F5 FF      lea d, [bp + -11] ; $i
2050   0F44 2A            mov b, [d]
2051   0F45 E7            pop d
2052   0F46 5A            add d, b
2053   0F47 E4            pop a
2054   0F48 DA            push d
2055   0F49 26 30 00      mov b, $30
2056   0F4C             ; START TERMS
2057   0F4C D7            push a
2058   0F4D 11            mov a, b
2059   0F4E FA 05 00      lea d, [bp + 5] ; $num
2060   0F51 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2061   0F54 FD 39         mov c, b ; And place it into C
2062   0F56 2A            mov b, [d] ; Lower Word in B
2063   0F57             ; START FACTORS
2064   0F57 D7            push a
2065   0F58 11            mov a, b
2066   0F59 26 0A 00      mov b, $a
2067   0F5C AE            div a, b ; 
2068   0F5D 11            mov a, b
2069   0F5E 27            mov b, a
2070   0F5F E4            pop a
2071   0F60             ; END FACTORS
2072   0F60 54            add a, b
2073   0F61 D7            push a
2074   0F62 FD 12         mov a, g
2075   0F64 28            mov b, c
2076   0F65 5C            adc a, b
2077   0F66 39            mov c, a
2078   0F67 E5            pop b
2079   0F68 E4            pop a
2080   0F69             ; END TERMS
2081   0F69 E7            pop d
2082   0F6A FD 3E         mov [d], bl
2083   0F6C             ;; num = num / 10; 
2084   0F6C FA 05 00      lea d, [bp + 5] ; $num
2085   0F6F DA            push d
2086   0F70 FA 05 00      lea d, [bp + 5] ; $num
2087   0F73 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2088   0F76 FD 39         mov c, b ; And place it into C
2089   0F78 2A            mov b, [d] ; Lower Word in B
2090   0F79             ; START FACTORS
2091   0F79 D7            push a
2092   0F7A 11            mov a, b
2093   0F7B 26 0A 00      mov b, $a
2094   0F7E AE            div a, b
2095   0F7F 27            mov b, a
2096   0F80 E4            pop a
2097   0F81             ; END FACTORS
2098   0F81 E7            pop d
2099   0F82 FD 43         mov [d], b
2100   0F84 28            mov b, c
2101   0F85 FD 44 02 00   mov [d + 2], b
2102   0F89             ;; i++; 
2103   0F89 FA F5 FF      lea d, [bp + -11] ; $i
2104   0F8C 2A            mov b, [d]
2105   0F8D D8            push b
2106   0F8E FD 77         inc b
2107   0F90 FA F5 FF      lea d, [bp + -11] ; $i
2108   0F93 FD 43         mov [d], b
2109   0F95 E5            pop b
2110   0F96 0A 1E 0F      jmp _while31_cond
2111   0F99             _while31_exit:
2112   0F99             ;; while (i > 0) { 
2113   0F99             _while32_cond:
2114   0F99 FA F5 FF      lea d, [bp + -11] ; $i
2115   0F9C 2A            mov b, [d]
2116   0F9D             ; START RELATIONAL
2117   0F9D D7            push a
2118   0F9E 11            mov a, b
2119   0F9F 26 00 00      mov b, $0
2120   0FA2 B0            cmp a, b
2121   0FA3 FD 7F         sgt ; >
2122   0FA5 E4            pop a
2123   0FA6             ; END RELATIONAL
2124   0FA6 C0 00 00      cmp b, 0
2125   0FA9 C6 D2 0F      je _while32_exit
2126   0FAC             _while32_block:
2127   0FAC             ;; i--; 
2128   0FAC FA F5 FF      lea d, [bp + -11] ; $i
2129   0FAF 2A            mov b, [d]
2130   0FB0 D8            push b
2131   0FB1 FD 7D         dec b
2132   0FB3 FA F5 FF      lea d, [bp + -11] ; $i
2133   0FB6 FD 43         mov [d], b
2134   0FB8 E5            pop b
2135   0FB9             ;; putchar(digits[i]); 
2136   0FB9 FA F7 FF      lea d, [bp + -9] ; $digits
2137   0FBC D7            push a
2138   0FBD DA            push d
2139   0FBE FA F5 FF      lea d, [bp + -11] ; $i
2140   0FC1 2A            mov b, [d]
2141   0FC2 E7            pop d
2142   0FC3 5A            add d, b
2143   0FC4 E4            pop a
2144   0FC5 32            mov bl, [d]
2145   0FC6 A7 00         mov bh, 0
2146   0FC8 DD            push bl
2147   0FC9 07 A4 10      call putchar
2148   0FCC 51 01 00      add sp, 1
2149   0FCF 0A 99 0F      jmp _while32_cond
2150   0FD2             _while32_exit:
2151   0FD2 F9            leave
2152   0FD3 09            ret
2153   0FD4             
2154   0FD4             print_unsigned:
2155   0FD4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2156   0FD7             ; $digits 
2157   0FD7             ; $i 
2158   0FD7 52 07 00      sub sp, 7
2159   0FDA             ;; i = 0; 
2160   0FDA FA FA FF      lea d, [bp + -6] ; $i
2161   0FDD DA            push d
2162   0FDE 26 00 00      mov b, $0
2163   0FE1 E7            pop d
2164   0FE2 FD 43         mov [d], b
2165   0FE4             ;; if(num == 0){ 
2166   0FE4             _if33_cond:
2167   0FE4 FA 05 00      lea d, [bp + 5] ; $num
2168   0FE7 2A            mov b, [d]
2169   0FE8             ; START RELATIONAL
2170   0FE8 D7            push a
2171   0FE9 11            mov a, b
2172   0FEA 26 00 00      mov b, $0
2173   0FED B0            cmp a, b
2174   0FEE FD 71         seq ; ==
2175   0FF0 E4            pop a
2176   0FF1             ; END RELATIONAL
2177   0FF1 C0 00 00      cmp b, 0
2178   0FF4 C6 06 10      je _if33_exit
2179   0FF7             _if33_true:
2180   0FF7             ;; putchar('0'); 
2181   0FF7 26 30 00      mov b, $30
2182   0FFA DD            push bl
2183   0FFB 07 A4 10      call putchar
2184   0FFE 51 01 00      add sp, 1
2185   1001             ;; return; 
2186   1001 F9            leave
2187   1002 09            ret
2188   1003 0A 06 10      jmp _if33_exit
2189   1006             _if33_exit:
2190   1006             ;; while (num > 0) { 
2191   1006             _while34_cond:
2192   1006 FA 05 00      lea d, [bp + 5] ; $num
2193   1009 2A            mov b, [d]
2194   100A             ; START RELATIONAL
2195   100A D7            push a
2196   100B 11            mov a, b
2197   100C 26 00 00      mov b, $0
2198   100F B0            cmp a, b
2199   1010 FD 81         sgu ; > (unsigned)
2200   1012 E4            pop a
2201   1013             ; END RELATIONAL
2202   1013 C0 00 00      cmp b, 0
2203   1016 C6 60 10      je _while34_exit
2204   1019             _while34_block:
2205   1019             ;; digits[i] = '0' + (num % 10); 
2206   1019 FA FC FF      lea d, [bp + -4] ; $digits
2207   101C D7            push a
2208   101D DA            push d
2209   101E FA FA FF      lea d, [bp + -6] ; $i
2210   1021 2A            mov b, [d]
2211   1022 E7            pop d
2212   1023 5A            add d, b
2213   1024 E4            pop a
2214   1025 DA            push d
2215   1026 26 30 00      mov b, $30
2216   1029             ; START TERMS
2217   1029 D7            push a
2218   102A 11            mov a, b
2219   102B FA 05 00      lea d, [bp + 5] ; $num
2220   102E 2A            mov b, [d]
2221   102F             ; START FACTORS
2222   102F D7            push a
2223   1030 11            mov a, b
2224   1031 26 0A 00      mov b, $a
2225   1034 AE            div a, b ; 
2226   1035 11            mov a, b
2227   1036 27            mov b, a
2228   1037 E4            pop a
2229   1038             ; END FACTORS
2230   1038 56            add b, a
2231   1039 E4            pop a
2232   103A             ; END TERMS
2233   103A E7            pop d
2234   103B FD 3E         mov [d], bl
2235   103D             ;; num = num / 10; 
2236   103D FA 05 00      lea d, [bp + 5] ; $num
2237   1040 DA            push d
2238   1041 FA 05 00      lea d, [bp + 5] ; $num
2239   1044 2A            mov b, [d]
2240   1045             ; START FACTORS
2241   1045 D7            push a
2242   1046 11            mov a, b
2243   1047 26 0A 00      mov b, $a
2244   104A AE            div a, b
2245   104B 27            mov b, a
2246   104C E4            pop a
2247   104D             ; END FACTORS
2248   104D E7            pop d
2249   104E FD 43         mov [d], b
2250   1050             ;; i++; 
2251   1050 FA FA FF      lea d, [bp + -6] ; $i
2252   1053 2A            mov b, [d]
2253   1054 D8            push b
2254   1055 FD 77         inc b
2255   1057 FA FA FF      lea d, [bp + -6] ; $i
2256   105A FD 43         mov [d], b
2257   105C E5            pop b
2258   105D 0A 06 10      jmp _while34_cond
2259   1060             _while34_exit:
2260   1060             ;; while (i > 0) { 
2261   1060             _while35_cond:
2262   1060 FA FA FF      lea d, [bp + -6] ; $i
2263   1063 2A            mov b, [d]
2264   1064             ; START RELATIONAL
2265   1064 D7            push a
2266   1065 11            mov a, b
2267   1066 26 00 00      mov b, $0
2268   1069 B0            cmp a, b
2269   106A FD 7F         sgt ; >
2270   106C E4            pop a
2271   106D             ; END RELATIONAL
2272   106D C0 00 00      cmp b, 0
2273   1070 C6 99 10      je _while35_exit
2274   1073             _while35_block:
2275   1073             ;; i--; 
2276   1073 FA FA FF      lea d, [bp + -6] ; $i
2277   1076 2A            mov b, [d]
2278   1077 D8            push b
2279   1078 FD 7D         dec b
2280   107A FA FA FF      lea d, [bp + -6] ; $i
2281   107D FD 43         mov [d], b
2282   107F E5            pop b
2283   1080             ;; putchar(digits[i]); 
2284   1080 FA FC FF      lea d, [bp + -4] ; $digits
2285   1083 D7            push a
2286   1084 DA            push d
2287   1085 FA FA FF      lea d, [bp + -6] ; $i
2288   1088 2A            mov b, [d]
2289   1089 E7            pop d
2290   108A 5A            add d, b
2291   108B E4            pop a
2292   108C 32            mov bl, [d]
2293   108D A7 00         mov bh, 0
2294   108F DD            push bl
2295   1090 07 A4 10      call putchar
2296   1093 51 01 00      add sp, 1
2297   1096 0A 60 10      jmp _while35_cond
2298   1099             _while35_exit:
2299   1099 F9            leave
2300   109A 09            ret
2301   109B             
2302   109B             date:
2303   109B F8 00 00      enter 0 ; (push bp; mov bp, sp)
2304   109E             
2305   109E             ; --- BEGIN INLINE ASM BLOCK
2306   109E 19 00         mov al, 0 
2307   10A0 05 07         syscall sys_datetime
2308   10A2             ; --- END INLINE ASM BLOCK
2309   10A2             
2310   10A2 F9            leave
2311   10A3 09            ret
2312   10A4             
2313   10A4             putchar:
2314   10A4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2315   10A7             
2316   10A7             ; --- BEGIN INLINE ASM BLOCK
2317   10A7 FA 05 00      lea d, [bp + 5] ; $c
2318   10AA 1E            mov al, [d]
2319   10AB 23            mov ah, al
2320   10AC 07 10 12      call _putchar
2321   10AF             ; --- END INLINE ASM BLOCK
2322   10AF             
2323   10AF F9            leave
2324   10B0 09            ret
2325   10B1             
2326   10B1             getchar:
2327   10B1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2328   10B4             ; $c 
2329   10B4 52 01 00      sub sp, 1
2330   10B7             
2331   10B7             ; --- BEGIN INLINE ASM BLOCK
2332   10B7 07 09 12      call getch
2333   10BA 1A            mov al, ah
2334   10BB FA 00 00      lea d, [bp + 0] ; $c
2335   10BE 3E            mov [d], al
2336   10BF             ; --- END INLINE ASM BLOCK
2337   10BF             
2338   10BF             ;; return c; 
2339   10BF FA 00 00      lea d, [bp + 0] ; $c
2340   10C2 32            mov bl, [d]
2341   10C3 A7 00         mov bh, 0
2342   10C5 F9            leave
2343   10C6 09            ret
2344   10C7             
2345   10C7             scann:
2346   10C7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2347   10CA             ; $m 
2348   10CA 52 02 00      sub sp, 2
2349   10CD             
2350   10CD             ; --- BEGIN INLINE ASM BLOCK
2351   10CD 07 54 14      call scan_u16d
2352   10D0 FA FF FF      lea d, [bp + -1] ; $m
2353   10D3 43            mov [d], a
2354   10D4             ; --- END INLINE ASM BLOCK
2355   10D4             
2356   10D4             ;; return m; 
2357   10D4 FA FF FF      lea d, [bp + -1] ; $m
2358   10D7 2A            mov b, [d]
2359   10D8 F9            leave
2360   10D9 09            ret
2361   10DA             
2362   10DA             puts:
2363   10DA F8 00 00      enter 0 ; (push bp; mov bp, sp)
2364   10DD             
2365   10DD             ; --- BEGIN INLINE ASM BLOCK
2366   10DD FA 05 00      lea d, [bp + 5] ; $s
2367   10E0 15            mov a, [d]
2368   10E1 3C            mov d, a
2369   10E2 07 5A 13      call _puts
2370   10E5 10 00 0A      mov a, $0A00
2371   10E8 05 03         syscall sys_io
2372   10EA             ; --- END INLINE ASM BLOCK
2373   10EA             
2374   10EA F9            leave
2375   10EB 09            ret
2376   10EC             
2377   10EC             print:
2378   10EC F8 00 00      enter 0 ; (push bp; mov bp, sp)
2379   10EF             
2380   10EF             ; --- BEGIN INLINE ASM BLOCK
2381   10EF FA 05 00      lea d, [bp + 5] ; $s
2382   10F2 FD 2A         mov d, [d]
2383   10F4 07 5A 13      call _puts
2384   10F7             ; --- END INLINE ASM BLOCK
2385   10F7             
2386   10F7 F9            leave
2387   10F8 09            ret
2388   10F9             
2389   10F9             getparam:
2390   10F9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2391   10FC             ; $data 
2392   10FC 52 01 00      sub sp, 1
2393   10FF             
2394   10FF             ; --- BEGIN INLINE ASM BLOCK
2395   10FF 19 04         mov al, 4
2396   1101 FA 05 00      lea d, [bp + 5] ; $address
2397   1104 FD 2A         mov d, [d]
2398   1106 05 0C         syscall sys_system
2399   1108 FA 00 00      lea d, [bp + 0] ; $data
2400   110B FD 3E         mov [d], bl
2401   110D             ; --- END INLINE ASM BLOCK
2402   110D             
2403   110D             ;; return data; 
2404   110D FA 00 00      lea d, [bp + 0] ; $data
2405   1110 32            mov bl, [d]
2406   1111 A7 00         mov bh, 0
2407   1113 F9            leave
2408   1114 09            ret
2409   1115             
2410   1115             clear:
2411   1115 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2412   1118             ;; print("\033[2J\033[H"); 
2413   1118 26 84 15      mov b, __s3 ; "\033[2J\033[H"
2414   111B FD AB         swp b
2415   111D D8            push b
2416   111E 07 EC 10      call print
2417   1121 51 02 00      add sp, 2
2418   1124 F9            leave
2419   1125 09            ret
2420   1126             
2421   1126             include_stdio_asm:
2422   1126 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2423   1129             
2424   1129             ; --- BEGIN INLINE ASM BLOCK
2425   1129             .include "lib/asm/stdio.asm"
0001+  1129             ;-----------------------------------------------------------------------------
0002+  1129             ; stdio.s
0003+  1129             ;-----------------------------------------------------------------------------
0004+  1129             .include "lib/asm/string.asm"
0001++ 1129             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 1129             ; string.s
0003++ 1129             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 1129             
0005++ 1129             
0006++ 1129             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 1129             ; _strrev
0008++ 1129             ; reverse a string
0009++ 1129             ; D = string address
0010++ 1129             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 1129             ; 01234
0012++ 1129             _strrev:
0013++ 1129 4B          	pusha
0014++ 112A 07 70 11    	call _strlen	; length in C
0015++ 112D 12          	mov a, c
0016++ 112E AF 01 00    	cmp a, 1
0017++ 1131 D0 4B 11    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 1134 7D          	dec a
0019++ 1135 FD 4E       	mov si, d	; beginning of string
0020++ 1137 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 1139 59          	add d, a	; end of string
0022++ 113A 12          	mov a, c
0023++ 113B FD 9B       	shr a		; divide by 2
0024++ 113D 39          	mov c, a	; C now counts the steps
0025++ 113E             _strrev_L0:
0026++ 113E 32          	mov bl, [d]	; save load right-side char into BL
0027++ 113F F6          	lodsb		; load left-side char into AL; increase SI
0028++ 1140 3E          	mov [d], al	; store left char into right side
0029++ 1141 1B          	mov al, bl
0030++ 1142 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 1143 7E          	dec c
0032++ 1144 7F          	dec d
0033++ 1145 C2 00 00    	cmp c, 0
0034++ 1148 C7 3E 11    	jne _strrev_L0
0035++ 114B             _strrev_end:
0036++ 114B 4C          	popa
0037++ 114C 09          	ret
0038++ 114D             	
0039++ 114D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 114D             ; _strchr
0041++ 114D             ; search string in D for char in AL
0042++ 114D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 114D             _strchr:
0044++ 114D             _strchr_L0:
0045++ 114D 32          	mov bl, [d]
0046++ 114E C1 00       	cmp bl, 0
0047++ 1150 C6 5B 11    	je _strchr_end
0048++ 1153 BA          	cmp al, bl
0049++ 1154 C6 5B 11    	je _strchr_end
0050++ 1157 79          	inc d
0051++ 1158 0A 4D 11    	jmp _strchr_L0
0052++ 115B             _strchr_end:
0053++ 115B 1B          	mov al, bl
0054++ 115C 09          	ret
0055++ 115D             
0056++ 115D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 115D             ; _strstr
0058++ 115D             ; find sub-string
0059++ 115D             ; str1 in SI
0060++ 115D             ; str2 in DI
0061++ 115D             ; SI points to end of source string
0062++ 115D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 115D             _strstr:
0064++ 115D DB          	push al
0065++ 115E DA          	push d
0066++ 115F E3          	push di
0067++ 1160             _strstr_loop:
0068++ 1160 F3          	cmpsb					; compare a byte of the strings
0069++ 1161 C7 6C 11    	jne _strstr_ret
0070++ 1164 FC 00 00    	lea d, [di + 0]
0071++ 1167 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1169 C7 60 11    	jne _strstr_loop				; equal chars but not at end
0073++ 116C             _strstr_ret:
0074++ 116C F0          	pop di
0075++ 116D E7          	pop d
0076++ 116E E8          	pop al
0077++ 116F 09          	ret
0078++ 1170             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1170             ; length of null terminated string
0080++ 1170             ; result in C
0081++ 1170             ; pointer in D
0082++ 1170             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1170             _strlen:
0084++ 1170 DA          	push d
0085++ 1171 38 00 00    	mov c, 0
0086++ 1174             _strlen_L1:
0087++ 1174 BD 00       	cmp byte [d], 0
0088++ 1176 C6 7E 11    	je _strlen_ret
0089++ 1179 79          	inc d
0090++ 117A 78          	inc c
0091++ 117B 0A 74 11    	jmp _strlen_L1
0092++ 117E             _strlen_ret:
0093++ 117E E7          	pop d
0094++ 117F 09          	ret
0095++ 1180             
0096++ 1180             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1180             ; STRCMP
0098++ 1180             ; compare two strings
0099++ 1180             ; str1 in SI
0100++ 1180             ; str2 in DI
0101++ 1180             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 1180             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1180             _strcmp:
0104++ 1180 DB          	push al
0105++ 1181 DA          	push d
0106++ 1182 E3          	push di
0107++ 1183 E2          	push si
0108++ 1184             _strcmp_loop:
0109++ 1184 F3          	cmpsb					; compare a byte of the strings
0110++ 1185 C7 90 11    	jne _strcmp_ret
0111++ 1188 FB FF FF    	lea d, [si +- 1]
0112++ 118B BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 118D C7 84 11    	jne _strcmp_loop				; equal chars but not at end
0114++ 1190             _strcmp_ret:
0115++ 1190 EF          	pop si
0116++ 1191 F0          	pop di
0117++ 1192 E7          	pop d
0118++ 1193 E8          	pop al
0119++ 1194 09          	ret
0120++ 1195             
0121++ 1195             
0122++ 1195             ; STRCPY
0123++ 1195             ; copy null terminated string from SI to DI
0124++ 1195             ; source in SI
0125++ 1195             ; destination in DI
0126++ 1195             _strcpy:
0127++ 1195 E2          	push si
0128++ 1196 E3          	push di
0129++ 1197 DB          	push al
0130++ 1198             _strcpy_L1:
0131++ 1198 F6          	lodsb
0132++ 1199 F7          	stosb
0133++ 119A B9 00       	cmp al, 0
0134++ 119C C7 98 11    	jne _strcpy_L1
0135++ 119F             _strcpy_end:
0136++ 119F E8          	pop al
0137++ 11A0 F0          	pop di
0138++ 11A1 EF          	pop si
0139++ 11A2 09          	ret
0140++ 11A3             
0141++ 11A3             ; STRCAT
0142++ 11A3             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 11A3             ; source in SI
0144++ 11A3             ; destination in DI
0145++ 11A3             _strcat:
0146++ 11A3 E2          	push si
0147++ 11A4 E3          	push di
0148++ 11A5 D7          	push a
0149++ 11A6 DA          	push d
0150++ 11A7 50          	mov a, di
0151++ 11A8 3C          	mov d, a
0152++ 11A9             _strcat_goto_end_L1:
0153++ 11A9 BD 00       	cmp byte[d], 0
0154++ 11AB C6 B2 11    	je _strcat_start
0155++ 11AE 79          	inc d
0156++ 11AF 0A A9 11    	jmp _strcat_goto_end_L1
0157++ 11B2             _strcat_start:
0158++ 11B2 FD 50       	mov di, d
0159++ 11B4             _strcat_L1:
0160++ 11B4 F6          	lodsb
0161++ 11B5 F7          	stosb
0162++ 11B6 B9 00       	cmp al, 0
0163++ 11B8 C7 B4 11    	jne _strcat_L1
0164++ 11BB             _strcat_end:
0165++ 11BB E7          	pop d
0166++ 11BC E4          	pop a
0167++ 11BD F0          	pop di
0168++ 11BE EF          	pop si
0169++ 11BF 09          	ret
0170++ 11C0             
0171++ 11C0             
0005+  11C0             
0006+  11C0             ;-----------------------------------------------------------------------------
0007+  11C0             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0008+  11C0             ; ASCII in BL
0009+  11C0             ; result in AL
0010+  11C0             ; ascii for F = 0100 0110
0011+  11C0             ; ascii for 9 = 0011 1001
0012+  11C0             ;-----------------------------------------------------------------------------
0013+  11C0             hex_ascii_encode:
0014+  11C0 1B            mov al, bl
0015+  11C1 93 40         test al, $40        ; test if letter or number
0016+  11C3 C7 C9 11      jnz hex_letter
0017+  11C6 87 0F         and al, $0F        ; get number
0018+  11C8 09            ret
0019+  11C9             hex_letter:
0020+  11C9 87 0F         and al, $0F        ; get letter
0021+  11CB 6A 09         add al, 9
0022+  11CD 09            ret
0023+  11CE             
0024+  11CE             ;-----------------------------------------------------------------------------
0025+  11CE             ; ATOI
0026+  11CE             ; 2 letter hex string in B
0027+  11CE             ; 8bit integer returned in AL
0028+  11CE             ;-----------------------------------------------------------------------------
0029+  11CE             _atoi:
0030+  11CE D8            push b
0031+  11CF 07 C0 11      call hex_ascii_encode      ; convert BL to 4bit code in AL
0032+  11D2 30            mov bl, bh
0033+  11D3 DB            push al          ; save a
0034+  11D4 07 C0 11      call hex_ascii_encode
0035+  11D7 EA            pop bl  
0036+  11D8 FD 9E 04      shl al, 4
0037+  11DB 8C            or al, bl
0038+  11DC E5            pop b
0039+  11DD 09            ret  
0040+  11DE             
0041+  11DE             
0042+  11DE             ;-----------------------------------------------------------------------------
0043+  11DE             ; ITOA
0044+  11DE             ; 8bit value in BL
0045+  11DE             ; 2 byte ASCII result in A
0046+  11DE             ;-----------------------------------------------------------------------------
0047+  11DE             _itoa:
0048+  11DE DA            push d
0049+  11DF D8            push b
0050+  11E0 A7 00         mov bh, 0
0051+  11E2 FD A4 04      shr bl, 4  
0052+  11E5 74            mov d, b
0053+  11E6 1F 8E 14      mov al, [d + s_hex_digits]
0054+  11E9 23            mov ah, al
0055+  11EA               
0056+  11EA E5            pop b
0057+  11EB D8            push b
0058+  11EC A7 00         mov bh, 0
0059+  11EE FD 87 0F      and bl, $0F
0060+  11F1 74            mov d, b
0061+  11F2 1F 8E 14      mov al, [d + s_hex_digits]
0062+  11F5 E5            pop b
0063+  11F6 E7            pop d
0064+  11F7 09            ret
0065+  11F8             
0066+  11F8             ;-----------------------------------------------------------------------------
0067+  11F8             ; HEX STRING TO BINARY
0068+  11F8             ; di = destination address
0069+  11F8             ; si = source
0070+  11F8             ;-----------------------------------------------------------------------------
0071+  11F8             _hex_to_int:
0072+  11F8             _hex_to_int_L1:
0073+  11F8 F6            lodsb          ; load from [SI] to AL
0074+  11F9 B9 00         cmp al, 0        ; check if ASCII 0
0075+  11FB C6 08 12      jz _hex_to_int_ret
0076+  11FE 36            mov bh, al
0077+  11FF F6            lodsb
0078+  1200 2F            mov bl, al
0079+  1201 07 CE 11      call _atoi        ; convert ASCII byte in B to int (to AL)
0080+  1204 F7            stosb          ; store AL to [DI]
0081+  1205 0A F8 11      jmp _hex_to_int_L1
0082+  1208             _hex_to_int_ret:
0083+  1208 09            ret    
0084+  1209             
0085+  1209             ;-----------------------------------------------------------------------------
0086+  1209             ; GETCHAR
0087+  1209             ; char in ah
0088+  1209             ;-----------------------------------------------------------------------------
0089+  1209             getch:
0090+  1209 DB            push al
0091+  120A             getch_retry:
0092+  120A 19 01         mov al, 1
0093+  120C 05 03         syscall sys_io      ; receive in AH
0094+  120E E8            pop al
0095+  120F 09            ret
0096+  1210             
0097+  1210             ;-----------------------------------------------------------------------------
0098+  1210             ; PUTCHAR
0099+  1210             ; char in ah
0100+  1210             ;-----------------------------------------------------------------------------
0101+  1210             _putchar:
0102+  1210 D7            push a
0103+  1211 19 00         mov al, 0
0104+  1213 05 03         syscall sys_io      ; char in AH
0105+  1215 E4            pop a
0106+  1216 09            ret
0107+  1217             
0108+  1217             ;-----------------------------------------------------------------------------
0109+  1217             ;; INPUT A STRING
0110+  1217             ;; terminates with null
0111+  1217             ;; pointer in D
0112+  1217             ;-----------------------------------------------------------------------------
0113+  1217             _gets:
0114+  1217 D7            push a
0115+  1218 DA            push d
0116+  1219             _gets_loop:
0117+  1219 19 01         mov al, 1
0118+  121B 05 03         syscall sys_io      ; receive in AH
0119+  121D B9 00         cmp al, 0        ; check error code (AL)
0120+  121F C6 19 12      je _gets_loop      ; if no char received, retry
0121+  1222             
0122+  1222 76 1B         cmp ah, 27
0123+  1224 C6 45 12      je _gets_ansi_esc
0124+  1227 76 0A         cmp ah, $0A        ; LF
0125+  1229 C6 B0 12      je _gets_end
0126+  122C 76 0D         cmp ah, $0D        ; CR
0127+  122E C6 B0 12      je _gets_end
0128+  1231 76 5C         cmp ah, $5C        ; '\\'
0129+  1233 C6 71 12      je _gets_escape
0130+  1236               
0131+  1236 76 08         cmp ah, $08      ; check for backspace
0132+  1238 C6 41 12      je _gets_backspace
0133+  123B             
0134+  123B 1A            mov al, ah
0135+  123C 3E            mov [d], al
0136+  123D 79            inc d
0137+  123E 0A 19 12      jmp _gets_loop
0138+  1241             _gets_backspace:
0139+  1241 7F            dec d
0140+  1242 0A 19 12      jmp _gets_loop
0141+  1245             _gets_ansi_esc:
0142+  1245 19 01         mov al, 1
0143+  1247 05 03         syscall sys_io        ; receive in AH without echo
0144+  1249 B9 00         cmp al, 0          ; check error code (AL)
0145+  124B C6 45 12      je _gets_ansi_esc    ; if no char received, retry
0146+  124E 76 5B         cmp ah, '['
0147+  1250 C7 19 12      jne _gets_loop
0148+  1253             _gets_ansi_esc_2:
0149+  1253 19 01         mov al, 1
0150+  1255 05 03         syscall sys_io          ; receive in AH without echo
0151+  1257 B9 00         cmp al, 0            ; check error code (AL)
0152+  1259 C6 53 12      je _gets_ansi_esc_2  ; if no char received, retry
0153+  125C 76 44         cmp ah, 'D'
0154+  125E C6 69 12      je _gets_left_arrow
0155+  1261 76 43         cmp ah, 'C'
0156+  1263 C6 6D 12      je _gets_right_arrow
0157+  1266 0A 19 12      jmp _gets_loop
0158+  1269             _gets_left_arrow:
0159+  1269 7F            dec d
0160+  126A 0A 19 12      jmp _gets_loop
0161+  126D             _gets_right_arrow:
0162+  126D 79            inc d
0163+  126E 0A 19 12      jmp _gets_loop
0164+  1271             _gets_escape:
0165+  1271 19 01         mov al, 1
0166+  1273 05 03         syscall sys_io      ; receive in AH
0167+  1275 B9 00         cmp al, 0        ; check error code (AL)
0168+  1277 C6 71 12      je _gets_escape      ; if no char received, retry
0169+  127A 76 6E         cmp ah, 'n'
0170+  127C C6 9B 12      je _gets_LF
0171+  127F 76 72         cmp ah, 'r'
0172+  1281 C6 A2 12      je _gets_CR
0173+  1284 76 30         cmp ah, '0'
0174+  1286 C6 A9 12      je _gets_NULL
0175+  1289 76 5C         cmp ah, $5C  ; '\'
0176+  128B C6 94 12      je _gets_slash
0177+  128E 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0178+  128F 3E            mov [d], al
0179+  1290 79            inc d
0180+  1291 0A 19 12      jmp _gets_loop
0181+  1294             _gets_slash:
0182+  1294 19 5C         mov al, $5C
0183+  1296 3E            mov [d], al
0184+  1297 79            inc d
0185+  1298 0A 19 12      jmp _gets_loop
0186+  129B             _gets_LF:
0187+  129B 19 0A         mov al, $0A
0188+  129D 3E            mov [d], al
0189+  129E 79            inc d
0190+  129F 0A 19 12      jmp _gets_loop
0191+  12A2             _gets_CR:
0192+  12A2 19 0D         mov al, $0D
0193+  12A4 3E            mov [d], al
0194+  12A5 79            inc d
0195+  12A6 0A 19 12      jmp _gets_loop
0196+  12A9             _gets_NULL:
0197+  12A9 19 00         mov al, $00
0198+  12AB 3E            mov [d], al
0199+  12AC 79            inc d
0200+  12AD 0A 19 12      jmp _gets_loop
0201+  12B0             _gets_end:
0202+  12B0 19 00         mov al, 0
0203+  12B2 3E            mov [d], al        ; terminate string
0204+  12B3 E7            pop d
0205+  12B4 E4            pop a
0206+  12B5 09            ret
0207+  12B6             
0208+  12B6             ;-----------------------------------------------------------------------------
0209+  12B6             ;; INPUT TEXT
0210+  12B6             ;; terminated with CTRL+D
0211+  12B6             ;; pointer in D
0212+  12B6             ;-----------------------------------------------------------------------------
0213+  12B6             _gettxt:
0214+  12B6 D7            push a
0215+  12B7 DA            push d
0216+  12B8             _gettxt_loop:
0217+  12B8 19 01         mov al, 1
0218+  12BA 05 03         syscall sys_io      ; receive in AH
0219+  12BC B9 00         cmp al, 0        ; check error code (AL)
0220+  12BE C6 B8 12      je _gettxt_loop    ; if no char received, retry
0221+  12C1 76 04         cmp ah, 4      ; EOT
0222+  12C3 C6 01 13      je _gettxt_end
0223+  12C6 76 08         cmp ah, $08      ; check for backspace
0224+  12C8 C6 FD 12      je _gettxt_backspace
0225+  12CB 76 5C         cmp ah, $5C        ; '\'
0226+  12CD C6 D6 12      je _gettxt_escape
0227+  12D0 1A            mov al, ah
0228+  12D1 3E            mov [d], al
0229+  12D2 79            inc d
0230+  12D3 0A B8 12      jmp _gettxt_loop
0231+  12D6             _gettxt_escape:
0232+  12D6 19 01         mov al, 1
0233+  12D8 05 03         syscall sys_io      ; receive in AH
0234+  12DA B9 00         cmp al, 0        ; check error code (AL)
0235+  12DC C6 D6 12      je _gettxt_escape    ; if no char received, retry
0236+  12DF 76 6E         cmp ah, 'n'
0237+  12E1 C6 EF 12      je _gettxt_LF
0238+  12E4 76 72         cmp ah, 'r'
0239+  12E6 C6 F6 12      je _gettxt_CR
0240+  12E9 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0241+  12EA 3E            mov [d], al
0242+  12EB 79            inc d
0243+  12EC 0A B8 12      jmp _gettxt_loop
0244+  12EF             _gettxt_LF:
0245+  12EF 19 0A         mov al, $0A
0246+  12F1 3E            mov [d], al
0247+  12F2 79            inc d
0248+  12F3 0A B8 12      jmp _gettxt_loop
0249+  12F6             _gettxt_CR:
0250+  12F6 19 0D         mov al, $0D
0251+  12F8 3E            mov [d], al
0252+  12F9 79            inc d
0253+  12FA 0A B8 12      jmp _gettxt_loop
0254+  12FD             _gettxt_backspace:
0255+  12FD 7F            dec d
0256+  12FE 0A B8 12      jmp _gettxt_loop
0257+  1301             _gettxt_end:
0258+  1301 19 00         mov al, 0
0259+  1303 3E            mov [d], al        ; terminate string
0260+  1304 E7            pop d
0261+  1305 E4            pop a
0262+  1306 09            ret
0263+  1307             
0264+  1307             ;-----------------------------------------------------------------------------
0265+  1307             ; PRINT NEW LINE
0266+  1307             ;-----------------------------------------------------------------------------
0267+  1307             printnl:
0268+  1307 D7            push a
0269+  1308 10 00 0A      mov a, $0A00
0270+  130B 05 03         syscall sys_io
0271+  130D 10 00 0D      mov a, $0D00
0272+  1310 05 03         syscall sys_io
0273+  1312 E4            pop a
0274+  1313 09            ret
0275+  1314             
0276+  1314             ;-----------------------------------------------------------------------------
0277+  1314             ; _strtoint
0278+  1314             ; 4 digit hex string number in d
0279+  1314             ; integer returned in A
0280+  1314             ;-----------------------------------------------------------------------------
0281+  1314             _strtointx:
0282+  1314 D8            push b
0283+  1315 32            mov bl, [d]
0284+  1316 37            mov bh, bl
0285+  1317 33 01 00      mov bl, [d + 1]
0286+  131A 07 CE 11      call _atoi        ; convert to int in AL
0287+  131D 23            mov ah, al        ; move to AH
0288+  131E 33 02 00      mov bl, [d + 2]
0289+  1321 37            mov bh, bl
0290+  1322 33 03 00      mov bl, [d + 3]
0291+  1325 07 CE 11      call _atoi        ; convert to int in AL
0292+  1328 E5            pop b
0293+  1329 09            ret
0294+  132A             
0295+  132A             ;-----------------------------------------------------------------------------
0296+  132A             ; _strtoint
0297+  132A             ; 5 digit base10 string number in d
0298+  132A             ; integer returned in A
0299+  132A             ;-----------------------------------------------------------------------------
0300+  132A             _strtoint:
0301+  132A E2            push si
0302+  132B D8            push b
0303+  132C D9            push c
0304+  132D DA            push d
0305+  132E 07 70 11      call _strlen      ; get string length in C
0306+  1331 7E            dec c
0307+  1332 FD 4E         mov si, d
0308+  1334 12            mov a, c
0309+  1335 FD 99         shl a
0310+  1337 3B A6 14      mov d, table_power
0311+  133A 59            add d, a
0312+  133B 38 00 00      mov c, 0
0313+  133E             _strtoint_L0:
0314+  133E F6            lodsb      ; load ASCII to al
0315+  133F B9 00         cmp al, 0
0316+  1341 C6 54 13      je _strtoint_end
0317+  1344 6F 30         sub al, $30    ; make into integer
0318+  1346 22 00         mov ah, 0
0319+  1348 2A            mov b, [d]
0320+  1349 AC            mul a, b      ; result in B since it fits in 16bits
0321+  134A 11            mov a, b
0322+  134B 28            mov b, c
0323+  134C 54            add a, b
0324+  134D 39            mov c, a
0325+  134E 63 02 00      sub d, 2
0326+  1351 0A 3E 13      jmp _strtoint_L0
0327+  1354             _strtoint_end:
0328+  1354 12            mov a, c
0329+  1355 E7            pop d
0330+  1356 E6            pop c
0331+  1357 E5            pop b
0332+  1358 EF            pop si
0333+  1359 09            ret
0334+  135A             
0335+  135A             ;-----------------------------------------------------------------------------
0336+  135A             ; PRINT NULL TERMINATED STRING
0337+  135A             ; pointer in D
0338+  135A             ;-----------------------------------------------------------------------------
0339+  135A             _puts:
0340+  135A D7            push a
0341+  135B DA            push d
0342+  135C             _puts_L1:
0343+  135C 1E            mov al, [d]
0344+  135D B9 00         cmp al, 0
0345+  135F C6 6B 13      jz _puts_END
0346+  1362 23            mov ah, al
0347+  1363 19 00         mov al, 0
0348+  1365 05 03         syscall sys_io
0349+  1367 79            inc d
0350+  1368 0A 5C 13      jmp _puts_L1
0351+  136B             _puts_END:
0352+  136B E7            pop d
0353+  136C E4            pop a
0354+  136D 09            ret
0355+  136E             
0356+  136E             ;-----------------------------------------------------------------------------
0357+  136E             ; PRINT N SIZE STRING
0358+  136E             ; pointer in D
0359+  136E             ; size in C
0360+  136E             ;-----------------------------------------------------------------------------
0361+  136E             _putsn:
0362+  136E DB            push al
0363+  136F DA            push d
0364+  1370 D9            push c
0365+  1371             _putsn_L0:
0366+  1371 1E            mov al, [d]
0367+  1372 23            mov ah, al
0368+  1373 19 00         mov al, 0
0369+  1375 05 03         syscall sys_io
0370+  1377 79            inc d
0371+  1378 7E            dec c  
0372+  1379 C2 00 00      cmp c, 0
0373+  137C C7 71 13      jne _putsn_L0
0374+  137F             _putsn_end:
0375+  137F E6            pop c
0376+  1380 E7            pop d
0377+  1381 E8            pop al
0378+  1382 09            ret
0379+  1383             
0380+  1383             ;-----------------------------------------------------------------------------
0381+  1383             ; print 16bit decimal number
0382+  1383             ; input number in A
0383+  1383             ;-----------------------------------------------------------------------------
0384+  1383             print_u16d:
0385+  1383 D7            push a
0386+  1384 D8            push b
0387+  1385 26 10 27      mov b, 10000
0388+  1388 AE            div a, b      ; get 10000's coeff.
0389+  1389 07 AB 13      call print_number
0390+  138C 11            mov a, b
0391+  138D 26 E8 03      mov b, 1000
0392+  1390 AE            div a, b      ; get 1000's coeff.
0393+  1391 07 AB 13      call print_number
0394+  1394 11            mov a, b
0395+  1395 26 64 00      mov b, 100
0396+  1398 AE            div a, b
0397+  1399 07 AB 13      call print_number
0398+  139C 11            mov a, b
0399+  139D 26 0A 00      mov b, 10
0400+  13A0 AE            div a, b
0401+  13A1 07 AB 13      call print_number
0402+  13A4 1B            mov al, bl      ; 1's coeff in bl
0403+  13A5 07 AB 13      call print_number
0404+  13A8 E5            pop b
0405+  13A9 E4            pop a
0406+  13AA 09            ret
0407+  13AB             
0408+  13AB             ;-----------------------------------------------------------------------------
0409+  13AB             ; print AL
0410+  13AB             ;-----------------------------------------------------------------------------
0411+  13AB             print_number:
0412+  13AB 6A 30         add al, $30
0413+  13AD 23            mov ah, al
0414+  13AE 07 10 12      call _putchar
0415+  13B1 09            ret
0416+  13B2             
0417+  13B2             ;-----------------------------------------------------------------------------
0418+  13B2             ; PRINT 16BIT HEX INTEGER
0419+  13B2             ; integer value in reg B
0420+  13B2             ;-----------------------------------------------------------------------------
0421+  13B2             print_u16x:
0422+  13B2 D7            push a
0423+  13B3 D8            push b
0424+  13B4 DD            push bl
0425+  13B5 30            mov bl, bh
0426+  13B6 07 DE 11      call _itoa        ; convert bh to char in A
0427+  13B9 2F            mov bl, al        ; save al
0428+  13BA 19 00         mov al, 0
0429+  13BC 05 03         syscall sys_io        ; display AH
0430+  13BE 24            mov ah, bl        ; retrieve al
0431+  13BF 19 00         mov al, 0
0432+  13C1 05 03         syscall sys_io        ; display AL
0433+  13C3             
0434+  13C3 EA            pop bl
0435+  13C4 07 DE 11      call _itoa        ; convert bh to char in A
0436+  13C7 2F            mov bl, al        ; save al
0437+  13C8 19 00         mov al, 0
0438+  13CA 05 03         syscall sys_io        ; display AH
0439+  13CC 24            mov ah, bl        ; retrieve al
0440+  13CD 19 00         mov al, 0
0441+  13CF 05 03         syscall sys_io        ; display AL
0442+  13D1             
0443+  13D1 E5            pop b
0444+  13D2 E4            pop a
0445+  13D3 09            ret
0446+  13D4             
0447+  13D4             ;-----------------------------------------------------------------------------
0448+  13D4             ; INPUT 16BIT HEX INTEGER
0449+  13D4             ; read 16bit integer into A
0450+  13D4             ;-----------------------------------------------------------------------------
0451+  13D4             scan_u16x:
0452+  13D4 F8 10 00      enter 16
0453+  13D7 D8            push b
0454+  13D8 DA            push d
0455+  13D9             
0456+  13D9 FA F1 FF      lea d, [bp + -15]
0457+  13DC 07 17 12      call _gets        ; get number
0458+  13DF             
0459+  13DF 32            mov bl, [d]
0460+  13E0 37            mov bh, bl
0461+  13E1 33 01 00      mov bl, [d + 1]
0462+  13E4 07 CE 11      call _atoi        ; convert to int in AL
0463+  13E7 23            mov ah, al        ; move to AH
0464+  13E8             
0465+  13E8 33 02 00      mov bl, [d + 2]
0466+  13EB 37            mov bh, bl
0467+  13EC 33 03 00      mov bl, [d + 3]
0468+  13EF 07 CE 11      call _atoi        ; convert to int in AL
0469+  13F2             
0470+  13F2 E7            pop d
0471+  13F3 E5            pop b
0472+  13F4 F9            leave
0473+  13F5 09            ret
0474+  13F6             
0475+  13F6             ;-----------------------------------------------------------------------------
0476+  13F6             ; PRINT 8bit HEX INTEGER
0477+  13F6             ; integer value in reg bl
0478+  13F6             ;-----------------------------------------------------------------------------
0479+  13F6             print_u8x:
0480+  13F6 D7            push a
0481+  13F7 DD            push bl
0482+  13F8             
0483+  13F8 07 DE 11      call _itoa        ; convert bl to char in A
0484+  13FB 2F            mov bl, al        ; save al
0485+  13FC 19 00         mov al, 0
0486+  13FE 05 03         syscall sys_io        ; display AH
0487+  1400 24            mov ah, bl        ; retrieve al
0488+  1401 19 00         mov al, 0
0489+  1403 05 03         syscall sys_io        ; display AL
0490+  1405             
0491+  1405 EA            pop bl
0492+  1406 E4            pop a
0493+  1407 09            ret
0494+  1408             
0495+  1408             ;-----------------------------------------------------------------------------
0496+  1408             ; print 8bit decimal unsigned number
0497+  1408             ; input number in AL
0498+  1408             ;-----------------------------------------------------------------------------
0499+  1408             print_u8d:
0500+  1408 D7            push a
0501+  1409 D8            push b
0502+  140A             
0503+  140A 22 00         mov ah, 0
0504+  140C 26 64 00      mov b, 100
0505+  140F AE            div a, b
0506+  1410 D8            push b      ; save remainder
0507+  1411 B9 00         cmp al, 0
0508+  1413 C6 1D 14      je skip100
0509+  1416 6A 30         add al, $30
0510+  1418 23            mov ah, al
0511+  1419 19 00         mov al, 0
0512+  141B 05 03         syscall sys_io  ; print coeff
0513+  141D             skip100:
0514+  141D E4            pop a
0515+  141E 22 00         mov ah, 0
0516+  1420 26 0A 00      mov b, 10
0517+  1423 AE            div a, b
0518+  1424 D8            push b      ; save remainder
0519+  1425 B9 00         cmp al, 0
0520+  1427 C6 31 14      je skip10
0521+  142A 6A 30         add al, $30
0522+  142C 23            mov ah, al
0523+  142D 19 00         mov al, 0
0524+  142F 05 03         syscall sys_io  ; print coeff
0525+  1431             skip10:
0526+  1431 E4            pop a
0527+  1432 1B            mov al, bl
0528+  1433 6A 30         add al, $30
0529+  1435 23            mov ah, al
0530+  1436 19 00         mov al, 0
0531+  1438 05 03         syscall sys_io  ; print coeff
0532+  143A E5            pop b
0533+  143B E4            pop a
0534+  143C 09            ret
0535+  143D             
0536+  143D             ;-----------------------------------------------------------------------------
0537+  143D             ; INPUT 8BIT HEX INTEGER
0538+  143D             ; read 8bit integer into AL
0539+  143D             ;-----------------------------------------------------------------------------
0540+  143D             scan_u8x:
0541+  143D F8 04 00      enter 4
0542+  1440 D8            push b
0543+  1441 DA            push d
0544+  1442             
0545+  1442 FA FD FF      lea d, [bp + -3]
0546+  1445 07 17 12      call _gets        ; get number
0547+  1448             
0548+  1448 32            mov bl, [d]
0549+  1449 37            mov bh, bl
0550+  144A 33 01 00      mov bl, [d + 1]
0551+  144D 07 CE 11      call _atoi        ; convert to int in AL
0552+  1450             
0553+  1450 E7            pop d
0554+  1451 E5            pop b
0555+  1452 F9            leave
0556+  1453 09            ret
0557+  1454             
0558+  1454             ;-----------------------------------------------------------------------------
0559+  1454             ; input decimal number
0560+  1454             ; result in A
0561+  1454             ; 655'\0'
0562+  1454             ; low--------high
0563+  1454             ;-----------------------------------------------------------------------------
0564+  1454             scan_u16d:
0565+  1454 F8 08 00      enter 8
0566+  1457 E2            push si
0567+  1458 D8            push b
0568+  1459 D9            push c
0569+  145A DA            push d
0570+  145B FA F9 FF      lea d, [bp +- 7]
0571+  145E 07 17 12      call _gets
0572+  1461 07 70 11      call _strlen      ; get string length in C
0573+  1464 7E            dec c
0574+  1465 FD 4E         mov si, d
0575+  1467 12            mov a, c
0576+  1468 FD 99         shl a
0577+  146A 3B A6 14      mov d, table_power
0578+  146D 59            add d, a
0579+  146E 38 00 00      mov c, 0
0580+  1471             mul_loop:
0581+  1471 F6            lodsb      ; load ASCII to al
0582+  1472 B9 00         cmp al, 0
0583+  1474 C6 87 14      je mul_exit
0584+  1477 6F 30         sub al, $30    ; make into integer
0585+  1479 22 00         mov ah, 0
0586+  147B 2A            mov b, [d]
0587+  147C AC            mul a, b      ; result in B since it fits in 16bits
0588+  147D 11            mov a, b
0589+  147E 28            mov b, c
0590+  147F 54            add a, b
0591+  1480 39            mov c, a
0592+  1481 63 02 00      sub d, 2
0593+  1484 0A 71 14      jmp mul_loop
0594+  1487             mul_exit:
0595+  1487 12            mov a, c
0596+  1488 E7            pop d
0597+  1489 E6            pop c
0598+  148A E5            pop b
0599+  148B EF            pop si
0600+  148C F9            leave
0601+  148D 09            ret
0602+  148E             
0603+  148E 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0603+  1492 34 35 36 37 
0603+  1496 38 39 41 42 
0603+  149A 43 44 45 46 
0604+  149E 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0604+  14A2 1B 5B 48 00 
0605+  14A6             
0606+  14A6             table_power:
0607+  14A6 01 00         .dw 1
0608+  14A8 0A 00         .dw 10
0609+  14AA 64 00         .dw 100
0610+  14AC E8 03         .dw 1000
0611+  14AE 10 27         .dw 100002426   14B0             ; --- END INLINE ASM BLOCK
2427   14B0             
2428   14B0 F9            leave
2429   14B1 09            ret
2430   14B2             ; --- END TEXT BLOCK
2431   14B2             
2432   14B2             ; --- BEGIN DATA BLOCK
2433   14B2 00          _c0: .fill 1, 0
2434   14B3 00 00       _i0: .fill 2, 0
2435   14B5 00 00       _c_array0_data: .fill 2, 0
2436   14B7 00 00 00 00 _i_array0_data: .fill 4, 0
2437   14BB 00 00 00 00 _cp_array0_data: .fill 4, 0
2438   14BF 00 00 00 00 _ip_array0_data: .fill 4, 0
2439   14C3 00 00 00 00 _cpp_array0_data: .fill 4, 0
2440   14C7 00 00 00 00 _ipp_array0_data: .fill 4, 0
2441   14CB 00 00 00 00 _cc_array0_data: .fill 4, 0
2442   14CF 00 00 00 00 _ii_array0_data: .fill 8, 0
2442   14D3 00 00 00 00 
2443   14D7 00 00 00 00 _ccp_array0_data: .fill 8, 0
2443   14DB 00 00 00 00 
2444   14DF 00 00 00 00 _iip_array0_data: .fill 8, 0
2444   14E3 00 00 00 00 
2445   14E7 00 00 00 00 _ccpp_array0_data: .fill 8, 0
2445   14EB 00 00 00 00 
2446   14EF 00 00 00 00 _iipp_array0_data: .fill 8, 0
2446   14F3 00 00 00 00 
2447   14F7 00 00 00 00 _st0_data: .fill 69, 0
2447   14FB 00 00 00 00 
2447   14FF 00 00 00 00 
2447   1503 00 00 00 00 
2447   1507 00 00 00 00 
2447   150B 00 00 00 00 
2447   150F 00 00 00 00 
2447   1513 00 00 00 00 
2447   1517 00 00 00 00 
2447   151B 00 00 00 00 
2447   151F 00 00 00 00 
2447   1523 00 00 00 00 
2447   1527 00 00 00 00 
2447   152B 00 00 00 00 
2447   152F 00 00 00 00 
2447   1533 00 00 00 00 
2447   1537 00 00 00 00 
2447   153B 00 
2448   153C 52 65 73 75 __s0: .db "Result: %d\n", 0
2448   1540 6C 74 3A 20 
2448   1544 25 64 0A 00 
2449   1548 55 6E 65 78 __s1: .db "Unexpected format in printf.", 0
2449   154C 70 65 63 74 
2449   1550 65 64 20 66 
2449   1554 6F 72 6D 61 
2449   1558 74 20 69 6E 
2449   155C 20 70 72 69 
2449   1560 6E 74 66 2E 
2449   1564 00 
2450   1565 45 72 72 6F __s2: .db "Error: Unknown argument type.\n", 0
2450   1569 72 3A 20 55 
2450   156D 6E 6B 6E 6F 
2450   1571 77 6E 20 61 
2450   1575 72 67 75 6D 
2450   1579 65 6E 74 20 
2450   157D 74 79 70 65 
2450   1581 2E 0A 00 
2451   1584 1B 5B 32 4A __s3: .db "\033[2J\033[H", 0
2451   1588 1B 5B 48 00 
2452   158C             
2453   158C 8E 15       _heap_top: .dw _heap
2454   158E 00          _heap: .db 0
2455   158F             ; --- END DATA BLOCK
2456   158F             
2457   158F             .end
tasm: Number of errors = 0
