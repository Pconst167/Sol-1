0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0000             
0005   0000             ; --- BEGIN TEXT SEGMENT
0006   0400             .org text_org
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; char option; 
0011   0408 52 01 00      sub sp, 1
0012   040B             ; char byte; 
0013   040B 52 01 00      sub sp, 1
0014   040E             ; printf("Test of 5.25 inch Floppy Drive Interface.\n"); 
0015   040E             ; --- START FUNCTION CALL
0016   040E 26 16 0E      mov b, _s0 ; "Test of 5.25 inch Floppy Drive Interface.\n"
0017   0411 FD AB         swp b
0018   0413 D8            push b
0019   0414 07 FF 04      call printf
0020   0417 51 02 00      add sp, 2
0021   041A             ; --- END FUNCTION CALL
0022   041A             ; --- BEGIN INLINE ASM SEGMENT
0023   041A 3B C0 FF      mov d, $FFC0    ; wd1770 data register
0024   041D 19 02         mov al, 2       ; setparam call
0025   041F 2E 09         mov bl, $09     ; track 16
0026   0421 05 0C         syscall sys_system
0027   0423             ; --- END INLINE ASM SEGMENT
0028   0423             ; for(;;){ 
0029   0423             _for1_init:
0030   0423             _for1_cond:
0031   0423             _for1_block:
0032   0423             ; printf("\nOption: "); 
0033   0423             ; --- START FUNCTION CALL
0034   0423 26 41 0E      mov b, _s1 ; "\nOption: "
0035   0426 FD AB         swp b
0036   0428 D8            push b
0037   0429 07 FF 04      call printf
0038   042C 51 02 00      add sp, 2
0039   042F             ; --- END FUNCTION CALL
0040   042F             ; option = getchar(); 
0041   042F FA 00 00      lea d, [bp + 0] ; $option
0042   0432 DA            push d
0043   0433             ; --- START FUNCTION CALL
0044   0433 07 FC 0D      call getchar
0045   0436 E7            pop d
0046   0437 FD 3E         mov [d], bl
0047   0439             ; switch(option){ 
0048   0439             _switch2_expr:
0049   0439 FA 00 00      lea d, [bp + 0] ; $option
0050   043C 32            mov bl, [d]
0051   043D A7 00         mov bh, 0
0052   043F 38 00 00      mov c, 0
0053   0442             _switch2_comparisons:
0054   0442 C1 77         cmp bl, $77
0055   0444 C6 6D 04      je _switch2_case0
0056   0447 C1 64         cmp bl, $64
0057   0449 C6 79 04      je _switch2_case1
0058   044C C1 74         cmp bl, $74
0059   044E C6 A0 04      je _switch2_case2
0060   0451 C1 73         cmp bl, $73
0061   0453 C6 C7 04      je _switch2_case3
0062   0456 C1 72         cmp bl, $72
0063   0458 C6 D3 04      je _switch2_case4
0064   045B C1 69         cmp bl, $69
0065   045D C6 DF 04      je _switch2_case5
0066   0460 C1 6F         cmp bl, $6f
0067   0462 C6 EB 04      je _switch2_case6
0068   0465 C1 65         cmp bl, $65
0069   0467 C6 F7 04      je _switch2_case7
0070   046A 0A FA 04      jmp _switch2_exit
0071   046D             _switch2_case0:
0072   046D             ; --- BEGIN INLINE ASM SEGMENT
0073   046D 3B CB FF      mov d, $FFCB    ; wd1770 data register
0074   0470 19 02         mov al, 2       ; setparam call
0075   0472 2E 10         mov bl, $10     ; track 16
0076   0474 05 0C         syscall sys_system
0077   0476             ; --- END INLINE ASM SEGMENT
0078   0476             ; break; 
0079   0476 0A FA 04      jmp _switch2_exit ; case break
0080   0479             _switch2_case1:
0081   0479             ; --- BEGIN INLINE ASM SEGMENT
0082   0479 3B CB FF      mov d, $FFCB    ; wd1770 data register
0083   047C 19 04         mov al, 4       ; getparam call
0084   047E 05 0C         syscall sys_system
0085   0480 FA FF FF      lea d, [bp + -1] ; $byte
0086   0483 FD 3E         mov [d], bl
0087   0485             ; --- END INLINE ASM SEGMENT
0088   0485             ; printf("\nData register value: %d\n", byte); 
0089   0485             ; --- START FUNCTION CALL
0090   0485 FA FF FF      lea d, [bp + -1] ; $byte
0091   0488 32            mov bl, [d]
0092   0489 A7 00         mov bh, 0
0093   048B 38 00 00      mov c, 0
0094   048E FD AB         swp b
0095   0490 D8            push b
0096   0491 26 4B 0E      mov b, _s2 ; "\nData register value: %d\n"
0097   0494 FD AB         swp b
0098   0496 D8            push b
0099   0497 07 FF 04      call printf
0100   049A 51 03 00      add sp, 3
0101   049D             ; --- END FUNCTION CALL
0102   049D             ; break; 
0103   049D 0A FA 04      jmp _switch2_exit ; case break
0104   04A0             _switch2_case2:
0105   04A0             ; --- BEGIN INLINE ASM SEGMENT
0106   04A0 3B C9 FF      mov d, $FFC9    ; wd1770 track register
0107   04A3 19 04         mov al, 4       ; getparam call
0108   04A5 05 0C         syscall sys_system
0109   04A7 FA FF FF      lea d, [bp + -1] ; $byte
0110   04AA FD 3E         mov [d], bl
0111   04AC             ; --- END INLINE ASM SEGMENT
0112   04AC             ; printf("\nTrack register value: %d\n", byte); 
0113   04AC             ; --- START FUNCTION CALL
0114   04AC FA FF FF      lea d, [bp + -1] ; $byte
0115   04AF 32            mov bl, [d]
0116   04B0 A7 00         mov bh, 0
0117   04B2 38 00 00      mov c, 0
0118   04B5 FD AB         swp b
0119   04B7 D8            push b
0120   04B8 26 65 0E      mov b, _s3 ; "\nTrack register value: %d\n"
0121   04BB FD AB         swp b
0122   04BD D8            push b
0123   04BE 07 FF 04      call printf
0124   04C1 51 03 00      add sp, 3
0125   04C4             ; --- END FUNCTION CALL
0126   04C4             ; break; 
0127   04C4 0A FA 04      jmp _switch2_exit ; case break
0128   04C7             _switch2_case3:
0129   04C7             ; --- BEGIN INLINE ASM SEGMENT
0130   04C7 3B C8 FF      mov d, $FFC8    ; wd1770 command register
0131   04CA 19 02         mov al, 2       ; setparam call
0132   04CC 2E 23         mov bl, $23     ; STEP command, 30ms rate
0133   04CE 05 0C         syscall sys_system
0134   04D0             ; --- END INLINE ASM SEGMENT
0135   04D0             ; break; 
0136   04D0 0A FA 04      jmp _switch2_exit ; case break
0137   04D3             _switch2_case4:
0138   04D3             ; --- BEGIN INLINE ASM SEGMENT
0139   04D3               ; send restore command
0140   04D3 3B C8 FF      mov d, $FFC8    ; wd1770
0141   04D6 19 02         mov al, 2       ; setparam call
0142   04D8 2E 03         mov bl, $03     ; restore command, 30ms rate
0143   04DA 05 0C         syscall sys_system
0144   04DC             ; --- END INLINE ASM SEGMENT
0145   04DC             ; break; 
0146   04DC 0A FA 04      jmp _switch2_exit ; case break
0147   04DF             _switch2_case5:
0148   04DF             ; --- BEGIN INLINE ASM SEGMENT
0149   04DF               ; send step in command
0150   04DF 3B C8 FF      mov d, $FFC8    ; wd1770
0151   04E2 19 02         mov al, 2       ; setparam call
0152   04E4 2E 43         mov bl, $43     ; step in command, 30ms rate
0153   04E6 05 0C         syscall sys_system
0154   04E8             ; --- END INLINE ASM SEGMENT
0155   04E8             ; break; 
0156   04E8 0A FA 04      jmp _switch2_exit ; case break
0157   04EB             _switch2_case6:
0158   04EB             ; --- BEGIN INLINE ASM SEGMENT
0159   04EB               ; send step out command
0160   04EB 3B C8 FF      mov d, $FFC8    ; wd1770
0161   04EE 19 02         mov al, 2       ; setparam call
0162   04F0 2E 63         mov bl, $63     ; step out command, 30ms rate
0163   04F2 05 0C         syscall sys_system
0164   04F4             ; --- END INLINE ASM SEGMENT
0165   04F4             ; break; 
0166   04F4 0A FA 04      jmp _switch2_exit ; case break
0167   04F7             _switch2_case7:
0168   04F7             ; return; 
0169   04F7 F9            leave
0170   04F8 05 0B         syscall sys_terminate_proc
0171   04FA             _switch2_exit:
0172   04FA             _for1_update:
0173   04FA 0A 23 04      jmp _for1_cond
0174   04FD             _for1_exit:
0175   04FD 05 0B         syscall sys_terminate_proc
0176   04FF             
0177   04FF             printf:
0178   04FF F8 00 00      enter 0 ; (push bp; mov bp, sp)
0179   0502             ; char *p, *format_p; 
0180   0502 52 02 00      sub sp, 2
0181   0505 52 02 00      sub sp, 2
0182   0508             ; format_p = format; 
0183   0508 FA FD FF      lea d, [bp + -3] ; $format_p
0184   050B DA            push d
0185   050C FA 05 00      lea d, [bp + 5] ; $format
0186   050F 2A            mov b, [d]
0187   0510 38 00 00      mov c, 0
0188   0513 E7            pop d
0189   0514 FD 43         mov [d], b
0190   0516             ; p = &format + 2; 
0191   0516 FA FF FF      lea d, [bp + -1] ; $p
0192   0519 DA            push d
0193   051A FA 05 00      lea d, [bp + 5] ; $format
0194   051D 2D            mov b, d
0195   051E             ; --- START TERMS
0196   051E D7            push a
0197   051F 11            mov a, b
0198   0520 FD 2E 02 00   mov32 cb, $00000002
0198   0524 00 00 
0199   0526 56            add b, a
0200   0527 E4            pop a
0201   0528             ; --- END TERMS
0202   0528 E7            pop d
0203   0529 FD 43         mov [d], b
0204   052B             ; for(;;){ 
0205   052B             _for3_init:
0206   052B             _for3_cond:
0207   052B             _for3_block:
0208   052B             ; if(!*format_p) break; 
0209   052B             _if4_cond:
0210   052B FA FD FF      lea d, [bp + -3] ; $format_p
0211   052E 2A            mov b, [d]
0212   052F 38 00 00      mov c, 0
0213   0532 74            mov d, b
0214   0533 32            mov bl, [d]
0215   0534 A7 00         mov bh, 0
0216   0536 38 00 00      mov c, 0
0217   0539 C0 00 00      cmp b, 0
0218   053C FD 71         seq ; !
0219   053E C0 00 00      cmp b, 0
0220   0541 C6 4A 05      je _if4_else
0221   0544             _if4_TRUE:
0222   0544             ; break; 
0223   0544 0A EA 07      jmp _for3_exit ; for break
0224   0547 0A D7 07      jmp _if4_exit
0225   054A             _if4_else:
0226   054A             ; if(*format_p == '%'){ 
0227   054A             _if5_cond:
0228   054A FA FD FF      lea d, [bp + -3] ; $format_p
0229   054D 2A            mov b, [d]
0230   054E 38 00 00      mov c, 0
0231   0551 74            mov d, b
0232   0552 32            mov bl, [d]
0233   0553 A7 00         mov bh, 0
0234   0555 38 00 00      mov c, 0
0235   0558             ; --- START RELATIONAL
0236   0558 D7            push a
0237   0559 11            mov a, b
0238   055A FD 2E 25 00   mov32 cb, $00000025
0238   055E 00 00 
0239   0560 B0            cmp a, b
0240   0561 FD 71         seq ; ==
0241   0563 E4            pop a
0242   0564             ; --- END RELATIONAL
0243   0564 C0 00 00      cmp b, 0
0244   0567 C6 C2 07      je _if5_else
0245   056A             _if5_TRUE:
0246   056A             ; format_p++; 
0247   056A FA FD FF      lea d, [bp + -3] ; $format_p
0248   056D 2A            mov b, [d]
0249   056E 38 00 00      mov c, 0
0250   0571 FD 77         inc b
0251   0573 FA FD FF      lea d, [bp + -3] ; $format_p
0252   0576 FD 43         mov [d], b
0253   0578 FD 7D         dec b
0254   057A             ; switch(*format_p){ 
0255   057A             _switch6_expr:
0256   057A FA FD FF      lea d, [bp + -3] ; $format_p
0257   057D 2A            mov b, [d]
0258   057E 38 00 00      mov c, 0
0259   0581 74            mov d, b
0260   0582 32            mov bl, [d]
0261   0583 A7 00         mov bh, 0
0262   0585 38 00 00      mov c, 0
0263   0588             _switch6_comparisons:
0264   0588 C1 6C         cmp bl, $6c
0265   058A C6 B6 05      je _switch6_case0
0266   058D C1 4C         cmp bl, $4c
0267   058F C6 B6 05      je _switch6_case1
0268   0592 C1 64         cmp bl, $64
0269   0594 C6 C6 06      je _switch6_case2
0270   0597 C1 69         cmp bl, $69
0271   0599 C6 C6 06      je _switch6_case3
0272   059C C1 75         cmp bl, $75
0273   059E C6 F6 06      je _switch6_case4
0274   05A1 C1 78         cmp bl, $78
0275   05A3 C6 26 07      je _switch6_case5
0276   05A6 C1 63         cmp bl, $63
0277   05A8 C6 56 07      je _switch6_case6
0278   05AB C1 73         cmp bl, $73
0279   05AD C6 86 07      je _switch6_case7
0280   05B0 0A B3 07      jmp _switch6_default
0281   05B3 0A BF 07      jmp _switch6_exit
0282   05B6             _switch6_case0:
0283   05B6             _switch6_case1:
0284   05B6             ; format_p++; 
0285   05B6 FA FD FF      lea d, [bp + -3] ; $format_p
0286   05B9 2A            mov b, [d]
0287   05BA 38 00 00      mov c, 0
0288   05BD FD 77         inc b
0289   05BF FA FD FF      lea d, [bp + -3] ; $format_p
0290   05C2 FD 43         mov [d], b
0291   05C4 FD 7D         dec b
0292   05C6             ; if(*format_p == 'd' || *format_p == 'i') 
0293   05C6             _if7_cond:
0294   05C6 FA FD FF      lea d, [bp + -3] ; $format_p
0295   05C9 2A            mov b, [d]
0296   05CA 38 00 00      mov c, 0
0297   05CD 74            mov d, b
0298   05CE 32            mov bl, [d]
0299   05CF A7 00         mov bh, 0
0300   05D1 38 00 00      mov c, 0
0301   05D4             ; --- START RELATIONAL
0302   05D4 D7            push a
0303   05D5 11            mov a, b
0304   05D6 FD 2E 64 00   mov32 cb, $00000064
0304   05DA 00 00 
0305   05DC B0            cmp a, b
0306   05DD FD 71         seq ; ==
0307   05DF E4            pop a
0308   05E0             ; --- END RELATIONAL
0309   05E0             ; --- START LOGICAL OR
0310   05E0 D7            push a
0311   05E1 11            mov a, b
0312   05E2 FA FD FF      lea d, [bp + -3] ; $format_p
0313   05E5 2A            mov b, [d]
0314   05E6 38 00 00      mov c, 0
0315   05E9 74            mov d, b
0316   05EA 32            mov bl, [d]
0317   05EB A7 00         mov bh, 0
0318   05ED 38 00 00      mov c, 0
0319   05F0             ; --- START RELATIONAL
0320   05F0 D7            push a
0321   05F1 11            mov a, b
0322   05F2 FD 2E 69 00   mov32 cb, $00000069
0322   05F6 00 00 
0323   05F8 B0            cmp a, b
0324   05F9 FD 71         seq ; ==
0325   05FB E4            pop a
0326   05FC             ; --- END RELATIONAL
0327   05FC FD A8         sor a, b ; ||
0328   05FE E4            pop a
0329   05FF             ; --- END LOGICAL OR
0330   05FF C0 00 00      cmp b, 0
0331   0602 C6 23 06      je _if7_else
0332   0605             _if7_TRUE:
0333   0605             ; print_signed_long(*(long *)p); 
0334   0605             ; --- START FUNCTION CALL
0335   0605 FA FF FF      lea d, [bp + -1] ; $p
0336   0608 2A            mov b, [d]
0337   0609 38 00 00      mov c, 0
0338   060C 74            mov d, b
0339   060D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0340   0610 FD 39         mov c, b ; And place it into C
0341   0612 2A            mov b, [d] ; Lower Word in B
0342   0613 12            mov a, c
0343   0614 FD AA         swp a
0344   0616 D7            push a
0345   0617 FD AB         swp b
0346   0619 D8            push b
0347   061A 07 EC 07      call print_signed_long
0348   061D 51 04 00      add sp, 4
0349   0620             ; --- END FUNCTION CALL
0350   0620 0A AB 06      jmp _if7_exit
0351   0623             _if7_else:
0352   0623             ; if(*format_p == 'u') 
0353   0623             _if8_cond:
0354   0623 FA FD FF      lea d, [bp + -3] ; $format_p
0355   0626 2A            mov b, [d]
0356   0627 38 00 00      mov c, 0
0357   062A 74            mov d, b
0358   062B 32            mov bl, [d]
0359   062C A7 00         mov bh, 0
0360   062E 38 00 00      mov c, 0
0361   0631             ; --- START RELATIONAL
0362   0631 D7            push a
0363   0632 11            mov a, b
0364   0633 FD 2E 75 00   mov32 cb, $00000075
0364   0637 00 00 
0365   0639 B0            cmp a, b
0366   063A FD 71         seq ; ==
0367   063C E4            pop a
0368   063D             ; --- END RELATIONAL
0369   063D C0 00 00      cmp b, 0
0370   0640 C6 61 06      je _if8_else
0371   0643             _if8_TRUE:
0372   0643             ; print_unsigned_long(*(unsigned long *)p); 
0373   0643             ; --- START FUNCTION CALL
0374   0643 FA FF FF      lea d, [bp + -1] ; $p
0375   0646 2A            mov b, [d]
0376   0647 38 00 00      mov c, 0
0377   064A 74            mov d, b
0378   064B 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0379   064E FD 39         mov c, b ; And place it into C
0380   0650 2A            mov b, [d] ; Lower Word in B
0381   0651 12            mov a, c
0382   0652 FD AA         swp a
0383   0654 D7            push a
0384   0655 FD AB         swp b
0385   0657 D8            push b
0386   0658 07 7F 09      call print_unsigned_long
0387   065B 51 04 00      add sp, 4
0388   065E             ; --- END FUNCTION CALL
0389   065E 0A AB 06      jmp _if8_exit
0390   0661             _if8_else:
0391   0661             ; if(*format_p == 'x') 
0392   0661             _if9_cond:
0393   0661 FA FD FF      lea d, [bp + -3] ; $format_p
0394   0664 2A            mov b, [d]
0395   0665 38 00 00      mov c, 0
0396   0668 74            mov d, b
0397   0669 32            mov bl, [d]
0398   066A A7 00         mov bh, 0
0399   066C 38 00 00      mov c, 0
0400   066F             ; --- START RELATIONAL
0401   066F D7            push a
0402   0670 11            mov a, b
0403   0671 FD 2E 78 00   mov32 cb, $00000078
0403   0675 00 00 
0404   0677 B0            cmp a, b
0405   0678 FD 71         seq ; ==
0406   067A E4            pop a
0407   067B             ; --- END RELATIONAL
0408   067B C0 00 00      cmp b, 0
0409   067E C6 9F 06      je _if9_else
0410   0681             _if9_TRUE:
0411   0681             ; printx32(*(long int *)p); 
0412   0681             ; --- START FUNCTION CALL
0413   0681 FA FF FF      lea d, [bp + -1] ; $p
0414   0684 2A            mov b, [d]
0415   0685 38 00 00      mov c, 0
0416   0688 74            mov d, b
0417   0689 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0418   068C FD 39         mov c, b ; And place it into C
0419   068E 2A            mov b, [d] ; Lower Word in B
0420   068F 12            mov a, c
0421   0690 FD AA         swp a
0422   0692 D7            push a
0423   0693 FD AB         swp b
0424   0695 D8            push b
0425   0696 07 B3 0A      call printx32
0426   0699 51 04 00      add sp, 4
0427   069C             ; --- END FUNCTION CALL
0428   069C 0A AB 06      jmp _if9_exit
0429   069F             _if9_else:
0430   069F             ; err("Unexpected format in printf."); 
0431   069F             ; --- START FUNCTION CALL
0432   069F 26 80 0E      mov b, _s4 ; "Unexpected format in printf."
0433   06A2 FD AB         swp b
0434   06A4 D8            push b
0435   06A5 07 13 0B      call err
0436   06A8 51 02 00      add sp, 2
0437   06AB             ; --- END FUNCTION CALL
0438   06AB             _if9_exit:
0439   06AB             _if8_exit:
0440   06AB             _if7_exit:
0441   06AB             ; p = p + 4; 
0442   06AB FA FF FF      lea d, [bp + -1] ; $p
0443   06AE DA            push d
0444   06AF FA FF FF      lea d, [bp + -1] ; $p
0445   06B2 2A            mov b, [d]
0446   06B3 38 00 00      mov c, 0
0447   06B6             ; --- START TERMS
0448   06B6 D7            push a
0449   06B7 11            mov a, b
0450   06B8 FD 2E 04 00   mov32 cb, $00000004
0450   06BC 00 00 
0451   06BE 56            add b, a
0452   06BF E4            pop a
0453   06C0             ; --- END TERMS
0454   06C0 E7            pop d
0455   06C1 FD 43         mov [d], b
0456   06C3             ; break; 
0457   06C3 0A BF 07      jmp _switch6_exit ; case break
0458   06C6             _switch6_case2:
0459   06C6             _switch6_case3:
0460   06C6             ; print_signed(*(int*)p); 
0461   06C6             ; --- START FUNCTION CALL
0462   06C6 FA FF FF      lea d, [bp + -1] ; $p
0463   06C9 2A            mov b, [d]
0464   06CA 38 00 00      mov c, 0
0465   06CD 74            mov d, b
0466   06CE 2A            mov b, [d]
0467   06CF 38 00 00      mov c, 0
0468   06D2 FD AB         swp b
0469   06D4 D8            push b
0470   06D5 07 41 0B      call print_signed
0471   06D8 51 02 00      add sp, 2
0472   06DB             ; --- END FUNCTION CALL
0473   06DB             ; p = p + 2; 
0474   06DB FA FF FF      lea d, [bp + -1] ; $p
0475   06DE DA            push d
0476   06DF FA FF FF      lea d, [bp + -1] ; $p
0477   06E2 2A            mov b, [d]
0478   06E3 38 00 00      mov c, 0
0479   06E6             ; --- START TERMS
0480   06E6 D7            push a
0481   06E7 11            mov a, b
0482   06E8 FD 2E 02 00   mov32 cb, $00000002
0482   06EC 00 00 
0483   06EE 56            add b, a
0484   06EF E4            pop a
0485   06F0             ; --- END TERMS
0486   06F0 E7            pop d
0487   06F1 FD 43         mov [d], b
0488   06F3             ; break; 
0489   06F3 0A BF 07      jmp _switch6_exit ; case break
0490   06F6             _switch6_case4:
0491   06F6             ; print_unsigned(*(unsigned int*)p); 
0492   06F6             ; --- START FUNCTION CALL
0493   06F6 FA FF FF      lea d, [bp + -1] ; $p
0494   06F9 2A            mov b, [d]
0495   06FA 38 00 00      mov c, 0
0496   06FD 74            mov d, b
0497   06FE 2A            mov b, [d]
0498   06FF 38 00 00      mov c, 0
0499   0702 FD AB         swp b
0500   0704 D8            push b
0501   0705 07 92 0C      call print_unsigned
0502   0708 51 02 00      add sp, 2
0503   070B             ; --- END FUNCTION CALL
0504   070B             ; p = p + 2; 
0505   070B FA FF FF      lea d, [bp + -1] ; $p
0506   070E DA            push d
0507   070F FA FF FF      lea d, [bp + -1] ; $p
0508   0712 2A            mov b, [d]
0509   0713 38 00 00      mov c, 0
0510   0716             ; --- START TERMS
0511   0716 D7            push a
0512   0717 11            mov a, b
0513   0718 FD 2E 02 00   mov32 cb, $00000002
0513   071C 00 00 
0514   071E 56            add b, a
0515   071F E4            pop a
0516   0720             ; --- END TERMS
0517   0720 E7            pop d
0518   0721 FD 43         mov [d], b
0519   0723             ; break; 
0520   0723 0A BF 07      jmp _switch6_exit ; case break
0521   0726             _switch6_case5:
0522   0726             ; printx16(*(int*)p); 
0523   0726             ; --- START FUNCTION CALL
0524   0726 FA FF FF      lea d, [bp + -1] ; $p
0525   0729 2A            mov b, [d]
0526   072A 38 00 00      mov c, 0
0527   072D 74            mov d, b
0528   072E 2A            mov b, [d]
0529   072F 38 00 00      mov c, 0
0530   0732 FD AB         swp b
0531   0734 D8            push b
0532   0735 07 AA 0D      call printx16
0533   0738 51 02 00      add sp, 2
0534   073B             ; --- END FUNCTION CALL
0535   073B             ; p = p + 2; 
0536   073B FA FF FF      lea d, [bp + -1] ; $p
0537   073E DA            push d
0538   073F FA FF FF      lea d, [bp + -1] ; $p
0539   0742 2A            mov b, [d]
0540   0743 38 00 00      mov c, 0
0541   0746             ; --- START TERMS
0542   0746 D7            push a
0543   0747 11            mov a, b
0544   0748 FD 2E 02 00   mov32 cb, $00000002
0544   074C 00 00 
0545   074E 56            add b, a
0546   074F E4            pop a
0547   0750             ; --- END TERMS
0548   0750 E7            pop d
0549   0751 FD 43         mov [d], b
0550   0753             ; break; 
0551   0753 0A BF 07      jmp _switch6_exit ; case break
0552   0756             _switch6_case6:
0553   0756             ; putchar(*(char*)p); 
0554   0756             ; --- START FUNCTION CALL
0555   0756 FA FF FF      lea d, [bp + -1] ; $p
0556   0759 2A            mov b, [d]
0557   075A 38 00 00      mov c, 0
0558   075D 74            mov d, b
0559   075E 32            mov bl, [d]
0560   075F A7 00         mov bh, 0
0561   0761 38 00 00      mov c, 0
0562   0764 DD            push bl
0563   0765 07 71 09      call putchar
0564   0768 51 01 00      add sp, 1
0565   076B             ; --- END FUNCTION CALL
0566   076B             ; p = p + 2; 
0567   076B FA FF FF      lea d, [bp + -1] ; $p
0568   076E DA            push d
0569   076F FA FF FF      lea d, [bp + -1] ; $p
0570   0772 2A            mov b, [d]
0571   0773 38 00 00      mov c, 0
0572   0776             ; --- START TERMS
0573   0776 D7            push a
0574   0777 11            mov a, b
0575   0778 FD 2E 02 00   mov32 cb, $00000002
0575   077C 00 00 
0576   077E 56            add b, a
0577   077F E4            pop a
0578   0780             ; --- END TERMS
0579   0780 E7            pop d
0580   0781 FD 43         mov [d], b
0581   0783             ; break; 
0582   0783 0A BF 07      jmp _switch6_exit ; case break
0583   0786             _switch6_case7:
0584   0786             ; print(*(char**)p); 
0585   0786             ; --- START FUNCTION CALL
0586   0786 FA FF FF      lea d, [bp + -1] ; $p
0587   0789 2A            mov b, [d]
0588   078A 38 00 00      mov c, 0
0589   078D 74            mov d, b
0590   078E 2A            mov b, [d]
0591   078F FD AB         swp b
0592   0791 D8            push b
0593   0792 07 28 0B      call print
0594   0795 51 02 00      add sp, 2
0595   0798             ; --- END FUNCTION CALL
0596   0798             ; p = p + 2; 
0597   0798 FA FF FF      lea d, [bp + -1] ; $p
0598   079B DA            push d
0599   079C FA FF FF      lea d, [bp + -1] ; $p
0600   079F 2A            mov b, [d]
0601   07A0 38 00 00      mov c, 0
0602   07A3             ; --- START TERMS
0603   07A3 D7            push a
0604   07A4 11            mov a, b
0605   07A5 FD 2E 02 00   mov32 cb, $00000002
0605   07A9 00 00 
0606   07AB 56            add b, a
0607   07AC E4            pop a
0608   07AD             ; --- END TERMS
0609   07AD E7            pop d
0610   07AE FD 43         mov [d], b
0611   07B0             ; break; 
0612   07B0 0A BF 07      jmp _switch6_exit ; case break
0613   07B3             _switch6_default:
0614   07B3             ; print("Error: Unknown argument type.\n"); 
0615   07B3             ; --- START FUNCTION CALL
0616   07B3 26 9D 0E      mov b, _s5 ; "Error: Unknown argument type.\n"
0617   07B6 FD AB         swp b
0618   07B8 D8            push b
0619   07B9 07 28 0B      call print
0620   07BC 51 02 00      add sp, 2
0621   07BF             ; --- END FUNCTION CALL
0622   07BF             _switch6_exit:
0623   07BF 0A D7 07      jmp _if5_exit
0624   07C2             _if5_else:
0625   07C2             ; putchar(*format_p); 
0626   07C2             ; --- START FUNCTION CALL
0627   07C2 FA FD FF      lea d, [bp + -3] ; $format_p
0628   07C5 2A            mov b, [d]
0629   07C6 38 00 00      mov c, 0
0630   07C9 74            mov d, b
0631   07CA 32            mov bl, [d]
0632   07CB A7 00         mov bh, 0
0633   07CD 38 00 00      mov c, 0
0634   07D0 DD            push bl
0635   07D1 07 71 09      call putchar
0636   07D4 51 01 00      add sp, 1
0637   07D7             ; --- END FUNCTION CALL
0638   07D7             _if5_exit:
0639   07D7             _if4_exit:
0640   07D7             ; format_p++; 
0641   07D7 FA FD FF      lea d, [bp + -3] ; $format_p
0642   07DA 2A            mov b, [d]
0643   07DB 38 00 00      mov c, 0
0644   07DE FD 77         inc b
0645   07E0 FA FD FF      lea d, [bp + -3] ; $format_p
0646   07E3 FD 43         mov [d], b
0647   07E5 FD 7D         dec b
0648   07E7             _for3_update:
0649   07E7 0A 2B 05      jmp _for3_cond
0650   07EA             _for3_exit:
0651   07EA F9            leave
0652   07EB 09            ret
0653   07EC             
0654   07EC             print_signed_long:
0655   07EC F8 00 00      enter 0 ; (push bp; mov bp, sp)
0656   07EF             ; char digits[10]; 
0657   07EF 52 0A 00      sub sp, 10
0658   07F2             ; int i = 0; 
0659   07F2 52 02 00      sub sp, 2
0660   07F5             ; --- START LOCAL VAR INITIALIZATION
0661   07F5 FA F5 FF      lea d, [bp + -11] ; $i
0662   07F8 DA            push d
0663   07F9 FD 2E 00 00   mov32 cb, $00000000
0663   07FD 00 00 
0664   07FF E7            pop d
0665   0800 FD 43         mov [d], b
0666   0802             ; --- END LOCAL VAR INITIALIZATION
0667   0802             ; if (num < 0) { 
0668   0802             _if10_cond:
0669   0802 FA 05 00      lea d, [bp + 5] ; $num
0670   0805 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0671   0808 FD 39         mov c, b ; And place it into C
0672   080A 2A            mov b, [d] ; Lower Word in B
0673   080B             ; --- START RELATIONAL
0674   080B D7            push a
0675   080C FD D8         push g
0676   080E 11            mov a, b
0677   080F FD 7A         mov g, c
0678   0811 FD 2E 00 00   mov32 cb, $00000000
0678   0815 00 00 
0679   0817 FD AF         cmp32 ga, cb
0680   0819 FD 73         slt ; <
0681   081B FD F1         pop g
0682   081D E4            pop a
0683   081E             ; --- END RELATIONAL
0684   081E C0 00 00      cmp b, 0
0685   0821 C6 53 08      je _if10_else
0686   0824             _if10_TRUE:
0687   0824             ; putchar('-'); 
0688   0824             ; --- START FUNCTION CALL
0689   0824 FD 2E 2D 00   mov32 cb, $0000002d
0689   0828 00 00 
0690   082A DD            push bl
0691   082B 07 71 09      call putchar
0692   082E 51 01 00      add sp, 1
0693   0831             ; --- END FUNCTION CALL
0694   0831             ; num = -num; 
0695   0831 FA 05 00      lea d, [bp + 5] ; $num
0696   0834 DA            push d
0697   0835 FA 05 00      lea d, [bp + 5] ; $num
0698   0838 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0699   083B FD 39         mov c, b ; And place it into C
0700   083D 2A            mov b, [d] ; Lower Word in B
0701   083E 12            mov a, c
0702   083F 95            not a
0703   0840 97            not b
0704   0841 55 01 00      add b, 1
0705   0844 5B 00 00      adc a, 0
0706   0847 39            mov c, a
0707   0848 E7            pop d
0708   0849 FD 43         mov [d], b
0709   084B 28            mov b, c
0710   084C FD 44 02 00   mov [d + 2], b
0711   0850 0A 87 08      jmp _if10_exit
0712   0853             _if10_else:
0713   0853             ; if (num == 0) { 
0714   0853             _if11_cond:
0715   0853 FA 05 00      lea d, [bp + 5] ; $num
0716   0856 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0717   0859 FD 39         mov c, b ; And place it into C
0718   085B 2A            mov b, [d] ; Lower Word in B
0719   085C             ; --- START RELATIONAL
0720   085C D7            push a
0721   085D FD D8         push g
0722   085F 11            mov a, b
0723   0860 FD 7A         mov g, c
0724   0862 FD 2E 00 00   mov32 cb, $00000000
0724   0866 00 00 
0725   0868 FD AF         cmp32 ga, cb
0726   086A FD 71         seq ; ==
0727   086C FD F1         pop g
0728   086E E4            pop a
0729   086F             ; --- END RELATIONAL
0730   086F C0 00 00      cmp b, 0
0731   0872 C6 87 08      je _if11_exit
0732   0875             _if11_TRUE:
0733   0875             ; putchar('0'); 
0734   0875             ; --- START FUNCTION CALL
0735   0875 FD 2E 30 00   mov32 cb, $00000030
0735   0879 00 00 
0736   087B DD            push bl
0737   087C 07 71 09      call putchar
0738   087F 51 01 00      add sp, 1
0739   0882             ; --- END FUNCTION CALL
0740   0882             ; return; 
0741   0882 F9            leave
0742   0883 09            ret
0743   0884 0A 87 08      jmp _if11_exit
0744   0887             _if11_exit:
0745   0887             _if10_exit:
0746   0887             ; while (num > 0) { 
0747   0887             _while12_cond:
0748   0887 FA 05 00      lea d, [bp + 5] ; $num
0749   088A 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0750   088D FD 39         mov c, b ; And place it into C
0751   088F 2A            mov b, [d] ; Lower Word in B
0752   0890             ; --- START RELATIONAL
0753   0890 D7            push a
0754   0891 FD D8         push g
0755   0893 11            mov a, b
0756   0894 FD 7A         mov g, c
0757   0896 FD 2E 00 00   mov32 cb, $00000000
0757   089A 00 00 
0758   089C FD AF         cmp32 ga, cb
0759   089E FD 7F         sgt
0760   08A0 FD F1         pop g
0761   08A2 E4            pop a
0762   08A3             ; --- END RELATIONAL
0763   08A3 C0 00 00      cmp b, 0
0764   08A6 C6 27 09      je _while12_exit
0765   08A9             _while12_block:
0766   08A9             ; digits[i] = '0' + (num % 10); 
0767   08A9 FA F7 FF      lea d, [bp + -9] ; $digits
0768   08AC D7            push a
0769   08AD DA            push d
0770   08AE FA F5 FF      lea d, [bp + -11] ; $i
0771   08B1 2A            mov b, [d]
0772   08B2 38 00 00      mov c, 0
0773   08B5 E7            pop d
0774   08B6 5A            add d, b
0775   08B7 E4            pop a
0776   08B8 DA            push d
0777   08B9 FD 2E 30 00   mov32 cb, $00000030
0777   08BD 00 00 
0778   08BF             ; --- START TERMS
0779   08BF D7            push a
0780   08C0 11            mov a, b
0781   08C1 FA 05 00      lea d, [bp + 5] ; $num
0782   08C4 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0783   08C7 FD 39         mov c, b ; And place it into C
0784   08C9 2A            mov b, [d] ; Lower Word in B
0785   08CA             ; --- START FACTORS
0786   08CA D7            push a
0787   08CB FD D8         push g
0788   08CD 11            mov a, b
0789   08CE FD 7A         mov g, c
0790   08D0 FD 2E 0A 00   mov32 cb, $0000000a
0790   08D4 00 00 
0791   08D6 FD D8         push g ; save 'g' as the div instruction uses it
0792   08D8 AE            div a, b ; %, a: quotient, b: remainder
0793   08D9 11            mov a, b
0794   08DA FD F1         pop g
0795   08DC FD 38         mov c, g
0796   08DE 27            mov b, a
0797   08DF FD F1         pop g
0798   08E1 E4            pop a
0799   08E2             ; --- END FACTORS
0800   08E2 FD 15         add32 cb, ga
0801   08E4 E4            pop a
0802   08E5             ; --- END TERMS
0803   08E5 E7            pop d
0804   08E6 FD 3E         mov [d], bl
0805   08E8             ; num = num / 10; 
0806   08E8 FA 05 00      lea d, [bp + 5] ; $num
0807   08EB DA            push d
0808   08EC FA 05 00      lea d, [bp + 5] ; $num
0809   08EF 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0810   08F2 FD 39         mov c, b ; And place it into C
0811   08F4 2A            mov b, [d] ; Lower Word in B
0812   08F5             ; --- START FACTORS
0813   08F5 D7            push a
0814   08F6 FD D8         push g
0815   08F8 11            mov a, b
0816   08F9 FD 7A         mov g, c
0817   08FB FD 2E 0A 00   mov32 cb, $0000000a
0817   08FF 00 00 
0818   0901 FD D8         push g ; save 'g' as the div instruction uses it
0819   0903 AE            div a, b ; /, a: quotient, b: remainder
0820   0904 FD F1         pop g
0821   0906 FD 38         mov c, g
0822   0908 27            mov b, a
0823   0909 FD F1         pop g
0824   090B E4            pop a
0825   090C             ; --- END FACTORS
0826   090C E7            pop d
0827   090D FD 43         mov [d], b
0828   090F 28            mov b, c
0829   0910 FD 44 02 00   mov [d + 2], b
0830   0914             ; i++; 
0831   0914 FA F5 FF      lea d, [bp + -11] ; $i
0832   0917 2A            mov b, [d]
0833   0918 38 00 00      mov c, 0
0834   091B 11            mov a, b
0835   091C FD 77         inc b
0836   091E FA F5 FF      lea d, [bp + -11] ; $i
0837   0921 FD 43         mov [d], b
0838   0923 27            mov b, a
0839   0924 0A 87 08      jmp _while12_cond
0840   0927             _while12_exit:
0841   0927             ; while (i > 0) { 
0842   0927             _while19_cond:
0843   0927 FA F5 FF      lea d, [bp + -11] ; $i
0844   092A 2A            mov b, [d]
0845   092B 38 00 00      mov c, 0
0846   092E             ; --- START RELATIONAL
0847   092E D7            push a
0848   092F 11            mov a, b
0849   0930 FD 2E 00 00   mov32 cb, $00000000
0849   0934 00 00 
0850   0936 B0            cmp a, b
0851   0937 FD 7F         sgt ; >
0852   0939 E4            pop a
0853   093A             ; --- END RELATIONAL
0854   093A C0 00 00      cmp b, 0
0855   093D C6 6F 09      je _while19_exit
0856   0940             _while19_block:
0857   0940             ; i--; 
0858   0940 FA F5 FF      lea d, [bp + -11] ; $i
0859   0943 2A            mov b, [d]
0860   0944 38 00 00      mov c, 0
0861   0947 11            mov a, b
0862   0948 FD 7D         dec b
0863   094A FA F5 FF      lea d, [bp + -11] ; $i
0864   094D FD 43         mov [d], b
0865   094F 27            mov b, a
0866   0950             ; putchar(digits[i]); 
0867   0950             ; --- START FUNCTION CALL
0868   0950 FA F7 FF      lea d, [bp + -9] ; $digits
0869   0953 D7            push a
0870   0954 DA            push d
0871   0955 FA F5 FF      lea d, [bp + -11] ; $i
0872   0958 2A            mov b, [d]
0873   0959 38 00 00      mov c, 0
0874   095C E7            pop d
0875   095D 5A            add d, b
0876   095E E4            pop a
0877   095F 32            mov bl, [d]
0878   0960 A7 00         mov bh, 0
0879   0962 38 00 00      mov c, 0
0880   0965 DD            push bl
0881   0966 07 71 09      call putchar
0882   0969 51 01 00      add sp, 1
0883   096C             ; --- END FUNCTION CALL
0884   096C 0A 27 09      jmp _while19_cond
0885   096F             _while19_exit:
0886   096F F9            leave
0887   0970 09            ret
0888   0971             
0889   0971             putchar:
0890   0971 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0891   0974             ; --- BEGIN INLINE ASM SEGMENT
0892   0974 FA 05 00      lea d, [bp + 5] ; $c
0893   0977 1E            mov al, [d]
0894   0978 23            mov ah, al
0895   0979 19 00         mov al, 0
0896   097B 05 03         syscall sys_io      ; char in AH
0897   097D             ; --- END INLINE ASM SEGMENT
0898   097D F9            leave
0899   097E 09            ret
0900   097F             
0901   097F             print_unsigned_long:
0902   097F F8 00 00      enter 0 ; (push bp; mov bp, sp)
0903   0982             ; char digits[10]; 
0904   0982 52 0A 00      sub sp, 10
0905   0985             ; int i; 
0906   0985 52 02 00      sub sp, 2
0907   0988             ; i = 0; 
0908   0988 FA F5 FF      lea d, [bp + -11] ; $i
0909   098B DA            push d
0910   098C FD 2E 00 00   mov32 cb, $00000000
0910   0990 00 00 
0911   0992 E7            pop d
0912   0993 FD 43         mov [d], b
0913   0995             ; if(num == 0){ 
0914   0995             _if20_cond:
0915   0995 FA 05 00      lea d, [bp + 5] ; $num
0916   0998 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0917   099B FD 39         mov c, b ; And place it into C
0918   099D 2A            mov b, [d] ; Lower Word in B
0919   099E             ; --- START RELATIONAL
0920   099E D7            push a
0921   099F FD D8         push g
0922   09A1 11            mov a, b
0923   09A2 FD 7A         mov g, c
0924   09A4 FD 2E 00 00   mov32 cb, $00000000
0924   09A8 00 00 
0925   09AA FD AF         cmp32 ga, cb
0926   09AC FD 71         seq ; ==
0927   09AE FD F1         pop g
0928   09B0 E4            pop a
0929   09B1             ; --- END RELATIONAL
0930   09B1 C0 00 00      cmp b, 0
0931   09B4 C6 C9 09      je _if20_exit
0932   09B7             _if20_TRUE:
0933   09B7             ; putchar('0'); 
0934   09B7             ; --- START FUNCTION CALL
0935   09B7 FD 2E 30 00   mov32 cb, $00000030
0935   09BB 00 00 
0936   09BD DD            push bl
0937   09BE 07 71 09      call putchar
0938   09C1 51 01 00      add sp, 1
0939   09C4             ; --- END FUNCTION CALL
0940   09C4             ; return; 
0941   09C4 F9            leave
0942   09C5 09            ret
0943   09C6 0A C9 09      jmp _if20_exit
0944   09C9             _if20_exit:
0945   09C9             ; while (num > 0) { 
0946   09C9             _while21_cond:
0947   09C9 FA 05 00      lea d, [bp + 5] ; $num
0948   09CC 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0949   09CF FD 39         mov c, b ; And place it into C
0950   09D1 2A            mov b, [d] ; Lower Word in B
0951   09D2             ; --- START RELATIONAL
0952   09D2 D7            push a
0953   09D3 FD D8         push g
0954   09D5 11            mov a, b
0955   09D6 FD 7A         mov g, c
0956   09D8 FD 2E 00 00   mov32 cb, $00000000
0956   09DC 00 00 
0957   09DE FD AF         cmp32 ga, cb
0958   09E0 FD 81         sgu
0959   09E2 FD F1         pop g
0960   09E4 E4            pop a
0961   09E5             ; --- END RELATIONAL
0962   09E5 C0 00 00      cmp b, 0
0963   09E8 C6 69 0A      je _while21_exit
0964   09EB             _while21_block:
0965   09EB             ; digits[i] = '0' + (num % 10); 
0966   09EB FA F7 FF      lea d, [bp + -9] ; $digits
0967   09EE D7            push a
0968   09EF DA            push d
0969   09F0 FA F5 FF      lea d, [bp + -11] ; $i
0970   09F3 2A            mov b, [d]
0971   09F4 38 00 00      mov c, 0
0972   09F7 E7            pop d
0973   09F8 5A            add d, b
0974   09F9 E4            pop a
0975   09FA DA            push d
0976   09FB FD 2E 30 00   mov32 cb, $00000030
0976   09FF 00 00 
0977   0A01             ; --- START TERMS
0978   0A01 D7            push a
0979   0A02 11            mov a, b
0980   0A03 FA 05 00      lea d, [bp + 5] ; $num
0981   0A06 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0982   0A09 FD 39         mov c, b ; And place it into C
0983   0A0B 2A            mov b, [d] ; Lower Word in B
0984   0A0C             ; --- START FACTORS
0985   0A0C D7            push a
0986   0A0D FD D8         push g
0987   0A0F 11            mov a, b
0988   0A10 FD 7A         mov g, c
0989   0A12 FD 2E 0A 00   mov32 cb, $0000000a
0989   0A16 00 00 
0990   0A18 FD D8         push g ; save 'g' as the div instruction uses it
0991   0A1A AE            div a, b ; %, a: quotient, b: remainder
0992   0A1B 11            mov a, b
0993   0A1C FD F1         pop g
0994   0A1E FD 38         mov c, g
0995   0A20 27            mov b, a
0996   0A21 FD F1         pop g
0997   0A23 E4            pop a
0998   0A24             ; --- END FACTORS
0999   0A24 FD 15         add32 cb, ga
1000   0A26 E4            pop a
1001   0A27             ; --- END TERMS
1002   0A27 E7            pop d
1003   0A28 FD 3E         mov [d], bl
1004   0A2A             ; num = num / 10; 
1005   0A2A FA 05 00      lea d, [bp + 5] ; $num
1006   0A2D DA            push d
1007   0A2E FA 05 00      lea d, [bp + 5] ; $num
1008   0A31 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1009   0A34 FD 39         mov c, b ; And place it into C
1010   0A36 2A            mov b, [d] ; Lower Word in B
1011   0A37             ; --- START FACTORS
1012   0A37 D7            push a
1013   0A38 FD D8         push g
1014   0A3A 11            mov a, b
1015   0A3B FD 7A         mov g, c
1016   0A3D FD 2E 0A 00   mov32 cb, $0000000a
1016   0A41 00 00 
1017   0A43 FD D8         push g ; save 'g' as the div instruction uses it
1018   0A45 AE            div a, b ; /, a: quotient, b: remainder
1019   0A46 FD F1         pop g
1020   0A48 FD 38         mov c, g
1021   0A4A 27            mov b, a
1022   0A4B FD F1         pop g
1023   0A4D E4            pop a
1024   0A4E             ; --- END FACTORS
1025   0A4E E7            pop d
1026   0A4F FD 43         mov [d], b
1027   0A51 28            mov b, c
1028   0A52 FD 44 02 00   mov [d + 2], b
1029   0A56             ; i++; 
1030   0A56 FA F5 FF      lea d, [bp + -11] ; $i
1031   0A59 2A            mov b, [d]
1032   0A5A 38 00 00      mov c, 0
1033   0A5D 11            mov a, b
1034   0A5E FD 77         inc b
1035   0A60 FA F5 FF      lea d, [bp + -11] ; $i
1036   0A63 FD 43         mov [d], b
1037   0A65 27            mov b, a
1038   0A66 0A C9 09      jmp _while21_cond
1039   0A69             _while21_exit:
1040   0A69             ; while (i > 0) { 
1041   0A69             _while28_cond:
1042   0A69 FA F5 FF      lea d, [bp + -11] ; $i
1043   0A6C 2A            mov b, [d]
1044   0A6D 38 00 00      mov c, 0
1045   0A70             ; --- START RELATIONAL
1046   0A70 D7            push a
1047   0A71 11            mov a, b
1048   0A72 FD 2E 00 00   mov32 cb, $00000000
1048   0A76 00 00 
1049   0A78 B0            cmp a, b
1050   0A79 FD 7F         sgt ; >
1051   0A7B E4            pop a
1052   0A7C             ; --- END RELATIONAL
1053   0A7C C0 00 00      cmp b, 0
1054   0A7F C6 B1 0A      je _while28_exit
1055   0A82             _while28_block:
1056   0A82             ; i--; 
1057   0A82 FA F5 FF      lea d, [bp + -11] ; $i
1058   0A85 2A            mov b, [d]
1059   0A86 38 00 00      mov c, 0
1060   0A89 11            mov a, b
1061   0A8A FD 7D         dec b
1062   0A8C FA F5 FF      lea d, [bp + -11] ; $i
1063   0A8F FD 43         mov [d], b
1064   0A91 27            mov b, a
1065   0A92             ; putchar(digits[i]); 
1066   0A92             ; --- START FUNCTION CALL
1067   0A92 FA F7 FF      lea d, [bp + -9] ; $digits
1068   0A95 D7            push a
1069   0A96 DA            push d
1070   0A97 FA F5 FF      lea d, [bp + -11] ; $i
1071   0A9A 2A            mov b, [d]
1072   0A9B 38 00 00      mov c, 0
1073   0A9E E7            pop d
1074   0A9F 5A            add d, b
1075   0AA0 E4            pop a
1076   0AA1 32            mov bl, [d]
1077   0AA2 A7 00         mov bh, 0
1078   0AA4 38 00 00      mov c, 0
1079   0AA7 DD            push bl
1080   0AA8 07 71 09      call putchar
1081   0AAB 51 01 00      add sp, 1
1082   0AAE             ; --- END FUNCTION CALL
1083   0AAE 0A 69 0A      jmp _while28_cond
1084   0AB1             _while28_exit:
1085   0AB1 F9            leave
1086   0AB2 09            ret
1087   0AB3             
1088   0AB3             printx32:
1089   0AB3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1090   0AB6             ; --- BEGIN INLINE ASM SEGMENT
1091   0AB6 FA 05 00      lea d, [bp + 5] ; $hex
1092   0AB9 2B 02 00      mov b, [d+2]
1093   0ABC 07 C5 0A      call print_u16x_printx32
1094   0ABF 2A            mov b, [d]
1095   0AC0 07 C5 0A      call print_u16x_printx32
1096   0AC3             ; --- END INLINE ASM SEGMENT
1097   0AC3             ; return; 
1098   0AC3 F9            leave
1099   0AC4 09            ret
1100   0AC5             ; --- BEGIN INLINE ASM SEGMENT
1101   0AC5             print_u16x_printx32:
1102   0AC5 D7            push a
1103   0AC6 D8            push b
1104   0AC7 DD            push bl
1105   0AC8 30            mov bl, bh
1106   0AC9 07 E7 0A      call _itoa_printx32        ; convert bh to char in A
1107   0ACC 2F            mov bl, al        ; save al
1108   0ACD 19 00         mov al, 0
1109   0ACF 05 03         syscall sys_io        ; display AH
1110   0AD1 24            mov ah, bl        ; retrieve al
1111   0AD2 19 00         mov al, 0
1112   0AD4 05 03         syscall sys_io        ; display AL
1113   0AD6 EA            pop bl
1114   0AD7 07 E7 0A      call _itoa_printx32        ; convert bh to char in A
1115   0ADA 2F            mov bl, al        ; save al
1116   0ADB 19 00         mov al, 0
1117   0ADD 05 03         syscall sys_io        ; display AH
1118   0ADF 24            mov ah, bl        ; retrieve al
1119   0AE0 19 00         mov al, 0
1120   0AE2 05 03         syscall sys_io        ; display AL
1121   0AE4 E5            pop b
1122   0AE5 E4            pop a
1123   0AE6 09            ret
1124   0AE7             _itoa_printx32:
1125   0AE7 DA            push d
1126   0AE8 D8            push b
1127   0AE9 A7 00         mov bh, 0
1128   0AEB FD A4 04      shr bl, 4  
1129   0AEE 74            mov d, b
1130   0AEF 1F 01 0B      mov al, [d + s_hex_digits_printx32]
1131   0AF2 23            mov ah, al
1132   0AF3 E5            pop b
1133   0AF4 D8            push b
1134   0AF5 A7 00         mov bh, 0
1135   0AF7 FD 87 0F      and bl, $0F
1136   0AFA 74            mov d, b
1137   0AFB 1F 01 0B      mov al, [d + s_hex_digits_printx32]
1138   0AFE E5            pop b
1139   0AFF E7            pop d
1140   0B00 09            ret
1141   0B01 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
1141   0B05 34 35 36 37 
1141   0B09 38 39 41 42 
1141   0B0D 43 44 45 46 
1142   0B11             ; --- END INLINE ASM SEGMENT
1143   0B11 F9            leave
1144   0B12 09            ret
1145   0B13             
1146   0B13             err:
1147   0B13 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1148   0B16             ; print(e); 
1149   0B16             ; --- START FUNCTION CALL
1150   0B16 FA 05 00      lea d, [bp + 5] ; $e
1151   0B19 2A            mov b, [d]
1152   0B1A 38 00 00      mov c, 0
1153   0B1D FD AB         swp b
1154   0B1F D8            push b
1155   0B20 07 28 0B      call print
1156   0B23 51 02 00      add sp, 2
1157   0B26             ; --- END FUNCTION CALL
1158   0B26 F9            leave
1159   0B27 09            ret
1160   0B28             
1161   0B28             print:
1162   0B28 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1163   0B2B             ; --- BEGIN INLINE ASM SEGMENT
1164   0B2B FA 05 00      lea d, [bp + 5] ; $s
1165   0B2E FD 2A         mov d, [d]
1166   0B30             _puts_L1_print:
1167   0B30 1E            mov al, [d]
1168   0B31 B9 00         cmp al, 0
1169   0B33 C6 3F 0B      jz _puts_END_print
1170   0B36 23            mov ah, al
1171   0B37 19 00         mov al, 0
1172   0B39 05 03         syscall sys_io
1173   0B3B 79            inc d
1174   0B3C 0A 30 0B      jmp _puts_L1_print
1175   0B3F             _puts_END_print:
1176   0B3F             ; --- END INLINE ASM SEGMENT
1177   0B3F F9            leave
1178   0B40 09            ret
1179   0B41             
1180   0B41             print_signed:
1181   0B41 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1182   0B44             ; char digits[5]; 
1183   0B44 52 05 00      sub sp, 5
1184   0B47             ; int i = 0; 
1185   0B47 52 02 00      sub sp, 2
1186   0B4A             ; --- START LOCAL VAR INITIALIZATION
1187   0B4A FA FA FF      lea d, [bp + -6] ; $i
1188   0B4D DA            push d
1189   0B4E FD 2E 00 00   mov32 cb, $00000000
1189   0B52 00 00 
1190   0B54 E7            pop d
1191   0B55 FD 43         mov [d], b
1192   0B57             ; --- END LOCAL VAR INITIALIZATION
1193   0B57             ; if (num < 0) { 
1194   0B57             _if29_cond:
1195   0B57 FA 05 00      lea d, [bp + 5] ; $num
1196   0B5A 2A            mov b, [d]
1197   0B5B 38 00 00      mov c, 0
1198   0B5E             ; --- START RELATIONAL
1199   0B5E D7            push a
1200   0B5F 11            mov a, b
1201   0B60 FD 2E 00 00   mov32 cb, $00000000
1201   0B64 00 00 
1202   0B66 B0            cmp a, b
1203   0B67 FD 73         slt ; < (signed)
1204   0B69 E4            pop a
1205   0B6A             ; --- END RELATIONAL
1206   0B6A C0 00 00      cmp b, 0
1207   0B6D C6 90 0B      je _if29_else
1208   0B70             _if29_TRUE:
1209   0B70             ; putchar('-'); 
1210   0B70             ; --- START FUNCTION CALL
1211   0B70 FD 2E 2D 00   mov32 cb, $0000002d
1211   0B74 00 00 
1212   0B76 DD            push bl
1213   0B77 07 71 09      call putchar
1214   0B7A 51 01 00      add sp, 1
1215   0B7D             ; --- END FUNCTION CALL
1216   0B7D             ; num = -num; 
1217   0B7D FA 05 00      lea d, [bp + 5] ; $num
1218   0B80 DA            push d
1219   0B81 FA 05 00      lea d, [bp + 5] ; $num
1220   0B84 2A            mov b, [d]
1221   0B85 38 00 00      mov c, 0
1222   0B88 FD 97         neg b
1223   0B8A E7            pop d
1224   0B8B FD 43         mov [d], b
1225   0B8D 0A BB 0B      jmp _if29_exit
1226   0B90             _if29_else:
1227   0B90             ; if (num == 0) { 
1228   0B90             _if30_cond:
1229   0B90 FA 05 00      lea d, [bp + 5] ; $num
1230   0B93 2A            mov b, [d]
1231   0B94 38 00 00      mov c, 0
1232   0B97             ; --- START RELATIONAL
1233   0B97 D7            push a
1234   0B98 11            mov a, b
1235   0B99 FD 2E 00 00   mov32 cb, $00000000
1235   0B9D 00 00 
1236   0B9F B0            cmp a, b
1237   0BA0 FD 71         seq ; ==
1238   0BA2 E4            pop a
1239   0BA3             ; --- END RELATIONAL
1240   0BA3 C0 00 00      cmp b, 0
1241   0BA6 C6 BB 0B      je _if30_exit
1242   0BA9             _if30_TRUE:
1243   0BA9             ; putchar('0'); 
1244   0BA9             ; --- START FUNCTION CALL
1245   0BA9 FD 2E 30 00   mov32 cb, $00000030
1245   0BAD 00 00 
1246   0BAF DD            push bl
1247   0BB0 07 71 09      call putchar
1248   0BB3 51 01 00      add sp, 1
1249   0BB6             ; --- END FUNCTION CALL
1250   0BB6             ; return; 
1251   0BB6 F9            leave
1252   0BB7 09            ret
1253   0BB8 0A BB 0B      jmp _if30_exit
1254   0BBB             _if30_exit:
1255   0BBB             _if29_exit:
1256   0BBB             ; while (num > 0) { 
1257   0BBB             _while31_cond:
1258   0BBB FA 05 00      lea d, [bp + 5] ; $num
1259   0BBE 2A            mov b, [d]
1260   0BBF 38 00 00      mov c, 0
1261   0BC2             ; --- START RELATIONAL
1262   0BC2 D7            push a
1263   0BC3 11            mov a, b
1264   0BC4 FD 2E 00 00   mov32 cb, $00000000
1264   0BC8 00 00 
1265   0BCA B0            cmp a, b
1266   0BCB FD 7F         sgt ; >
1267   0BCD E4            pop a
1268   0BCE             ; --- END RELATIONAL
1269   0BCE C0 00 00      cmp b, 0
1270   0BD1 C6 48 0C      je _while31_exit
1271   0BD4             _while31_block:
1272   0BD4             ; digits[i] = '0' + (num % 10); 
1273   0BD4 FA FC FF      lea d, [bp + -4] ; $digits
1274   0BD7 D7            push a
1275   0BD8 DA            push d
1276   0BD9 FA FA FF      lea d, [bp + -6] ; $i
1277   0BDC 2A            mov b, [d]
1278   0BDD 38 00 00      mov c, 0
1279   0BE0 E7            pop d
1280   0BE1 5A            add d, b
1281   0BE2 E4            pop a
1282   0BE3 DA            push d
1283   0BE4 FD 2E 30 00   mov32 cb, $00000030
1283   0BE8 00 00 
1284   0BEA             ; --- START TERMS
1285   0BEA D7            push a
1286   0BEB 11            mov a, b
1287   0BEC FA 05 00      lea d, [bp + 5] ; $num
1288   0BEF 2A            mov b, [d]
1289   0BF0 38 00 00      mov c, 0
1290   0BF3             ; --- START FACTORS
1291   0BF3 D7            push a
1292   0BF4 FD D8         push g
1293   0BF6 11            mov a, b
1294   0BF7 FD 7A         mov g, c
1295   0BF9 FD 2E 0A 00   mov32 cb, $0000000a
1295   0BFD 00 00 
1296   0BFF FD D8         push g ; save 'g' as the div instruction uses it
1297   0C01 AE            div a, b ; %, a: quotient, b: remainder
1298   0C02 11            mov a, b
1299   0C03 FD F1         pop g
1300   0C05 FD 38         mov c, g
1301   0C07 27            mov b, a
1302   0C08 FD F1         pop g
1303   0C0A E4            pop a
1304   0C0B             ; --- END FACTORS
1305   0C0B 56            add b, a
1306   0C0C E4            pop a
1307   0C0D             ; --- END TERMS
1308   0C0D E7            pop d
1309   0C0E FD 3E         mov [d], bl
1310   0C10             ; num = num / 10; 
1311   0C10 FA 05 00      lea d, [bp + 5] ; $num
1312   0C13 DA            push d
1313   0C14 FA 05 00      lea d, [bp + 5] ; $num
1314   0C17 2A            mov b, [d]
1315   0C18 38 00 00      mov c, 0
1316   0C1B             ; --- START FACTORS
1317   0C1B D7            push a
1318   0C1C FD D8         push g
1319   0C1E 11            mov a, b
1320   0C1F FD 7A         mov g, c
1321   0C21 FD 2E 0A 00   mov32 cb, $0000000a
1321   0C25 00 00 
1322   0C27 FD D8         push g ; save 'g' as the div instruction uses it
1323   0C29 AE            div a, b ; /, a: quotient, b: remainder
1324   0C2A FD F1         pop g
1325   0C2C FD 38         mov c, g
1326   0C2E 27            mov b, a
1327   0C2F FD F1         pop g
1328   0C31 E4            pop a
1329   0C32             ; --- END FACTORS
1330   0C32 E7            pop d
1331   0C33 FD 43         mov [d], b
1332   0C35             ; i++; 
1333   0C35 FA FA FF      lea d, [bp + -6] ; $i
1334   0C38 2A            mov b, [d]
1335   0C39 38 00 00      mov c, 0
1336   0C3C 11            mov a, b
1337   0C3D FD 77         inc b
1338   0C3F FA FA FF      lea d, [bp + -6] ; $i
1339   0C42 FD 43         mov [d], b
1340   0C44 27            mov b, a
1341   0C45 0A BB 0B      jmp _while31_cond
1342   0C48             _while31_exit:
1343   0C48             ; while (i > 0) { 
1344   0C48             _while38_cond:
1345   0C48 FA FA FF      lea d, [bp + -6] ; $i
1346   0C4B 2A            mov b, [d]
1347   0C4C 38 00 00      mov c, 0
1348   0C4F             ; --- START RELATIONAL
1349   0C4F D7            push a
1350   0C50 11            mov a, b
1351   0C51 FD 2E 00 00   mov32 cb, $00000000
1351   0C55 00 00 
1352   0C57 B0            cmp a, b
1353   0C58 FD 7F         sgt ; >
1354   0C5A E4            pop a
1355   0C5B             ; --- END RELATIONAL
1356   0C5B C0 00 00      cmp b, 0
1357   0C5E C6 90 0C      je _while38_exit
1358   0C61             _while38_block:
1359   0C61             ; i--; 
1360   0C61 FA FA FF      lea d, [bp + -6] ; $i
1361   0C64 2A            mov b, [d]
1362   0C65 38 00 00      mov c, 0
1363   0C68 11            mov a, b
1364   0C69 FD 7D         dec b
1365   0C6B FA FA FF      lea d, [bp + -6] ; $i
1366   0C6E FD 43         mov [d], b
1367   0C70 27            mov b, a
1368   0C71             ; putchar(digits[i]); 
1369   0C71             ; --- START FUNCTION CALL
1370   0C71 FA FC FF      lea d, [bp + -4] ; $digits
1371   0C74 D7            push a
1372   0C75 DA            push d
1373   0C76 FA FA FF      lea d, [bp + -6] ; $i
1374   0C79 2A            mov b, [d]
1375   0C7A 38 00 00      mov c, 0
1376   0C7D E7            pop d
1377   0C7E 5A            add d, b
1378   0C7F E4            pop a
1379   0C80 32            mov bl, [d]
1380   0C81 A7 00         mov bh, 0
1381   0C83 38 00 00      mov c, 0
1382   0C86 DD            push bl
1383   0C87 07 71 09      call putchar
1384   0C8A 51 01 00      add sp, 1
1385   0C8D             ; --- END FUNCTION CALL
1386   0C8D 0A 48 0C      jmp _while38_cond
1387   0C90             _while38_exit:
1388   0C90 F9            leave
1389   0C91 09            ret
1390   0C92             
1391   0C92             print_unsigned:
1392   0C92 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1393   0C95             ; char digits[5]; 
1394   0C95 52 05 00      sub sp, 5
1395   0C98             ; int i; 
1396   0C98 52 02 00      sub sp, 2
1397   0C9B             ; i = 0; 
1398   0C9B FA FA FF      lea d, [bp + -6] ; $i
1399   0C9E DA            push d
1400   0C9F FD 2E 00 00   mov32 cb, $00000000
1400   0CA3 00 00 
1401   0CA5 E7            pop d
1402   0CA6 FD 43         mov [d], b
1403   0CA8             ; if(num == 0){ 
1404   0CA8             _if39_cond:
1405   0CA8 FA 05 00      lea d, [bp + 5] ; $num
1406   0CAB 2A            mov b, [d]
1407   0CAC 38 00 00      mov c, 0
1408   0CAF             ; --- START RELATIONAL
1409   0CAF D7            push a
1410   0CB0 11            mov a, b
1411   0CB1 FD 2E 00 00   mov32 cb, $00000000
1411   0CB5 00 00 
1412   0CB7 B0            cmp a, b
1413   0CB8 FD 71         seq ; ==
1414   0CBA E4            pop a
1415   0CBB             ; --- END RELATIONAL
1416   0CBB C0 00 00      cmp b, 0
1417   0CBE C6 D3 0C      je _if39_exit
1418   0CC1             _if39_TRUE:
1419   0CC1             ; putchar('0'); 
1420   0CC1             ; --- START FUNCTION CALL
1421   0CC1 FD 2E 30 00   mov32 cb, $00000030
1421   0CC5 00 00 
1422   0CC7 DD            push bl
1423   0CC8 07 71 09      call putchar
1424   0CCB 51 01 00      add sp, 1
1425   0CCE             ; --- END FUNCTION CALL
1426   0CCE             ; return; 
1427   0CCE F9            leave
1428   0CCF 09            ret
1429   0CD0 0A D3 0C      jmp _if39_exit
1430   0CD3             _if39_exit:
1431   0CD3             ; while (num > 0) { 
1432   0CD3             _while40_cond:
1433   0CD3 FA 05 00      lea d, [bp + 5] ; $num
1434   0CD6 2A            mov b, [d]
1435   0CD7 38 00 00      mov c, 0
1436   0CDA             ; --- START RELATIONAL
1437   0CDA D7            push a
1438   0CDB 11            mov a, b
1439   0CDC FD 2E 00 00   mov32 cb, $00000000
1439   0CE0 00 00 
1440   0CE2 B0            cmp a, b
1441   0CE3 FD 81         sgu ; > (unsigned)
1442   0CE5 E4            pop a
1443   0CE6             ; --- END RELATIONAL
1444   0CE6 C0 00 00      cmp b, 0
1445   0CE9 C6 60 0D      je _while40_exit
1446   0CEC             _while40_block:
1447   0CEC             ; digits[i] = '0' + (num % 10); 
1448   0CEC FA FC FF      lea d, [bp + -4] ; $digits
1449   0CEF D7            push a
1450   0CF0 DA            push d
1451   0CF1 FA FA FF      lea d, [bp + -6] ; $i
1452   0CF4 2A            mov b, [d]
1453   0CF5 38 00 00      mov c, 0
1454   0CF8 E7            pop d
1455   0CF9 5A            add d, b
1456   0CFA E4            pop a
1457   0CFB DA            push d
1458   0CFC FD 2E 30 00   mov32 cb, $00000030
1458   0D00 00 00 
1459   0D02             ; --- START TERMS
1460   0D02 D7            push a
1461   0D03 11            mov a, b
1462   0D04 FA 05 00      lea d, [bp + 5] ; $num
1463   0D07 2A            mov b, [d]
1464   0D08 38 00 00      mov c, 0
1465   0D0B             ; --- START FACTORS
1466   0D0B D7            push a
1467   0D0C FD D8         push g
1468   0D0E 11            mov a, b
1469   0D0F FD 7A         mov g, c
1470   0D11 FD 2E 0A 00   mov32 cb, $0000000a
1470   0D15 00 00 
1471   0D17 FD D8         push g ; save 'g' as the div instruction uses it
1472   0D19 AE            div a, b ; %, a: quotient, b: remainder
1473   0D1A 11            mov a, b
1474   0D1B FD F1         pop g
1475   0D1D FD 38         mov c, g
1476   0D1F 27            mov b, a
1477   0D20 FD F1         pop g
1478   0D22 E4            pop a
1479   0D23             ; --- END FACTORS
1480   0D23 56            add b, a
1481   0D24 E4            pop a
1482   0D25             ; --- END TERMS
1483   0D25 E7            pop d
1484   0D26 FD 3E         mov [d], bl
1485   0D28             ; num = num / 10; 
1486   0D28 FA 05 00      lea d, [bp + 5] ; $num
1487   0D2B DA            push d
1488   0D2C FA 05 00      lea d, [bp + 5] ; $num
1489   0D2F 2A            mov b, [d]
1490   0D30 38 00 00      mov c, 0
1491   0D33             ; --- START FACTORS
1492   0D33 D7            push a
1493   0D34 FD D8         push g
1494   0D36 11            mov a, b
1495   0D37 FD 7A         mov g, c
1496   0D39 FD 2E 0A 00   mov32 cb, $0000000a
1496   0D3D 00 00 
1497   0D3F FD D8         push g ; save 'g' as the div instruction uses it
1498   0D41 AE            div a, b ; /, a: quotient, b: remainder
1499   0D42 FD F1         pop g
1500   0D44 FD 38         mov c, g
1501   0D46 27            mov b, a
1502   0D47 FD F1         pop g
1503   0D49 E4            pop a
1504   0D4A             ; --- END FACTORS
1505   0D4A E7            pop d
1506   0D4B FD 43         mov [d], b
1507   0D4D             ; i++; 
1508   0D4D FA FA FF      lea d, [bp + -6] ; $i
1509   0D50 2A            mov b, [d]
1510   0D51 38 00 00      mov c, 0
1511   0D54 11            mov a, b
1512   0D55 FD 77         inc b
1513   0D57 FA FA FF      lea d, [bp + -6] ; $i
1514   0D5A FD 43         mov [d], b
1515   0D5C 27            mov b, a
1516   0D5D 0A D3 0C      jmp _while40_cond
1517   0D60             _while40_exit:
1518   0D60             ; while (i > 0) { 
1519   0D60             _while47_cond:
1520   0D60 FA FA FF      lea d, [bp + -6] ; $i
1521   0D63 2A            mov b, [d]
1522   0D64 38 00 00      mov c, 0
1523   0D67             ; --- START RELATIONAL
1524   0D67 D7            push a
1525   0D68 11            mov a, b
1526   0D69 FD 2E 00 00   mov32 cb, $00000000
1526   0D6D 00 00 
1527   0D6F B0            cmp a, b
1528   0D70 FD 7F         sgt ; >
1529   0D72 E4            pop a
1530   0D73             ; --- END RELATIONAL
1531   0D73 C0 00 00      cmp b, 0
1532   0D76 C6 A8 0D      je _while47_exit
1533   0D79             _while47_block:
1534   0D79             ; i--; 
1535   0D79 FA FA FF      lea d, [bp + -6] ; $i
1536   0D7C 2A            mov b, [d]
1537   0D7D 38 00 00      mov c, 0
1538   0D80 11            mov a, b
1539   0D81 FD 7D         dec b
1540   0D83 FA FA FF      lea d, [bp + -6] ; $i
1541   0D86 FD 43         mov [d], b
1542   0D88 27            mov b, a
1543   0D89             ; putchar(digits[i]); 
1544   0D89             ; --- START FUNCTION CALL
1545   0D89 FA FC FF      lea d, [bp + -4] ; $digits
1546   0D8C D7            push a
1547   0D8D DA            push d
1548   0D8E FA FA FF      lea d, [bp + -6] ; $i
1549   0D91 2A            mov b, [d]
1550   0D92 38 00 00      mov c, 0
1551   0D95 E7            pop d
1552   0D96 5A            add d, b
1553   0D97 E4            pop a
1554   0D98 32            mov bl, [d]
1555   0D99 A7 00         mov bh, 0
1556   0D9B 38 00 00      mov c, 0
1557   0D9E DD            push bl
1558   0D9F 07 71 09      call putchar
1559   0DA2 51 01 00      add sp, 1
1560   0DA5             ; --- END FUNCTION CALL
1561   0DA5 0A 60 0D      jmp _while47_cond
1562   0DA8             _while47_exit:
1563   0DA8 F9            leave
1564   0DA9 09            ret
1565   0DAA             
1566   0DAA             printx16:
1567   0DAA F8 00 00      enter 0 ; (push bp; mov bp, sp)
1568   0DAD             ; --- BEGIN INLINE ASM SEGMENT
1569   0DAD FA 05 00      lea d, [bp + 5] ; $hex
1570   0DB0 2A            mov b, [d]
1571   0DB1             print_u16x_printx16:
1572   0DB1 DD            push bl
1573   0DB2 30            mov bl, bh
1574   0DB3 07 D0 0D      call _itoa_printx16        ; convert bh to char in A
1575   0DB6 2F            mov bl, al        ; save al
1576   0DB7 19 00         mov al, 0
1577   0DB9 05 03         syscall sys_io        ; display AH
1578   0DBB 24            mov ah, bl        ; retrieve al
1579   0DBC 19 00         mov al, 0
1580   0DBE 05 03         syscall sys_io        ; display AL
1581   0DC0 EA            pop bl
1582   0DC1 07 D0 0D      call _itoa_printx16        ; convert bh to char in A
1583   0DC4 2F            mov bl, al        ; save al
1584   0DC5 19 00         mov al, 0
1585   0DC7 05 03         syscall sys_io        ; display AH
1586   0DC9 24            mov ah, bl        ; retrieve al
1587   0DCA 19 00         mov al, 0
1588   0DCC 05 03         syscall sys_io        ; display AL
1589   0DCE             ; --- END INLINE ASM SEGMENT
1590   0DCE             ; return; 
1591   0DCE F9            leave
1592   0DCF 09            ret
1593   0DD0             ; --- BEGIN INLINE ASM SEGMENT
1594   0DD0             _itoa_printx16:
1595   0DD0 DA            push d
1596   0DD1 D8            push b
1597   0DD2 A7 00         mov bh, 0
1598   0DD4 FD A4 04      shr bl, 4  
1599   0DD7 74            mov d, b
1600   0DD8 1F EA 0D      mov al, [d + s_hex_digits_printx16]
1601   0DDB 23            mov ah, al
1602   0DDC E5            pop b
1603   0DDD D8            push b
1604   0DDE A7 00         mov bh, 0
1605   0DE0 FD 87 0F      and bl, $0F
1606   0DE3 74            mov d, b
1607   0DE4 1F EA 0D      mov al, [d + s_hex_digits_printx16]
1608   0DE7 E5            pop b
1609   0DE8 E7            pop d
1610   0DE9 09            ret
1611   0DEA 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
1611   0DEE 34 35 36 37 
1611   0DF2 38 39 41 42 
1611   0DF6 43 44 45 46 
1612   0DFA             ; --- END INLINE ASM SEGMENT
1613   0DFA F9            leave
1614   0DFB 09            ret
1615   0DFC             
1616   0DFC             getchar:
1617   0DFC F8 00 00      enter 0 ; (push bp; mov bp, sp)
1618   0DFF             ; char c; 
1619   0DFF 52 01 00      sub sp, 1
1620   0E02             ; --- BEGIN INLINE ASM SEGMENT
1621   0E02 19 01         mov al, 1
1622   0E04 05 03         syscall sys_io      ; receive in AH
1623   0E06 1A            mov al, ah
1624   0E07 FA 00 00      lea d, [bp + 0] ; $c
1625   0E0A 3E            mov [d], al
1626   0E0B             ; --- END INLINE ASM SEGMENT
1627   0E0B             ; return c; 
1628   0E0B FA 00 00      lea d, [bp + 0] ; $c
1629   0E0E 32            mov bl, [d]
1630   0E0F A7 00         mov bh, 0
1631   0E11 38 00 00      mov c, 0
1632   0E14 F9            leave
1633   0E15 09            ret
1634   0E16             ; --- END TEXT SEGMENT
1635   0E16             
1636   0E16             ; --- BEGIN DATA SEGMENT
1637   0E16 54 65 73 74 _s0: .db "Test of 5.25 inch Floppy Drive Interface.\n", 0
1637   0E1A 20 6F 66 20 
1637   0E1E 35 2E 32 35 
1637   0E22 20 69 6E 63 
1637   0E26 68 20 46 6C 
1637   0E2A 6F 70 70 79 
1637   0E2E 20 44 72 69 
1637   0E32 76 65 20 49 
1637   0E36 6E 74 65 72 
1637   0E3A 66 61 63 65 
1637   0E3E 2E 0A 00 
1638   0E41 0A 4F 70 74 _s1: .db "\nOption: ", 0
1638   0E45 69 6F 6E 3A 
1638   0E49 20 00 
1639   0E4B 0A 44 61 74 _s2: .db "\nData register value: %d\n", 0
1639   0E4F 61 20 72 65 
1639   0E53 67 69 73 74 
1639   0E57 65 72 20 76 
1639   0E5B 61 6C 75 65 
1639   0E5F 3A 20 25 64 
1639   0E63 0A 00 
1640   0E65 0A 54 72 61 _s3: .db "\nTrack register value: %d\n", 0
1640   0E69 63 6B 20 72 
1640   0E6D 65 67 69 73 
1640   0E71 74 65 72 20 
1640   0E75 76 61 6C 75 
1640   0E79 65 3A 20 25 
1640   0E7D 64 0A 00 
1641   0E80 55 6E 65 78 _s4: .db "Unexpected format in printf.", 0
1641   0E84 70 65 63 74 
1641   0E88 65 64 20 66 
1641   0E8C 6F 72 6D 61 
1641   0E90 74 20 69 6E 
1641   0E94 20 70 72 69 
1641   0E98 6E 74 66 2E 
1641   0E9C 00 
1642   0E9D 45 72 72 6F _s5: .db "Error: Unknown argument type.\n", 0
1642   0EA1 72 3A 20 55 
1642   0EA5 6E 6B 6E 6F 
1642   0EA9 77 6E 20 61 
1642   0EAD 72 67 75 6D 
1642   0EB1 65 6E 74 20 
1642   0EB5 74 79 70 65 
1642   0EB9 2E 0A 00 
1643   0EBC             
1644   0EBC BE 0E       _heap_top: .dw _heap
1645   0EBE 00          _heap: .db 0
1646   0EBF             ; --- END DATA SEGMENT
1647   0EBF             
1648   0EBF             .end
tasm: Number of errors = 0
