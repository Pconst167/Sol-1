0001   0000             ; --- FILENAME: test
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ;; il0 = 0x80000000L; 
0011   0408 3B 28 17      mov d, _il0 ; $il0
0012   040B DA            push d
0013   040C 26 00 00      mov b, 0
0014   040F 38 00 80      mov c, 32768
0015   0412 E7            pop d
0016   0413 FD 43         mov [d], b
0017   0415 28            mov b, c
0018   0416 FD 44 02 00   mov [d + 2], b
0019   041A             ;; il1 = 0x00000001L; 
0020   041A 3B 2C 17      mov d, _il1 ; $il1
0021   041D DA            push d
0022   041E 26 01 00      mov b, 1
0023   0421 38 00 00      mov c, 0
0024   0424 E7            pop d
0025   0425 FD 43         mov [d], b
0026   0427 28            mov b, c
0027   0428 FD 44 02 00   mov [d + 2], b
0028   042C             ;; i0 = 0x8000; 
0029   042C 3B 30 17      mov d, _i0 ; $i0
0030   042F DA            push d
0031   0430 26 00 80      mov b, $8000
0032   0433 E7            pop d
0033   0434 FD 43         mov [d], b
0034   0436             ;; i1 = 0x0001; 
0035   0436 3B 32 17      mov d, _i1 ; $i1
0036   0439 DA            push d
0037   043A 26 01 00      mov b, $1
0038   043D E7            pop d
0039   043E FD 43         mov [d], b
0040   0440             ;; c0 = 'A'; 
0041   0440 3B 34 17      mov d, _c0 ; $c0
0042   0443 DA            push d
0043   0444 26 41 00      mov b, $41
0044   0447 E7            pop d
0045   0448 FD 3E         mov [d], bl
0046   044A             ;; c1 = 'Z'; 
0047   044A 3B 35 17      mov d, _c1 ; $c1
0048   044D DA            push d
0049   044E 26 5A 00      mov b, $5a
0050   0451 E7            pop d
0051   0452 FD 3E         mov [d], bl
0052   0454 05 0B         syscall sys_terminate_proc
0053   0456             
0054   0456             strcpy:
0055   0456 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0056   0459             ; $psrc 
0057   0459             ; $pdest 
0058   0459 52 04 00      sub sp, 4
0059   045C             ;; psrc = src; 
0060   045C FA FF FF      lea d, [bp + -1] ; $psrc
0061   045F DA            push d
0062   0460 FA 07 00      lea d, [bp + 7] ; $src
0063   0463 2A            mov b, [d]
0064   0464 E7            pop d
0065   0465 FD 43         mov [d], b
0066   0467             ;; pdest = dest; 
0067   0467 FA FD FF      lea d, [bp + -3] ; $pdest
0068   046A DA            push d
0069   046B FA 05 00      lea d, [bp + 5] ; $dest
0070   046E 2A            mov b, [d]
0071   046F E7            pop d
0072   0470 FD 43         mov [d], b
0073   0472             ;; while(*psrc) *pdest++ = *psrc++; 
0074   0472             _while1_cond:
0075   0472 FA FF FF      lea d, [bp + -1] ; $psrc
0076   0475 2A            mov b, [d]
0077   0476 74            mov d, b
0078   0477 32            mov bl, [d]
0079   0478 A7 00         mov bh, 0
0080   047A C0 00 00      cmp b, 0
0081   047D C6 A5 04      je _while1_exit
0082   0480             _while1_block:
0083   0480             ;; *pdest++ = *psrc++; 
0084   0480 FA FD FF      lea d, [bp + -3] ; $pdest
0085   0483 2A            mov b, [d]
0086   0484 D8            push b
0087   0485 FD 77         inc b
0088   0487 FA FD FF      lea d, [bp + -3] ; $pdest
0089   048A FD 43         mov [d], b
0090   048C E5            pop b
0091   048D D8            push b
0092   048E FA FF FF      lea d, [bp + -1] ; $psrc
0093   0491 2A            mov b, [d]
0094   0492 D8            push b
0095   0493 FD 77         inc b
0096   0495 FA FF FF      lea d, [bp + -1] ; $psrc
0097   0498 FD 43         mov [d], b
0098   049A E5            pop b
0099   049B 74            mov d, b
0100   049C 32            mov bl, [d]
0101   049D A7 00         mov bh, 0
0102   049F E7            pop d
0103   04A0 FD 3E         mov [d], bl
0104   04A2 0A 72 04      jmp _while1_cond
0105   04A5             _while1_exit:
0106   04A5             ;; *pdest = '\0'; 
0107   04A5 FA FD FF      lea d, [bp + -3] ; $pdest
0108   04A8 2A            mov b, [d]
0109   04A9 D8            push b
0110   04AA 26 00 00      mov b, $0
0111   04AD E7            pop d
0112   04AE FD 3E         mov [d], bl
0113   04B0 F9            leave
0114   04B1 09            ret
0115   04B2             
0116   04B2             strcmp:
0117   04B2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0118   04B5             ;; while (*s1 && (*s1 == *s2)) { 
0119   04B5             _while2_cond:
0120   04B5 FA 05 00      lea d, [bp + 5] ; $s1
0121   04B8 2A            mov b, [d]
0122   04B9 74            mov d, b
0123   04BA 32            mov bl, [d]
0124   04BB A7 00         mov bh, 0
0125   04BD D7            push a
0126   04BE 11            mov a, b
0127   04BF FA 05 00      lea d, [bp + 5] ; $s1
0128   04C2 2A            mov b, [d]
0129   04C3 74            mov d, b
0130   04C4 32            mov bl, [d]
0131   04C5 A7 00         mov bh, 0
0132   04C7             ; START RELATIONAL
0133   04C7 D7            push a
0134   04C8 11            mov a, b
0135   04C9 FA 07 00      lea d, [bp + 7] ; $s2
0136   04CC 2A            mov b, [d]
0137   04CD 74            mov d, b
0138   04CE 32            mov bl, [d]
0139   04CF A7 00         mov bh, 0
0140   04D1 B0            cmp a, b
0141   04D2 FD 71         seq ; ==
0142   04D4 E4            pop a
0143   04D5             ; END RELATIONAL
0144   04D5 FD A7         sand a, b
0145   04D7 E4            pop a
0146   04D8 C0 00 00      cmp b, 0
0147   04DB C6 FB 04      je _while2_exit
0148   04DE             _while2_block:
0149   04DE             ;; s1++; 
0150   04DE FA 05 00      lea d, [bp + 5] ; $s1
0151   04E1 2A            mov b, [d]
0152   04E2 D8            push b
0153   04E3 FD 77         inc b
0154   04E5 FA 05 00      lea d, [bp + 5] ; $s1
0155   04E8 FD 43         mov [d], b
0156   04EA E5            pop b
0157   04EB             ;; s2++; 
0158   04EB FA 07 00      lea d, [bp + 7] ; $s2
0159   04EE 2A            mov b, [d]
0160   04EF D8            push b
0161   04F0 FD 77         inc b
0162   04F2 FA 07 00      lea d, [bp + 7] ; $s2
0163   04F5 FD 43         mov [d], b
0164   04F7 E5            pop b
0165   04F8 0A B5 04      jmp _while2_cond
0166   04FB             _while2_exit:
0167   04FB             ;; return *s1 - *s2; 
0168   04FB FA 05 00      lea d, [bp + 5] ; $s1
0169   04FE 2A            mov b, [d]
0170   04FF 74            mov d, b
0171   0500 32            mov bl, [d]
0172   0501 A7 00         mov bh, 0
0173   0503             ; START TERMS
0174   0503 D7            push a
0175   0504 11            mov a, b
0176   0505 FA 07 00      lea d, [bp + 7] ; $s2
0177   0508 2A            mov b, [d]
0178   0509 74            mov d, b
0179   050A 32            mov bl, [d]
0180   050B A7 00         mov bh, 0
0181   050D 60            sub a, b
0182   050E 27            mov b, a
0183   050F E4            pop a
0184   0510             ; END TERMS
0185   0510 F9            leave
0186   0511 09            ret
0187   0512             
0188   0512             strcat:
0189   0512 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0190   0515             ; $dest_len 
0191   0515             ; $i 
0192   0515 52 04 00      sub sp, 4
0193   0518             ;; dest_len = strlen(dest); 
0194   0518 FA FF FF      lea d, [bp + -1] ; $dest_len
0195   051B DA            push d
0196   051C FA 05 00      lea d, [bp + 5] ; $dest
0197   051F 2A            mov b, [d]
0198   0520 FD AB         swp b
0199   0522 D8            push b
0200   0523 07 C5 05      call strlen
0201   0526 51 02 00      add sp, 2
0202   0529 E7            pop d
0203   052A FD 43         mov [d], b
0204   052C             ;; for (i = 0; src[i] != 0; i=i+1) { 
0205   052C             _for3_init:
0206   052C FA FD FF      lea d, [bp + -3] ; $i
0207   052F DA            push d
0208   0530 26 00 00      mov b, $0
0209   0533 E7            pop d
0210   0534 FD 43         mov [d], b
0211   0536             _for3_cond:
0212   0536 FA 07 00      lea d, [bp + 7] ; $src
0213   0539 FD 2A         mov d, [d]
0214   053B D7            push a
0215   053C DA            push d
0216   053D FA FD FF      lea d, [bp + -3] ; $i
0217   0540 2A            mov b, [d]
0218   0541 E7            pop d
0219   0542 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0220   0546 E4            pop a
0221   0547 32            mov bl, [d]
0222   0548 A7 00         mov bh, 0
0223   054A             ; START RELATIONAL
0224   054A D7            push a
0225   054B 11            mov a, b
0226   054C 26 00 00      mov b, $0
0227   054F B0            cmp a, b
0228   0550 FD 72         sneq ; !=
0229   0552 E4            pop a
0230   0553             ; END RELATIONAL
0231   0553 C0 00 00      cmp b, 0
0232   0556 C6 9F 05      je _for3_exit
0233   0559             _for3_block:
0234   0559             ;; dest[dest_len + i] = src[i]; 
0235   0559 FA 05 00      lea d, [bp + 5] ; $dest
0236   055C FD 2A         mov d, [d]
0237   055E D7            push a
0238   055F DA            push d
0239   0560 FA FF FF      lea d, [bp + -1] ; $dest_len
0240   0563 2A            mov b, [d]
0241   0564             ; START TERMS
0242   0564 D7            push a
0243   0565 11            mov a, b
0244   0566 FA FD FF      lea d, [bp + -3] ; $i
0245   0569 2A            mov b, [d]
0246   056A 56            add b, a
0247   056B E4            pop a
0248   056C             ; END TERMS
0249   056C E7            pop d
0250   056D FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0251   0571 E4            pop a
0252   0572 DA            push d
0253   0573 FA 07 00      lea d, [bp + 7] ; $src
0254   0576 FD 2A         mov d, [d]
0255   0578 D7            push a
0256   0579 DA            push d
0257   057A FA FD FF      lea d, [bp + -3] ; $i
0258   057D 2A            mov b, [d]
0259   057E E7            pop d
0260   057F FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0261   0583 E4            pop a
0262   0584 32            mov bl, [d]
0263   0585 A7 00         mov bh, 0
0264   0587 E7            pop d
0265   0588 FD 3E         mov [d], bl
0266   058A             _for3_update:
0267   058A FA FD FF      lea d, [bp + -3] ; $i
0268   058D DA            push d
0269   058E FA FD FF      lea d, [bp + -3] ; $i
0270   0591 2A            mov b, [d]
0271   0592             ; START TERMS
0272   0592 D7            push a
0273   0593 11            mov a, b
0274   0594 26 01 00      mov b, $1
0275   0597 56            add b, a
0276   0598 E4            pop a
0277   0599             ; END TERMS
0278   0599 E7            pop d
0279   059A FD 43         mov [d], b
0280   059C 0A 36 05      jmp _for3_cond
0281   059F             _for3_exit:
0282   059F             ;; dest[dest_len + i] = 0; 
0283   059F FA 05 00      lea d, [bp + 5] ; $dest
0284   05A2 FD 2A         mov d, [d]
0285   05A4 D7            push a
0286   05A5 DA            push d
0287   05A6 FA FF FF      lea d, [bp + -1] ; $dest_len
0288   05A9 2A            mov b, [d]
0289   05AA             ; START TERMS
0290   05AA D7            push a
0291   05AB 11            mov a, b
0292   05AC FA FD FF      lea d, [bp + -3] ; $i
0293   05AF 2A            mov b, [d]
0294   05B0 56            add b, a
0295   05B1 E4            pop a
0296   05B2             ; END TERMS
0297   05B2 E7            pop d
0298   05B3 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0299   05B7 E4            pop a
0300   05B8 DA            push d
0301   05B9 26 00 00      mov b, $0
0302   05BC E7            pop d
0303   05BD FD 3E         mov [d], bl
0304   05BF             ;; return dest; 
0305   05BF FA 05 00      lea d, [bp + 5] ; $dest
0306   05C2 2A            mov b, [d]
0307   05C3 F9            leave
0308   05C4 09            ret
0309   05C5             
0310   05C5             strlen:
0311   05C5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0312   05C8             ; $length 
0313   05C8 52 02 00      sub sp, 2
0314   05CB             ;; length = 0; 
0315   05CB FA FF FF      lea d, [bp + -1] ; $length
0316   05CE DA            push d
0317   05CF 26 00 00      mov b, $0
0318   05D2 E7            pop d
0319   05D3 FD 43         mov [d], b
0320   05D5             ;; while (str[length] != 0) { 
0321   05D5             _while4_cond:
0322   05D5 FA 05 00      lea d, [bp + 5] ; $str
0323   05D8 FD 2A         mov d, [d]
0324   05DA D7            push a
0325   05DB DA            push d
0326   05DC FA FF FF      lea d, [bp + -1] ; $length
0327   05DF 2A            mov b, [d]
0328   05E0 E7            pop d
0329   05E1 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0330   05E5 E4            pop a
0331   05E6 32            mov bl, [d]
0332   05E7 A7 00         mov bh, 0
0333   05E9             ; START RELATIONAL
0334   05E9 D7            push a
0335   05EA 11            mov a, b
0336   05EB 26 00 00      mov b, $0
0337   05EE B0            cmp a, b
0338   05EF FD 72         sneq ; !=
0339   05F1 E4            pop a
0340   05F2             ; END RELATIONAL
0341   05F2 C0 00 00      cmp b, 0
0342   05F5 C6 08 06      je _while4_exit
0343   05F8             _while4_block:
0344   05F8             ;; length++; 
0345   05F8 FA FF FF      lea d, [bp + -1] ; $length
0346   05FB 2A            mov b, [d]
0347   05FC D8            push b
0348   05FD FD 77         inc b
0349   05FF FA FF FF      lea d, [bp + -1] ; $length
0350   0602 FD 43         mov [d], b
0351   0604 E5            pop b
0352   0605 0A D5 05      jmp _while4_cond
0353   0608             _while4_exit:
0354   0608             ;; return length; 
0355   0608 FA FF FF      lea d, [bp + -1] ; $length
0356   060B 2A            mov b, [d]
0357   060C F9            leave
0358   060D 09            ret
0359   060E             
0360   060E             scanf:
0361   060E F8 00 00      enter 0 ; (push bp; mov bp, sp)
0362   0611             ; $p 
0363   0611             ; $format_p 
0364   0611             ; $c 
0365   0611             ; $i 
0366   0611             ; $input_string 
0367   0611 52 07 02      sub sp, 519
0368   0614             ;; format_p = format; 
0369   0614 FA FD FF      lea d, [bp + -3] ; $format_p
0370   0617 DA            push d
0371   0618 FA 05 00      lea d, [bp + 5] ; $format
0372   061B 2A            mov b, [d]
0373   061C E7            pop d
0374   061D FD 43         mov [d], b
0375   061F             ;; p = &format + 2; 
0376   061F FA FF FF      lea d, [bp + -1] ; $p
0377   0622 DA            push d
0378   0623 FA 05 00      lea d, [bp + 5] ; $format
0379   0626 2D            mov b, d
0380   0627             ; START TERMS
0381   0627 D7            push a
0382   0628 11            mov a, b
0383   0629 26 02 00      mov b, $2
0384   062C 56            add b, a
0385   062D E4            pop a
0386   062E             ; END TERMS
0387   062E E7            pop d
0388   062F FD 43         mov [d], b
0389   0631             ;; for(;;){ 
0390   0631             _for5_init:
0391   0631             _for5_cond:
0392   0631             _for5_block:
0393   0631             ;; if(!*format_p) break; 
0394   0631             _if6_cond:
0395   0631 FA FD FF      lea d, [bp + -3] ; $format_p
0396   0634 2A            mov b, [d]
0397   0635 74            mov d, b
0398   0636 32            mov bl, [d]
0399   0637 A7 00         mov bh, 0
0400   0639 C0 00 00      cmp b, 0
0401   063C FD 71         seq ; !
0402   063E C0 00 00      cmp b, 0
0403   0641 C6 4A 06      je _if6_else
0404   0644             _if6_true:
0405   0644             ;; break; 
0406   0644 0A 47 08      jmp _for5_exit ; for break
0407   0647 0A 44 08      jmp _if6_exit
0408   064A             _if6_else:
0409   064A             ;; if(*format_p == '%'){ 
0410   064A             _if7_cond:
0411   064A FA FD FF      lea d, [bp + -3] ; $format_p
0412   064D 2A            mov b, [d]
0413   064E 74            mov d, b
0414   064F 32            mov bl, [d]
0415   0650 A7 00         mov bh, 0
0416   0652             ; START RELATIONAL
0417   0652 D7            push a
0418   0653 11            mov a, b
0419   0654 26 25 00      mov b, $25
0420   0657 B0            cmp a, b
0421   0658 FD 71         seq ; ==
0422   065A E4            pop a
0423   065B             ; END RELATIONAL
0424   065B C0 00 00      cmp b, 0
0425   065E C6 28 08      je _if7_else
0426   0661             _if7_true:
0427   0661             ;; format_p++; 
0428   0661 FA FD FF      lea d, [bp + -3] ; $format_p
0429   0664 2A            mov b, [d]
0430   0665 D8            push b
0431   0666 FD 77         inc b
0432   0668 FA FD FF      lea d, [bp + -3] ; $format_p
0433   066B FD 43         mov [d], b
0434   066D E5            pop b
0435   066E             ;; switch(*format_p){ 
0436   066E             _switch8_expr:
0437   066E FA FD FF      lea d, [bp + -3] ; $format_p
0438   0671 2A            mov b, [d]
0439   0672 74            mov d, b
0440   0673 32            mov bl, [d]
0441   0674 A7 00         mov bh, 0
0442   0676             _switch8_comparisons:
0443   0676 C1 6C         cmp bl, $6c
0444   0678 C6 A4 06      je _switch8_case0
0445   067B C1 4C         cmp bl, $4c
0446   067D C6 A4 06      je _switch8_case1
0447   0680 C1 64         cmp bl, $64
0448   0682 C6 36 07      je _switch8_case2
0449   0685 C1 69         cmp bl, $69
0450   0687 C6 36 07      je _switch8_case3
0451   068A C1 75         cmp bl, $75
0452   068C C6 63 07      je _switch8_case4
0453   068F C1 78         cmp bl, $78
0454   0691 C6 90 07      je _switch8_case5
0455   0694 C1 63         cmp bl, $63
0456   0696 C6 A5 07      je _switch8_case6
0457   0699 C1 73         cmp bl, $73
0458   069B C6 D4 07      je _switch8_case7
0459   069E 0A 0C 08      jmp _switch8_default
0460   06A1 0A 18 08      jmp _switch8_exit
0461   06A4             _switch8_case0:
0462   06A4             _switch8_case1:
0463   06A4             ;; format_p++; 
0464   06A4 FA FD FF      lea d, [bp + -3] ; $format_p
0465   06A7 2A            mov b, [d]
0466   06A8 D8            push b
0467   06A9 FD 77         inc b
0468   06AB FA FD FF      lea d, [bp + -3] ; $format_p
0469   06AE FD 43         mov [d], b
0470   06B0 E5            pop b
0471   06B1             ;; if(*format_p == 'd' || *format_p == 'i'); 
0472   06B1             _if9_cond:
0473   06B1 FA FD FF      lea d, [bp + -3] ; $format_p
0474   06B4 2A            mov b, [d]
0475   06B5 74            mov d, b
0476   06B6 32            mov bl, [d]
0477   06B7 A7 00         mov bh, 0
0478   06B9             ; START RELATIONAL
0479   06B9 D7            push a
0480   06BA 11            mov a, b
0481   06BB 26 64 00      mov b, $64
0482   06BE B0            cmp a, b
0483   06BF FD 71         seq ; ==
0484   06C1 E4            pop a
0485   06C2             ; END RELATIONAL
0486   06C2 D7            push a
0487   06C3 11            mov a, b
0488   06C4 FA FD FF      lea d, [bp + -3] ; $format_p
0489   06C7 2A            mov b, [d]
0490   06C8 74            mov d, b
0491   06C9 32            mov bl, [d]
0492   06CA A7 00         mov bh, 0
0493   06CC             ; START RELATIONAL
0494   06CC D7            push a
0495   06CD 11            mov a, b
0496   06CE 26 69 00      mov b, $69
0497   06D1 B0            cmp a, b
0498   06D2 FD 71         seq ; ==
0499   06D4 E4            pop a
0500   06D5             ; END RELATIONAL
0501   06D5 FD A8         sor a, b ; ||
0502   06D7 E4            pop a
0503   06D8 C0 00 00      cmp b, 0
0504   06DB C6 E1 06      je _if9_else
0505   06DE             _if9_true:
0506   06DE             ;; ; 
0507   06DE 0A 21 07      jmp _if9_exit
0508   06E1             _if9_else:
0509   06E1             ;; if(*format_p == 'u'); 
0510   06E1             _if10_cond:
0511   06E1 FA FD FF      lea d, [bp + -3] ; $format_p
0512   06E4 2A            mov b, [d]
0513   06E5 74            mov d, b
0514   06E6 32            mov bl, [d]
0515   06E7 A7 00         mov bh, 0
0516   06E9             ; START RELATIONAL
0517   06E9 D7            push a
0518   06EA 11            mov a, b
0519   06EB 26 75 00      mov b, $75
0520   06EE B0            cmp a, b
0521   06EF FD 71         seq ; ==
0522   06F1 E4            pop a
0523   06F2             ; END RELATIONAL
0524   06F2 C0 00 00      cmp b, 0
0525   06F5 C6 FB 06      je _if10_else
0526   06F8             _if10_true:
0527   06F8             ;; ; 
0528   06F8 0A 21 07      jmp _if10_exit
0529   06FB             _if10_else:
0530   06FB             ;; if(*format_p == 'x'); 
0531   06FB             _if11_cond:
0532   06FB FA FD FF      lea d, [bp + -3] ; $format_p
0533   06FE 2A            mov b, [d]
0534   06FF 74            mov d, b
0535   0700 32            mov bl, [d]
0536   0701 A7 00         mov bh, 0
0537   0703             ; START RELATIONAL
0538   0703 D7            push a
0539   0704 11            mov a, b
0540   0705 26 78 00      mov b, $78
0541   0708 B0            cmp a, b
0542   0709 FD 71         seq ; ==
0543   070B E4            pop a
0544   070C             ; END RELATIONAL
0545   070C C0 00 00      cmp b, 0
0546   070F C6 15 07      je _if11_else
0547   0712             _if11_true:
0548   0712             ;; ; 
0549   0712 0A 21 07      jmp _if11_exit
0550   0715             _if11_else:
0551   0715             ;; err("Unexpected format in printf."); 
0552   0715 26 36 17      mov b, __s0 ; "Unexpected format in printf."
0553   0718 FD AB         swp b
0554   071A D8            push b
0555   071B 07 90 0A      call err
0556   071E 51 02 00      add sp, 2
0557   0721             _if11_exit:
0558   0721             _if10_exit:
0559   0721             _if9_exit:
0560   0721             ;; p = p + 4; 
0561   0721 FA FF FF      lea d, [bp + -1] ; $p
0562   0724 DA            push d
0563   0725 FA FF FF      lea d, [bp + -1] ; $p
0564   0728 2A            mov b, [d]
0565   0729             ; START TERMS
0566   0729 D7            push a
0567   072A 11            mov a, b
0568   072B 26 04 00      mov b, $4
0569   072E 56            add b, a
0570   072F E4            pop a
0571   0730             ; END TERMS
0572   0730 E7            pop d
0573   0731 FD 43         mov [d], b
0574   0733             ;; break; 
0575   0733 0A 18 08      jmp _switch8_exit ; case break
0576   0736             _switch8_case2:
0577   0736             _switch8_case3:
0578   0736             ;; i = scann(); 
0579   0736 FA FA FF      lea d, [bp + -6] ; $i
0580   0739 DA            push d
0581   073A 07 3D 13      call scann
0582   073D E7            pop d
0583   073E FD 43         mov [d], b
0584   0740             ;; **(int **)p = i; 
0585   0740 FA FF FF      lea d, [bp + -1] ; $p
0586   0743 2A            mov b, [d]
0587   0744 74            mov d, b
0588   0745 2A            mov b, [d]
0589   0746 D8            push b
0590   0747 FA FA FF      lea d, [bp + -6] ; $i
0591   074A 2A            mov b, [d]
0592   074B E7            pop d
0593   074C FD 43         mov [d], b
0594   074E             ;; p = p + 2; 
0595   074E FA FF FF      lea d, [bp + -1] ; $p
0596   0751 DA            push d
0597   0752 FA FF FF      lea d, [bp + -1] ; $p
0598   0755 2A            mov b, [d]
0599   0756             ; START TERMS
0600   0756 D7            push a
0601   0757 11            mov a, b
0602   0758 26 02 00      mov b, $2
0603   075B 56            add b, a
0604   075C E4            pop a
0605   075D             ; END TERMS
0606   075D E7            pop d
0607   075E FD 43         mov [d], b
0608   0760             ;; break; 
0609   0760 0A 18 08      jmp _switch8_exit ; case break
0610   0763             _switch8_case4:
0611   0763             ;; i = scann(); 
0612   0763 FA FA FF      lea d, [bp + -6] ; $i
0613   0766 DA            push d
0614   0767 07 3D 13      call scann
0615   076A E7            pop d
0616   076B FD 43         mov [d], b
0617   076D             ;; **(int **)p = i; 
0618   076D FA FF FF      lea d, [bp + -1] ; $p
0619   0770 2A            mov b, [d]
0620   0771 74            mov d, b
0621   0772 2A            mov b, [d]
0622   0773 D8            push b
0623   0774 FA FA FF      lea d, [bp + -6] ; $i
0624   0777 2A            mov b, [d]
0625   0778 E7            pop d
0626   0779 FD 43         mov [d], b
0627   077B             ;; p = p + 2; 
0628   077B FA FF FF      lea d, [bp + -1] ; $p
0629   077E DA            push d
0630   077F FA FF FF      lea d, [bp + -1] ; $p
0631   0782 2A            mov b, [d]
0632   0783             ; START TERMS
0633   0783 D7            push a
0634   0784 11            mov a, b
0635   0785 26 02 00      mov b, $2
0636   0788 56            add b, a
0637   0789 E4            pop a
0638   078A             ; END TERMS
0639   078A E7            pop d
0640   078B FD 43         mov [d], b
0641   078D             ;; break; 
0642   078D 0A 18 08      jmp _switch8_exit ; case break
0643   0790             _switch8_case5:
0644   0790             ;; p = p + 2; 
0645   0790 FA FF FF      lea d, [bp + -1] ; $p
0646   0793 DA            push d
0647   0794 FA FF FF      lea d, [bp + -1] ; $p
0648   0797 2A            mov b, [d]
0649   0798             ; START TERMS
0650   0798 D7            push a
0651   0799 11            mov a, b
0652   079A 26 02 00      mov b, $2
0653   079D 56            add b, a
0654   079E E4            pop a
0655   079F             ; END TERMS
0656   079F E7            pop d
0657   07A0 FD 43         mov [d], b
0658   07A2             ;; break; 
0659   07A2 0A 18 08      jmp _switch8_exit ; case break
0660   07A5             _switch8_case6:
0661   07A5             ;; c = getchar(); 
0662   07A5 FA FC FF      lea d, [bp + -4] ; $c
0663   07A8 DA            push d
0664   07A9 07 27 13      call getchar
0665   07AC E7            pop d
0666   07AD FD 3E         mov [d], bl
0667   07AF             ;; **(char **)p = c; 
0668   07AF FA FF FF      lea d, [bp + -1] ; $p
0669   07B2 2A            mov b, [d]
0670   07B3 74            mov d, b
0671   07B4 2A            mov b, [d]
0672   07B5 D8            push b
0673   07B6 FA FC FF      lea d, [bp + -4] ; $c
0674   07B9 32            mov bl, [d]
0675   07BA A7 00         mov bh, 0
0676   07BC E7            pop d
0677   07BD FD 43         mov [d], b
0678   07BF             ;; p = p + 2; 
0679   07BF FA FF FF      lea d, [bp + -1] ; $p
0680   07C2 DA            push d
0681   07C3 FA FF FF      lea d, [bp + -1] ; $p
0682   07C6 2A            mov b, [d]
0683   07C7             ; START TERMS
0684   07C7 D7            push a
0685   07C8 11            mov a, b
0686   07C9 26 02 00      mov b, $2
0687   07CC 56            add b, a
0688   07CD E4            pop a
0689   07CE             ; END TERMS
0690   07CE E7            pop d
0691   07CF FD 43         mov [d], b
0692   07D1             ;; break; 
0693   07D1 0A 18 08      jmp _switch8_exit ; case break
0694   07D4             _switch8_case7:
0695   07D4             ;; gets(input_string); 
0696   07D4 FA FA FD      lea d, [bp + -518] ; $input_string
0697   07D7 2D            mov b, d
0698   07D8 FD AB         swp b
0699   07DA D8            push b
0700   07DB 07 0F 0C      call gets
0701   07DE 51 02 00      add sp, 2
0702   07E1             ;; strcpy(*(char **)p, input_string); 
0703   07E1 FA FA FD      lea d, [bp + -518] ; $input_string
0704   07E4 2D            mov b, d
0705   07E5 FD AB         swp b
0706   07E7 D8            push b
0707   07E8 FA FF FF      lea d, [bp + -1] ; $p
0708   07EB 2A            mov b, [d]
0709   07EC 74            mov d, b
0710   07ED 2A            mov b, [d]
0711   07EE FD AB         swp b
0712   07F0 D8            push b
0713   07F1 07 56 04      call strcpy
0714   07F4 51 04 00      add sp, 4
0715   07F7             ;; p = p + 2; 
0716   07F7 FA FF FF      lea d, [bp + -1] ; $p
0717   07FA DA            push d
0718   07FB FA FF FF      lea d, [bp + -1] ; $p
0719   07FE 2A            mov b, [d]
0720   07FF             ; START TERMS
0721   07FF D7            push a
0722   0800 11            mov a, b
0723   0801 26 02 00      mov b, $2
0724   0804 56            add b, a
0725   0805 E4            pop a
0726   0806             ; END TERMS
0727   0806 E7            pop d
0728   0807 FD 43         mov [d], b
0729   0809             ;; break; 
0730   0809 0A 18 08      jmp _switch8_exit ; case break
0731   080C             _switch8_default:
0732   080C             ;; print("Error: Unknown argument type.\n"); 
0733   080C 26 53 17      mov b, __s1 ; "Error: Unknown argument type.\n"
0734   080F FD AB         swp b
0735   0811 D8            push b
0736   0812 07 62 13      call print
0737   0815 51 02 00      add sp, 2
0738   0818             _switch8_exit:
0739   0818             ;; format_p++; 
0740   0818 FA FD FF      lea d, [bp + -3] ; $format_p
0741   081B 2A            mov b, [d]
0742   081C D8            push b
0743   081D FD 77         inc b
0744   081F FA FD FF      lea d, [bp + -3] ; $format_p
0745   0822 FD 43         mov [d], b
0746   0824 E5            pop b
0747   0825 0A 44 08      jmp _if7_exit
0748   0828             _if7_else:
0749   0828             ;; putchar(*format_p); 
0750   0828 FA FD FF      lea d, [bp + -3] ; $format_p
0751   082B 2A            mov b, [d]
0752   082C 74            mov d, b
0753   082D 32            mov bl, [d]
0754   082E A7 00         mov bh, 0
0755   0830 DD            push bl
0756   0831 07 1A 13      call putchar
0757   0834 51 01 00      add sp, 1
0758   0837             ;; format_p++; 
0759   0837 FA FD FF      lea d, [bp + -3] ; $format_p
0760   083A 2A            mov b, [d]
0761   083B D8            push b
0762   083C FD 77         inc b
0763   083E FA FD FF      lea d, [bp + -3] ; $format_p
0764   0841 FD 43         mov [d], b
0765   0843 E5            pop b
0766   0844             _if7_exit:
0767   0844             _if6_exit:
0768   0844             _for5_update:
0769   0844 0A 31 06      jmp _for5_cond
0770   0847             _for5_exit:
0771   0847 F9            leave
0772   0848 09            ret
0773   0849             
0774   0849             printf:
0775   0849 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0776   084C             ; $p 
0777   084C             ; $format_p 
0778   084C 52 04 00      sub sp, 4
0779   084F             ;; format_p = format; 
0780   084F FA FD FF      lea d, [bp + -3] ; $format_p
0781   0852 DA            push d
0782   0853 FA 05 00      lea d, [bp + 5] ; $format
0783   0856 2A            mov b, [d]
0784   0857 E7            pop d
0785   0858 FD 43         mov [d], b
0786   085A             ;; p = &format + 2; 
0787   085A FA FF FF      lea d, [bp + -1] ; $p
0788   085D DA            push d
0789   085E FA 05 00      lea d, [bp + 5] ; $format
0790   0861 2D            mov b, d
0791   0862             ; START TERMS
0792   0862 D7            push a
0793   0863 11            mov a, b
0794   0864 26 02 00      mov b, $2
0795   0867 56            add b, a
0796   0868 E4            pop a
0797   0869             ; END TERMS
0798   0869 E7            pop d
0799   086A FD 43         mov [d], b
0800   086C             ;; for(;;){ 
0801   086C             _for12_init:
0802   086C             _for12_cond:
0803   086C             _for12_block:
0804   086C             ;; if(!*format_p) break; 
0805   086C             _if13_cond:
0806   086C FA FD FF      lea d, [bp + -3] ; $format_p
0807   086F 2A            mov b, [d]
0808   0870 74            mov d, b
0809   0871 32            mov bl, [d]
0810   0872 A7 00         mov bh, 0
0811   0874 C0 00 00      cmp b, 0
0812   0877 FD 71         seq ; !
0813   0879 C0 00 00      cmp b, 0
0814   087C C6 85 08      je _if13_else
0815   087F             _if13_true:
0816   087F             ;; break; 
0817   087F 0A 8E 0A      jmp _for12_exit ; for break
0818   0882 0A 8B 0A      jmp _if13_exit
0819   0885             _if13_else:
0820   0885             ;; if(*format_p == '%'){ 
0821   0885             _if14_cond:
0822   0885 FA FD FF      lea d, [bp + -3] ; $format_p
0823   0888 2A            mov b, [d]
0824   0889 74            mov d, b
0825   088A 32            mov bl, [d]
0826   088B A7 00         mov bh, 0
0827   088D             ; START RELATIONAL
0828   088D D7            push a
0829   088E 11            mov a, b
0830   088F 26 25 00      mov b, $25
0831   0892 B0            cmp a, b
0832   0893 FD 71         seq ; ==
0833   0895 E4            pop a
0834   0896             ; END RELATIONAL
0835   0896 C0 00 00      cmp b, 0
0836   0899 C6 6F 0A      je _if14_else
0837   089C             _if14_true:
0838   089C             ;; format_p++; 
0839   089C FA FD FF      lea d, [bp + -3] ; $format_p
0840   089F 2A            mov b, [d]
0841   08A0 D8            push b
0842   08A1 FD 77         inc b
0843   08A3 FA FD FF      lea d, [bp + -3] ; $format_p
0844   08A6 FD 43         mov [d], b
0845   08A8 E5            pop b
0846   08A9             ;; switch(*format_p){ 
0847   08A9             _switch15_expr:
0848   08A9 FA FD FF      lea d, [bp + -3] ; $format_p
0849   08AC 2A            mov b, [d]
0850   08AD 74            mov d, b
0851   08AE 32            mov bl, [d]
0852   08AF A7 00         mov bh, 0
0853   08B1             _switch15_comparisons:
0854   08B1 C1 6C         cmp bl, $6c
0855   08B3 C6 DF 08      je _switch15_case0
0856   08B6 C1 4C         cmp bl, $4c
0857   08B8 C6 DF 08      je _switch15_case1
0858   08BB C1 64         cmp bl, $64
0859   08BD C6 AF 09      je _switch15_case2
0860   08C0 C1 69         cmp bl, $69
0861   08C2 C6 AF 09      je _switch15_case3
0862   08C5 C1 75         cmp bl, $75
0863   08C7 C6 D3 09      je _switch15_case4
0864   08CA C1 78         cmp bl, $78
0865   08CC C6 F7 09      je _switch15_case5
0866   08CF C1 63         cmp bl, $63
0867   08D1 C6 15 0A      je _switch15_case6
0868   08D4 C1 73         cmp bl, $73
0869   08D6 C6 34 0A      je _switch15_case7
0870   08D9 0A 53 0A      jmp _switch15_default
0871   08DC 0A 5F 0A      jmp _switch15_exit
0872   08DF             _switch15_case0:
0873   08DF             _switch15_case1:
0874   08DF             ;; format_p++; 
0875   08DF FA FD FF      lea d, [bp + -3] ; $format_p
0876   08E2 2A            mov b, [d]
0877   08E3 D8            push b
0878   08E4 FD 77         inc b
0879   08E6 FA FD FF      lea d, [bp + -3] ; $format_p
0880   08E9 FD 43         mov [d], b
0881   08EB E5            pop b
0882   08EC             ;; if(*format_p == 'd' || *format_p == 'i') 
0883   08EC             _if16_cond:
0884   08EC FA FD FF      lea d, [bp + -3] ; $format_p
0885   08EF 2A            mov b, [d]
0886   08F0 74            mov d, b
0887   08F1 32            mov bl, [d]
0888   08F2 A7 00         mov bh, 0
0889   08F4             ; START RELATIONAL
0890   08F4 D7            push a
0891   08F5 11            mov a, b
0892   08F6 26 64 00      mov b, $64
0893   08F9 B0            cmp a, b
0894   08FA FD 71         seq ; ==
0895   08FC E4            pop a
0896   08FD             ; END RELATIONAL
0897   08FD D7            push a
0898   08FE 11            mov a, b
0899   08FF FA FD FF      lea d, [bp + -3] ; $format_p
0900   0902 2A            mov b, [d]
0901   0903 74            mov d, b
0902   0904 32            mov bl, [d]
0903   0905 A7 00         mov bh, 0
0904   0907             ; START RELATIONAL
0905   0907 D7            push a
0906   0908 11            mov a, b
0907   0909 26 69 00      mov b, $69
0908   090C B0            cmp a, b
0909   090D FD 71         seq ; ==
0910   090F E4            pop a
0911   0910             ; END RELATIONAL
0912   0910 FD A8         sor a, b ; ||
0913   0912 E4            pop a
0914   0913 C0 00 00      cmp b, 0
0915   0916 C6 2D 09      je _if16_else
0916   0919             _if16_true:
0917   0919             ;; print_signed_long(*(long *)p); 
0918   0919 FD 79         mov g, b
0919   091B 28            mov b, c
0920   091C FD AB         swp b
0921   091E D8            push b
0922   091F FD 27         mov b, g
0923   0921 FD AB         swp b
0924   0923 D8            push b
0925   0924 07 19 0D      call print_signed_long
0926   0927 51 04 00      add sp, 4
0927   092A 0A 9A 09      jmp _if16_exit
0928   092D             _if16_else:
0929   092D             ;; if(*format_p == 'u') 
0930   092D             _if17_cond:
0931   092D FA FD FF      lea d, [bp + -3] ; $format_p
0932   0930 2A            mov b, [d]
0933   0931 74            mov d, b
0934   0932 32            mov bl, [d]
0935   0933 A7 00         mov bh, 0
0936   0935             ; START RELATIONAL
0937   0935 D7            push a
0938   0936 11            mov a, b
0939   0937 26 75 00      mov b, $75
0940   093A B0            cmp a, b
0941   093B FD 71         seq ; ==
0942   093D E4            pop a
0943   093E             ; END RELATIONAL
0944   093E C0 00 00      cmp b, 0
0945   0941 C6 58 09      je _if17_else
0946   0944             _if17_true:
0947   0944             ;; print_unsigned_long(*(unsigned long *)p); 
0948   0944 FD 79         mov g, b
0949   0946 28            mov b, c
0950   0947 FD AB         swp b
0951   0949 D8            push b
0952   094A FD 27         mov b, g
0953   094C FD AB         swp b
0954   094E D8            push b
0955   094F 07 52 10      call print_unsigned_long
0956   0952 51 04 00      add sp, 4
0957   0955 0A 9A 09      jmp _if17_exit
0958   0958             _if17_else:
0959   0958             ;; if(*format_p == 'x') 
0960   0958             _if18_cond:
0961   0958 FA FD FF      lea d, [bp + -3] ; $format_p
0962   095B 2A            mov b, [d]
0963   095C 74            mov d, b
0964   095D 32            mov bl, [d]
0965   095E A7 00         mov bh, 0
0966   0960             ; START RELATIONAL
0967   0960 D7            push a
0968   0961 11            mov a, b
0969   0962 26 78 00      mov b, $78
0970   0965 B0            cmp a, b
0971   0966 FD 71         seq ; ==
0972   0968 E4            pop a
0973   0969             ; END RELATIONAL
0974   0969 C0 00 00      cmp b, 0
0975   096C C6 8E 09      je _if18_else
0976   096F             _if18_true:
0977   096F             ;; printx32(*(long int *)p); 
0978   096F FA FF FF      lea d, [bp + -1] ; $p
0979   0972 2A            mov b, [d]
0980   0973 74            mov d, b
0981   0974 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0982   0977 FD 39         mov c, b ; And place it into C
0983   0979 2A            mov b, [d] ; Lower Word in B
0984   097A FD 79         mov g, b
0985   097C 28            mov b, c
0986   097D FD AB         swp b
0987   097F D8            push b
0988   0980 FD 27         mov b, g
0989   0982 FD AB         swp b
0990   0984 D8            push b
0991   0985 07 A2 0A      call printx32
0992   0988 51 04 00      add sp, 4
0993   098B 0A 9A 09      jmp _if18_exit
0994   098E             _if18_else:
0995   098E             ;; err("Unexpected format in printf."); 
0996   098E 26 36 17      mov b, __s0 ; "Unexpected format in printf."
0997   0991 FD AB         swp b
0998   0993 D8            push b
0999   0994 07 90 0A      call err
1000   0997 51 02 00      add sp, 2
1001   099A             _if18_exit:
1002   099A             _if17_exit:
1003   099A             _if16_exit:
1004   099A             ;; p = p + 4; 
1005   099A FA FF FF      lea d, [bp + -1] ; $p
1006   099D DA            push d
1007   099E FA FF FF      lea d, [bp + -1] ; $p
1008   09A1 2A            mov b, [d]
1009   09A2             ; START TERMS
1010   09A2 D7            push a
1011   09A3 11            mov a, b
1012   09A4 26 04 00      mov b, $4
1013   09A7 56            add b, a
1014   09A8 E4            pop a
1015   09A9             ; END TERMS
1016   09A9 E7            pop d
1017   09AA FD 43         mov [d], b
1018   09AC             ;; break; 
1019   09AC 0A 5F 0A      jmp _switch15_exit ; case break
1020   09AF             _switch15_case2:
1021   09AF             _switch15_case3:
1022   09AF             ;; print_signed(*(int*)p); 
1023   09AF FA FF FF      lea d, [bp + -1] ; $p
1024   09B2 2A            mov b, [d]
1025   09B3 74            mov d, b
1026   09B4 2A            mov b, [d]
1027   09B5 FD AB         swp b
1028   09B7 D8            push b
1029   09B8 07 29 0C      call print_signed
1030   09BB 51 02 00      add sp, 2
1031   09BE             ;; p = p + 2; 
1032   09BE FA FF FF      lea d, [bp + -1] ; $p
1033   09C1 DA            push d
1034   09C2 FA FF FF      lea d, [bp + -1] ; $p
1035   09C5 2A            mov b, [d]
1036   09C6             ; START TERMS
1037   09C6 D7            push a
1038   09C7 11            mov a, b
1039   09C8 26 02 00      mov b, $2
1040   09CB 56            add b, a
1041   09CC E4            pop a
1042   09CD             ; END TERMS
1043   09CD E7            pop d
1044   09CE FD 43         mov [d], b
1045   09D0             ;; break; 
1046   09D0 0A 5F 0A      jmp _switch15_exit ; case break
1047   09D3             _switch15_case4:
1048   09D3             ;; print_unsigned(*(unsigned int*)p); 
1049   09D3 FA FF FF      lea d, [bp + -1] ; $p
1050   09D6 2A            mov b, [d]
1051   09D7 74            mov d, b
1052   09D8 2A            mov b, [d]
1053   09D9 FD AB         swp b
1054   09DB D8            push b
1055   09DC 07 4A 12      call print_unsigned
1056   09DF 51 02 00      add sp, 2
1057   09E2             ;; p = p + 2; 
1058   09E2 FA FF FF      lea d, [bp + -1] ; $p
1059   09E5 DA            push d
1060   09E6 FA FF FF      lea d, [bp + -1] ; $p
1061   09E9 2A            mov b, [d]
1062   09EA             ; START TERMS
1063   09EA D7            push a
1064   09EB 11            mov a, b
1065   09EC 26 02 00      mov b, $2
1066   09EF 56            add b, a
1067   09F0 E4            pop a
1068   09F1             ; END TERMS
1069   09F1 E7            pop d
1070   09F2 FD 43         mov [d], b
1071   09F4             ;; break; 
1072   09F4 0A 5F 0A      jmp _switch15_exit ; case break
1073   09F7             _switch15_case5:
1074   09F7             
1075   09F7             ; --- BEGIN INLINE ASM BLOCK
1076   09F7 FA FF FF      lea d, [bp + -1] ; $p
1077   09FA FD 2A         mov d, [d]
1078   09FC 2A            mov b, [d]
1079   09FD 07 28 16      call print_u16x
1080   0A00             ; --- END INLINE ASM BLOCK
1081   0A00             
1082   0A00             ;; p = p + 2; 
1083   0A00 FA FF FF      lea d, [bp + -1] ; $p
1084   0A03 DA            push d
1085   0A04 FA FF FF      lea d, [bp + -1] ; $p
1086   0A07 2A            mov b, [d]
1087   0A08             ; START TERMS
1088   0A08 D7            push a
1089   0A09 11            mov a, b
1090   0A0A 26 02 00      mov b, $2
1091   0A0D 56            add b, a
1092   0A0E E4            pop a
1093   0A0F             ; END TERMS
1094   0A0F E7            pop d
1095   0A10 FD 43         mov [d], b
1096   0A12             ;; break; 
1097   0A12 0A 5F 0A      jmp _switch15_exit ; case break
1098   0A15             _switch15_case6:
1099   0A15             
1100   0A15             ; --- BEGIN INLINE ASM BLOCK
1101   0A15 FA FF FF      lea d, [bp + -1] ; $p
1102   0A18 FD 2A         mov d, [d]
1103   0A1A 1E            mov al, [d]
1104   0A1B 23            mov ah, al
1105   0A1C 07 86 14      call _putchar
1106   0A1F             ; --- END INLINE ASM BLOCK
1107   0A1F             
1108   0A1F             ;; p = p + 2; 
1109   0A1F FA FF FF      lea d, [bp + -1] ; $p
1110   0A22 DA            push d
1111   0A23 FA FF FF      lea d, [bp + -1] ; $p
1112   0A26 2A            mov b, [d]
1113   0A27             ; START TERMS
1114   0A27 D7            push a
1115   0A28 11            mov a, b
1116   0A29 26 02 00      mov b, $2
1117   0A2C 56            add b, a
1118   0A2D E4            pop a
1119   0A2E             ; END TERMS
1120   0A2E E7            pop d
1121   0A2F FD 43         mov [d], b
1122   0A31             ;; break; 
1123   0A31 0A 5F 0A      jmp _switch15_exit ; case break
1124   0A34             _switch15_case7:
1125   0A34             
1126   0A34             ; --- BEGIN INLINE ASM BLOCK
1127   0A34 FA FF FF      lea d, [bp + -1] ; $p
1128   0A37 FD 2A         mov d, [d]
1129   0A39 FD 2A         mov d, [d]
1130   0A3B 07 D0 15      call _puts
1131   0A3E             ; --- END INLINE ASM BLOCK
1132   0A3E             
1133   0A3E             ;; p = p + 2; 
1134   0A3E FA FF FF      lea d, [bp + -1] ; $p
1135   0A41 DA            push d
1136   0A42 FA FF FF      lea d, [bp + -1] ; $p
1137   0A45 2A            mov b, [d]
1138   0A46             ; START TERMS
1139   0A46 D7            push a
1140   0A47 11            mov a, b
1141   0A48 26 02 00      mov b, $2
1142   0A4B 56            add b, a
1143   0A4C E4            pop a
1144   0A4D             ; END TERMS
1145   0A4D E7            pop d
1146   0A4E FD 43         mov [d], b
1147   0A50             ;; break; 
1148   0A50 0A 5F 0A      jmp _switch15_exit ; case break
1149   0A53             _switch15_default:
1150   0A53             ;; print("Error: Unknown argument type.\n"); 
1151   0A53 26 53 17      mov b, __s1 ; "Error: Unknown argument type.\n"
1152   0A56 FD AB         swp b
1153   0A58 D8            push b
1154   0A59 07 62 13      call print
1155   0A5C 51 02 00      add sp, 2
1156   0A5F             _switch15_exit:
1157   0A5F             ;; format_p++; 
1158   0A5F FA FD FF      lea d, [bp + -3] ; $format_p
1159   0A62 2A            mov b, [d]
1160   0A63 D8            push b
1161   0A64 FD 77         inc b
1162   0A66 FA FD FF      lea d, [bp + -3] ; $format_p
1163   0A69 FD 43         mov [d], b
1164   0A6B E5            pop b
1165   0A6C 0A 8B 0A      jmp _if14_exit
1166   0A6F             _if14_else:
1167   0A6F             ;; putchar(*format_p); 
1168   0A6F FA FD FF      lea d, [bp + -3] ; $format_p
1169   0A72 2A            mov b, [d]
1170   0A73 74            mov d, b
1171   0A74 32            mov bl, [d]
1172   0A75 A7 00         mov bh, 0
1173   0A77 DD            push bl
1174   0A78 07 1A 13      call putchar
1175   0A7B 51 01 00      add sp, 1
1176   0A7E             ;; format_p++; 
1177   0A7E FA FD FF      lea d, [bp + -3] ; $format_p
1178   0A81 2A            mov b, [d]
1179   0A82 D8            push b
1180   0A83 FD 77         inc b
1181   0A85 FA FD FF      lea d, [bp + -3] ; $format_p
1182   0A88 FD 43         mov [d], b
1183   0A8A E5            pop b
1184   0A8B             _if14_exit:
1185   0A8B             _if13_exit:
1186   0A8B             _for12_update:
1187   0A8B 0A 6C 08      jmp _for12_cond
1188   0A8E             _for12_exit:
1189   0A8E F9            leave
1190   0A8F 09            ret
1191   0A90             
1192   0A90             err:
1193   0A90 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1194   0A93             ;; print(e); 
1195   0A93 FA 05 00      lea d, [bp + 5] ; $e
1196   0A96 2A            mov b, [d]
1197   0A97 FD AB         swp b
1198   0A99 D8            push b
1199   0A9A 07 62 13      call print
1200   0A9D 51 02 00      add sp, 2
1201   0AA0 F9            leave
1202   0AA1 09            ret
1203   0AA2             
1204   0AA2             printx32:
1205   0AA2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1206   0AA5             
1207   0AA5             ; --- BEGIN INLINE ASM BLOCK
1208   0AA5 FA 05 00      lea d, [bp + 5] ; $hex
1209   0AA8 2B 02 00      mov b, [d+2]
1210   0AAB 07 28 16      call print_u16x
1211   0AAE 2A            mov b, [d]
1212   0AAF 07 28 16      call print_u16x
1213   0AB2             ; --- END INLINE ASM BLOCK
1214   0AB2             
1215   0AB2 F9            leave
1216   0AB3 09            ret
1217   0AB4             
1218   0AB4             printx16:
1219   0AB4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1220   0AB7             
1221   0AB7             ; --- BEGIN INLINE ASM BLOCK
1222   0AB7 FA 05 00      lea d, [bp + 5] ; $hex
1223   0ABA 2A            mov b, [d]
1224   0ABB 07 28 16      call print_u16x
1225   0ABE             ; --- END INLINE ASM BLOCK
1226   0ABE             
1227   0ABE F9            leave
1228   0ABF 09            ret
1229   0AC0             
1230   0AC0             printx8:
1231   0AC0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1232   0AC3             
1233   0AC3             ; --- BEGIN INLINE ASM BLOCK
1234   0AC3 FA 05 00      lea d, [bp + 5] ; $hex
1235   0AC6 32            mov bl, [d]
1236   0AC7 07 6C 16      call print_u8x
1237   0ACA             ; --- END INLINE ASM BLOCK
1238   0ACA             
1239   0ACA F9            leave
1240   0ACB 09            ret
1241   0ACC             
1242   0ACC             hex_str_to_int:
1243   0ACC F8 00 00      enter 0 ; (push bp; mov bp, sp)
1244   0ACF             ; $value 
1245   0ACF 10 00 00      mov a, $0
1246   0AD2 45 FF FF      mov [bp + -1], a
1247   0AD5             ; $i 
1248   0AD5             ; $hex_char 
1249   0AD5             ; $len 
1250   0AD5 52 07 00      sub sp, 7
1251   0AD8             ;; len = strlen(hex_string); 
1252   0AD8 FA FA FF      lea d, [bp + -6] ; $len
1253   0ADB DA            push d
1254   0ADC FA 05 00      lea d, [bp + 5] ; $hex_string
1255   0ADF 2A            mov b, [d]
1256   0AE0 FD AB         swp b
1257   0AE2 D8            push b
1258   0AE3 07 C5 05      call strlen
1259   0AE6 51 02 00      add sp, 2
1260   0AE9 E7            pop d
1261   0AEA FD 43         mov [d], b
1262   0AEC             ;; for (i = 0; i < len; i++) { 
1263   0AEC             _for19_init:
1264   0AEC FA FD FF      lea d, [bp + -3] ; $i
1265   0AEF DA            push d
1266   0AF0 26 00 00      mov b, $0
1267   0AF3 E7            pop d
1268   0AF4 FD 43         mov [d], b
1269   0AF6             _for19_cond:
1270   0AF6 FA FD FF      lea d, [bp + -3] ; $i
1271   0AF9 2A            mov b, [d]
1272   0AFA             ; START RELATIONAL
1273   0AFA D7            push a
1274   0AFB 11            mov a, b
1275   0AFC FA FA FF      lea d, [bp + -6] ; $len
1276   0AFF 2A            mov b, [d]
1277   0B00 B0            cmp a, b
1278   0B01 FD 73         slt ; < (signed)
1279   0B03 E4            pop a
1280   0B04             ; END RELATIONAL
1281   0B04 C0 00 00      cmp b, 0
1282   0B07 C6 09 0C      je _for19_exit
1283   0B0A             _for19_block:
1284   0B0A             ;; hex_char = hex_string[i]; 
1285   0B0A FA FC FF      lea d, [bp + -4] ; $hex_char
1286   0B0D DA            push d
1287   0B0E FA 05 00      lea d, [bp + 5] ; $hex_string
1288   0B11 FD 2A         mov d, [d]
1289   0B13 D7            push a
1290   0B14 DA            push d
1291   0B15 FA FD FF      lea d, [bp + -3] ; $i
1292   0B18 2A            mov b, [d]
1293   0B19 E7            pop d
1294   0B1A FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
1295   0B1E E4            pop a
1296   0B1F 32            mov bl, [d]
1297   0B20 A7 00         mov bh, 0
1298   0B22 E7            pop d
1299   0B23 FD 3E         mov [d], bl
1300   0B25             ;; if (hex_char >= 'a' && hex_char <= 'f')  
1301   0B25             _if20_cond:
1302   0B25 FA FC FF      lea d, [bp + -4] ; $hex_char
1303   0B28 32            mov bl, [d]
1304   0B29 A7 00         mov bh, 0
1305   0B2B             ; START RELATIONAL
1306   0B2B D7            push a
1307   0B2C 11            mov a, b
1308   0B2D 26 61 00      mov b, $61
1309   0B30 B0            cmp a, b
1310   0B31 FD 80         sge ; >=
1311   0B33 E4            pop a
1312   0B34             ; END RELATIONAL
1313   0B34 D7            push a
1314   0B35 11            mov a, b
1315   0B36 FA FC FF      lea d, [bp + -4] ; $hex_char
1316   0B39 32            mov bl, [d]
1317   0B3A A7 00         mov bh, 0
1318   0B3C             ; START RELATIONAL
1319   0B3C D7            push a
1320   0B3D 11            mov a, b
1321   0B3E 26 66 00      mov b, $66
1322   0B41 B0            cmp a, b
1323   0B42 FD 73         slt ; <= (signed)
1324   0B44 E4            pop a
1325   0B45             ; END RELATIONAL
1326   0B45 FD A7         sand a, b
1327   0B47 E4            pop a
1328   0B48 C0 00 00      cmp b, 0
1329   0B4B C6 7C 0B      je _if20_else
1330   0B4E             _if20_true:
1331   0B4E             ;; value = (value * 16) + (hex_char - 'a' + 10); 
1332   0B4E FA FF FF      lea d, [bp + -1] ; $value
1333   0B51 DA            push d
1334   0B52 FA FF FF      lea d, [bp + -1] ; $value
1335   0B55 2A            mov b, [d]
1336   0B56             ; START FACTORS
1337   0B56 D7            push a
1338   0B57 11            mov a, b
1339   0B58 26 10 00      mov b, $10
1340   0B5B AC            mul a, b ; *
1341   0B5C 11            mov a, b
1342   0B5D 27            mov b, a
1343   0B5E E4            pop a
1344   0B5F             ; END FACTORS
1345   0B5F             ; START TERMS
1346   0B5F D7            push a
1347   0B60 11            mov a, b
1348   0B61 FA FC FF      lea d, [bp + -4] ; $hex_char
1349   0B64 32            mov bl, [d]
1350   0B65 A7 00         mov bh, 0
1351   0B67             ; START TERMS
1352   0B67 D7            push a
1353   0B68 11            mov a, b
1354   0B69 26 61 00      mov b, $61
1355   0B6C 60            sub a, b
1356   0B6D 27            mov b, a
1357   0B6E 11            mov a, b
1358   0B6F 26 0A 00      mov b, $a
1359   0B72 56            add b, a
1360   0B73 E4            pop a
1361   0B74             ; END TERMS
1362   0B74 56            add b, a
1363   0B75 E4            pop a
1364   0B76             ; END TERMS
1365   0B76 E7            pop d
1366   0B77 FD 43         mov [d], b
1367   0B79 0A F9 0B      jmp _if20_exit
1368   0B7C             _if20_else:
1369   0B7C             ;; if (hex_char >= 'A' && hex_char <= 'F')  
1370   0B7C             _if21_cond:
1371   0B7C FA FC FF      lea d, [bp + -4] ; $hex_char
1372   0B7F 32            mov bl, [d]
1373   0B80 A7 00         mov bh, 0
1374   0B82             ; START RELATIONAL
1375   0B82 D7            push a
1376   0B83 11            mov a, b
1377   0B84 26 41 00      mov b, $41
1378   0B87 B0            cmp a, b
1379   0B88 FD 80         sge ; >=
1380   0B8A E4            pop a
1381   0B8B             ; END RELATIONAL
1382   0B8B D7            push a
1383   0B8C 11            mov a, b
1384   0B8D FA FC FF      lea d, [bp + -4] ; $hex_char
1385   0B90 32            mov bl, [d]
1386   0B91 A7 00         mov bh, 0
1387   0B93             ; START RELATIONAL
1388   0B93 D7            push a
1389   0B94 11            mov a, b
1390   0B95 26 46 00      mov b, $46
1391   0B98 B0            cmp a, b
1392   0B99 FD 73         slt ; <= (signed)
1393   0B9B E4            pop a
1394   0B9C             ; END RELATIONAL
1395   0B9C FD A7         sand a, b
1396   0B9E E4            pop a
1397   0B9F C0 00 00      cmp b, 0
1398   0BA2 C6 D3 0B      je _if21_else
1399   0BA5             _if21_true:
1400   0BA5             ;; value = (value * 16) + (hex_char - 'A' + 10); 
1401   0BA5 FA FF FF      lea d, [bp + -1] ; $value
1402   0BA8 DA            push d
1403   0BA9 FA FF FF      lea d, [bp + -1] ; $value
1404   0BAC 2A            mov b, [d]
1405   0BAD             ; START FACTORS
1406   0BAD D7            push a
1407   0BAE 11            mov a, b
1408   0BAF 26 10 00      mov b, $10
1409   0BB2 AC            mul a, b ; *
1410   0BB3 11            mov a, b
1411   0BB4 27            mov b, a
1412   0BB5 E4            pop a
1413   0BB6             ; END FACTORS
1414   0BB6             ; START TERMS
1415   0BB6 D7            push a
1416   0BB7 11            mov a, b
1417   0BB8 FA FC FF      lea d, [bp + -4] ; $hex_char
1418   0BBB 32            mov bl, [d]
1419   0BBC A7 00         mov bh, 0
1420   0BBE             ; START TERMS
1421   0BBE D7            push a
1422   0BBF 11            mov a, b
1423   0BC0 26 41 00      mov b, $41
1424   0BC3 60            sub a, b
1425   0BC4 27            mov b, a
1426   0BC5 11            mov a, b
1427   0BC6 26 0A 00      mov b, $a
1428   0BC9 56            add b, a
1429   0BCA E4            pop a
1430   0BCB             ; END TERMS
1431   0BCB 56            add b, a
1432   0BCC E4            pop a
1433   0BCD             ; END TERMS
1434   0BCD E7            pop d
1435   0BCE FD 43         mov [d], b
1436   0BD0 0A F9 0B      jmp _if21_exit
1437   0BD3             _if21_else:
1438   0BD3             ;; value = (value * 16) + (hex_char - '0'); 
1439   0BD3 FA FF FF      lea d, [bp + -1] ; $value
1440   0BD6 DA            push d
1441   0BD7 FA FF FF      lea d, [bp + -1] ; $value
1442   0BDA 2A            mov b, [d]
1443   0BDB             ; START FACTORS
1444   0BDB D7            push a
1445   0BDC 11            mov a, b
1446   0BDD 26 10 00      mov b, $10
1447   0BE0 AC            mul a, b ; *
1448   0BE1 11            mov a, b
1449   0BE2 27            mov b, a
1450   0BE3 E4            pop a
1451   0BE4             ; END FACTORS
1452   0BE4             ; START TERMS
1453   0BE4 D7            push a
1454   0BE5 11            mov a, b
1455   0BE6 FA FC FF      lea d, [bp + -4] ; $hex_char
1456   0BE9 32            mov bl, [d]
1457   0BEA A7 00         mov bh, 0
1458   0BEC             ; START TERMS
1459   0BEC D7            push a
1460   0BED 11            mov a, b
1461   0BEE 26 30 00      mov b, $30
1462   0BF1 60            sub a, b
1463   0BF2 27            mov b, a
1464   0BF3 E4            pop a
1465   0BF4             ; END TERMS
1466   0BF4 56            add b, a
1467   0BF5 E4            pop a
1468   0BF6             ; END TERMS
1469   0BF6 E7            pop d
1470   0BF7 FD 43         mov [d], b
1471   0BF9             _if21_exit:
1472   0BF9             _if20_exit:
1473   0BF9             _for19_update:
1474   0BF9 FA FD FF      lea d, [bp + -3] ; $i
1475   0BFC 2A            mov b, [d]
1476   0BFD D8            push b
1477   0BFE FD 77         inc b
1478   0C00 FA FD FF      lea d, [bp + -3] ; $i
1479   0C03 FD 43         mov [d], b
1480   0C05 E5            pop b
1481   0C06 0A F6 0A      jmp _for19_cond
1482   0C09             _for19_exit:
1483   0C09             ;; return value; 
1484   0C09 FA FF FF      lea d, [bp + -1] ; $value
1485   0C0C 2A            mov b, [d]
1486   0C0D F9            leave
1487   0C0E 09            ret
1488   0C0F             
1489   0C0F             gets:
1490   0C0F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1491   0C12             
1492   0C12             ; --- BEGIN INLINE ASM BLOCK
1493   0C12 FA 05 00      lea d, [bp + 5] ; $s
1494   0C15 15            mov a, [d]
1495   0C16 3C            mov d, a
1496   0C17 07 8D 14      call _gets
1497   0C1A             ; --- END INLINE ASM BLOCK
1498   0C1A             
1499   0C1A             ;; return strlen(s); 
1500   0C1A FA 05 00      lea d, [bp + 5] ; $s
1501   0C1D 2A            mov b, [d]
1502   0C1E FD AB         swp b
1503   0C20 D8            push b
1504   0C21 07 C5 05      call strlen
1505   0C24 51 02 00      add sp, 2
1506   0C27 F9            leave
1507   0C28 09            ret
1508   0C29             
1509   0C29             print_signed:
1510   0C29 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1511   0C2C             ; $digits 
1512   0C2C             ; $i 
1513   0C2C 10 00 00      mov a, $0
1514   0C2F 45 FA FF      mov [bp + -6], a
1515   0C32 52 07 00      sub sp, 7
1516   0C35             ;; if (num < 0) { 
1517   0C35             _if22_cond:
1518   0C35 FA 05 00      lea d, [bp + 5] ; $num
1519   0C38 2A            mov b, [d]
1520   0C39             ; START RELATIONAL
1521   0C39 D7            push a
1522   0C3A 11            mov a, b
1523   0C3B 26 00 00      mov b, $0
1524   0C3E B0            cmp a, b
1525   0C3F FD 73         slt ; < (signed)
1526   0C41 E4            pop a
1527   0C42             ; END RELATIONAL
1528   0C42 C0 00 00      cmp b, 0
1529   0C45 C6 62 0C      je _if22_else
1530   0C48             _if22_true:
1531   0C48             ;; putchar('-'); 
1532   0C48 26 2D 00      mov b, $2d
1533   0C4B DD            push bl
1534   0C4C 07 1A 13      call putchar
1535   0C4F 51 01 00      add sp, 1
1536   0C52             ;; num = -num; 
1537   0C52 FA 05 00      lea d, [bp + 5] ; $num
1538   0C55 DA            push d
1539   0C56 FA 05 00      lea d, [bp + 5] ; $num
1540   0C59 2A            mov b, [d]
1541   0C5A FD 97         neg b
1542   0C5C E7            pop d
1543   0C5D FD 43         mov [d], b
1544   0C5F 0A 84 0C      jmp _if22_exit
1545   0C62             _if22_else:
1546   0C62             ;; if (num == 0) { 
1547   0C62             _if23_cond:
1548   0C62 FA 05 00      lea d, [bp + 5] ; $num
1549   0C65 2A            mov b, [d]
1550   0C66             ; START RELATIONAL
1551   0C66 D7            push a
1552   0C67 11            mov a, b
1553   0C68 26 00 00      mov b, $0
1554   0C6B B0            cmp a, b
1555   0C6C FD 71         seq ; ==
1556   0C6E E4            pop a
1557   0C6F             ; END RELATIONAL
1558   0C6F C0 00 00      cmp b, 0
1559   0C72 C6 84 0C      je _if23_exit
1560   0C75             _if23_true:
1561   0C75             ;; putchar('0'); 
1562   0C75 26 30 00      mov b, $30
1563   0C78 DD            push bl
1564   0C79 07 1A 13      call putchar
1565   0C7C 51 01 00      add sp, 1
1566   0C7F             ;; return; 
1567   0C7F F9            leave
1568   0C80 09            ret
1569   0C81 0A 84 0C      jmp _if23_exit
1570   0C84             _if23_exit:
1571   0C84             _if22_exit:
1572   0C84             ;; while (num > 0) { 
1573   0C84             _while24_cond:
1574   0C84 FA 05 00      lea d, [bp + 5] ; $num
1575   0C87 2A            mov b, [d]
1576   0C88             ; START RELATIONAL
1577   0C88 D7            push a
1578   0C89 11            mov a, b
1579   0C8A 26 00 00      mov b, $0
1580   0C8D B0            cmp a, b
1581   0C8E FD 7F         sgt ; >
1582   0C90 E4            pop a
1583   0C91             ; END RELATIONAL
1584   0C91 C0 00 00      cmp b, 0
1585   0C94 C6 DE 0C      je _while24_exit
1586   0C97             _while24_block:
1587   0C97             ;; digits[i] = '0' + (num % 10); 
1588   0C97 FA FC FF      lea d, [bp + -4] ; $digits
1589   0C9A D7            push a
1590   0C9B DA            push d
1591   0C9C FA FA FF      lea d, [bp + -6] ; $i
1592   0C9F 2A            mov b, [d]
1593   0CA0 E7            pop d
1594   0CA1 5A            add d, b
1595   0CA2 E4            pop a
1596   0CA3 DA            push d
1597   0CA4 26 30 00      mov b, $30
1598   0CA7             ; START TERMS
1599   0CA7 D7            push a
1600   0CA8 11            mov a, b
1601   0CA9 FA 05 00      lea d, [bp + 5] ; $num
1602   0CAC 2A            mov b, [d]
1603   0CAD             ; START FACTORS
1604   0CAD D7            push a
1605   0CAE 11            mov a, b
1606   0CAF 26 0A 00      mov b, $a
1607   0CB2 AE            div a, b ; 
1608   0CB3 11            mov a, b
1609   0CB4 27            mov b, a
1610   0CB5 E4            pop a
1611   0CB6             ; END FACTORS
1612   0CB6 56            add b, a
1613   0CB7 E4            pop a
1614   0CB8             ; END TERMS
1615   0CB8 E7            pop d
1616   0CB9 FD 3E         mov [d], bl
1617   0CBB             ;; num = num / 10; 
1618   0CBB FA 05 00      lea d, [bp + 5] ; $num
1619   0CBE DA            push d
1620   0CBF FA 05 00      lea d, [bp + 5] ; $num
1621   0CC2 2A            mov b, [d]
1622   0CC3             ; START FACTORS
1623   0CC3 D7            push a
1624   0CC4 11            mov a, b
1625   0CC5 26 0A 00      mov b, $a
1626   0CC8 AE            div a, b
1627   0CC9 27            mov b, a
1628   0CCA E4            pop a
1629   0CCB             ; END FACTORS
1630   0CCB E7            pop d
1631   0CCC FD 43         mov [d], b
1632   0CCE             ;; i++; 
1633   0CCE FA FA FF      lea d, [bp + -6] ; $i
1634   0CD1 2A            mov b, [d]
1635   0CD2 D8            push b
1636   0CD3 FD 77         inc b
1637   0CD5 FA FA FF      lea d, [bp + -6] ; $i
1638   0CD8 FD 43         mov [d], b
1639   0CDA E5            pop b
1640   0CDB 0A 84 0C      jmp _while24_cond
1641   0CDE             _while24_exit:
1642   0CDE             ;; while (i > 0) { 
1643   0CDE             _while25_cond:
1644   0CDE FA FA FF      lea d, [bp + -6] ; $i
1645   0CE1 2A            mov b, [d]
1646   0CE2             ; START RELATIONAL
1647   0CE2 D7            push a
1648   0CE3 11            mov a, b
1649   0CE4 26 00 00      mov b, $0
1650   0CE7 B0            cmp a, b
1651   0CE8 FD 7F         sgt ; >
1652   0CEA E4            pop a
1653   0CEB             ; END RELATIONAL
1654   0CEB C0 00 00      cmp b, 0
1655   0CEE C6 17 0D      je _while25_exit
1656   0CF1             _while25_block:
1657   0CF1             ;; i--; 
1658   0CF1 FA FA FF      lea d, [bp + -6] ; $i
1659   0CF4 2A            mov b, [d]
1660   0CF5 D8            push b
1661   0CF6 FD 7D         dec b
1662   0CF8 FA FA FF      lea d, [bp + -6] ; $i
1663   0CFB FD 43         mov [d], b
1664   0CFD E5            pop b
1665   0CFE             ;; putchar(digits[i]); 
1666   0CFE FA FC FF      lea d, [bp + -4] ; $digits
1667   0D01 D7            push a
1668   0D02 DA            push d
1669   0D03 FA FA FF      lea d, [bp + -6] ; $i
1670   0D06 2A            mov b, [d]
1671   0D07 E7            pop d
1672   0D08 5A            add d, b
1673   0D09 E4            pop a
1674   0D0A 32            mov bl, [d]
1675   0D0B A7 00         mov bh, 0
1676   0D0D DD            push bl
1677   0D0E 07 1A 13      call putchar
1678   0D11 51 01 00      add sp, 1
1679   0D14 0A DE 0C      jmp _while25_cond
1680   0D17             _while25_exit:
1681   0D17 F9            leave
1682   0D18 09            ret
1683   0D19             
1684   0D19             print_signed_long:
1685   0D19 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1686   0D1C             ; $digits 
1687   0D1C             ; $i 
1688   0D1C 10 00 00      mov a, $0
1689   0D1F 45 F5 FF      mov [bp + -11], a
1690   0D22 52 0C 00      sub sp, 12
1691   0D25             ;; if (num < 0) { 
1692   0D25             _if26_cond:
1693   0D25 FA 05 00      lea d, [bp + 5] ; $num
1694   0D28 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1695   0D2B FD 39         mov c, b ; And place it into C
1696   0D2D 2A            mov b, [d] ; Lower Word in B
1697   0D2E             ; START RELATIONAL
1698   0D2E D7            push a
1699   0D2F FD D8         push g
1700   0D31 11            mov a, b
1701   0D32 FD 7A         mov g, c
1702   0D34 26 00 00      mov b, $0
1703   0D37 38 00 00      mov c, 0
1704   0D3A FD AF 00 00   cmp32 ga, cb
1704   0D3E 00 00 00 00 
1704   0D42 00 00 00 00 
1704   0D46 00 00 00 00 
1704   0D4A 00 00 00 00 
1704   0D4E 00 00 00 00 
1704   0D52 00 00 00 00 
1704   0D56 00 00 00 00 
1704   0D5A 00 00 00 00 
1704   0D5E 00 00 00 00 
1704   0D62 00 00 00 00 
1704   0D66 00 00 00 00 
1704   0D6A 00 00 00 00 
1704   0D6E 00 00 00 00 
1704   0D72 00 00 00 00 
1704   0D76 00 00 00 00 
1704   0D7A 00 00 00 00 
1704   0D7E 00 00 00 00 
1704   0D82 00 00 00 00 
1704   0D86 00 00 00 00 
1704   0D8A 00 00 00 00 
1704   0D8E 00 00 00 00 
1704   0D92 00 00 00 00 
1704   0D96 00 00 00 00 
1704   0D9A 00 00 00 00 
1704   0D9E 00 00 00 00 
1704   0DA2 00 00 00 00 
1704   0DA6 00 00 00 00 
1704   0DAA 00 00 00 00 
1704   0DAE 00 00 00 00 
1704   0DB2 00 00 00 00 
1704   0DB6 00 00 00 00 
1704   0DBA 00 00 00 00 
1704   0DBE 00 00 00 00 
1704   0DC2 00 00 00 00 
1704   0DC6 00 00 00 00 
1704   0DCA 00 00 00 00 
1704   0DCE 00 00 00 00 
1704   0DD2 00 00 00 00 
1704   0DD6 00 00 00 00 
1704   0DDA 00 00 00 00 
1704   0DDE 00 00 00 00 
1704   0DE2 00 00 00 00 
1704   0DE6 00 00 00 00 
1704   0DEA 00 00 00 00 
1704   0DEE 00 00 00 00 
1704   0DF2 00 00 00 00 
1704   0DF6 00 00 00 00 
1704   0DFA 00 00 00 00 
1704   0DFE 00 00 00 00 
1704   0E02 00 00 00 00 
1704   0E06 00 00 00 00 
1704   0E0A 00 00 00 00 
1704   0E0E 00 00 00 00 
1704   0E12 00 00 00 00 
1704   0E16 00 00 00 00 
1704   0E1A 00 00 00 00 
1704   0E1E 00 00 00 00 
1704   0E22 00 00 00 00 
1704   0E26 00 00 00 00 
1704   0E2A 00 00 00 00 
1704   0E2E 00 00 00 00 
1704   0E32 00 00 00 00 
1704   0E36 00 00 00 00 
1704   0E3A 00 
1705   0E3B FD 73         slt ; <
1706   0E3D FD F1         pop g
1707   0E3F E4            pop a
1708   0E40             ; END RELATIONAL
1709   0E40 C0 00 00      cmp b, 0
1710   0E43 C6 6A 0E      je _if26_else
1711   0E46             _if26_true:
1712   0E46             ;; putchar('-'); 
1713   0E46 26 2D 00      mov b, $2d
1714   0E49 DD            push bl
1715   0E4A 07 1A 13      call putchar
1716   0E4D 51 01 00      add sp, 1
1717   0E50             ;; num = -num; 
1718   0E50 FA 05 00      lea d, [bp + 5] ; $num
1719   0E53 DA            push d
1720   0E54 FA 05 00      lea d, [bp + 5] ; $num
1721   0E57 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1722   0E5A FD 39         mov c, b ; And place it into C
1723   0E5C 2A            mov b, [d] ; Lower Word in B
1724   0E5D FD 97         neg b
1725   0E5F E7            pop d
1726   0E60 FD 43         mov [d], b
1727   0E62 28            mov b, c
1728   0E63 FD 44 02 00   mov [d + 2], b
1729   0E67 0A 9A 0F      jmp _if26_exit
1730   0E6A             _if26_else:
1731   0E6A             ;; if (num == 0) { 
1732   0E6A             _if27_cond:
1733   0E6A FA 05 00      lea d, [bp + 5] ; $num
1734   0E6D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1735   0E70 FD 39         mov c, b ; And place it into C
1736   0E72 2A            mov b, [d] ; Lower Word in B
1737   0E73             ; START RELATIONAL
1738   0E73 D7            push a
1739   0E74 FD D8         push g
1740   0E76 11            mov a, b
1741   0E77 FD 7A         mov g, c
1742   0E79 26 00 00      mov b, $0
1743   0E7C 38 00 00      mov c, 0
1744   0E7F FD AF 00 00   cmp32 ga, cb
1744   0E83 00 00 00 00 
1744   0E87 00 00 00 00 
1744   0E8B 00 00 00 00 
1744   0E8F 00 00 00 00 
1744   0E93 00 00 00 00 
1744   0E97 00 00 00 00 
1744   0E9B 00 00 00 00 
1744   0E9F 00 00 00 00 
1744   0EA3 00 00 00 00 
1744   0EA7 00 00 00 00 
1744   0EAB 00 00 00 00 
1744   0EAF 00 00 00 00 
1744   0EB3 00 00 00 00 
1744   0EB7 00 00 00 00 
1744   0EBB 00 00 00 00 
1744   0EBF 00 00 00 00 
1744   0EC3 00 00 00 00 
1744   0EC7 00 00 00 00 
1744   0ECB 00 00 00 00 
1744   0ECF 00 00 00 00 
1744   0ED3 00 00 00 00 
1744   0ED7 00 00 00 00 
1744   0EDB 00 00 00 00 
1744   0EDF 00 00 00 00 
1744   0EE3 00 00 00 00 
1744   0EE7 00 00 00 00 
1744   0EEB 00 00 00 00 
1744   0EEF 00 00 00 00 
1744   0EF3 00 00 00 00 
1744   0EF7 00 00 00 00 
1744   0EFB 00 00 00 00 
1744   0EFF 00 00 00 00 
1744   0F03 00 00 00 00 
1744   0F07 00 00 00 00 
1744   0F0B 00 00 00 00 
1744   0F0F 00 00 00 00 
1744   0F13 00 00 00 00 
1744   0F17 00 00 00 00 
1744   0F1B 00 00 00 00 
1744   0F1F 00 00 00 00 
1744   0F23 00 00 00 00 
1744   0F27 00 00 00 00 
1744   0F2B 00 00 00 00 
1744   0F2F 00 00 00 00 
1744   0F33 00 00 00 00 
1744   0F37 00 00 00 00 
1744   0F3B 00 00 00 00 
1744   0F3F 00 00 00 00 
1744   0F43 00 00 00 00 
1744   0F47 00 00 00 00 
1744   0F4B 00 00 00 00 
1744   0F4F 00 00 00 00 
1744   0F53 00 00 00 00 
1744   0F57 00 00 00 00 
1744   0F5B 00 00 00 00 
1744   0F5F 00 00 00 00 
1744   0F63 00 00 00 00 
1744   0F67 00 00 00 00 
1744   0F6B 00 00 00 00 
1744   0F6F 00 00 00 00 
1744   0F73 00 00 00 00 
1744   0F77 00 00 00 00 
1744   0F7B 00 00 00 00 
1744   0F7F 00 
1745   0F80 FD 71         seq ; ==
1746   0F82 FD F1         pop g
1747   0F84 E4            pop a
1748   0F85             ; END RELATIONAL
1749   0F85 C0 00 00      cmp b, 0
1750   0F88 C6 9A 0F      je _if27_exit
1751   0F8B             _if27_true:
1752   0F8B             ;; putchar('0'); 
1753   0F8B 26 30 00      mov b, $30
1754   0F8E DD            push bl
1755   0F8F 07 1A 13      call putchar
1756   0F92 51 01 00      add sp, 1
1757   0F95             ;; return; 
1758   0F95 F9            leave
1759   0F96 09            ret
1760   0F97 0A 9A 0F      jmp _if27_exit
1761   0F9A             _if27_exit:
1762   0F9A             _if26_exit:
1763   0F9A             ;; while (num > 0) { 
1764   0F9A             _while28_cond:
1765   0F9A FA 05 00      lea d, [bp + 5] ; $num
1766   0F9D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1767   0FA0 FD 39         mov c, b ; And place it into C
1768   0FA2 2A            mov b, [d] ; Lower Word in B
1769   0FA3             ; START RELATIONAL
1770   0FA3 D7            push a
1771   0FA4 FD D8         push g
1772   0FA6 11            mov a, b
1773   0FA7 FD 7A         mov g, c
1774   0FA9 26 00 00      mov b, $0
1775   0FAC 38 00 00      mov c, 0
1776   0FAF FD 7F         sgt
1777   0FB1 FD F1         pop g
1778   0FB3 E4            pop a
1779   0FB4             ; END RELATIONAL
1780   0FB4 C0 00 00      cmp b, 0
1781   0FB7 C6 17 10      je _while28_exit
1782   0FBA             _while28_block:
1783   0FBA             ;; digits[i] = '0' + (num % 10); 
1784   0FBA FA F7 FF      lea d, [bp + -9] ; $digits
1785   0FBD D7            push a
1786   0FBE DA            push d
1787   0FBF FA F5 FF      lea d, [bp + -11] ; $i
1788   0FC2 2A            mov b, [d]
1789   0FC3 E7            pop d
1790   0FC4 5A            add d, b
1791   0FC5 E4            pop a
1792   0FC6 DA            push d
1793   0FC7 26 30 00      mov b, $30
1794   0FCA             ; START TERMS
1795   0FCA D7            push a
1796   0FCB 11            mov a, b
1797   0FCC FA 05 00      lea d, [bp + 5] ; $num
1798   0FCF 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1799   0FD2 FD 39         mov c, b ; And place it into C
1800   0FD4 2A            mov b, [d] ; Lower Word in B
1801   0FD5             ; START FACTORS
1802   0FD5 D7            push a
1803   0FD6 11            mov a, b
1804   0FD7 26 0A 00      mov b, $a
1805   0FDA AE            div a, b ; 
1806   0FDB 11            mov a, b
1807   0FDC 27            mov b, a
1808   0FDD E4            pop a
1809   0FDE             ; END FACTORS
1810   0FDE 54            add a, b
1811   0FDF D7            push a
1812   0FE0 FD 12         mov a, g
1813   0FE2 28            mov b, c
1814   0FE3 5C            adc a, b
1815   0FE4 39            mov c, a
1816   0FE5 E5            pop b
1817   0FE6 E4            pop a
1818   0FE7             ; END TERMS
1819   0FE7 E7            pop d
1820   0FE8 FD 3E         mov [d], bl
1821   0FEA             ;; num = num / 10; 
1822   0FEA FA 05 00      lea d, [bp + 5] ; $num
1823   0FED DA            push d
1824   0FEE FA 05 00      lea d, [bp + 5] ; $num
1825   0FF1 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1826   0FF4 FD 39         mov c, b ; And place it into C
1827   0FF6 2A            mov b, [d] ; Lower Word in B
1828   0FF7             ; START FACTORS
1829   0FF7 D7            push a
1830   0FF8 11            mov a, b
1831   0FF9 26 0A 00      mov b, $a
1832   0FFC AE            div a, b
1833   0FFD 27            mov b, a
1834   0FFE E4            pop a
1835   0FFF             ; END FACTORS
1836   0FFF E7            pop d
1837   1000 FD 43         mov [d], b
1838   1002 28            mov b, c
1839   1003 FD 44 02 00   mov [d + 2], b
1840   1007             ;; i++; 
1841   1007 FA F5 FF      lea d, [bp + -11] ; $i
1842   100A 2A            mov b, [d]
1843   100B D8            push b
1844   100C FD 77         inc b
1845   100E FA F5 FF      lea d, [bp + -11] ; $i
1846   1011 FD 43         mov [d], b
1847   1013 E5            pop b
1848   1014 0A 9A 0F      jmp _while28_cond
1849   1017             _while28_exit:
1850   1017             ;; while (i > 0) { 
1851   1017             _while29_cond:
1852   1017 FA F5 FF      lea d, [bp + -11] ; $i
1853   101A 2A            mov b, [d]
1854   101B             ; START RELATIONAL
1855   101B D7            push a
1856   101C 11            mov a, b
1857   101D 26 00 00      mov b, $0
1858   1020 B0            cmp a, b
1859   1021 FD 7F         sgt ; >
1860   1023 E4            pop a
1861   1024             ; END RELATIONAL
1862   1024 C0 00 00      cmp b, 0
1863   1027 C6 50 10      je _while29_exit
1864   102A             _while29_block:
1865   102A             ;; i--; 
1866   102A FA F5 FF      lea d, [bp + -11] ; $i
1867   102D 2A            mov b, [d]
1868   102E D8            push b
1869   102F FD 7D         dec b
1870   1031 FA F5 FF      lea d, [bp + -11] ; $i
1871   1034 FD 43         mov [d], b
1872   1036 E5            pop b
1873   1037             ;; putchar(digits[i]); 
1874   1037 FA F7 FF      lea d, [bp + -9] ; $digits
1875   103A D7            push a
1876   103B DA            push d
1877   103C FA F5 FF      lea d, [bp + -11] ; $i
1878   103F 2A            mov b, [d]
1879   1040 E7            pop d
1880   1041 5A            add d, b
1881   1042 E4            pop a
1882   1043 32            mov bl, [d]
1883   1044 A7 00         mov bh, 0
1884   1046 DD            push bl
1885   1047 07 1A 13      call putchar
1886   104A 51 01 00      add sp, 1
1887   104D 0A 17 10      jmp _while29_cond
1888   1050             _while29_exit:
1889   1050 F9            leave
1890   1051 09            ret
1891   1052             
1892   1052             print_unsigned_long:
1893   1052 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1894   1055             ; $digits 
1895   1055             ; $i 
1896   1055 52 0C 00      sub sp, 12
1897   1058             ;; i = 0; 
1898   1058 FA F5 FF      lea d, [bp + -11] ; $i
1899   105B DA            push d
1900   105C 26 00 00      mov b, $0
1901   105F E7            pop d
1902   1060 FD 43         mov [d], b
1903   1062             ;; if(num == 0){ 
1904   1062             _if30_cond:
1905   1062 FA 05 00      lea d, [bp + 5] ; $num
1906   1065 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1907   1068 FD 39         mov c, b ; And place it into C
1908   106A 2A            mov b, [d] ; Lower Word in B
1909   106B             ; START RELATIONAL
1910   106B D7            push a
1911   106C FD D8         push g
1912   106E 11            mov a, b
1913   106F FD 7A         mov g, c
1914   1071 26 00 00      mov b, $0
1915   1074 38 00 00      mov c, 0
1916   1077 FD AF 00 00   cmp32 ga, cb
1916   107B 00 00 00 00 
1916   107F 00 00 00 00 
1916   1083 00 00 00 00 
1916   1087 00 00 00 00 
1916   108B 00 00 00 00 
1916   108F 00 00 00 00 
1916   1093 00 00 00 00 
1916   1097 00 00 00 00 
1916   109B 00 00 00 00 
1916   109F 00 00 00 00 
1916   10A3 00 00 00 00 
1916   10A7 00 00 00 00 
1916   10AB 00 00 00 00 
1916   10AF 00 00 00 00 
1916   10B3 00 00 00 00 
1916   10B7 00 00 00 00 
1916   10BB 00 00 00 00 
1916   10BF 00 00 00 00 
1916   10C3 00 00 00 00 
1916   10C7 00 00 00 00 
1916   10CB 00 00 00 00 
1916   10CF 00 00 00 00 
1916   10D3 00 00 00 00 
1916   10D7 00 00 00 00 
1916   10DB 00 00 00 00 
1916   10DF 00 00 00 00 
1916   10E3 00 00 00 00 
1916   10E7 00 00 00 00 
1916   10EB 00 00 00 00 
1916   10EF 00 00 00 00 
1916   10F3 00 00 00 00 
1916   10F7 00 00 00 00 
1916   10FB 00 00 00 00 
1916   10FF 00 00 00 00 
1916   1103 00 00 00 00 
1916   1107 00 00 00 00 
1916   110B 00 00 00 00 
1916   110F 00 00 00 00 
1916   1113 00 00 00 00 
1916   1117 00 00 00 00 
1916   111B 00 00 00 00 
1916   111F 00 00 00 00 
1916   1123 00 00 00 00 
1916   1127 00 00 00 00 
1916   112B 00 00 00 00 
1916   112F 00 00 00 00 
1916   1133 00 00 00 00 
1916   1137 00 00 00 00 
1916   113B 00 00 00 00 
1916   113F 00 00 00 00 
1916   1143 00 00 00 00 
1916   1147 00 00 00 00 
1916   114B 00 00 00 00 
1916   114F 00 00 00 00 
1916   1153 00 00 00 00 
1916   1157 00 00 00 00 
1916   115B 00 00 00 00 
1916   115F 00 00 00 00 
1916   1163 00 00 00 00 
1916   1167 00 00 00 00 
1916   116B 00 00 00 00 
1916   116F 00 00 00 00 
1916   1173 00 00 00 00 
1916   1177 00 
1917   1178 FD 71         seq ; ==
1918   117A FD F1         pop g
1919   117C E4            pop a
1920   117D             ; END RELATIONAL
1921   117D C0 00 00      cmp b, 0
1922   1180 C6 92 11      je _if30_exit
1923   1183             _if30_true:
1924   1183             ;; putchar('0'); 
1925   1183 26 30 00      mov b, $30
1926   1186 DD            push bl
1927   1187 07 1A 13      call putchar
1928   118A 51 01 00      add sp, 1
1929   118D             ;; return; 
1930   118D F9            leave
1931   118E 09            ret
1932   118F 0A 92 11      jmp _if30_exit
1933   1192             _if30_exit:
1934   1192             ;; while (num > 0) { 
1935   1192             _while31_cond:
1936   1192 FA 05 00      lea d, [bp + 5] ; $num
1937   1195 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1938   1198 FD 39         mov c, b ; And place it into C
1939   119A 2A            mov b, [d] ; Lower Word in B
1940   119B             ; START RELATIONAL
1941   119B D7            push a
1942   119C FD D8         push g
1943   119E 11            mov a, b
1944   119F FD 7A         mov g, c
1945   11A1 26 00 00      mov b, $0
1946   11A4 38 00 00      mov c, 0
1947   11A7 FD 81         sgu
1948   11A9 FD F1         pop g
1949   11AB E4            pop a
1950   11AC             ; END RELATIONAL
1951   11AC C0 00 00      cmp b, 0
1952   11AF C6 0F 12      je _while31_exit
1953   11B2             _while31_block:
1954   11B2             ;; digits[i] = '0' + (num % 10); 
1955   11B2 FA F7 FF      lea d, [bp + -9] ; $digits
1956   11B5 D7            push a
1957   11B6 DA            push d
1958   11B7 FA F5 FF      lea d, [bp + -11] ; $i
1959   11BA 2A            mov b, [d]
1960   11BB E7            pop d
1961   11BC 5A            add d, b
1962   11BD E4            pop a
1963   11BE DA            push d
1964   11BF 26 30 00      mov b, $30
1965   11C2             ; START TERMS
1966   11C2 D7            push a
1967   11C3 11            mov a, b
1968   11C4 FA 05 00      lea d, [bp + 5] ; $num
1969   11C7 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1970   11CA FD 39         mov c, b ; And place it into C
1971   11CC 2A            mov b, [d] ; Lower Word in B
1972   11CD             ; START FACTORS
1973   11CD D7            push a
1974   11CE 11            mov a, b
1975   11CF 26 0A 00      mov b, $a
1976   11D2 AE            div a, b ; 
1977   11D3 11            mov a, b
1978   11D4 27            mov b, a
1979   11D5 E4            pop a
1980   11D6             ; END FACTORS
1981   11D6 54            add a, b
1982   11D7 D7            push a
1983   11D8 FD 12         mov a, g
1984   11DA 28            mov b, c
1985   11DB 5C            adc a, b
1986   11DC 39            mov c, a
1987   11DD E5            pop b
1988   11DE E4            pop a
1989   11DF             ; END TERMS
1990   11DF E7            pop d
1991   11E0 FD 3E         mov [d], bl
1992   11E2             ;; num = num / 10; 
1993   11E2 FA 05 00      lea d, [bp + 5] ; $num
1994   11E5 DA            push d
1995   11E6 FA 05 00      lea d, [bp + 5] ; $num
1996   11E9 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1997   11EC FD 39         mov c, b ; And place it into C
1998   11EE 2A            mov b, [d] ; Lower Word in B
1999   11EF             ; START FACTORS
2000   11EF D7            push a
2001   11F0 11            mov a, b
2002   11F1 26 0A 00      mov b, $a
2003   11F4 AE            div a, b
2004   11F5 27            mov b, a
2005   11F6 E4            pop a
2006   11F7             ; END FACTORS
2007   11F7 E7            pop d
2008   11F8 FD 43         mov [d], b
2009   11FA 28            mov b, c
2010   11FB FD 44 02 00   mov [d + 2], b
2011   11FF             ;; i++; 
2012   11FF FA F5 FF      lea d, [bp + -11] ; $i
2013   1202 2A            mov b, [d]
2014   1203 D8            push b
2015   1204 FD 77         inc b
2016   1206 FA F5 FF      lea d, [bp + -11] ; $i
2017   1209 FD 43         mov [d], b
2018   120B E5            pop b
2019   120C 0A 92 11      jmp _while31_cond
2020   120F             _while31_exit:
2021   120F             ;; while (i > 0) { 
2022   120F             _while32_cond:
2023   120F FA F5 FF      lea d, [bp + -11] ; $i
2024   1212 2A            mov b, [d]
2025   1213             ; START RELATIONAL
2026   1213 D7            push a
2027   1214 11            mov a, b
2028   1215 26 00 00      mov b, $0
2029   1218 B0            cmp a, b
2030   1219 FD 7F         sgt ; >
2031   121B E4            pop a
2032   121C             ; END RELATIONAL
2033   121C C0 00 00      cmp b, 0
2034   121F C6 48 12      je _while32_exit
2035   1222             _while32_block:
2036   1222             ;; i--; 
2037   1222 FA F5 FF      lea d, [bp + -11] ; $i
2038   1225 2A            mov b, [d]
2039   1226 D8            push b
2040   1227 FD 7D         dec b
2041   1229 FA F5 FF      lea d, [bp + -11] ; $i
2042   122C FD 43         mov [d], b
2043   122E E5            pop b
2044   122F             ;; putchar(digits[i]); 
2045   122F FA F7 FF      lea d, [bp + -9] ; $digits
2046   1232 D7            push a
2047   1233 DA            push d
2048   1234 FA F5 FF      lea d, [bp + -11] ; $i
2049   1237 2A            mov b, [d]
2050   1238 E7            pop d
2051   1239 5A            add d, b
2052   123A E4            pop a
2053   123B 32            mov bl, [d]
2054   123C A7 00         mov bh, 0
2055   123E DD            push bl
2056   123F 07 1A 13      call putchar
2057   1242 51 01 00      add sp, 1
2058   1245 0A 0F 12      jmp _while32_cond
2059   1248             _while32_exit:
2060   1248 F9            leave
2061   1249 09            ret
2062   124A             
2063   124A             print_unsigned:
2064   124A F8 00 00      enter 0 ; (push bp; mov bp, sp)
2065   124D             ; $digits 
2066   124D             ; $i 
2067   124D 52 07 00      sub sp, 7
2068   1250             ;; i = 0; 
2069   1250 FA FA FF      lea d, [bp + -6] ; $i
2070   1253 DA            push d
2071   1254 26 00 00      mov b, $0
2072   1257 E7            pop d
2073   1258 FD 43         mov [d], b
2074   125A             ;; if(num == 0){ 
2075   125A             _if33_cond:
2076   125A FA 05 00      lea d, [bp + 5] ; $num
2077   125D 2A            mov b, [d]
2078   125E             ; START RELATIONAL
2079   125E D7            push a
2080   125F 11            mov a, b
2081   1260 26 00 00      mov b, $0
2082   1263 B0            cmp a, b
2083   1264 FD 71         seq ; ==
2084   1266 E4            pop a
2085   1267             ; END RELATIONAL
2086   1267 C0 00 00      cmp b, 0
2087   126A C6 7C 12      je _if33_exit
2088   126D             _if33_true:
2089   126D             ;; putchar('0'); 
2090   126D 26 30 00      mov b, $30
2091   1270 DD            push bl
2092   1271 07 1A 13      call putchar
2093   1274 51 01 00      add sp, 1
2094   1277             ;; return; 
2095   1277 F9            leave
2096   1278 09            ret
2097   1279 0A 7C 12      jmp _if33_exit
2098   127C             _if33_exit:
2099   127C             ;; while (num > 0) { 
2100   127C             _while34_cond:
2101   127C FA 05 00      lea d, [bp + 5] ; $num
2102   127F 2A            mov b, [d]
2103   1280             ; START RELATIONAL
2104   1280 D7            push a
2105   1281 11            mov a, b
2106   1282 26 00 00      mov b, $0
2107   1285 B0            cmp a, b
2108   1286 FD 81         sgu ; > (unsigned)
2109   1288 E4            pop a
2110   1289             ; END RELATIONAL
2111   1289 C0 00 00      cmp b, 0
2112   128C C6 D6 12      je _while34_exit
2113   128F             _while34_block:
2114   128F             ;; digits[i] = '0' + (num % 10); 
2115   128F FA FC FF      lea d, [bp + -4] ; $digits
2116   1292 D7            push a
2117   1293 DA            push d
2118   1294 FA FA FF      lea d, [bp + -6] ; $i
2119   1297 2A            mov b, [d]
2120   1298 E7            pop d
2121   1299 5A            add d, b
2122   129A E4            pop a
2123   129B DA            push d
2124   129C 26 30 00      mov b, $30
2125   129F             ; START TERMS
2126   129F D7            push a
2127   12A0 11            mov a, b
2128   12A1 FA 05 00      lea d, [bp + 5] ; $num
2129   12A4 2A            mov b, [d]
2130   12A5             ; START FACTORS
2131   12A5 D7            push a
2132   12A6 11            mov a, b
2133   12A7 26 0A 00      mov b, $a
2134   12AA AE            div a, b ; 
2135   12AB 11            mov a, b
2136   12AC 27            mov b, a
2137   12AD E4            pop a
2138   12AE             ; END FACTORS
2139   12AE 56            add b, a
2140   12AF E4            pop a
2141   12B0             ; END TERMS
2142   12B0 E7            pop d
2143   12B1 FD 3E         mov [d], bl
2144   12B3             ;; num = num / 10; 
2145   12B3 FA 05 00      lea d, [bp + 5] ; $num
2146   12B6 DA            push d
2147   12B7 FA 05 00      lea d, [bp + 5] ; $num
2148   12BA 2A            mov b, [d]
2149   12BB             ; START FACTORS
2150   12BB D7            push a
2151   12BC 11            mov a, b
2152   12BD 26 0A 00      mov b, $a
2153   12C0 AE            div a, b
2154   12C1 27            mov b, a
2155   12C2 E4            pop a
2156   12C3             ; END FACTORS
2157   12C3 E7            pop d
2158   12C4 FD 43         mov [d], b
2159   12C6             ;; i++; 
2160   12C6 FA FA FF      lea d, [bp + -6] ; $i
2161   12C9 2A            mov b, [d]
2162   12CA D8            push b
2163   12CB FD 77         inc b
2164   12CD FA FA FF      lea d, [bp + -6] ; $i
2165   12D0 FD 43         mov [d], b
2166   12D2 E5            pop b
2167   12D3 0A 7C 12      jmp _while34_cond
2168   12D6             _while34_exit:
2169   12D6             ;; while (i > 0) { 
2170   12D6             _while35_cond:
2171   12D6 FA FA FF      lea d, [bp + -6] ; $i
2172   12D9 2A            mov b, [d]
2173   12DA             ; START RELATIONAL
2174   12DA D7            push a
2175   12DB 11            mov a, b
2176   12DC 26 00 00      mov b, $0
2177   12DF B0            cmp a, b
2178   12E0 FD 7F         sgt ; >
2179   12E2 E4            pop a
2180   12E3             ; END RELATIONAL
2181   12E3 C0 00 00      cmp b, 0
2182   12E6 C6 0F 13      je _while35_exit
2183   12E9             _while35_block:
2184   12E9             ;; i--; 
2185   12E9 FA FA FF      lea d, [bp + -6] ; $i
2186   12EC 2A            mov b, [d]
2187   12ED D8            push b
2188   12EE FD 7D         dec b
2189   12F0 FA FA FF      lea d, [bp + -6] ; $i
2190   12F3 FD 43         mov [d], b
2191   12F5 E5            pop b
2192   12F6             ;; putchar(digits[i]); 
2193   12F6 FA FC FF      lea d, [bp + -4] ; $digits
2194   12F9 D7            push a
2195   12FA DA            push d
2196   12FB FA FA FF      lea d, [bp + -6] ; $i
2197   12FE 2A            mov b, [d]
2198   12FF E7            pop d
2199   1300 5A            add d, b
2200   1301 E4            pop a
2201   1302 32            mov bl, [d]
2202   1303 A7 00         mov bh, 0
2203   1305 DD            push bl
2204   1306 07 1A 13      call putchar
2205   1309 51 01 00      add sp, 1
2206   130C 0A D6 12      jmp _while35_cond
2207   130F             _while35_exit:
2208   130F F9            leave
2209   1310 09            ret
2210   1311             
2211   1311             date:
2212   1311 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2213   1314             
2214   1314             ; --- BEGIN INLINE ASM BLOCK
2215   1314 19 00         mov al, 0 
2216   1316 05 07         syscall sys_datetime
2217   1318             ; --- END INLINE ASM BLOCK
2218   1318             
2219   1318 F9            leave
2220   1319 09            ret
2221   131A             
2222   131A             putchar:
2223   131A F8 00 00      enter 0 ; (push bp; mov bp, sp)
2224   131D             
2225   131D             ; --- BEGIN INLINE ASM BLOCK
2226   131D FA 05 00      lea d, [bp + 5] ; $c
2227   1320 1E            mov al, [d]
2228   1321 23            mov ah, al
2229   1322 07 86 14      call _putchar
2230   1325             ; --- END INLINE ASM BLOCK
2231   1325             
2232   1325 F9            leave
2233   1326 09            ret
2234   1327             
2235   1327             getchar:
2236   1327 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2237   132A             ; $c 
2238   132A 52 01 00      sub sp, 1
2239   132D             
2240   132D             ; --- BEGIN INLINE ASM BLOCK
2241   132D 07 7F 14      call getch
2242   1330 1A            mov al, ah
2243   1331 FA 00 00      lea d, [bp + 0] ; $c
2244   1334 3E            mov [d], al
2245   1335             ; --- END INLINE ASM BLOCK
2246   1335             
2247   1335             ;; return c; 
2248   1335 FA 00 00      lea d, [bp + 0] ; $c
2249   1338 32            mov bl, [d]
2250   1339 A7 00         mov bh, 0
2251   133B F9            leave
2252   133C 09            ret
2253   133D             
2254   133D             scann:
2255   133D F8 00 00      enter 0 ; (push bp; mov bp, sp)
2256   1340             ; $m 
2257   1340 52 02 00      sub sp, 2
2258   1343             
2259   1343             ; --- BEGIN INLINE ASM BLOCK
2260   1343 07 CA 16      call scan_u16d
2261   1346 FA FF FF      lea d, [bp + -1] ; $m
2262   1349 43            mov [d], a
2263   134A             ; --- END INLINE ASM BLOCK
2264   134A             
2265   134A             ;; return m; 
2266   134A FA FF FF      lea d, [bp + -1] ; $m
2267   134D 2A            mov b, [d]
2268   134E F9            leave
2269   134F 09            ret
2270   1350             
2271   1350             puts:
2272   1350 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2273   1353             
2274   1353             ; --- BEGIN INLINE ASM BLOCK
2275   1353 FA 05 00      lea d, [bp + 5] ; $s
2276   1356 15            mov a, [d]
2277   1357 3C            mov d, a
2278   1358 07 D0 15      call _puts
2279   135B 10 00 0A      mov a, $0A00
2280   135E 05 03         syscall sys_io
2281   1360             ; --- END INLINE ASM BLOCK
2282   1360             
2283   1360 F9            leave
2284   1361 09            ret
2285   1362             
2286   1362             print:
2287   1362 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2288   1365             
2289   1365             ; --- BEGIN INLINE ASM BLOCK
2290   1365 FA 05 00      lea d, [bp + 5] ; $s
2291   1368 FD 2A         mov d, [d]
2292   136A 07 D0 15      call _puts
2293   136D             ; --- END INLINE ASM BLOCK
2294   136D             
2295   136D F9            leave
2296   136E 09            ret
2297   136F             
2298   136F             getparam:
2299   136F F8 00 00      enter 0 ; (push bp; mov bp, sp)
2300   1372             ; $data 
2301   1372 52 01 00      sub sp, 1
2302   1375             
2303   1375             ; --- BEGIN INLINE ASM BLOCK
2304   1375 19 04         mov al, 4
2305   1377 FA 05 00      lea d, [bp + 5] ; $address
2306   137A FD 2A         mov d, [d]
2307   137C 05 0C         syscall sys_system
2308   137E FA 00 00      lea d, [bp + 0] ; $data
2309   1381 FD 3E         mov [d], bl
2310   1383             ; --- END INLINE ASM BLOCK
2311   1383             
2312   1383             ;; return data; 
2313   1383 FA 00 00      lea d, [bp + 0] ; $data
2314   1386 32            mov bl, [d]
2315   1387 A7 00         mov bh, 0
2316   1389 F9            leave
2317   138A 09            ret
2318   138B             
2319   138B             clear:
2320   138B F8 00 00      enter 0 ; (push bp; mov bp, sp)
2321   138E             ;; print("\033[2J\033[H"); 
2322   138E 26 72 17      mov b, __s2 ; "\033[2J\033[H"
2323   1391 FD AB         swp b
2324   1393 D8            push b
2325   1394 07 62 13      call print
2326   1397 51 02 00      add sp, 2
2327   139A F9            leave
2328   139B 09            ret
2329   139C             
2330   139C             include_stdio_asm:
2331   139C F8 00 00      enter 0 ; (push bp; mov bp, sp)
2332   139F             
2333   139F             ; --- BEGIN INLINE ASM BLOCK
2334   139F             .include "lib/asm/stdio.asm"
0001+  139F             ;-----------------------------------------------------------------------------
0002+  139F             ; stdio.s
0003+  139F             ;-----------------------------------------------------------------------------
0004+  139F             .include "lib/asm/string.asm"
0001++ 139F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 139F             ; string.s
0003++ 139F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 139F             
0005++ 139F             
0006++ 139F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 139F             ; _strrev
0008++ 139F             ; reverse a string
0009++ 139F             ; D = string address
0010++ 139F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 139F             ; 01234
0012++ 139F             _strrev:
0013++ 139F 4B          	pusha
0014++ 13A0 07 E6 13    	call _strlen	; length in C
0015++ 13A3 12          	mov a, c
0016++ 13A4 AF 01 00    	cmp a, 1
0017++ 13A7 D0 C1 13    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 13AA 7D          	dec a
0019++ 13AB FD 4E       	mov si, d	; beginning of string
0020++ 13AD FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 13AF 59          	add d, a	; end of string
0022++ 13B0 12          	mov a, c
0023++ 13B1 FD 9B       	shr a		; divide by 2
0024++ 13B3 39          	mov c, a	; C now counts the steps
0025++ 13B4             _strrev_L0:
0026++ 13B4 32          	mov bl, [d]	; save load right-side char into BL
0027++ 13B5 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 13B6 3E          	mov [d], al	; store left char into right side
0029++ 13B7 1B          	mov al, bl
0030++ 13B8 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 13B9 7E          	dec c
0032++ 13BA 7F          	dec d
0033++ 13BB C2 00 00    	cmp c, 0
0034++ 13BE C7 B4 13    	jne _strrev_L0
0035++ 13C1             _strrev_end:
0036++ 13C1 4C          	popa
0037++ 13C2 09          	ret
0038++ 13C3             	
0039++ 13C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 13C3             ; _strchr
0041++ 13C3             ; search string in D for char in AL
0042++ 13C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 13C3             _strchr:
0044++ 13C3             _strchr_L0:
0045++ 13C3 32          	mov bl, [d]
0046++ 13C4 C1 00       	cmp bl, 0
0047++ 13C6 C6 D1 13    	je _strchr_end
0048++ 13C9 BA          	cmp al, bl
0049++ 13CA C6 D1 13    	je _strchr_end
0050++ 13CD 79          	inc d
0051++ 13CE 0A C3 13    	jmp _strchr_L0
0052++ 13D1             _strchr_end:
0053++ 13D1 1B          	mov al, bl
0054++ 13D2 09          	ret
0055++ 13D3             
0056++ 13D3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 13D3             ; _strstr
0058++ 13D3             ; find sub-string
0059++ 13D3             ; str1 in SI
0060++ 13D3             ; str2 in DI
0061++ 13D3             ; SI points to end of source string
0062++ 13D3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 13D3             _strstr:
0064++ 13D3 DB          	push al
0065++ 13D4 DA          	push d
0066++ 13D5 E3          	push di
0067++ 13D6             _strstr_loop:
0068++ 13D6 F3          	cmpsb					; compare a byte of the strings
0069++ 13D7 C7 E2 13    	jne _strstr_ret
0070++ 13DA FC 00 00    	lea d, [di + 0]
0071++ 13DD BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 13DF C7 D6 13    	jne _strstr_loop				; equal chars but not at end
0073++ 13E2             _strstr_ret:
0074++ 13E2 F0          	pop di
0075++ 13E3 E7          	pop d
0076++ 13E4 E8          	pop al
0077++ 13E5 09          	ret
0078++ 13E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 13E6             ; length of null terminated string
0080++ 13E6             ; result in C
0081++ 13E6             ; pointer in D
0082++ 13E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 13E6             _strlen:
0084++ 13E6 DA          	push d
0085++ 13E7 38 00 00    	mov c, 0
0086++ 13EA             _strlen_L1:
0087++ 13EA BD 00       	cmp byte [d], 0
0088++ 13EC C6 F4 13    	je _strlen_ret
0089++ 13EF 79          	inc d
0090++ 13F0 78          	inc c
0091++ 13F1 0A EA 13    	jmp _strlen_L1
0092++ 13F4             _strlen_ret:
0093++ 13F4 E7          	pop d
0094++ 13F5 09          	ret
0095++ 13F6             
0096++ 13F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 13F6             ; STRCMP
0098++ 13F6             ; compare two strings
0099++ 13F6             ; str1 in SI
0100++ 13F6             ; str2 in DI
0101++ 13F6             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 13F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 13F6             _strcmp:
0104++ 13F6 DB          	push al
0105++ 13F7 DA          	push d
0106++ 13F8 E3          	push di
0107++ 13F9 E2          	push si
0108++ 13FA             _strcmp_loop:
0109++ 13FA F3          	cmpsb					; compare a byte of the strings
0110++ 13FB C7 06 14    	jne _strcmp_ret
0111++ 13FE FB FF FF    	lea d, [si +- 1]
0112++ 1401 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1403 C7 FA 13    	jne _strcmp_loop				; equal chars but not at end
0114++ 1406             _strcmp_ret:
0115++ 1406 EF          	pop si
0116++ 1407 F0          	pop di
0117++ 1408 E7          	pop d
0118++ 1409 E8          	pop al
0119++ 140A 09          	ret
0120++ 140B             
0121++ 140B             
0122++ 140B             ; STRCPY
0123++ 140B             ; copy null terminated string from SI to DI
0124++ 140B             ; source in SI
0125++ 140B             ; destination in DI
0126++ 140B             _strcpy:
0127++ 140B E2          	push si
0128++ 140C E3          	push di
0129++ 140D DB          	push al
0130++ 140E             _strcpy_L1:
0131++ 140E F6          	lodsb
0132++ 140F F7          	stosb
0133++ 1410 B9 00       	cmp al, 0
0134++ 1412 C7 0E 14    	jne _strcpy_L1
0135++ 1415             _strcpy_end:
0136++ 1415 E8          	pop al
0137++ 1416 F0          	pop di
0138++ 1417 EF          	pop si
0139++ 1418 09          	ret
0140++ 1419             
0141++ 1419             ; STRCAT
0142++ 1419             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 1419             ; source in SI
0144++ 1419             ; destination in DI
0145++ 1419             _strcat:
0146++ 1419 E2          	push si
0147++ 141A E3          	push di
0148++ 141B D7          	push a
0149++ 141C DA          	push d
0150++ 141D 50          	mov a, di
0151++ 141E 3C          	mov d, a
0152++ 141F             _strcat_goto_end_L1:
0153++ 141F BD 00       	cmp byte[d], 0
0154++ 1421 C6 28 14    	je _strcat_start
0155++ 1424 79          	inc d
0156++ 1425 0A 1F 14    	jmp _strcat_goto_end_L1
0157++ 1428             _strcat_start:
0158++ 1428 FD 50       	mov di, d
0159++ 142A             _strcat_L1:
0160++ 142A F6          	lodsb
0161++ 142B F7          	stosb
0162++ 142C B9 00       	cmp al, 0
0163++ 142E C7 2A 14    	jne _strcat_L1
0164++ 1431             _strcat_end:
0165++ 1431 E7          	pop d
0166++ 1432 E4          	pop a
0167++ 1433 F0          	pop di
0168++ 1434 EF          	pop si
0169++ 1435 09          	ret
0170++ 1436             
0171++ 1436             
0005+  1436             
0006+  1436             ;-----------------------------------------------------------------------------
0007+  1436             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0008+  1436             ; ASCII in BL
0009+  1436             ; result in AL
0010+  1436             ; ascii for F = 0100 0110
0011+  1436             ; ascii for 9 = 0011 1001
0012+  1436             ;-----------------------------------------------------------------------------
0013+  1436             hex_ascii_encode:
0014+  1436 1B            mov al, bl
0015+  1437 93 40         test al, $40        ; test if letter or number
0016+  1439 C7 3F 14      jnz hex_letter
0017+  143C 87 0F         and al, $0F        ; get number
0018+  143E 09            ret
0019+  143F             hex_letter:
0020+  143F 87 0F         and al, $0F        ; get letter
0021+  1441 6A 09         add al, 9
0022+  1443 09            ret
0023+  1444             
0024+  1444             ;-----------------------------------------------------------------------------
0025+  1444             ; ATOI
0026+  1444             ; 2 letter hex string in B
0027+  1444             ; 8bit integer returned in AL
0028+  1444             ;-----------------------------------------------------------------------------
0029+  1444             _atoi:
0030+  1444 D8            push b
0031+  1445 07 36 14      call hex_ascii_encode      ; convert BL to 4bit code in AL
0032+  1448 30            mov bl, bh
0033+  1449 DB            push al          ; save a
0034+  144A 07 36 14      call hex_ascii_encode
0035+  144D EA            pop bl  
0036+  144E FD 9E 04      shl al, 4
0037+  1451 8C            or al, bl
0038+  1452 E5            pop b
0039+  1453 09            ret  
0040+  1454             
0041+  1454             
0042+  1454             ;-----------------------------------------------------------------------------
0043+  1454             ; ITOA
0044+  1454             ; 8bit value in BL
0045+  1454             ; 2 byte ASCII result in A
0046+  1454             ;-----------------------------------------------------------------------------
0047+  1454             _itoa:
0048+  1454 DA            push d
0049+  1455 D8            push b
0050+  1456 A7 00         mov bh, 0
0051+  1458 FD A4 04      shr bl, 4  
0052+  145B 74            mov d, b
0053+  145C 1F 04 17      mov al, [d + s_hex_digits]
0054+  145F 23            mov ah, al
0055+  1460               
0056+  1460 E5            pop b
0057+  1461 D8            push b
0058+  1462 A7 00         mov bh, 0
0059+  1464 FD 87 0F      and bl, $0F
0060+  1467 74            mov d, b
0061+  1468 1F 04 17      mov al, [d + s_hex_digits]
0062+  146B E5            pop b
0063+  146C E7            pop d
0064+  146D 09            ret
0065+  146E             
0066+  146E             ;-----------------------------------------------------------------------------
0067+  146E             ; HEX STRING TO BINARY
0068+  146E             ; di = destination address
0069+  146E             ; si = source
0070+  146E             ;-----------------------------------------------------------------------------
0071+  146E             _hex_to_int:
0072+  146E             _hex_to_int_L1:
0073+  146E F6            lodsb          ; load from [SI] to AL
0074+  146F B9 00         cmp al, 0        ; check if ASCII 0
0075+  1471 C6 7E 14      jz _hex_to_int_ret
0076+  1474 36            mov bh, al
0077+  1475 F6            lodsb
0078+  1476 2F            mov bl, al
0079+  1477 07 44 14      call _atoi        ; convert ASCII byte in B to int (to AL)
0080+  147A F7            stosb          ; store AL to [DI]
0081+  147B 0A 6E 14      jmp _hex_to_int_L1
0082+  147E             _hex_to_int_ret:
0083+  147E 09            ret    
0084+  147F             
0085+  147F             ;-----------------------------------------------------------------------------
0086+  147F             ; GETCHAR
0087+  147F             ; char in ah
0088+  147F             ;-----------------------------------------------------------------------------
0089+  147F             getch:
0090+  147F DB            push al
0091+  1480             getch_retry:
0092+  1480 19 01         mov al, 1
0093+  1482 05 03         syscall sys_io      ; receive in AH
0094+  1484 E8            pop al
0095+  1485 09            ret
0096+  1486             
0097+  1486             ;-----------------------------------------------------------------------------
0098+  1486             ; PUTCHAR
0099+  1486             ; char in ah
0100+  1486             ;-----------------------------------------------------------------------------
0101+  1486             _putchar:
0102+  1486 D7            push a
0103+  1487 19 00         mov al, 0
0104+  1489 05 03         syscall sys_io      ; char in AH
0105+  148B E4            pop a
0106+  148C 09            ret
0107+  148D             
0108+  148D             ;-----------------------------------------------------------------------------
0109+  148D             ;; INPUT A STRING
0110+  148D             ;; terminates with null
0111+  148D             ;; pointer in D
0112+  148D             ;-----------------------------------------------------------------------------
0113+  148D             _gets:
0114+  148D D7            push a
0115+  148E DA            push d
0116+  148F             _gets_loop:
0117+  148F 19 01         mov al, 1
0118+  1491 05 03         syscall sys_io      ; receive in AH
0119+  1493 B9 00         cmp al, 0        ; check error code (AL)
0120+  1495 C6 8F 14      je _gets_loop      ; if no char received, retry
0121+  1498             
0122+  1498 76 1B         cmp ah, 27
0123+  149A C6 BB 14      je _gets_ansi_esc
0124+  149D 76 0A         cmp ah, $0A        ; LF
0125+  149F C6 26 15      je _gets_end
0126+  14A2 76 0D         cmp ah, $0D        ; CR
0127+  14A4 C6 26 15      je _gets_end
0128+  14A7 76 5C         cmp ah, $5C        ; '\\'
0129+  14A9 C6 E7 14      je _gets_escape
0130+  14AC               
0131+  14AC 76 08         cmp ah, $08      ; check for backspace
0132+  14AE C6 B7 14      je _gets_backspace
0133+  14B1             
0134+  14B1 1A            mov al, ah
0135+  14B2 3E            mov [d], al
0136+  14B3 79            inc d
0137+  14B4 0A 8F 14      jmp _gets_loop
0138+  14B7             _gets_backspace:
0139+  14B7 7F            dec d
0140+  14B8 0A 8F 14      jmp _gets_loop
0141+  14BB             _gets_ansi_esc:
0142+  14BB 19 01         mov al, 1
0143+  14BD 05 03         syscall sys_io        ; receive in AH without echo
0144+  14BF B9 00         cmp al, 0          ; check error code (AL)
0145+  14C1 C6 BB 14      je _gets_ansi_esc    ; if no char received, retry
0146+  14C4 76 5B         cmp ah, '['
0147+  14C6 C7 8F 14      jne _gets_loop
0148+  14C9             _gets_ansi_esc_2:
0149+  14C9 19 01         mov al, 1
0150+  14CB 05 03         syscall sys_io          ; receive in AH without echo
0151+  14CD B9 00         cmp al, 0            ; check error code (AL)
0152+  14CF C6 C9 14      je _gets_ansi_esc_2  ; if no char received, retry
0153+  14D2 76 44         cmp ah, 'D'
0154+  14D4 C6 DF 14      je _gets_left_arrow
0155+  14D7 76 43         cmp ah, 'C'
0156+  14D9 C6 E3 14      je _gets_right_arrow
0157+  14DC 0A 8F 14      jmp _gets_loop
0158+  14DF             _gets_left_arrow:
0159+  14DF 7F            dec d
0160+  14E0 0A 8F 14      jmp _gets_loop
0161+  14E3             _gets_right_arrow:
0162+  14E3 79            inc d
0163+  14E4 0A 8F 14      jmp _gets_loop
0164+  14E7             _gets_escape:
0165+  14E7 19 01         mov al, 1
0166+  14E9 05 03         syscall sys_io      ; receive in AH
0167+  14EB B9 00         cmp al, 0        ; check error code (AL)
0168+  14ED C6 E7 14      je _gets_escape      ; if no char received, retry
0169+  14F0 76 6E         cmp ah, 'n'
0170+  14F2 C6 11 15      je _gets_LF
0171+  14F5 76 72         cmp ah, 'r'
0172+  14F7 C6 18 15      je _gets_CR
0173+  14FA 76 30         cmp ah, '0'
0174+  14FC C6 1F 15      je _gets_NULL
0175+  14FF 76 5C         cmp ah, $5C  ; '\'
0176+  1501 C6 0A 15      je _gets_slash
0177+  1504 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0178+  1505 3E            mov [d], al
0179+  1506 79            inc d
0180+  1507 0A 8F 14      jmp _gets_loop
0181+  150A             _gets_slash:
0182+  150A 19 5C         mov al, $5C
0183+  150C 3E            mov [d], al
0184+  150D 79            inc d
0185+  150E 0A 8F 14      jmp _gets_loop
0186+  1511             _gets_LF:
0187+  1511 19 0A         mov al, $0A
0188+  1513 3E            mov [d], al
0189+  1514 79            inc d
0190+  1515 0A 8F 14      jmp _gets_loop
0191+  1518             _gets_CR:
0192+  1518 19 0D         mov al, $0D
0193+  151A 3E            mov [d], al
0194+  151B 79            inc d
0195+  151C 0A 8F 14      jmp _gets_loop
0196+  151F             _gets_NULL:
0197+  151F 19 00         mov al, $00
0198+  1521 3E            mov [d], al
0199+  1522 79            inc d
0200+  1523 0A 8F 14      jmp _gets_loop
0201+  1526             _gets_end:
0202+  1526 19 00         mov al, 0
0203+  1528 3E            mov [d], al        ; terminate string
0204+  1529 E7            pop d
0205+  152A E4            pop a
0206+  152B 09            ret
0207+  152C             
0208+  152C             ;-----------------------------------------------------------------------------
0209+  152C             ;; INPUT TEXT
0210+  152C             ;; terminated with CTRL+D
0211+  152C             ;; pointer in D
0212+  152C             ;-----------------------------------------------------------------------------
0213+  152C             _gettxt:
0214+  152C D7            push a
0215+  152D DA            push d
0216+  152E             _gettxt_loop:
0217+  152E 19 01         mov al, 1
0218+  1530 05 03         syscall sys_io      ; receive in AH
0219+  1532 B9 00         cmp al, 0        ; check error code (AL)
0220+  1534 C6 2E 15      je _gettxt_loop    ; if no char received, retry
0221+  1537 76 04         cmp ah, 4      ; EOT
0222+  1539 C6 77 15      je _gettxt_end
0223+  153C 76 08         cmp ah, $08      ; check for backspace
0224+  153E C6 73 15      je _gettxt_backspace
0225+  1541 76 5C         cmp ah, $5C        ; '\'
0226+  1543 C6 4C 15      je _gettxt_escape
0227+  1546 1A            mov al, ah
0228+  1547 3E            mov [d], al
0229+  1548 79            inc d
0230+  1549 0A 2E 15      jmp _gettxt_loop
0231+  154C             _gettxt_escape:
0232+  154C 19 01         mov al, 1
0233+  154E 05 03         syscall sys_io      ; receive in AH
0234+  1550 B9 00         cmp al, 0        ; check error code (AL)
0235+  1552 C6 4C 15      je _gettxt_escape    ; if no char received, retry
0236+  1555 76 6E         cmp ah, 'n'
0237+  1557 C6 65 15      je _gettxt_LF
0238+  155A 76 72         cmp ah, 'r'
0239+  155C C6 6C 15      je _gettxt_CR
0240+  155F 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0241+  1560 3E            mov [d], al
0242+  1561 79            inc d
0243+  1562 0A 2E 15      jmp _gettxt_loop
0244+  1565             _gettxt_LF:
0245+  1565 19 0A         mov al, $0A
0246+  1567 3E            mov [d], al
0247+  1568 79            inc d
0248+  1569 0A 2E 15      jmp _gettxt_loop
0249+  156C             _gettxt_CR:
0250+  156C 19 0D         mov al, $0D
0251+  156E 3E            mov [d], al
0252+  156F 79            inc d
0253+  1570 0A 2E 15      jmp _gettxt_loop
0254+  1573             _gettxt_backspace:
0255+  1573 7F            dec d
0256+  1574 0A 2E 15      jmp _gettxt_loop
0257+  1577             _gettxt_end:
0258+  1577 19 00         mov al, 0
0259+  1579 3E            mov [d], al        ; terminate string
0260+  157A E7            pop d
0261+  157B E4            pop a
0262+  157C 09            ret
0263+  157D             
0264+  157D             ;-----------------------------------------------------------------------------
0265+  157D             ; PRINT NEW LINE
0266+  157D             ;-----------------------------------------------------------------------------
0267+  157D             printnl:
0268+  157D D7            push a
0269+  157E 10 00 0A      mov a, $0A00
0270+  1581 05 03         syscall sys_io
0271+  1583 10 00 0D      mov a, $0D00
0272+  1586 05 03         syscall sys_io
0273+  1588 E4            pop a
0274+  1589 09            ret
0275+  158A             
0276+  158A             ;-----------------------------------------------------------------------------
0277+  158A             ; _strtoint
0278+  158A             ; 4 digit hex string number in d
0279+  158A             ; integer returned in A
0280+  158A             ;-----------------------------------------------------------------------------
0281+  158A             _strtointx:
0282+  158A D8            push b
0283+  158B 32            mov bl, [d]
0284+  158C 37            mov bh, bl
0285+  158D 33 01 00      mov bl, [d + 1]
0286+  1590 07 44 14      call _atoi        ; convert to int in AL
0287+  1593 23            mov ah, al        ; move to AH
0288+  1594 33 02 00      mov bl, [d + 2]
0289+  1597 37            mov bh, bl
0290+  1598 33 03 00      mov bl, [d + 3]
0291+  159B 07 44 14      call _atoi        ; convert to int in AL
0292+  159E E5            pop b
0293+  159F 09            ret
0294+  15A0             
0295+  15A0             ;-----------------------------------------------------------------------------
0296+  15A0             ; _strtoint
0297+  15A0             ; 5 digit base10 string number in d
0298+  15A0             ; integer returned in A
0299+  15A0             ;-----------------------------------------------------------------------------
0300+  15A0             _strtoint:
0301+  15A0 E2            push si
0302+  15A1 D8            push b
0303+  15A2 D9            push c
0304+  15A3 DA            push d
0305+  15A4 07 E6 13      call _strlen      ; get string length in C
0306+  15A7 7E            dec c
0307+  15A8 FD 4E         mov si, d
0308+  15AA 12            mov a, c
0309+  15AB FD 99         shl a
0310+  15AD 3B 1C 17      mov d, table_power
0311+  15B0 59            add d, a
0312+  15B1 38 00 00      mov c, 0
0313+  15B4             _strtoint_L0:
0314+  15B4 F6            lodsb      ; load ASCII to al
0315+  15B5 B9 00         cmp al, 0
0316+  15B7 C6 CA 15      je _strtoint_end
0317+  15BA 6F 30         sub al, $30    ; make into integer
0318+  15BC 22 00         mov ah, 0
0319+  15BE 2A            mov b, [d]
0320+  15BF AC            mul a, b      ; result in B since it fits in 16bits
0321+  15C0 11            mov a, b
0322+  15C1 28            mov b, c
0323+  15C2 54            add a, b
0324+  15C3 39            mov c, a
0325+  15C4 63 02 00      sub d, 2
0326+  15C7 0A B4 15      jmp _strtoint_L0
0327+  15CA             _strtoint_end:
0328+  15CA 12            mov a, c
0329+  15CB E7            pop d
0330+  15CC E6            pop c
0331+  15CD E5            pop b
0332+  15CE EF            pop si
0333+  15CF 09            ret
0334+  15D0             
0335+  15D0             ;-----------------------------------------------------------------------------
0336+  15D0             ; PRINT NULL TERMINATED STRING
0337+  15D0             ; pointer in D
0338+  15D0             ;-----------------------------------------------------------------------------
0339+  15D0             _puts:
0340+  15D0 D7            push a
0341+  15D1 DA            push d
0342+  15D2             _puts_L1:
0343+  15D2 1E            mov al, [d]
0344+  15D3 B9 00         cmp al, 0
0345+  15D5 C6 E1 15      jz _puts_END
0346+  15D8 23            mov ah, al
0347+  15D9 19 00         mov al, 0
0348+  15DB 05 03         syscall sys_io
0349+  15DD 79            inc d
0350+  15DE 0A D2 15      jmp _puts_L1
0351+  15E1             _puts_END:
0352+  15E1 E7            pop d
0353+  15E2 E4            pop a
0354+  15E3 09            ret
0355+  15E4             
0356+  15E4             ;-----------------------------------------------------------------------------
0357+  15E4             ; PRINT N SIZE STRING
0358+  15E4             ; pointer in D
0359+  15E4             ; size in C
0360+  15E4             ;-----------------------------------------------------------------------------
0361+  15E4             _putsn:
0362+  15E4 DB            push al
0363+  15E5 DA            push d
0364+  15E6 D9            push c
0365+  15E7             _putsn_L0:
0366+  15E7 1E            mov al, [d]
0367+  15E8 23            mov ah, al
0368+  15E9 19 00         mov al, 0
0369+  15EB 05 03         syscall sys_io
0370+  15ED 79            inc d
0371+  15EE 7E            dec c  
0372+  15EF C2 00 00      cmp c, 0
0373+  15F2 C7 E7 15      jne _putsn_L0
0374+  15F5             _putsn_end:
0375+  15F5 E6            pop c
0376+  15F6 E7            pop d
0377+  15F7 E8            pop al
0378+  15F8 09            ret
0379+  15F9             
0380+  15F9             ;-----------------------------------------------------------------------------
0381+  15F9             ; print 16bit decimal number
0382+  15F9             ; input number in A
0383+  15F9             ;-----------------------------------------------------------------------------
0384+  15F9             print_u16d:
0385+  15F9 D7            push a
0386+  15FA D8            push b
0387+  15FB 26 10 27      mov b, 10000
0388+  15FE AE            div a, b      ; get 10000's coeff.
0389+  15FF 07 21 16      call print_number
0390+  1602 11            mov a, b
0391+  1603 26 E8 03      mov b, 1000
0392+  1606 AE            div a, b      ; get 1000's coeff.
0393+  1607 07 21 16      call print_number
0394+  160A 11            mov a, b
0395+  160B 26 64 00      mov b, 100
0396+  160E AE            div a, b
0397+  160F 07 21 16      call print_number
0398+  1612 11            mov a, b
0399+  1613 26 0A 00      mov b, 10
0400+  1616 AE            div a, b
0401+  1617 07 21 16      call print_number
0402+  161A 1B            mov al, bl      ; 1's coeff in bl
0403+  161B 07 21 16      call print_number
0404+  161E E5            pop b
0405+  161F E4            pop a
0406+  1620 09            ret
0407+  1621             
0408+  1621             ;-----------------------------------------------------------------------------
0409+  1621             ; print AL
0410+  1621             ;-----------------------------------------------------------------------------
0411+  1621             print_number:
0412+  1621 6A 30         add al, $30
0413+  1623 23            mov ah, al
0414+  1624 07 86 14      call _putchar
0415+  1627 09            ret
0416+  1628             
0417+  1628             ;-----------------------------------------------------------------------------
0418+  1628             ; PRINT 16BIT HEX INTEGER
0419+  1628             ; integer value in reg B
0420+  1628             ;-----------------------------------------------------------------------------
0421+  1628             print_u16x:
0422+  1628 D7            push a
0423+  1629 D8            push b
0424+  162A DD            push bl
0425+  162B 30            mov bl, bh
0426+  162C 07 54 14      call _itoa        ; convert bh to char in A
0427+  162F 2F            mov bl, al        ; save al
0428+  1630 19 00         mov al, 0
0429+  1632 05 03         syscall sys_io        ; display AH
0430+  1634 24            mov ah, bl        ; retrieve al
0431+  1635 19 00         mov al, 0
0432+  1637 05 03         syscall sys_io        ; display AL
0433+  1639             
0434+  1639 EA            pop bl
0435+  163A 07 54 14      call _itoa        ; convert bh to char in A
0436+  163D 2F            mov bl, al        ; save al
0437+  163E 19 00         mov al, 0
0438+  1640 05 03         syscall sys_io        ; display AH
0439+  1642 24            mov ah, bl        ; retrieve al
0440+  1643 19 00         mov al, 0
0441+  1645 05 03         syscall sys_io        ; display AL
0442+  1647             
0443+  1647 E5            pop b
0444+  1648 E4            pop a
0445+  1649 09            ret
0446+  164A             
0447+  164A             ;-----------------------------------------------------------------------------
0448+  164A             ; INPUT 16BIT HEX INTEGER
0449+  164A             ; read 16bit integer into A
0450+  164A             ;-----------------------------------------------------------------------------
0451+  164A             scan_u16x:
0452+  164A F8 10 00      enter 16
0453+  164D D8            push b
0454+  164E DA            push d
0455+  164F             
0456+  164F FA F1 FF      lea d, [bp + -15]
0457+  1652 07 8D 14      call _gets        ; get number
0458+  1655             
0459+  1655 32            mov bl, [d]
0460+  1656 37            mov bh, bl
0461+  1657 33 01 00      mov bl, [d + 1]
0462+  165A 07 44 14      call _atoi        ; convert to int in AL
0463+  165D 23            mov ah, al        ; move to AH
0464+  165E             
0465+  165E 33 02 00      mov bl, [d + 2]
0466+  1661 37            mov bh, bl
0467+  1662 33 03 00      mov bl, [d + 3]
0468+  1665 07 44 14      call _atoi        ; convert to int in AL
0469+  1668             
0470+  1668 E7            pop d
0471+  1669 E5            pop b
0472+  166A F9            leave
0473+  166B 09            ret
0474+  166C             
0475+  166C             ;-----------------------------------------------------------------------------
0476+  166C             ; PRINT 8bit HEX INTEGER
0477+  166C             ; integer value in reg bl
0478+  166C             ;-----------------------------------------------------------------------------
0479+  166C             print_u8x:
0480+  166C D7            push a
0481+  166D DD            push bl
0482+  166E             
0483+  166E 07 54 14      call _itoa        ; convert bl to char in A
0484+  1671 2F            mov bl, al        ; save al
0485+  1672 19 00         mov al, 0
0486+  1674 05 03         syscall sys_io        ; display AH
0487+  1676 24            mov ah, bl        ; retrieve al
0488+  1677 19 00         mov al, 0
0489+  1679 05 03         syscall sys_io        ; display AL
0490+  167B             
0491+  167B EA            pop bl
0492+  167C E4            pop a
0493+  167D 09            ret
0494+  167E             
0495+  167E             ;-----------------------------------------------------------------------------
0496+  167E             ; print 8bit decimal unsigned number
0497+  167E             ; input number in AL
0498+  167E             ;-----------------------------------------------------------------------------
0499+  167E             print_u8d:
0500+  167E D7            push a
0501+  167F D8            push b
0502+  1680             
0503+  1680 22 00         mov ah, 0
0504+  1682 26 64 00      mov b, 100
0505+  1685 AE            div a, b
0506+  1686 D8            push b      ; save remainder
0507+  1687 B9 00         cmp al, 0
0508+  1689 C6 93 16      je skip100
0509+  168C 6A 30         add al, $30
0510+  168E 23            mov ah, al
0511+  168F 19 00         mov al, 0
0512+  1691 05 03         syscall sys_io  ; print coeff
0513+  1693             skip100:
0514+  1693 E4            pop a
0515+  1694 22 00         mov ah, 0
0516+  1696 26 0A 00      mov b, 10
0517+  1699 AE            div a, b
0518+  169A D8            push b      ; save remainder
0519+  169B B9 00         cmp al, 0
0520+  169D C6 A7 16      je skip10
0521+  16A0 6A 30         add al, $30
0522+  16A2 23            mov ah, al
0523+  16A3 19 00         mov al, 0
0524+  16A5 05 03         syscall sys_io  ; print coeff
0525+  16A7             skip10:
0526+  16A7 E4            pop a
0527+  16A8 1B            mov al, bl
0528+  16A9 6A 30         add al, $30
0529+  16AB 23            mov ah, al
0530+  16AC 19 00         mov al, 0
0531+  16AE 05 03         syscall sys_io  ; print coeff
0532+  16B0 E5            pop b
0533+  16B1 E4            pop a
0534+  16B2 09            ret
0535+  16B3             
0536+  16B3             ;-----------------------------------------------------------------------------
0537+  16B3             ; INPUT 8BIT HEX INTEGER
0538+  16B3             ; read 8bit integer into AL
0539+  16B3             ;-----------------------------------------------------------------------------
0540+  16B3             scan_u8x:
0541+  16B3 F8 04 00      enter 4
0542+  16B6 D8            push b
0543+  16B7 DA            push d
0544+  16B8             
0545+  16B8 FA FD FF      lea d, [bp + -3]
0546+  16BB 07 8D 14      call _gets        ; get number
0547+  16BE             
0548+  16BE 32            mov bl, [d]
0549+  16BF 37            mov bh, bl
0550+  16C0 33 01 00      mov bl, [d + 1]
0551+  16C3 07 44 14      call _atoi        ; convert to int in AL
0552+  16C6             
0553+  16C6 E7            pop d
0554+  16C7 E5            pop b
0555+  16C8 F9            leave
0556+  16C9 09            ret
0557+  16CA             
0558+  16CA             ;-----------------------------------------------------------------------------
0559+  16CA             ; input decimal number
0560+  16CA             ; result in A
0561+  16CA             ; 655'\0'
0562+  16CA             ; low--------high
0563+  16CA             ;-----------------------------------------------------------------------------
0564+  16CA             scan_u16d:
0565+  16CA F8 08 00      enter 8
0566+  16CD E2            push si
0567+  16CE D8            push b
0568+  16CF D9            push c
0569+  16D0 DA            push d
0570+  16D1 FA F9 FF      lea d, [bp +- 7]
0571+  16D4 07 8D 14      call _gets
0572+  16D7 07 E6 13      call _strlen      ; get string length in C
0573+  16DA 7E            dec c
0574+  16DB FD 4E         mov si, d
0575+  16DD 12            mov a, c
0576+  16DE FD 99         shl a
0577+  16E0 3B 1C 17      mov d, table_power
0578+  16E3 59            add d, a
0579+  16E4 38 00 00      mov c, 0
0580+  16E7             mul_loop:
0581+  16E7 F6            lodsb      ; load ASCII to al
0582+  16E8 B9 00         cmp al, 0
0583+  16EA C6 FD 16      je mul_exit
0584+  16ED 6F 30         sub al, $30    ; make into integer
0585+  16EF 22 00         mov ah, 0
0586+  16F1 2A            mov b, [d]
0587+  16F2 AC            mul a, b      ; result in B since it fits in 16bits
0588+  16F3 11            mov a, b
0589+  16F4 28            mov b, c
0590+  16F5 54            add a, b
0591+  16F6 39            mov c, a
0592+  16F7 63 02 00      sub d, 2
0593+  16FA 0A E7 16      jmp mul_loop
0594+  16FD             mul_exit:
0595+  16FD 12            mov a, c
0596+  16FE E7            pop d
0597+  16FF E6            pop c
0598+  1700 E5            pop b
0599+  1701 EF            pop si
0600+  1702 F9            leave
0601+  1703 09            ret
0602+  1704             
0603+  1704 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0603+  1708 34 35 36 37 
0603+  170C 38 39 41 42 
0603+  1710 43 44 45 46 
0604+  1714 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0604+  1718 1B 5B 48 00 
0605+  171C             
0606+  171C             table_power:
0607+  171C 01 00         .dw 1
0608+  171E 0A 00         .dw 10
0609+  1720 64 00         .dw 100
0610+  1722 E8 03         .dw 1000
0611+  1724 10 27         .dw 100002335   1726             ; --- END INLINE ASM BLOCK
2336   1726             
2337   1726 F9            leave
2338   1727 09            ret
2339   1728             ; --- END TEXT BLOCK
2340   1728             
2341   1728             ; --- BEGIN DATA BLOCK
2342   1728 00 00 00 00 _il0: .fill 4, 0
2343   172C 00 00 00 00 _il1: .fill 4, 0
2344   1730 00 00       _i0: .fill 2, 0
2345   1732 00 00       _i1: .fill 2, 0
2346   1734 00          _c0: .fill 1, 0
2347   1735 00          _c1: .fill 1, 0
2348   1736 55 6E 65 78 __s0: .db "Unexpected format in printf.", 0
2348   173A 70 65 63 74 
2348   173E 65 64 20 66 
2348   1742 6F 72 6D 61 
2348   1746 74 20 69 6E 
2348   174A 20 70 72 69 
2348   174E 6E 74 66 2E 
2348   1752 00 
2349   1753 45 72 72 6F __s1: .db "Error: Unknown argument type.\n", 0
2349   1757 72 3A 20 55 
2349   175B 6E 6B 6E 6F 
2349   175F 77 6E 20 61 
2349   1763 72 67 75 6D 
2349   1767 65 6E 74 20 
2349   176B 74 79 70 65 
2349   176F 2E 0A 00 
2350   1772 1B 5B 32 4A __s2: .db "\033[2J\033[H", 0
2350   1776 1B 5B 48 00 
2351   177A             
2352   177A 7C 17       _heap_top: .dw _heap
2353   177C 00          _heap: .db 0
2354   177D             ; --- END DATA BLOCK
2355   177D             
2356   177D             .end
tasm: Number of errors = 0
