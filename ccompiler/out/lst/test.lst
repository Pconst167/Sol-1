0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT SEGMENT
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; 1L || 'A'; 
0011   0408 FD 2E 01 00   mov32 cb, $00000001
0011   040C 00 00 
0012   040E             ; --- START LOGICAL OR
0013   040E D7            push a
0014   040F FD D8         push g
0015   0411 11            mov a, b
0016   0412 FD 7A         mov g, c
0017   0414 FD 2E 41 00   mov32 cb, $00000041
0017   0418 00 00 
0018   041A FD B2         sor32 ga, cb
0019   041C FD F1         pop g
0020   041E E4            pop a
0021   041F             ; --- END LOGICAL OR
0022   041F 05 0B         syscall sys_terminate_proc
0023   0421             
0024   0421             strcpy:
0025   0421 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0026   0424             ; char *psrc; 
0027   0424 52 02 00      sub sp, 2
0028   0427             ; char *pdest; 
0029   0427 52 02 00      sub sp, 2
0030   042A             ; psrc = src; 
0031   042A FA FF FF      lea d, [bp + -1] ; $psrc
0032   042D DA            push d
0033   042E FA 07 00      lea d, [bp + 7] ; $src
0034   0431 2A            mov b, [d]
0035   0432 38 00 00      mov c, 0
0036   0435 E7            pop d
0037   0436 FD 43         mov [d], b
0038   0438             ; pdest = dest; 
0039   0438 FA FD FF      lea d, [bp + -3] ; $pdest
0040   043B DA            push d
0041   043C FA 05 00      lea d, [bp + 5] ; $dest
0042   043F 2A            mov b, [d]
0043   0440 38 00 00      mov c, 0
0044   0443 E7            pop d
0045   0444 FD 43         mov [d], b
0046   0446             ; while(*psrc) *pdest++ = *psrc++; 
0047   0446             _while1_cond:
0048   0446 FA FF FF      lea d, [bp + -1] ; $psrc
0049   0449 2A            mov b, [d]
0050   044A 38 00 00      mov c, 0
0051   044D 74            mov d, b
0052   044E 32            mov bl, [d]
0053   044F A7 00         mov bh, 0
0054   0451 38 00 00      mov c, 0
0055   0454 C0 00 00      cmp b, 0
0056   0457 C6 88 04      je _while1_exit
0057   045A             _while1_block:
0058   045A             ; *pdest++ = *psrc++; 
0059   045A FA FD FF      lea d, [bp + -3] ; $pdest
0060   045D 2A            mov b, [d]
0061   045E 38 00 00      mov c, 0
0062   0461 FD 77         inc b
0063   0463 FA FD FF      lea d, [bp + -3] ; $pdest
0064   0466 FD 43         mov [d], b
0065   0468 FD 7D         dec b
0066   046A D8            push b
0067   046B FA FF FF      lea d, [bp + -1] ; $psrc
0068   046E 2A            mov b, [d]
0069   046F 38 00 00      mov c, 0
0070   0472 FD 77         inc b
0071   0474 FA FF FF      lea d, [bp + -1] ; $psrc
0072   0477 FD 43         mov [d], b
0073   0479 FD 7D         dec b
0074   047B 74            mov d, b
0075   047C 32            mov bl, [d]
0076   047D A7 00         mov bh, 0
0077   047F 38 00 00      mov c, 0
0078   0482 E7            pop d
0079   0483 FD 3E         mov [d], bl
0080   0485 0A 46 04      jmp _while1_cond
0081   0488             _while1_exit:
0082   0488             ; *pdest = '\0'; 
0083   0488 FA FD FF      lea d, [bp + -3] ; $pdest
0084   048B 2A            mov b, [d]
0085   048C 38 00 00      mov c, 0
0086   048F D8            push b
0087   0490 FD 2E 00 00   mov32 cb, $00000000
0087   0494 00 00 
0088   0496 E7            pop d
0089   0497 FD 3E         mov [d], bl
0090   0499 F9            leave
0091   049A 09            ret
0092   049B             
0093   049B             strcmp:
0094   049B F8 00 00      enter 0 ; (push bp; mov bp, sp)
0095   049E             ; while (*s1 && (*s1 == *s2)) { 
0096   049E             _while2_cond:
0097   049E FA 05 00      lea d, [bp + 5] ; $s1
0098   04A1 2A            mov b, [d]
0099   04A2 38 00 00      mov c, 0
0100   04A5 74            mov d, b
0101   04A6 32            mov bl, [d]
0102   04A7 A7 00         mov bh, 0
0103   04A9 38 00 00      mov c, 0
0104   04AC             ; --- START LOGICAL AND
0105   04AC D7            push a
0106   04AD 11            mov a, b
0107   04AE FA 05 00      lea d, [bp + 5] ; $s1
0108   04B1 2A            mov b, [d]
0109   04B2 38 00 00      mov c, 0
0110   04B5 74            mov d, b
0111   04B6 32            mov bl, [d]
0112   04B7 A7 00         mov bh, 0
0113   04B9 38 00 00      mov c, 0
0114   04BC             ; --- START RELATIONAL
0115   04BC D7            push a
0116   04BD 11            mov a, b
0117   04BE FA 07 00      lea d, [bp + 7] ; $s2
0118   04C1 2A            mov b, [d]
0119   04C2 38 00 00      mov c, 0
0120   04C5 74            mov d, b
0121   04C6 32            mov bl, [d]
0122   04C7 A7 00         mov bh, 0
0123   04C9 38 00 00      mov c, 0
0124   04CC B0            cmp a, b
0125   04CD FD 71         seq ; ==
0126   04CF E4            pop a
0127   04D0             ; --- END RELATIONAL
0128   04D0 FD A7         sand a, b
0129   04D2 E4            pop a
0130   04D3             ; --- END LOGICAL AND
0131   04D3 C0 00 00      cmp b, 0
0132   04D6 C6 FC 04      je _while2_exit
0133   04D9             _while2_block:
0134   04D9             ; s1++; 
0135   04D9 FA 05 00      lea d, [bp + 5] ; $s1
0136   04DC 2A            mov b, [d]
0137   04DD 38 00 00      mov c, 0
0138   04E0 FD 77         inc b
0139   04E2 FA 05 00      lea d, [bp + 5] ; $s1
0140   04E5 FD 43         mov [d], b
0141   04E7 FD 7D         dec b
0142   04E9             ; s2++; 
0143   04E9 FA 07 00      lea d, [bp + 7] ; $s2
0144   04EC 2A            mov b, [d]
0145   04ED 38 00 00      mov c, 0
0146   04F0 FD 77         inc b
0147   04F2 FA 07 00      lea d, [bp + 7] ; $s2
0148   04F5 FD 43         mov [d], b
0149   04F7 FD 7D         dec b
0150   04F9 0A 9E 04      jmp _while2_cond
0151   04FC             _while2_exit:
0152   04FC             ; return *s1 - *s2; 
0153   04FC FA 05 00      lea d, [bp + 5] ; $s1
0154   04FF 2A            mov b, [d]
0155   0500 38 00 00      mov c, 0
0156   0503 74            mov d, b
0157   0504 32            mov bl, [d]
0158   0505 A7 00         mov bh, 0
0159   0507 38 00 00      mov c, 0
0160   050A             ; --- START TERMS
0161   050A D7            push a
0162   050B 11            mov a, b
0163   050C FA 07 00      lea d, [bp + 7] ; $s2
0164   050F 2A            mov b, [d]
0165   0510 38 00 00      mov c, 0
0166   0513 74            mov d, b
0167   0514 32            mov bl, [d]
0168   0515 A7 00         mov bh, 0
0169   0517 38 00 00      mov c, 0
0170   051A 60            sub a, b
0171   051B 27            mov b, a
0172   051C E4            pop a
0173   051D             ; --- END TERMS
0174   051D F9            leave
0175   051E 09            ret
0176   051F             
0177   051F             strncmp:
0178   051F F8 00 00      enter 0 ; (push bp; mov bp, sp)
0179   0522 F9            leave
0180   0523 09            ret
0181   0524             
0182   0524             strcat:
0183   0524 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0184   0527             ; int dest_len; 
0185   0527 52 02 00      sub sp, 2
0186   052A             ; int i; 
0187   052A 52 02 00      sub sp, 2
0188   052D             ; dest_len = strlen(dest); 
0189   052D FA FF FF      lea d, [bp + -1] ; $dest_len
0190   0530 DA            push d
0191   0531             ; --- START FUNCTION CALL
0192   0531 FA 05 00      lea d, [bp + 5] ; $dest
0193   0534 2A            mov b, [d]
0194   0535 38 00 00      mov c, 0
0195   0538 FD AB         swp b
0196   053A D8            push b
0197   053B 07 07 06      call strlen
0198   053E 51 02 00      add sp, 2
0199   0541             ; --- END FUNCTION CALL
0200   0541 E7            pop d
0201   0542 FD 43         mov [d], b
0202   0544             ; for (i = 0; src[i] != 0; i=i+1) { 
0203   0544             _for3_init:
0204   0544 FA FD FF      lea d, [bp + -3] ; $i
0205   0547 DA            push d
0206   0548 FD 2E 00 00   mov32 cb, $00000000
0206   054C 00 00 
0207   054E E7            pop d
0208   054F FD 43         mov [d], b
0209   0551             _for3_cond:
0210   0551 FA 07 00      lea d, [bp + 7] ; $src
0211   0554 FD 2A         mov d, [d]
0212   0556 D7            push a
0213   0557 DA            push d
0214   0558 FA FD FF      lea d, [bp + -3] ; $i
0215   055B 2A            mov b, [d]
0216   055C 38 00 00      mov c, 0
0217   055F E7            pop d
0218   0560 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0219   0564 E4            pop a
0220   0565 32            mov bl, [d]
0221   0566 A7 00         mov bh, 0
0222   0568 38 00 00      mov c, 0
0223   056B             ; --- START RELATIONAL
0224   056B D7            push a
0225   056C 11            mov a, b
0226   056D FD 2E 00 00   mov32 cb, $00000000
0226   0571 00 00 
0227   0573 B0            cmp a, b
0228   0574 FD 72         sneq ; !=
0229   0576 E4            pop a
0230   0577             ; --- END RELATIONAL
0231   0577 C0 00 00      cmp b, 0
0232   057A C6 D5 05      je _for3_exit
0233   057D             _for3_block:
0234   057D             ; dest[dest_len + i] = src[i]; 
0235   057D FA 05 00      lea d, [bp + 5] ; $dest
0236   0580 FD 2A         mov d, [d]
0237   0582 D7            push a
0238   0583 DA            push d
0239   0584 FA FF FF      lea d, [bp + -1] ; $dest_len
0240   0587 2A            mov b, [d]
0241   0588 38 00 00      mov c, 0
0242   058B             ; --- START TERMS
0243   058B D7            push a
0244   058C 11            mov a, b
0245   058D FA FD FF      lea d, [bp + -3] ; $i
0246   0590 2A            mov b, [d]
0247   0591 38 00 00      mov c, 0
0248   0594 56            add b, a
0249   0595 E4            pop a
0250   0596             ; --- END TERMS
0251   0596 E7            pop d
0252   0597 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0253   059B E4            pop a
0254   059C DA            push d
0255   059D FA 07 00      lea d, [bp + 7] ; $src
0256   05A0 FD 2A         mov d, [d]
0257   05A2 D7            push a
0258   05A3 DA            push d
0259   05A4 FA FD FF      lea d, [bp + -3] ; $i
0260   05A7 2A            mov b, [d]
0261   05A8 38 00 00      mov c, 0
0262   05AB E7            pop d
0263   05AC FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0264   05B0 E4            pop a
0265   05B1 32            mov bl, [d]
0266   05B2 A7 00         mov bh, 0
0267   05B4 38 00 00      mov c, 0
0268   05B7 E7            pop d
0269   05B8 FD 3E         mov [d], bl
0270   05BA             _for3_update:
0271   05BA FA FD FF      lea d, [bp + -3] ; $i
0272   05BD DA            push d
0273   05BE FA FD FF      lea d, [bp + -3] ; $i
0274   05C1 2A            mov b, [d]
0275   05C2 38 00 00      mov c, 0
0276   05C5             ; --- START TERMS
0277   05C5 D7            push a
0278   05C6 11            mov a, b
0279   05C7 FD 2E 01 00   mov32 cb, $00000001
0279   05CB 00 00 
0280   05CD 56            add b, a
0281   05CE E4            pop a
0282   05CF             ; --- END TERMS
0283   05CF E7            pop d
0284   05D0 FD 43         mov [d], b
0285   05D2 0A 51 05      jmp _for3_cond
0286   05D5             _for3_exit:
0287   05D5             ; dest[dest_len + i] = 0; 
0288   05D5 FA 05 00      lea d, [bp + 5] ; $dest
0289   05D8 FD 2A         mov d, [d]
0290   05DA D7            push a
0291   05DB DA            push d
0292   05DC FA FF FF      lea d, [bp + -1] ; $dest_len
0293   05DF 2A            mov b, [d]
0294   05E0 38 00 00      mov c, 0
0295   05E3             ; --- START TERMS
0296   05E3 D7            push a
0297   05E4 11            mov a, b
0298   05E5 FA FD FF      lea d, [bp + -3] ; $i
0299   05E8 2A            mov b, [d]
0300   05E9 38 00 00      mov c, 0
0301   05EC 56            add b, a
0302   05ED E4            pop a
0303   05EE             ; --- END TERMS
0304   05EE E7            pop d
0305   05EF FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0306   05F3 E4            pop a
0307   05F4 DA            push d
0308   05F5 FD 2E 00 00   mov32 cb, $00000000
0308   05F9 00 00 
0309   05FB E7            pop d
0310   05FC FD 3E         mov [d], bl
0311   05FE             ; return dest; 
0312   05FE FA 05 00      lea d, [bp + 5] ; $dest
0313   0601 2A            mov b, [d]
0314   0602 38 00 00      mov c, 0
0315   0605 F9            leave
0316   0606 09            ret
0317   0607             
0318   0607             strlen:
0319   0607 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0320   060A             ; int length; 
0321   060A 52 02 00      sub sp, 2
0322   060D             ; length = 0; 
0323   060D FA FF FF      lea d, [bp + -1] ; $length
0324   0610 DA            push d
0325   0611 FD 2E 00 00   mov32 cb, $00000000
0325   0615 00 00 
0326   0617 E7            pop d
0327   0618 FD 43         mov [d], b
0328   061A             ; while (str[length] != 0) { 
0329   061A             _while4_cond:
0330   061A FA 05 00      lea d, [bp + 5] ; $str
0331   061D FD 2A         mov d, [d]
0332   061F D7            push a
0333   0620 DA            push d
0334   0621 FA FF FF      lea d, [bp + -1] ; $length
0335   0624 2A            mov b, [d]
0336   0625 38 00 00      mov c, 0
0337   0628 E7            pop d
0338   0629 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0339   062D E4            pop a
0340   062E 32            mov bl, [d]
0341   062F A7 00         mov bh, 0
0342   0631 38 00 00      mov c, 0
0343   0634             ; --- START RELATIONAL
0344   0634 D7            push a
0345   0635 11            mov a, b
0346   0636 FD 2E 00 00   mov32 cb, $00000000
0346   063A 00 00 
0347   063C B0            cmp a, b
0348   063D FD 72         sneq ; !=
0349   063F E4            pop a
0350   0640             ; --- END RELATIONAL
0351   0640 C0 00 00      cmp b, 0
0352   0643 C6 59 06      je _while4_exit
0353   0646             _while4_block:
0354   0646             ; length++; 
0355   0646 FA FF FF      lea d, [bp + -1] ; $length
0356   0649 2A            mov b, [d]
0357   064A 38 00 00      mov c, 0
0358   064D FD 77         inc b
0359   064F FA FF FF      lea d, [bp + -1] ; $length
0360   0652 FD 43         mov [d], b
0361   0654 FD 7D         dec b
0362   0656 0A 1A 06      jmp _while4_cond
0363   0659             _while4_exit:
0364   0659             ; return length; 
0365   0659 FA FF FF      lea d, [bp + -1] ; $length
0366   065C 2A            mov b, [d]
0367   065D 38 00 00      mov c, 0
0368   0660 F9            leave
0369   0661 09            ret
0370   0662             
0371   0662             exit:
0372   0662 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0373   0665             
0374   0665             ; --- BEGIN INLINE ASM SEGMENT
0375   0665 05 0B         syscall sys_terminate_proc
0376   0667             ; --- END INLINE ASM SEGMENT
0377   0667             
0378   0667 F9            leave
0379   0668 09            ret
0380   0669             
0381   0669             memset:
0382   0669 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0383   066C             ; int i; 
0384   066C 52 02 00      sub sp, 2
0385   066F             ; for(i = 0; i < size; i++){ 
0386   066F             _for5_init:
0387   066F FA FF FF      lea d, [bp + -1] ; $i
0388   0672 DA            push d
0389   0673 FD 2E 00 00   mov32 cb, $00000000
0389   0677 00 00 
0390   0679 E7            pop d
0391   067A FD 43         mov [d], b
0392   067C             _for5_cond:
0393   067C FA FF FF      lea d, [bp + -1] ; $i
0394   067F 2A            mov b, [d]
0395   0680 38 00 00      mov c, 0
0396   0683             ; --- START RELATIONAL
0397   0683 D7            push a
0398   0684 11            mov a, b
0399   0685 FA 08 00      lea d, [bp + 8] ; $size
0400   0688 2A            mov b, [d]
0401   0689 38 00 00      mov c, 0
0402   068C B0            cmp a, b
0403   068D FD 73         slt ; < (signed)
0404   068F E4            pop a
0405   0690             ; --- END RELATIONAL
0406   0690 C0 00 00      cmp b, 0
0407   0693 C6 C8 06      je _for5_exit
0408   0696             _for5_block:
0409   0696             ; *(s+i) = c; 
0410   0696 FA 05 00      lea d, [bp + 5] ; $s
0411   0699 2A            mov b, [d]
0412   069A 38 00 00      mov c, 0
0413   069D             ; --- START TERMS
0414   069D D7            push a
0415   069E 11            mov a, b
0416   069F FA FF FF      lea d, [bp + -1] ; $i
0417   06A2 2A            mov b, [d]
0418   06A3 38 00 00      mov c, 0
0419   06A6 56            add b, a
0420   06A7 E4            pop a
0421   06A8             ; --- END TERMS
0422   06A8 D8            push b
0423   06A9 FA 07 00      lea d, [bp + 7] ; $c
0424   06AC 32            mov bl, [d]
0425   06AD A7 00         mov bh, 0
0426   06AF 38 00 00      mov c, 0
0427   06B2 E7            pop d
0428   06B3 FD 3E         mov [d], bl
0429   06B5             _for5_update:
0430   06B5 FA FF FF      lea d, [bp + -1] ; $i
0431   06B8 2A            mov b, [d]
0432   06B9 38 00 00      mov c, 0
0433   06BC FD 77         inc b
0434   06BE FA FF FF      lea d, [bp + -1] ; $i
0435   06C1 FD 43         mov [d], b
0436   06C3 FD 7D         dec b
0437   06C5 0A 7C 06      jmp _for5_cond
0438   06C8             _for5_exit:
0439   06C8             ; return s; 
0440   06C8 FA 05 00      lea d, [bp + 5] ; $s
0441   06CB 2A            mov b, [d]
0442   06CC 38 00 00      mov c, 0
0443   06CF F9            leave
0444   06D0 09            ret
0445   06D1             
0446   06D1             atoi:
0447   06D1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0448   06D4             ; int result = 0;  // Initialize result 
0449   06D4 52 02 00      sub sp, 2
0450   06D7             ; --- START LOCAL VAR INITIALIZATION
0451   06D7 FA FF FF      lea d, [bp + -1] ; $result
0452   06DA DA            push d
0453   06DB FD 2E 00 00   mov32 cb, $00000000
0453   06DF 00 00 
0454   06E1 E7            pop d
0455   06E2 FD 43         mov [d], b
0456   06E4             ; --- END LOCAL VAR INITIALIZATION
0457   06E4             ; int sign = 1;    // Initialize sign as positive 
0458   06E4 52 02 00      sub sp, 2
0459   06E7             ; --- START LOCAL VAR INITIALIZATION
0460   06E7 FA FD FF      lea d, [bp + -3] ; $sign
0461   06EA DA            push d
0462   06EB FD 2E 01 00   mov32 cb, $00000001
0462   06EF 00 00 
0463   06F1 E7            pop d
0464   06F2 FD 43         mov [d], b
0465   06F4             ; --- END LOCAL VAR INITIALIZATION
0466   06F4             ; while (*str == ' ') str++; 
0467   06F4             _while6_cond:
0468   06F4 FA 05 00      lea d, [bp + 5] ; $str
0469   06F7 2A            mov b, [d]
0470   06F8 38 00 00      mov c, 0
0471   06FB 74            mov d, b
0472   06FC 32            mov bl, [d]
0473   06FD A7 00         mov bh, 0
0474   06FF 38 00 00      mov c, 0
0475   0702             ; --- START RELATIONAL
0476   0702 D7            push a
0477   0703 11            mov a, b
0478   0704 FD 2E 20 00   mov32 cb, $00000020
0478   0708 00 00 
0479   070A B0            cmp a, b
0480   070B FD 71         seq ; ==
0481   070D E4            pop a
0482   070E             ; --- END RELATIONAL
0483   070E C0 00 00      cmp b, 0
0484   0711 C6 27 07      je _while6_exit
0485   0714             _while6_block:
0486   0714             ; str++; 
0487   0714 FA 05 00      lea d, [bp + 5] ; $str
0488   0717 2A            mov b, [d]
0489   0718 38 00 00      mov c, 0
0490   071B FD 77         inc b
0491   071D FA 05 00      lea d, [bp + 5] ; $str
0492   0720 FD 43         mov [d], b
0493   0722 FD 7D         dec b
0494   0724 0A F4 06      jmp _while6_cond
0495   0727             _while6_exit:
0496   0727             ; if (*str == '-' || *str == '+') { 
0497   0727             _if7_cond:
0498   0727 FA 05 00      lea d, [bp + 5] ; $str
0499   072A 2A            mov b, [d]
0500   072B 38 00 00      mov c, 0
0501   072E 74            mov d, b
0502   072F 32            mov bl, [d]
0503   0730 A7 00         mov bh, 0
0504   0732 38 00 00      mov c, 0
0505   0735             ; --- START RELATIONAL
0506   0735 D7            push a
0507   0736 11            mov a, b
0508   0737 FD 2E 2D 00   mov32 cb, $0000002d
0508   073B 00 00 
0509   073D B0            cmp a, b
0510   073E FD 71         seq ; ==
0511   0740 E4            pop a
0512   0741             ; --- END RELATIONAL
0513   0741             ; --- START LOGICAL OR
0514   0741 D7            push a
0515   0742 11            mov a, b
0516   0743 FA 05 00      lea d, [bp + 5] ; $str
0517   0746 2A            mov b, [d]
0518   0747 38 00 00      mov c, 0
0519   074A 74            mov d, b
0520   074B 32            mov bl, [d]
0521   074C A7 00         mov bh, 0
0522   074E 38 00 00      mov c, 0
0523   0751             ; --- START RELATIONAL
0524   0751 D7            push a
0525   0752 11            mov a, b
0526   0753 FD 2E 2B 00   mov32 cb, $0000002b
0526   0757 00 00 
0527   0759 B0            cmp a, b
0528   075A FD 71         seq ; ==
0529   075C E4            pop a
0530   075D             ; --- END RELATIONAL
0531   075D FD A8         sor a, b ; ||
0532   075F E4            pop a
0533   0760             ; --- END LOGICAL OR
0534   0760 C0 00 00      cmp b, 0
0535   0763 C6 A9 07      je _if7_exit
0536   0766             _if7_true:
0537   0766             ; if (*str == '-') sign = -1; 
0538   0766             _if8_cond:
0539   0766 FA 05 00      lea d, [bp + 5] ; $str
0540   0769 2A            mov b, [d]
0541   076A 38 00 00      mov c, 0
0542   076D 74            mov d, b
0543   076E 32            mov bl, [d]
0544   076F A7 00         mov bh, 0
0545   0771 38 00 00      mov c, 0
0546   0774             ; --- START RELATIONAL
0547   0774 D7            push a
0548   0775 11            mov a, b
0549   0776 FD 2E 2D 00   mov32 cb, $0000002d
0549   077A 00 00 
0550   077C B0            cmp a, b
0551   077D FD 71         seq ; ==
0552   077F E4            pop a
0553   0780             ; --- END RELATIONAL
0554   0780 C0 00 00      cmp b, 0
0555   0783 C6 96 07      je _if8_exit
0556   0786             _if8_true:
0557   0786             ; sign = -1; 
0558   0786 FA FD FF      lea d, [bp + -3] ; $sign
0559   0789 DA            push d
0560   078A FD 2E 01 00   mov32 cb, $00000001
0560   078E 00 00 
0561   0790 E7            pop d
0562   0791 FD 43         mov [d], b
0563   0793 0A 96 07      jmp _if8_exit
0564   0796             _if8_exit:
0565   0796             ; str++; 
0566   0796 FA 05 00      lea d, [bp + 5] ; $str
0567   0799 2A            mov b, [d]
0568   079A 38 00 00      mov c, 0
0569   079D FD 77         inc b
0570   079F FA 05 00      lea d, [bp + 5] ; $str
0571   07A2 FD 43         mov [d], b
0572   07A4 FD 7D         dec b
0573   07A6 0A A9 07      jmp _if7_exit
0574   07A9             _if7_exit:
0575   07A9             ; while (*str >= '0' && *str <= '9') { 
0576   07A9             _while9_cond:
0577   07A9 FA 05 00      lea d, [bp + 5] ; $str
0578   07AC 2A            mov b, [d]
0579   07AD 38 00 00      mov c, 0
0580   07B0 74            mov d, b
0581   07B1 32            mov bl, [d]
0582   07B2 A7 00         mov bh, 0
0583   07B4 38 00 00      mov c, 0
0584   07B7             ; --- START RELATIONAL
0585   07B7 D7            push a
0586   07B8 11            mov a, b
0587   07B9 FD 2E 30 00   mov32 cb, $00000030
0587   07BD 00 00 
0588   07BF B0            cmp a, b
0589   07C0 FD 82         sgeu ; >= (unsigned)
0590   07C2 E4            pop a
0591   07C3             ; --- END RELATIONAL
0592   07C3             ; --- START LOGICAL AND
0593   07C3 D7            push a
0594   07C4 11            mov a, b
0595   07C5 FA 05 00      lea d, [bp + 5] ; $str
0596   07C8 2A            mov b, [d]
0597   07C9 38 00 00      mov c, 0
0598   07CC 74            mov d, b
0599   07CD 32            mov bl, [d]
0600   07CE A7 00         mov bh, 0
0601   07D0 38 00 00      mov c, 0
0602   07D3             ; --- START RELATIONAL
0603   07D3 D7            push a
0604   07D4 11            mov a, b
0605   07D5 FD 2E 39 00   mov32 cb, $00000039
0605   07D9 00 00 
0606   07DB B0            cmp a, b
0607   07DC FD 76         sleu ; <= (unsigned)
0608   07DE E4            pop a
0609   07DF             ; --- END RELATIONAL
0610   07DF FD A7         sand a, b
0611   07E1 E4            pop a
0612   07E2             ; --- END LOGICAL AND
0613   07E2 C0 00 00      cmp b, 0
0614   07E5 C6 32 08      je _while9_exit
0615   07E8             _while9_block:
0616   07E8             ; result = result * 10 + (*str - '0'); 
0617   07E8 FA FF FF      lea d, [bp + -1] ; $result
0618   07EB DA            push d
0619   07EC FA FF FF      lea d, [bp + -1] ; $result
0620   07EF 2A            mov b, [d]
0621   07F0 38 00 00      mov c, 0
0622   07F3             ; --- START FACTORS
0623   07F3 D7            push a
0624   07F4 11            mov a, b
0625   07F5 FD 2E 0A 00   mov32 cb, $0000000a
0625   07F9 00 00 
0626   07FB AC            mul a, b ; *
0627   07FC 11            mov a, b
0628   07FD 27            mov b, a
0629   07FE E4            pop a
0630   07FF             ; --- END FACTORS
0631   07FF             ; --- START TERMS
0632   07FF D7            push a
0633   0800 11            mov a, b
0634   0801 FA 05 00      lea d, [bp + 5] ; $str
0635   0804 2A            mov b, [d]
0636   0805 38 00 00      mov c, 0
0637   0808 74            mov d, b
0638   0809 32            mov bl, [d]
0639   080A A7 00         mov bh, 0
0640   080C 38 00 00      mov c, 0
0641   080F             ; --- START TERMS
0642   080F D7            push a
0643   0810 11            mov a, b
0644   0811 FD 2E 30 00   mov32 cb, $00000030
0644   0815 00 00 
0645   0817 60            sub a, b
0646   0818 27            mov b, a
0647   0819 E4            pop a
0648   081A             ; --- END TERMS
0649   081A 56            add b, a
0650   081B E4            pop a
0651   081C             ; --- END TERMS
0652   081C E7            pop d
0653   081D FD 43         mov [d], b
0654   081F             ; str++; 
0655   081F FA 05 00      lea d, [bp + 5] ; $str
0656   0822 2A            mov b, [d]
0657   0823 38 00 00      mov c, 0
0658   0826 FD 77         inc b
0659   0828 FA 05 00      lea d, [bp + 5] ; $str
0660   082B FD 43         mov [d], b
0661   082D FD 7D         dec b
0662   082F 0A A9 07      jmp _while9_cond
0663   0832             _while9_exit:
0664   0832             ; return sign * result; 
0665   0832 FA FD FF      lea d, [bp + -3] ; $sign
0666   0835 2A            mov b, [d]
0667   0836 38 00 00      mov c, 0
0668   0839             ; --- START FACTORS
0669   0839 D7            push a
0670   083A 11            mov a, b
0671   083B FA FF FF      lea d, [bp + -1] ; $result
0672   083E 2A            mov b, [d]
0673   083F 38 00 00      mov c, 0
0674   0842 AC            mul a, b ; *
0675   0843 11            mov a, b
0676   0844 27            mov b, a
0677   0845 E4            pop a
0678   0846             ; --- END FACTORS
0679   0846 F9            leave
0680   0847 09            ret
0681   0848             
0682   0848             rand:
0683   0848 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0684   084B             ; int  sec; 
0685   084B 52 02 00      sub sp, 2
0686   084E             
0687   084E             ; --- BEGIN INLINE ASM SEGMENT
0688   084E 19 00         mov al, 0
0689   0850 05 01         syscall sys_rtc					
0690   0852 1A            mov al, ah
0691   0853 FA FF FF      lea d, [bp + -1] ; $sec
0692   0856 1E            mov al, [d]
0693   0857 22 00         mov ah, 0
0694   0859             ; --- END INLINE ASM SEGMENT
0695   0859             
0696   0859             ; return sec; 
0697   0859 FA FF FF      lea d, [bp + -1] ; $sec
0698   085C 2A            mov b, [d]
0699   085D 38 00 00      mov c, 0
0700   0860 F9            leave
0701   0861 09            ret
0702   0862             
0703   0862             alloc:
0704   0862 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0705   0865             ; heap_top = heap_top + bytes; 
0706   0865 3B 9C 21      mov d, _heap_top ; $heap_top
0707   0868 DA            push d
0708   0869 3B 9C 21      mov d, _heap_top ; $heap_top
0709   086C 2A            mov b, [d]
0710   086D 38 00 00      mov c, 0
0711   0870             ; --- START TERMS
0712   0870 D7            push a
0713   0871 11            mov a, b
0714   0872 FA 05 00      lea d, [bp + 5] ; $bytes
0715   0875 2A            mov b, [d]
0716   0876 38 00 00      mov c, 0
0717   0879 56            add b, a
0718   087A E4            pop a
0719   087B             ; --- END TERMS
0720   087B E7            pop d
0721   087C FD 43         mov [d], b
0722   087E             ; return heap_top - bytes; 
0723   087E 3B 9C 21      mov d, _heap_top ; $heap_top
0724   0881 2A            mov b, [d]
0725   0882 38 00 00      mov c, 0
0726   0885             ; --- START TERMS
0727   0885 D7            push a
0728   0886 11            mov a, b
0729   0887 FA 05 00      lea d, [bp + 5] ; $bytes
0730   088A 2A            mov b, [d]
0731   088B 38 00 00      mov c, 0
0732   088E 60            sub a, b
0733   088F 27            mov b, a
0734   0890 E4            pop a
0735   0891             ; --- END TERMS
0736   0891 F9            leave
0737   0892 09            ret
0738   0893             
0739   0893             free:
0740   0893 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0741   0896             ; return heap_top = heap_top - bytes; 
0742   0896 3B 9C 21      mov d, _heap_top ; $heap_top
0743   0899 DA            push d
0744   089A 3B 9C 21      mov d, _heap_top ; $heap_top
0745   089D 2A            mov b, [d]
0746   089E 38 00 00      mov c, 0
0747   08A1             ; --- START TERMS
0748   08A1 D7            push a
0749   08A2 11            mov a, b
0750   08A3 FA 05 00      lea d, [bp + 5] ; $bytes
0751   08A6 2A            mov b, [d]
0752   08A7 38 00 00      mov c, 0
0753   08AA 60            sub a, b
0754   08AB 27            mov b, a
0755   08AC E4            pop a
0756   08AD             ; --- END TERMS
0757   08AD E7            pop d
0758   08AE FD 43         mov [d], b
0759   08B0 F9            leave
0760   08B1 09            ret
0761   08B2             
0762   08B2             fopen:
0763   08B2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0764   08B5             ; FILE *fp; 
0765   08B5 52 02 00      sub sp, 2
0766   08B8             ; static int max_handle = 0; 
0767   08B8 52 02 00      sub sp, 2
0768   08BB             ; fp = alloc(sizeof(FILE)); 
0769   08BB FA FF FF      lea d, [bp + -1] ; $fp
0770   08BE DA            push d
0771   08BF             ; --- START FUNCTION CALL
0772   08BF 26 04 01      mov b, 260
0773   08C2 FD AB         swp b
0774   08C4 D8            push b
0775   08C5 07 62 08      call alloc
0776   08C8 51 02 00      add sp, 2
0777   08CB             ; --- END FUNCTION CALL
0778   08CB E7            pop d
0779   08CC FD 43         mov [d], b
0780   08CE             ; strcpy(fp->filename, filename); 
0781   08CE             ; --- START FUNCTION CALL
0782   08CE FA 05 00      lea d, [bp + 5] ; $filename
0783   08D1 2A            mov b, [d]
0784   08D2 38 00 00      mov c, 0
0785   08D5 FD AB         swp b
0786   08D7 D8            push b
0787   08D8 FA FF FF      lea d, [bp + -1] ; $fp
0788   08DB FD 2A         mov d, [d]
0789   08DD 58 02 00      add d, 2
0790   08E0 2D            mov b, d
0791   08E1 38 00 00      mov c, 0
0792   08E4 FD AB         swp b
0793   08E6 D8            push b
0794   08E7 07 21 04      call strcpy
0795   08EA 51 04 00      add sp, 4
0796   08ED             ; --- END FUNCTION CALL
0797   08ED             ; fp->handle = max_handle; 
0798   08ED FA FF FF      lea d, [bp + -1] ; $fp
0799   08F0 FD 2A         mov d, [d]
0800   08F2 58 00 00      add d, 0
0801   08F5 DA            push d
0802   08F6 3B 56 21      mov d, st_fopen_max_handle ; static max_handle
0803   08F9 2A            mov b, [d]
0804   08FA 38 00 00      mov c, 0
0805   08FD E7            pop d
0806   08FE FD 43         mov [d], b
0807   0900             ; fp->mode = mode; 
0808   0900 FA FF FF      lea d, [bp + -1] ; $fp
0809   0903 FD 2A         mov d, [d]
0810   0905 58 02 01      add d, 258
0811   0908 DA            push d
0812   0909 FA 07 00      lea d, [bp + 7] ; $mode
0813   090C 32            mov bl, [d]
0814   090D A7 00         mov bh, 0
0815   090F 38 00 00      mov c, 0
0816   0912 E7            pop d
0817   0913 FD 3E         mov [d], bl
0818   0915             ; fp->loc = 0; 
0819   0915 FA FF FF      lea d, [bp + -1] ; $fp
0820   0918 FD 2A         mov d, [d]
0821   091A 58 03 01      add d, 259
0822   091D DA            push d
0823   091E FD 2E 00 00   mov32 cb, $00000000
0823   0922 00 00 
0824   0924 E7            pop d
0825   0925 FD 3E         mov [d], bl
0826   0927             ; max_handle++; 
0827   0927 3B 56 21      mov d, st_fopen_max_handle ; static max_handle
0828   092A 2A            mov b, [d]
0829   092B 38 00 00      mov c, 0
0830   092E FD 77         inc b
0831   0930 3B 56 21      mov d, st_fopen_max_handle ; static max_handle
0832   0933 FD 43         mov [d], b
0833   0935 FD 7D         dec b
0834   0937 F9            leave
0835   0938 09            ret
0836   0939             
0837   0939             fclose:
0838   0939 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0839   093C             ; free(sizeof(FILE)); 
0840   093C             ; --- START FUNCTION CALL
0841   093C 26 04 01      mov b, 260
0842   093F FD AB         swp b
0843   0941 D8            push b
0844   0942 07 93 08      call free
0845   0945 51 02 00      add sp, 2
0846   0948             ; --- END FUNCTION CALL
0847   0948 F9            leave
0848   0949 09            ret
0849   094A             
0850   094A             printf:
0851   094A F8 00 00      enter 0 ; (push bp; mov bp, sp)
0852   094D             ; char *p, *format_p; 
0853   094D 52 02 00      sub sp, 2
0854   0950 52 02 00      sub sp, 2
0855   0953             ; format_p = format; 
0856   0953 FA FD FF      lea d, [bp + -3] ; $format_p
0857   0956 DA            push d
0858   0957 FA 05 00      lea d, [bp + 5] ; $format
0859   095A 2A            mov b, [d]
0860   095B 38 00 00      mov c, 0
0861   095E E7            pop d
0862   095F FD 43         mov [d], b
0863   0961             ; p = &format + 2; 
0864   0961 FA FF FF      lea d, [bp + -1] ; $p
0865   0964 DA            push d
0866   0965 FA 05 00      lea d, [bp + 5] ; $format
0867   0968 2D            mov b, d
0868   0969             ; --- START TERMS
0869   0969 D7            push a
0870   096A 11            mov a, b
0871   096B FD 2E 02 00   mov32 cb, $00000002
0871   096F 00 00 
0872   0971 56            add b, a
0873   0972 E4            pop a
0874   0973             ; --- END TERMS
0875   0973 E7            pop d
0876   0974 FD 43         mov [d], b
0877   0976             ; for(;;){ 
0878   0976             _for10_init:
0879   0976             _for10_cond:
0880   0976             _for10_block:
0881   0976             ; if(!*format_p) break; 
0882   0976             _if11_cond:
0883   0976 FA FD FF      lea d, [bp + -3] ; $format_p
0884   0979 2A            mov b, [d]
0885   097A 38 00 00      mov c, 0
0886   097D 74            mov d, b
0887   097E 32            mov bl, [d]
0888   097F A7 00         mov bh, 0
0889   0981 38 00 00      mov c, 0
0890   0984 C0 00 00      cmp b, 0
0891   0987 FD 71         seq ; !
0892   0989 C0 00 00      cmp b, 0
0893   098C C6 95 09      je _if11_else
0894   098F             _if11_true:
0895   098F             ; break; 
0896   098F 0A 2E 0C      jmp _for10_exit ; for break
0897   0992 0A 2B 0C      jmp _if11_exit
0898   0995             _if11_else:
0899   0995             ; if(*format_p == '%'){ 
0900   0995             _if12_cond:
0901   0995 FA FD FF      lea d, [bp + -3] ; $format_p
0902   0998 2A            mov b, [d]
0903   0999 38 00 00      mov c, 0
0904   099C 74            mov d, b
0905   099D 32            mov bl, [d]
0906   099E A7 00         mov bh, 0
0907   09A0 38 00 00      mov c, 0
0908   09A3             ; --- START RELATIONAL
0909   09A3 D7            push a
0910   09A4 11            mov a, b
0911   09A5 FD 2E 25 00   mov32 cb, $00000025
0911   09A9 00 00 
0912   09AB B0            cmp a, b
0913   09AC FD 71         seq ; ==
0914   09AE E4            pop a
0915   09AF             ; --- END RELATIONAL
0916   09AF C0 00 00      cmp b, 0
0917   09B2 C6 06 0C      je _if12_else
0918   09B5             _if12_true:
0919   09B5             ; format_p++; 
0920   09B5 FA FD FF      lea d, [bp + -3] ; $format_p
0921   09B8 2A            mov b, [d]
0922   09B9 38 00 00      mov c, 0
0923   09BC FD 77         inc b
0924   09BE FA FD FF      lea d, [bp + -3] ; $format_p
0925   09C1 FD 43         mov [d], b
0926   09C3 FD 7D         dec b
0927   09C5             ; switch(*format_p){ 
0928   09C5             _switch13_expr:
0929   09C5 FA FD FF      lea d, [bp + -3] ; $format_p
0930   09C8 2A            mov b, [d]
0931   09C9 38 00 00      mov c, 0
0932   09CC 74            mov d, b
0933   09CD 32            mov bl, [d]
0934   09CE A7 00         mov bh, 0
0935   09D0 38 00 00      mov c, 0
0936   09D3             _switch13_comparisons:
0937   09D3 C1 6C         cmp bl, $6c
0938   09D5 C6 01 0A      je _switch13_case0
0939   09D8 C1 4C         cmp bl, $4c
0940   09DA C6 01 0A      je _switch13_case1
0941   09DD C1 64         cmp bl, $64
0942   09DF C6 19 0B      je _switch13_case2
0943   09E2 C1 69         cmp bl, $69
0944   09E4 C6 19 0B      je _switch13_case3
0945   09E7 C1 75         cmp bl, $75
0946   09E9 C6 49 0B      je _switch13_case4
0947   09EC C1 78         cmp bl, $78
0948   09EE C6 79 0B      je _switch13_case5
0949   09F1 C1 63         cmp bl, $63
0950   09F3 C6 9D 0B      je _switch13_case6
0951   09F6 C1 73         cmp bl, $73
0952   09F8 C6 C2 0B      je _switch13_case7
0953   09FB 0A E7 0B      jmp _switch13_default
0954   09FE 0A F3 0B      jmp _switch13_exit
0955   0A01             _switch13_case0:
0956   0A01             _switch13_case1:
0957   0A01             ; format_p++; 
0958   0A01 FA FD FF      lea d, [bp + -3] ; $format_p
0959   0A04 2A            mov b, [d]
0960   0A05 38 00 00      mov c, 0
0961   0A08 FD 77         inc b
0962   0A0A FA FD FF      lea d, [bp + -3] ; $format_p
0963   0A0D FD 43         mov [d], b
0964   0A0F FD 7D         dec b
0965   0A11             ; if(*format_p == 'd' || *format_p == 'i') 
0966   0A11             _if14_cond:
0967   0A11 FA FD FF      lea d, [bp + -3] ; $format_p
0968   0A14 2A            mov b, [d]
0969   0A15 38 00 00      mov c, 0
0970   0A18 74            mov d, b
0971   0A19 32            mov bl, [d]
0972   0A1A A7 00         mov bh, 0
0973   0A1C 38 00 00      mov c, 0
0974   0A1F             ; --- START RELATIONAL
0975   0A1F D7            push a
0976   0A20 11            mov a, b
0977   0A21 FD 2E 64 00   mov32 cb, $00000064
0977   0A25 00 00 
0978   0A27 B0            cmp a, b
0979   0A28 FD 71         seq ; ==
0980   0A2A E4            pop a
0981   0A2B             ; --- END RELATIONAL
0982   0A2B             ; --- START LOGICAL OR
0983   0A2B D7            push a
0984   0A2C 11            mov a, b
0985   0A2D FA FD FF      lea d, [bp + -3] ; $format_p
0986   0A30 2A            mov b, [d]
0987   0A31 38 00 00      mov c, 0
0988   0A34 74            mov d, b
0989   0A35 32            mov bl, [d]
0990   0A36 A7 00         mov bh, 0
0991   0A38 38 00 00      mov c, 0
0992   0A3B             ; --- START RELATIONAL
0993   0A3B D7            push a
0994   0A3C 11            mov a, b
0995   0A3D FD 2E 69 00   mov32 cb, $00000069
0995   0A41 00 00 
0996   0A43 B0            cmp a, b
0997   0A44 FD 71         seq ; ==
0998   0A46 E4            pop a
0999   0A47             ; --- END RELATIONAL
1000   0A47 FD A8         sor a, b ; ||
1001   0A49 E4            pop a
1002   0A4A             ; --- END LOGICAL OR
1003   0A4A C0 00 00      cmp b, 0
1004   0A4D C6 71 0A      je _if14_else
1005   0A50             _if14_true:
1006   0A50             ; print_signed_long(*(long *)p); 
1007   0A50             ; --- START FUNCTION CALL
1008   0A50 FA FF FF      lea d, [bp + -1] ; $p
1009   0A53 2A            mov b, [d]
1010   0A54 38 00 00      mov c, 0
1011   0A57 AB            snex b
1012   0A58 FD 39         mov c, b
1013   0A5A 74            mov d, b
1014   0A5B 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1015   0A5E FD 39         mov c, b ; And place it into C
1016   0A60 2A            mov b, [d] ; Lower Word in B
1017   0A61 12            mov a, c
1018   0A62 FD AA         swp a
1019   0A64 D7            push a
1020   0A65 FD AB         swp b
1021   0A67 D8            push b
1022   0A68 07 06 16      call print_signed_long
1023   0A6B 51 04 00      add sp, 4
1024   0A6E             ; --- END FUNCTION CALL
1025   0A6E 0A FE 0A      jmp _if14_exit
1026   0A71             _if14_else:
1027   0A71             ; if(*format_p == 'u') 
1028   0A71             _if15_cond:
1029   0A71 FA FD FF      lea d, [bp + -3] ; $format_p
1030   0A74 2A            mov b, [d]
1031   0A75 38 00 00      mov c, 0
1032   0A78 74            mov d, b
1033   0A79 32            mov bl, [d]
1034   0A7A A7 00         mov bh, 0
1035   0A7C 38 00 00      mov c, 0
1036   0A7F             ; --- START RELATIONAL
1037   0A7F D7            push a
1038   0A80 11            mov a, b
1039   0A81 FD 2E 75 00   mov32 cb, $00000075
1039   0A85 00 00 
1040   0A87 B0            cmp a, b
1041   0A88 FD 71         seq ; ==
1042   0A8A E4            pop a
1043   0A8B             ; --- END RELATIONAL
1044   0A8B C0 00 00      cmp b, 0
1045   0A8E C6 B4 0A      je _if15_else
1046   0A91             _if15_true:
1047   0A91             ; print_unsigned_long(*(unsigned long *)p); 
1048   0A91             ; --- START FUNCTION CALL
1049   0A91 FA FF FF      lea d, [bp + -1] ; $p
1050   0A94 2A            mov b, [d]
1051   0A95 38 00 00      mov c, 0
1052   0A98 A7 00         mov bh, 0
1053   0A9A 38 00 00      mov c, 0
1054   0A9D 74            mov d, b
1055   0A9E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1056   0AA1 FD 39         mov c, b ; And place it into C
1057   0AA3 2A            mov b, [d] ; Lower Word in B
1058   0AA4 12            mov a, c
1059   0AA5 FD AA         swp a
1060   0AA7 D7            push a
1061   0AA8 FD AB         swp b
1062   0AAA D8            push b
1063   0AAB 07 6D 17      call print_unsigned_long
1064   0AAE 51 04 00      add sp, 4
1065   0AB1             ; --- END FUNCTION CALL
1066   0AB1 0A FE 0A      jmp _if15_exit
1067   0AB4             _if15_else:
1068   0AB4             ; if(*format_p == 'x') 
1069   0AB4             _if16_cond:
1070   0AB4 FA FD FF      lea d, [bp + -3] ; $format_p
1071   0AB7 2A            mov b, [d]
1072   0AB8 38 00 00      mov c, 0
1073   0ABB 74            mov d, b
1074   0ABC 32            mov bl, [d]
1075   0ABD A7 00         mov bh, 0
1076   0ABF 38 00 00      mov c, 0
1077   0AC2             ; --- START RELATIONAL
1078   0AC2 D7            push a
1079   0AC3 11            mov a, b
1080   0AC4 FD 2E 78 00   mov32 cb, $00000078
1080   0AC8 00 00 
1081   0ACA B0            cmp a, b
1082   0ACB FD 71         seq ; ==
1083   0ACD E4            pop a
1084   0ACE             ; --- END RELATIONAL
1085   0ACE C0 00 00      cmp b, 0
1086   0AD1 C6 F2 0A      je _if16_else
1087   0AD4             _if16_true:
1088   0AD4             ; printx32(*(long int *)p); 
1089   0AD4             ; --- START FUNCTION CALL
1090   0AD4 FA FF FF      lea d, [bp + -1] ; $p
1091   0AD7 2A            mov b, [d]
1092   0AD8 38 00 00      mov c, 0
1093   0ADB 74            mov d, b
1094   0ADC 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1095   0ADF FD 39         mov c, b ; And place it into C
1096   0AE1 2A            mov b, [d] ; Lower Word in B
1097   0AE2 12            mov a, c
1098   0AE3 FD AA         swp a
1099   0AE5 D7            push a
1100   0AE6 FD AB         swp b
1101   0AE8 D8            push b
1102   0AE9 07 DB 12      call printx32
1103   0AEC 51 04 00      add sp, 4
1104   0AEF             ; --- END FUNCTION CALL
1105   0AEF 0A FE 0A      jmp _if16_exit
1106   0AF2             _if16_else:
1107   0AF2             ; err("Unexpected format in printf."); 
1108   0AF2             ; --- START FUNCTION CALL
1109   0AF2 26 58 21      mov b, _s0 ; "Unexpected format in printf."
1110   0AF5 FD AB         swp b
1111   0AF7 D8            push b
1112   0AF8 07 C6 12      call err
1113   0AFB 51 02 00      add sp, 2
1114   0AFE             ; --- END FUNCTION CALL
1115   0AFE             _if16_exit:
1116   0AFE             _if15_exit:
1117   0AFE             _if14_exit:
1118   0AFE             ; p = p + 4; 
1119   0AFE FA FF FF      lea d, [bp + -1] ; $p
1120   0B01 DA            push d
1121   0B02 FA FF FF      lea d, [bp + -1] ; $p
1122   0B05 2A            mov b, [d]
1123   0B06 38 00 00      mov c, 0
1124   0B09             ; --- START TERMS
1125   0B09 D7            push a
1126   0B0A 11            mov a, b
1127   0B0B FD 2E 04 00   mov32 cb, $00000004
1127   0B0F 00 00 
1128   0B11 56            add b, a
1129   0B12 E4            pop a
1130   0B13             ; --- END TERMS
1131   0B13 E7            pop d
1132   0B14 FD 43         mov [d], b
1133   0B16             ; break; 
1134   0B16 0A F3 0B      jmp _switch13_exit ; case break
1135   0B19             _switch13_case2:
1136   0B19             _switch13_case3:
1137   0B19             ; print_signed(*(int*)p); 
1138   0B19             ; --- START FUNCTION CALL
1139   0B19 FA FF FF      lea d, [bp + -1] ; $p
1140   0B1C 2A            mov b, [d]
1141   0B1D 38 00 00      mov c, 0
1142   0B20 74            mov d, b
1143   0B21 2A            mov b, [d]
1144   0B22 38 00 00      mov c, 0
1145   0B25 FD AB         swp b
1146   0B27 D8            push b
1147   0B28 07 CF 14      call print_signed
1148   0B2B 51 02 00      add sp, 2
1149   0B2E             ; --- END FUNCTION CALL
1150   0B2E             ; p = p + 2; 
1151   0B2E FA FF FF      lea d, [bp + -1] ; $p
1152   0B31 DA            push d
1153   0B32 FA FF FF      lea d, [bp + -1] ; $p
1154   0B35 2A            mov b, [d]
1155   0B36 38 00 00      mov c, 0
1156   0B39             ; --- START TERMS
1157   0B39 D7            push a
1158   0B3A 11            mov a, b
1159   0B3B FD 2E 02 00   mov32 cb, $00000002
1159   0B3F 00 00 
1160   0B41 56            add b, a
1161   0B42 E4            pop a
1162   0B43             ; --- END TERMS
1163   0B43 E7            pop d
1164   0B44 FD 43         mov [d], b
1165   0B46             ; break; 
1166   0B46 0A F3 0B      jmp _switch13_exit ; case break
1167   0B49             _switch13_case4:
1168   0B49             ; print_unsigned(*(unsigned int*)p); 
1169   0B49             ; --- START FUNCTION CALL
1170   0B49 FA FF FF      lea d, [bp + -1] ; $p
1171   0B4C 2A            mov b, [d]
1172   0B4D 38 00 00      mov c, 0
1173   0B50 74            mov d, b
1174   0B51 2A            mov b, [d]
1175   0B52 38 00 00      mov c, 0
1176   0B55 FD AB         swp b
1177   0B57 D8            push b
1178   0B58 07 E1 19      call print_unsigned
1179   0B5B 51 02 00      add sp, 2
1180   0B5E             ; --- END FUNCTION CALL
1181   0B5E             ; p = p + 2; 
1182   0B5E FA FF FF      lea d, [bp + -1] ; $p
1183   0B61 DA            push d
1184   0B62 FA FF FF      lea d, [bp + -1] ; $p
1185   0B65 2A            mov b, [d]
1186   0B66 38 00 00      mov c, 0
1187   0B69             ; --- START TERMS
1188   0B69 D7            push a
1189   0B6A 11            mov a, b
1190   0B6B FD 2E 02 00   mov32 cb, $00000002
1190   0B6F 00 00 
1191   0B71 56            add b, a
1192   0B72 E4            pop a
1193   0B73             ; --- END TERMS
1194   0B73 E7            pop d
1195   0B74 FD 43         mov [d], b
1196   0B76             ; break; 
1197   0B76 0A F3 0B      jmp _switch13_exit ; case break
1198   0B79             _switch13_case5:
1199   0B79             
1200   0B79             ; --- BEGIN INLINE ASM SEGMENT
1201   0B79 FA FF FF      lea d, [bp + -1] ; $p
1202   0B7C FD 2A         mov d, [d]
1203   0B7E 2A            mov b, [d]
1204   0B7F 07 56 20      call print_u16x
1205   0B82             ; --- END INLINE ASM SEGMENT
1206   0B82             
1207   0B82             ; p = p + 2; 
1208   0B82 FA FF FF      lea d, [bp + -1] ; $p
1209   0B85 DA            push d
1210   0B86 FA FF FF      lea d, [bp + -1] ; $p
1211   0B89 2A            mov b, [d]
1212   0B8A 38 00 00      mov c, 0
1213   0B8D             ; --- START TERMS
1214   0B8D D7            push a
1215   0B8E 11            mov a, b
1216   0B8F FD 2E 02 00   mov32 cb, $00000002
1216   0B93 00 00 
1217   0B95 56            add b, a
1218   0B96 E4            pop a
1219   0B97             ; --- END TERMS
1220   0B97 E7            pop d
1221   0B98 FD 43         mov [d], b
1222   0B9A             ; break; 
1223   0B9A 0A F3 0B      jmp _switch13_exit ; case break
1224   0B9D             _switch13_case6:
1225   0B9D             
1226   0B9D             ; --- BEGIN INLINE ASM SEGMENT
1227   0B9D FA FF FF      lea d, [bp + -1] ; $p
1228   0BA0 FD 2A         mov d, [d]
1229   0BA2 1E            mov al, [d]
1230   0BA3 23            mov ah, al
1231   0BA4 07 B4 1E      call _putchar
1232   0BA7             ; --- END INLINE ASM SEGMENT
1233   0BA7             
1234   0BA7             ; p = p + 1; 
1235   0BA7 FA FF FF      lea d, [bp + -1] ; $p
1236   0BAA DA            push d
1237   0BAB FA FF FF      lea d, [bp + -1] ; $p
1238   0BAE 2A            mov b, [d]
1239   0BAF 38 00 00      mov c, 0
1240   0BB2             ; --- START TERMS
1241   0BB2 D7            push a
1242   0BB3 11            mov a, b
1243   0BB4 FD 2E 01 00   mov32 cb, $00000001
1243   0BB8 00 00 
1244   0BBA 56            add b, a
1245   0BBB E4            pop a
1246   0BBC             ; --- END TERMS
1247   0BBC E7            pop d
1248   0BBD FD 43         mov [d], b
1249   0BBF             ; break; 
1250   0BBF 0A F3 0B      jmp _switch13_exit ; case break
1251   0BC2             _switch13_case7:
1252   0BC2             
1253   0BC2             ; --- BEGIN INLINE ASM SEGMENT
1254   0BC2 FA FF FF      lea d, [bp + -1] ; $p
1255   0BC5 FD 2A         mov d, [d]
1256   0BC7 FD 2A         mov d, [d]
1257   0BC9 07 FE 1F      call _puts
1258   0BCC             ; --- END INLINE ASM SEGMENT
1259   0BCC             
1260   0BCC             ; p = p + 2; 
1261   0BCC FA FF FF      lea d, [bp + -1] ; $p
1262   0BCF DA            push d
1263   0BD0 FA FF FF      lea d, [bp + -1] ; $p
1264   0BD3 2A            mov b, [d]
1265   0BD4 38 00 00      mov c, 0
1266   0BD7             ; --- START TERMS
1267   0BD7 D7            push a
1268   0BD8 11            mov a, b
1269   0BD9 FD 2E 02 00   mov32 cb, $00000002
1269   0BDD 00 00 
1270   0BDF 56            add b, a
1271   0BE0 E4            pop a
1272   0BE1             ; --- END TERMS
1273   0BE1 E7            pop d
1274   0BE2 FD 43         mov [d], b
1275   0BE4             ; break; 
1276   0BE4 0A F3 0B      jmp _switch13_exit ; case break
1277   0BE7             _switch13_default:
1278   0BE7             ; print("Error: Unknown argument type.\n"); 
1279   0BE7             ; --- START FUNCTION CALL
1280   0BE7 26 75 21      mov b, _s1 ; "Error: Unknown argument type.\n"
1281   0BEA FD AB         swp b
1282   0BEC D8            push b
1283   0BED 07 F5 1C      call print
1284   0BF0 51 02 00      add sp, 2
1285   0BF3             ; --- END FUNCTION CALL
1286   0BF3             _switch13_exit:
1287   0BF3             ; format_p++; 
1288   0BF3 FA FD FF      lea d, [bp + -3] ; $format_p
1289   0BF6 2A            mov b, [d]
1290   0BF7 38 00 00      mov c, 0
1291   0BFA FD 77         inc b
1292   0BFC FA FD FF      lea d, [bp + -3] ; $format_p
1293   0BFF FD 43         mov [d], b
1294   0C01 FD 7D         dec b
1295   0C03 0A 2B 0C      jmp _if12_exit
1296   0C06             _if12_else:
1297   0C06             ; putchar(*format_p); 
1298   0C06             ; --- START FUNCTION CALL
1299   0C06 FA FD FF      lea d, [bp + -3] ; $format_p
1300   0C09 2A            mov b, [d]
1301   0C0A 38 00 00      mov c, 0
1302   0C0D 74            mov d, b
1303   0C0E 32            mov bl, [d]
1304   0C0F A7 00         mov bh, 0
1305   0C11 38 00 00      mov c, 0
1306   0C14 DD            push bl
1307   0C15 07 A7 1C      call putchar
1308   0C18 51 01 00      add sp, 1
1309   0C1B             ; --- END FUNCTION CALL
1310   0C1B             ; format_p++; 
1311   0C1B FA FD FF      lea d, [bp + -3] ; $format_p
1312   0C1E 2A            mov b, [d]
1313   0C1F 38 00 00      mov c, 0
1314   0C22 FD 77         inc b
1315   0C24 FA FD FF      lea d, [bp + -3] ; $format_p
1316   0C27 FD 43         mov [d], b
1317   0C29 FD 7D         dec b
1318   0C2B             _if12_exit:
1319   0C2B             _if11_exit:
1320   0C2B             _for10_update:
1321   0C2B 0A 76 09      jmp _for10_cond
1322   0C2E             _for10_exit:
1323   0C2E F9            leave
1324   0C2F 09            ret
1325   0C30             
1326   0C30             scanf:
1327   0C30 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1328   0C33             ; char *p, *format_p; 
1329   0C33 52 02 00      sub sp, 2
1330   0C36 52 02 00      sub sp, 2
1331   0C39             ; char c; 
1332   0C39 52 01 00      sub sp, 1
1333   0C3C             ; int i; 
1334   0C3C 52 02 00      sub sp, 2
1335   0C3F             ; char input_string[  512                    ]; 
1336   0C3F 52 00 02      sub sp, 512
1337   0C42             ; format_p = format; 
1338   0C42 FA FD FF      lea d, [bp + -3] ; $format_p
1339   0C45 DA            push d
1340   0C46 FA 05 00      lea d, [bp + 5] ; $format
1341   0C49 2A            mov b, [d]
1342   0C4A 38 00 00      mov c, 0
1343   0C4D E7            pop d
1344   0C4E FD 43         mov [d], b
1345   0C50             ; p = &format + 2; 
1346   0C50 FA FF FF      lea d, [bp + -1] ; $p
1347   0C53 DA            push d
1348   0C54 FA 05 00      lea d, [bp + 5] ; $format
1349   0C57 2D            mov b, d
1350   0C58             ; --- START TERMS
1351   0C58 D7            push a
1352   0C59 11            mov a, b
1353   0C5A FD 2E 02 00   mov32 cb, $00000002
1353   0C5E 00 00 
1354   0C60 56            add b, a
1355   0C61 E4            pop a
1356   0C62             ; --- END TERMS
1357   0C62 E7            pop d
1358   0C63 FD 43         mov [d], b
1359   0C65             ; for(;;){ 
1360   0C65             _for17_init:
1361   0C65             _for17_cond:
1362   0C65             _for17_block:
1363   0C65             ; if(!*format_p) break; 
1364   0C65             _if18_cond:
1365   0C65 FA FD FF      lea d, [bp + -3] ; $format_p
1366   0C68 2A            mov b, [d]
1367   0C69 38 00 00      mov c, 0
1368   0C6C 74            mov d, b
1369   0C6D 32            mov bl, [d]
1370   0C6E A7 00         mov bh, 0
1371   0C70 38 00 00      mov c, 0
1372   0C73 C0 00 00      cmp b, 0
1373   0C76 FD 71         seq ; !
1374   0C78 C0 00 00      cmp b, 0
1375   0C7B C6 84 0C      je _if18_else
1376   0C7E             _if18_true:
1377   0C7E             ; break; 
1378   0C7E 0A 0C 0F      jmp _for17_exit ; for break
1379   0C81 0A 09 0F      jmp _if18_exit
1380   0C84             _if18_else:
1381   0C84             ; if(*format_p == '%'){ 
1382   0C84             _if19_cond:
1383   0C84 FA FD FF      lea d, [bp + -3] ; $format_p
1384   0C87 2A            mov b, [d]
1385   0C88 38 00 00      mov c, 0
1386   0C8B 74            mov d, b
1387   0C8C 32            mov bl, [d]
1388   0C8D A7 00         mov bh, 0
1389   0C8F 38 00 00      mov c, 0
1390   0C92             ; --- START RELATIONAL
1391   0C92 D7            push a
1392   0C93 11            mov a, b
1393   0C94 FD 2E 25 00   mov32 cb, $00000025
1393   0C98 00 00 
1394   0C9A B0            cmp a, b
1395   0C9B FD 71         seq ; ==
1396   0C9D E4            pop a
1397   0C9E             ; --- END RELATIONAL
1398   0C9E C0 00 00      cmp b, 0
1399   0CA1 C6 E4 0E      je _if19_else
1400   0CA4             _if19_true:
1401   0CA4             ; format_p++; 
1402   0CA4 FA FD FF      lea d, [bp + -3] ; $format_p
1403   0CA7 2A            mov b, [d]
1404   0CA8 38 00 00      mov c, 0
1405   0CAB FD 77         inc b
1406   0CAD FA FD FF      lea d, [bp + -3] ; $format_p
1407   0CB0 FD 43         mov [d], b
1408   0CB2 FD 7D         dec b
1409   0CB4             ; switch(*format_p){ 
1410   0CB4             _switch20_expr:
1411   0CB4 FA FD FF      lea d, [bp + -3] ; $format_p
1412   0CB7 2A            mov b, [d]
1413   0CB8 38 00 00      mov c, 0
1414   0CBB 74            mov d, b
1415   0CBC 32            mov bl, [d]
1416   0CBD A7 00         mov bh, 0
1417   0CBF 38 00 00      mov c, 0
1418   0CC2             _switch20_comparisons:
1419   0CC2 C1 6C         cmp bl, $6c
1420   0CC4 C6 F0 0C      je _switch20_case0
1421   0CC7 C1 4C         cmp bl, $4c
1422   0CC9 C6 F0 0C      je _switch20_case1
1423   0CCC C1 64         cmp bl, $64
1424   0CCE C6 AF 0D      je _switch20_case2
1425   0CD1 C1 69         cmp bl, $69
1426   0CD3 C6 AF 0D      je _switch20_case3
1427   0CD6 C1 75         cmp bl, $75
1428   0CD8 C6 E8 0D      je _switch20_case4
1429   0CDB C1 78         cmp bl, $78
1430   0CDD C6 21 0E      je _switch20_case5
1431   0CE0 C1 63         cmp bl, $63
1432   0CE2 C6 3C 0E      je _switch20_case6
1433   0CE5 C1 73         cmp bl, $73
1434   0CE7 C6 7E 0E      je _switch20_case7
1435   0CEA 0A C5 0E      jmp _switch20_default
1436   0CED 0A D1 0E      jmp _switch20_exit
1437   0CF0             _switch20_case0:
1438   0CF0             _switch20_case1:
1439   0CF0             ; format_p++; 
1440   0CF0 FA FD FF      lea d, [bp + -3] ; $format_p
1441   0CF3 2A            mov b, [d]
1442   0CF4 38 00 00      mov c, 0
1443   0CF7 FD 77         inc b
1444   0CF9 FA FD FF      lea d, [bp + -3] ; $format_p
1445   0CFC FD 43         mov [d], b
1446   0CFE FD 7D         dec b
1447   0D00             ; if(*format_p == 'd' || *format_p == 'i'); 
1448   0D00             _if21_cond:
1449   0D00 FA FD FF      lea d, [bp + -3] ; $format_p
1450   0D03 2A            mov b, [d]
1451   0D04 38 00 00      mov c, 0
1452   0D07 74            mov d, b
1453   0D08 32            mov bl, [d]
1454   0D09 A7 00         mov bh, 0
1455   0D0B 38 00 00      mov c, 0
1456   0D0E             ; --- START RELATIONAL
1457   0D0E D7            push a
1458   0D0F 11            mov a, b
1459   0D10 FD 2E 64 00   mov32 cb, $00000064
1459   0D14 00 00 
1460   0D16 B0            cmp a, b
1461   0D17 FD 71         seq ; ==
1462   0D19 E4            pop a
1463   0D1A             ; --- END RELATIONAL
1464   0D1A             ; --- START LOGICAL OR
1465   0D1A D7            push a
1466   0D1B 11            mov a, b
1467   0D1C FA FD FF      lea d, [bp + -3] ; $format_p
1468   0D1F 2A            mov b, [d]
1469   0D20 38 00 00      mov c, 0
1470   0D23 74            mov d, b
1471   0D24 32            mov bl, [d]
1472   0D25 A7 00         mov bh, 0
1473   0D27 38 00 00      mov c, 0
1474   0D2A             ; --- START RELATIONAL
1475   0D2A D7            push a
1476   0D2B 11            mov a, b
1477   0D2C FD 2E 69 00   mov32 cb, $00000069
1477   0D30 00 00 
1478   0D32 B0            cmp a, b
1479   0D33 FD 71         seq ; ==
1480   0D35 E4            pop a
1481   0D36             ; --- END RELATIONAL
1482   0D36 FD A8         sor a, b ; ||
1483   0D38 E4            pop a
1484   0D39             ; --- END LOGICAL OR
1485   0D39 C0 00 00      cmp b, 0
1486   0D3C C6 42 0D      je _if21_else
1487   0D3F             _if21_true:
1488   0D3F             ; ; 
1489   0D3F 0A 94 0D      jmp _if21_exit
1490   0D42             _if21_else:
1491   0D42             ; if(*format_p == 'u'); 
1492   0D42             _if22_cond:
1493   0D42 FA FD FF      lea d, [bp + -3] ; $format_p
1494   0D45 2A            mov b, [d]
1495   0D46 38 00 00      mov c, 0
1496   0D49 74            mov d, b
1497   0D4A 32            mov bl, [d]
1498   0D4B A7 00         mov bh, 0
1499   0D4D 38 00 00      mov c, 0
1500   0D50             ; --- START RELATIONAL
1501   0D50 D7            push a
1502   0D51 11            mov a, b
1503   0D52 FD 2E 75 00   mov32 cb, $00000075
1503   0D56 00 00 
1504   0D58 B0            cmp a, b
1505   0D59 FD 71         seq ; ==
1506   0D5B E4            pop a
1507   0D5C             ; --- END RELATIONAL
1508   0D5C C0 00 00      cmp b, 0
1509   0D5F C6 65 0D      je _if22_else
1510   0D62             _if22_true:
1511   0D62             ; ; 
1512   0D62 0A 94 0D      jmp _if22_exit
1513   0D65             _if22_else:
1514   0D65             ; if(*format_p == 'x'); 
1515   0D65             _if23_cond:
1516   0D65 FA FD FF      lea d, [bp + -3] ; $format_p
1517   0D68 2A            mov b, [d]
1518   0D69 38 00 00      mov c, 0
1519   0D6C 74            mov d, b
1520   0D6D 32            mov bl, [d]
1521   0D6E A7 00         mov bh, 0
1522   0D70 38 00 00      mov c, 0
1523   0D73             ; --- START RELATIONAL
1524   0D73 D7            push a
1525   0D74 11            mov a, b
1526   0D75 FD 2E 78 00   mov32 cb, $00000078
1526   0D79 00 00 
1527   0D7B B0            cmp a, b
1528   0D7C FD 71         seq ; ==
1529   0D7E E4            pop a
1530   0D7F             ; --- END RELATIONAL
1531   0D7F C0 00 00      cmp b, 0
1532   0D82 C6 88 0D      je _if23_else
1533   0D85             _if23_true:
1534   0D85             ; ; 
1535   0D85 0A 94 0D      jmp _if23_exit
1536   0D88             _if23_else:
1537   0D88             ; err("Unexpected format in printf."); 
1538   0D88             ; --- START FUNCTION CALL
1539   0D88 26 58 21      mov b, _s0 ; "Unexpected format in printf."
1540   0D8B FD AB         swp b
1541   0D8D D8            push b
1542   0D8E 07 C6 12      call err
1543   0D91 51 02 00      add sp, 2
1544   0D94             ; --- END FUNCTION CALL
1545   0D94             _if23_exit:
1546   0D94             _if22_exit:
1547   0D94             _if21_exit:
1548   0D94             ; p = p + 4; 
1549   0D94 FA FF FF      lea d, [bp + -1] ; $p
1550   0D97 DA            push d
1551   0D98 FA FF FF      lea d, [bp + -1] ; $p
1552   0D9B 2A            mov b, [d]
1553   0D9C 38 00 00      mov c, 0
1554   0D9F             ; --- START TERMS
1555   0D9F D7            push a
1556   0DA0 11            mov a, b
1557   0DA1 FD 2E 04 00   mov32 cb, $00000004
1557   0DA5 00 00 
1558   0DA7 56            add b, a
1559   0DA8 E4            pop a
1560   0DA9             ; --- END TERMS
1561   0DA9 E7            pop d
1562   0DAA FD 43         mov [d], b
1563   0DAC             ; break; 
1564   0DAC 0A D1 0E      jmp _switch20_exit ; case break
1565   0DAF             _switch20_case2:
1566   0DAF             _switch20_case3:
1567   0DAF             ; i = scann(); 
1568   0DAF FA FA FF      lea d, [bp + -6] ; $i
1569   0DB2 DA            push d
1570   0DB3             ; --- START FUNCTION CALL
1571   0DB3 07 CD 1C      call scann
1572   0DB6 E7            pop d
1573   0DB7 FD 43         mov [d], b
1574   0DB9             ; **(int **)p = i; 
1575   0DB9 FA FF FF      lea d, [bp + -1] ; $p
1576   0DBC 2A            mov b, [d]
1577   0DBD 38 00 00      mov c, 0
1578   0DC0 74            mov d, b
1579   0DC1 2A            mov b, [d]
1580   0DC2 D8            push b
1581   0DC3 FA FA FF      lea d, [bp + -6] ; $i
1582   0DC6 2A            mov b, [d]
1583   0DC7 38 00 00      mov c, 0
1584   0DCA E7            pop d
1585   0DCB FD 43         mov [d], b
1586   0DCD             ; p = p + 2; 
1587   0DCD FA FF FF      lea d, [bp + -1] ; $p
1588   0DD0 DA            push d
1589   0DD1 FA FF FF      lea d, [bp + -1] ; $p
1590   0DD4 2A            mov b, [d]
1591   0DD5 38 00 00      mov c, 0
1592   0DD8             ; --- START TERMS
1593   0DD8 D7            push a
1594   0DD9 11            mov a, b
1595   0DDA FD 2E 02 00   mov32 cb, $00000002
1595   0DDE 00 00 
1596   0DE0 56            add b, a
1597   0DE1 E4            pop a
1598   0DE2             ; --- END TERMS
1599   0DE2 E7            pop d
1600   0DE3 FD 43         mov [d], b
1601   0DE5             ; break; 
1602   0DE5 0A D1 0E      jmp _switch20_exit ; case break
1603   0DE8             _switch20_case4:
1604   0DE8             ; i = scann(); 
1605   0DE8 FA FA FF      lea d, [bp + -6] ; $i
1606   0DEB DA            push d
1607   0DEC             ; --- START FUNCTION CALL
1608   0DEC 07 CD 1C      call scann
1609   0DEF E7            pop d
1610   0DF0 FD 43         mov [d], b
1611   0DF2             ; **(int **)p = i; 
1612   0DF2 FA FF FF      lea d, [bp + -1] ; $p
1613   0DF5 2A            mov b, [d]
1614   0DF6 38 00 00      mov c, 0
1615   0DF9 74            mov d, b
1616   0DFA 2A            mov b, [d]
1617   0DFB D8            push b
1618   0DFC FA FA FF      lea d, [bp + -6] ; $i
1619   0DFF 2A            mov b, [d]
1620   0E00 38 00 00      mov c, 0
1621   0E03 E7            pop d
1622   0E04 FD 43         mov [d], b
1623   0E06             ; p = p + 2; 
1624   0E06 FA FF FF      lea d, [bp + -1] ; $p
1625   0E09 DA            push d
1626   0E0A FA FF FF      lea d, [bp + -1] ; $p
1627   0E0D 2A            mov b, [d]
1628   0E0E 38 00 00      mov c, 0
1629   0E11             ; --- START TERMS
1630   0E11 D7            push a
1631   0E12 11            mov a, b
1632   0E13 FD 2E 02 00   mov32 cb, $00000002
1632   0E17 00 00 
1633   0E19 56            add b, a
1634   0E1A E4            pop a
1635   0E1B             ; --- END TERMS
1636   0E1B E7            pop d
1637   0E1C FD 43         mov [d], b
1638   0E1E             ; break; 
1639   0E1E 0A D1 0E      jmp _switch20_exit ; case break
1640   0E21             _switch20_case5:
1641   0E21             ; p = p + 2; 
1642   0E21 FA FF FF      lea d, [bp + -1] ; $p
1643   0E24 DA            push d
1644   0E25 FA FF FF      lea d, [bp + -1] ; $p
1645   0E28 2A            mov b, [d]
1646   0E29 38 00 00      mov c, 0
1647   0E2C             ; --- START TERMS
1648   0E2C D7            push a
1649   0E2D 11            mov a, b
1650   0E2E FD 2E 02 00   mov32 cb, $00000002
1650   0E32 00 00 
1651   0E34 56            add b, a
1652   0E35 E4            pop a
1653   0E36             ; --- END TERMS
1654   0E36 E7            pop d
1655   0E37 FD 43         mov [d], b
1656   0E39             ; break; 
1657   0E39 0A D1 0E      jmp _switch20_exit ; case break
1658   0E3C             _switch20_case6:
1659   0E3C             ; c = getchar(); 
1660   0E3C FA FC FF      lea d, [bp + -4] ; $c
1661   0E3F DA            push d
1662   0E40             ; --- START FUNCTION CALL
1663   0E40 07 B4 1C      call getchar
1664   0E43 E7            pop d
1665   0E44 FD 3E         mov [d], bl
1666   0E46             ; **(char **)p = *(char *)c; 
1667   0E46 FA FF FF      lea d, [bp + -1] ; $p
1668   0E49 2A            mov b, [d]
1669   0E4A 38 00 00      mov c, 0
1670   0E4D 74            mov d, b
1671   0E4E 2A            mov b, [d]
1672   0E4F D8            push b
1673   0E50 FA FC FF      lea d, [bp + -4] ; $c
1674   0E53 32            mov bl, [d]
1675   0E54 A7 00         mov bh, 0
1676   0E56 38 00 00      mov c, 0
1677   0E59 74            mov d, b
1678   0E5A 32            mov bl, [d]
1679   0E5B A7 00         mov bh, 0
1680   0E5D 38 00 00      mov c, 0
1681   0E60 E7            pop d
1682   0E61 FD 43         mov [d], b
1683   0E63             ; p = p + 1; 
1684   0E63 FA FF FF      lea d, [bp + -1] ; $p
1685   0E66 DA            push d
1686   0E67 FA FF FF      lea d, [bp + -1] ; $p
1687   0E6A 2A            mov b, [d]
1688   0E6B 38 00 00      mov c, 0
1689   0E6E             ; --- START TERMS
1690   0E6E D7            push a
1691   0E6F 11            mov a, b
1692   0E70 FD 2E 01 00   mov32 cb, $00000001
1692   0E74 00 00 
1693   0E76 56            add b, a
1694   0E77 E4            pop a
1695   0E78             ; --- END TERMS
1696   0E78 E7            pop d
1697   0E79 FD 43         mov [d], b
1698   0E7B             ; break; 
1699   0E7B 0A D1 0E      jmp _switch20_exit ; case break
1700   0E7E             _switch20_case7:
1701   0E7E             ; gets(input_string); 
1702   0E7E             ; --- START FUNCTION CALL
1703   0E7E FA FA FD      lea d, [bp + -518] ; $input_string
1704   0E81 2D            mov b, d
1705   0E82 38 00 00      mov c, 0
1706   0E85 FD AB         swp b
1707   0E87 D8            push b
1708   0E88 07 B2 14      call gets
1709   0E8B 51 02 00      add sp, 2
1710   0E8E             ; --- END FUNCTION CALL
1711   0E8E             ; strcpy(*(char **)p, input_string); 
1712   0E8E             ; --- START FUNCTION CALL
1713   0E8E FA FA FD      lea d, [bp + -518] ; $input_string
1714   0E91 2D            mov b, d
1715   0E92 38 00 00      mov c, 0
1716   0E95 FD AB         swp b
1717   0E97 D8            push b
1718   0E98 FA FF FF      lea d, [bp + -1] ; $p
1719   0E9B 2A            mov b, [d]
1720   0E9C 38 00 00      mov c, 0
1721   0E9F 74            mov d, b
1722   0EA0 2A            mov b, [d]
1723   0EA1 FD AB         swp b
1724   0EA3 D8            push b
1725   0EA4 07 21 04      call strcpy
1726   0EA7 51 04 00      add sp, 4
1727   0EAA             ; --- END FUNCTION CALL
1728   0EAA             ; p = p + 2; 
1729   0EAA FA FF FF      lea d, [bp + -1] ; $p
1730   0EAD DA            push d
1731   0EAE FA FF FF      lea d, [bp + -1] ; $p
1732   0EB1 2A            mov b, [d]
1733   0EB2 38 00 00      mov c, 0
1734   0EB5             ; --- START TERMS
1735   0EB5 D7            push a
1736   0EB6 11            mov a, b
1737   0EB7 FD 2E 02 00   mov32 cb, $00000002
1737   0EBB 00 00 
1738   0EBD 56            add b, a
1739   0EBE E4            pop a
1740   0EBF             ; --- END TERMS
1741   0EBF E7            pop d
1742   0EC0 FD 43         mov [d], b
1743   0EC2             ; break; 
1744   0EC2 0A D1 0E      jmp _switch20_exit ; case break
1745   0EC5             _switch20_default:
1746   0EC5             ; print("Error: Unknown argument type.\n"); 
1747   0EC5             ; --- START FUNCTION CALL
1748   0EC5 26 75 21      mov b, _s1 ; "Error: Unknown argument type.\n"
1749   0EC8 FD AB         swp b
1750   0ECA D8            push b
1751   0ECB 07 F5 1C      call print
1752   0ECE 51 02 00      add sp, 2
1753   0ED1             ; --- END FUNCTION CALL
1754   0ED1             _switch20_exit:
1755   0ED1             ; format_p++; 
1756   0ED1 FA FD FF      lea d, [bp + -3] ; $format_p
1757   0ED4 2A            mov b, [d]
1758   0ED5 38 00 00      mov c, 0
1759   0ED8 FD 77         inc b
1760   0EDA FA FD FF      lea d, [bp + -3] ; $format_p
1761   0EDD FD 43         mov [d], b
1762   0EDF FD 7D         dec b
1763   0EE1 0A 09 0F      jmp _if19_exit
1764   0EE4             _if19_else:
1765   0EE4             ; putchar(*format_p); 
1766   0EE4             ; --- START FUNCTION CALL
1767   0EE4 FA FD FF      lea d, [bp + -3] ; $format_p
1768   0EE7 2A            mov b, [d]
1769   0EE8 38 00 00      mov c, 0
1770   0EEB 74            mov d, b
1771   0EEC 32            mov bl, [d]
1772   0EED A7 00         mov bh, 0
1773   0EEF 38 00 00      mov c, 0
1774   0EF2 DD            push bl
1775   0EF3 07 A7 1C      call putchar
1776   0EF6 51 01 00      add sp, 1
1777   0EF9             ; --- END FUNCTION CALL
1778   0EF9             ; format_p++; 
1779   0EF9 FA FD FF      lea d, [bp + -3] ; $format_p
1780   0EFC 2A            mov b, [d]
1781   0EFD 38 00 00      mov c, 0
1782   0F00 FD 77         inc b
1783   0F02 FA FD FF      lea d, [bp + -3] ; $format_p
1784   0F05 FD 43         mov [d], b
1785   0F07 FD 7D         dec b
1786   0F09             _if19_exit:
1787   0F09             _if18_exit:
1788   0F09             _for17_update:
1789   0F09 0A 65 0C      jmp _for17_cond
1790   0F0C             _for17_exit:
1791   0F0C F9            leave
1792   0F0D 09            ret
1793   0F0E             
1794   0F0E             sprintf:
1795   0F0E F8 00 00      enter 0 ; (push bp; mov bp, sp)
1796   0F11             ; char *p, *format_p; 
1797   0F11 52 02 00      sub sp, 2
1798   0F14 52 02 00      sub sp, 2
1799   0F17             ; char *sp; 
1800   0F17 52 02 00      sub sp, 2
1801   0F1A             ; sp = dest; 
1802   0F1A FA FB FF      lea d, [bp + -5] ; $sp
1803   0F1D DA            push d
1804   0F1E FA 05 00      lea d, [bp + 5] ; $dest
1805   0F21 2A            mov b, [d]
1806   0F22 38 00 00      mov c, 0
1807   0F25 E7            pop d
1808   0F26 FD 43         mov [d], b
1809   0F28             ; format_p = format; 
1810   0F28 FA FD FF      lea d, [bp + -3] ; $format_p
1811   0F2B DA            push d
1812   0F2C FA 07 00      lea d, [bp + 7] ; $format
1813   0F2F 2A            mov b, [d]
1814   0F30 38 00 00      mov c, 0
1815   0F33 E7            pop d
1816   0F34 FD 43         mov [d], b
1817   0F36             ; p = &format + 2; 
1818   0F36 FA FF FF      lea d, [bp + -1] ; $p
1819   0F39 DA            push d
1820   0F3A FA 07 00      lea d, [bp + 7] ; $format
1821   0F3D 2D            mov b, d
1822   0F3E             ; --- START TERMS
1823   0F3E D7            push a
1824   0F3F 11            mov a, b
1825   0F40 FD 2E 02 00   mov32 cb, $00000002
1825   0F44 00 00 
1826   0F46 56            add b, a
1827   0F47 E4            pop a
1828   0F48             ; --- END TERMS
1829   0F48 E7            pop d
1830   0F49 FD 43         mov [d], b
1831   0F4B             ; for(;;){ 
1832   0F4B             _for24_init:
1833   0F4B             _for24_cond:
1834   0F4B             _for24_block:
1835   0F4B             ; if(!*format_p) break; 
1836   0F4B             _if25_cond:
1837   0F4B FA FD FF      lea d, [bp + -3] ; $format_p
1838   0F4E 2A            mov b, [d]
1839   0F4F 38 00 00      mov c, 0
1840   0F52 74            mov d, b
1841   0F53 32            mov bl, [d]
1842   0F54 A7 00         mov bh, 0
1843   0F56 38 00 00      mov c, 0
1844   0F59 C0 00 00      cmp b, 0
1845   0F5C FD 71         seq ; !
1846   0F5E C0 00 00      cmp b, 0
1847   0F61 C6 6A 0F      je _if25_else
1848   0F64             _if25_true:
1849   0F64             ; break; 
1850   0F64 0A A0 12      jmp _for24_exit ; for break
1851   0F67 0A 9D 12      jmp _if25_exit
1852   0F6A             _if25_else:
1853   0F6A             ; if(*format_p == '%'){ 
1854   0F6A             _if26_cond:
1855   0F6A FA FD FF      lea d, [bp + -3] ; $format_p
1856   0F6D 2A            mov b, [d]
1857   0F6E 38 00 00      mov c, 0
1858   0F71 74            mov d, b
1859   0F72 32            mov bl, [d]
1860   0F73 A7 00         mov bh, 0
1861   0F75 38 00 00      mov c, 0
1862   0F78             ; --- START RELATIONAL
1863   0F78 D7            push a
1864   0F79 11            mov a, b
1865   0F7A FD 2E 25 00   mov32 cb, $00000025
1865   0F7E 00 00 
1866   0F80 B0            cmp a, b
1867   0F81 FD 71         seq ; ==
1868   0F83 E4            pop a
1869   0F84             ; --- END RELATIONAL
1870   0F84 C0 00 00      cmp b, 0
1871   0F87 C6 72 12      je _if26_else
1872   0F8A             _if26_true:
1873   0F8A             ; format_p++; 
1874   0F8A FA FD FF      lea d, [bp + -3] ; $format_p
1875   0F8D 2A            mov b, [d]
1876   0F8E 38 00 00      mov c, 0
1877   0F91 FD 77         inc b
1878   0F93 FA FD FF      lea d, [bp + -3] ; $format_p
1879   0F96 FD 43         mov [d], b
1880   0F98 FD 7D         dec b
1881   0F9A             ; switch(*format_p){ 
1882   0F9A             _switch27_expr:
1883   0F9A FA FD FF      lea d, [bp + -3] ; $format_p
1884   0F9D 2A            mov b, [d]
1885   0F9E 38 00 00      mov c, 0
1886   0FA1 74            mov d, b
1887   0FA2 32            mov bl, [d]
1888   0FA3 A7 00         mov bh, 0
1889   0FA5 38 00 00      mov c, 0
1890   0FA8             _switch27_comparisons:
1891   0FA8 C1 6C         cmp bl, $6c
1892   0FAA C6 D6 0F      je _switch27_case0
1893   0FAD C1 4C         cmp bl, $4c
1894   0FAF C6 D6 0F      je _switch27_case1
1895   0FB2 C1 64         cmp bl, $64
1896   0FB4 C6 EE 10      je _switch27_case2
1897   0FB7 C1 69         cmp bl, $69
1898   0FB9 C6 EE 10      je _switch27_case3
1899   0FBC C1 75         cmp bl, $75
1900   0FBE C6 3A 11      je _switch27_case4
1901   0FC1 C1 78         cmp bl, $78
1902   0FC3 C6 86 11      je _switch27_case5
1903   0FC6 C1 63         cmp bl, $63
1904   0FC8 C6 AA 11      je _switch27_case6
1905   0FCB C1 73         cmp bl, $73
1906   0FCD C6 E7 11      je _switch27_case7
1907   0FD0 0A 53 12      jmp _switch27_default
1908   0FD3 0A 5F 12      jmp _switch27_exit
1909   0FD6             _switch27_case0:
1910   0FD6             _switch27_case1:
1911   0FD6             ; format_p++; 
1912   0FD6 FA FD FF      lea d, [bp + -3] ; $format_p
1913   0FD9 2A            mov b, [d]
1914   0FDA 38 00 00      mov c, 0
1915   0FDD FD 77         inc b
1916   0FDF FA FD FF      lea d, [bp + -3] ; $format_p
1917   0FE2 FD 43         mov [d], b
1918   0FE4 FD 7D         dec b
1919   0FE6             ; if(*format_p == 'd' || *format_p == 'i') 
1920   0FE6             _if28_cond:
1921   0FE6 FA FD FF      lea d, [bp + -3] ; $format_p
1922   0FE9 2A            mov b, [d]
1923   0FEA 38 00 00      mov c, 0
1924   0FED 74            mov d, b
1925   0FEE 32            mov bl, [d]
1926   0FEF A7 00         mov bh, 0
1927   0FF1 38 00 00      mov c, 0
1928   0FF4             ; --- START RELATIONAL
1929   0FF4 D7            push a
1930   0FF5 11            mov a, b
1931   0FF6 FD 2E 64 00   mov32 cb, $00000064
1931   0FFA 00 00 
1932   0FFC B0            cmp a, b
1933   0FFD FD 71         seq ; ==
1934   0FFF E4            pop a
1935   1000             ; --- END RELATIONAL
1936   1000             ; --- START LOGICAL OR
1937   1000 D7            push a
1938   1001 11            mov a, b
1939   1002 FA FD FF      lea d, [bp + -3] ; $format_p
1940   1005 2A            mov b, [d]
1941   1006 38 00 00      mov c, 0
1942   1009 74            mov d, b
1943   100A 32            mov bl, [d]
1944   100B A7 00         mov bh, 0
1945   100D 38 00 00      mov c, 0
1946   1010             ; --- START RELATIONAL
1947   1010 D7            push a
1948   1011 11            mov a, b
1949   1012 FD 2E 69 00   mov32 cb, $00000069
1949   1016 00 00 
1950   1018 B0            cmp a, b
1951   1019 FD 71         seq ; ==
1952   101B E4            pop a
1953   101C             ; --- END RELATIONAL
1954   101C FD A8         sor a, b ; ||
1955   101E E4            pop a
1956   101F             ; --- END LOGICAL OR
1957   101F C0 00 00      cmp b, 0
1958   1022 C6 46 10      je _if28_else
1959   1025             _if28_true:
1960   1025             ; print_signed_long(*(long *)p); 
1961   1025             ; --- START FUNCTION CALL
1962   1025 FA FF FF      lea d, [bp + -1] ; $p
1963   1028 2A            mov b, [d]
1964   1029 38 00 00      mov c, 0
1965   102C AB            snex b
1966   102D FD 39         mov c, b
1967   102F 74            mov d, b
1968   1030 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1969   1033 FD 39         mov c, b ; And place it into C
1970   1035 2A            mov b, [d] ; Lower Word in B
1971   1036 12            mov a, c
1972   1037 FD AA         swp a
1973   1039 D7            push a
1974   103A FD AB         swp b
1975   103C D8            push b
1976   103D 07 06 16      call print_signed_long
1977   1040 51 04 00      add sp, 4
1978   1043             ; --- END FUNCTION CALL
1979   1043 0A D3 10      jmp _if28_exit
1980   1046             _if28_else:
1981   1046             ; if(*format_p == 'u') 
1982   1046             _if29_cond:
1983   1046 FA FD FF      lea d, [bp + -3] ; $format_p
1984   1049 2A            mov b, [d]
1985   104A 38 00 00      mov c, 0
1986   104D 74            mov d, b
1987   104E 32            mov bl, [d]
1988   104F A7 00         mov bh, 0
1989   1051 38 00 00      mov c, 0
1990   1054             ; --- START RELATIONAL
1991   1054 D7            push a
1992   1055 11            mov a, b
1993   1056 FD 2E 75 00   mov32 cb, $00000075
1993   105A 00 00 
1994   105C B0            cmp a, b
1995   105D FD 71         seq ; ==
1996   105F E4            pop a
1997   1060             ; --- END RELATIONAL
1998   1060 C0 00 00      cmp b, 0
1999   1063 C6 89 10      je _if29_else
2000   1066             _if29_true:
2001   1066             ; print_unsigned_long(*(unsigned long *)p); 
2002   1066             ; --- START FUNCTION CALL
2003   1066 FA FF FF      lea d, [bp + -1] ; $p
2004   1069 2A            mov b, [d]
2005   106A 38 00 00      mov c, 0
2006   106D A7 00         mov bh, 0
2007   106F 38 00 00      mov c, 0
2008   1072 74            mov d, b
2009   1073 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2010   1076 FD 39         mov c, b ; And place it into C
2011   1078 2A            mov b, [d] ; Lower Word in B
2012   1079 12            mov a, c
2013   107A FD AA         swp a
2014   107C D7            push a
2015   107D FD AB         swp b
2016   107F D8            push b
2017   1080 07 6D 17      call print_unsigned_long
2018   1083 51 04 00      add sp, 4
2019   1086             ; --- END FUNCTION CALL
2020   1086 0A D3 10      jmp _if29_exit
2021   1089             _if29_else:
2022   1089             ; if(*format_p == 'x') 
2023   1089             _if30_cond:
2024   1089 FA FD FF      lea d, [bp + -3] ; $format_p
2025   108C 2A            mov b, [d]
2026   108D 38 00 00      mov c, 0
2027   1090 74            mov d, b
2028   1091 32            mov bl, [d]
2029   1092 A7 00         mov bh, 0
2030   1094 38 00 00      mov c, 0
2031   1097             ; --- START RELATIONAL
2032   1097 D7            push a
2033   1098 11            mov a, b
2034   1099 FD 2E 78 00   mov32 cb, $00000078
2034   109D 00 00 
2035   109F B0            cmp a, b
2036   10A0 FD 71         seq ; ==
2037   10A2 E4            pop a
2038   10A3             ; --- END RELATIONAL
2039   10A3 C0 00 00      cmp b, 0
2040   10A6 C6 C7 10      je _if30_else
2041   10A9             _if30_true:
2042   10A9             ; printx32(*(long int *)p); 
2043   10A9             ; --- START FUNCTION CALL
2044   10A9 FA FF FF      lea d, [bp + -1] ; $p
2045   10AC 2A            mov b, [d]
2046   10AD 38 00 00      mov c, 0
2047   10B0 74            mov d, b
2048   10B1 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2049   10B4 FD 39         mov c, b ; And place it into C
2050   10B6 2A            mov b, [d] ; Lower Word in B
2051   10B7 12            mov a, c
2052   10B8 FD AA         swp a
2053   10BA D7            push a
2054   10BB FD AB         swp b
2055   10BD D8            push b
2056   10BE 07 DB 12      call printx32
2057   10C1 51 04 00      add sp, 4
2058   10C4             ; --- END FUNCTION CALL
2059   10C4 0A D3 10      jmp _if30_exit
2060   10C7             _if30_else:
2061   10C7             ; err("Unexpected format in printf."); 
2062   10C7             ; --- START FUNCTION CALL
2063   10C7 26 58 21      mov b, _s0 ; "Unexpected format in printf."
2064   10CA FD AB         swp b
2065   10CC D8            push b
2066   10CD 07 C6 12      call err
2067   10D0 51 02 00      add sp, 2
2068   10D3             ; --- END FUNCTION CALL
2069   10D3             _if30_exit:
2070   10D3             _if29_exit:
2071   10D3             _if28_exit:
2072   10D3             ; p = p + 4; 
2073   10D3 FA FF FF      lea d, [bp + -1] ; $p
2074   10D6 DA            push d
2075   10D7 FA FF FF      lea d, [bp + -1] ; $p
2076   10DA 2A            mov b, [d]
2077   10DB 38 00 00      mov c, 0
2078   10DE             ; --- START TERMS
2079   10DE D7            push a
2080   10DF 11            mov a, b
2081   10E0 FD 2E 04 00   mov32 cb, $00000004
2081   10E4 00 00 
2082   10E6 56            add b, a
2083   10E7 E4            pop a
2084   10E8             ; --- END TERMS
2085   10E8 E7            pop d
2086   10E9 FD 43         mov [d], b
2087   10EB             ; break; 
2088   10EB 0A 5F 12      jmp _switch27_exit ; case break
2089   10EE             _switch27_case2:
2090   10EE             _switch27_case3:
2091   10EE             ; sp = sp + sprint_signed(sp, *(int*)p); 
2092   10EE FA FB FF      lea d, [bp + -5] ; $sp
2093   10F1 DA            push d
2094   10F2 FA FB FF      lea d, [bp + -5] ; $sp
2095   10F5 2A            mov b, [d]
2096   10F6 38 00 00      mov c, 0
2097   10F9             ; --- START TERMS
2098   10F9 D7            push a
2099   10FA 11            mov a, b
2100   10FB             ; --- START FUNCTION CALL
2101   10FB FA FF FF      lea d, [bp + -1] ; $p
2102   10FE 2A            mov b, [d]
2103   10FF 38 00 00      mov c, 0
2104   1102 74            mov d, b
2105   1103 2A            mov b, [d]
2106   1104 38 00 00      mov c, 0
2107   1107 FD AB         swp b
2108   1109 D8            push b
2109   110A FA FB FF      lea d, [bp + -5] ; $sp
2110   110D 2A            mov b, [d]
2111   110E 38 00 00      mov c, 0
2112   1111 FD AB         swp b
2113   1113 D8            push b
2114   1114 07 E1 1A      call sprint_signed
2115   1117 51 04 00      add sp, 4
2116   111A             ; --- END FUNCTION CALL
2117   111A 56            add b, a
2118   111B E4            pop a
2119   111C             ; --- END TERMS
2120   111C E7            pop d
2121   111D FD 43         mov [d], b
2122   111F             ; p = p + 2; 
2123   111F FA FF FF      lea d, [bp + -1] ; $p
2124   1122 DA            push d
2125   1123 FA FF FF      lea d, [bp + -1] ; $p
2126   1126 2A            mov b, [d]
2127   1127 38 00 00      mov c, 0
2128   112A             ; --- START TERMS
2129   112A D7            push a
2130   112B 11            mov a, b
2131   112C FD 2E 02 00   mov32 cb, $00000002
2131   1130 00 00 
2132   1132 56            add b, a
2133   1133 E4            pop a
2134   1134             ; --- END TERMS
2135   1134 E7            pop d
2136   1135 FD 43         mov [d], b
2137   1137             ; break; 
2138   1137 0A 5F 12      jmp _switch27_exit ; case break
2139   113A             _switch27_case4:
2140   113A             ; sp = sp + sprint_unsigned(sp, *(unsigned int*)p); 
2141   113A FA FB FF      lea d, [bp + -5] ; $sp
2142   113D DA            push d
2143   113E FA FB FF      lea d, [bp + -5] ; $sp
2144   1141 2A            mov b, [d]
2145   1142 38 00 00      mov c, 0
2146   1145             ; --- START TERMS
2147   1145 D7            push a
2148   1146 11            mov a, b
2149   1147             ; --- START FUNCTION CALL
2150   1147 FA FF FF      lea d, [bp + -1] ; $p
2151   114A 2A            mov b, [d]
2152   114B 38 00 00      mov c, 0
2153   114E 74            mov d, b
2154   114F 2A            mov b, [d]
2155   1150 38 00 00      mov c, 0
2156   1153 FD AB         swp b
2157   1155 D8            push b
2158   1156 FA FB FF      lea d, [bp + -5] ; $sp
2159   1159 2A            mov b, [d]
2160   115A 38 00 00      mov c, 0
2161   115D FD AB         swp b
2162   115F D8            push b
2163   1160 07 89 18      call sprint_unsigned
2164   1163 51 04 00      add sp, 4
2165   1166             ; --- END FUNCTION CALL
2166   1166 56            add b, a
2167   1167 E4            pop a
2168   1168             ; --- END TERMS
2169   1168 E7            pop d
2170   1169 FD 43         mov [d], b
2171   116B             ; p = p + 2; 
2172   116B FA FF FF      lea d, [bp + -1] ; $p
2173   116E DA            push d
2174   116F FA FF FF      lea d, [bp + -1] ; $p
2175   1172 2A            mov b, [d]
2176   1173 38 00 00      mov c, 0
2177   1176             ; --- START TERMS
2178   1176 D7            push a
2179   1177 11            mov a, b
2180   1178 FD 2E 02 00   mov32 cb, $00000002
2180   117C 00 00 
2181   117E 56            add b, a
2182   117F E4            pop a
2183   1180             ; --- END TERMS
2184   1180 E7            pop d
2185   1181 FD 43         mov [d], b
2186   1183             ; break; 
2187   1183 0A 5F 12      jmp _switch27_exit ; case break
2188   1186             _switch27_case5:
2189   1186             
2190   1186             ; --- BEGIN INLINE ASM SEGMENT
2191   1186 FA FF FF      lea d, [bp + -1] ; $p
2192   1189 FD 2A         mov d, [d]
2193   118B 2A            mov b, [d]
2194   118C 07 56 20      call print_u16x
2195   118F             ; --- END INLINE ASM SEGMENT
2196   118F             
2197   118F             ; p = p + 2; 
2198   118F FA FF FF      lea d, [bp + -1] ; $p
2199   1192 DA            push d
2200   1193 FA FF FF      lea d, [bp + -1] ; $p
2201   1196 2A            mov b, [d]
2202   1197 38 00 00      mov c, 0
2203   119A             ; --- START TERMS
2204   119A D7            push a
2205   119B 11            mov a, b
2206   119C FD 2E 02 00   mov32 cb, $00000002
2206   11A0 00 00 
2207   11A2 56            add b, a
2208   11A3 E4            pop a
2209   11A4             ; --- END TERMS
2210   11A4 E7            pop d
2211   11A5 FD 43         mov [d], b
2212   11A7             ; break; 
2213   11A7 0A 5F 12      jmp _switch27_exit ; case break
2214   11AA             _switch27_case6:
2215   11AA             ; *sp++ = *(char *)p; 
2216   11AA FA FB FF      lea d, [bp + -5] ; $sp
2217   11AD 2A            mov b, [d]
2218   11AE 38 00 00      mov c, 0
2219   11B1 FD 77         inc b
2220   11B3 FA FB FF      lea d, [bp + -5] ; $sp
2221   11B6 FD 43         mov [d], b
2222   11B8 FD 7D         dec b
2223   11BA D8            push b
2224   11BB FA FF FF      lea d, [bp + -1] ; $p
2225   11BE 2A            mov b, [d]
2226   11BF 38 00 00      mov c, 0
2227   11C2 74            mov d, b
2228   11C3 32            mov bl, [d]
2229   11C4 A7 00         mov bh, 0
2230   11C6 38 00 00      mov c, 0
2231   11C9 E7            pop d
2232   11CA FD 3E         mov [d], bl
2233   11CC             ; p = p + 1; 
2234   11CC FA FF FF      lea d, [bp + -1] ; $p
2235   11CF DA            push d
2236   11D0 FA FF FF      lea d, [bp + -1] ; $p
2237   11D3 2A            mov b, [d]
2238   11D4 38 00 00      mov c, 0
2239   11D7             ; --- START TERMS
2240   11D7 D7            push a
2241   11D8 11            mov a, b
2242   11D9 FD 2E 01 00   mov32 cb, $00000001
2242   11DD 00 00 
2243   11DF 56            add b, a
2244   11E0 E4            pop a
2245   11E1             ; --- END TERMS
2246   11E1 E7            pop d
2247   11E2 FD 43         mov [d], b
2248   11E4             ; break; 
2249   11E4 0A 5F 12      jmp _switch27_exit ; case break
2250   11E7             _switch27_case7:
2251   11E7             ; int len = strlen(*(char **)p); 
2252   11E7 52 02 00      sub sp, 2
2253   11EA             ; --- START LOCAL VAR INITIALIZATION
2254   11EA FA F9 FF      lea d, [bp + -7] ; $len
2255   11ED DA            push d
2256   11EE             ; --- START FUNCTION CALL
2257   11EE FA FF FF      lea d, [bp + -1] ; $p
2258   11F1 2A            mov b, [d]
2259   11F2 38 00 00      mov c, 0
2260   11F5 74            mov d, b
2261   11F6 2A            mov b, [d]
2262   11F7 FD AB         swp b
2263   11F9 D8            push b
2264   11FA 07 07 06      call strlen
2265   11FD 51 02 00      add sp, 2
2266   1200             ; --- END FUNCTION CALL
2267   1200 E7            pop d
2268   1201 FD 43         mov [d], b
2269   1203             ; --- END LOCAL VAR INITIALIZATION
2270   1203             ; strcpy(sp, *(char **)p); 
2271   1203             ; --- START FUNCTION CALL
2272   1203 FA FF FF      lea d, [bp + -1] ; $p
2273   1206 2A            mov b, [d]
2274   1207 38 00 00      mov c, 0
2275   120A 74            mov d, b
2276   120B 2A            mov b, [d]
2277   120C FD AB         swp b
2278   120E D8            push b
2279   120F FA FB FF      lea d, [bp + -5] ; $sp
2280   1212 2A            mov b, [d]
2281   1213 38 00 00      mov c, 0
2282   1216 FD AB         swp b
2283   1218 D8            push b
2284   1219 07 21 04      call strcpy
2285   121C 51 04 00      add sp, 4
2286   121F             ; --- END FUNCTION CALL
2287   121F             ; sp = sp + len; 
2288   121F FA FB FF      lea d, [bp + -5] ; $sp
2289   1222 DA            push d
2290   1223 FA FB FF      lea d, [bp + -5] ; $sp
2291   1226 2A            mov b, [d]
2292   1227 38 00 00      mov c, 0
2293   122A             ; --- START TERMS
2294   122A D7            push a
2295   122B 11            mov a, b
2296   122C FA F9 FF      lea d, [bp + -7] ; $len
2297   122F 2A            mov b, [d]
2298   1230 38 00 00      mov c, 0
2299   1233 56            add b, a
2300   1234 E4            pop a
2301   1235             ; --- END TERMS
2302   1235 E7            pop d
2303   1236 FD 43         mov [d], b
2304   1238             ; p = p + 2; 
2305   1238 FA FF FF      lea d, [bp + -1] ; $p
2306   123B DA            push d
2307   123C FA FF FF      lea d, [bp + -1] ; $p
2308   123F 2A            mov b, [d]
2309   1240 38 00 00      mov c, 0
2310   1243             ; --- START TERMS
2311   1243 D7            push a
2312   1244 11            mov a, b
2313   1245 FD 2E 02 00   mov32 cb, $00000002
2313   1249 00 00 
2314   124B 56            add b, a
2315   124C E4            pop a
2316   124D             ; --- END TERMS
2317   124D E7            pop d
2318   124E FD 43         mov [d], b
2319   1250             ; break; 
2320   1250 0A 5F 12      jmp _switch27_exit ; case break
2321   1253             _switch27_default:
2322   1253             ; print("Error: Unknown argument type.\n"); 
2323   1253             ; --- START FUNCTION CALL
2324   1253 26 75 21      mov b, _s1 ; "Error: Unknown argument type.\n"
2325   1256 FD AB         swp b
2326   1258 D8            push b
2327   1259 07 F5 1C      call print
2328   125C 51 02 00      add sp, 2
2329   125F             ; --- END FUNCTION CALL
2330   125F             _switch27_exit:
2331   125F             ; format_p++; 
2332   125F FA FD FF      lea d, [bp + -3] ; $format_p
2333   1262 2A            mov b, [d]
2334   1263 38 00 00      mov c, 0
2335   1266 FD 77         inc b
2336   1268 FA FD FF      lea d, [bp + -3] ; $format_p
2337   126B FD 43         mov [d], b
2338   126D FD 7D         dec b
2339   126F 0A 9D 12      jmp _if26_exit
2340   1272             _if26_else:
2341   1272             ; *sp++ = *format_p++; 
2342   1272 FA FB FF      lea d, [bp + -5] ; $sp
2343   1275 2A            mov b, [d]
2344   1276 38 00 00      mov c, 0
2345   1279 FD 77         inc b
2346   127B FA FB FF      lea d, [bp + -5] ; $sp
2347   127E FD 43         mov [d], b
2348   1280 FD 7D         dec b
2349   1282 D8            push b
2350   1283 FA FD FF      lea d, [bp + -3] ; $format_p
2351   1286 2A            mov b, [d]
2352   1287 38 00 00      mov c, 0
2353   128A FD 77         inc b
2354   128C FA FD FF      lea d, [bp + -3] ; $format_p
2355   128F FD 43         mov [d], b
2356   1291 FD 7D         dec b
2357   1293 74            mov d, b
2358   1294 32            mov bl, [d]
2359   1295 A7 00         mov bh, 0
2360   1297 38 00 00      mov c, 0
2361   129A E7            pop d
2362   129B FD 3E         mov [d], bl
2363   129D             _if26_exit:
2364   129D             _if25_exit:
2365   129D             _for24_update:
2366   129D 0A 4B 0F      jmp _for24_cond
2367   12A0             _for24_exit:
2368   12A0             ; *sp = '\0'; 
2369   12A0 FA FB FF      lea d, [bp + -5] ; $sp
2370   12A3 2A            mov b, [d]
2371   12A4 38 00 00      mov c, 0
2372   12A7 D8            push b
2373   12A8 FD 2E 00 00   mov32 cb, $00000000
2373   12AC 00 00 
2374   12AE E7            pop d
2375   12AF FD 3E         mov [d], bl
2376   12B1             ; return sp - dest; // return total number of chars written 
2377   12B1 FA FB FF      lea d, [bp + -5] ; $sp
2378   12B4 2A            mov b, [d]
2379   12B5 38 00 00      mov c, 0
2380   12B8             ; --- START TERMS
2381   12B8 D7            push a
2382   12B9 11            mov a, b
2383   12BA FA 05 00      lea d, [bp + 5] ; $dest
2384   12BD 2A            mov b, [d]
2385   12BE 38 00 00      mov c, 0
2386   12C1 60            sub a, b
2387   12C2 27            mov b, a
2388   12C3 E4            pop a
2389   12C4             ; --- END TERMS
2390   12C4 F9            leave
2391   12C5 09            ret
2392   12C6             
2393   12C6             err:
2394   12C6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2395   12C9             ; print(e); 
2396   12C9             ; --- START FUNCTION CALL
2397   12C9 FA 05 00      lea d, [bp + 5] ; $e
2398   12CC 2A            mov b, [d]
2399   12CD 38 00 00      mov c, 0
2400   12D0 FD AB         swp b
2401   12D2 D8            push b
2402   12D3 07 F5 1C      call print
2403   12D6 51 02 00      add sp, 2
2404   12D9             ; --- END FUNCTION CALL
2405   12D9 F9            leave
2406   12DA 09            ret
2407   12DB             
2408   12DB             printx32:
2409   12DB F8 00 00      enter 0 ; (push bp; mov bp, sp)
2410   12DE             
2411   12DE             ; --- BEGIN INLINE ASM SEGMENT
2412   12DE FA 05 00      lea d, [bp + 5] ; $hex
2413   12E1 2B 02 00      mov b, [d+2]
2414   12E4 07 56 20      call print_u16x
2415   12E7 2A            mov b, [d]
2416   12E8 07 56 20      call print_u16x
2417   12EB             ; --- END INLINE ASM SEGMENT
2418   12EB             
2419   12EB F9            leave
2420   12EC 09            ret
2421   12ED             
2422   12ED             printx16:
2423   12ED F8 00 00      enter 0 ; (push bp; mov bp, sp)
2424   12F0             
2425   12F0             ; --- BEGIN INLINE ASM SEGMENT
2426   12F0 FA 05 00      lea d, [bp + 5] ; $hex
2427   12F3 2A            mov b, [d]
2428   12F4 07 56 20      call print_u16x
2429   12F7             ; --- END INLINE ASM SEGMENT
2430   12F7             
2431   12F7 F9            leave
2432   12F8 09            ret
2433   12F9             
2434   12F9             printx8:
2435   12F9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2436   12FC             
2437   12FC             ; --- BEGIN INLINE ASM SEGMENT
2438   12FC FA 05 00      lea d, [bp + 5] ; $hex
2439   12FF 32            mov bl, [d]
2440   1300 07 9A 20      call print_u8x
2441   1303             ; --- END INLINE ASM SEGMENT
2442   1303             
2443   1303 F9            leave
2444   1304 09            ret
2445   1305             
2446   1305             hex_str_to_int:
2447   1305 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2448   1308             ; int value = 0; 
2449   1308 52 02 00      sub sp, 2
2450   130B             ; --- START LOCAL VAR INITIALIZATION
2451   130B FA FF FF      lea d, [bp + -1] ; $value
2452   130E DA            push d
2453   130F FD 2E 00 00   mov32 cb, $00000000
2453   1313 00 00 
2454   1315 E7            pop d
2455   1316 FD 43         mov [d], b
2456   1318             ; --- END LOCAL VAR INITIALIZATION
2457   1318             ; int i; 
2458   1318 52 02 00      sub sp, 2
2459   131B             ; char hex_char; 
2460   131B 52 01 00      sub sp, 1
2461   131E             ; int len; 
2462   131E 52 02 00      sub sp, 2
2463   1321             ; len = strlen(hex_string); 
2464   1321 FA FA FF      lea d, [bp + -6] ; $len
2465   1324 DA            push d
2466   1325             ; --- START FUNCTION CALL
2467   1325 FA 05 00      lea d, [bp + 5] ; $hex_string
2468   1328 2A            mov b, [d]
2469   1329 38 00 00      mov c, 0
2470   132C FD AB         swp b
2471   132E D8            push b
2472   132F 07 07 06      call strlen
2473   1332 51 02 00      add sp, 2
2474   1335             ; --- END FUNCTION CALL
2475   1335 E7            pop d
2476   1336 FD 43         mov [d], b
2477   1338             ; for (i = 0; i < len; i++) { 
2478   1338             _for31_init:
2479   1338 FA FD FF      lea d, [bp + -3] ; $i
2480   133B DA            push d
2481   133C FD 2E 00 00   mov32 cb, $00000000
2481   1340 00 00 
2482   1342 E7            pop d
2483   1343 FD 43         mov [d], b
2484   1345             _for31_cond:
2485   1345 FA FD FF      lea d, [bp + -3] ; $i
2486   1348 2A            mov b, [d]
2487   1349 38 00 00      mov c, 0
2488   134C             ; --- START RELATIONAL
2489   134C D7            push a
2490   134D 11            mov a, b
2491   134E FA FA FF      lea d, [bp + -6] ; $len
2492   1351 2A            mov b, [d]
2493   1352 38 00 00      mov c, 0
2494   1355 B0            cmp a, b
2495   1356 FD 73         slt ; < (signed)
2496   1358 E4            pop a
2497   1359             ; --- END RELATIONAL
2498   1359 C0 00 00      cmp b, 0
2499   135C C6 A9 14      je _for31_exit
2500   135F             _for31_block:
2501   135F             ; hex_char = hex_string[i]; 
2502   135F FA FC FF      lea d, [bp + -4] ; $hex_char
2503   1362 DA            push d
2504   1363 FA 05 00      lea d, [bp + 5] ; $hex_string
2505   1366 FD 2A         mov d, [d]
2506   1368 D7            push a
2507   1369 DA            push d
2508   136A FA FD FF      lea d, [bp + -3] ; $i
2509   136D 2A            mov b, [d]
2510   136E 38 00 00      mov c, 0
2511   1371 E7            pop d
2512   1372 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
2513   1376 E4            pop a
2514   1377 32            mov bl, [d]
2515   1378 A7 00         mov bh, 0
2516   137A 38 00 00      mov c, 0
2517   137D E7            pop d
2518   137E FD 3E         mov [d], bl
2519   1380             ; if (hex_char >= 'a' && hex_char <= 'f')  
2520   1380             _if32_cond:
2521   1380 FA FC FF      lea d, [bp + -4] ; $hex_char
2522   1383 32            mov bl, [d]
2523   1384 A7 00         mov bh, 0
2524   1386 38 00 00      mov c, 0
2525   1389             ; --- START RELATIONAL
2526   1389 D7            push a
2527   138A 11            mov a, b
2528   138B FD 2E 61 00   mov32 cb, $00000061
2528   138F 00 00 
2529   1391 B0            cmp a, b
2530   1392 FD 80         sge ; >=
2531   1394 E4            pop a
2532   1395             ; --- END RELATIONAL
2533   1395             ; --- START LOGICAL AND
2534   1395 D7            push a
2535   1396 11            mov a, b
2536   1397 FA FC FF      lea d, [bp + -4] ; $hex_char
2537   139A 32            mov bl, [d]
2538   139B A7 00         mov bh, 0
2539   139D 38 00 00      mov c, 0
2540   13A0             ; --- START RELATIONAL
2541   13A0 D7            push a
2542   13A1 11            mov a, b
2543   13A2 FD 2E 66 00   mov32 cb, $00000066
2543   13A6 00 00 
2544   13A8 B0            cmp a, b
2545   13A9 FD 74         sle ; <= (signed)
2546   13AB E4            pop a
2547   13AC             ; --- END RELATIONAL
2548   13AC FD A7         sand a, b
2549   13AE E4            pop a
2550   13AF             ; --- END LOGICAL AND
2551   13AF C0 00 00      cmp b, 0
2552   13B2 C6 F2 13      je _if32_else
2553   13B5             _if32_true:
2554   13B5             ; value = (value * 16) + (hex_char - 'a' + 10); 
2555   13B5 FA FF FF      lea d, [bp + -1] ; $value
2556   13B8 DA            push d
2557   13B9 FA FF FF      lea d, [bp + -1] ; $value
2558   13BC 2A            mov b, [d]
2559   13BD 38 00 00      mov c, 0
2560   13C0             ; --- START FACTORS
2561   13C0 D7            push a
2562   13C1 11            mov a, b
2563   13C2 FD 2E 10 00   mov32 cb, $00000010
2563   13C6 00 00 
2564   13C8 AC            mul a, b ; *
2565   13C9 11            mov a, b
2566   13CA 27            mov b, a
2567   13CB E4            pop a
2568   13CC             ; --- END FACTORS
2569   13CC             ; --- START TERMS
2570   13CC D7            push a
2571   13CD 11            mov a, b
2572   13CE FA FC FF      lea d, [bp + -4] ; $hex_char
2573   13D1 32            mov bl, [d]
2574   13D2 A7 00         mov bh, 0
2575   13D4 38 00 00      mov c, 0
2576   13D7             ; --- START TERMS
2577   13D7 D7            push a
2578   13D8 11            mov a, b
2579   13D9 FD 2E 61 00   mov32 cb, $00000061
2579   13DD 00 00 
2580   13DF 60            sub a, b
2581   13E0 27            mov b, a
2582   13E1 11            mov a, b
2583   13E2 FD 2E 0A 00   mov32 cb, $0000000a
2583   13E6 00 00 
2584   13E8 56            add b, a
2585   13E9 E4            pop a
2586   13EA             ; --- END TERMS
2587   13EA 56            add b, a
2588   13EB E4            pop a
2589   13EC             ; --- END TERMS
2590   13EC E7            pop d
2591   13ED FD 43         mov [d], b
2592   13EF 0A 96 14      jmp _if32_exit
2593   13F2             _if32_else:
2594   13F2             ; if (hex_char >= 'A' && hex_char <= 'F')  
2595   13F2             _if33_cond:
2596   13F2 FA FC FF      lea d, [bp + -4] ; $hex_char
2597   13F5 32            mov bl, [d]
2598   13F6 A7 00         mov bh, 0
2599   13F8 38 00 00      mov c, 0
2600   13FB             ; --- START RELATIONAL
2601   13FB D7            push a
2602   13FC 11            mov a, b
2603   13FD FD 2E 41 00   mov32 cb, $00000041
2603   1401 00 00 
2604   1403 B0            cmp a, b
2605   1404 FD 80         sge ; >=
2606   1406 E4            pop a
2607   1407             ; --- END RELATIONAL
2608   1407             ; --- START LOGICAL AND
2609   1407 D7            push a
2610   1408 11            mov a, b
2611   1409 FA FC FF      lea d, [bp + -4] ; $hex_char
2612   140C 32            mov bl, [d]
2613   140D A7 00         mov bh, 0
2614   140F 38 00 00      mov c, 0
2615   1412             ; --- START RELATIONAL
2616   1412 D7            push a
2617   1413 11            mov a, b
2618   1414 FD 2E 46 00   mov32 cb, $00000046
2618   1418 00 00 
2619   141A B0            cmp a, b
2620   141B FD 74         sle ; <= (signed)
2621   141D E4            pop a
2622   141E             ; --- END RELATIONAL
2623   141E FD A7         sand a, b
2624   1420 E4            pop a
2625   1421             ; --- END LOGICAL AND
2626   1421 C0 00 00      cmp b, 0
2627   1424 C6 64 14      je _if33_else
2628   1427             _if33_true:
2629   1427             ; value = (value * 16) + (hex_char - 'A' + 10); 
2630   1427 FA FF FF      lea d, [bp + -1] ; $value
2631   142A DA            push d
2632   142B FA FF FF      lea d, [bp + -1] ; $value
2633   142E 2A            mov b, [d]
2634   142F 38 00 00      mov c, 0
2635   1432             ; --- START FACTORS
2636   1432 D7            push a
2637   1433 11            mov a, b
2638   1434 FD 2E 10 00   mov32 cb, $00000010
2638   1438 00 00 
2639   143A AC            mul a, b ; *
2640   143B 11            mov a, b
2641   143C 27            mov b, a
2642   143D E4            pop a
2643   143E             ; --- END FACTORS
2644   143E             ; --- START TERMS
2645   143E D7            push a
2646   143F 11            mov a, b
2647   1440 FA FC FF      lea d, [bp + -4] ; $hex_char
2648   1443 32            mov bl, [d]
2649   1444 A7 00         mov bh, 0
2650   1446 38 00 00      mov c, 0
2651   1449             ; --- START TERMS
2652   1449 D7            push a
2653   144A 11            mov a, b
2654   144B FD 2E 41 00   mov32 cb, $00000041
2654   144F 00 00 
2655   1451 60            sub a, b
2656   1452 27            mov b, a
2657   1453 11            mov a, b
2658   1454 FD 2E 0A 00   mov32 cb, $0000000a
2658   1458 00 00 
2659   145A 56            add b, a
2660   145B E4            pop a
2661   145C             ; --- END TERMS
2662   145C 56            add b, a
2663   145D E4            pop a
2664   145E             ; --- END TERMS
2665   145E E7            pop d
2666   145F FD 43         mov [d], b
2667   1461 0A 96 14      jmp _if33_exit
2668   1464             _if33_else:
2669   1464             ; value = (value * 16) + (hex_char - '0'); 
2670   1464 FA FF FF      lea d, [bp + -1] ; $value
2671   1467 DA            push d
2672   1468 FA FF FF      lea d, [bp + -1] ; $value
2673   146B 2A            mov b, [d]
2674   146C 38 00 00      mov c, 0
2675   146F             ; --- START FACTORS
2676   146F D7            push a
2677   1470 11            mov a, b
2678   1471 FD 2E 10 00   mov32 cb, $00000010
2678   1475 00 00 
2679   1477 AC            mul a, b ; *
2680   1478 11            mov a, b
2681   1479 27            mov b, a
2682   147A E4            pop a
2683   147B             ; --- END FACTORS
2684   147B             ; --- START TERMS
2685   147B D7            push a
2686   147C 11            mov a, b
2687   147D FA FC FF      lea d, [bp + -4] ; $hex_char
2688   1480 32            mov bl, [d]
2689   1481 A7 00         mov bh, 0
2690   1483 38 00 00      mov c, 0
2691   1486             ; --- START TERMS
2692   1486 D7            push a
2693   1487 11            mov a, b
2694   1488 FD 2E 30 00   mov32 cb, $00000030
2694   148C 00 00 
2695   148E 60            sub a, b
2696   148F 27            mov b, a
2697   1490 E4            pop a
2698   1491             ; --- END TERMS
2699   1491 56            add b, a
2700   1492 E4            pop a
2701   1493             ; --- END TERMS
2702   1493 E7            pop d
2703   1494 FD 43         mov [d], b
2704   1496             _if33_exit:
2705   1496             _if32_exit:
2706   1496             _for31_update:
2707   1496 FA FD FF      lea d, [bp + -3] ; $i
2708   1499 2A            mov b, [d]
2709   149A 38 00 00      mov c, 0
2710   149D FD 77         inc b
2711   149F FA FD FF      lea d, [bp + -3] ; $i
2712   14A2 FD 43         mov [d], b
2713   14A4 FD 7D         dec b
2714   14A6 0A 45 13      jmp _for31_cond
2715   14A9             _for31_exit:
2716   14A9             ; return value; 
2717   14A9 FA FF FF      lea d, [bp + -1] ; $value
2718   14AC 2A            mov b, [d]
2719   14AD 38 00 00      mov c, 0
2720   14B0 F9            leave
2721   14B1 09            ret
2722   14B2             
2723   14B2             gets:
2724   14B2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2725   14B5             
2726   14B5             ; --- BEGIN INLINE ASM SEGMENT
2727   14B5 FA 05 00      lea d, [bp + 5] ; $s
2728   14B8 15            mov a, [d]
2729   14B9 3C            mov d, a
2730   14BA 07 BB 1E      call _gets
2731   14BD             ; --- END INLINE ASM SEGMENT
2732   14BD             
2733   14BD             ; return strlen(s); 
2734   14BD             ; --- START FUNCTION CALL
2735   14BD FA 05 00      lea d, [bp + 5] ; $s
2736   14C0 2A            mov b, [d]
2737   14C1 38 00 00      mov c, 0
2738   14C4 FD AB         swp b
2739   14C6 D8            push b
2740   14C7 07 07 06      call strlen
2741   14CA 51 02 00      add sp, 2
2742   14CD             ; --- END FUNCTION CALL
2743   14CD F9            leave
2744   14CE 09            ret
2745   14CF             
2746   14CF             print_signed:
2747   14CF F8 00 00      enter 0 ; (push bp; mov bp, sp)
2748   14D2             ; char digits[5]; 
2749   14D2 52 05 00      sub sp, 5
2750   14D5             ; int i = 0; 
2751   14D5 52 02 00      sub sp, 2
2752   14D8             ; --- START LOCAL VAR INITIALIZATION
2753   14D8 FA FA FF      lea d, [bp + -6] ; $i
2754   14DB DA            push d
2755   14DC FD 2E 00 00   mov32 cb, $00000000
2755   14E0 00 00 
2756   14E2 E7            pop d
2757   14E3 FD 43         mov [d], b
2758   14E5             ; --- END LOCAL VAR INITIALIZATION
2759   14E5             ; if (num < 0) { 
2760   14E5             _if34_cond:
2761   14E5 FA 05 00      lea d, [bp + 5] ; $num
2762   14E8 2A            mov b, [d]
2763   14E9 38 00 00      mov c, 0
2764   14EC             ; --- START RELATIONAL
2765   14EC D7            push a
2766   14ED 11            mov a, b
2767   14EE FD 2E 00 00   mov32 cb, $00000000
2767   14F2 00 00 
2768   14F4 B0            cmp a, b
2769   14F5 FD 73         slt ; < (signed)
2770   14F7 E4            pop a
2771   14F8             ; --- END RELATIONAL
2772   14F8 C0 00 00      cmp b, 0
2773   14FB C6 1C 15      je _if34_else
2774   14FE             _if34_true:
2775   14FE             ; putchar('-'); 
2776   14FE             ; --- START FUNCTION CALL
2777   14FE FD 2E 2D 00   mov32 cb, $0000002d
2777   1502 00 00 
2778   1504 DD            push bl
2779   1505 07 A7 1C      call putchar
2780   1508 51 01 00      add sp, 1
2781   150B             ; --- END FUNCTION CALL
2782   150B             ; num = -num; 
2783   150B FA 05 00      lea d, [bp + 5] ; $num
2784   150E DA            push d
2785   150F FA 05 00      lea d, [bp + 5] ; $num
2786   1512 2A            mov b, [d]
2787   1513 38 00 00      mov c, 0
2788   1516 E7            pop d
2789   1517 FD 43         mov [d], b
2790   1519 0A 47 15      jmp _if34_exit
2791   151C             _if34_else:
2792   151C             ; if (num == 0) { 
2793   151C             _if35_cond:
2794   151C FA 05 00      lea d, [bp + 5] ; $num
2795   151F 2A            mov b, [d]
2796   1520 38 00 00      mov c, 0
2797   1523             ; --- START RELATIONAL
2798   1523 D7            push a
2799   1524 11            mov a, b
2800   1525 FD 2E 00 00   mov32 cb, $00000000
2800   1529 00 00 
2801   152B B0            cmp a, b
2802   152C FD 71         seq ; ==
2803   152E E4            pop a
2804   152F             ; --- END RELATIONAL
2805   152F C0 00 00      cmp b, 0
2806   1532 C6 47 15      je _if35_exit
2807   1535             _if35_true:
2808   1535             ; putchar('0'); 
2809   1535             ; --- START FUNCTION CALL
2810   1535 FD 2E 30 00   mov32 cb, $00000030
2810   1539 00 00 
2811   153B DD            push bl
2812   153C 07 A7 1C      call putchar
2813   153F 51 01 00      add sp, 1
2814   1542             ; --- END FUNCTION CALL
2815   1542             ; return; 
2816   1542 F9            leave
2817   1543 09            ret
2818   1544 0A 47 15      jmp _if35_exit
2819   1547             _if35_exit:
2820   1547             _if34_exit:
2821   1547             ; while (num > 0) { 
2822   1547             _while36_cond:
2823   1547 FA 05 00      lea d, [bp + 5] ; $num
2824   154A 2A            mov b, [d]
2825   154B 38 00 00      mov c, 0
2826   154E             ; --- START RELATIONAL
2827   154E D7            push a
2828   154F 11            mov a, b
2829   1550 FD 2E 00 00   mov32 cb, $00000000
2829   1554 00 00 
2830   1556 B0            cmp a, b
2831   1557 FD 7F         sgt ; >
2832   1559 E4            pop a
2833   155A             ; --- END RELATIONAL
2834   155A C0 00 00      cmp b, 0
2835   155D C6 BC 15      je _while36_exit
2836   1560             _while36_block:
2837   1560             ; digits[i] = '0' + (num % 10); 
2838   1560 FA FC FF      lea d, [bp + -4] ; $digits
2839   1563 D7            push a
2840   1564 DA            push d
2841   1565 FA FA FF      lea d, [bp + -6] ; $i
2842   1568 2A            mov b, [d]
2843   1569 38 00 00      mov c, 0
2844   156C E7            pop d
2845   156D 5A            add d, b
2846   156E E4            pop a
2847   156F DA            push d
2848   1570 FD 2E 30 00   mov32 cb, $00000030
2848   1574 00 00 
2849   1576             ; --- START TERMS
2850   1576 D7            push a
2851   1577 11            mov a, b
2852   1578 FA 05 00      lea d, [bp + 5] ; $num
2853   157B 2A            mov b, [d]
2854   157C 38 00 00      mov c, 0
2855   157F             ; --- START FACTORS
2856   157F D7            push a
2857   1580 11            mov a, b
2858   1581 FD 2E 0A 00   mov32 cb, $0000000a
2858   1585 00 00 
2859   1587 AE            div a, b ; 
2860   1588 11            mov a, b
2861   1589 27            mov b, a
2862   158A E4            pop a
2863   158B             ; --- END FACTORS
2864   158B 56            add b, a
2865   158C E4            pop a
2866   158D             ; --- END TERMS
2867   158D E7            pop d
2868   158E FD 3E         mov [d], bl
2869   1590             ; num = num / 10; 
2870   1590 FA 05 00      lea d, [bp + 5] ; $num
2871   1593 DA            push d
2872   1594 FA 05 00      lea d, [bp + 5] ; $num
2873   1597 2A            mov b, [d]
2874   1598 38 00 00      mov c, 0
2875   159B             ; --- START FACTORS
2876   159B D7            push a
2877   159C 11            mov a, b
2878   159D FD 2E 0A 00   mov32 cb, $0000000a
2878   15A1 00 00 
2879   15A3 AE            div a, b
2880   15A4 27            mov b, a
2881   15A5 E4            pop a
2882   15A6             ; --- END FACTORS
2883   15A6 E7            pop d
2884   15A7 FD 43         mov [d], b
2885   15A9             ; i++; 
2886   15A9 FA FA FF      lea d, [bp + -6] ; $i
2887   15AC 2A            mov b, [d]
2888   15AD 38 00 00      mov c, 0
2889   15B0 FD 77         inc b
2890   15B2 FA FA FF      lea d, [bp + -6] ; $i
2891   15B5 FD 43         mov [d], b
2892   15B7 FD 7D         dec b
2893   15B9 0A 47 15      jmp _while36_cond
2894   15BC             _while36_exit:
2895   15BC             ; while (i > 0) { 
2896   15BC             _while37_cond:
2897   15BC FA FA FF      lea d, [bp + -6] ; $i
2898   15BF 2A            mov b, [d]
2899   15C0 38 00 00      mov c, 0
2900   15C3             ; --- START RELATIONAL
2901   15C3 D7            push a
2902   15C4 11            mov a, b
2903   15C5 FD 2E 00 00   mov32 cb, $00000000
2903   15C9 00 00 
2904   15CB B0            cmp a, b
2905   15CC FD 7F         sgt ; >
2906   15CE E4            pop a
2907   15CF             ; --- END RELATIONAL
2908   15CF C0 00 00      cmp b, 0
2909   15D2 C6 04 16      je _while37_exit
2910   15D5             _while37_block:
2911   15D5             ; i--; 
2912   15D5 FA FA FF      lea d, [bp + -6] ; $i
2913   15D8 2A            mov b, [d]
2914   15D9 38 00 00      mov c, 0
2915   15DC FD 7D         dec b
2916   15DE FA FA FF      lea d, [bp + -6] ; $i
2917   15E1 FD 43         mov [d], b
2918   15E3 FD 77         inc b
2919   15E5             ; putchar(digits[i]); 
2920   15E5             ; --- START FUNCTION CALL
2921   15E5 FA FC FF      lea d, [bp + -4] ; $digits
2922   15E8 D7            push a
2923   15E9 DA            push d
2924   15EA FA FA FF      lea d, [bp + -6] ; $i
2925   15ED 2A            mov b, [d]
2926   15EE 38 00 00      mov c, 0
2927   15F1 E7            pop d
2928   15F2 5A            add d, b
2929   15F3 E4            pop a
2930   15F4 32            mov bl, [d]
2931   15F5 A7 00         mov bh, 0
2932   15F7 38 00 00      mov c, 0
2933   15FA DD            push bl
2934   15FB 07 A7 1C      call putchar
2935   15FE 51 01 00      add sp, 1
2936   1601             ; --- END FUNCTION CALL
2937   1601 0A BC 15      jmp _while37_cond
2938   1604             _while37_exit:
2939   1604 F9            leave
2940   1605 09            ret
2941   1606             
2942   1606             print_signed_long:
2943   1606 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2944   1609             ; char digits[10]; 
2945   1609 52 0A 00      sub sp, 10
2946   160C             ; int i = 0; 
2947   160C 52 02 00      sub sp, 2
2948   160F             ; --- START LOCAL VAR INITIALIZATION
2949   160F FA F5 FF      lea d, [bp + -11] ; $i
2950   1612 DA            push d
2951   1613 FD 2E 00 00   mov32 cb, $00000000
2951   1617 00 00 
2952   1619 E7            pop d
2953   161A FD 43         mov [d], b
2954   161C             ; --- END LOCAL VAR INITIALIZATION
2955   161C             ; if (num < 0) { 
2956   161C             _if38_cond:
2957   161C FA 05 00      lea d, [bp + 5] ; $num
2958   161F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2959   1622 FD 39         mov c, b ; And place it into C
2960   1624 2A            mov b, [d] ; Lower Word in B
2961   1625             ; --- START RELATIONAL
2962   1625 D7            push a
2963   1626 FD D8         push g
2964   1628 11            mov a, b
2965   1629 FD 7A         mov g, c
2966   162B FD 2E 00 00   mov32 cb, $00000000
2966   162F 00 00 
2967   1631 FD AF         cmp32 ga, cb
2968   1633 FD 73         slt ; <
2969   1635 FD F1         pop g
2970   1637 E4            pop a
2971   1638             ; --- END RELATIONAL
2972   1638 C0 00 00      cmp b, 0
2973   163B C6 67 16      je _if38_else
2974   163E             _if38_true:
2975   163E             ; putchar('-'); 
2976   163E             ; --- START FUNCTION CALL
2977   163E FD 2E 2D 00   mov32 cb, $0000002d
2977   1642 00 00 
2978   1644 DD            push bl
2979   1645 07 A7 1C      call putchar
2980   1648 51 01 00      add sp, 1
2981   164B             ; --- END FUNCTION CALL
2982   164B             ; num = -num; 
2983   164B FA 05 00      lea d, [bp + 5] ; $num
2984   164E DA            push d
2985   164F FA 05 00      lea d, [bp + 5] ; $num
2986   1652 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2987   1655 FD 39         mov c, b ; And place it into C
2988   1657 2A            mov b, [d] ; Lower Word in B
2989   1658 FD 97         neg b
2990   165A E7            pop d
2991   165B FD 43         mov [d], b
2992   165D 26 00 00      mov b, 0
2993   1660 FD 44 02 00   mov [d + 2], b
2994   1664 0A 9B 16      jmp _if38_exit
2995   1667             _if38_else:
2996   1667             ; if (num == 0) { 
2997   1667             _if39_cond:
2998   1667 FA 05 00      lea d, [bp + 5] ; $num
2999   166A 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3000   166D FD 39         mov c, b ; And place it into C
3001   166F 2A            mov b, [d] ; Lower Word in B
3002   1670             ; --- START RELATIONAL
3003   1670 D7            push a
3004   1671 FD D8         push g
3005   1673 11            mov a, b
3006   1674 FD 7A         mov g, c
3007   1676 FD 2E 00 00   mov32 cb, $00000000
3007   167A 00 00 
3008   167C FD AF         cmp32 ga, cb
3009   167E FD 71         seq ; ==
3010   1680 FD F1         pop g
3011   1682 E4            pop a
3012   1683             ; --- END RELATIONAL
3013   1683 C0 00 00      cmp b, 0
3014   1686 C6 9B 16      je _if39_exit
3015   1689             _if39_true:
3016   1689             ; putchar('0'); 
3017   1689             ; --- START FUNCTION CALL
3018   1689 FD 2E 30 00   mov32 cb, $00000030
3018   168D 00 00 
3019   168F DD            push bl
3020   1690 07 A7 1C      call putchar
3021   1693 51 01 00      add sp, 1
3022   1696             ; --- END FUNCTION CALL
3023   1696             ; return; 
3024   1696 F9            leave
3025   1697 09            ret
3026   1698 0A 9B 16      jmp _if39_exit
3027   169B             _if39_exit:
3028   169B             _if38_exit:
3029   169B             ; while (num > 0) { 
3030   169B             _while40_cond:
3031   169B FA 05 00      lea d, [bp + 5] ; $num
3032   169E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3033   16A1 FD 39         mov c, b ; And place it into C
3034   16A3 2A            mov b, [d] ; Lower Word in B
3035   16A4             ; --- START RELATIONAL
3036   16A4 D7            push a
3037   16A5 FD D8         push g
3038   16A7 11            mov a, b
3039   16A8 FD 7A         mov g, c
3040   16AA FD 2E 00 00   mov32 cb, $00000000
3040   16AE 00 00 
3041   16B0 FD AF         cmp32 ga, cb
3042   16B2 FD 7F         sgt
3043   16B4 FD F1         pop g
3044   16B6 E4            pop a
3045   16B7             ; --- END RELATIONAL
3046   16B7 C0 00 00      cmp b, 0
3047   16BA C6 23 17      je _while40_exit
3048   16BD             _while40_block:
3049   16BD             ; digits[i] = '0' + (num % 10); 
3050   16BD FA F7 FF      lea d, [bp + -9] ; $digits
3051   16C0 D7            push a
3052   16C1 DA            push d
3053   16C2 FA F5 FF      lea d, [bp + -11] ; $i
3054   16C5 2A            mov b, [d]
3055   16C6 38 00 00      mov c, 0
3056   16C9 E7            pop d
3057   16CA 5A            add d, b
3058   16CB E4            pop a
3059   16CC DA            push d
3060   16CD FD 2E 30 00   mov32 cb, $00000030
3060   16D1 00 00 
3061   16D3             ; --- START TERMS
3062   16D3 D7            push a
3063   16D4 11            mov a, b
3064   16D5 FA 05 00      lea d, [bp + 5] ; $num
3065   16D8 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3066   16DB FD 39         mov c, b ; And place it into C
3067   16DD 2A            mov b, [d] ; Lower Word in B
3068   16DE             ; --- START FACTORS
3069   16DE D7            push a
3070   16DF 11            mov a, b
3071   16E0 FD 2E 0A 00   mov32 cb, $0000000a
3071   16E4 00 00 
3072   16E6 AE            div a, b ; 
3073   16E7 11            mov a, b
3074   16E8 27            mov b, a
3075   16E9 E4            pop a
3076   16EA             ; --- END FACTORS
3077   16EA FD 15         add32 cb, ga
3078   16EC E4            pop a
3079   16ED             ; --- END TERMS
3080   16ED E7            pop d
3081   16EE FD 3E         mov [d], bl
3082   16F0             ; num = num / 10; 
3083   16F0 FA 05 00      lea d, [bp + 5] ; $num
3084   16F3 DA            push d
3085   16F4 FA 05 00      lea d, [bp + 5] ; $num
3086   16F7 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3087   16FA FD 39         mov c, b ; And place it into C
3088   16FC 2A            mov b, [d] ; Lower Word in B
3089   16FD             ; --- START FACTORS
3090   16FD D7            push a
3091   16FE 11            mov a, b
3092   16FF FD 2E 0A 00   mov32 cb, $0000000a
3092   1703 00 00 
3093   1705 AE            div a, b
3094   1706 27            mov b, a
3095   1707 E4            pop a
3096   1708             ; --- END FACTORS
3097   1708 E7            pop d
3098   1709 FD 43         mov [d], b
3099   170B 28            mov b, c
3100   170C FD 44 02 00   mov [d + 2], b
3101   1710             ; i++; 
3102   1710 FA F5 FF      lea d, [bp + -11] ; $i
3103   1713 2A            mov b, [d]
3104   1714 38 00 00      mov c, 0
3105   1717 FD 77         inc b
3106   1719 FA F5 FF      lea d, [bp + -11] ; $i
3107   171C FD 43         mov [d], b
3108   171E FD 7D         dec b
3109   1720 0A 9B 16      jmp _while40_cond
3110   1723             _while40_exit:
3111   1723             ; while (i > 0) { 
3112   1723             _while41_cond:
3113   1723 FA F5 FF      lea d, [bp + -11] ; $i
3114   1726 2A            mov b, [d]
3115   1727 38 00 00      mov c, 0
3116   172A             ; --- START RELATIONAL
3117   172A D7            push a
3118   172B 11            mov a, b
3119   172C FD 2E 00 00   mov32 cb, $00000000
3119   1730 00 00 
3120   1732 B0            cmp a, b
3121   1733 FD 7F         sgt ; >
3122   1735 E4            pop a
3123   1736             ; --- END RELATIONAL
3124   1736 C0 00 00      cmp b, 0
3125   1739 C6 6B 17      je _while41_exit
3126   173C             _while41_block:
3127   173C             ; i--; 
3128   173C FA F5 FF      lea d, [bp + -11] ; $i
3129   173F 2A            mov b, [d]
3130   1740 38 00 00      mov c, 0
3131   1743 FD 7D         dec b
3132   1745 FA F5 FF      lea d, [bp + -11] ; $i
3133   1748 FD 43         mov [d], b
3134   174A FD 77         inc b
3135   174C             ; putchar(digits[i]); 
3136   174C             ; --- START FUNCTION CALL
3137   174C FA F7 FF      lea d, [bp + -9] ; $digits
3138   174F D7            push a
3139   1750 DA            push d
3140   1751 FA F5 FF      lea d, [bp + -11] ; $i
3141   1754 2A            mov b, [d]
3142   1755 38 00 00      mov c, 0
3143   1758 E7            pop d
3144   1759 5A            add d, b
3145   175A E4            pop a
3146   175B 32            mov bl, [d]
3147   175C A7 00         mov bh, 0
3148   175E 38 00 00      mov c, 0
3149   1761 DD            push bl
3150   1762 07 A7 1C      call putchar
3151   1765 51 01 00      add sp, 1
3152   1768             ; --- END FUNCTION CALL
3153   1768 0A 23 17      jmp _while41_cond
3154   176B             _while41_exit:
3155   176B F9            leave
3156   176C 09            ret
3157   176D             
3158   176D             print_unsigned_long:
3159   176D F8 00 00      enter 0 ; (push bp; mov bp, sp)
3160   1770             ; char digits[10]; 
3161   1770 52 0A 00      sub sp, 10
3162   1773             ; int i; 
3163   1773 52 02 00      sub sp, 2
3164   1776             ; i = 0; 
3165   1776 FA F5 FF      lea d, [bp + -11] ; $i
3166   1779 DA            push d
3167   177A FD 2E 00 00   mov32 cb, $00000000
3167   177E 00 00 
3168   1780 E7            pop d
3169   1781 FD 43         mov [d], b
3170   1783             ; if(num == 0){ 
3171   1783             _if42_cond:
3172   1783 FA 05 00      lea d, [bp + 5] ; $num
3173   1786 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3174   1789 FD 39         mov c, b ; And place it into C
3175   178B 2A            mov b, [d] ; Lower Word in B
3176   178C             ; --- START RELATIONAL
3177   178C D7            push a
3178   178D FD D8         push g
3179   178F 11            mov a, b
3180   1790 FD 7A         mov g, c
3181   1792 FD 2E 00 00   mov32 cb, $00000000
3181   1796 00 00 
3182   1798 FD AF         cmp32 ga, cb
3183   179A FD 71         seq ; ==
3184   179C FD F1         pop g
3185   179E E4            pop a
3186   179F             ; --- END RELATIONAL
3187   179F C0 00 00      cmp b, 0
3188   17A2 C6 B7 17      je _if42_exit
3189   17A5             _if42_true:
3190   17A5             ; putchar('0'); 
3191   17A5             ; --- START FUNCTION CALL
3192   17A5 FD 2E 30 00   mov32 cb, $00000030
3192   17A9 00 00 
3193   17AB DD            push bl
3194   17AC 07 A7 1C      call putchar
3195   17AF 51 01 00      add sp, 1
3196   17B2             ; --- END FUNCTION CALL
3197   17B2             ; return; 
3198   17B2 F9            leave
3199   17B3 09            ret
3200   17B4 0A B7 17      jmp _if42_exit
3201   17B7             _if42_exit:
3202   17B7             ; while (num > 0) { 
3203   17B7             _while43_cond:
3204   17B7 FA 05 00      lea d, [bp + 5] ; $num
3205   17BA 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3206   17BD FD 39         mov c, b ; And place it into C
3207   17BF 2A            mov b, [d] ; Lower Word in B
3208   17C0             ; --- START RELATIONAL
3209   17C0 D7            push a
3210   17C1 FD D8         push g
3211   17C3 11            mov a, b
3212   17C4 FD 7A         mov g, c
3213   17C6 FD 2E 00 00   mov32 cb, $00000000
3213   17CA 00 00 
3214   17CC FD AF         cmp32 ga, cb
3215   17CE FD 81         sgu
3216   17D0 FD F1         pop g
3217   17D2 E4            pop a
3218   17D3             ; --- END RELATIONAL
3219   17D3 C0 00 00      cmp b, 0
3220   17D6 C6 3F 18      je _while43_exit
3221   17D9             _while43_block:
3222   17D9             ; digits[i] = '0' + (num % 10); 
3223   17D9 FA F7 FF      lea d, [bp + -9] ; $digits
3224   17DC D7            push a
3225   17DD DA            push d
3226   17DE FA F5 FF      lea d, [bp + -11] ; $i
3227   17E1 2A            mov b, [d]
3228   17E2 38 00 00      mov c, 0
3229   17E5 E7            pop d
3230   17E6 5A            add d, b
3231   17E7 E4            pop a
3232   17E8 DA            push d
3233   17E9 FD 2E 30 00   mov32 cb, $00000030
3233   17ED 00 00 
3234   17EF             ; --- START TERMS
3235   17EF D7            push a
3236   17F0 11            mov a, b
3237   17F1 FA 05 00      lea d, [bp + 5] ; $num
3238   17F4 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3239   17F7 FD 39         mov c, b ; And place it into C
3240   17F9 2A            mov b, [d] ; Lower Word in B
3241   17FA             ; --- START FACTORS
3242   17FA D7            push a
3243   17FB 11            mov a, b
3244   17FC FD 2E 0A 00   mov32 cb, $0000000a
3244   1800 00 00 
3245   1802 AE            div a, b ; 
3246   1803 11            mov a, b
3247   1804 27            mov b, a
3248   1805 E4            pop a
3249   1806             ; --- END FACTORS
3250   1806 FD 15         add32 cb, ga
3251   1808 E4            pop a
3252   1809             ; --- END TERMS
3253   1809 E7            pop d
3254   180A FD 3E         mov [d], bl
3255   180C             ; num = num / 10; 
3256   180C FA 05 00      lea d, [bp + 5] ; $num
3257   180F DA            push d
3258   1810 FA 05 00      lea d, [bp + 5] ; $num
3259   1813 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3260   1816 FD 39         mov c, b ; And place it into C
3261   1818 2A            mov b, [d] ; Lower Word in B
3262   1819             ; --- START FACTORS
3263   1819 D7            push a
3264   181A 11            mov a, b
3265   181B FD 2E 0A 00   mov32 cb, $0000000a
3265   181F 00 00 
3266   1821 AE            div a, b
3267   1822 27            mov b, a
3268   1823 E4            pop a
3269   1824             ; --- END FACTORS
3270   1824 E7            pop d
3271   1825 FD 43         mov [d], b
3272   1827 28            mov b, c
3273   1828 FD 44 02 00   mov [d + 2], b
3274   182C             ; i++; 
3275   182C FA F5 FF      lea d, [bp + -11] ; $i
3276   182F 2A            mov b, [d]
3277   1830 38 00 00      mov c, 0
3278   1833 FD 77         inc b
3279   1835 FA F5 FF      lea d, [bp + -11] ; $i
3280   1838 FD 43         mov [d], b
3281   183A FD 7D         dec b
3282   183C 0A B7 17      jmp _while43_cond
3283   183F             _while43_exit:
3284   183F             ; while (i > 0) { 
3285   183F             _while44_cond:
3286   183F FA F5 FF      lea d, [bp + -11] ; $i
3287   1842 2A            mov b, [d]
3288   1843 38 00 00      mov c, 0
3289   1846             ; --- START RELATIONAL
3290   1846 D7            push a
3291   1847 11            mov a, b
3292   1848 FD 2E 00 00   mov32 cb, $00000000
3292   184C 00 00 
3293   184E B0            cmp a, b
3294   184F FD 7F         sgt ; >
3295   1851 E4            pop a
3296   1852             ; --- END RELATIONAL
3297   1852 C0 00 00      cmp b, 0
3298   1855 C6 87 18      je _while44_exit
3299   1858             _while44_block:
3300   1858             ; i--; 
3301   1858 FA F5 FF      lea d, [bp + -11] ; $i
3302   185B 2A            mov b, [d]
3303   185C 38 00 00      mov c, 0
3304   185F FD 7D         dec b
3305   1861 FA F5 FF      lea d, [bp + -11] ; $i
3306   1864 FD 43         mov [d], b
3307   1866 FD 77         inc b
3308   1868             ; putchar(digits[i]); 
3309   1868             ; --- START FUNCTION CALL
3310   1868 FA F7 FF      lea d, [bp + -9] ; $digits
3311   186B D7            push a
3312   186C DA            push d
3313   186D FA F5 FF      lea d, [bp + -11] ; $i
3314   1870 2A            mov b, [d]
3315   1871 38 00 00      mov c, 0
3316   1874 E7            pop d
3317   1875 5A            add d, b
3318   1876 E4            pop a
3319   1877 32            mov bl, [d]
3320   1878 A7 00         mov bh, 0
3321   187A 38 00 00      mov c, 0
3322   187D DD            push bl
3323   187E 07 A7 1C      call putchar
3324   1881 51 01 00      add sp, 1
3325   1884             ; --- END FUNCTION CALL
3326   1884 0A 3F 18      jmp _while44_cond
3327   1887             _while44_exit:
3328   1887 F9            leave
3329   1888 09            ret
3330   1889             
3331   1889             sprint_unsigned:
3332   1889 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3333   188C             ; char digits[5]; 
3334   188C 52 05 00      sub sp, 5
3335   188F             ; int i; 
3336   188F 52 02 00      sub sp, 2
3337   1892             ; int len = 0; 
3338   1892 52 02 00      sub sp, 2
3339   1895             ; --- START LOCAL VAR INITIALIZATION
3340   1895 FA F8 FF      lea d, [bp + -8] ; $len
3341   1898 DA            push d
3342   1899 FD 2E 00 00   mov32 cb, $00000000
3342   189D 00 00 
3343   189F E7            pop d
3344   18A0 FD 43         mov [d], b
3345   18A2             ; --- END LOCAL VAR INITIALIZATION
3346   18A2             ; i = 0; 
3347   18A2 FA FA FF      lea d, [bp + -6] ; $i
3348   18A5 DA            push d
3349   18A6 FD 2E 00 00   mov32 cb, $00000000
3349   18AA 00 00 
3350   18AC E7            pop d
3351   18AD FD 43         mov [d], b
3352   18AF             ; if(num == 0){ 
3353   18AF             _if45_cond:
3354   18AF FA 07 00      lea d, [bp + 7] ; $num
3355   18B2 2A            mov b, [d]
3356   18B3 38 00 00      mov c, 0
3357   18B6             ; --- START RELATIONAL
3358   18B6 D7            push a
3359   18B7 11            mov a, b
3360   18B8 FD 2E 00 00   mov32 cb, $00000000
3360   18BC 00 00 
3361   18BE B0            cmp a, b
3362   18BF FD 71         seq ; ==
3363   18C1 E4            pop a
3364   18C2             ; --- END RELATIONAL
3365   18C2 C0 00 00      cmp b, 0
3366   18C5 C6 ED 18      je _if45_exit
3367   18C8             _if45_true:
3368   18C8             ; *dest++ = '0'; 
3369   18C8 FA 05 00      lea d, [bp + 5] ; $dest
3370   18CB 2A            mov b, [d]
3371   18CC 38 00 00      mov c, 0
3372   18CF FD 77         inc b
3373   18D1 FA 05 00      lea d, [bp + 5] ; $dest
3374   18D4 FD 43         mov [d], b
3375   18D6 FD 7D         dec b
3376   18D8 D8            push b
3377   18D9 FD 2E 30 00   mov32 cb, $00000030
3377   18DD 00 00 
3378   18DF E7            pop d
3379   18E0 FD 3E         mov [d], bl
3380   18E2             ; return 1; 
3381   18E2 FD 2E 01 00   mov32 cb, $00000001
3381   18E6 00 00 
3382   18E8 F9            leave
3383   18E9 09            ret
3384   18EA 0A ED 18      jmp _if45_exit
3385   18ED             _if45_exit:
3386   18ED             ; while (num > 0) { 
3387   18ED             _while46_cond:
3388   18ED FA 07 00      lea d, [bp + 7] ; $num
3389   18F0 2A            mov b, [d]
3390   18F1 38 00 00      mov c, 0
3391   18F4             ; --- START RELATIONAL
3392   18F4 D7            push a
3393   18F5 11            mov a, b
3394   18F6 FD 2E 00 00   mov32 cb, $00000000
3394   18FA 00 00 
3395   18FC B0            cmp a, b
3396   18FD FD 81         sgu ; > (unsigned)
3397   18FF E4            pop a
3398   1900             ; --- END RELATIONAL
3399   1900 C0 00 00      cmp b, 0
3400   1903 C6 62 19      je _while46_exit
3401   1906             _while46_block:
3402   1906             ; digits[i] = '0' + (num % 10); 
3403   1906 FA FC FF      lea d, [bp + -4] ; $digits
3404   1909 D7            push a
3405   190A DA            push d
3406   190B FA FA FF      lea d, [bp + -6] ; $i
3407   190E 2A            mov b, [d]
3408   190F 38 00 00      mov c, 0
3409   1912 E7            pop d
3410   1913 5A            add d, b
3411   1914 E4            pop a
3412   1915 DA            push d
3413   1916 FD 2E 30 00   mov32 cb, $00000030
3413   191A 00 00 
3414   191C             ; --- START TERMS
3415   191C D7            push a
3416   191D 11            mov a, b
3417   191E FA 07 00      lea d, [bp + 7] ; $num
3418   1921 2A            mov b, [d]
3419   1922 38 00 00      mov c, 0
3420   1925             ; --- START FACTORS
3421   1925 D7            push a
3422   1926 11            mov a, b
3423   1927 FD 2E 0A 00   mov32 cb, $0000000a
3423   192B 00 00 
3424   192D AE            div a, b ; 
3425   192E 11            mov a, b
3426   192F 27            mov b, a
3427   1930 E4            pop a
3428   1931             ; --- END FACTORS
3429   1931 56            add b, a
3430   1932 E4            pop a
3431   1933             ; --- END TERMS
3432   1933 E7            pop d
3433   1934 FD 3E         mov [d], bl
3434   1936             ; num = num / 10; 
3435   1936 FA 07 00      lea d, [bp + 7] ; $num
3436   1939 DA            push d
3437   193A FA 07 00      lea d, [bp + 7] ; $num
3438   193D 2A            mov b, [d]
3439   193E 38 00 00      mov c, 0
3440   1941             ; --- START FACTORS
3441   1941 D7            push a
3442   1942 11            mov a, b
3443   1943 FD 2E 0A 00   mov32 cb, $0000000a
3443   1947 00 00 
3444   1949 AE            div a, b
3445   194A 27            mov b, a
3446   194B E4            pop a
3447   194C             ; --- END FACTORS
3448   194C E7            pop d
3449   194D FD 43         mov [d], b
3450   194F             ; i++; 
3451   194F FA FA FF      lea d, [bp + -6] ; $i
3452   1952 2A            mov b, [d]
3453   1953 38 00 00      mov c, 0
3454   1956 FD 77         inc b
3455   1958 FA FA FF      lea d, [bp + -6] ; $i
3456   195B FD 43         mov [d], b
3457   195D FD 7D         dec b
3458   195F 0A ED 18      jmp _while46_cond
3459   1962             _while46_exit:
3460   1962             ; while (i > 0) { 
3461   1962             _while47_cond:
3462   1962 FA FA FF      lea d, [bp + -6] ; $i
3463   1965 2A            mov b, [d]
3464   1966 38 00 00      mov c, 0
3465   1969             ; --- START RELATIONAL
3466   1969 D7            push a
3467   196A 11            mov a, b
3468   196B FD 2E 00 00   mov32 cb, $00000000
3468   196F 00 00 
3469   1971 B0            cmp a, b
3470   1972 FD 7F         sgt ; >
3471   1974 E4            pop a
3472   1975             ; --- END RELATIONAL
3473   1975 C0 00 00      cmp b, 0
3474   1978 C6 C7 19      je _while47_exit
3475   197B             _while47_block:
3476   197B             ; i--; 
3477   197B FA FA FF      lea d, [bp + -6] ; $i
3478   197E 2A            mov b, [d]
3479   197F 38 00 00      mov c, 0
3480   1982 FD 7D         dec b
3481   1984 FA FA FF      lea d, [bp + -6] ; $i
3482   1987 FD 43         mov [d], b
3483   1989 FD 77         inc b
3484   198B             ; *dest++ = digits[i]; 
3485   198B FA 05 00      lea d, [bp + 5] ; $dest
3486   198E 2A            mov b, [d]
3487   198F 38 00 00      mov c, 0
3488   1992 FD 77         inc b
3489   1994 FA 05 00      lea d, [bp + 5] ; $dest
3490   1997 FD 43         mov [d], b
3491   1999 FD 7D         dec b
3492   199B D8            push b
3493   199C FA FC FF      lea d, [bp + -4] ; $digits
3494   199F D7            push a
3495   19A0 DA            push d
3496   19A1 FA FA FF      lea d, [bp + -6] ; $i
3497   19A4 2A            mov b, [d]
3498   19A5 38 00 00      mov c, 0
3499   19A8 E7            pop d
3500   19A9 5A            add d, b
3501   19AA E4            pop a
3502   19AB 32            mov bl, [d]
3503   19AC A7 00         mov bh, 0
3504   19AE 38 00 00      mov c, 0
3505   19B1 E7            pop d
3506   19B2 FD 3E         mov [d], bl
3507   19B4             ; len++; 
3508   19B4 FA F8 FF      lea d, [bp + -8] ; $len
3509   19B7 2A            mov b, [d]
3510   19B8 38 00 00      mov c, 0
3511   19BB FD 77         inc b
3512   19BD FA F8 FF      lea d, [bp + -8] ; $len
3513   19C0 FD 43         mov [d], b
3514   19C2 FD 7D         dec b
3515   19C4 0A 62 19      jmp _while47_cond
3516   19C7             _while47_exit:
3517   19C7             ; *dest = '\0'; 
3518   19C7 FA 05 00      lea d, [bp + 5] ; $dest
3519   19CA 2A            mov b, [d]
3520   19CB 38 00 00      mov c, 0
3521   19CE D8            push b
3522   19CF FD 2E 00 00   mov32 cb, $00000000
3522   19D3 00 00 
3523   19D5 E7            pop d
3524   19D6 FD 3E         mov [d], bl
3525   19D8             ; return len; 
3526   19D8 FA F8 FF      lea d, [bp + -8] ; $len
3527   19DB 2A            mov b, [d]
3528   19DC 38 00 00      mov c, 0
3529   19DF F9            leave
3530   19E0 09            ret
3531   19E1             
3532   19E1             print_unsigned:
3533   19E1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3534   19E4             ; char digits[5]; 
3535   19E4 52 05 00      sub sp, 5
3536   19E7             ; int i; 
3537   19E7 52 02 00      sub sp, 2
3538   19EA             ; i = 0; 
3539   19EA FA FA FF      lea d, [bp + -6] ; $i
3540   19ED DA            push d
3541   19EE FD 2E 00 00   mov32 cb, $00000000
3541   19F2 00 00 
3542   19F4 E7            pop d
3543   19F5 FD 43         mov [d], b
3544   19F7             ; if(num == 0){ 
3545   19F7             _if48_cond:
3546   19F7 FA 05 00      lea d, [bp + 5] ; $num
3547   19FA 2A            mov b, [d]
3548   19FB 38 00 00      mov c, 0
3549   19FE             ; --- START RELATIONAL
3550   19FE D7            push a
3551   19FF 11            mov a, b
3552   1A00 FD 2E 00 00   mov32 cb, $00000000
3552   1A04 00 00 
3553   1A06 B0            cmp a, b
3554   1A07 FD 71         seq ; ==
3555   1A09 E4            pop a
3556   1A0A             ; --- END RELATIONAL
3557   1A0A C0 00 00      cmp b, 0
3558   1A0D C6 22 1A      je _if48_exit
3559   1A10             _if48_true:
3560   1A10             ; putchar('0'); 
3561   1A10             ; --- START FUNCTION CALL
3562   1A10 FD 2E 30 00   mov32 cb, $00000030
3562   1A14 00 00 
3563   1A16 DD            push bl
3564   1A17 07 A7 1C      call putchar
3565   1A1A 51 01 00      add sp, 1
3566   1A1D             ; --- END FUNCTION CALL
3567   1A1D             ; return; 
3568   1A1D F9            leave
3569   1A1E 09            ret
3570   1A1F 0A 22 1A      jmp _if48_exit
3571   1A22             _if48_exit:
3572   1A22             ; while (num > 0) { 
3573   1A22             _while49_cond:
3574   1A22 FA 05 00      lea d, [bp + 5] ; $num
3575   1A25 2A            mov b, [d]
3576   1A26 38 00 00      mov c, 0
3577   1A29             ; --- START RELATIONAL
3578   1A29 D7            push a
3579   1A2A 11            mov a, b
3580   1A2B FD 2E 00 00   mov32 cb, $00000000
3580   1A2F 00 00 
3581   1A31 B0            cmp a, b
3582   1A32 FD 81         sgu ; > (unsigned)
3583   1A34 E4            pop a
3584   1A35             ; --- END RELATIONAL
3585   1A35 C0 00 00      cmp b, 0
3586   1A38 C6 97 1A      je _while49_exit
3587   1A3B             _while49_block:
3588   1A3B             ; digits[i] = '0' + (num % 10); 
3589   1A3B FA FC FF      lea d, [bp + -4] ; $digits
3590   1A3E D7            push a
3591   1A3F DA            push d
3592   1A40 FA FA FF      lea d, [bp + -6] ; $i
3593   1A43 2A            mov b, [d]
3594   1A44 38 00 00      mov c, 0
3595   1A47 E7            pop d
3596   1A48 5A            add d, b
3597   1A49 E4            pop a
3598   1A4A DA            push d
3599   1A4B FD 2E 30 00   mov32 cb, $00000030
3599   1A4F 00 00 
3600   1A51             ; --- START TERMS
3601   1A51 D7            push a
3602   1A52 11            mov a, b
3603   1A53 FA 05 00      lea d, [bp + 5] ; $num
3604   1A56 2A            mov b, [d]
3605   1A57 38 00 00      mov c, 0
3606   1A5A             ; --- START FACTORS
3607   1A5A D7            push a
3608   1A5B 11            mov a, b
3609   1A5C FD 2E 0A 00   mov32 cb, $0000000a
3609   1A60 00 00 
3610   1A62 AE            div a, b ; 
3611   1A63 11            mov a, b
3612   1A64 27            mov b, a
3613   1A65 E4            pop a
3614   1A66             ; --- END FACTORS
3615   1A66 56            add b, a
3616   1A67 E4            pop a
3617   1A68             ; --- END TERMS
3618   1A68 E7            pop d
3619   1A69 FD 3E         mov [d], bl
3620   1A6B             ; num = num / 10; 
3621   1A6B FA 05 00      lea d, [bp + 5] ; $num
3622   1A6E DA            push d
3623   1A6F FA 05 00      lea d, [bp + 5] ; $num
3624   1A72 2A            mov b, [d]
3625   1A73 38 00 00      mov c, 0
3626   1A76             ; --- START FACTORS
3627   1A76 D7            push a
3628   1A77 11            mov a, b
3629   1A78 FD 2E 0A 00   mov32 cb, $0000000a
3629   1A7C 00 00 
3630   1A7E AE            div a, b
3631   1A7F 27            mov b, a
3632   1A80 E4            pop a
3633   1A81             ; --- END FACTORS
3634   1A81 E7            pop d
3635   1A82 FD 43         mov [d], b
3636   1A84             ; i++; 
3637   1A84 FA FA FF      lea d, [bp + -6] ; $i
3638   1A87 2A            mov b, [d]
3639   1A88 38 00 00      mov c, 0
3640   1A8B FD 77         inc b
3641   1A8D FA FA FF      lea d, [bp + -6] ; $i
3642   1A90 FD 43         mov [d], b
3643   1A92 FD 7D         dec b
3644   1A94 0A 22 1A      jmp _while49_cond
3645   1A97             _while49_exit:
3646   1A97             ; while (i > 0) { 
3647   1A97             _while50_cond:
3648   1A97 FA FA FF      lea d, [bp + -6] ; $i
3649   1A9A 2A            mov b, [d]
3650   1A9B 38 00 00      mov c, 0
3651   1A9E             ; --- START RELATIONAL
3652   1A9E D7            push a
3653   1A9F 11            mov a, b
3654   1AA0 FD 2E 00 00   mov32 cb, $00000000
3654   1AA4 00 00 
3655   1AA6 B0            cmp a, b
3656   1AA7 FD 7F         sgt ; >
3657   1AA9 E4            pop a
3658   1AAA             ; --- END RELATIONAL
3659   1AAA C0 00 00      cmp b, 0
3660   1AAD C6 DF 1A      je _while50_exit
3661   1AB0             _while50_block:
3662   1AB0             ; i--; 
3663   1AB0 FA FA FF      lea d, [bp + -6] ; $i
3664   1AB3 2A            mov b, [d]
3665   1AB4 38 00 00      mov c, 0
3666   1AB7 FD 7D         dec b
3667   1AB9 FA FA FF      lea d, [bp + -6] ; $i
3668   1ABC FD 43         mov [d], b
3669   1ABE FD 77         inc b
3670   1AC0             ; putchar(digits[i]); 
3671   1AC0             ; --- START FUNCTION CALL
3672   1AC0 FA FC FF      lea d, [bp + -4] ; $digits
3673   1AC3 D7            push a
3674   1AC4 DA            push d
3675   1AC5 FA FA FF      lea d, [bp + -6] ; $i
3676   1AC8 2A            mov b, [d]
3677   1AC9 38 00 00      mov c, 0
3678   1ACC E7            pop d
3679   1ACD 5A            add d, b
3680   1ACE E4            pop a
3681   1ACF 32            mov bl, [d]
3682   1AD0 A7 00         mov bh, 0
3683   1AD2 38 00 00      mov c, 0
3684   1AD5 DD            push bl
3685   1AD6 07 A7 1C      call putchar
3686   1AD9 51 01 00      add sp, 1
3687   1ADC             ; --- END FUNCTION CALL
3688   1ADC 0A 97 1A      jmp _while50_cond
3689   1ADF             _while50_exit:
3690   1ADF F9            leave
3691   1AE0 09            ret
3692   1AE1             
3693   1AE1             sprint_signed:
3694   1AE1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3695   1AE4             ; char digits[5]; 
3696   1AE4 52 05 00      sub sp, 5
3697   1AE7             ; int i = 0; 
3698   1AE7 52 02 00      sub sp, 2
3699   1AEA             ; --- START LOCAL VAR INITIALIZATION
3700   1AEA FA FA FF      lea d, [bp + -6] ; $i
3701   1AED DA            push d
3702   1AEE FD 2E 00 00   mov32 cb, $00000000
3702   1AF2 00 00 
3703   1AF4 E7            pop d
3704   1AF5 FD 43         mov [d], b
3705   1AF7             ; --- END LOCAL VAR INITIALIZATION
3706   1AF7             ; int len = 0; 
3707   1AF7 52 02 00      sub sp, 2
3708   1AFA             ; --- START LOCAL VAR INITIALIZATION
3709   1AFA FA F8 FF      lea d, [bp + -8] ; $len
3710   1AFD DA            push d
3711   1AFE FD 2E 00 00   mov32 cb, $00000000
3711   1B02 00 00 
3712   1B04 E7            pop d
3713   1B05 FD 43         mov [d], b
3714   1B07             ; --- END LOCAL VAR INITIALIZATION
3715   1B07             ; if (num < 0) { 
3716   1B07             _if51_cond:
3717   1B07 FA 07 00      lea d, [bp + 7] ; $num
3718   1B0A 2A            mov b, [d]
3719   1B0B 38 00 00      mov c, 0
3720   1B0E             ; --- START RELATIONAL
3721   1B0E D7            push a
3722   1B0F 11            mov a, b
3723   1B10 FD 2E 00 00   mov32 cb, $00000000
3723   1B14 00 00 
3724   1B16 B0            cmp a, b
3725   1B17 FD 73         slt ; < (signed)
3726   1B19 E4            pop a
3727   1B1A             ; --- END RELATIONAL
3728   1B1A C0 00 00      cmp b, 0
3729   1B1D C6 5B 1B      je _if51_else
3730   1B20             _if51_true:
3731   1B20             ; *dest++ = '-'; 
3732   1B20 FA 05 00      lea d, [bp + 5] ; $dest
3733   1B23 2A            mov b, [d]
3734   1B24 38 00 00      mov c, 0
3735   1B27 FD 77         inc b
3736   1B29 FA 05 00      lea d, [bp + 5] ; $dest
3737   1B2C FD 43         mov [d], b
3738   1B2E FD 7D         dec b
3739   1B30 D8            push b
3740   1B31 FD 2E 2D 00   mov32 cb, $0000002d
3740   1B35 00 00 
3741   1B37 E7            pop d
3742   1B38 FD 3E         mov [d], bl
3743   1B3A             ; num = -num; 
3744   1B3A FA 07 00      lea d, [bp + 7] ; $num
3745   1B3D DA            push d
3746   1B3E FA 07 00      lea d, [bp + 7] ; $num
3747   1B41 2A            mov b, [d]
3748   1B42 38 00 00      mov c, 0
3749   1B45 E7            pop d
3750   1B46 FD 43         mov [d], b
3751   1B48             ; len++; 
3752   1B48 FA F8 FF      lea d, [bp + -8] ; $len
3753   1B4B 2A            mov b, [d]
3754   1B4C 38 00 00      mov c, 0
3755   1B4F FD 77         inc b
3756   1B51 FA F8 FF      lea d, [bp + -8] ; $len
3757   1B54 FD 43         mov [d], b
3758   1B56 FD 7D         dec b
3759   1B58 0A AA 1B      jmp _if51_exit
3760   1B5B             _if51_else:
3761   1B5B             ; if (num == 0) { 
3762   1B5B             _if52_cond:
3763   1B5B FA 07 00      lea d, [bp + 7] ; $num
3764   1B5E 2A            mov b, [d]
3765   1B5F 38 00 00      mov c, 0
3766   1B62             ; --- START RELATIONAL
3767   1B62 D7            push a
3768   1B63 11            mov a, b
3769   1B64 FD 2E 00 00   mov32 cb, $00000000
3769   1B68 00 00 
3770   1B6A B0            cmp a, b
3771   1B6B FD 71         seq ; ==
3772   1B6D E4            pop a
3773   1B6E             ; --- END RELATIONAL
3774   1B6E C0 00 00      cmp b, 0
3775   1B71 C6 AA 1B      je _if52_exit
3776   1B74             _if52_true:
3777   1B74             ; *dest++ = '0'; 
3778   1B74 FA 05 00      lea d, [bp + 5] ; $dest
3779   1B77 2A            mov b, [d]
3780   1B78 38 00 00      mov c, 0
3781   1B7B FD 77         inc b
3782   1B7D FA 05 00      lea d, [bp + 5] ; $dest
3783   1B80 FD 43         mov [d], b
3784   1B82 FD 7D         dec b
3785   1B84 D8            push b
3786   1B85 FD 2E 30 00   mov32 cb, $00000030
3786   1B89 00 00 
3787   1B8B E7            pop d
3788   1B8C FD 3E         mov [d], bl
3789   1B8E             ; *dest = '\0'; 
3790   1B8E FA 05 00      lea d, [bp + 5] ; $dest
3791   1B91 2A            mov b, [d]
3792   1B92 38 00 00      mov c, 0
3793   1B95 D8            push b
3794   1B96 FD 2E 00 00   mov32 cb, $00000000
3794   1B9A 00 00 
3795   1B9C E7            pop d
3796   1B9D FD 3E         mov [d], bl
3797   1B9F             ; return 1; 
3798   1B9F FD 2E 01 00   mov32 cb, $00000001
3798   1BA3 00 00 
3799   1BA5 F9            leave
3800   1BA6 09            ret
3801   1BA7 0A AA 1B      jmp _if52_exit
3802   1BAA             _if52_exit:
3803   1BAA             _if51_exit:
3804   1BAA             ; while (num > 0) { 
3805   1BAA             _while53_cond:
3806   1BAA FA 07 00      lea d, [bp + 7] ; $num
3807   1BAD 2A            mov b, [d]
3808   1BAE 38 00 00      mov c, 0
3809   1BB1             ; --- START RELATIONAL
3810   1BB1 D7            push a
3811   1BB2 11            mov a, b
3812   1BB3 FD 2E 00 00   mov32 cb, $00000000
3812   1BB7 00 00 
3813   1BB9 B0            cmp a, b
3814   1BBA FD 7F         sgt ; >
3815   1BBC E4            pop a
3816   1BBD             ; --- END RELATIONAL
3817   1BBD C0 00 00      cmp b, 0
3818   1BC0 C6 1F 1C      je _while53_exit
3819   1BC3             _while53_block:
3820   1BC3             ; digits[i] = '0' + (num % 10); 
3821   1BC3 FA FC FF      lea d, [bp + -4] ; $digits
3822   1BC6 D7            push a
3823   1BC7 DA            push d
3824   1BC8 FA FA FF      lea d, [bp + -6] ; $i
3825   1BCB 2A            mov b, [d]
3826   1BCC 38 00 00      mov c, 0
3827   1BCF E7            pop d
3828   1BD0 5A            add d, b
3829   1BD1 E4            pop a
3830   1BD2 DA            push d
3831   1BD3 FD 2E 30 00   mov32 cb, $00000030
3831   1BD7 00 00 
3832   1BD9             ; --- START TERMS
3833   1BD9 D7            push a
3834   1BDA 11            mov a, b
3835   1BDB FA 07 00      lea d, [bp + 7] ; $num
3836   1BDE 2A            mov b, [d]
3837   1BDF 38 00 00      mov c, 0
3838   1BE2             ; --- START FACTORS
3839   1BE2 D7            push a
3840   1BE3 11            mov a, b
3841   1BE4 FD 2E 0A 00   mov32 cb, $0000000a
3841   1BE8 00 00 
3842   1BEA AE            div a, b ; 
3843   1BEB 11            mov a, b
3844   1BEC 27            mov b, a
3845   1BED E4            pop a
3846   1BEE             ; --- END FACTORS
3847   1BEE 56            add b, a
3848   1BEF E4            pop a
3849   1BF0             ; --- END TERMS
3850   1BF0 E7            pop d
3851   1BF1 FD 3E         mov [d], bl
3852   1BF3             ; num = num / 10; 
3853   1BF3 FA 07 00      lea d, [bp + 7] ; $num
3854   1BF6 DA            push d
3855   1BF7 FA 07 00      lea d, [bp + 7] ; $num
3856   1BFA 2A            mov b, [d]
3857   1BFB 38 00 00      mov c, 0
3858   1BFE             ; --- START FACTORS
3859   1BFE D7            push a
3860   1BFF 11            mov a, b
3861   1C00 FD 2E 0A 00   mov32 cb, $0000000a
3861   1C04 00 00 
3862   1C06 AE            div a, b
3863   1C07 27            mov b, a
3864   1C08 E4            pop a
3865   1C09             ; --- END FACTORS
3866   1C09 E7            pop d
3867   1C0A FD 43         mov [d], b
3868   1C0C             ; i++; 
3869   1C0C FA FA FF      lea d, [bp + -6] ; $i
3870   1C0F 2A            mov b, [d]
3871   1C10 38 00 00      mov c, 0
3872   1C13 FD 77         inc b
3873   1C15 FA FA FF      lea d, [bp + -6] ; $i
3874   1C18 FD 43         mov [d], b
3875   1C1A FD 7D         dec b
3876   1C1C 0A AA 1B      jmp _while53_cond
3877   1C1F             _while53_exit:
3878   1C1F             ; while (i > 0) { 
3879   1C1F             _while54_cond:
3880   1C1F FA FA FF      lea d, [bp + -6] ; $i
3881   1C22 2A            mov b, [d]
3882   1C23 38 00 00      mov c, 0
3883   1C26             ; --- START RELATIONAL
3884   1C26 D7            push a
3885   1C27 11            mov a, b
3886   1C28 FD 2E 00 00   mov32 cb, $00000000
3886   1C2C 00 00 
3887   1C2E B0            cmp a, b
3888   1C2F FD 7F         sgt ; >
3889   1C31 E4            pop a
3890   1C32             ; --- END RELATIONAL
3891   1C32 C0 00 00      cmp b, 0
3892   1C35 C6 84 1C      je _while54_exit
3893   1C38             _while54_block:
3894   1C38             ; i--; 
3895   1C38 FA FA FF      lea d, [bp + -6] ; $i
3896   1C3B 2A            mov b, [d]
3897   1C3C 38 00 00      mov c, 0
3898   1C3F FD 7D         dec b
3899   1C41 FA FA FF      lea d, [bp + -6] ; $i
3900   1C44 FD 43         mov [d], b
3901   1C46 FD 77         inc b
3902   1C48             ; *dest++ = digits[i]; 
3903   1C48 FA 05 00      lea d, [bp + 5] ; $dest
3904   1C4B 2A            mov b, [d]
3905   1C4C 38 00 00      mov c, 0
3906   1C4F FD 77         inc b
3907   1C51 FA 05 00      lea d, [bp + 5] ; $dest
3908   1C54 FD 43         mov [d], b
3909   1C56 FD 7D         dec b
3910   1C58 D8            push b
3911   1C59 FA FC FF      lea d, [bp + -4] ; $digits
3912   1C5C D7            push a
3913   1C5D DA            push d
3914   1C5E FA FA FF      lea d, [bp + -6] ; $i
3915   1C61 2A            mov b, [d]
3916   1C62 38 00 00      mov c, 0
3917   1C65 E7            pop d
3918   1C66 5A            add d, b
3919   1C67 E4            pop a
3920   1C68 32            mov bl, [d]
3921   1C69 A7 00         mov bh, 0
3922   1C6B 38 00 00      mov c, 0
3923   1C6E E7            pop d
3924   1C6F FD 3E         mov [d], bl
3925   1C71             ; len++; 
3926   1C71 FA F8 FF      lea d, [bp + -8] ; $len
3927   1C74 2A            mov b, [d]
3928   1C75 38 00 00      mov c, 0
3929   1C78 FD 77         inc b
3930   1C7A FA F8 FF      lea d, [bp + -8] ; $len
3931   1C7D FD 43         mov [d], b
3932   1C7F FD 7D         dec b
3933   1C81 0A 1F 1C      jmp _while54_cond
3934   1C84             _while54_exit:
3935   1C84             ; *dest = '\0'; 
3936   1C84 FA 05 00      lea d, [bp + 5] ; $dest
3937   1C87 2A            mov b, [d]
3938   1C88 38 00 00      mov c, 0
3939   1C8B D8            push b
3940   1C8C FD 2E 00 00   mov32 cb, $00000000
3940   1C90 00 00 
3941   1C92 E7            pop d
3942   1C93 FD 3E         mov [d], bl
3943   1C95             ; return len; 
3944   1C95 FA F8 FF      lea d, [bp + -8] ; $len
3945   1C98 2A            mov b, [d]
3946   1C99 38 00 00      mov c, 0
3947   1C9C F9            leave
3948   1C9D 09            ret
3949   1C9E             
3950   1C9E             date:
3951   1C9E F8 00 00      enter 0 ; (push bp; mov bp, sp)
3952   1CA1             
3953   1CA1             ; --- BEGIN INLINE ASM SEGMENT
3954   1CA1 19 00         mov al, 0 
3955   1CA3 05 07         syscall sys_datetime
3956   1CA5             ; --- END INLINE ASM SEGMENT
3957   1CA5             
3958   1CA5 F9            leave
3959   1CA6 09            ret
3960   1CA7             
3961   1CA7             putchar:
3962   1CA7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3963   1CAA             
3964   1CAA             ; --- BEGIN INLINE ASM SEGMENT
3965   1CAA FA 05 00      lea d, [bp + 5] ; $c
3966   1CAD 1E            mov al, [d]
3967   1CAE 23            mov ah, al
3968   1CAF 07 B4 1E      call _putchar
3969   1CB2             ; --- END INLINE ASM SEGMENT
3970   1CB2             
3971   1CB2 F9            leave
3972   1CB3 09            ret
3973   1CB4             
3974   1CB4             getchar:
3975   1CB4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3976   1CB7             ; char c; 
3977   1CB7 52 01 00      sub sp, 1
3978   1CBA             
3979   1CBA             ; --- BEGIN INLINE ASM SEGMENT
3980   1CBA 07 AD 1E      call getch
3981   1CBD 1A            mov al, ah
3982   1CBE FA 00 00      lea d, [bp + 0] ; $c
3983   1CC1 3E            mov [d], al
3984   1CC2             ; --- END INLINE ASM SEGMENT
3985   1CC2             
3986   1CC2             ; return c; 
3987   1CC2 FA 00 00      lea d, [bp + 0] ; $c
3988   1CC5 32            mov bl, [d]
3989   1CC6 A7 00         mov bh, 0
3990   1CC8 38 00 00      mov c, 0
3991   1CCB F9            leave
3992   1CCC 09            ret
3993   1CCD             
3994   1CCD             scann:
3995   1CCD F8 00 00      enter 0 ; (push bp; mov bp, sp)
3996   1CD0             ; int m; 
3997   1CD0 52 02 00      sub sp, 2
3998   1CD3             
3999   1CD3             ; --- BEGIN INLINE ASM SEGMENT
4000   1CD3 07 F8 20      call scan_u16d
4001   1CD6 FA FF FF      lea d, [bp + -1] ; $m
4002   1CD9 43            mov [d], a
4003   1CDA             ; --- END INLINE ASM SEGMENT
4004   1CDA             
4005   1CDA             ; return m; 
4006   1CDA FA FF FF      lea d, [bp + -1] ; $m
4007   1CDD 2A            mov b, [d]
4008   1CDE 38 00 00      mov c, 0
4009   1CE1 F9            leave
4010   1CE2 09            ret
4011   1CE3             
4012   1CE3             puts:
4013   1CE3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4014   1CE6             
4015   1CE6             ; --- BEGIN INLINE ASM SEGMENT
4016   1CE6 FA 05 00      lea d, [bp + 5] ; $s
4017   1CE9 15            mov a, [d]
4018   1CEA 3C            mov d, a
4019   1CEB 07 FE 1F      call _puts
4020   1CEE 10 00 0A      mov a, $0A00
4021   1CF1 05 03         syscall sys_io
4022   1CF3             ; --- END INLINE ASM SEGMENT
4023   1CF3             
4024   1CF3 F9            leave
4025   1CF4 09            ret
4026   1CF5             
4027   1CF5             print:
4028   1CF5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4029   1CF8             
4030   1CF8             ; --- BEGIN INLINE ASM SEGMENT
4031   1CF8 FA 05 00      lea d, [bp + 5] ; $s
4032   1CFB FD 2A         mov d, [d]
4033   1CFD 07 FE 1F      call _puts
4034   1D00             ; --- END INLINE ASM SEGMENT
4035   1D00             
4036   1D00 F9            leave
4037   1D01 09            ret
4038   1D02             
4039   1D02             getparam:
4040   1D02 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4041   1D05             ; char data; 
4042   1D05 52 01 00      sub sp, 1
4043   1D08             
4044   1D08             ; --- BEGIN INLINE ASM SEGMENT
4045   1D08 19 04         mov al, 4
4046   1D0A FA 05 00      lea d, [bp + 5] ; $address
4047   1D0D FD 2A         mov d, [d]
4048   1D0F 05 0C         syscall sys_system
4049   1D11 FA 00 00      lea d, [bp + 0] ; $data
4050   1D14 FD 3E         mov [d], bl
4051   1D16             ; --- END INLINE ASM SEGMENT
4052   1D16             
4053   1D16             ; return data; 
4054   1D16 FA 00 00      lea d, [bp + 0] ; $data
4055   1D19 32            mov bl, [d]
4056   1D1A A7 00         mov bh, 0
4057   1D1C 38 00 00      mov c, 0
4058   1D1F F9            leave
4059   1D20 09            ret
4060   1D21             
4061   1D21             clear:
4062   1D21 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4063   1D24             ; print("\033[2J\033[H"); 
4064   1D24             ; --- START FUNCTION CALL
4065   1D24 26 94 21      mov b, _s2 ; "\033[2J\033[H"
4066   1D27 FD AB         swp b
4067   1D29 D8            push b
4068   1D2A 07 F5 1C      call print
4069   1D2D 51 02 00      add sp, 2
4070   1D30             ; --- END FUNCTION CALL
4071   1D30 F9            leave
4072   1D31 09            ret
4073   1D32             
4074   1D32             abs:
4075   1D32 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4076   1D35             ; return i < 0 ? -i : i; 
4077   1D35             _ternary55_cond:
4078   1D35 FA 05 00      lea d, [bp + 5] ; $i
4079   1D38 2A            mov b, [d]
4080   1D39 38 00 00      mov c, 0
4081   1D3C             ; --- START RELATIONAL
4082   1D3C D7            push a
4083   1D3D 11            mov a, b
4084   1D3E FD 2E 00 00   mov32 cb, $00000000
4084   1D42 00 00 
4085   1D44 B0            cmp a, b
4086   1D45 FD 73         slt ; < (signed)
4087   1D47 E4            pop a
4088   1D48             ; --- END RELATIONAL
4089   1D48 C0 00 00      cmp b, 0
4090   1D4B C6 58 1D      je _ternary55_false
4091   1D4E             _ternary55_true:
4092   1D4E FA 05 00      lea d, [bp + 5] ; $i
4093   1D51 2A            mov b, [d]
4094   1D52 38 00 00      mov c, 0
4095   1D55 0A 5F 1D      jmp _ternary55_exit
4096   1D58             _ternary55_false:
4097   1D58 FA 05 00      lea d, [bp + 5] ; $i
4098   1D5B 2A            mov b, [d]
4099   1D5C 38 00 00      mov c, 0
4100   1D5F             _ternary55_exit:
4101   1D5F F9            leave
4102   1D60 09            ret
4103   1D61             
4104   1D61             loadfile:
4105   1D61 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4106   1D64             
4107   1D64             ; --- BEGIN INLINE ASM SEGMENT
4108   1D64 FA 07 00      lea d, [bp + 7] ; $destination
4109   1D67 15            mov a, [d]
4110   1D68 4F            mov di, a
4111   1D69 FA 05 00      lea d, [bp + 5] ; $filename
4112   1D6C FD 2A         mov d, [d]
4113   1D6E 19 14         mov al, 20
4114   1D70 05 04         syscall sys_filesystem
4115   1D72             ; --- END INLINE ASM SEGMENT
4116   1D72             
4117   1D72 F9            leave
4118   1D73 09            ret
4119   1D74             
4120   1D74             create_file:
4121   1D74 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4122   1D77 F9            leave
4123   1D78 09            ret
4124   1D79             
4125   1D79             delete_file:
4126   1D79 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4127   1D7C             
4128   1D7C             ; --- BEGIN INLINE ASM SEGMENT
4129   1D7C FA 05 00      lea d, [bp + 5] ; $filename
4130   1D7F 19 0A         mov al, 10
4131   1D81 05 04         syscall sys_filesystem
4132   1D83             ; --- END INLINE ASM SEGMENT
4133   1D83             
4134   1D83 F9            leave
4135   1D84 09            ret
4136   1D85             
4137   1D85             load_hex:
4138   1D85 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4139   1D88             ; char *temp; 
4140   1D88 52 02 00      sub sp, 2
4141   1D8B             ; temp = alloc(32768); 
4142   1D8B FA FF FF      lea d, [bp + -1] ; $temp
4143   1D8E DA            push d
4144   1D8F             ; --- START FUNCTION CALL
4145   1D8F FD 2E 00 80   mov32 cb, $00008000
4145   1D93 00 00 
4146   1D95 FD AB         swp b
4147   1D97 D8            push b
4148   1D98 07 62 08      call alloc
4149   1D9B 51 02 00      add sp, 2
4150   1D9E             ; --- END FUNCTION CALL
4151   1D9E E7            pop d
4152   1D9F FD 43         mov [d], b
4153   1DA1             
4154   1DA1             ; --- BEGIN INLINE ASM SEGMENT
4155   1DA1               
4156   1DA1               
4157   1DA1               
4158   1DA1             _load_hex:
4159   1DA1 FA 05 00      lea d, [bp + 5] ; $destination
4160   1DA4 FD 2A         mov d, [d]
4161   1DA6 FD 50         mov di, d
4162   1DA8 FA FF FF      lea d, [bp + -1] ; $temp
4163   1DAB FD 2A         mov d, [d]
4164   1DAD 38 00 00      mov c, 0
4165   1DB0 48            mov a, sp
4166   1DB1 77            inc a
4167   1DB2 3C            mov d, a          
4168   1DB3 07 BB 1E      call _gets        
4169   1DB6 4D            mov si, a
4170   1DB7             __load_hex_loop:
4171   1DB7 F6            lodsb             
4172   1DB8 B9 00         cmp al, 0         
4173   1DBA C6 C8 1D      jz __load_hex_ret
4174   1DBD 36            mov bh, al
4175   1DBE F6            lodsb
4176   1DBF 2F            mov bl, al
4177   1DC0 07 72 1E      call _atoi        
4178   1DC3 F7            stosb             
4179   1DC4 78            inc c
4180   1DC5 0A B7 1D      jmp __load_hex_loop
4181   1DC8             __load_hex_ret:
4182   1DC8             ; --- END INLINE ASM SEGMENT
4183   1DC8             
4184   1DC8 F9            leave
4185   1DC9 09            ret
4186   1DCA             
4187   1DCA             include_stdio_asm:
4188   1DCA F8 00 00      enter 0 ; (push bp; mov bp, sp)
4189   1DCD             
4190   1DCD             ; --- BEGIN INLINE ASM SEGMENT
4191   1DCD             .include "lib/asm/stdio.asm"
0001+  1DCD             ;-----------------------------------------------------------------------------
0002+  1DCD             ; stdio.s
0003+  1DCD             ;-----------------------------------------------------------------------------
0004+  1DCD             .include "lib/asm/string.asm"
0001++ 1DCD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 1DCD             ; string.s
0003++ 1DCD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 1DCD             
0005++ 1DCD             
0006++ 1DCD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 1DCD             ; _strrev
0008++ 1DCD             ; reverse a string
0009++ 1DCD             ; D = string address
0010++ 1DCD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 1DCD             ; 01234
0012++ 1DCD             _strrev:
0013++ 1DCD 4B          	pusha
0014++ 1DCE 07 14 1E    	call _strlen	; length in C
0015++ 1DD1 12          	mov a, c
0016++ 1DD2 AF 01 00    	cmp a, 1
0017++ 1DD5 D0 EF 1D    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 1DD8 7D          	dec a
0019++ 1DD9 FD 4E       	mov si, d	; beginning of string
0020++ 1DDB FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 1DDD 59          	add d, a	; end of string
0022++ 1DDE 12          	mov a, c
0023++ 1DDF FD 9B       	shr a		; divide by 2
0024++ 1DE1 39          	mov c, a	; C now counts the steps
0025++ 1DE2             _strrev_L0:
0026++ 1DE2 32          	mov bl, [d]	; save load right-side char into BL
0027++ 1DE3 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 1DE4 3E          	mov [d], al	; store left char into right side
0029++ 1DE5 1B          	mov al, bl
0030++ 1DE6 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 1DE7 7E          	dec c
0032++ 1DE8 7F          	dec d
0033++ 1DE9 C2 00 00    	cmp c, 0
0034++ 1DEC C7 E2 1D    	jne _strrev_L0
0035++ 1DEF             _strrev_end:
0036++ 1DEF 4C          	popa
0037++ 1DF0 09          	ret
0038++ 1DF1             	
0039++ 1DF1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 1DF1             ; _strchr
0041++ 1DF1             ; search string in D for char in AL
0042++ 1DF1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 1DF1             _strchr:
0044++ 1DF1             _strchr_L0:
0045++ 1DF1 32          	mov bl, [d]
0046++ 1DF2 C1 00       	cmp bl, 0
0047++ 1DF4 C6 FF 1D    	je _strchr_end
0048++ 1DF7 BA          	cmp al, bl
0049++ 1DF8 C6 FF 1D    	je _strchr_end
0050++ 1DFB 79          	inc d
0051++ 1DFC 0A F1 1D    	jmp _strchr_L0
0052++ 1DFF             _strchr_end:
0053++ 1DFF 1B          	mov al, bl
0054++ 1E00 09          	ret
0055++ 1E01             
0056++ 1E01             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 1E01             ; _strstr
0058++ 1E01             ; find sub-string
0059++ 1E01             ; str1 in SI
0060++ 1E01             ; str2 in DI
0061++ 1E01             ; SI points to end of source string
0062++ 1E01             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 1E01             _strstr:
0064++ 1E01 DB          	push al
0065++ 1E02 DA          	push d
0066++ 1E03 E3          	push di
0067++ 1E04             _strstr_loop:
0068++ 1E04 F3          	cmpsb					; compare a byte of the strings
0069++ 1E05 C7 10 1E    	jne _strstr_ret
0070++ 1E08 FC 00 00    	lea d, [di + 0]
0071++ 1E0B BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1E0D C7 04 1E    	jne _strstr_loop				; equal chars but not at end
0073++ 1E10             _strstr_ret:
0074++ 1E10 F0          	pop di
0075++ 1E11 E7          	pop d
0076++ 1E12 E8          	pop al
0077++ 1E13 09          	ret
0078++ 1E14             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1E14             ; length of null terminated string
0080++ 1E14             ; result in C
0081++ 1E14             ; pointer in D
0082++ 1E14             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1E14             _strlen:
0084++ 1E14 DA          	push d
0085++ 1E15 38 00 00    	mov c, 0
0086++ 1E18             _strlen_L1:
0087++ 1E18 BD 00       	cmp byte [d], 0
0088++ 1E1A C6 22 1E    	je _strlen_ret
0089++ 1E1D 79          	inc d
0090++ 1E1E 78          	inc c
0091++ 1E1F 0A 18 1E    	jmp _strlen_L1
0092++ 1E22             _strlen_ret:
0093++ 1E22 E7          	pop d
0094++ 1E23 09          	ret
0095++ 1E24             
0096++ 1E24             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1E24             ; STRCMP
0098++ 1E24             ; compare two strings
0099++ 1E24             ; str1 in SI
0100++ 1E24             ; str2 in DI
0101++ 1E24             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 1E24             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1E24             _strcmp:
0104++ 1E24 DB          	push al
0105++ 1E25 DA          	push d
0106++ 1E26 E3          	push di
0107++ 1E27 E2          	push si
0108++ 1E28             _strcmp_loop:
0109++ 1E28 F3          	cmpsb					; compare a byte of the strings
0110++ 1E29 C7 34 1E    	jne _strcmp_ret
0111++ 1E2C FB FF FF    	lea d, [si +- 1]
0112++ 1E2F BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1E31 C7 28 1E    	jne _strcmp_loop				; equal chars but not at end
0114++ 1E34             _strcmp_ret:
0115++ 1E34 EF          	pop si
0116++ 1E35 F0          	pop di
0117++ 1E36 E7          	pop d
0118++ 1E37 E8          	pop al
0119++ 1E38 09          	ret
0120++ 1E39             
0121++ 1E39             
0122++ 1E39             ; STRCPY
0123++ 1E39             ; copy null terminated string from SI to DI
0124++ 1E39             ; source in SI
0125++ 1E39             ; destination in DI
0126++ 1E39             _strcpy:
0127++ 1E39 E2          	push si
0128++ 1E3A E3          	push di
0129++ 1E3B DB          	push al
0130++ 1E3C             _strcpy_L1:
0131++ 1E3C F6          	lodsb
0132++ 1E3D F7          	stosb
0133++ 1E3E B9 00       	cmp al, 0
0134++ 1E40 C7 3C 1E    	jne _strcpy_L1
0135++ 1E43             _strcpy_end:
0136++ 1E43 E8          	pop al
0137++ 1E44 F0          	pop di
0138++ 1E45 EF          	pop si
0139++ 1E46 09          	ret
0140++ 1E47             
0141++ 1E47             ; STRCAT
0142++ 1E47             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 1E47             ; source in SI
0144++ 1E47             ; destination in DI
0145++ 1E47             _strcat:
0146++ 1E47 E2          	push si
0147++ 1E48 E3          	push di
0148++ 1E49 D7          	push a
0149++ 1E4A DA          	push d
0150++ 1E4B 50          	mov a, di
0151++ 1E4C 3C          	mov d, a
0152++ 1E4D             _strcat_goto_end_L1:
0153++ 1E4D BD 00       	cmp byte[d], 0
0154++ 1E4F C6 56 1E    	je _strcat_start
0155++ 1E52 79          	inc d
0156++ 1E53 0A 4D 1E    	jmp _strcat_goto_end_L1
0157++ 1E56             _strcat_start:
0158++ 1E56 FD 50       	mov di, d
0159++ 1E58             _strcat_L1:
0160++ 1E58 F6          	lodsb
0161++ 1E59 F7          	stosb
0162++ 1E5A B9 00       	cmp al, 0
0163++ 1E5C C7 58 1E    	jne _strcat_L1
0164++ 1E5F             _strcat_end:
0165++ 1E5F E7          	pop d
0166++ 1E60 E4          	pop a
0167++ 1E61 F0          	pop di
0168++ 1E62 EF          	pop si
0169++ 1E63 09          	ret
0170++ 1E64             
0171++ 1E64             
0005+  1E64             
0006+  1E64             ;-----------------------------------------------------------------------------
0007+  1E64             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0008+  1E64             ; ASCII in BL
0009+  1E64             ; result in AL
0010+  1E64             ; ascii for F = 0100 0110
0011+  1E64             ; ascii for 9 = 0011 1001
0012+  1E64             ;-----------------------------------------------------------------------------
0013+  1E64             hex_ascii_encode:
0014+  1E64 1B            mov al, bl
0015+  1E65 93 40         test al, $40        ; test if letter or number
0016+  1E67 C7 6D 1E      jnz hex_letter
0017+  1E6A 87 0F         and al, $0F        ; get number
0018+  1E6C 09            ret
0019+  1E6D             hex_letter:
0020+  1E6D 87 0F         and al, $0F        ; get letter
0021+  1E6F 6A 09         add al, 9
0022+  1E71 09            ret
0023+  1E72             
0024+  1E72             ;-----------------------------------------------------------------------------
0025+  1E72             ; ATOI
0026+  1E72             ; 2 letter hex string in B
0027+  1E72             ; 8bit integer returned in AL
0028+  1E72             ;-----------------------------------------------------------------------------
0029+  1E72             _atoi:
0030+  1E72 D8            push b
0031+  1E73 07 64 1E      call hex_ascii_encode      ; convert BL to 4bit code in AL
0032+  1E76 30            mov bl, bh
0033+  1E77 DB            push al          ; save a
0034+  1E78 07 64 1E      call hex_ascii_encode
0035+  1E7B EA            pop bl  
0036+  1E7C FD 9E 04      shl al, 4
0037+  1E7F 8C            or al, bl
0038+  1E80 E5            pop b
0039+  1E81 09            ret  
0040+  1E82             
0041+  1E82             
0042+  1E82             ;-----------------------------------------------------------------------------
0043+  1E82             ; ITOA
0044+  1E82             ; 8bit value in BL
0045+  1E82             ; 2 byte ASCII result in A
0046+  1E82             ;-----------------------------------------------------------------------------
0047+  1E82             _itoa:
0048+  1E82 DA            push d
0049+  1E83 D8            push b
0050+  1E84 A7 00         mov bh, 0
0051+  1E86 FD A4 04      shr bl, 4  
0052+  1E89 74            mov d, b
0053+  1E8A 1F 32 21      mov al, [d + s_hex_digits]
0054+  1E8D 23            mov ah, al
0055+  1E8E               
0056+  1E8E E5            pop b
0057+  1E8F D8            push b
0058+  1E90 A7 00         mov bh, 0
0059+  1E92 FD 87 0F      and bl, $0F
0060+  1E95 74            mov d, b
0061+  1E96 1F 32 21      mov al, [d + s_hex_digits]
0062+  1E99 E5            pop b
0063+  1E9A E7            pop d
0064+  1E9B 09            ret
0065+  1E9C             
0066+  1E9C             ;-----------------------------------------------------------------------------
0067+  1E9C             ; HEX STRING TO BINARY
0068+  1E9C             ; di = destination address
0069+  1E9C             ; si = source
0070+  1E9C             ;-----------------------------------------------------------------------------
0071+  1E9C             _hex_to_int:
0072+  1E9C             _hex_to_int_L1:
0073+  1E9C F6            lodsb          ; load from [SI] to AL
0074+  1E9D B9 00         cmp al, 0        ; check if ASCII 0
0075+  1E9F C6 AC 1E      jz _hex_to_int_ret
0076+  1EA2 36            mov bh, al
0077+  1EA3 F6            lodsb
0078+  1EA4 2F            mov bl, al
0079+  1EA5 07 72 1E      call _atoi        ; convert ASCII byte in B to int (to AL)
0080+  1EA8 F7            stosb          ; store AL to [DI]
0081+  1EA9 0A 9C 1E      jmp _hex_to_int_L1
0082+  1EAC             _hex_to_int_ret:
0083+  1EAC 09            ret    
0084+  1EAD             
0085+  1EAD             ;-----------------------------------------------------------------------------
0086+  1EAD             ; GETCHAR
0087+  1EAD             ; char in ah
0088+  1EAD             ;-----------------------------------------------------------------------------
0089+  1EAD             getch:
0090+  1EAD DB            push al
0091+  1EAE             getch_retry:
0092+  1EAE 19 01         mov al, 1
0093+  1EB0 05 03         syscall sys_io      ; receive in AH
0094+  1EB2 E8            pop al
0095+  1EB3 09            ret
0096+  1EB4             
0097+  1EB4             ;-----------------------------------------------------------------------------
0098+  1EB4             ; PUTCHAR
0099+  1EB4             ; char in ah
0100+  1EB4             ;-----------------------------------------------------------------------------
0101+  1EB4             _putchar:
0102+  1EB4 D7            push a
0103+  1EB5 19 00         mov al, 0
0104+  1EB7 05 03         syscall sys_io      ; char in AH
0105+  1EB9 E4            pop a
0106+  1EBA 09            ret
0107+  1EBB             
0108+  1EBB             ;-----------------------------------------------------------------------------
0109+  1EBB             ;; INPUT A STRING
0110+  1EBB             ;; terminates with null
0111+  1EBB             ;; pointer in D
0112+  1EBB             ;-----------------------------------------------------------------------------
0113+  1EBB             _gets:
0114+  1EBB D7            push a
0115+  1EBC DA            push d
0116+  1EBD             _gets_loop:
0117+  1EBD 19 01         mov al, 1
0118+  1EBF 05 03         syscall sys_io      ; receive in AH
0119+  1EC1 B9 00         cmp al, 0        ; check error code (AL)
0120+  1EC3 C6 BD 1E      je _gets_loop      ; if no char received, retry
0121+  1EC6             
0122+  1EC6 76 1B         cmp ah, 27
0123+  1EC8 C6 E9 1E      je _gets_ansi_esc
0124+  1ECB 76 0A         cmp ah, $0A        ; LF
0125+  1ECD C6 54 1F      je _gets_end
0126+  1ED0 76 0D         cmp ah, $0D        ; CR
0127+  1ED2 C6 54 1F      je _gets_end
0128+  1ED5 76 5C         cmp ah, $5C        ; '\\'
0129+  1ED7 C6 15 1F      je _gets_escape
0130+  1EDA               
0131+  1EDA 76 08         cmp ah, $08      ; check for backspace
0132+  1EDC C6 E5 1E      je _gets_backspace
0133+  1EDF             
0134+  1EDF 1A            mov al, ah
0135+  1EE0 3E            mov [d], al
0136+  1EE1 79            inc d
0137+  1EE2 0A BD 1E      jmp _gets_loop
0138+  1EE5             _gets_backspace:
0139+  1EE5 7F            dec d
0140+  1EE6 0A BD 1E      jmp _gets_loop
0141+  1EE9             _gets_ansi_esc:
0142+  1EE9 19 01         mov al, 1
0143+  1EEB 05 03         syscall sys_io        ; receive in AH without echo
0144+  1EED B9 00         cmp al, 0          ; check error code (AL)
0145+  1EEF C6 E9 1E      je _gets_ansi_esc    ; if no char received, retry
0146+  1EF2 76 5B         cmp ah, '['
0147+  1EF4 C7 BD 1E      jne _gets_loop
0148+  1EF7             _gets_ansi_esc_2:
0149+  1EF7 19 01         mov al, 1
0150+  1EF9 05 03         syscall sys_io          ; receive in AH without echo
0151+  1EFB B9 00         cmp al, 0            ; check error code (AL)
0152+  1EFD C6 F7 1E      je _gets_ansi_esc_2  ; if no char received, retry
0153+  1F00 76 44         cmp ah, 'D'
0154+  1F02 C6 0D 1F      je _gets_left_arrow
0155+  1F05 76 43         cmp ah, 'C'
0156+  1F07 C6 11 1F      je _gets_right_arrow
0157+  1F0A 0A BD 1E      jmp _gets_loop
0158+  1F0D             _gets_left_arrow:
0159+  1F0D 7F            dec d
0160+  1F0E 0A BD 1E      jmp _gets_loop
0161+  1F11             _gets_right_arrow:
0162+  1F11 79            inc d
0163+  1F12 0A BD 1E      jmp _gets_loop
0164+  1F15             _gets_escape:
0165+  1F15 19 01         mov al, 1
0166+  1F17 05 03         syscall sys_io      ; receive in AH
0167+  1F19 B9 00         cmp al, 0        ; check error code (AL)
0168+  1F1B C6 15 1F      je _gets_escape      ; if no char received, retry
0169+  1F1E 76 6E         cmp ah, 'n'
0170+  1F20 C6 3F 1F      je _gets_LF
0171+  1F23 76 72         cmp ah, 'r'
0172+  1F25 C6 46 1F      je _gets_CR
0173+  1F28 76 30         cmp ah, '0'
0174+  1F2A C6 4D 1F      je _gets_NULL
0175+  1F2D 76 5C         cmp ah, $5C  ; '\'
0176+  1F2F C6 38 1F      je _gets_slash
0177+  1F32 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0178+  1F33 3E            mov [d], al
0179+  1F34 79            inc d
0180+  1F35 0A BD 1E      jmp _gets_loop
0181+  1F38             _gets_slash:
0182+  1F38 19 5C         mov al, $5C
0183+  1F3A 3E            mov [d], al
0184+  1F3B 79            inc d
0185+  1F3C 0A BD 1E      jmp _gets_loop
0186+  1F3F             _gets_LF:
0187+  1F3F 19 0A         mov al, $0A
0188+  1F41 3E            mov [d], al
0189+  1F42 79            inc d
0190+  1F43 0A BD 1E      jmp _gets_loop
0191+  1F46             _gets_CR:
0192+  1F46 19 0D         mov al, $0D
0193+  1F48 3E            mov [d], al
0194+  1F49 79            inc d
0195+  1F4A 0A BD 1E      jmp _gets_loop
0196+  1F4D             _gets_NULL:
0197+  1F4D 19 00         mov al, $00
0198+  1F4F 3E            mov [d], al
0199+  1F50 79            inc d
0200+  1F51 0A BD 1E      jmp _gets_loop
0201+  1F54             _gets_end:
0202+  1F54 19 00         mov al, 0
0203+  1F56 3E            mov [d], al        ; terminate string
0204+  1F57 E7            pop d
0205+  1F58 E4            pop a
0206+  1F59 09            ret
0207+  1F5A             
0208+  1F5A             ;-----------------------------------------------------------------------------
0209+  1F5A             ;; INPUT TEXT
0210+  1F5A             ;; terminated with CTRL+D
0211+  1F5A             ;; pointer in D
0212+  1F5A             ;-----------------------------------------------------------------------------
0213+  1F5A             _gettxt:
0214+  1F5A D7            push a
0215+  1F5B DA            push d
0216+  1F5C             _gettxt_loop:
0217+  1F5C 19 01         mov al, 1
0218+  1F5E 05 03         syscall sys_io      ; receive in AH
0219+  1F60 B9 00         cmp al, 0        ; check error code (AL)
0220+  1F62 C6 5C 1F      je _gettxt_loop    ; if no char received, retry
0221+  1F65 76 04         cmp ah, 4      ; EOT
0222+  1F67 C6 A5 1F      je _gettxt_end
0223+  1F6A 76 08         cmp ah, $08      ; check for backspace
0224+  1F6C C6 A1 1F      je _gettxt_backspace
0225+  1F6F 76 5C         cmp ah, $5C        ; '\'
0226+  1F71 C6 7A 1F      je _gettxt_escape
0227+  1F74 1A            mov al, ah
0228+  1F75 3E            mov [d], al
0229+  1F76 79            inc d
0230+  1F77 0A 5C 1F      jmp _gettxt_loop
0231+  1F7A             _gettxt_escape:
0232+  1F7A 19 01         mov al, 1
0233+  1F7C 05 03         syscall sys_io      ; receive in AH
0234+  1F7E B9 00         cmp al, 0        ; check error code (AL)
0235+  1F80 C6 7A 1F      je _gettxt_escape    ; if no char received, retry
0236+  1F83 76 6E         cmp ah, 'n'
0237+  1F85 C6 93 1F      je _gettxt_LF
0238+  1F88 76 72         cmp ah, 'r'
0239+  1F8A C6 9A 1F      je _gettxt_CR
0240+  1F8D 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0241+  1F8E 3E            mov [d], al
0242+  1F8F 79            inc d
0243+  1F90 0A 5C 1F      jmp _gettxt_loop
0244+  1F93             _gettxt_LF:
0245+  1F93 19 0A         mov al, $0A
0246+  1F95 3E            mov [d], al
0247+  1F96 79            inc d
0248+  1F97 0A 5C 1F      jmp _gettxt_loop
0249+  1F9A             _gettxt_CR:
0250+  1F9A 19 0D         mov al, $0D
0251+  1F9C 3E            mov [d], al
0252+  1F9D 79            inc d
0253+  1F9E 0A 5C 1F      jmp _gettxt_loop
0254+  1FA1             _gettxt_backspace:
0255+  1FA1 7F            dec d
0256+  1FA2 0A 5C 1F      jmp _gettxt_loop
0257+  1FA5             _gettxt_end:
0258+  1FA5 19 00         mov al, 0
0259+  1FA7 3E            mov [d], al        ; terminate string
0260+  1FA8 E7            pop d
0261+  1FA9 E4            pop a
0262+  1FAA 09            ret
0263+  1FAB             
0264+  1FAB             ;-----------------------------------------------------------------------------
0265+  1FAB             ; PRINT NEW LINE
0266+  1FAB             ;-----------------------------------------------------------------------------
0267+  1FAB             printnl:
0268+  1FAB D7            push a
0269+  1FAC 10 00 0A      mov a, $0A00
0270+  1FAF 05 03         syscall sys_io
0271+  1FB1 10 00 0D      mov a, $0D00
0272+  1FB4 05 03         syscall sys_io
0273+  1FB6 E4            pop a
0274+  1FB7 09            ret
0275+  1FB8             
0276+  1FB8             ;-----------------------------------------------------------------------------
0277+  1FB8             ; _strtoint
0278+  1FB8             ; 4 digit hex string number in d
0279+  1FB8             ; integer returned in A
0280+  1FB8             ;-----------------------------------------------------------------------------
0281+  1FB8             _strtointx:
0282+  1FB8 D8            push b
0283+  1FB9 32            mov bl, [d]
0284+  1FBA 37            mov bh, bl
0285+  1FBB 33 01 00      mov bl, [d + 1]
0286+  1FBE 07 72 1E      call _atoi        ; convert to int in AL
0287+  1FC1 23            mov ah, al        ; move to AH
0288+  1FC2 33 02 00      mov bl, [d + 2]
0289+  1FC5 37            mov bh, bl
0290+  1FC6 33 03 00      mov bl, [d + 3]
0291+  1FC9 07 72 1E      call _atoi        ; convert to int in AL
0292+  1FCC E5            pop b
0293+  1FCD 09            ret
0294+  1FCE             
0295+  1FCE             ;-----------------------------------------------------------------------------
0296+  1FCE             ; _strtoint
0297+  1FCE             ; 5 digit base10 string number in d
0298+  1FCE             ; integer returned in A
0299+  1FCE             ;-----------------------------------------------------------------------------
0300+  1FCE             _strtoint:
0301+  1FCE E2            push si
0302+  1FCF D8            push b
0303+  1FD0 D9            push c
0304+  1FD1 DA            push d
0305+  1FD2 07 14 1E      call _strlen      ; get string length in C
0306+  1FD5 7E            dec c
0307+  1FD6 FD 4E         mov si, d
0308+  1FD8 12            mov a, c
0309+  1FD9 FD 99         shl a
0310+  1FDB 3B 4A 21      mov d, table_power
0311+  1FDE 59            add d, a
0312+  1FDF 38 00 00      mov c, 0
0313+  1FE2             _strtoint_L0:
0314+  1FE2 F6            lodsb      ; load ASCII to al
0315+  1FE3 B9 00         cmp al, 0
0316+  1FE5 C6 F8 1F      je _strtoint_end
0317+  1FE8 6F 30         sub al, $30    ; make into integer
0318+  1FEA 22 00         mov ah, 0
0319+  1FEC 2A            mov b, [d]
0320+  1FED AC            mul a, b      ; result in B since it fits in 16bits
0321+  1FEE 11            mov a, b
0322+  1FEF 28            mov b, c
0323+  1FF0 54            add a, b
0324+  1FF1 39            mov c, a
0325+  1FF2 63 02 00      sub d, 2
0326+  1FF5 0A E2 1F      jmp _strtoint_L0
0327+  1FF8             _strtoint_end:
0328+  1FF8 12            mov a, c
0329+  1FF9 E7            pop d
0330+  1FFA E6            pop c
0331+  1FFB E5            pop b
0332+  1FFC EF            pop si
0333+  1FFD 09            ret
0334+  1FFE             
0335+  1FFE             ;-----------------------------------------------------------------------------
0336+  1FFE             ; PRINT NULL TERMINATED STRING
0337+  1FFE             ; pointer in D
0338+  1FFE             ;-----------------------------------------------------------------------------
0339+  1FFE             _puts:
0340+  1FFE D7            push a
0341+  1FFF DA            push d
0342+  2000             _puts_L1:
0343+  2000 1E            mov al, [d]
0344+  2001 B9 00         cmp al, 0
0345+  2003 C6 0F 20      jz _puts_END
0346+  2006 23            mov ah, al
0347+  2007 19 00         mov al, 0
0348+  2009 05 03         syscall sys_io
0349+  200B 79            inc d
0350+  200C 0A 00 20      jmp _puts_L1
0351+  200F             _puts_END:
0352+  200F E7            pop d
0353+  2010 E4            pop a
0354+  2011 09            ret
0355+  2012             
0356+  2012             ;-----------------------------------------------------------------------------
0357+  2012             ; PRINT N SIZE STRING
0358+  2012             ; pointer in D
0359+  2012             ; size in C
0360+  2012             ;-----------------------------------------------------------------------------
0361+  2012             _putsn:
0362+  2012 DB            push al
0363+  2013 DA            push d
0364+  2014 D9            push c
0365+  2015             _putsn_L0:
0366+  2015 1E            mov al, [d]
0367+  2016 23            mov ah, al
0368+  2017 19 00         mov al, 0
0369+  2019 05 03         syscall sys_io
0370+  201B 79            inc d
0371+  201C 7E            dec c  
0372+  201D C2 00 00      cmp c, 0
0373+  2020 C7 15 20      jne _putsn_L0
0374+  2023             _putsn_end:
0375+  2023 E6            pop c
0376+  2024 E7            pop d
0377+  2025 E8            pop al
0378+  2026 09            ret
0379+  2027             
0380+  2027             ;-----------------------------------------------------------------------------
0381+  2027             ; print 16bit decimal number
0382+  2027             ; input number in A
0383+  2027             ;-----------------------------------------------------------------------------
0384+  2027             print_u16d:
0385+  2027 D7            push a
0386+  2028 D8            push b
0387+  2029 26 10 27      mov b, 10000
0388+  202C AE            div a, b      ; get 10000's coeff.
0389+  202D 07 4F 20      call print_number
0390+  2030 11            mov a, b
0391+  2031 26 E8 03      mov b, 1000
0392+  2034 AE            div a, b      ; get 1000's coeff.
0393+  2035 07 4F 20      call print_number
0394+  2038 11            mov a, b
0395+  2039 26 64 00      mov b, 100
0396+  203C AE            div a, b
0397+  203D 07 4F 20      call print_number
0398+  2040 11            mov a, b
0399+  2041 26 0A 00      mov b, 10
0400+  2044 AE            div a, b
0401+  2045 07 4F 20      call print_number
0402+  2048 1B            mov al, bl      ; 1's coeff in bl
0403+  2049 07 4F 20      call print_number
0404+  204C E5            pop b
0405+  204D E4            pop a
0406+  204E 09            ret
0407+  204F             
0408+  204F             ;-----------------------------------------------------------------------------
0409+  204F             ; print AL
0410+  204F             ;-----------------------------------------------------------------------------
0411+  204F             print_number:
0412+  204F 6A 30         add al, $30
0413+  2051 23            mov ah, al
0414+  2052 07 B4 1E      call _putchar
0415+  2055 09            ret
0416+  2056             
0417+  2056             ;-----------------------------------------------------------------------------
0418+  2056             ; PRINT 16BIT HEX INTEGER
0419+  2056             ; integer value in reg B
0420+  2056             ;-----------------------------------------------------------------------------
0421+  2056             print_u16x:
0422+  2056 D7            push a
0423+  2057 D8            push b
0424+  2058 DD            push bl
0425+  2059 30            mov bl, bh
0426+  205A 07 82 1E      call _itoa        ; convert bh to char in A
0427+  205D 2F            mov bl, al        ; save al
0428+  205E 19 00         mov al, 0
0429+  2060 05 03         syscall sys_io        ; display AH
0430+  2062 24            mov ah, bl        ; retrieve al
0431+  2063 19 00         mov al, 0
0432+  2065 05 03         syscall sys_io        ; display AL
0433+  2067             
0434+  2067 EA            pop bl
0435+  2068 07 82 1E      call _itoa        ; convert bh to char in A
0436+  206B 2F            mov bl, al        ; save al
0437+  206C 19 00         mov al, 0
0438+  206E 05 03         syscall sys_io        ; display AH
0439+  2070 24            mov ah, bl        ; retrieve al
0440+  2071 19 00         mov al, 0
0441+  2073 05 03         syscall sys_io        ; display AL
0442+  2075             
0443+  2075 E5            pop b
0444+  2076 E4            pop a
0445+  2077 09            ret
0446+  2078             
0447+  2078             ;-----------------------------------------------------------------------------
0448+  2078             ; INPUT 16BIT HEX INTEGER
0449+  2078             ; read 16bit integer into A
0450+  2078             ;-----------------------------------------------------------------------------
0451+  2078             scan_u16x:
0452+  2078 F8 10 00      enter 16
0453+  207B D8            push b
0454+  207C DA            push d
0455+  207D             
0456+  207D FA F1 FF      lea d, [bp + -15]
0457+  2080 07 BB 1E      call _gets        ; get number
0458+  2083             
0459+  2083 32            mov bl, [d]
0460+  2084 37            mov bh, bl
0461+  2085 33 01 00      mov bl, [d + 1]
0462+  2088 07 72 1E      call _atoi        ; convert to int in AL
0463+  208B 23            mov ah, al        ; move to AH
0464+  208C             
0465+  208C 33 02 00      mov bl, [d + 2]
0466+  208F 37            mov bh, bl
0467+  2090 33 03 00      mov bl, [d + 3]
0468+  2093 07 72 1E      call _atoi        ; convert to int in AL
0469+  2096             
0470+  2096 E7            pop d
0471+  2097 E5            pop b
0472+  2098 F9            leave
0473+  2099 09            ret
0474+  209A             
0475+  209A             ;-----------------------------------------------------------------------------
0476+  209A             ; PRINT 8bit HEX INTEGER
0477+  209A             ; integer value in reg bl
0478+  209A             ;-----------------------------------------------------------------------------
0479+  209A             print_u8x:
0480+  209A D7            push a
0481+  209B DD            push bl
0482+  209C             
0483+  209C 07 82 1E      call _itoa        ; convert bl to char in A
0484+  209F 2F            mov bl, al        ; save al
0485+  20A0 19 00         mov al, 0
0486+  20A2 05 03         syscall sys_io        ; display AH
0487+  20A4 24            mov ah, bl        ; retrieve al
0488+  20A5 19 00         mov al, 0
0489+  20A7 05 03         syscall sys_io        ; display AL
0490+  20A9             
0491+  20A9 EA            pop bl
0492+  20AA E4            pop a
0493+  20AB 09            ret
0494+  20AC             
0495+  20AC             ;-----------------------------------------------------------------------------
0496+  20AC             ; print 8bit decimal unsigned number
0497+  20AC             ; input number in AL
0498+  20AC             ;-----------------------------------------------------------------------------
0499+  20AC             print_u8d:
0500+  20AC D7            push a
0501+  20AD D8            push b
0502+  20AE             
0503+  20AE 22 00         mov ah, 0
0504+  20B0 26 64 00      mov b, 100
0505+  20B3 AE            div a, b
0506+  20B4 D8            push b      ; save remainder
0507+  20B5 B9 00         cmp al, 0
0508+  20B7 C6 C1 20      je skip100
0509+  20BA 6A 30         add al, $30
0510+  20BC 23            mov ah, al
0511+  20BD 19 00         mov al, 0
0512+  20BF 05 03         syscall sys_io  ; print coeff
0513+  20C1             skip100:
0514+  20C1 E4            pop a
0515+  20C2 22 00         mov ah, 0
0516+  20C4 26 0A 00      mov b, 10
0517+  20C7 AE            div a, b
0518+  20C8 D8            push b      ; save remainder
0519+  20C9 B9 00         cmp al, 0
0520+  20CB C6 D5 20      je skip10
0521+  20CE 6A 30         add al, $30
0522+  20D0 23            mov ah, al
0523+  20D1 19 00         mov al, 0
0524+  20D3 05 03         syscall sys_io  ; print coeff
0525+  20D5             skip10:
0526+  20D5 E4            pop a
0527+  20D6 1B            mov al, bl
0528+  20D7 6A 30         add al, $30
0529+  20D9 23            mov ah, al
0530+  20DA 19 00         mov al, 0
0531+  20DC 05 03         syscall sys_io  ; print coeff
0532+  20DE E5            pop b
0533+  20DF E4            pop a
0534+  20E0 09            ret
0535+  20E1             
0536+  20E1             ;-----------------------------------------------------------------------------
0537+  20E1             ; INPUT 8BIT HEX INTEGER
0538+  20E1             ; read 8bit integer into AL
0539+  20E1             ;-----------------------------------------------------------------------------
0540+  20E1             scan_u8x:
0541+  20E1 F8 04 00      enter 4
0542+  20E4 D8            push b
0543+  20E5 DA            push d
0544+  20E6             
0545+  20E6 FA FD FF      lea d, [bp + -3]
0546+  20E9 07 BB 1E      call _gets        ; get number
0547+  20EC             
0548+  20EC 32            mov bl, [d]
0549+  20ED 37            mov bh, bl
0550+  20EE 33 01 00      mov bl, [d + 1]
0551+  20F1 07 72 1E      call _atoi        ; convert to int in AL
0552+  20F4             
0553+  20F4 E7            pop d
0554+  20F5 E5            pop b
0555+  20F6 F9            leave
0556+  20F7 09            ret
0557+  20F8             
0558+  20F8             ;-----------------------------------------------------------------------------
0559+  20F8             ; input decimal number
0560+  20F8             ; result in A
0561+  20F8             ; 655'\0'
0562+  20F8             ; low--------high
0563+  20F8             ;-----------------------------------------------------------------------------
0564+  20F8             scan_u16d:
0565+  20F8 F8 08 00      enter 8
0566+  20FB E2            push si
0567+  20FC D8            push b
0568+  20FD D9            push c
0569+  20FE DA            push d
0570+  20FF FA F9 FF      lea d, [bp +- 7]
0571+  2102 07 BB 1E      call _gets
0572+  2105 07 14 1E      call _strlen      ; get string length in C
0573+  2108 7E            dec c
0574+  2109 FD 4E         mov si, d
0575+  210B 12            mov a, c
0576+  210C FD 99         shl a
0577+  210E 3B 4A 21      mov d, table_power
0578+  2111 59            add d, a
0579+  2112 38 00 00      mov c, 0
0580+  2115             mul_loop:
0581+  2115 F6            lodsb      ; load ASCII to al
0582+  2116 B9 00         cmp al, 0
0583+  2118 C6 2B 21      je mul_exit
0584+  211B 6F 30         sub al, $30    ; make into integer
0585+  211D 22 00         mov ah, 0
0586+  211F 2A            mov b, [d]
0587+  2120 AC            mul a, b      ; result in B since it fits in 16bits
0588+  2121 11            mov a, b
0589+  2122 28            mov b, c
0590+  2123 54            add a, b
0591+  2124 39            mov c, a
0592+  2125 63 02 00      sub d, 2
0593+  2128 0A 15 21      jmp mul_loop
0594+  212B             mul_exit:
0595+  212B 12            mov a, c
0596+  212C E7            pop d
0597+  212D E6            pop c
0598+  212E E5            pop b
0599+  212F EF            pop si
0600+  2130 F9            leave
0601+  2131 09            ret
0602+  2132             
0603+  2132 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0603+  2136 34 35 36 37 
0603+  213A 38 39 41 42 
0603+  213E 43 44 45 46 
0604+  2142 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0604+  2146 1B 5B 48 00 
0605+  214A             
0606+  214A             table_power:
0607+  214A 01 00         .dw 1
0608+  214C 0A 00         .dw 10
0609+  214E 64 00         .dw 100
0610+  2150 E8 03         .dw 1000
0611+  2152 10 27         .dw 100004192   2154             ; --- END INLINE ASM SEGMENT
4193   2154             
4194   2154 F9            leave
4195   2155 09            ret
4196   2156             ; --- END TEXT SEGMENT
4197   2156             
4198   2156             ; --- BEGIN DATA SEGMENT
4199   2156 00 00       st_fopen_max_handle: .dw 0
4200   2158 55 6E 65 78 _s0: .db "Unexpected format in printf.", 0
4200   215C 70 65 63 74 
4200   2160 65 64 20 66 
4200   2164 6F 72 6D 61 
4200   2168 74 20 69 6E 
4200   216C 20 70 72 69 
4200   2170 6E 74 66 2E 
4200   2174 00 
4201   2175 45 72 72 6F _s1: .db "Error: Unknown argument type.\n", 0
4201   2179 72 3A 20 55 
4201   217D 6E 6B 6E 6F 
4201   2181 77 6E 20 61 
4201   2185 72 67 75 6D 
4201   2189 65 6E 74 20 
4201   218D 74 79 70 65 
4201   2191 2E 0A 00 
4202   2194 1B 5B 32 4A _s2: .db "\033[2J\033[H", 0
4202   2198 1B 5B 48 00 
4203   219C             
4204   219C 9E 21       _heap_top: .dw _heap
4205   219E 00          _heap: .db 0
4206   219F             ; --- END DATA SEGMENT
4207   219F             
4208   219F             .end
tasm: Number of errors = 0
