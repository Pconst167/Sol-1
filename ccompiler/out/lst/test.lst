0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0000             
0005   0000             ; --- BEGIN TEXT SEGMENT
0006   0400             .org text_org
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; printf(strings[1]); 
0011   0408             ; --- START FUNCTION CALL
0012   0408 3B 35 0D      mov d, _strings_data ; $strings
0013   040B D7            push a
0014   040C DA            push d
0015   040D FD 2E 01 00   mov32 cb, $00000001
0015   0411 00 00 
0016   0413 E7            pop d
0017   0414 FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
0018   0418 E4            pop a
0019   0419 2A            mov b, [d]
0020   041A 38 00 00      mov c, 0
0021   041D FD AB         swp b
0022   041F D8            push b
0023   0420 07 28 04      call printf
0024   0423 51 02 00      add sp, 2
0025   0426             ; --- END FUNCTION CALL
0026   0426 05 0B         syscall sys_terminate_proc
0027   0428             
0028   0428             printf:
0029   0428 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0030   042B             ; char *p, *format_p; 
0031   042B 52 02 00      sub sp, 2
0032   042E 52 02 00      sub sp, 2
0033   0431             ; format_p = format; 
0034   0431 FA FD FF      lea d, [bp + -3] ; $format_p
0035   0434 DA            push d
0036   0435 FA 05 00      lea d, [bp + 5] ; $format
0037   0438 2A            mov b, [d]
0038   0439 38 00 00      mov c, 0
0039   043C E7            pop d
0040   043D FD 43         mov [d], b
0041   043F             ; p = &format + 2; 
0042   043F FA FF FF      lea d, [bp + -1] ; $p
0043   0442 DA            push d
0044   0443 FA 05 00      lea d, [bp + 5] ; $format
0045   0446 2D            mov b, d
0046   0447             ; --- START TERMS
0047   0447 D7            push a
0048   0448 11            mov a, b
0049   0449 FD 2E 02 00   mov32 cb, $00000002
0049   044D 00 00 
0050   044F 56            add b, a
0051   0450 E4            pop a
0052   0451             ; --- END TERMS
0053   0451 E7            pop d
0054   0452 FD 43         mov [d], b
0055   0454             ; for(;;){ 
0056   0454             _for1_init:
0057   0454             _for1_cond:
0058   0454             _for1_block:
0059   0454             ; if(!*format_p) break; 
0060   0454             _if2_cond:
0061   0454 FA FD FF      lea d, [bp + -3] ; $format_p
0062   0457 2A            mov b, [d]
0063   0458 38 00 00      mov c, 0
0064   045B 74            mov d, b
0065   045C 32            mov bl, [d]
0066   045D A7 00         mov bh, 0
0067   045F 38 00 00      mov c, 0
0068   0462 C0 00 00      cmp b, 0
0069   0465 FD 71         seq ; !
0070   0467 C0 00 00      cmp b, 0
0071   046A C6 73 04      je _if2_else
0072   046D             _if2_TRUE:
0073   046D             ; break; 
0074   046D 0A 23 07      jmp _for1_exit ; for break
0075   0470 0A 20 07      jmp _if2_exit
0076   0473             _if2_else:
0077   0473             ; if(*format_p == '%'){ 
0078   0473             _if3_cond:
0079   0473 FA FD FF      lea d, [bp + -3] ; $format_p
0080   0476 2A            mov b, [d]
0081   0477 38 00 00      mov c, 0
0082   047A 74            mov d, b
0083   047B 32            mov bl, [d]
0084   047C A7 00         mov bh, 0
0085   047E 38 00 00      mov c, 0
0086   0481             ; --- START RELATIONAL
0087   0481 D7            push a
0088   0482 11            mov a, b
0089   0483 FD 2E 25 00   mov32 cb, $00000025
0089   0487 00 00 
0090   0489 B0            cmp a, b
0091   048A FD 71         seq ; ==
0092   048C E4            pop a
0093   048D             ; --- END RELATIONAL
0094   048D C0 00 00      cmp b, 0
0095   0490 C6 FB 06      je _if3_else
0096   0493             _if3_TRUE:
0097   0493             ; format_p++; 
0098   0493 FA FD FF      lea d, [bp + -3] ; $format_p
0099   0496 2A            mov b, [d]
0100   0497 38 00 00      mov c, 0
0101   049A FD 77         inc b
0102   049C FA FD FF      lea d, [bp + -3] ; $format_p
0103   049F FD 43         mov [d], b
0104   04A1 FD 7D         dec b
0105   04A3             ; switch(*format_p){ 
0106   04A3             _switch4_expr:
0107   04A3 FA FD FF      lea d, [bp + -3] ; $format_p
0108   04A6 2A            mov b, [d]
0109   04A7 38 00 00      mov c, 0
0110   04AA 74            mov d, b
0111   04AB 32            mov bl, [d]
0112   04AC A7 00         mov bh, 0
0113   04AE 38 00 00      mov c, 0
0114   04B1             _switch4_comparisons:
0115   04B1 C1 6C         cmp bl, $6c
0116   04B3 C6 DF 04      je _switch4_case0
0117   04B6 C1 4C         cmp bl, $4c
0118   04B8 C6 DF 04      je _switch4_case1
0119   04BB C1 64         cmp bl, $64
0120   04BD C6 EF 05      je _switch4_case2
0121   04C0 C1 69         cmp bl, $69
0122   04C2 C6 EF 05      je _switch4_case3
0123   04C5 C1 75         cmp bl, $75
0124   04C7 C6 1F 06      je _switch4_case4
0125   04CA C1 78         cmp bl, $78
0126   04CC C6 4F 06      je _switch4_case5
0127   04CF C1 63         cmp bl, $63
0128   04D1 C6 7F 06      je _switch4_case6
0129   04D4 C1 73         cmp bl, $73
0130   04D6 C6 AF 06      je _switch4_case7
0131   04D9 0A DC 06      jmp _switch4_default
0132   04DC 0A E8 06      jmp _switch4_exit
0133   04DF             _switch4_case0:
0134   04DF             _switch4_case1:
0135   04DF             ; format_p++; 
0136   04DF FA FD FF      lea d, [bp + -3] ; $format_p
0137   04E2 2A            mov b, [d]
0138   04E3 38 00 00      mov c, 0
0139   04E6 FD 77         inc b
0140   04E8 FA FD FF      lea d, [bp + -3] ; $format_p
0141   04EB FD 43         mov [d], b
0142   04ED FD 7D         dec b
0143   04EF             ; if(*format_p == 'd' || *format_p == 'i') 
0144   04EF             _if5_cond:
0145   04EF FA FD FF      lea d, [bp + -3] ; $format_p
0146   04F2 2A            mov b, [d]
0147   04F3 38 00 00      mov c, 0
0148   04F6 74            mov d, b
0149   04F7 32            mov bl, [d]
0150   04F8 A7 00         mov bh, 0
0151   04FA 38 00 00      mov c, 0
0152   04FD             ; --- START RELATIONAL
0153   04FD D7            push a
0154   04FE 11            mov a, b
0155   04FF FD 2E 64 00   mov32 cb, $00000064
0155   0503 00 00 
0156   0505 B0            cmp a, b
0157   0506 FD 71         seq ; ==
0158   0508 E4            pop a
0159   0509             ; --- END RELATIONAL
0160   0509             ; --- START LOGICAL OR
0161   0509 D7            push a
0162   050A 11            mov a, b
0163   050B FA FD FF      lea d, [bp + -3] ; $format_p
0164   050E 2A            mov b, [d]
0165   050F 38 00 00      mov c, 0
0166   0512 74            mov d, b
0167   0513 32            mov bl, [d]
0168   0514 A7 00         mov bh, 0
0169   0516 38 00 00      mov c, 0
0170   0519             ; --- START RELATIONAL
0171   0519 D7            push a
0172   051A 11            mov a, b
0173   051B FD 2E 69 00   mov32 cb, $00000069
0173   051F 00 00 
0174   0521 B0            cmp a, b
0175   0522 FD 71         seq ; ==
0176   0524 E4            pop a
0177   0525             ; --- END RELATIONAL
0178   0525 FD A8         sor a, b ; ||
0179   0527 E4            pop a
0180   0528             ; --- END LOGICAL OR
0181   0528 C0 00 00      cmp b, 0
0182   052B C6 4C 05      je _if5_else
0183   052E             _if5_TRUE:
0184   052E             ; print_signed_long(*(long *)p); 
0185   052E             ; --- START FUNCTION CALL
0186   052E FA FF FF      lea d, [bp + -1] ; $p
0187   0531 2A            mov b, [d]
0188   0532 38 00 00      mov c, 0
0189   0535 74            mov d, b
0190   0536 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0191   0539 FD 39         mov c, b ; And place it into C
0192   053B 2A            mov b, [d] ; Lower Word in B
0193   053C 12            mov a, c
0194   053D FD AA         swp a
0195   053F D7            push a
0196   0540 FD AB         swp b
0197   0542 D8            push b
0198   0543 07 25 07      call print_signed_long
0199   0546 51 04 00      add sp, 4
0200   0549             ; --- END FUNCTION CALL
0201   0549 0A D4 05      jmp _if5_exit
0202   054C             _if5_else:
0203   054C             ; if(*format_p == 'u') 
0204   054C             _if6_cond:
0205   054C FA FD FF      lea d, [bp + -3] ; $format_p
0206   054F 2A            mov b, [d]
0207   0550 38 00 00      mov c, 0
0208   0553 74            mov d, b
0209   0554 32            mov bl, [d]
0210   0555 A7 00         mov bh, 0
0211   0557 38 00 00      mov c, 0
0212   055A             ; --- START RELATIONAL
0213   055A D7            push a
0214   055B 11            mov a, b
0215   055C FD 2E 75 00   mov32 cb, $00000075
0215   0560 00 00 
0216   0562 B0            cmp a, b
0217   0563 FD 71         seq ; ==
0218   0565 E4            pop a
0219   0566             ; --- END RELATIONAL
0220   0566 C0 00 00      cmp b, 0
0221   0569 C6 8A 05      je _if6_else
0222   056C             _if6_TRUE:
0223   056C             ; print_unsigned_long(*(unsigned long *)p); 
0224   056C             ; --- START FUNCTION CALL
0225   056C FA FF FF      lea d, [bp + -1] ; $p
0226   056F 2A            mov b, [d]
0227   0570 38 00 00      mov c, 0
0228   0573 74            mov d, b
0229   0574 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0230   0577 FD 39         mov c, b ; And place it into C
0231   0579 2A            mov b, [d] ; Lower Word in B
0232   057A 12            mov a, c
0233   057B FD AA         swp a
0234   057D D7            push a
0235   057E FD AB         swp b
0236   0580 D8            push b
0237   0581 07 B8 08      call print_unsigned_long
0238   0584 51 04 00      add sp, 4
0239   0587             ; --- END FUNCTION CALL
0240   0587 0A D4 05      jmp _if6_exit
0241   058A             _if6_else:
0242   058A             ; if(*format_p == 'x') 
0243   058A             _if7_cond:
0244   058A FA FD FF      lea d, [bp + -3] ; $format_p
0245   058D 2A            mov b, [d]
0246   058E 38 00 00      mov c, 0
0247   0591 74            mov d, b
0248   0592 32            mov bl, [d]
0249   0593 A7 00         mov bh, 0
0250   0595 38 00 00      mov c, 0
0251   0598             ; --- START RELATIONAL
0252   0598 D7            push a
0253   0599 11            mov a, b
0254   059A FD 2E 78 00   mov32 cb, $00000078
0254   059E 00 00 
0255   05A0 B0            cmp a, b
0256   05A1 FD 71         seq ; ==
0257   05A3 E4            pop a
0258   05A4             ; --- END RELATIONAL
0259   05A4 C0 00 00      cmp b, 0
0260   05A7 C6 C8 05      je _if7_else
0261   05AA             _if7_TRUE:
0262   05AA             ; printx32(*(long int *)p); 
0263   05AA             ; --- START FUNCTION CALL
0264   05AA FA FF FF      lea d, [bp + -1] ; $p
0265   05AD 2A            mov b, [d]
0266   05AE 38 00 00      mov c, 0
0267   05B1 74            mov d, b
0268   05B2 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0269   05B5 FD 39         mov c, b ; And place it into C
0270   05B7 2A            mov b, [d] ; Lower Word in B
0271   05B8 12            mov a, c
0272   05B9 FD AA         swp a
0273   05BB D7            push a
0274   05BC FD AB         swp b
0275   05BE D8            push b
0276   05BF 07 EC 09      call printx32
0277   05C2 51 04 00      add sp, 4
0278   05C5             ; --- END FUNCTION CALL
0279   05C5 0A D4 05      jmp _if7_exit
0280   05C8             _if7_else:
0281   05C8             ; err("Unexpected format in printf."); 
0282   05C8             ; --- START FUNCTION CALL
0283   05C8 26 51 0D      mov b, _s3 ; "Unexpected format in printf."
0284   05CB FD AB         swp b
0285   05CD D8            push b
0286   05CE 07 4C 0A      call err
0287   05D1 51 02 00      add sp, 2
0288   05D4             ; --- END FUNCTION CALL
0289   05D4             _if7_exit:
0290   05D4             _if6_exit:
0291   05D4             _if5_exit:
0292   05D4             ; p = p + 4; 
0293   05D4 FA FF FF      lea d, [bp + -1] ; $p
0294   05D7 DA            push d
0295   05D8 FA FF FF      lea d, [bp + -1] ; $p
0296   05DB 2A            mov b, [d]
0297   05DC 38 00 00      mov c, 0
0298   05DF             ; --- START TERMS
0299   05DF D7            push a
0300   05E0 11            mov a, b
0301   05E1 FD 2E 04 00   mov32 cb, $00000004
0301   05E5 00 00 
0302   05E7 56            add b, a
0303   05E8 E4            pop a
0304   05E9             ; --- END TERMS
0305   05E9 E7            pop d
0306   05EA FD 43         mov [d], b
0307   05EC             ; break; 
0308   05EC 0A E8 06      jmp _switch4_exit ; case break
0309   05EF             _switch4_case2:
0310   05EF             _switch4_case3:
0311   05EF             ; print_signed(*(int*)p); 
0312   05EF             ; --- START FUNCTION CALL
0313   05EF FA FF FF      lea d, [bp + -1] ; $p
0314   05F2 2A            mov b, [d]
0315   05F3 38 00 00      mov c, 0
0316   05F6 74            mov d, b
0317   05F7 2A            mov b, [d]
0318   05F8 38 00 00      mov c, 0
0319   05FB FD AB         swp b
0320   05FD D8            push b
0321   05FE 07 7A 0A      call print_signed
0322   0601 51 02 00      add sp, 2
0323   0604             ; --- END FUNCTION CALL
0324   0604             ; p = p + 2; 
0325   0604 FA FF FF      lea d, [bp + -1] ; $p
0326   0607 DA            push d
0327   0608 FA FF FF      lea d, [bp + -1] ; $p
0328   060B 2A            mov b, [d]
0329   060C 38 00 00      mov c, 0
0330   060F             ; --- START TERMS
0331   060F D7            push a
0332   0610 11            mov a, b
0333   0611 FD 2E 02 00   mov32 cb, $00000002
0333   0615 00 00 
0334   0617 56            add b, a
0335   0618 E4            pop a
0336   0619             ; --- END TERMS
0337   0619 E7            pop d
0338   061A FD 43         mov [d], b
0339   061C             ; break; 
0340   061C 0A E8 06      jmp _switch4_exit ; case break
0341   061F             _switch4_case4:
0342   061F             ; print_unsigned(*(unsigned int*)p); 
0343   061F             ; --- START FUNCTION CALL
0344   061F FA FF FF      lea d, [bp + -1] ; $p
0345   0622 2A            mov b, [d]
0346   0623 38 00 00      mov c, 0
0347   0626 74            mov d, b
0348   0627 2A            mov b, [d]
0349   0628 38 00 00      mov c, 0
0350   062B FD AB         swp b
0351   062D D8            push b
0352   062E 07 CB 0B      call print_unsigned
0353   0631 51 02 00      add sp, 2
0354   0634             ; --- END FUNCTION CALL
0355   0634             ; p = p + 2; 
0356   0634 FA FF FF      lea d, [bp + -1] ; $p
0357   0637 DA            push d
0358   0638 FA FF FF      lea d, [bp + -1] ; $p
0359   063B 2A            mov b, [d]
0360   063C 38 00 00      mov c, 0
0361   063F             ; --- START TERMS
0362   063F D7            push a
0363   0640 11            mov a, b
0364   0641 FD 2E 02 00   mov32 cb, $00000002
0364   0645 00 00 
0365   0647 56            add b, a
0366   0648 E4            pop a
0367   0649             ; --- END TERMS
0368   0649 E7            pop d
0369   064A FD 43         mov [d], b
0370   064C             ; break; 
0371   064C 0A E8 06      jmp _switch4_exit ; case break
0372   064F             _switch4_case5:
0373   064F             ; printx16(*(int*)p); 
0374   064F             ; --- START FUNCTION CALL
0375   064F FA FF FF      lea d, [bp + -1] ; $p
0376   0652 2A            mov b, [d]
0377   0653 38 00 00      mov c, 0
0378   0656 74            mov d, b
0379   0657 2A            mov b, [d]
0380   0658 38 00 00      mov c, 0
0381   065B FD AB         swp b
0382   065D D8            push b
0383   065E 07 E3 0C      call printx16
0384   0661 51 02 00      add sp, 2
0385   0664             ; --- END FUNCTION CALL
0386   0664             ; p = p + 2; 
0387   0664 FA FF FF      lea d, [bp + -1] ; $p
0388   0667 DA            push d
0389   0668 FA FF FF      lea d, [bp + -1] ; $p
0390   066B 2A            mov b, [d]
0391   066C 38 00 00      mov c, 0
0392   066F             ; --- START TERMS
0393   066F D7            push a
0394   0670 11            mov a, b
0395   0671 FD 2E 02 00   mov32 cb, $00000002
0395   0675 00 00 
0396   0677 56            add b, a
0397   0678 E4            pop a
0398   0679             ; --- END TERMS
0399   0679 E7            pop d
0400   067A FD 43         mov [d], b
0401   067C             ; break; 
0402   067C 0A E8 06      jmp _switch4_exit ; case break
0403   067F             _switch4_case6:
0404   067F             ; putchar(*(char*)p); 
0405   067F             ; --- START FUNCTION CALL
0406   067F FA FF FF      lea d, [bp + -1] ; $p
0407   0682 2A            mov b, [d]
0408   0683 38 00 00      mov c, 0
0409   0686 74            mov d, b
0410   0687 32            mov bl, [d]
0411   0688 A7 00         mov bh, 0
0412   068A 38 00 00      mov c, 0
0413   068D DD            push bl
0414   068E 07 AA 08      call putchar
0415   0691 51 01 00      add sp, 1
0416   0694             ; --- END FUNCTION CALL
0417   0694             ; p = p + 2; 
0418   0694 FA FF FF      lea d, [bp + -1] ; $p
0419   0697 DA            push d
0420   0698 FA FF FF      lea d, [bp + -1] ; $p
0421   069B 2A            mov b, [d]
0422   069C 38 00 00      mov c, 0
0423   069F             ; --- START TERMS
0424   069F D7            push a
0425   06A0 11            mov a, b
0426   06A1 FD 2E 02 00   mov32 cb, $00000002
0426   06A5 00 00 
0427   06A7 56            add b, a
0428   06A8 E4            pop a
0429   06A9             ; --- END TERMS
0430   06A9 E7            pop d
0431   06AA FD 43         mov [d], b
0432   06AC             ; break; 
0433   06AC 0A E8 06      jmp _switch4_exit ; case break
0434   06AF             _switch4_case7:
0435   06AF             ; print(*(char**)p); 
0436   06AF             ; --- START FUNCTION CALL
0437   06AF FA FF FF      lea d, [bp + -1] ; $p
0438   06B2 2A            mov b, [d]
0439   06B3 38 00 00      mov c, 0
0440   06B6 74            mov d, b
0441   06B7 2A            mov b, [d]
0442   06B8 FD AB         swp b
0443   06BA D8            push b
0444   06BB 07 61 0A      call print
0445   06BE 51 02 00      add sp, 2
0446   06C1             ; --- END FUNCTION CALL
0447   06C1             ; p = p + 2; 
0448   06C1 FA FF FF      lea d, [bp + -1] ; $p
0449   06C4 DA            push d
0450   06C5 FA FF FF      lea d, [bp + -1] ; $p
0451   06C8 2A            mov b, [d]
0452   06C9 38 00 00      mov c, 0
0453   06CC             ; --- START TERMS
0454   06CC D7            push a
0455   06CD 11            mov a, b
0456   06CE FD 2E 02 00   mov32 cb, $00000002
0456   06D2 00 00 
0457   06D4 56            add b, a
0458   06D5 E4            pop a
0459   06D6             ; --- END TERMS
0460   06D6 E7            pop d
0461   06D7 FD 43         mov [d], b
0462   06D9             ; break; 
0463   06D9 0A E8 06      jmp _switch4_exit ; case break
0464   06DC             _switch4_default:
0465   06DC             ; print("Error: Unknown argument type.\n"); 
0466   06DC             ; --- START FUNCTION CALL
0467   06DC 26 6E 0D      mov b, _s4 ; "Error: Unknown argument type.\n"
0468   06DF FD AB         swp b
0469   06E1 D8            push b
0470   06E2 07 61 0A      call print
0471   06E5 51 02 00      add sp, 2
0472   06E8             ; --- END FUNCTION CALL
0473   06E8             _switch4_exit:
0474   06E8             ; format_p++; 
0475   06E8 FA FD FF      lea d, [bp + -3] ; $format_p
0476   06EB 2A            mov b, [d]
0477   06EC 38 00 00      mov c, 0
0478   06EF FD 77         inc b
0479   06F1 FA FD FF      lea d, [bp + -3] ; $format_p
0480   06F4 FD 43         mov [d], b
0481   06F6 FD 7D         dec b
0482   06F8 0A 20 07      jmp _if3_exit
0483   06FB             _if3_else:
0484   06FB             ; putchar(*format_p); 
0485   06FB             ; --- START FUNCTION CALL
0486   06FB FA FD FF      lea d, [bp + -3] ; $format_p
0487   06FE 2A            mov b, [d]
0488   06FF 38 00 00      mov c, 0
0489   0702 74            mov d, b
0490   0703 32            mov bl, [d]
0491   0704 A7 00         mov bh, 0
0492   0706 38 00 00      mov c, 0
0493   0709 DD            push bl
0494   070A 07 AA 08      call putchar
0495   070D 51 01 00      add sp, 1
0496   0710             ; --- END FUNCTION CALL
0497   0710             ; format_p++; 
0498   0710 FA FD FF      lea d, [bp + -3] ; $format_p
0499   0713 2A            mov b, [d]
0500   0714 38 00 00      mov c, 0
0501   0717 FD 77         inc b
0502   0719 FA FD FF      lea d, [bp + -3] ; $format_p
0503   071C FD 43         mov [d], b
0504   071E FD 7D         dec b
0505   0720             _if3_exit:
0506   0720             _if2_exit:
0507   0720             _for1_update:
0508   0720 0A 54 04      jmp _for1_cond
0509   0723             _for1_exit:
0510   0723 F9            leave
0511   0724 09            ret
0512   0725             
0513   0725             print_signed_long:
0514   0725 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0515   0728             ; char digits[10]; 
0516   0728 52 0A 00      sub sp, 10
0517   072B             ; int i = 0; 
0518   072B 52 02 00      sub sp, 2
0519   072E             ; --- START LOCAL VAR INITIALIZATION
0520   072E FA F5 FF      lea d, [bp + -11] ; $i
0521   0731 DA            push d
0522   0732 FD 2E 00 00   mov32 cb, $00000000
0522   0736 00 00 
0523   0738 E7            pop d
0524   0739 FD 43         mov [d], b
0525   073B             ; --- END LOCAL VAR INITIALIZATION
0526   073B             ; if (num < 0) { 
0527   073B             _if8_cond:
0528   073B FA 05 00      lea d, [bp + 5] ; $num
0529   073E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0530   0741 FD 39         mov c, b ; And place it into C
0531   0743 2A            mov b, [d] ; Lower Word in B
0532   0744             ; --- START RELATIONAL
0533   0744 D7            push a
0534   0745 FD D8         push g
0535   0747 11            mov a, b
0536   0748 FD 7A         mov g, c
0537   074A FD 2E 00 00   mov32 cb, $00000000
0537   074E 00 00 
0538   0750 FD AF         cmp32 ga, cb
0539   0752 FD 73         slt ; <
0540   0754 FD F1         pop g
0541   0756 E4            pop a
0542   0757             ; --- END RELATIONAL
0543   0757 C0 00 00      cmp b, 0
0544   075A C6 8C 07      je _if8_else
0545   075D             _if8_TRUE:
0546   075D             ; putchar('-'); 
0547   075D             ; --- START FUNCTION CALL
0548   075D FD 2E 2D 00   mov32 cb, $0000002d
0548   0761 00 00 
0549   0763 DD            push bl
0550   0764 07 AA 08      call putchar
0551   0767 51 01 00      add sp, 1
0552   076A             ; --- END FUNCTION CALL
0553   076A             ; num = -num; 
0554   076A FA 05 00      lea d, [bp + 5] ; $num
0555   076D DA            push d
0556   076E FA 05 00      lea d, [bp + 5] ; $num
0557   0771 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0558   0774 FD 39         mov c, b ; And place it into C
0559   0776 2A            mov b, [d] ; Lower Word in B
0560   0777 12            mov a, c
0561   0778 95            not a
0562   0779 97            not b
0563   077A 55 01 00      add b, 1
0564   077D 5B 00 00      adc a, 0
0565   0780 39            mov c, a
0566   0781 E7            pop d
0567   0782 FD 43         mov [d], b
0568   0784 28            mov b, c
0569   0785 FD 44 02 00   mov [d + 2], b
0570   0789 0A C0 07      jmp _if8_exit
0571   078C             _if8_else:
0572   078C             ; if (num == 0) { 
0573   078C             _if9_cond:
0574   078C FA 05 00      lea d, [bp + 5] ; $num
0575   078F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0576   0792 FD 39         mov c, b ; And place it into C
0577   0794 2A            mov b, [d] ; Lower Word in B
0578   0795             ; --- START RELATIONAL
0579   0795 D7            push a
0580   0796 FD D8         push g
0581   0798 11            mov a, b
0582   0799 FD 7A         mov g, c
0583   079B FD 2E 00 00   mov32 cb, $00000000
0583   079F 00 00 
0584   07A1 FD AF         cmp32 ga, cb
0585   07A3 FD 71         seq ; ==
0586   07A5 FD F1         pop g
0587   07A7 E4            pop a
0588   07A8             ; --- END RELATIONAL
0589   07A8 C0 00 00      cmp b, 0
0590   07AB C6 C0 07      je _if9_exit
0591   07AE             _if9_TRUE:
0592   07AE             ; putchar('0'); 
0593   07AE             ; --- START FUNCTION CALL
0594   07AE FD 2E 30 00   mov32 cb, $00000030
0594   07B2 00 00 
0595   07B4 DD            push bl
0596   07B5 07 AA 08      call putchar
0597   07B8 51 01 00      add sp, 1
0598   07BB             ; --- END FUNCTION CALL
0599   07BB             ; return; 
0600   07BB F9            leave
0601   07BC 09            ret
0602   07BD 0A C0 07      jmp _if9_exit
0603   07C0             _if9_exit:
0604   07C0             _if8_exit:
0605   07C0             ; while (num > 0) { 
0606   07C0             _while10_cond:
0607   07C0 FA 05 00      lea d, [bp + 5] ; $num
0608   07C3 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0609   07C6 FD 39         mov c, b ; And place it into C
0610   07C8 2A            mov b, [d] ; Lower Word in B
0611   07C9             ; --- START RELATIONAL
0612   07C9 D7            push a
0613   07CA FD D8         push g
0614   07CC 11            mov a, b
0615   07CD FD 7A         mov g, c
0616   07CF FD 2E 00 00   mov32 cb, $00000000
0616   07D3 00 00 
0617   07D5 FD AF         cmp32 ga, cb
0618   07D7 FD 7F         sgt
0619   07D9 FD F1         pop g
0620   07DB E4            pop a
0621   07DC             ; --- END RELATIONAL
0622   07DC C0 00 00      cmp b, 0
0623   07DF C6 60 08      je _while10_exit
0624   07E2             _while10_block:
0625   07E2             ; digits[i] = '0' + (num % 10); 
0626   07E2 FA F7 FF      lea d, [bp + -9] ; $digits
0627   07E5 D7            push a
0628   07E6 DA            push d
0629   07E7 FA F5 FF      lea d, [bp + -11] ; $i
0630   07EA 2A            mov b, [d]
0631   07EB 38 00 00      mov c, 0
0632   07EE E7            pop d
0633   07EF 5A            add d, b
0634   07F0 E4            pop a
0635   07F1 DA            push d
0636   07F2 FD 2E 30 00   mov32 cb, $00000030
0636   07F6 00 00 
0637   07F8             ; --- START TERMS
0638   07F8 D7            push a
0639   07F9 11            mov a, b
0640   07FA FA 05 00      lea d, [bp + 5] ; $num
0641   07FD 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0642   0800 FD 39         mov c, b ; And place it into C
0643   0802 2A            mov b, [d] ; Lower Word in B
0644   0803             ; --- START FACTORS
0645   0803 D7            push a
0646   0804 FD D8         push g
0647   0806 11            mov a, b
0648   0807 FD 7A         mov g, c
0649   0809 FD 2E 0A 00   mov32 cb, $0000000a
0649   080D 00 00 
0650   080F FD D8         push g ; save 'g' as the div instruction uses it
0651   0811 AE            div a, b ; %, a: quotient, b: remainder
0652   0812 11            mov a, b
0653   0813 FD F1         pop g
0654   0815 FD 38         mov c, g
0655   0817 27            mov b, a
0656   0818 FD F1         pop g
0657   081A E4            pop a
0658   081B             ; --- END FACTORS
0659   081B FD 15         add32 cb, ga
0660   081D E4            pop a
0661   081E             ; --- END TERMS
0662   081E E7            pop d
0663   081F FD 3E         mov [d], bl
0664   0821             ; num = num / 10; 
0665   0821 FA 05 00      lea d, [bp + 5] ; $num
0666   0824 DA            push d
0667   0825 FA 05 00      lea d, [bp + 5] ; $num
0668   0828 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0669   082B FD 39         mov c, b ; And place it into C
0670   082D 2A            mov b, [d] ; Lower Word in B
0671   082E             ; --- START FACTORS
0672   082E D7            push a
0673   082F FD D8         push g
0674   0831 11            mov a, b
0675   0832 FD 7A         mov g, c
0676   0834 FD 2E 0A 00   mov32 cb, $0000000a
0676   0838 00 00 
0677   083A FD D8         push g ; save 'g' as the div instruction uses it
0678   083C AE            div a, b ; /, a: quotient, b: remainder
0679   083D FD F1         pop g
0680   083F FD 38         mov c, g
0681   0841 27            mov b, a
0682   0842 FD F1         pop g
0683   0844 E4            pop a
0684   0845             ; --- END FACTORS
0685   0845 E7            pop d
0686   0846 FD 43         mov [d], b
0687   0848 28            mov b, c
0688   0849 FD 44 02 00   mov [d + 2], b
0689   084D             ; i++; 
0690   084D FA F5 FF      lea d, [bp + -11] ; $i
0691   0850 2A            mov b, [d]
0692   0851 38 00 00      mov c, 0
0693   0854 11            mov a, b
0694   0855 FD 77         inc b
0695   0857 FA F5 FF      lea d, [bp + -11] ; $i
0696   085A FD 43         mov [d], b
0697   085C 27            mov b, a
0698   085D 0A C0 07      jmp _while10_cond
0699   0860             _while10_exit:
0700   0860             ; while (i > 0) { 
0701   0860             _while17_cond:
0702   0860 FA F5 FF      lea d, [bp + -11] ; $i
0703   0863 2A            mov b, [d]
0704   0864 38 00 00      mov c, 0
0705   0867             ; --- START RELATIONAL
0706   0867 D7            push a
0707   0868 11            mov a, b
0708   0869 FD 2E 00 00   mov32 cb, $00000000
0708   086D 00 00 
0709   086F B0            cmp a, b
0710   0870 FD 7F         sgt ; >
0711   0872 E4            pop a
0712   0873             ; --- END RELATIONAL
0713   0873 C0 00 00      cmp b, 0
0714   0876 C6 A8 08      je _while17_exit
0715   0879             _while17_block:
0716   0879             ; i--; 
0717   0879 FA F5 FF      lea d, [bp + -11] ; $i
0718   087C 2A            mov b, [d]
0719   087D 38 00 00      mov c, 0
0720   0880 11            mov a, b
0721   0881 FD 7D         dec b
0722   0883 FA F5 FF      lea d, [bp + -11] ; $i
0723   0886 FD 43         mov [d], b
0724   0888 27            mov b, a
0725   0889             ; putchar(digits[i]); 
0726   0889             ; --- START FUNCTION CALL
0727   0889 FA F7 FF      lea d, [bp + -9] ; $digits
0728   088C D7            push a
0729   088D DA            push d
0730   088E FA F5 FF      lea d, [bp + -11] ; $i
0731   0891 2A            mov b, [d]
0732   0892 38 00 00      mov c, 0
0733   0895 E7            pop d
0734   0896 5A            add d, b
0735   0897 E4            pop a
0736   0898 32            mov bl, [d]
0737   0899 A7 00         mov bh, 0
0738   089B 38 00 00      mov c, 0
0739   089E DD            push bl
0740   089F 07 AA 08      call putchar
0741   08A2 51 01 00      add sp, 1
0742   08A5             ; --- END FUNCTION CALL
0743   08A5 0A 60 08      jmp _while17_cond
0744   08A8             _while17_exit:
0745   08A8 F9            leave
0746   08A9 09            ret
0747   08AA             
0748   08AA             putchar:
0749   08AA F8 00 00      enter 0 ; (push bp; mov bp, sp)
0750   08AD             ; --- BEGIN INLINE ASM SEGMENT
0751   08AD FA 05 00      lea d, [bp + 5] ; $c
0752   08B0 1E            mov al, [d]
0753   08B1 23            mov ah, al
0754   08B2 19 00         mov al, 0
0755   08B4 05 03         syscall sys_io      ; char in AH
0756   08B6             ; --- END INLINE ASM SEGMENT
0757   08B6 F9            leave
0758   08B7 09            ret
0759   08B8             
0760   08B8             print_unsigned_long:
0761   08B8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0762   08BB             ; char digits[10]; 
0763   08BB 52 0A 00      sub sp, 10
0764   08BE             ; int i; 
0765   08BE 52 02 00      sub sp, 2
0766   08C1             ; i = 0; 
0767   08C1 FA F5 FF      lea d, [bp + -11] ; $i
0768   08C4 DA            push d
0769   08C5 FD 2E 00 00   mov32 cb, $00000000
0769   08C9 00 00 
0770   08CB E7            pop d
0771   08CC FD 43         mov [d], b
0772   08CE             ; if(num == 0){ 
0773   08CE             _if18_cond:
0774   08CE FA 05 00      lea d, [bp + 5] ; $num
0775   08D1 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0776   08D4 FD 39         mov c, b ; And place it into C
0777   08D6 2A            mov b, [d] ; Lower Word in B
0778   08D7             ; --- START RELATIONAL
0779   08D7 D7            push a
0780   08D8 FD D8         push g
0781   08DA 11            mov a, b
0782   08DB FD 7A         mov g, c
0783   08DD FD 2E 00 00   mov32 cb, $00000000
0783   08E1 00 00 
0784   08E3 FD AF         cmp32 ga, cb
0785   08E5 FD 71         seq ; ==
0786   08E7 FD F1         pop g
0787   08E9 E4            pop a
0788   08EA             ; --- END RELATIONAL
0789   08EA C0 00 00      cmp b, 0
0790   08ED C6 02 09      je _if18_exit
0791   08F0             _if18_TRUE:
0792   08F0             ; putchar('0'); 
0793   08F0             ; --- START FUNCTION CALL
0794   08F0 FD 2E 30 00   mov32 cb, $00000030
0794   08F4 00 00 
0795   08F6 DD            push bl
0796   08F7 07 AA 08      call putchar
0797   08FA 51 01 00      add sp, 1
0798   08FD             ; --- END FUNCTION CALL
0799   08FD             ; return; 
0800   08FD F9            leave
0801   08FE 09            ret
0802   08FF 0A 02 09      jmp _if18_exit
0803   0902             _if18_exit:
0804   0902             ; while (num > 0) { 
0805   0902             _while19_cond:
0806   0902 FA 05 00      lea d, [bp + 5] ; $num
0807   0905 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0808   0908 FD 39         mov c, b ; And place it into C
0809   090A 2A            mov b, [d] ; Lower Word in B
0810   090B             ; --- START RELATIONAL
0811   090B D7            push a
0812   090C FD D8         push g
0813   090E 11            mov a, b
0814   090F FD 7A         mov g, c
0815   0911 FD 2E 00 00   mov32 cb, $00000000
0815   0915 00 00 
0816   0917 FD AF         cmp32 ga, cb
0817   0919 FD 81         sgu
0818   091B FD F1         pop g
0819   091D E4            pop a
0820   091E             ; --- END RELATIONAL
0821   091E C0 00 00      cmp b, 0
0822   0921 C6 A2 09      je _while19_exit
0823   0924             _while19_block:
0824   0924             ; digits[i] = '0' + (num % 10); 
0825   0924 FA F7 FF      lea d, [bp + -9] ; $digits
0826   0927 D7            push a
0827   0928 DA            push d
0828   0929 FA F5 FF      lea d, [bp + -11] ; $i
0829   092C 2A            mov b, [d]
0830   092D 38 00 00      mov c, 0
0831   0930 E7            pop d
0832   0931 5A            add d, b
0833   0932 E4            pop a
0834   0933 DA            push d
0835   0934 FD 2E 30 00   mov32 cb, $00000030
0835   0938 00 00 
0836   093A             ; --- START TERMS
0837   093A D7            push a
0838   093B 11            mov a, b
0839   093C FA 05 00      lea d, [bp + 5] ; $num
0840   093F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0841   0942 FD 39         mov c, b ; And place it into C
0842   0944 2A            mov b, [d] ; Lower Word in B
0843   0945             ; --- START FACTORS
0844   0945 D7            push a
0845   0946 FD D8         push g
0846   0948 11            mov a, b
0847   0949 FD 7A         mov g, c
0848   094B FD 2E 0A 00   mov32 cb, $0000000a
0848   094F 00 00 
0849   0951 FD D8         push g ; save 'g' as the div instruction uses it
0850   0953 AE            div a, b ; %, a: quotient, b: remainder
0851   0954 11            mov a, b
0852   0955 FD F1         pop g
0853   0957 FD 38         mov c, g
0854   0959 27            mov b, a
0855   095A FD F1         pop g
0856   095C E4            pop a
0857   095D             ; --- END FACTORS
0858   095D FD 15         add32 cb, ga
0859   095F E4            pop a
0860   0960             ; --- END TERMS
0861   0960 E7            pop d
0862   0961 FD 3E         mov [d], bl
0863   0963             ; num = num / 10; 
0864   0963 FA 05 00      lea d, [bp + 5] ; $num
0865   0966 DA            push d
0866   0967 FA 05 00      lea d, [bp + 5] ; $num
0867   096A 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0868   096D FD 39         mov c, b ; And place it into C
0869   096F 2A            mov b, [d] ; Lower Word in B
0870   0970             ; --- START FACTORS
0871   0970 D7            push a
0872   0971 FD D8         push g
0873   0973 11            mov a, b
0874   0974 FD 7A         mov g, c
0875   0976 FD 2E 0A 00   mov32 cb, $0000000a
0875   097A 00 00 
0876   097C FD D8         push g ; save 'g' as the div instruction uses it
0877   097E AE            div a, b ; /, a: quotient, b: remainder
0878   097F FD F1         pop g
0879   0981 FD 38         mov c, g
0880   0983 27            mov b, a
0881   0984 FD F1         pop g
0882   0986 E4            pop a
0883   0987             ; --- END FACTORS
0884   0987 E7            pop d
0885   0988 FD 43         mov [d], b
0886   098A 28            mov b, c
0887   098B FD 44 02 00   mov [d + 2], b
0888   098F             ; i++; 
0889   098F FA F5 FF      lea d, [bp + -11] ; $i
0890   0992 2A            mov b, [d]
0891   0993 38 00 00      mov c, 0
0892   0996 11            mov a, b
0893   0997 FD 77         inc b
0894   0999 FA F5 FF      lea d, [bp + -11] ; $i
0895   099C FD 43         mov [d], b
0896   099E 27            mov b, a
0897   099F 0A 02 09      jmp _while19_cond
0898   09A2             _while19_exit:
0899   09A2             ; while (i > 0) { 
0900   09A2             _while26_cond:
0901   09A2 FA F5 FF      lea d, [bp + -11] ; $i
0902   09A5 2A            mov b, [d]
0903   09A6 38 00 00      mov c, 0
0904   09A9             ; --- START RELATIONAL
0905   09A9 D7            push a
0906   09AA 11            mov a, b
0907   09AB FD 2E 00 00   mov32 cb, $00000000
0907   09AF 00 00 
0908   09B1 B0            cmp a, b
0909   09B2 FD 7F         sgt ; >
0910   09B4 E4            pop a
0911   09B5             ; --- END RELATIONAL
0912   09B5 C0 00 00      cmp b, 0
0913   09B8 C6 EA 09      je _while26_exit
0914   09BB             _while26_block:
0915   09BB             ; i--; 
0916   09BB FA F5 FF      lea d, [bp + -11] ; $i
0917   09BE 2A            mov b, [d]
0918   09BF 38 00 00      mov c, 0
0919   09C2 11            mov a, b
0920   09C3 FD 7D         dec b
0921   09C5 FA F5 FF      lea d, [bp + -11] ; $i
0922   09C8 FD 43         mov [d], b
0923   09CA 27            mov b, a
0924   09CB             ; putchar(digits[i]); 
0925   09CB             ; --- START FUNCTION CALL
0926   09CB FA F7 FF      lea d, [bp + -9] ; $digits
0927   09CE D7            push a
0928   09CF DA            push d
0929   09D0 FA F5 FF      lea d, [bp + -11] ; $i
0930   09D3 2A            mov b, [d]
0931   09D4 38 00 00      mov c, 0
0932   09D7 E7            pop d
0933   09D8 5A            add d, b
0934   09D9 E4            pop a
0935   09DA 32            mov bl, [d]
0936   09DB A7 00         mov bh, 0
0937   09DD 38 00 00      mov c, 0
0938   09E0 DD            push bl
0939   09E1 07 AA 08      call putchar
0940   09E4 51 01 00      add sp, 1
0941   09E7             ; --- END FUNCTION CALL
0942   09E7 0A A2 09      jmp _while26_cond
0943   09EA             _while26_exit:
0944   09EA F9            leave
0945   09EB 09            ret
0946   09EC             
0947   09EC             printx32:
0948   09EC F8 00 00      enter 0 ; (push bp; mov bp, sp)
0949   09EF             ; --- BEGIN INLINE ASM SEGMENT
0950   09EF FA 05 00      lea d, [bp + 5] ; $hex
0951   09F2 2B 02 00      mov b, [d+2]
0952   09F5 07 FE 09      call print_u16x_printx32
0953   09F8 2A            mov b, [d]
0954   09F9 07 FE 09      call print_u16x_printx32
0955   09FC             ; --- END INLINE ASM SEGMENT
0956   09FC             ; return; 
0957   09FC F9            leave
0958   09FD 09            ret
0959   09FE             ; --- BEGIN INLINE ASM SEGMENT
0960   09FE             print_u16x_printx32:
0961   09FE D7            push a
0962   09FF D8            push b
0963   0A00 DD            push bl
0964   0A01 30            mov bl, bh
0965   0A02 07 20 0A      call _itoa_printx32        ; convert bh to char in A
0966   0A05 2F            mov bl, al        ; save al
0967   0A06 19 00         mov al, 0
0968   0A08 05 03         syscall sys_io        ; display AH
0969   0A0A 24            mov ah, bl        ; retrieve al
0970   0A0B 19 00         mov al, 0
0971   0A0D 05 03         syscall sys_io        ; display AL
0972   0A0F EA            pop bl
0973   0A10 07 20 0A      call _itoa_printx32        ; convert bh to char in A
0974   0A13 2F            mov bl, al        ; save al
0975   0A14 19 00         mov al, 0
0976   0A16 05 03         syscall sys_io        ; display AH
0977   0A18 24            mov ah, bl        ; retrieve al
0978   0A19 19 00         mov al, 0
0979   0A1B 05 03         syscall sys_io        ; display AL
0980   0A1D E5            pop b
0981   0A1E E4            pop a
0982   0A1F 09            ret
0983   0A20             _itoa_printx32:
0984   0A20 DA            push d
0985   0A21 D8            push b
0986   0A22 A7 00         mov bh, 0
0987   0A24 FD A4 04      shr bl, 4  
0988   0A27 74            mov d, b
0989   0A28 1F 3A 0A      mov al, [d + s_hex_digits_printx32]
0990   0A2B 23            mov ah, al
0991   0A2C E5            pop b
0992   0A2D D8            push b
0993   0A2E A7 00         mov bh, 0
0994   0A30 FD 87 0F      and bl, $0F
0995   0A33 74            mov d, b
0996   0A34 1F 3A 0A      mov al, [d + s_hex_digits_printx32]
0997   0A37 E5            pop b
0998   0A38 E7            pop d
0999   0A39 09            ret
1000   0A3A 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
1000   0A3E 34 35 36 37 
1000   0A42 38 39 41 42 
1000   0A46 43 44 45 46 
1001   0A4A             ; --- END INLINE ASM SEGMENT
1002   0A4A F9            leave
1003   0A4B 09            ret
1004   0A4C             
1005   0A4C             err:
1006   0A4C F8 00 00      enter 0 ; (push bp; mov bp, sp)
1007   0A4F             ; print(e); 
1008   0A4F             ; --- START FUNCTION CALL
1009   0A4F FA 05 00      lea d, [bp + 5] ; $e
1010   0A52 2A            mov b, [d]
1011   0A53 38 00 00      mov c, 0
1012   0A56 FD AB         swp b
1013   0A58 D8            push b
1014   0A59 07 61 0A      call print
1015   0A5C 51 02 00      add sp, 2
1016   0A5F             ; --- END FUNCTION CALL
1017   0A5F F9            leave
1018   0A60 09            ret
1019   0A61             
1020   0A61             print:
1021   0A61 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1022   0A64             ; --- BEGIN INLINE ASM SEGMENT
1023   0A64 FA 05 00      lea d, [bp + 5] ; $s
1024   0A67 FD 2A         mov d, [d]
1025   0A69             _puts_L1_print:
1026   0A69 1E            mov al, [d]
1027   0A6A B9 00         cmp al, 0
1028   0A6C C6 78 0A      jz _puts_END_print
1029   0A6F 23            mov ah, al
1030   0A70 19 00         mov al, 0
1031   0A72 05 03         syscall sys_io
1032   0A74 79            inc d
1033   0A75 0A 69 0A      jmp _puts_L1_print
1034   0A78             _puts_END_print:
1035   0A78             ; --- END INLINE ASM SEGMENT
1036   0A78 F9            leave
1037   0A79 09            ret
1038   0A7A             
1039   0A7A             print_signed:
1040   0A7A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1041   0A7D             ; char digits[5]; 
1042   0A7D 52 05 00      sub sp, 5
1043   0A80             ; int i = 0; 
1044   0A80 52 02 00      sub sp, 2
1045   0A83             ; --- START LOCAL VAR INITIALIZATION
1046   0A83 FA FA FF      lea d, [bp + -6] ; $i
1047   0A86 DA            push d
1048   0A87 FD 2E 00 00   mov32 cb, $00000000
1048   0A8B 00 00 
1049   0A8D E7            pop d
1050   0A8E FD 43         mov [d], b
1051   0A90             ; --- END LOCAL VAR INITIALIZATION
1052   0A90             ; if (num < 0) { 
1053   0A90             _if27_cond:
1054   0A90 FA 05 00      lea d, [bp + 5] ; $num
1055   0A93 2A            mov b, [d]
1056   0A94 38 00 00      mov c, 0
1057   0A97             ; --- START RELATIONAL
1058   0A97 D7            push a
1059   0A98 11            mov a, b
1060   0A99 FD 2E 00 00   mov32 cb, $00000000
1060   0A9D 00 00 
1061   0A9F B0            cmp a, b
1062   0AA0 FD 73         slt ; < (signed)
1063   0AA2 E4            pop a
1064   0AA3             ; --- END RELATIONAL
1065   0AA3 C0 00 00      cmp b, 0
1066   0AA6 C6 C9 0A      je _if27_else
1067   0AA9             _if27_TRUE:
1068   0AA9             ; putchar('-'); 
1069   0AA9             ; --- START FUNCTION CALL
1070   0AA9 FD 2E 2D 00   mov32 cb, $0000002d
1070   0AAD 00 00 
1071   0AAF DD            push bl
1072   0AB0 07 AA 08      call putchar
1073   0AB3 51 01 00      add sp, 1
1074   0AB6             ; --- END FUNCTION CALL
1075   0AB6             ; num = -num; 
1076   0AB6 FA 05 00      lea d, [bp + 5] ; $num
1077   0AB9 DA            push d
1078   0ABA FA 05 00      lea d, [bp + 5] ; $num
1079   0ABD 2A            mov b, [d]
1080   0ABE 38 00 00      mov c, 0
1081   0AC1 FD 97         neg b
1082   0AC3 E7            pop d
1083   0AC4 FD 43         mov [d], b
1084   0AC6 0A F4 0A      jmp _if27_exit
1085   0AC9             _if27_else:
1086   0AC9             ; if (num == 0) { 
1087   0AC9             _if28_cond:
1088   0AC9 FA 05 00      lea d, [bp + 5] ; $num
1089   0ACC 2A            mov b, [d]
1090   0ACD 38 00 00      mov c, 0
1091   0AD0             ; --- START RELATIONAL
1092   0AD0 D7            push a
1093   0AD1 11            mov a, b
1094   0AD2 FD 2E 00 00   mov32 cb, $00000000
1094   0AD6 00 00 
1095   0AD8 B0            cmp a, b
1096   0AD9 FD 71         seq ; ==
1097   0ADB E4            pop a
1098   0ADC             ; --- END RELATIONAL
1099   0ADC C0 00 00      cmp b, 0
1100   0ADF C6 F4 0A      je _if28_exit
1101   0AE2             _if28_TRUE:
1102   0AE2             ; putchar('0'); 
1103   0AE2             ; --- START FUNCTION CALL
1104   0AE2 FD 2E 30 00   mov32 cb, $00000030
1104   0AE6 00 00 
1105   0AE8 DD            push bl
1106   0AE9 07 AA 08      call putchar
1107   0AEC 51 01 00      add sp, 1
1108   0AEF             ; --- END FUNCTION CALL
1109   0AEF             ; return; 
1110   0AEF F9            leave
1111   0AF0 09            ret
1112   0AF1 0A F4 0A      jmp _if28_exit
1113   0AF4             _if28_exit:
1114   0AF4             _if27_exit:
1115   0AF4             ; while (num > 0) { 
1116   0AF4             _while29_cond:
1117   0AF4 FA 05 00      lea d, [bp + 5] ; $num
1118   0AF7 2A            mov b, [d]
1119   0AF8 38 00 00      mov c, 0
1120   0AFB             ; --- START RELATIONAL
1121   0AFB D7            push a
1122   0AFC 11            mov a, b
1123   0AFD FD 2E 00 00   mov32 cb, $00000000
1123   0B01 00 00 
1124   0B03 B0            cmp a, b
1125   0B04 FD 7F         sgt ; >
1126   0B06 E4            pop a
1127   0B07             ; --- END RELATIONAL
1128   0B07 C0 00 00      cmp b, 0
1129   0B0A C6 81 0B      je _while29_exit
1130   0B0D             _while29_block:
1131   0B0D             ; digits[i] = '0' + (num % 10); 
1132   0B0D FA FC FF      lea d, [bp + -4] ; $digits
1133   0B10 D7            push a
1134   0B11 DA            push d
1135   0B12 FA FA FF      lea d, [bp + -6] ; $i
1136   0B15 2A            mov b, [d]
1137   0B16 38 00 00      mov c, 0
1138   0B19 E7            pop d
1139   0B1A 5A            add d, b
1140   0B1B E4            pop a
1141   0B1C DA            push d
1142   0B1D FD 2E 30 00   mov32 cb, $00000030
1142   0B21 00 00 
1143   0B23             ; --- START TERMS
1144   0B23 D7            push a
1145   0B24 11            mov a, b
1146   0B25 FA 05 00      lea d, [bp + 5] ; $num
1147   0B28 2A            mov b, [d]
1148   0B29 38 00 00      mov c, 0
1149   0B2C             ; --- START FACTORS
1150   0B2C D7            push a
1151   0B2D FD D8         push g
1152   0B2F 11            mov a, b
1153   0B30 FD 7A         mov g, c
1154   0B32 FD 2E 0A 00   mov32 cb, $0000000a
1154   0B36 00 00 
1155   0B38 FD D8         push g ; save 'g' as the div instruction uses it
1156   0B3A AE            div a, b ; %, a: quotient, b: remainder
1157   0B3B 11            mov a, b
1158   0B3C FD F1         pop g
1159   0B3E FD 38         mov c, g
1160   0B40 27            mov b, a
1161   0B41 FD F1         pop g
1162   0B43 E4            pop a
1163   0B44             ; --- END FACTORS
1164   0B44 56            add b, a
1165   0B45 E4            pop a
1166   0B46             ; --- END TERMS
1167   0B46 E7            pop d
1168   0B47 FD 3E         mov [d], bl
1169   0B49             ; num = num / 10; 
1170   0B49 FA 05 00      lea d, [bp + 5] ; $num
1171   0B4C DA            push d
1172   0B4D FA 05 00      lea d, [bp + 5] ; $num
1173   0B50 2A            mov b, [d]
1174   0B51 38 00 00      mov c, 0
1175   0B54             ; --- START FACTORS
1176   0B54 D7            push a
1177   0B55 FD D8         push g
1178   0B57 11            mov a, b
1179   0B58 FD 7A         mov g, c
1180   0B5A FD 2E 0A 00   mov32 cb, $0000000a
1180   0B5E 00 00 
1181   0B60 FD D8         push g ; save 'g' as the div instruction uses it
1182   0B62 AE            div a, b ; /, a: quotient, b: remainder
1183   0B63 FD F1         pop g
1184   0B65 FD 38         mov c, g
1185   0B67 27            mov b, a
1186   0B68 FD F1         pop g
1187   0B6A E4            pop a
1188   0B6B             ; --- END FACTORS
1189   0B6B E7            pop d
1190   0B6C FD 43         mov [d], b
1191   0B6E             ; i++; 
1192   0B6E FA FA FF      lea d, [bp + -6] ; $i
1193   0B71 2A            mov b, [d]
1194   0B72 38 00 00      mov c, 0
1195   0B75 11            mov a, b
1196   0B76 FD 77         inc b
1197   0B78 FA FA FF      lea d, [bp + -6] ; $i
1198   0B7B FD 43         mov [d], b
1199   0B7D 27            mov b, a
1200   0B7E 0A F4 0A      jmp _while29_cond
1201   0B81             _while29_exit:
1202   0B81             ; while (i > 0) { 
1203   0B81             _while36_cond:
1204   0B81 FA FA FF      lea d, [bp + -6] ; $i
1205   0B84 2A            mov b, [d]
1206   0B85 38 00 00      mov c, 0
1207   0B88             ; --- START RELATIONAL
1208   0B88 D7            push a
1209   0B89 11            mov a, b
1210   0B8A FD 2E 00 00   mov32 cb, $00000000
1210   0B8E 00 00 
1211   0B90 B0            cmp a, b
1212   0B91 FD 7F         sgt ; >
1213   0B93 E4            pop a
1214   0B94             ; --- END RELATIONAL
1215   0B94 C0 00 00      cmp b, 0
1216   0B97 C6 C9 0B      je _while36_exit
1217   0B9A             _while36_block:
1218   0B9A             ; i--; 
1219   0B9A FA FA FF      lea d, [bp + -6] ; $i
1220   0B9D 2A            mov b, [d]
1221   0B9E 38 00 00      mov c, 0
1222   0BA1 11            mov a, b
1223   0BA2 FD 7D         dec b
1224   0BA4 FA FA FF      lea d, [bp + -6] ; $i
1225   0BA7 FD 43         mov [d], b
1226   0BA9 27            mov b, a
1227   0BAA             ; putchar(digits[i]); 
1228   0BAA             ; --- START FUNCTION CALL
1229   0BAA FA FC FF      lea d, [bp + -4] ; $digits
1230   0BAD D7            push a
1231   0BAE DA            push d
1232   0BAF FA FA FF      lea d, [bp + -6] ; $i
1233   0BB2 2A            mov b, [d]
1234   0BB3 38 00 00      mov c, 0
1235   0BB6 E7            pop d
1236   0BB7 5A            add d, b
1237   0BB8 E4            pop a
1238   0BB9 32            mov bl, [d]
1239   0BBA A7 00         mov bh, 0
1240   0BBC 38 00 00      mov c, 0
1241   0BBF DD            push bl
1242   0BC0 07 AA 08      call putchar
1243   0BC3 51 01 00      add sp, 1
1244   0BC6             ; --- END FUNCTION CALL
1245   0BC6 0A 81 0B      jmp _while36_cond
1246   0BC9             _while36_exit:
1247   0BC9 F9            leave
1248   0BCA 09            ret
1249   0BCB             
1250   0BCB             print_unsigned:
1251   0BCB F8 00 00      enter 0 ; (push bp; mov bp, sp)
1252   0BCE             ; char digits[5]; 
1253   0BCE 52 05 00      sub sp, 5
1254   0BD1             ; int i; 
1255   0BD1 52 02 00      sub sp, 2
1256   0BD4             ; i = 0; 
1257   0BD4 FA FA FF      lea d, [bp + -6] ; $i
1258   0BD7 DA            push d
1259   0BD8 FD 2E 00 00   mov32 cb, $00000000
1259   0BDC 00 00 
1260   0BDE E7            pop d
1261   0BDF FD 43         mov [d], b
1262   0BE1             ; if(num == 0){ 
1263   0BE1             _if37_cond:
1264   0BE1 FA 05 00      lea d, [bp + 5] ; $num
1265   0BE4 2A            mov b, [d]
1266   0BE5 38 00 00      mov c, 0
1267   0BE8             ; --- START RELATIONAL
1268   0BE8 D7            push a
1269   0BE9 11            mov a, b
1270   0BEA FD 2E 00 00   mov32 cb, $00000000
1270   0BEE 00 00 
1271   0BF0 B0            cmp a, b
1272   0BF1 FD 71         seq ; ==
1273   0BF3 E4            pop a
1274   0BF4             ; --- END RELATIONAL
1275   0BF4 C0 00 00      cmp b, 0
1276   0BF7 C6 0C 0C      je _if37_exit
1277   0BFA             _if37_TRUE:
1278   0BFA             ; putchar('0'); 
1279   0BFA             ; --- START FUNCTION CALL
1280   0BFA FD 2E 30 00   mov32 cb, $00000030
1280   0BFE 00 00 
1281   0C00 DD            push bl
1282   0C01 07 AA 08      call putchar
1283   0C04 51 01 00      add sp, 1
1284   0C07             ; --- END FUNCTION CALL
1285   0C07             ; return; 
1286   0C07 F9            leave
1287   0C08 09            ret
1288   0C09 0A 0C 0C      jmp _if37_exit
1289   0C0C             _if37_exit:
1290   0C0C             ; while (num > 0) { 
1291   0C0C             _while38_cond:
1292   0C0C FA 05 00      lea d, [bp + 5] ; $num
1293   0C0F 2A            mov b, [d]
1294   0C10 38 00 00      mov c, 0
1295   0C13             ; --- START RELATIONAL
1296   0C13 D7            push a
1297   0C14 11            mov a, b
1298   0C15 FD 2E 00 00   mov32 cb, $00000000
1298   0C19 00 00 
1299   0C1B B0            cmp a, b
1300   0C1C FD 81         sgu ; > (unsigned)
1301   0C1E E4            pop a
1302   0C1F             ; --- END RELATIONAL
1303   0C1F C0 00 00      cmp b, 0
1304   0C22 C6 99 0C      je _while38_exit
1305   0C25             _while38_block:
1306   0C25             ; digits[i] = '0' + (num % 10); 
1307   0C25 FA FC FF      lea d, [bp + -4] ; $digits
1308   0C28 D7            push a
1309   0C29 DA            push d
1310   0C2A FA FA FF      lea d, [bp + -6] ; $i
1311   0C2D 2A            mov b, [d]
1312   0C2E 38 00 00      mov c, 0
1313   0C31 E7            pop d
1314   0C32 5A            add d, b
1315   0C33 E4            pop a
1316   0C34 DA            push d
1317   0C35 FD 2E 30 00   mov32 cb, $00000030
1317   0C39 00 00 
1318   0C3B             ; --- START TERMS
1319   0C3B D7            push a
1320   0C3C 11            mov a, b
1321   0C3D FA 05 00      lea d, [bp + 5] ; $num
1322   0C40 2A            mov b, [d]
1323   0C41 38 00 00      mov c, 0
1324   0C44             ; --- START FACTORS
1325   0C44 D7            push a
1326   0C45 FD D8         push g
1327   0C47 11            mov a, b
1328   0C48 FD 7A         mov g, c
1329   0C4A FD 2E 0A 00   mov32 cb, $0000000a
1329   0C4E 00 00 
1330   0C50 FD D8         push g ; save 'g' as the div instruction uses it
1331   0C52 AE            div a, b ; %, a: quotient, b: remainder
1332   0C53 11            mov a, b
1333   0C54 FD F1         pop g
1334   0C56 FD 38         mov c, g
1335   0C58 27            mov b, a
1336   0C59 FD F1         pop g
1337   0C5B E4            pop a
1338   0C5C             ; --- END FACTORS
1339   0C5C 56            add b, a
1340   0C5D E4            pop a
1341   0C5E             ; --- END TERMS
1342   0C5E E7            pop d
1343   0C5F FD 3E         mov [d], bl
1344   0C61             ; num = num / 10; 
1345   0C61 FA 05 00      lea d, [bp + 5] ; $num
1346   0C64 DA            push d
1347   0C65 FA 05 00      lea d, [bp + 5] ; $num
1348   0C68 2A            mov b, [d]
1349   0C69 38 00 00      mov c, 0
1350   0C6C             ; --- START FACTORS
1351   0C6C D7            push a
1352   0C6D FD D8         push g
1353   0C6F 11            mov a, b
1354   0C70 FD 7A         mov g, c
1355   0C72 FD 2E 0A 00   mov32 cb, $0000000a
1355   0C76 00 00 
1356   0C78 FD D8         push g ; save 'g' as the div instruction uses it
1357   0C7A AE            div a, b ; /, a: quotient, b: remainder
1358   0C7B FD F1         pop g
1359   0C7D FD 38         mov c, g
1360   0C7F 27            mov b, a
1361   0C80 FD F1         pop g
1362   0C82 E4            pop a
1363   0C83             ; --- END FACTORS
1364   0C83 E7            pop d
1365   0C84 FD 43         mov [d], b
1366   0C86             ; i++; 
1367   0C86 FA FA FF      lea d, [bp + -6] ; $i
1368   0C89 2A            mov b, [d]
1369   0C8A 38 00 00      mov c, 0
1370   0C8D 11            mov a, b
1371   0C8E FD 77         inc b
1372   0C90 FA FA FF      lea d, [bp + -6] ; $i
1373   0C93 FD 43         mov [d], b
1374   0C95 27            mov b, a
1375   0C96 0A 0C 0C      jmp _while38_cond
1376   0C99             _while38_exit:
1377   0C99             ; while (i > 0) { 
1378   0C99             _while45_cond:
1379   0C99 FA FA FF      lea d, [bp + -6] ; $i
1380   0C9C 2A            mov b, [d]
1381   0C9D 38 00 00      mov c, 0
1382   0CA0             ; --- START RELATIONAL
1383   0CA0 D7            push a
1384   0CA1 11            mov a, b
1385   0CA2 FD 2E 00 00   mov32 cb, $00000000
1385   0CA6 00 00 
1386   0CA8 B0            cmp a, b
1387   0CA9 FD 7F         sgt ; >
1388   0CAB E4            pop a
1389   0CAC             ; --- END RELATIONAL
1390   0CAC C0 00 00      cmp b, 0
1391   0CAF C6 E1 0C      je _while45_exit
1392   0CB2             _while45_block:
1393   0CB2             ; i--; 
1394   0CB2 FA FA FF      lea d, [bp + -6] ; $i
1395   0CB5 2A            mov b, [d]
1396   0CB6 38 00 00      mov c, 0
1397   0CB9 11            mov a, b
1398   0CBA FD 7D         dec b
1399   0CBC FA FA FF      lea d, [bp + -6] ; $i
1400   0CBF FD 43         mov [d], b
1401   0CC1 27            mov b, a
1402   0CC2             ; putchar(digits[i]); 
1403   0CC2             ; --- START FUNCTION CALL
1404   0CC2 FA FC FF      lea d, [bp + -4] ; $digits
1405   0CC5 D7            push a
1406   0CC6 DA            push d
1407   0CC7 FA FA FF      lea d, [bp + -6] ; $i
1408   0CCA 2A            mov b, [d]
1409   0CCB 38 00 00      mov c, 0
1410   0CCE E7            pop d
1411   0CCF 5A            add d, b
1412   0CD0 E4            pop a
1413   0CD1 32            mov bl, [d]
1414   0CD2 A7 00         mov bh, 0
1415   0CD4 38 00 00      mov c, 0
1416   0CD7 DD            push bl
1417   0CD8 07 AA 08      call putchar
1418   0CDB 51 01 00      add sp, 1
1419   0CDE             ; --- END FUNCTION CALL
1420   0CDE 0A 99 0C      jmp _while45_cond
1421   0CE1             _while45_exit:
1422   0CE1 F9            leave
1423   0CE2 09            ret
1424   0CE3             
1425   0CE3             printx16:
1426   0CE3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1427   0CE6             ; --- BEGIN INLINE ASM SEGMENT
1428   0CE6 FA 05 00      lea d, [bp + 5] ; $hex
1429   0CE9 2A            mov b, [d]
1430   0CEA             print_u16x_printx16:
1431   0CEA DD            push bl
1432   0CEB 30            mov bl, bh
1433   0CEC 07 09 0D      call _itoa_printx16        ; convert bh to char in A
1434   0CEF 2F            mov bl, al        ; save al
1435   0CF0 19 00         mov al, 0
1436   0CF2 05 03         syscall sys_io        ; display AH
1437   0CF4 24            mov ah, bl        ; retrieve al
1438   0CF5 19 00         mov al, 0
1439   0CF7 05 03         syscall sys_io        ; display AL
1440   0CF9 EA            pop bl
1441   0CFA 07 09 0D      call _itoa_printx16        ; convert bh to char in A
1442   0CFD 2F            mov bl, al        ; save al
1443   0CFE 19 00         mov al, 0
1444   0D00 05 03         syscall sys_io        ; display AH
1445   0D02 24            mov ah, bl        ; retrieve al
1446   0D03 19 00         mov al, 0
1447   0D05 05 03         syscall sys_io        ; display AL
1448   0D07             ; --- END INLINE ASM SEGMENT
1449   0D07             ; return; 
1450   0D07 F9            leave
1451   0D08 09            ret
1452   0D09             ; --- BEGIN INLINE ASM SEGMENT
1453   0D09             _itoa_printx16:
1454   0D09 DA            push d
1455   0D0A D8            push b
1456   0D0B A7 00         mov bh, 0
1457   0D0D FD A4 04      shr bl, 4  
1458   0D10 74            mov d, b
1459   0D11 1F 23 0D      mov al, [d + s_hex_digits_printx16]
1460   0D14 23            mov ah, al
1461   0D15 E5            pop b
1462   0D16 D8            push b
1463   0D17 A7 00         mov bh, 0
1464   0D19 FD 87 0F      and bl, $0F
1465   0D1C 74            mov d, b
1466   0D1D 1F 23 0D      mov al, [d + s_hex_digits_printx16]
1467   0D20 E5            pop b
1468   0D21 E7            pop d
1469   0D22 09            ret
1470   0D23 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
1470   0D27 34 35 36 37 
1470   0D2B 38 39 41 42 
1470   0D2F 43 44 45 46 
1471   0D33             ; --- END INLINE ASM SEGMENT
1472   0D33 F9            leave
1473   0D34 09            ret
1474   0D35             ; --- END TEXT SEGMENT
1475   0D35             
1476   0D35             ; --- BEGIN DATA SEGMENT
1477   0D35 41 0D 47 0D _strings_data: .dw _s0, _s1, _s2, 
1477   0D39 4D 0D 
1478   0D3B             
1479   0D3B 00 00 00 00 .fill 6, 0
1479   0D3F 00 00 
1480   0D41 68 65 6C 6C _s0: .db "hello", 0
1480   0D45 6F 00 
1481   0D47 77 6F 72 6C _s1: .db "world", 0
1481   0D4B 64 00 
1482   0D4D 65 6E 64 00 _s2: .db "end", 0
1483   0D51 55 6E 65 78 _s3: .db "Unexpected format in printf.", 0
1483   0D55 70 65 63 74 
1483   0D59 65 64 20 66 
1483   0D5D 6F 72 6D 61 
1483   0D61 74 20 69 6E 
1483   0D65 20 70 72 69 
1483   0D69 6E 74 66 2E 
1483   0D6D 00 
1484   0D6E 45 72 72 6F _s4: .db "Error: Unknown argument type.\n", 0
1484   0D72 72 3A 20 55 
1484   0D76 6E 6B 6E 6F 
1484   0D7A 77 6E 20 61 
1484   0D7E 72 67 75 6D 
1484   0D82 65 6E 74 20 
1484   0D86 74 79 70 65 
1484   0D8A 2E 0A 00 
1485   0D8D             
1486   0D8D 8F 0D       _heap_top: .dw _heap
1487   0D8F 00          _heap: .db 0
1488   0D90             ; --- END DATA SEGMENT
1489   0D90             
1490   0D90             .end
tasm: Number of errors = 0
