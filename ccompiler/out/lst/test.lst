0001   0000             ; --- FILENAME: test
0002   0000             .include "lib/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; $i 
0011   0408 52 02 00      sub sp, 2
0012   040B             ;; printf("Hello: %s", "John"); 
0013   040B 26 29 12      mov b, __s0 ; "Hello: %s"
0014   040E FD AB         swp b
0015   0410 D8            push b
0016   0411 26 33 12      mov b, __s1 ; "John"
0017   0414 FD AB         swp b
0018   0416 D8            push b
0019   0417 07 78 06      call printf
0020   041A 51 04 00      add sp, 4
0021   041D             ;; return 0; 
0022   041D 26 00 00      mov b, $0
0023   0420 F9            leave
0024   0421 05 0B         syscall sys_terminate_proc
0025   0423             
0026   0423             strcpy:
0027   0423 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0028   0426             ; $psrc 
0029   0426             ; $pdest 
0030   0426 52 04 00      sub sp, 4
0031   0429             ;; psrc = src; 
0032   0429 FA FF FF      lea d, [bp + -1] ; $psrc
0033   042C DA            push d
0034   042D FA 05 00      lea d, [bp + 5] ; $src
0035   0430 2A            mov b, [d]
0036   0431 E7            pop d
0037   0432 FD 43         mov [d], b
0038   0434             ;; pdest = dest; 
0039   0434 FA FD FF      lea d, [bp + -3] ; $pdest
0040   0437 DA            push d
0041   0438 FA 07 00      lea d, [bp + 7] ; $dest
0042   043B 2A            mov b, [d]
0043   043C E7            pop d
0044   043D FD 43         mov [d], b
0045   043F             ;; while(*psrc) *pdest++ = *psrc++; 
0046   043F             _while1_cond:
0047   043F FA FF FF      lea d, [bp + -1] ; $psrc
0048   0442 2A            mov b, [d]
0049   0443 74            mov d, b
0050   0444 32            mov bl, [d]
0051   0445 A7 00         mov bh, 0
0052   0447 C0 00 00      cmp b, 0
0053   044A C6 76 04      je _while1_exit
0054   044D             _while1_block:
0055   044D             ;; *pdest++ = *psrc++; 
0056   044D FA FD FF      lea d, [bp + -3] ; $pdest
0057   0450 2A            mov b, [d]
0058   0451 FD 79         mov g, b
0059   0453 FD 77         inc b
0060   0455 FA FD FF      lea d, [bp + -3] ; $pdest
0061   0458 FD 43         mov [d], b
0062   045A FD 27         mov b, g
0063   045C D8            push b
0064   045D FA FF FF      lea d, [bp + -1] ; $psrc
0065   0460 2A            mov b, [d]
0066   0461 FD 79         mov g, b
0067   0463 FD 77         inc b
0068   0465 FA FF FF      lea d, [bp + -1] ; $psrc
0069   0468 FD 43         mov [d], b
0070   046A FD 27         mov b, g
0071   046C 74            mov d, b
0072   046D 32            mov bl, [d]
0073   046E A7 00         mov bh, 0
0074   0470 E7            pop d
0075   0471 FD 3E         mov [d], bl
0076   0473 0A 3F 04      jmp _while1_cond
0077   0476             _while1_exit:
0078   0476             ;; *pdest = '\0'; 
0079   0476 FA FD FF      lea d, [bp + -3] ; $pdest
0080   0479 2A            mov b, [d]
0081   047A D8            push b
0082   047B 26 00 00      mov b, $0
0083   047E E7            pop d
0084   047F FD 3E         mov [d], bl
0085   0481 F9            leave
0086   0482 09            ret
0087   0483             
0088   0483             strcmp:
0089   0483 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0090   0486             ;; while (*s1 && (*s1 == *s2)) { 
0091   0486             _while2_cond:
0092   0486 FA 07 00      lea d, [bp + 7] ; $s1
0093   0489 2A            mov b, [d]
0094   048A 74            mov d, b
0095   048B 32            mov bl, [d]
0096   048C A7 00         mov bh, 0
0097   048E D7            push a
0098   048F 11            mov a, b
0099   0490 FA 07 00      lea d, [bp + 7] ; $s1
0100   0493 2A            mov b, [d]
0101   0494 74            mov d, b
0102   0495 32            mov bl, [d]
0103   0496 A7 00         mov bh, 0
0104   0498             ; START RELATIONAL
0105   0498 D7            push a
0106   0499 11            mov a, b
0107   049A FA 05 00      lea d, [bp + 5] ; $s2
0108   049D 2A            mov b, [d]
0109   049E 74            mov d, b
0110   049F 32            mov bl, [d]
0111   04A0 A7 00         mov bh, 0
0112   04A2 B0            cmp a, b
0113   04A3 FD 71         seq ; ==
0114   04A5 E4            pop a
0115   04A6             ; END RELATIONAL
0116   04A6 FD A7         sand a, b ; &&
0117   04A8 E4            pop a
0118   04A9 C0 00 00      cmp b, 0
0119   04AC C6 D0 04      je _while2_exit
0120   04AF             _while2_block:
0121   04AF             ;; s1++; 
0122   04AF FA 07 00      lea d, [bp + 7] ; $s1
0123   04B2 2A            mov b, [d]
0124   04B3 FD 79         mov g, b
0125   04B5 FD 77         inc b
0126   04B7 FA 07 00      lea d, [bp + 7] ; $s1
0127   04BA FD 43         mov [d], b
0128   04BC FD 27         mov b, g
0129   04BE             ;; s2++; 
0130   04BE FA 05 00      lea d, [bp + 5] ; $s2
0131   04C1 2A            mov b, [d]
0132   04C2 FD 79         mov g, b
0133   04C4 FD 77         inc b
0134   04C6 FA 05 00      lea d, [bp + 5] ; $s2
0135   04C9 FD 43         mov [d], b
0136   04CB FD 27         mov b, g
0137   04CD 0A 86 04      jmp _while2_cond
0138   04D0             _while2_exit:
0139   04D0             ;; return *s1 - *s2; 
0140   04D0 FA 07 00      lea d, [bp + 7] ; $s1
0141   04D3 2A            mov b, [d]
0142   04D4 74            mov d, b
0143   04D5 32            mov bl, [d]
0144   04D6 A7 00         mov bh, 0
0145   04D8             ; START TERMS
0146   04D8 D7            push a
0147   04D9 11            mov a, b
0148   04DA FA 05 00      lea d, [bp + 5] ; $s2
0149   04DD 2A            mov b, [d]
0150   04DE 74            mov d, b
0151   04DF 32            mov bl, [d]
0152   04E0 A7 00         mov bh, 0
0153   04E2 60            sub a, b
0154   04E3 27            mov b, a
0155   04E4 E4            pop a
0156   04E5             ; END TERMS
0157   04E5 F9            leave
0158   04E6 09            ret
0159   04E7             
0160   04E7             strcat:
0161   04E7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0162   04EA             ; $dest_len 
0163   04EA             ; $i 
0164   04EA 52 04 00      sub sp, 4
0165   04ED             ;; dest_len = strlen(dest); 
0166   04ED FA FF FF      lea d, [bp + -1] ; $dest_len
0167   04F0 DA            push d
0168   04F1 FA 07 00      lea d, [bp + 7] ; $dest
0169   04F4 2A            mov b, [d]
0170   04F5 FD AB         swp b
0171   04F7 D8            push b
0172   04F8 07 9D 05      call strlen
0173   04FB 51 02 00      add sp, 2
0174   04FE E7            pop d
0175   04FF FD 43         mov [d], b
0176   0501             ;; for (i = 0; src[i] != 0; i=i+1) { 
0177   0501             _for3_init:
0178   0501 FA FD FF      lea d, [bp + -3] ; $i
0179   0504 DA            push d
0180   0505 26 00 00      mov b, $0
0181   0508 E7            pop d
0182   0509 FD 43         mov [d], b
0183   050B             _for3_cond:
0184   050B FA 05 00      lea d, [bp + 5] ; $src
0185   050E FD 2A         mov d, [d]
0186   0510 D7            push a
0187   0511 DA            push d
0188   0512 FA FD FF      lea d, [bp + -3] ; $i
0189   0515 2A            mov b, [d]
0190   0516 E7            pop d
0191   0517 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0192   051B E4            pop a
0193   051C 32            mov bl, [d]
0194   051D A7 00         mov bh, 0
0195   051F             ; START RELATIONAL
0196   051F D7            push a
0197   0520 11            mov a, b
0198   0521 26 00 00      mov b, $0
0199   0524 B0            cmp a, b
0200   0525 FD 72         sneq ; !=
0201   0527 E4            pop a
0202   0528             ; END RELATIONAL
0203   0528 C0 00 00      cmp b, 0
0204   052B C6 76 05      je _for3_exit
0205   052E             _for3_block:
0206   052E             ;; dest[dest_len + i] = src[i]; 
0207   052E FA 07 00      lea d, [bp + 7] ; $dest
0208   0531 FD 2A         mov d, [d]
0209   0533 D7            push a
0210   0534 DA            push d
0211   0535 FA FF FF      lea d, [bp + -1] ; $dest_len
0212   0538 2A            mov b, [d]
0213   0539             ; START TERMS
0214   0539 D7            push a
0215   053A 11            mov a, b
0216   053B FA FD FF      lea d, [bp + -3] ; $i
0217   053E 2A            mov b, [d]
0218   053F 54            add a, b
0219   0540 27            mov b, a
0220   0541 E4            pop a
0221   0542             ; END TERMS
0222   0542 E7            pop d
0223   0543 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0224   0547 E4            pop a
0225   0548 DA            push d
0226   0549 FA 05 00      lea d, [bp + 5] ; $src
0227   054C FD 2A         mov d, [d]
0228   054E D7            push a
0229   054F DA            push d
0230   0550 FA FD FF      lea d, [bp + -3] ; $i
0231   0553 2A            mov b, [d]
0232   0554 E7            pop d
0233   0555 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0234   0559 E4            pop a
0235   055A 32            mov bl, [d]
0236   055B A7 00         mov bh, 0
0237   055D E7            pop d
0238   055E FD 3E         mov [d], bl
0239   0560             _for3_update:
0240   0560 FA FD FF      lea d, [bp + -3] ; $i
0241   0563 DA            push d
0242   0564 FA FD FF      lea d, [bp + -3] ; $i
0243   0567 2A            mov b, [d]
0244   0568             ; START TERMS
0245   0568 D7            push a
0246   0569 11            mov a, b
0247   056A 26 01 00      mov b, $1
0248   056D 54            add a, b
0249   056E 27            mov b, a
0250   056F E4            pop a
0251   0570             ; END TERMS
0252   0570 E7            pop d
0253   0571 FD 43         mov [d], b
0254   0573 0A 0B 05      jmp _for3_cond
0255   0576             _for3_exit:
0256   0576             ;; dest[dest_len + i] = 0; 
0257   0576 FA 07 00      lea d, [bp + 7] ; $dest
0258   0579 FD 2A         mov d, [d]
0259   057B D7            push a
0260   057C DA            push d
0261   057D FA FF FF      lea d, [bp + -1] ; $dest_len
0262   0580 2A            mov b, [d]
0263   0581             ; START TERMS
0264   0581 D7            push a
0265   0582 11            mov a, b
0266   0583 FA FD FF      lea d, [bp + -3] ; $i
0267   0586 2A            mov b, [d]
0268   0587 54            add a, b
0269   0588 27            mov b, a
0270   0589 E4            pop a
0271   058A             ; END TERMS
0272   058A E7            pop d
0273   058B FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0274   058F E4            pop a
0275   0590 DA            push d
0276   0591 26 00 00      mov b, $0
0277   0594 E7            pop d
0278   0595 FD 3E         mov [d], bl
0279   0597             ;; return dest; 
0280   0597 FA 07 00      lea d, [bp + 7] ; $dest
0281   059A 2A            mov b, [d]
0282   059B F9            leave
0283   059C 09            ret
0284   059D             
0285   059D             strlen:
0286   059D F8 00 00      enter 0 ; (push bp; mov bp, sp)
0287   05A0             ; $length 
0288   05A0 52 02 00      sub sp, 2
0289   05A3             ;; length = 0; 
0290   05A3 FA FF FF      lea d, [bp + -1] ; $length
0291   05A6 DA            push d
0292   05A7 26 00 00      mov b, $0
0293   05AA E7            pop d
0294   05AB FD 43         mov [d], b
0295   05AD             ;; while (str[length] != 0) { 
0296   05AD             _while4_cond:
0297   05AD FA 05 00      lea d, [bp + 5] ; $str
0298   05B0 FD 2A         mov d, [d]
0299   05B2 D7            push a
0300   05B3 DA            push d
0301   05B4 FA FF FF      lea d, [bp + -1] ; $length
0302   05B7 2A            mov b, [d]
0303   05B8 E7            pop d
0304   05B9 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0305   05BD E4            pop a
0306   05BE 32            mov bl, [d]
0307   05BF A7 00         mov bh, 0
0308   05C1             ; START RELATIONAL
0309   05C1 D7            push a
0310   05C2 11            mov a, b
0311   05C3 26 00 00      mov b, $0
0312   05C6 B0            cmp a, b
0313   05C7 FD 72         sneq ; !=
0314   05C9 E4            pop a
0315   05CA             ; END RELATIONAL
0316   05CA C0 00 00      cmp b, 0
0317   05CD C6 E2 05      je _while4_exit
0318   05D0             _while4_block:
0319   05D0             ;; length++; 
0320   05D0 FA FF FF      lea d, [bp + -1] ; $length
0321   05D3 2A            mov b, [d]
0322   05D4 FD 79         mov g, b
0323   05D6 FD 77         inc b
0324   05D8 FA FF FF      lea d, [bp + -1] ; $length
0325   05DB FD 43         mov [d], b
0326   05DD FD 27         mov b, g
0327   05DF 0A AD 05      jmp _while4_cond
0328   05E2             _while4_exit:
0329   05E2             ;; return length; 
0330   05E2 FA FF FF      lea d, [bp + -1] ; $length
0331   05E5 2A            mov b, [d]
0332   05E6 F9            leave
0333   05E7 09            ret
0334   05E8             
0335   05E8             va_arg:
0336   05E8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0337   05EB             ; $val 
0338   05EB 52 02 00      sub sp, 2
0339   05EE             ;; if(size == 1){ 
0340   05EE             _if5_cond:
0341   05EE FA 05 00      lea d, [bp + 5] ; $size
0342   05F1 2A            mov b, [d]
0343   05F2             ; START RELATIONAL
0344   05F2 D7            push a
0345   05F3 11            mov a, b
0346   05F4 26 01 00      mov b, $1
0347   05F7 B0            cmp a, b
0348   05F8 FD 71         seq ; ==
0349   05FA E4            pop a
0350   05FB             ; END RELATIONAL
0351   05FB C0 00 00      cmp b, 0
0352   05FE C6 1A 06      je _if5_else
0353   0601             _if5_true:
0354   0601             ;; val = *(char*)arg->p; 
0355   0601 FA FF FF      lea d, [bp + -1] ; $val
0356   0604 DA            push d
0357   0605 FA 07 00      lea d, [bp + 7] ; $arg
0358   0608 FD 2A         mov d, [d]
0359   060A 58 00 00      add d, 0
0360   060D FD 14         clb
0361   060F 2A            mov b, [d]
0362   0610 74            mov d, b
0363   0611 32            mov bl, [d]
0364   0612 A7 00         mov bh, 0
0365   0614 E7            pop d
0366   0615 FD 43         mov [d], b
0367   0617 0A 50 06      jmp _if5_exit
0368   061A             _if5_else:
0369   061A             ;; if(size == 2){ 
0370   061A             _if6_cond:
0371   061A FA 05 00      lea d, [bp + 5] ; $size
0372   061D 2A            mov b, [d]
0373   061E             ; START RELATIONAL
0374   061E D7            push a
0375   061F 11            mov a, b
0376   0620 26 02 00      mov b, $2
0377   0623 B0            cmp a, b
0378   0624 FD 71         seq ; ==
0379   0626 E4            pop a
0380   0627             ; END RELATIONAL
0381   0627 C0 00 00      cmp b, 0
0382   062A C6 44 06      je _if6_else
0383   062D             _if6_true:
0384   062D             ;; val = *(int*)arg->p; 
0385   062D FA FF FF      lea d, [bp + -1] ; $val
0386   0630 DA            push d
0387   0631 FA 07 00      lea d, [bp + 7] ; $arg
0388   0634 FD 2A         mov d, [d]
0389   0636 58 00 00      add d, 0
0390   0639 FD 14         clb
0391   063B 2A            mov b, [d]
0392   063C 74            mov d, b
0393   063D 2A            mov b, [d]
0394   063E E7            pop d
0395   063F FD 43         mov [d], b
0396   0641 0A 50 06      jmp _if6_exit
0397   0644             _if6_else:
0398   0644             ;; print("Unknown type size in va_arg() call. Size needs to be either 1 or 2."); 
0399   0644 26 38 12      mov b, __s2 ; "Unknown type size in va_arg() call. Size needs to be either 1 or 2."
0400   0647 FD AB         swp b
0401   0649 D8            push b
0402   064A 07 B2 0C      call print
0403   064D 51 02 00      add sp, 2
0404   0650             _if6_exit:
0405   0650             _if5_exit:
0406   0650             ;; arg->p = arg->p + size; 
0407   0650 FA 07 00      lea d, [bp + 7] ; $arg
0408   0653 FD 2A         mov d, [d]
0409   0655 58 00 00      add d, 0
0410   0658 FD 14         clb
0411   065A DA            push d
0412   065B FA 07 00      lea d, [bp + 7] ; $arg
0413   065E FD 2A         mov d, [d]
0414   0660 58 00 00      add d, 0
0415   0663 FD 14         clb
0416   0665 2A            mov b, [d]
0417   0666             ; START TERMS
0418   0666 D7            push a
0419   0667 11            mov a, b
0420   0668 FA 05 00      lea d, [bp + 5] ; $size
0421   066B 2A            mov b, [d]
0422   066C 54            add a, b
0423   066D 27            mov b, a
0424   066E E4            pop a
0425   066F             ; END TERMS
0426   066F E7            pop d
0427   0670 FD 43         mov [d], b
0428   0672             ;; return val; 
0429   0672 FA FF FF      lea d, [bp + -1] ; $val
0430   0675 2A            mov b, [d]
0431   0676 F9            leave
0432   0677 09            ret
0433   0678             
0434   0678             printf:
0435   0678 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0436   067B             ; $p 
0437   067B             ; $fp 
0438   067B             ; $i 
0439   067B 52 06 00      sub sp, 6
0440   067E             ;; fp = format; 
0441   067E FA FD FF      lea d, [bp + -3] ; $fp
0442   0681 DA            push d
0443   0682 FA 05 00      lea d, [bp + 5] ; $format
0444   0685 2A            mov b, [d]
0445   0686 E7            pop d
0446   0687 FD 43         mov [d], b
0447   0689             ;; p = &format; 
0448   0689 FA FF FF      lea d, [bp + -1] ; $p
0449   068C DA            push d
0450   068D FA 05 00      lea d, [bp + 5] ; $format
0451   0690 2D            mov b, d
0452   0691 E7            pop d
0453   0692 FD 43         mov [d], b
0454   0694             ;; for(;;){ 
0455   0694             _for7_init:
0456   0694             _for7_cond:
0457   0694             _for7_block:
0458   0694             ;; if(!*fp) break; 
0459   0694             _if8_cond:
0460   0694 FA FD FF      lea d, [bp + -3] ; $fp
0461   0697 2A            mov b, [d]
0462   0698 74            mov d, b
0463   0699 32            mov bl, [d]
0464   069A A7 00         mov bh, 0
0465   069C C0 00 00      cmp b, 0
0466   069F FD 71         seq ; !
0467   06A1 C0 00 00      cmp b, 0
0468   06A4 C6 AD 06      je _if8_exit
0469   06A7             _if8_true:
0470   06A7             ;; break; 
0471   06A7 0A F7 07      jmp _for7_exit ; for break
0472   06AA 0A AD 06      jmp _if8_exit
0473   06AD             _if8_exit:
0474   06AD             ;; if(*fp == '%'){ 
0475   06AD             _if9_cond:
0476   06AD FA FD FF      lea d, [bp + -3] ; $fp
0477   06B0 2A            mov b, [d]
0478   06B1 74            mov d, b
0479   06B2 32            mov bl, [d]
0480   06B3 A7 00         mov bh, 0
0481   06B5             ; START RELATIONAL
0482   06B5 D7            push a
0483   06B6 11            mov a, b
0484   06B7 26 25 00      mov b, $25
0485   06BA B0            cmp a, b
0486   06BB FD 71         seq ; ==
0487   06BD E4            pop a
0488   06BE             ; END RELATIONAL
0489   06BE C0 00 00      cmp b, 0
0490   06C1 C6 D6 07      je _if9_else
0491   06C4             _if9_true:
0492   06C4             ;; fp++; 
0493   06C4 FA FD FF      lea d, [bp + -3] ; $fp
0494   06C7 2A            mov b, [d]
0495   06C8 FD 79         mov g, b
0496   06CA FD 77         inc b
0497   06CC FA FD FF      lea d, [bp + -3] ; $fp
0498   06CF FD 43         mov [d], b
0499   06D1 FD 27         mov b, g
0500   06D3             ;; switch(*fp){ 
0501   06D3             _switch10_expr:
0502   06D3 FA FD FF      lea d, [bp + -3] ; $fp
0503   06D6 2A            mov b, [d]
0504   06D7 74            mov d, b
0505   06D8 32            mov bl, [d]
0506   06D9 A7 00         mov bh, 0
0507   06DB             _switch10_comparisons:
0508   06DB C1 64         cmp bl, $64
0509   06DD C6 FF 06      je _switch10_case0
0510   06E0 C1 69         cmp bl, $69
0511   06E2 C6 FF 06      je _switch10_case1
0512   06E5 C1 75         cmp bl, $75
0513   06E7 C6 24 07      je _switch10_case2
0514   06EA C1 78         cmp bl, $78
0515   06EC C6 49 07      je _switch10_case3
0516   06EF C1 63         cmp bl, $63
0517   06F1 C6 6E 07      je _switch10_case4
0518   06F4 C1 73         cmp bl, $73
0519   06F6 C6 93 07      je _switch10_case5
0520   06F9 0A B8 07      jmp _switch10_default
0521   06FC 0A C4 07      jmp _switch10_exit
0522   06FF             _switch10_case0:
0523   06FF             _switch10_case1:
0524   06FF             ;; p = p - 2; 
0525   06FF FA FF FF      lea d, [bp + -1] ; $p
0526   0702 DA            push d
0527   0703 FA FF FF      lea d, [bp + -1] ; $p
0528   0706 2A            mov b, [d]
0529   0707             ; START TERMS
0530   0707 D7            push a
0531   0708 11            mov a, b
0532   0709 26 02 00      mov b, $2
0533   070C 60            sub a, b
0534   070D 27            mov b, a
0535   070E E4            pop a
0536   070F             ; END TERMS
0537   070F E7            pop d
0538   0710 FD 43         mov [d], b
0539   0712             ;; prints(*(int*)p); 
0540   0712 FA FF FF      lea d, [bp + -1] ; $p
0541   0715 2A            mov b, [d]
0542   0716 74            mov d, b
0543   0717 2A            mov b, [d]
0544   0718 FD AB         swp b
0545   071A D8            push b
0546   071B 07 89 0A      call prints
0547   071E 51 02 00      add sp, 2
0548   0721             ;; break; 
0549   0721 0A C4 07      jmp _switch10_exit ; case break
0550   0724             _switch10_case2:
0551   0724             ;; p = p - 2; 
0552   0724 FA FF FF      lea d, [bp + -1] ; $p
0553   0727 DA            push d
0554   0728 FA FF FF      lea d, [bp + -1] ; $p
0555   072B 2A            mov b, [d]
0556   072C             ; START TERMS
0557   072C D7            push a
0558   072D 11            mov a, b
0559   072E 26 02 00      mov b, $2
0560   0731 60            sub a, b
0561   0732 27            mov b, a
0562   0733 E4            pop a
0563   0734             ; END TERMS
0564   0734 E7            pop d
0565   0735 FD 43         mov [d], b
0566   0737             ;; printu(*(unsigned int*)p); 
0567   0737 FA FF FF      lea d, [bp + -1] ; $p
0568   073A 2A            mov b, [d]
0569   073B 74            mov d, b
0570   073C 2A            mov b, [d]
0571   073D FD AB         swp b
0572   073F D8            push b
0573   0740 07 7E 0B      call printu
0574   0743 51 02 00      add sp, 2
0575   0746             ;; break; 
0576   0746 0A C4 07      jmp _switch10_exit ; case break
0577   0749             _switch10_case3:
0578   0749             ;; p = p - 2; 
0579   0749 FA FF FF      lea d, [bp + -1] ; $p
0580   074C DA            push d
0581   074D FA FF FF      lea d, [bp + -1] ; $p
0582   0750 2A            mov b, [d]
0583   0751             ; START TERMS
0584   0751 D7            push a
0585   0752 11            mov a, b
0586   0753 26 02 00      mov b, $2
0587   0756 60            sub a, b
0588   0757 27            mov b, a
0589   0758 E4            pop a
0590   0759             ; END TERMS
0591   0759 E7            pop d
0592   075A FD 43         mov [d], b
0593   075C             ;; printx16(*(unsigned int*)p); 
0594   075C FA FF FF      lea d, [bp + -1] ; $p
0595   075F 2A            mov b, [d]
0596   0760 74            mov d, b
0597   0761 2A            mov b, [d]
0598   0762 FD AB         swp b
0599   0764 D8            push b
0600   0765 07 F9 07      call printx16
0601   0768 51 02 00      add sp, 2
0602   076B             ;; break; 
0603   076B 0A C4 07      jmp _switch10_exit ; case break
0604   076E             _switch10_case4:
0605   076E             ;; p = p - 2; 
0606   076E FA FF FF      lea d, [bp + -1] ; $p
0607   0771 DA            push d
0608   0772 FA FF FF      lea d, [bp + -1] ; $p
0609   0775 2A            mov b, [d]
0610   0776             ; START TERMS
0611   0776 D7            push a
0612   0777 11            mov a, b
0613   0778 26 02 00      mov b, $2
0614   077B 60            sub a, b
0615   077C 27            mov b, a
0616   077D E4            pop a
0617   077E             ; END TERMS
0618   077E E7            pop d
0619   077F FD 43         mov [d], b
0620   0781             ;; putchar(*(char*)p); 
0621   0781 FA FF FF      lea d, [bp + -1] ; $p
0622   0784 2A            mov b, [d]
0623   0785 74            mov d, b
0624   0786 32            mov bl, [d]
0625   0787 A7 00         mov bh, 0
0626   0789 DD            push bl
0627   078A 07 6A 0C      call putchar
0628   078D 51 01 00      add sp, 1
0629   0790             ;; break; 
0630   0790 0A C4 07      jmp _switch10_exit ; case break
0631   0793             _switch10_case5:
0632   0793             ;; p = p - 2; 
0633   0793 FA FF FF      lea d, [bp + -1] ; $p
0634   0796 DA            push d
0635   0797 FA FF FF      lea d, [bp + -1] ; $p
0636   079A 2A            mov b, [d]
0637   079B             ; START TERMS
0638   079B D7            push a
0639   079C 11            mov a, b
0640   079D 26 02 00      mov b, $2
0641   07A0 60            sub a, b
0642   07A1 27            mov b, a
0643   07A2 E4            pop a
0644   07A3             ; END TERMS
0645   07A3 E7            pop d
0646   07A4 FD 43         mov [d], b
0647   07A6             ;; print(*(char**)p); 
0648   07A6 FA FF FF      lea d, [bp + -1] ; $p
0649   07A9 2A            mov b, [d]
0650   07AA 74            mov d, b
0651   07AB 2A            mov b, [d]
0652   07AC FD AB         swp b
0653   07AE D8            push b
0654   07AF 07 B2 0C      call print
0655   07B2 51 02 00      add sp, 2
0656   07B5             ;; break; 
0657   07B5 0A C4 07      jmp _switch10_exit ; case break
0658   07B8             _switch10_default:
0659   07B8             ;; print("Error: Unknown argument type.\n"); 
0660   07B8 26 7C 12      mov b, __s3 ; "Error: Unknown argument type.\n"
0661   07BB FD AB         swp b
0662   07BD D8            push b
0663   07BE 07 B2 0C      call print
0664   07C1 51 02 00      add sp, 2
0665   07C4             _switch10_exit:
0666   07C4             ;; fp++; 
0667   07C4 FA FD FF      lea d, [bp + -3] ; $fp
0668   07C7 2A            mov b, [d]
0669   07C8 FD 79         mov g, b
0670   07CA FD 77         inc b
0671   07CC FA FD FF      lea d, [bp + -3] ; $fp
0672   07CF FD 43         mov [d], b
0673   07D1 FD 27         mov b, g
0674   07D3 0A F4 07      jmp _if9_exit
0675   07D6             _if9_else:
0676   07D6             ;; putchar(*fp); 
0677   07D6 FA FD FF      lea d, [bp + -3] ; $fp
0678   07D9 2A            mov b, [d]
0679   07DA 74            mov d, b
0680   07DB 32            mov bl, [d]
0681   07DC A7 00         mov bh, 0
0682   07DE DD            push bl
0683   07DF 07 6A 0C      call putchar
0684   07E2 51 01 00      add sp, 1
0685   07E5             ;; fp++; 
0686   07E5 FA FD FF      lea d, [bp + -3] ; $fp
0687   07E8 2A            mov b, [d]
0688   07E9 FD 79         mov g, b
0689   07EB FD 77         inc b
0690   07ED FA FD FF      lea d, [bp + -3] ; $fp
0691   07F0 FD 43         mov [d], b
0692   07F2 FD 27         mov b, g
0693   07F4             _if9_exit:
0694   07F4             _for7_update:
0695   07F4 0A 94 06      jmp _for7_cond
0696   07F7             _for7_exit:
0697   07F7 F9            leave
0698   07F8 09            ret
0699   07F9             
0700   07F9             printx16:
0701   07F9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0702   07FC             
0703   07FC             ; --- BEGIN INLINE ASM BLOCK
0704   07FC FA 05 00      lea d, [bp + 5] ; $hex
0705   07FF 2A            mov b, [d]
0706   0800 07 33 10      call print_u16x
0707   0803             ; --- END INLINE ASM BLOCK
0708   0803             
0709   0803 F9            leave
0710   0804 09            ret
0711   0805             
0712   0805             printx8:
0713   0805 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0714   0808             
0715   0808             ; --- BEGIN INLINE ASM BLOCK
0716   0808 FA 05 00      lea d, [bp + 5] ; $hex
0717   080B 32            mov bl, [d]
0718   080C 07 77 10      call print_u8x
0719   080F             ; --- END INLINE ASM BLOCK
0720   080F             
0721   080F F9            leave
0722   0810 09            ret
0723   0811             
0724   0811             hex_to_int:
0725   0811 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0726   0814             ; $value 
0727   0814 10 00 00      mov a, $0
0728   0817 45 FF FF      mov [bp + -1], a
0729   081A             ; $i 
0730   081A             ; $hex_char 
0731   081A             ; $len 
0732   081A 52 07 00      sub sp, 7
0733   081D             ;; len = strlen(hex_string); 
0734   081D FA FA FF      lea d, [bp + -6] ; $len
0735   0820 DA            push d
0736   0821 FA 05 00      lea d, [bp + 5] ; $hex_string
0737   0824 2A            mov b, [d]
0738   0825 FD AB         swp b
0739   0827 D8            push b
0740   0828 07 9D 05      call strlen
0741   082B 51 02 00      add sp, 2
0742   082E E7            pop d
0743   082F FD 43         mov [d], b
0744   0831             ;; for (i = 0; i < len; i++) { 
0745   0831             _for11_init:
0746   0831 FA FD FF      lea d, [bp + -3] ; $i
0747   0834 DA            push d
0748   0835 26 00 00      mov b, $0
0749   0838 E7            pop d
0750   0839 FD 43         mov [d], b
0751   083B             _for11_cond:
0752   083B FA FD FF      lea d, [bp + -3] ; $i
0753   083E 2A            mov b, [d]
0754   083F             ; START RELATIONAL
0755   083F D7            push a
0756   0840 11            mov a, b
0757   0841 FA FA FF      lea d, [bp + -6] ; $len
0758   0844 2A            mov b, [d]
0759   0845 B0            cmp a, b
0760   0846 FD 73         slt ; < 
0761   0848 E4            pop a
0762   0849             ; END RELATIONAL
0763   0849 C0 00 00      cmp b, 0
0764   084C C6 51 09      je _for11_exit
0765   084F             _for11_block:
0766   084F             ;; hex_char = hex_string[i]; 
0767   084F FA FC FF      lea d, [bp + -4] ; $hex_char
0768   0852 DA            push d
0769   0853 FA 05 00      lea d, [bp + 5] ; $hex_string
0770   0856 FD 2A         mov d, [d]
0771   0858 D7            push a
0772   0859 DA            push d
0773   085A FA FD FF      lea d, [bp + -3] ; $i
0774   085D 2A            mov b, [d]
0775   085E E7            pop d
0776   085F FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0777   0863 E4            pop a
0778   0864 32            mov bl, [d]
0779   0865 A7 00         mov bh, 0
0780   0867 E7            pop d
0781   0868 FD 3E         mov [d], bl
0782   086A             ;; if (hex_char >= 'a' && hex_char <= 'f')  
0783   086A             _if12_cond:
0784   086A FA FC FF      lea d, [bp + -4] ; $hex_char
0785   086D 32            mov bl, [d]
0786   086E A7 00         mov bh, 0
0787   0870             ; START RELATIONAL
0788   0870 D7            push a
0789   0871 11            mov a, b
0790   0872 26 61 00      mov b, $61
0791   0875 B0            cmp a, b
0792   0876 FD 80         sge ; >=
0793   0878 E4            pop a
0794   0879             ; END RELATIONAL
0795   0879 D7            push a
0796   087A 11            mov a, b
0797   087B FA FC FF      lea d, [bp + -4] ; $hex_char
0798   087E 32            mov bl, [d]
0799   087F A7 00         mov bh, 0
0800   0881             ; START RELATIONAL
0801   0881 D7            push a
0802   0882 11            mov a, b
0803   0883 26 66 00      mov b, $66
0804   0886 B0            cmp a, b
0805   0887 FD 74         sle ; <=
0806   0889 E4            pop a
0807   088A             ; END RELATIONAL
0808   088A FD A7         sand a, b ; &&
0809   088C E4            pop a
0810   088D C0 00 00      cmp b, 0
0811   0890 C6 C1 08      je _if12_else
0812   0893             _if12_true:
0813   0893             ;; value = (value * 16) + (hex_char - 'a' + 10); 
0814   0893 FA FF FF      lea d, [bp + -1] ; $value
0815   0896 DA            push d
0816   0897 FA FF FF      lea d, [bp + -1] ; $value
0817   089A 2A            mov b, [d]
0818   089B             ; START FACTORS
0819   089B D7            push a
0820   089C 11            mov a, b
0821   089D 26 10 00      mov b, $10
0822   08A0 AC            mul a, b ; *
0823   08A1 11            mov a, b
0824   08A2 27            mov b, a
0825   08A3 E4            pop a
0826   08A4             ; END FACTORS
0827   08A4             ; START TERMS
0828   08A4 D7            push a
0829   08A5 11            mov a, b
0830   08A6 FA FC FF      lea d, [bp + -4] ; $hex_char
0831   08A9 32            mov bl, [d]
0832   08AA A7 00         mov bh, 0
0833   08AC             ; START TERMS
0834   08AC D7            push a
0835   08AD 11            mov a, b
0836   08AE 26 61 00      mov b, $61
0837   08B1 60            sub a, b
0838   08B2 26 0A 00      mov b, $a
0839   08B5 54            add a, b
0840   08B6 27            mov b, a
0841   08B7 E4            pop a
0842   08B8             ; END TERMS
0843   08B8 54            add a, b
0844   08B9 27            mov b, a
0845   08BA E4            pop a
0846   08BB             ; END TERMS
0847   08BB E7            pop d
0848   08BC FD 43         mov [d], b
0849   08BE 0A 3F 09      jmp _if12_exit
0850   08C1             _if12_else:
0851   08C1             ;; if (hex_char >= 'A' && hex_char <= 'F')  
0852   08C1             _if13_cond:
0853   08C1 FA FC FF      lea d, [bp + -4] ; $hex_char
0854   08C4 32            mov bl, [d]
0855   08C5 A7 00         mov bh, 0
0856   08C7             ; START RELATIONAL
0857   08C7 D7            push a
0858   08C8 11            mov a, b
0859   08C9 26 41 00      mov b, $41
0860   08CC B0            cmp a, b
0861   08CD FD 80         sge ; >=
0862   08CF E4            pop a
0863   08D0             ; END RELATIONAL
0864   08D0 D7            push a
0865   08D1 11            mov a, b
0866   08D2 FA FC FF      lea d, [bp + -4] ; $hex_char
0867   08D5 32            mov bl, [d]
0868   08D6 A7 00         mov bh, 0
0869   08D8             ; START RELATIONAL
0870   08D8 D7            push a
0871   08D9 11            mov a, b
0872   08DA 26 46 00      mov b, $46
0873   08DD B0            cmp a, b
0874   08DE FD 74         sle ; <=
0875   08E0 E4            pop a
0876   08E1             ; END RELATIONAL
0877   08E1 FD A7         sand a, b ; &&
0878   08E3 E4            pop a
0879   08E4 C0 00 00      cmp b, 0
0880   08E7 C6 18 09      je _if13_else
0881   08EA             _if13_true:
0882   08EA             ;; value = (value * 16) + (hex_char - 'A' + 10); 
0883   08EA FA FF FF      lea d, [bp + -1] ; $value
0884   08ED DA            push d
0885   08EE FA FF FF      lea d, [bp + -1] ; $value
0886   08F1 2A            mov b, [d]
0887   08F2             ; START FACTORS
0888   08F2 D7            push a
0889   08F3 11            mov a, b
0890   08F4 26 10 00      mov b, $10
0891   08F7 AC            mul a, b ; *
0892   08F8 11            mov a, b
0893   08F9 27            mov b, a
0894   08FA E4            pop a
0895   08FB             ; END FACTORS
0896   08FB             ; START TERMS
0897   08FB D7            push a
0898   08FC 11            mov a, b
0899   08FD FA FC FF      lea d, [bp + -4] ; $hex_char
0900   0900 32            mov bl, [d]
0901   0901 A7 00         mov bh, 0
0902   0903             ; START TERMS
0903   0903 D7            push a
0904   0904 11            mov a, b
0905   0905 26 41 00      mov b, $41
0906   0908 60            sub a, b
0907   0909 26 0A 00      mov b, $a
0908   090C 54            add a, b
0909   090D 27            mov b, a
0910   090E E4            pop a
0911   090F             ; END TERMS
0912   090F 54            add a, b
0913   0910 27            mov b, a
0914   0911 E4            pop a
0915   0912             ; END TERMS
0916   0912 E7            pop d
0917   0913 FD 43         mov [d], b
0918   0915 0A 3F 09      jmp _if13_exit
0919   0918             _if13_else:
0920   0918             ;; value = (value * 16) + (hex_char - '0'); 
0921   0918 FA FF FF      lea d, [bp + -1] ; $value
0922   091B DA            push d
0923   091C FA FF FF      lea d, [bp + -1] ; $value
0924   091F 2A            mov b, [d]
0925   0920             ; START FACTORS
0926   0920 D7            push a
0927   0921 11            mov a, b
0928   0922 26 10 00      mov b, $10
0929   0925 AC            mul a, b ; *
0930   0926 11            mov a, b
0931   0927 27            mov b, a
0932   0928 E4            pop a
0933   0929             ; END FACTORS
0934   0929             ; START TERMS
0935   0929 D7            push a
0936   092A 11            mov a, b
0937   092B FA FC FF      lea d, [bp + -4] ; $hex_char
0938   092E 32            mov bl, [d]
0939   092F A7 00         mov bh, 0
0940   0931             ; START TERMS
0941   0931 D7            push a
0942   0932 11            mov a, b
0943   0933 26 30 00      mov b, $30
0944   0936 60            sub a, b
0945   0937 27            mov b, a
0946   0938 E4            pop a
0947   0939             ; END TERMS
0948   0939 54            add a, b
0949   093A 27            mov b, a
0950   093B E4            pop a
0951   093C             ; END TERMS
0952   093C E7            pop d
0953   093D FD 43         mov [d], b
0954   093F             _if13_exit:
0955   093F             _if12_exit:
0956   093F             _for11_update:
0957   093F FA FD FF      lea d, [bp + -3] ; $i
0958   0942 2A            mov b, [d]
0959   0943 FD 79         mov g, b
0960   0945 FD 77         inc b
0961   0947 FA FD FF      lea d, [bp + -3] ; $i
0962   094A FD 43         mov [d], b
0963   094C FD 27         mov b, g
0964   094E 0A 3B 08      jmp _for11_cond
0965   0951             _for11_exit:
0966   0951             ;; return value; 
0967   0951 FA FF FF      lea d, [bp + -1] ; $value
0968   0954 2A            mov b, [d]
0969   0955 F9            leave
0970   0956 09            ret
0971   0957             
0972   0957             atoi:
0973   0957 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0974   095A             ; $result 
0975   095A 10 00 00      mov a, $0
0976   095D 45 FF FF      mov [bp + -1], a
0977   0960             ; $sign 
0978   0960 10 01 00      mov a, $1
0979   0963 45 FD FF      mov [bp + -3], a
0980   0966 52 04 00      sub sp, 4
0981   0969             ;; while (*str == ' ') str++; 
0982   0969             _while14_cond:
0983   0969 FA 05 00      lea d, [bp + 5] ; $str
0984   096C 2A            mov b, [d]
0985   096D 74            mov d, b
0986   096E 32            mov bl, [d]
0987   096F A7 00         mov bh, 0
0988   0971             ; START RELATIONAL
0989   0971 D7            push a
0990   0972 11            mov a, b
0991   0973 26 20 00      mov b, $20
0992   0976 B0            cmp a, b
0993   0977 FD 71         seq ; ==
0994   0979 E4            pop a
0995   097A             ; END RELATIONAL
0996   097A C0 00 00      cmp b, 0
0997   097D C6 92 09      je _while14_exit
0998   0980             _while14_block:
0999   0980             ;; str++; 
1000   0980 FA 05 00      lea d, [bp + 5] ; $str
1001   0983 2A            mov b, [d]
1002   0984 FD 79         mov g, b
1003   0986 FD 77         inc b
1004   0988 FA 05 00      lea d, [bp + 5] ; $str
1005   098B FD 43         mov [d], b
1006   098D FD 27         mov b, g
1007   098F 0A 69 09      jmp _while14_cond
1008   0992             _while14_exit:
1009   0992             ;; if (*str == '-' || *str == '+') { 
1010   0992             _if15_cond:
1011   0992 FA 05 00      lea d, [bp + 5] ; $str
1012   0995 2A            mov b, [d]
1013   0996 74            mov d, b
1014   0997 32            mov bl, [d]
1015   0998 A7 00         mov bh, 0
1016   099A             ; START RELATIONAL
1017   099A D7            push a
1018   099B 11            mov a, b
1019   099C 26 2D 00      mov b, $2d
1020   099F B0            cmp a, b
1021   09A0 FD 71         seq ; ==
1022   09A2 E4            pop a
1023   09A3             ; END RELATIONAL
1024   09A3 D7            push a
1025   09A4 11            mov a, b
1026   09A5 FA 05 00      lea d, [bp + 5] ; $str
1027   09A8 2A            mov b, [d]
1028   09A9 74            mov d, b
1029   09AA 32            mov bl, [d]
1030   09AB A7 00         mov bh, 0
1031   09AD             ; START RELATIONAL
1032   09AD D7            push a
1033   09AE 11            mov a, b
1034   09AF 26 2B 00      mov b, $2b
1035   09B2 B0            cmp a, b
1036   09B3 FD 71         seq ; ==
1037   09B5 E4            pop a
1038   09B6             ; END RELATIONAL
1039   09B6 FD A8         sor a, b ; ||
1040   09B8 E4            pop a
1041   09B9 C0 00 00      cmp b, 0
1042   09BC C6 F7 09      je _if15_exit
1043   09BF             _if15_true:
1044   09BF             ;; if (*str == '-') sign = -1; 
1045   09BF             _if16_cond:
1046   09BF FA 05 00      lea d, [bp + 5] ; $str
1047   09C2 2A            mov b, [d]
1048   09C3 74            mov d, b
1049   09C4 32            mov bl, [d]
1050   09C5 A7 00         mov bh, 0
1051   09C7             ; START RELATIONAL
1052   09C7 D7            push a
1053   09C8 11            mov a, b
1054   09C9 26 2D 00      mov b, $2d
1055   09CC B0            cmp a, b
1056   09CD FD 71         seq ; ==
1057   09CF E4            pop a
1058   09D0             ; END RELATIONAL
1059   09D0 C0 00 00      cmp b, 0
1060   09D3 C6 E5 09      je _if16_exit
1061   09D6             _if16_true:
1062   09D6             ;; sign = -1; 
1063   09D6 FA FD FF      lea d, [bp + -3] ; $sign
1064   09D9 DA            push d
1065   09DA 26 01 00      mov b, $1
1066   09DD FD 97         neg b
1067   09DF E7            pop d
1068   09E0 FD 43         mov [d], b
1069   09E2 0A E5 09      jmp _if16_exit
1070   09E5             _if16_exit:
1071   09E5             ;; str++; 
1072   09E5 FA 05 00      lea d, [bp + 5] ; $str
1073   09E8 2A            mov b, [d]
1074   09E9 FD 79         mov g, b
1075   09EB FD 77         inc b
1076   09ED FA 05 00      lea d, [bp + 5] ; $str
1077   09F0 FD 43         mov [d], b
1078   09F2 FD 27         mov b, g
1079   09F4 0A F7 09      jmp _if15_exit
1080   09F7             _if15_exit:
1081   09F7             ;; while (*str >= '0' && *str <= '9') { 
1082   09F7             _while17_cond:
1083   09F7 FA 05 00      lea d, [bp + 5] ; $str
1084   09FA 2A            mov b, [d]
1085   09FB 74            mov d, b
1086   09FC 32            mov bl, [d]
1087   09FD A7 00         mov bh, 0
1088   09FF             ; START RELATIONAL
1089   09FF D7            push a
1090   0A00 11            mov a, b
1091   0A01 26 30 00      mov b, $30
1092   0A04 B0            cmp a, b
1093   0A05 FD 80         sge ; >=
1094   0A07 E4            pop a
1095   0A08             ; END RELATIONAL
1096   0A08 D7            push a
1097   0A09 11            mov a, b
1098   0A0A FA 05 00      lea d, [bp + 5] ; $str
1099   0A0D 2A            mov b, [d]
1100   0A0E 74            mov d, b
1101   0A0F 32            mov bl, [d]
1102   0A10 A7 00         mov bh, 0
1103   0A12             ; START RELATIONAL
1104   0A12 D7            push a
1105   0A13 11            mov a, b
1106   0A14 26 39 00      mov b, $39
1107   0A17 B0            cmp a, b
1108   0A18 FD 74         sle ; <=
1109   0A1A E4            pop a
1110   0A1B             ; END RELATIONAL
1111   0A1B FD A7         sand a, b ; &&
1112   0A1D E4            pop a
1113   0A1E C0 00 00      cmp b, 0
1114   0A21 C6 5F 0A      je _while17_exit
1115   0A24             _while17_block:
1116   0A24             ;; result = result * 10 + (*str - '0'); 
1117   0A24 FA FF FF      lea d, [bp + -1] ; $result
1118   0A27 DA            push d
1119   0A28 FA FF FF      lea d, [bp + -1] ; $result
1120   0A2B 2A            mov b, [d]
1121   0A2C             ; START FACTORS
1122   0A2C D7            push a
1123   0A2D 11            mov a, b
1124   0A2E 26 0A 00      mov b, $a
1125   0A31 AC            mul a, b ; *
1126   0A32 11            mov a, b
1127   0A33 27            mov b, a
1128   0A34 E4            pop a
1129   0A35             ; END FACTORS
1130   0A35             ; START TERMS
1131   0A35 D7            push a
1132   0A36 11            mov a, b
1133   0A37 FA 05 00      lea d, [bp + 5] ; $str
1134   0A3A 2A            mov b, [d]
1135   0A3B 74            mov d, b
1136   0A3C 32            mov bl, [d]
1137   0A3D A7 00         mov bh, 0
1138   0A3F             ; START TERMS
1139   0A3F D7            push a
1140   0A40 11            mov a, b
1141   0A41 26 30 00      mov b, $30
1142   0A44 60            sub a, b
1143   0A45 27            mov b, a
1144   0A46 E4            pop a
1145   0A47             ; END TERMS
1146   0A47 54            add a, b
1147   0A48 27            mov b, a
1148   0A49 E4            pop a
1149   0A4A             ; END TERMS
1150   0A4A E7            pop d
1151   0A4B FD 43         mov [d], b
1152   0A4D             ;; str++; 
1153   0A4D FA 05 00      lea d, [bp + 5] ; $str
1154   0A50 2A            mov b, [d]
1155   0A51 FD 79         mov g, b
1156   0A53 FD 77         inc b
1157   0A55 FA 05 00      lea d, [bp + 5] ; $str
1158   0A58 FD 43         mov [d], b
1159   0A5A FD 27         mov b, g
1160   0A5C 0A F7 09      jmp _while17_cond
1161   0A5F             _while17_exit:
1162   0A5F             ;; return sign * result; 
1163   0A5F FA FD FF      lea d, [bp + -3] ; $sign
1164   0A62 2A            mov b, [d]
1165   0A63             ; START FACTORS
1166   0A63 D7            push a
1167   0A64 11            mov a, b
1168   0A65 FA FF FF      lea d, [bp + -1] ; $result
1169   0A68 2A            mov b, [d]
1170   0A69 AC            mul a, b ; *
1171   0A6A 11            mov a, b
1172   0A6B 27            mov b, a
1173   0A6C E4            pop a
1174   0A6D             ; END FACTORS
1175   0A6D F9            leave
1176   0A6E 09            ret
1177   0A6F             
1178   0A6F             gets:
1179   0A6F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1180   0A72             
1181   0A72             ; --- BEGIN INLINE ASM BLOCK
1182   0A72 FA 05 00      lea d, [bp + 5] ; $s
1183   0A75 15            mov a, [d]
1184   0A76 3C            mov d, a
1185   0A77 07 98 0E      call _gets
1186   0A7A             ; --- END INLINE ASM BLOCK
1187   0A7A             
1188   0A7A             ;; return strlen(s); 
1189   0A7A FA 05 00      lea d, [bp + 5] ; $s
1190   0A7D 2A            mov b, [d]
1191   0A7E FD AB         swp b
1192   0A80 D8            push b
1193   0A81 07 9D 05      call strlen
1194   0A84 51 02 00      add sp, 2
1195   0A87 F9            leave
1196   0A88 09            ret
1197   0A89             
1198   0A89             prints:
1199   0A89 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1200   0A8C             ; $digits 
1201   0A8C             ; $i 
1202   0A8C 10 00 00      mov a, $0
1203   0A8F 45 FA FF      mov [bp + -6], a
1204   0A92 52 07 00      sub sp, 7
1205   0A95             ;; if (num < 0) { 
1206   0A95             _if18_cond:
1207   0A95 FA 05 00      lea d, [bp + 5] ; $num
1208   0A98 2A            mov b, [d]
1209   0A99             ; START RELATIONAL
1210   0A99 D7            push a
1211   0A9A 11            mov a, b
1212   0A9B 26 00 00      mov b, $0
1213   0A9E B0            cmp a, b
1214   0A9F FD 73         slt ; < 
1215   0AA1 E4            pop a
1216   0AA2             ; END RELATIONAL
1217   0AA2 C0 00 00      cmp b, 0
1218   0AA5 C6 C2 0A      je _if18_else
1219   0AA8             _if18_true:
1220   0AA8             ;; putchar('-'); 
1221   0AA8 26 2D 00      mov b, $2d
1222   0AAB DD            push bl
1223   0AAC 07 6A 0C      call putchar
1224   0AAF 51 01 00      add sp, 1
1225   0AB2             ;; num = -num; 
1226   0AB2 FA 05 00      lea d, [bp + 5] ; $num
1227   0AB5 DA            push d
1228   0AB6 FA 05 00      lea d, [bp + 5] ; $num
1229   0AB9 2A            mov b, [d]
1230   0ABA FD 97         neg b
1231   0ABC E7            pop d
1232   0ABD FD 43         mov [d], b
1233   0ABF 0A E4 0A      jmp _if18_exit
1234   0AC2             _if18_else:
1235   0AC2             ;; if (num == 0) { 
1236   0AC2             _if19_cond:
1237   0AC2 FA 05 00      lea d, [bp + 5] ; $num
1238   0AC5 2A            mov b, [d]
1239   0AC6             ; START RELATIONAL
1240   0AC6 D7            push a
1241   0AC7 11            mov a, b
1242   0AC8 26 00 00      mov b, $0
1243   0ACB B0            cmp a, b
1244   0ACC FD 71         seq ; ==
1245   0ACE E4            pop a
1246   0ACF             ; END RELATIONAL
1247   0ACF C0 00 00      cmp b, 0
1248   0AD2 C6 E4 0A      je _if19_exit
1249   0AD5             _if19_true:
1250   0AD5             ;; putchar('0'); 
1251   0AD5 26 30 00      mov b, $30
1252   0AD8 DD            push bl
1253   0AD9 07 6A 0C      call putchar
1254   0ADC 51 01 00      add sp, 1
1255   0ADF             ;; return; 
1256   0ADF F9            leave
1257   0AE0 09            ret
1258   0AE1 0A E4 0A      jmp _if19_exit
1259   0AE4             _if19_exit:
1260   0AE4             _if18_exit:
1261   0AE4             ;; while (num > 0) { 
1262   0AE4             _while20_cond:
1263   0AE4 FA 05 00      lea d, [bp + 5] ; $num
1264   0AE7 2A            mov b, [d]
1265   0AE8             ; START RELATIONAL
1266   0AE8 D7            push a
1267   0AE9 11            mov a, b
1268   0AEA 26 00 00      mov b, $0
1269   0AED B0            cmp a, b
1270   0AEE FD 7F         sgt ; >
1271   0AF0 E4            pop a
1272   0AF1             ; END RELATIONAL
1273   0AF1 C0 00 00      cmp b, 0
1274   0AF4 C6 41 0B      je _while20_exit
1275   0AF7             _while20_block:
1276   0AF7             ;; digits[i] = '0' + (num % 10); 
1277   0AF7 FA FC FF      lea d, [bp + -4] ; $digits
1278   0AFA D7            push a
1279   0AFB DA            push d
1280   0AFC FA FA FF      lea d, [bp + -6] ; $i
1281   0AFF 2A            mov b, [d]
1282   0B00 E7            pop d
1283   0B01 5A            add d, b
1284   0B02 E4            pop a
1285   0B03 DA            push d
1286   0B04 26 30 00      mov b, $30
1287   0B07             ; START TERMS
1288   0B07 D7            push a
1289   0B08 11            mov a, b
1290   0B09 FA 05 00      lea d, [bp + 5] ; $num
1291   0B0C 2A            mov b, [d]
1292   0B0D             ; START FACTORS
1293   0B0D D7            push a
1294   0B0E 11            mov a, b
1295   0B0F 26 0A 00      mov b, $a
1296   0B12 AE            div a, b ; 
1297   0B13 11            mov a, b
1298   0B14 27            mov b, a
1299   0B15 E4            pop a
1300   0B16             ; END FACTORS
1301   0B16 54            add a, b
1302   0B17 27            mov b, a
1303   0B18 E4            pop a
1304   0B19             ; END TERMS
1305   0B19 E7            pop d
1306   0B1A FD 3E         mov [d], bl
1307   0B1C             ;; num = num / 10; 
1308   0B1C FA 05 00      lea d, [bp + 5] ; $num
1309   0B1F DA            push d
1310   0B20 FA 05 00      lea d, [bp + 5] ; $num
1311   0B23 2A            mov b, [d]
1312   0B24             ; START FACTORS
1313   0B24 D7            push a
1314   0B25 11            mov a, b
1315   0B26 26 0A 00      mov b, $a
1316   0B29 AE            div a, b
1317   0B2A 27            mov b, a
1318   0B2B E4            pop a
1319   0B2C             ; END FACTORS
1320   0B2C E7            pop d
1321   0B2D FD 43         mov [d], b
1322   0B2F             ;; i++; 
1323   0B2F FA FA FF      lea d, [bp + -6] ; $i
1324   0B32 2A            mov b, [d]
1325   0B33 FD 79         mov g, b
1326   0B35 FD 77         inc b
1327   0B37 FA FA FF      lea d, [bp + -6] ; $i
1328   0B3A FD 43         mov [d], b
1329   0B3C FD 27         mov b, g
1330   0B3E 0A E4 0A      jmp _while20_cond
1331   0B41             _while20_exit:
1332   0B41             ;; while (i > 0) { 
1333   0B41             _while21_cond:
1334   0B41 FA FA FF      lea d, [bp + -6] ; $i
1335   0B44 2A            mov b, [d]
1336   0B45             ; START RELATIONAL
1337   0B45 D7            push a
1338   0B46 11            mov a, b
1339   0B47 26 00 00      mov b, $0
1340   0B4A B0            cmp a, b
1341   0B4B FD 7F         sgt ; >
1342   0B4D E4            pop a
1343   0B4E             ; END RELATIONAL
1344   0B4E C0 00 00      cmp b, 0
1345   0B51 C6 7C 0B      je _while21_exit
1346   0B54             _while21_block:
1347   0B54             ;; i--; 
1348   0B54 FA FA FF      lea d, [bp + -6] ; $i
1349   0B57 2A            mov b, [d]
1350   0B58 FD 79         mov g, b
1351   0B5A FD 7D         dec b
1352   0B5C FA FA FF      lea d, [bp + -6] ; $i
1353   0B5F FD 43         mov [d], b
1354   0B61 FD 27         mov b, g
1355   0B63             ;; putchar(digits[i]); 
1356   0B63 FA FC FF      lea d, [bp + -4] ; $digits
1357   0B66 D7            push a
1358   0B67 DA            push d
1359   0B68 FA FA FF      lea d, [bp + -6] ; $i
1360   0B6B 2A            mov b, [d]
1361   0B6C E7            pop d
1362   0B6D 5A            add d, b
1363   0B6E E4            pop a
1364   0B6F 32            mov bl, [d]
1365   0B70 A7 00         mov bh, 0
1366   0B72 DD            push bl
1367   0B73 07 6A 0C      call putchar
1368   0B76 51 01 00      add sp, 1
1369   0B79 0A 41 0B      jmp _while21_cond
1370   0B7C             _while21_exit:
1371   0B7C F9            leave
1372   0B7D 09            ret
1373   0B7E             
1374   0B7E             printu:
1375   0B7E F8 00 00      enter 0 ; (push bp; mov bp, sp)
1376   0B81             ; $digits 
1377   0B81             ; $i 
1378   0B81 52 07 00      sub sp, 7
1379   0B84             ;; i = 0; 
1380   0B84 FA FA FF      lea d, [bp + -6] ; $i
1381   0B87 DA            push d
1382   0B88 26 00 00      mov b, $0
1383   0B8B E7            pop d
1384   0B8C FD 43         mov [d], b
1385   0B8E             ;; if(num == 0){ 
1386   0B8E             _if22_cond:
1387   0B8E FA 05 00      lea d, [bp + 5] ; $num
1388   0B91 2A            mov b, [d]
1389   0B92             ; START RELATIONAL
1390   0B92 D7            push a
1391   0B93 11            mov a, b
1392   0B94 26 00 00      mov b, $0
1393   0B97 B0            cmp a, b
1394   0B98 FD 71         seq ; ==
1395   0B9A E4            pop a
1396   0B9B             ; END RELATIONAL
1397   0B9B C0 00 00      cmp b, 0
1398   0B9E C6 B0 0B      je _if22_exit
1399   0BA1             _if22_true:
1400   0BA1             ;; putchar('0'); 
1401   0BA1 26 30 00      mov b, $30
1402   0BA4 DD            push bl
1403   0BA5 07 6A 0C      call putchar
1404   0BA8 51 01 00      add sp, 1
1405   0BAB             ;; return; 
1406   0BAB F9            leave
1407   0BAC 09            ret
1408   0BAD 0A B0 0B      jmp _if22_exit
1409   0BB0             _if22_exit:
1410   0BB0             ;; while (num > 0) { 
1411   0BB0             _while23_cond:
1412   0BB0 FA 05 00      lea d, [bp + 5] ; $num
1413   0BB3 2A            mov b, [d]
1414   0BB4             ; START RELATIONAL
1415   0BB4 D7            push a
1416   0BB5 11            mov a, b
1417   0BB6 26 00 00      mov b, $0
1418   0BB9 B0            cmp a, b
1419   0BBA FD 81         sgu ; > (unsigned)
1420   0BBC E4            pop a
1421   0BBD             ; END RELATIONAL
1422   0BBD C0 00 00      cmp b, 0
1423   0BC0 C6 0D 0C      je _while23_exit
1424   0BC3             _while23_block:
1425   0BC3             ;; digits[i] = '0' + (num % 10); 
1426   0BC3 FA FC FF      lea d, [bp + -4] ; $digits
1427   0BC6 D7            push a
1428   0BC7 DA            push d
1429   0BC8 FA FA FF      lea d, [bp + -6] ; $i
1430   0BCB 2A            mov b, [d]
1431   0BCC E7            pop d
1432   0BCD 5A            add d, b
1433   0BCE E4            pop a
1434   0BCF DA            push d
1435   0BD0 26 30 00      mov b, $30
1436   0BD3             ; START TERMS
1437   0BD3 D7            push a
1438   0BD4 11            mov a, b
1439   0BD5 FA 05 00      lea d, [bp + 5] ; $num
1440   0BD8 2A            mov b, [d]
1441   0BD9             ; START FACTORS
1442   0BD9 D7            push a
1443   0BDA 11            mov a, b
1444   0BDB 26 0A 00      mov b, $a
1445   0BDE AE            div a, b ; 
1446   0BDF 11            mov a, b
1447   0BE0 27            mov b, a
1448   0BE1 E4            pop a
1449   0BE2             ; END FACTORS
1450   0BE2 54            add a, b
1451   0BE3 27            mov b, a
1452   0BE4 E4            pop a
1453   0BE5             ; END TERMS
1454   0BE5 E7            pop d
1455   0BE6 FD 3E         mov [d], bl
1456   0BE8             ;; num = num / 10; 
1457   0BE8 FA 05 00      lea d, [bp + 5] ; $num
1458   0BEB DA            push d
1459   0BEC FA 05 00      lea d, [bp + 5] ; $num
1460   0BEF 2A            mov b, [d]
1461   0BF0             ; START FACTORS
1462   0BF0 D7            push a
1463   0BF1 11            mov a, b
1464   0BF2 26 0A 00      mov b, $a
1465   0BF5 AE            div a, b
1466   0BF6 27            mov b, a
1467   0BF7 E4            pop a
1468   0BF8             ; END FACTORS
1469   0BF8 E7            pop d
1470   0BF9 FD 43         mov [d], b
1471   0BFB             ;; i++; 
1472   0BFB FA FA FF      lea d, [bp + -6] ; $i
1473   0BFE 2A            mov b, [d]
1474   0BFF FD 79         mov g, b
1475   0C01 FD 77         inc b
1476   0C03 FA FA FF      lea d, [bp + -6] ; $i
1477   0C06 FD 43         mov [d], b
1478   0C08 FD 27         mov b, g
1479   0C0A 0A B0 0B      jmp _while23_cond
1480   0C0D             _while23_exit:
1481   0C0D             ;; while (i > 0) { 
1482   0C0D             _while24_cond:
1483   0C0D FA FA FF      lea d, [bp + -6] ; $i
1484   0C10 2A            mov b, [d]
1485   0C11             ; START RELATIONAL
1486   0C11 D7            push a
1487   0C12 11            mov a, b
1488   0C13 26 00 00      mov b, $0
1489   0C16 B0            cmp a, b
1490   0C17 FD 7F         sgt ; >
1491   0C19 E4            pop a
1492   0C1A             ; END RELATIONAL
1493   0C1A C0 00 00      cmp b, 0
1494   0C1D C6 48 0C      je _while24_exit
1495   0C20             _while24_block:
1496   0C20             ;; i--; 
1497   0C20 FA FA FF      lea d, [bp + -6] ; $i
1498   0C23 2A            mov b, [d]
1499   0C24 FD 79         mov g, b
1500   0C26 FD 7D         dec b
1501   0C28 FA FA FF      lea d, [bp + -6] ; $i
1502   0C2B FD 43         mov [d], b
1503   0C2D FD 27         mov b, g
1504   0C2F             ;; putchar(digits[i]); 
1505   0C2F FA FC FF      lea d, [bp + -4] ; $digits
1506   0C32 D7            push a
1507   0C33 DA            push d
1508   0C34 FA FA FF      lea d, [bp + -6] ; $i
1509   0C37 2A            mov b, [d]
1510   0C38 E7            pop d
1511   0C39 5A            add d, b
1512   0C3A E4            pop a
1513   0C3B 32            mov bl, [d]
1514   0C3C A7 00         mov bh, 0
1515   0C3E DD            push bl
1516   0C3F 07 6A 0C      call putchar
1517   0C42 51 01 00      add sp, 1
1518   0C45 0A 0D 0C      jmp _while24_cond
1519   0C48             _while24_exit:
1520   0C48 F9            leave
1521   0C49 09            ret
1522   0C4A             
1523   0C4A             rand:
1524   0C4A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1525   0C4D             ; $sec 
1526   0C4D 52 01 00      sub sp, 1
1527   0C50             
1528   0C50             ; --- BEGIN INLINE ASM BLOCK
1529   0C50 19 00         mov al, 0
1530   0C52 05 01         syscall sys_rtc					
1531   0C54 1A            mov al, ah
1532   0C55 FA 00 00      lea d, [bp + 0] ; $sec
1533   0C58 1E            mov al, [d]
1534   0C59             ; --- END INLINE ASM BLOCK
1535   0C59             
1536   0C59             ;; return sec; 
1537   0C59 FA 00 00      lea d, [bp + 0] ; $sec
1538   0C5C 32            mov bl, [d]
1539   0C5D A7 00         mov bh, 0
1540   0C5F F9            leave
1541   0C60 09            ret
1542   0C61             
1543   0C61             date:
1544   0C61 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1545   0C64             
1546   0C64             ; --- BEGIN INLINE ASM BLOCK
1547   0C64 19 00         mov al, 0 
1548   0C66 05 07         syscall sys_datetime
1549   0C68             ; --- END INLINE ASM BLOCK
1550   0C68             
1551   0C68 F9            leave
1552   0C69 09            ret
1553   0C6A             
1554   0C6A             putchar:
1555   0C6A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1556   0C6D             
1557   0C6D             ; --- BEGIN INLINE ASM BLOCK
1558   0C6D FA 05 00      lea d, [bp + 5] ; $c
1559   0C70 1E            mov al, [d]
1560   0C71 23            mov ah, al
1561   0C72 07 91 0E      call _putchar
1562   0C75             ; --- END INLINE ASM BLOCK
1563   0C75             
1564   0C75 F9            leave
1565   0C76 09            ret
1566   0C77             
1567   0C77             getchar:
1568   0C77 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1569   0C7A             ; $c 
1570   0C7A 52 01 00      sub sp, 1
1571   0C7D             
1572   0C7D             ; --- BEGIN INLINE ASM BLOCK
1573   0C7D 07 8A 0E      call getch
1574   0C80 1A            mov al, ah
1575   0C81 FA 00 00      lea d, [bp + 0] ; $c
1576   0C84 3E            mov [d], al
1577   0C85             ; --- END INLINE ASM BLOCK
1578   0C85             
1579   0C85             ;; return c; 
1580   0C85 FA 00 00      lea d, [bp + 0] ; $c
1581   0C88 32            mov bl, [d]
1582   0C89 A7 00         mov bh, 0
1583   0C8B F9            leave
1584   0C8C 09            ret
1585   0C8D             
1586   0C8D             scann:
1587   0C8D F8 00 00      enter 0 ; (push bp; mov bp, sp)
1588   0C90             ; $m 
1589   0C90 52 02 00      sub sp, 2
1590   0C93             
1591   0C93             ; --- BEGIN INLINE ASM BLOCK
1592   0C93 07 D5 10      call scan_u16d
1593   0C96 FA FF FF      lea d, [bp + -1] ; $m
1594   0C99 43            mov [d], a
1595   0C9A             ; --- END INLINE ASM BLOCK
1596   0C9A             
1597   0C9A             ;; return m; 
1598   0C9A FA FF FF      lea d, [bp + -1] ; $m
1599   0C9D 2A            mov b, [d]
1600   0C9E F9            leave
1601   0C9F 09            ret
1602   0CA0             
1603   0CA0             puts:
1604   0CA0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1605   0CA3             
1606   0CA3             ; --- BEGIN INLINE ASM BLOCK
1607   0CA3 FA 05 00      lea d, [bp + 5] ; $s
1608   0CA6 15            mov a, [d]
1609   0CA7 3C            mov d, a
1610   0CA8 07 DB 0F      call _puts
1611   0CAB 10 00 0A      mov a, $0A00
1612   0CAE 05 03         syscall sys_io
1613   0CB0             ; --- END INLINE ASM BLOCK
1614   0CB0             
1615   0CB0 F9            leave
1616   0CB1 09            ret
1617   0CB2             
1618   0CB2             print:
1619   0CB2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1620   0CB5             
1621   0CB5             ; --- BEGIN INLINE ASM BLOCK
1622   0CB5 FA 05 00      lea d, [bp + 5] ; $s
1623   0CB8 FD 2A         mov d, [d]
1624   0CBA 07 DB 0F      call _puts
1625   0CBD             ; --- END INLINE ASM BLOCK
1626   0CBD             
1627   0CBD F9            leave
1628   0CBE 09            ret
1629   0CBF             
1630   0CBF             loadfile:
1631   0CBF F8 00 00      enter 0 ; (push bp; mov bp, sp)
1632   0CC2             
1633   0CC2             ; --- BEGIN INLINE ASM BLOCK
1634   0CC2 FA 05 00      lea d, [bp + 5] ; $destination
1635   0CC5 15            mov a, [d]
1636   0CC6 4F            mov di, a
1637   0CC7 FA 07 00      lea d, [bp + 7] ; $filename
1638   0CCA FD 2A         mov d, [d]
1639   0CCC 19 14         mov al, 20
1640   0CCE 05 04         syscall sys_filesystem
1641   0CD0             ; --- END INLINE ASM BLOCK
1642   0CD0             
1643   0CD0 F9            leave
1644   0CD1 09            ret
1645   0CD2             
1646   0CD2             create_file:
1647   0CD2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1648   0CD5 F9            leave
1649   0CD6 09            ret
1650   0CD7             
1651   0CD7             delete_file:
1652   0CD7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1653   0CDA             
1654   0CDA             ; --- BEGIN INLINE ASM BLOCK
1655   0CDA FA 05 00      lea d, [bp + 5] ; $filename
1656   0CDD 19 0A         mov al, 10
1657   0CDF 05 04         syscall sys_filesystem
1658   0CE1             ; --- END INLINE ASM BLOCK
1659   0CE1             
1660   0CE1 F9            leave
1661   0CE2 09            ret
1662   0CE3             
1663   0CE3             fopen:
1664   0CE3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1665   0CE6 F9            leave
1666   0CE7 09            ret
1667   0CE8             
1668   0CE8             fclose:
1669   0CE8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1670   0CEB F9            leave
1671   0CEC 09            ret
1672   0CED             
1673   0CED             alloc:
1674   0CED F8 00 00      enter 0 ; (push bp; mov bp, sp)
1675   0CF0             ;; heap_top = heap_top + bytes; 
1676   0CF0 3B A3 12      mov d, _heap_top ; $heap_top
1677   0CF3 DA            push d
1678   0CF4 3B A3 12      mov d, _heap_top ; $heap_top
1679   0CF7 2A            mov b, [d]
1680   0CF8             ; START TERMS
1681   0CF8 D7            push a
1682   0CF9 11            mov a, b
1683   0CFA FA 05 00      lea d, [bp + 5] ; $bytes
1684   0CFD 2A            mov b, [d]
1685   0CFE 54            add a, b
1686   0CFF 27            mov b, a
1687   0D00 E4            pop a
1688   0D01             ; END TERMS
1689   0D01 E7            pop d
1690   0D02 FD 43         mov [d], b
1691   0D04             ;; return heap_top - bytes; 
1692   0D04 3B A3 12      mov d, _heap_top ; $heap_top
1693   0D07 2A            mov b, [d]
1694   0D08             ; START TERMS
1695   0D08 D7            push a
1696   0D09 11            mov a, b
1697   0D0A FA 05 00      lea d, [bp + 5] ; $bytes
1698   0D0D 2A            mov b, [d]
1699   0D0E 60            sub a, b
1700   0D0F 27            mov b, a
1701   0D10 E4            pop a
1702   0D11             ; END TERMS
1703   0D11 F9            leave
1704   0D12 09            ret
1705   0D13             
1706   0D13             free:
1707   0D13 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1708   0D16             ;; return heap_top = heap_top - bytes; 
1709   0D16 3B A3 12      mov d, _heap_top ; $heap_top
1710   0D19 DA            push d
1711   0D1A 3B A3 12      mov d, _heap_top ; $heap_top
1712   0D1D 2A            mov b, [d]
1713   0D1E             ; START TERMS
1714   0D1E D7            push a
1715   0D1F 11            mov a, b
1716   0D20 FA 05 00      lea d, [bp + 5] ; $bytes
1717   0D23 2A            mov b, [d]
1718   0D24 60            sub a, b
1719   0D25 27            mov b, a
1720   0D26 E4            pop a
1721   0D27             ; END TERMS
1722   0D27 E7            pop d
1723   0D28 FD 43         mov [d], b
1724   0D2A F9            leave
1725   0D2B 09            ret
1726   0D2C             
1727   0D2C             exit:
1728   0D2C F8 00 00      enter 0 ; (push bp; mov bp, sp)
1729   0D2F             
1730   0D2F             ; --- BEGIN INLINE ASM BLOCK
1731   0D2F 05 0B         syscall sys_terminate_proc
1732   0D31             ; --- END INLINE ASM BLOCK
1733   0D31             
1734   0D31 F9            leave
1735   0D32 09            ret
1736   0D33             
1737   0D33             load_hex:
1738   0D33 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1739   0D36             ; $temp 
1740   0D36 52 02 00      sub sp, 2
1741   0D39             ;; temp = alloc(32768); 
1742   0D39 FA FF FF      lea d, [bp + -1] ; $temp
1743   0D3C DA            push d
1744   0D3D 26 00 80      mov b, $8000
1745   0D40 FD AB         swp b
1746   0D42 D8            push b
1747   0D43 07 ED 0C      call alloc
1748   0D46 51 02 00      add sp, 2
1749   0D49 E7            pop d
1750   0D4A FD 43         mov [d], b
1751   0D4C             
1752   0D4C             ; --- BEGIN INLINE ASM BLOCK
1753   0D4C               
1754   0D4C               
1755   0D4C               
1756   0D4C               
1757   0D4C               
1758   0D4C             _load_hex:
1759   0D4C D7            push a
1760   0D4D D8            push b
1761   0D4E DA            push d
1762   0D4F E2            push si
1763   0D50 E3            push di
1764   0D51 52 00 80      sub sp, $8000      
1765   0D54 38 00 00      mov c, 0
1766   0D57 48            mov a, sp
1767   0D58 77            inc a
1768   0D59 3C            mov d, a          
1769   0D5A 07 98 0E      call _gets        
1770   0D5D 4D            mov si, a
1771   0D5E             __load_hex_loop:
1772   0D5E F6            lodsb             
1773   0D5F B9 00         cmp al, 0         
1774   0D61 C6 6F 0D      jz __load_hex_ret
1775   0D64 36            mov bh, al
1776   0D65 F6            lodsb
1777   0D66 2F            mov bl, al
1778   0D67 07 4E 0E      call _atoi        
1779   0D6A F7            stosb             
1780   0D6B 78            inc c
1781   0D6C 0A 5E 0D      jmp __load_hex_loop
1782   0D6F             __load_hex_ret:
1783   0D6F 51 00 80      add sp, $8000
1784   0D72 F0            pop di
1785   0D73 EF            pop si
1786   0D74 E7            pop d
1787   0D75 E5            pop b
1788   0D76 E4            pop a
1789   0D77             ; --- END INLINE ASM BLOCK
1790   0D77             
1791   0D77 F9            leave
1792   0D78 09            ret
1793   0D79             
1794   0D79             getparam:
1795   0D79 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1796   0D7C             ; $data 
1797   0D7C 52 01 00      sub sp, 1
1798   0D7F             
1799   0D7F             ; --- BEGIN INLINE ASM BLOCK
1800   0D7F 19 04         mov al, 4
1801   0D81 FA 05 00      lea d, [bp + 5] ; $address
1802   0D84 FD 2A         mov d, [d]
1803   0D86 05 0C         syscall sys_system
1804   0D88 FA 00 00      lea d, [bp + 0] ; $data
1805   0D8B FD 3E         mov [d], bl
1806   0D8D             ; --- END INLINE ASM BLOCK
1807   0D8D             
1808   0D8D             ;; return data; 
1809   0D8D FA 00 00      lea d, [bp + 0] ; $data
1810   0D90 32            mov bl, [d]
1811   0D91 A7 00         mov bh, 0
1812   0D93 F9            leave
1813   0D94 09            ret
1814   0D95             
1815   0D95             clear:
1816   0D95 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1817   0D98             ;; print("\033[2J\033[H"); 
1818   0D98 26 9B 12      mov b, __s4 ; "\033[2J\033[H"
1819   0D9B FD AB         swp b
1820   0D9D D8            push b
1821   0D9E 07 B2 0C      call print
1822   0DA1 51 02 00      add sp, 2
1823   0DA4 F9            leave
1824   0DA5 09            ret
1825   0DA6             
1826   0DA6             include_stdio_asm:
1827   0DA6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1828   0DA9             
1829   0DA9             ; --- BEGIN INLINE ASM BLOCK
1830   0DA9             .include "lib/stdio.asm"
0001+  0DA9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0DA9             ; stdio.s
0003+  0DA9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0DA9             .include "lib/string.asm"
0001++ 0DA9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0DA9             ; string.s
0003++ 0DA9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0DA9             
0005++ 0DA9             
0006++ 0DA9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0DA9             ; _strrev
0008++ 0DA9             ; reverse a string
0009++ 0DA9             ; D = string address
0010++ 0DA9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0DA9             ; 01234
0012++ 0DA9             _strrev:
0013++ 0DA9 4B          	pusha
0014++ 0DAA 07 F0 0D    	call _strlen	; length in C
0015++ 0DAD 12          	mov a, c
0016++ 0DAE AF 01 00    	cmp a, 1
0017++ 0DB1 D0 CB 0D    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 0DB4 7D          	dec a
0019++ 0DB5 FD 4E       	mov si, d	; beginning of string
0020++ 0DB7 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0DB9 59          	add d, a	; end of string
0022++ 0DBA 12          	mov a, c
0023++ 0DBB FD 9B       	shr a		; divide by 2
0024++ 0DBD 39          	mov c, a	; C now counts the steps
0025++ 0DBE             _strrev_L0:
0026++ 0DBE 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0DBF F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0DC0 3E          	mov [d], al	; store left char into right side
0029++ 0DC1 1B          	mov al, bl
0030++ 0DC2 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0DC3 7E          	dec c
0032++ 0DC4 7F          	dec d
0033++ 0DC5 C2 00 00    	cmp c, 0
0034++ 0DC8 C7 BE 0D    	jne _strrev_L0
0035++ 0DCB             _strrev_end:
0036++ 0DCB 4C          	popa
0037++ 0DCC 09          	ret
0038++ 0DCD             	
0039++ 0DCD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0DCD             ; _strchr
0041++ 0DCD             ; search string in D for char in AL
0042++ 0DCD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0DCD             _strchr:
0044++ 0DCD             _strchr_L0:
0045++ 0DCD 32          	mov bl, [d]
0046++ 0DCE C1 00       	cmp bl, 0
0047++ 0DD0 C6 DB 0D    	je _strchr_end
0048++ 0DD3 BA          	cmp al, bl
0049++ 0DD4 C6 DB 0D    	je _strchr_end
0050++ 0DD7 79          	inc d
0051++ 0DD8 0A CD 0D    	jmp _strchr_L0
0052++ 0DDB             _strchr_end:
0053++ 0DDB 1B          	mov al, bl
0054++ 0DDC 09          	ret
0055++ 0DDD             
0056++ 0DDD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0DDD             ; _strstr
0058++ 0DDD             ; find sub-string
0059++ 0DDD             ; str1 in SI
0060++ 0DDD             ; str2 in DI
0061++ 0DDD             ; SI points to end of source string
0062++ 0DDD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0DDD             _strstr:
0064++ 0DDD DB          	push al
0065++ 0DDE DA          	push d
0066++ 0DDF E3          	push di
0067++ 0DE0             _strstr_loop:
0068++ 0DE0 F3          	cmpsb					; compare a byte of the strings
0069++ 0DE1 C7 EC 0D    	jne _strstr_ret
0070++ 0DE4 FC 00 00    	lea d, [di + 0]
0071++ 0DE7 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0DE9 C7 E0 0D    	jne _strstr_loop				; equal chars but not at end
0073++ 0DEC             _strstr_ret:
0074++ 0DEC F0          	pop di
0075++ 0DED E7          	pop d
0076++ 0DEE E8          	pop al
0077++ 0DEF 09          	ret
0078++ 0DF0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0DF0             ; length of null terminated string
0080++ 0DF0             ; result in C
0081++ 0DF0             ; pointer in D
0082++ 0DF0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0DF0             _strlen:
0084++ 0DF0 DA          	push d
0085++ 0DF1 38 00 00    	mov c, 0
0086++ 0DF4             _strlen_L1:
0087++ 0DF4 BD 00       	cmp byte [d], 0
0088++ 0DF6 C6 FE 0D    	je _strlen_ret
0089++ 0DF9 79          	inc d
0090++ 0DFA 78          	inc c
0091++ 0DFB 0A F4 0D    	jmp _strlen_L1
0092++ 0DFE             _strlen_ret:
0093++ 0DFE E7          	pop d
0094++ 0DFF 09          	ret
0095++ 0E00             
0096++ 0E00             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0E00             ; STRCMP
0098++ 0E00             ; compare two strings
0099++ 0E00             ; str1 in SI
0100++ 0E00             ; str2 in DI
0101++ 0E00             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0E00             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0E00             _strcmp:
0104++ 0E00 DB          	push al
0105++ 0E01 DA          	push d
0106++ 0E02 E3          	push di
0107++ 0E03 E2          	push si
0108++ 0E04             _strcmp_loop:
0109++ 0E04 F3          	cmpsb					; compare a byte of the strings
0110++ 0E05 C7 10 0E    	jne _strcmp_ret
0111++ 0E08 FB FF FF    	lea d, [si +- 1]
0112++ 0E0B BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0E0D C7 04 0E    	jne _strcmp_loop				; equal chars but not at end
0114++ 0E10             _strcmp_ret:
0115++ 0E10 EF          	pop si
0116++ 0E11 F0          	pop di
0117++ 0E12 E7          	pop d
0118++ 0E13 E8          	pop al
0119++ 0E14 09          	ret
0120++ 0E15             
0121++ 0E15             
0122++ 0E15             ; STRCPY
0123++ 0E15             ; copy null terminated string from SI to DI
0124++ 0E15             ; source in SI
0125++ 0E15             ; destination in DI
0126++ 0E15             _strcpy:
0127++ 0E15 E2          	push si
0128++ 0E16 E3          	push di
0129++ 0E17 DB          	push al
0130++ 0E18             _strcpy_L1:
0131++ 0E18 F6          	lodsb
0132++ 0E19 F7          	stosb
0133++ 0E1A B9 00       	cmp al, 0
0134++ 0E1C C7 18 0E    	jne _strcpy_L1
0135++ 0E1F             _strcpy_end:
0136++ 0E1F E8          	pop al
0137++ 0E20 F0          	pop di
0138++ 0E21 EF          	pop si
0139++ 0E22 09          	ret
0140++ 0E23             
0141++ 0E23             ; STRCAT
0142++ 0E23             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0E23             ; source in SI
0144++ 0E23             ; destination in DI
0145++ 0E23             _strcat:
0146++ 0E23 E2          	push si
0147++ 0E24 E3          	push di
0148++ 0E25 D7          	push a
0149++ 0E26 DA          	push d
0150++ 0E27 50          	mov a, di
0151++ 0E28 3C          	mov d, a
0152++ 0E29             _strcat_goto_end_L1:
0153++ 0E29 BD 00       	cmp byte[d], 0
0154++ 0E2B C6 32 0E    	je _strcat_start
0155++ 0E2E 79          	inc d
0156++ 0E2F 0A 29 0E    	jmp _strcat_goto_end_L1
0157++ 0E32             _strcat_start:
0158++ 0E32 FD 50       	mov di, d
0159++ 0E34             _strcat_L1:
0160++ 0E34 F6          	lodsb
0161++ 0E35 F7          	stosb
0162++ 0E36 B9 00       	cmp al, 0
0163++ 0E38 C7 34 0E    	jne _strcat_L1
0164++ 0E3B             _strcat_end:
0165++ 0E3B E7          	pop d
0166++ 0E3C E4          	pop a
0167++ 0E3D F0          	pop di
0168++ 0E3E EF          	pop si
0169++ 0E3F 09          	ret
0170++ 0E40             
0171++ 0E40             
0005+  0E40             
0006+  0E40             
0007+  0E40             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  0E40             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  0E40             ; ASCII in BL
0010+  0E40             ; result in AL
0011+  0E40             ; ascii for F = 0100 0110
0012+  0E40             ; ascii for 9 = 0011 1001
0013+  0E40             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  0E40             hex_ascii_encode:
0015+  0E40 1B            mov al, bl
0016+  0E41 93 40         test al, $40        ; test if letter or number
0017+  0E43 C7 49 0E      jnz hex_letter
0018+  0E46 87 0F         and al, $0F        ; get number
0019+  0E48 09            ret
0020+  0E49             hex_letter:
0021+  0E49 87 0F         and al, $0F        ; get letter
0022+  0E4B 6A 09         add al, 9
0023+  0E4D 09            ret
0024+  0E4E             
0025+  0E4E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0E4E             ; ATOI
0027+  0E4E             ; 2 letter hex string in B
0028+  0E4E             ; 8bit integer returned in AL
0029+  0E4E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  0E4E             _atoi:
0031+  0E4E D8            push b
0032+  0E4F 07 40 0E      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  0E52 30            mov bl, bh
0034+  0E53 DB            push al          ; save a
0035+  0E54 07 40 0E      call hex_ascii_encode
0036+  0E57 EA            pop bl  
0037+  0E58 FD 9E 04      shl al, 4
0038+  0E5B 8C            or al, bl
0039+  0E5C E5            pop b
0040+  0E5D 09            ret  
0041+  0E5E             
0042+  0E5E             
0043+  0E5E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  0E5E             ; scanf
0045+  0E5E             ; no need for explanations!
0046+  0E5E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  0E5E             scanf:
0048+  0E5E 09            ret
0049+  0E5F             
0050+  0E5F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0E5F             ; ITOA
0052+  0E5F             ; 8bit value in BL
0053+  0E5F             ; 2 byte ASCII result in A
0054+  0E5F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0E5F             _itoa:
0056+  0E5F DA            push d
0057+  0E60 D8            push b
0058+  0E61 A7 00         mov bh, 0
0059+  0E63 FD A4 04      shr bl, 4  
0060+  0E66 74            mov d, b
0061+  0E67 1F 0F 11      mov al, [d + s_hex_digits]
0062+  0E6A 23            mov ah, al
0063+  0E6B               
0064+  0E6B E5            pop b
0065+  0E6C D8            push b
0066+  0E6D A7 00         mov bh, 0
0067+  0E6F FD 87 0F      and bl, $0F
0068+  0E72 74            mov d, b
0069+  0E73 1F 0F 11      mov al, [d + s_hex_digits]
0070+  0E76 E5            pop b
0071+  0E77 E7            pop d
0072+  0E78 09            ret
0073+  0E79             
0074+  0E79             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  0E79             ; HEX STRING TO BINARY
0076+  0E79             ; di = destination address
0077+  0E79             ; si = source
0078+  0E79             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  0E79             _hex_to_int:
0080+  0E79             _hex_to_int_L1:
0081+  0E79 F6            lodsb          ; load from [SI] to AL
0082+  0E7A B9 00         cmp al, 0        ; check if ASCII 0
0083+  0E7C C6 89 0E      jz _hex_to_int_ret
0084+  0E7F 36            mov bh, al
0085+  0E80 F6            lodsb
0086+  0E81 2F            mov bl, al
0087+  0E82 07 4E 0E      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  0E85 F7            stosb          ; store AL to [DI]
0089+  0E86 0A 79 0E      jmp _hex_to_int_L1
0090+  0E89             _hex_to_int_ret:
0091+  0E89 09            ret    
0092+  0E8A             
0093+  0E8A             
0094+  0E8A             
0095+  0E8A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  0E8A             ; GETCHAR
0097+  0E8A             ; char in ah
0098+  0E8A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  0E8A             getch:
0100+  0E8A DB            push al
0101+  0E8B             getch_retry:
0102+  0E8B 19 01         mov al, 1
0103+  0E8D 05 03         syscall sys_io      ; receive in AH
0104+  0E8F E8            pop al
0105+  0E90 09            ret
0106+  0E91             
0107+  0E91             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  0E91             ; PUTCHAR
0109+  0E91             ; char in ah
0110+  0E91             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0E91             _putchar:
0112+  0E91 D7            push a
0113+  0E92 19 00         mov al, 0
0114+  0E94 05 03         syscall sys_io      ; char in AH
0115+  0E96 E4            pop a
0116+  0E97 09            ret
0117+  0E98             
0118+  0E98             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  0E98             ;; INPUT A STRING
0120+  0E98             ;; terminates with null
0121+  0E98             ;; pointer in D
0122+  0E98             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  0E98             _gets:
0124+  0E98 D7            push a
0125+  0E99 DA            push d
0126+  0E9A             _gets_loop:
0127+  0E9A 19 01         mov al, 1
0128+  0E9C 05 03         syscall sys_io      ; receive in AH
0129+  0E9E B9 00         cmp al, 0        ; check error code (AL)
0130+  0EA0 C6 9A 0E      je _gets_loop      ; if no char received, retry
0131+  0EA3             
0132+  0EA3 76 1B         cmp ah, 27
0133+  0EA5 C6 C6 0E      je _gets_ansi_esc
0134+  0EA8 76 0A         cmp ah, $0A        ; LF
0135+  0EAA C6 31 0F      je _gets_end
0136+  0EAD 76 0D         cmp ah, $0D        ; CR
0137+  0EAF C6 31 0F      je _gets_end
0138+  0EB2 76 5C         cmp ah, $5C        ; '\\'
0139+  0EB4 C6 F2 0E      je _gets_escape
0140+  0EB7               
0141+  0EB7 76 08         cmp ah, $08      ; check for backspace
0142+  0EB9 C6 C2 0E      je _gets_backspace
0143+  0EBC             
0144+  0EBC 1A            mov al, ah
0145+  0EBD 3E            mov [d], al
0146+  0EBE 79            inc d
0147+  0EBF 0A 9A 0E      jmp _gets_loop
0148+  0EC2             _gets_backspace:
0149+  0EC2 7F            dec d
0150+  0EC3 0A 9A 0E      jmp _gets_loop
0151+  0EC6             _gets_ansi_esc:
0152+  0EC6 19 01         mov al, 1
0153+  0EC8 05 03         syscall sys_io        ; receive in AH without echo
0154+  0ECA B9 00         cmp al, 0          ; check error code (AL)
0155+  0ECC C6 C6 0E      je _gets_ansi_esc    ; if no char received, retry
0156+  0ECF 76 5B         cmp ah, '['
0157+  0ED1 C7 9A 0E      jne _gets_loop
0158+  0ED4             _gets_ansi_esc_2:
0159+  0ED4 19 01         mov al, 1
0160+  0ED6 05 03         syscall sys_io          ; receive in AH without echo
0161+  0ED8 B9 00         cmp al, 0            ; check error code (AL)
0162+  0EDA C6 D4 0E      je _gets_ansi_esc_2  ; if no char received, retry
0163+  0EDD 76 44         cmp ah, 'D'
0164+  0EDF C6 EA 0E      je _gets_left_arrow
0165+  0EE2 76 43         cmp ah, 'C'
0166+  0EE4 C6 EE 0E      je _gets_right_arrow
0167+  0EE7 0A 9A 0E      jmp _gets_loop
0168+  0EEA             _gets_left_arrow:
0169+  0EEA 7F            dec d
0170+  0EEB 0A 9A 0E      jmp _gets_loop
0171+  0EEE             _gets_right_arrow:
0172+  0EEE 79            inc d
0173+  0EEF 0A 9A 0E      jmp _gets_loop
0174+  0EF2             _gets_escape:
0175+  0EF2 19 01         mov al, 1
0176+  0EF4 05 03         syscall sys_io      ; receive in AH
0177+  0EF6 B9 00         cmp al, 0        ; check error code (AL)
0178+  0EF8 C6 F2 0E      je _gets_escape      ; if no char received, retry
0179+  0EFB 76 6E         cmp ah, 'n'
0180+  0EFD C6 1C 0F      je _gets_LF
0181+  0F00 76 72         cmp ah, 'r'
0182+  0F02 C6 23 0F      je _gets_CR
0183+  0F05 76 30         cmp ah, '0'
0184+  0F07 C6 2A 0F      je _gets_NULL
0185+  0F0A 76 5C         cmp ah, $5C  ; '\'
0186+  0F0C C6 15 0F      je _gets_slash
0187+  0F0F 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0188+  0F10 3E            mov [d], al
0189+  0F11 79            inc d
0190+  0F12 0A 9A 0E      jmp _gets_loop
0191+  0F15             _gets_slash:
0192+  0F15 19 5C         mov al, $5C
0193+  0F17 3E            mov [d], al
0194+  0F18 79            inc d
0195+  0F19 0A 9A 0E      jmp _gets_loop
0196+  0F1C             _gets_LF:
0197+  0F1C 19 0A         mov al, $0A
0198+  0F1E 3E            mov [d], al
0199+  0F1F 79            inc d
0200+  0F20 0A 9A 0E      jmp _gets_loop
0201+  0F23             _gets_CR:
0202+  0F23 19 0D         mov al, $0D
0203+  0F25 3E            mov [d], al
0204+  0F26 79            inc d
0205+  0F27 0A 9A 0E      jmp _gets_loop
0206+  0F2A             _gets_NULL:
0207+  0F2A 19 00         mov al, $00
0208+  0F2C 3E            mov [d], al
0209+  0F2D 79            inc d
0210+  0F2E 0A 9A 0E      jmp _gets_loop
0211+  0F31             _gets_end:
0212+  0F31 19 00         mov al, 0
0213+  0F33 3E            mov [d], al        ; terminate string
0214+  0F34 E7            pop d
0215+  0F35 E4            pop a
0216+  0F36 09            ret
0217+  0F37             
0218+  0F37             
0219+  0F37             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0220+  0F37             ;; INPUT TEXT
0221+  0F37             ;; terminated with CTRL+D
0222+  0F37             ;; pointer in D
0223+  0F37             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0224+  0F37             _gettxt:
0225+  0F37 D7            push a
0226+  0F38 DA            push d
0227+  0F39             _gettxt_loop:
0228+  0F39 19 01         mov al, 1
0229+  0F3B 05 03         syscall sys_io      ; receive in AH
0230+  0F3D B9 00         cmp al, 0        ; check error code (AL)
0231+  0F3F C6 39 0F      je _gettxt_loop    ; if no char received, retry
0232+  0F42 76 04         cmp ah, 4      ; EOT
0233+  0F44 C6 82 0F      je _gettxt_end
0234+  0F47 76 08         cmp ah, $08      ; check for backspace
0235+  0F49 C6 7E 0F      je _gettxt_backspace
0236+  0F4C 76 5C         cmp ah, $5C        ; '\'
0237+  0F4E C6 57 0F      je _gettxt_escape
0238+  0F51 1A            mov al, ah
0239+  0F52 3E            mov [d], al
0240+  0F53 79            inc d
0241+  0F54 0A 39 0F      jmp _gettxt_loop
0242+  0F57             _gettxt_escape:
0243+  0F57 19 01         mov al, 1
0244+  0F59 05 03         syscall sys_io      ; receive in AH
0245+  0F5B B9 00         cmp al, 0        ; check error code (AL)
0246+  0F5D C6 57 0F      je _gettxt_escape    ; if no char received, retry
0247+  0F60 76 6E         cmp ah, 'n'
0248+  0F62 C6 70 0F      je _gettxt_LF
0249+  0F65 76 72         cmp ah, 'r'
0250+  0F67 C6 77 0F      je _gettxt_CR
0251+  0F6A 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0252+  0F6B 3E            mov [d], al
0253+  0F6C 79            inc d
0254+  0F6D 0A 39 0F      jmp _gettxt_loop
0255+  0F70             _gettxt_LF:
0256+  0F70 19 0A         mov al, $0A
0257+  0F72 3E            mov [d], al
0258+  0F73 79            inc d
0259+  0F74 0A 39 0F      jmp _gettxt_loop
0260+  0F77             _gettxt_CR:
0261+  0F77 19 0D         mov al, $0D
0262+  0F79 3E            mov [d], al
0263+  0F7A 79            inc d
0264+  0F7B 0A 39 0F      jmp _gettxt_loop
0265+  0F7E             _gettxt_backspace:
0266+  0F7E 7F            dec d
0267+  0F7F 0A 39 0F      jmp _gettxt_loop
0268+  0F82             _gettxt_end:
0269+  0F82 19 00         mov al, 0
0270+  0F84 3E            mov [d], al        ; terminate string
0271+  0F85 E7            pop d
0272+  0F86 E4            pop a
0273+  0F87 09            ret
0274+  0F88             
0275+  0F88             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  0F88             ; PRINT NEW LINE
0277+  0F88             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0278+  0F88             printnl:
0279+  0F88 D7            push a
0280+  0F89 10 00 0A      mov a, $0A00
0281+  0F8C 05 03         syscall sys_io
0282+  0F8E 10 00 0D      mov a, $0D00
0283+  0F91 05 03         syscall sys_io
0284+  0F93 E4            pop a
0285+  0F94 09            ret
0286+  0F95             
0287+  0F95             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  0F95             ; _strtoint
0289+  0F95             ; 4 digit hex string number in d
0290+  0F95             ; integer returned in A
0291+  0F95             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0292+  0F95             _strtointx:
0293+  0F95 D8            push b
0294+  0F96 32            mov bl, [d]
0295+  0F97 37            mov bh, bl
0296+  0F98 33 01 00      mov bl, [d + 1]
0297+  0F9B 07 4E 0E      call _atoi        ; convert to int in AL
0298+  0F9E 23            mov ah, al        ; move to AH
0299+  0F9F 33 02 00      mov bl, [d + 2]
0300+  0FA2 37            mov bh, bl
0301+  0FA3 33 03 00      mov bl, [d + 3]
0302+  0FA6 07 4E 0E      call _atoi        ; convert to int in AL
0303+  0FA9 E5            pop b
0304+  0FAA 09            ret
0305+  0FAB             
0306+  0FAB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0307+  0FAB             ; _strtoint
0308+  0FAB             ; 5 digit base10 string number in d
0309+  0FAB             ; integer returned in A
0310+  0FAB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0311+  0FAB             _strtoint:
0312+  0FAB E2            push si
0313+  0FAC D8            push b
0314+  0FAD D9            push c
0315+  0FAE DA            push d
0316+  0FAF 07 F0 0D      call _strlen      ; get string length in C
0317+  0FB2 7E            dec c
0318+  0FB3 FD 4E         mov si, d
0319+  0FB5 12            mov a, c
0320+  0FB6 FD 99         shl a
0321+  0FB8 3B 27 11      mov d, table_power
0322+  0FBB 59            add d, a
0323+  0FBC 38 00 00      mov c, 0
0324+  0FBF             _strtoint_L0:
0325+  0FBF F6            lodsb      ; load ASCII to al
0326+  0FC0 B9 00         cmp al, 0
0327+  0FC2 C6 D5 0F      je _strtoint_end
0328+  0FC5 6F 30         sub al, $30    ; make into integer
0329+  0FC7 22 00         mov ah, 0
0330+  0FC9 2A            mov b, [d]
0331+  0FCA AC            mul a, b      ; result in B since it fits in 16bits
0332+  0FCB 11            mov a, b
0333+  0FCC 28            mov b, c
0334+  0FCD 54            add a, b
0335+  0FCE 39            mov c, a
0336+  0FCF 63 02 00      sub d, 2
0337+  0FD2 0A BF 0F      jmp _strtoint_L0
0338+  0FD5             _strtoint_end:
0339+  0FD5 12            mov a, c
0340+  0FD6 E7            pop d
0341+  0FD7 E6            pop c
0342+  0FD8 E5            pop b
0343+  0FD9 EF            pop si
0344+  0FDA 09            ret
0345+  0FDB             
0346+  0FDB             
0347+  0FDB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0348+  0FDB             ; PRINT NULL TERMINATED STRING
0349+  0FDB             ; pointer in D
0350+  0FDB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0351+  0FDB             _puts:
0352+  0FDB D7            push a
0353+  0FDC DA            push d
0354+  0FDD             _puts_L1:
0355+  0FDD 1E            mov al, [d]
0356+  0FDE B9 00         cmp al, 0
0357+  0FE0 C6 EC 0F      jz _puts_END
0358+  0FE3 23            mov ah, al
0359+  0FE4 19 00         mov al, 0
0360+  0FE6 05 03         syscall sys_io
0361+  0FE8 79            inc d
0362+  0FE9 0A DD 0F      jmp _puts_L1
0363+  0FEC             _puts_END:
0364+  0FEC E7            pop d
0365+  0FED E4            pop a
0366+  0FEE 09            ret
0367+  0FEF             
0368+  0FEF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0369+  0FEF             ; PRINT N SIZE STRING
0370+  0FEF             ; pointer in D
0371+  0FEF             ; size in C
0372+  0FEF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0373+  0FEF             _putsn:
0374+  0FEF DB            push al
0375+  0FF0 DA            push d
0376+  0FF1 D9            push c
0377+  0FF2             _putsn_L0:
0378+  0FF2 1E            mov al, [d]
0379+  0FF3 23            mov ah, al
0380+  0FF4 19 00         mov al, 0
0381+  0FF6 05 03         syscall sys_io
0382+  0FF8 79            inc d
0383+  0FF9 7E            dec c  
0384+  0FFA C2 00 00      cmp c, 0
0385+  0FFD C7 F2 0F      jne _putsn_L0
0386+  1000             _putsn_end:
0387+  1000 E6            pop c
0388+  1001 E7            pop d
0389+  1002 E8            pop al
0390+  1003 09            ret
0391+  1004             
0392+  1004             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0393+  1004             ; print 16bit decimal number
0394+  1004             ; input number in A
0395+  1004             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0396+  1004             print_u16d:
0397+  1004 D7            push a
0398+  1005 D8            push b
0399+  1006 26 10 27      mov b, 10000
0400+  1009 AE            div a, b      ; get 10000's coeff.
0401+  100A 07 2C 10      call print_number
0402+  100D 11            mov a, b
0403+  100E 26 E8 03      mov b, 1000
0404+  1011 AE            div a, b      ; get 1000's coeff.
0405+  1012 07 2C 10      call print_number
0406+  1015 11            mov a, b
0407+  1016 26 64 00      mov b, 100
0408+  1019 AE            div a, b
0409+  101A 07 2C 10      call print_number
0410+  101D 11            mov a, b
0411+  101E 26 0A 00      mov b, 10
0412+  1021 AE            div a, b
0413+  1022 07 2C 10      call print_number
0414+  1025 1B            mov al, bl      ; 1's coeff in bl
0415+  1026 07 2C 10      call print_number
0416+  1029 E5            pop b
0417+  102A E4            pop a
0418+  102B 09            ret
0419+  102C             
0420+  102C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0421+  102C             ; print AL
0422+  102C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0423+  102C             print_number:
0424+  102C 6A 30         add al, $30
0425+  102E 23            mov ah, al
0426+  102F 07 91 0E      call _putchar
0427+  1032 09            ret
0428+  1033             
0429+  1033             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0430+  1033             ; PRINT 16BIT HEX INTEGER
0431+  1033             ; integer value in reg B
0432+  1033             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  1033             print_u16x:
0434+  1033 D7            push a
0435+  1034 D8            push b
0436+  1035 DD            push bl
0437+  1036 30            mov bl, bh
0438+  1037 07 5F 0E      call _itoa        ; convert bh to char in A
0439+  103A 2F            mov bl, al        ; save al
0440+  103B 19 00         mov al, 0
0441+  103D 05 03         syscall sys_io        ; display AH
0442+  103F 24            mov ah, bl        ; retrieve al
0443+  1040 19 00         mov al, 0
0444+  1042 05 03         syscall sys_io        ; display AL
0445+  1044             
0446+  1044 EA            pop bl
0447+  1045 07 5F 0E      call _itoa        ; convert bh to char in A
0448+  1048 2F            mov bl, al        ; save al
0449+  1049 19 00         mov al, 0
0450+  104B 05 03         syscall sys_io        ; display AH
0451+  104D 24            mov ah, bl        ; retrieve al
0452+  104E 19 00         mov al, 0
0453+  1050 05 03         syscall sys_io        ; display AL
0454+  1052             
0455+  1052 E5            pop b
0456+  1053 E4            pop a
0457+  1054 09            ret
0458+  1055             
0459+  1055             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0460+  1055             ; INPUT 16BIT HEX INTEGER
0461+  1055             ; read 16bit integer into A
0462+  1055             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0463+  1055             scan_u16x:
0464+  1055 F8 10 00      enter 16
0465+  1058 D8            push b
0466+  1059 DA            push d
0467+  105A             
0468+  105A FA F1 FF      lea d, [bp + -15]
0469+  105D 07 98 0E      call _gets        ; get number
0470+  1060             
0471+  1060 32            mov bl, [d]
0472+  1061 37            mov bh, bl
0473+  1062 33 01 00      mov bl, [d + 1]
0474+  1065 07 4E 0E      call _atoi        ; convert to int in AL
0475+  1068 23            mov ah, al        ; move to AH
0476+  1069             
0477+  1069 33 02 00      mov bl, [d + 2]
0478+  106C 37            mov bh, bl
0479+  106D 33 03 00      mov bl, [d + 3]
0480+  1070 07 4E 0E      call _atoi        ; convert to int in AL
0481+  1073             
0482+  1073 E7            pop d
0483+  1074 E5            pop b
0484+  1075 F9            leave
0485+  1076 09            ret
0486+  1077             
0487+  1077             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0488+  1077             ; PRINT 8bit HEX INTEGER
0489+  1077             ; integer value in reg bl
0490+  1077             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0491+  1077             print_u8x:
0492+  1077 D7            push a
0493+  1078 DD            push bl
0494+  1079             
0495+  1079 07 5F 0E      call _itoa        ; convert bl to char in A
0496+  107C 2F            mov bl, al        ; save al
0497+  107D 19 00         mov al, 0
0498+  107F 05 03         syscall sys_io        ; display AH
0499+  1081 24            mov ah, bl        ; retrieve al
0500+  1082 19 00         mov al, 0
0501+  1084 05 03         syscall sys_io        ; display AL
0502+  1086             
0503+  1086 EA            pop bl
0504+  1087 E4            pop a
0505+  1088 09            ret
0506+  1089             
0507+  1089             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0508+  1089             ; print 8bit decimal unsigned number
0509+  1089             ; input number in AL
0510+  1089             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0511+  1089             print_u8d:
0512+  1089 D7            push a
0513+  108A D8            push b
0514+  108B             
0515+  108B 22 00         mov ah, 0
0516+  108D 26 64 00      mov b, 100
0517+  1090 AE            div a, b
0518+  1091 D8            push b      ; save remainder
0519+  1092 B9 00         cmp al, 0
0520+  1094 C6 9E 10      je skip100
0521+  1097 6A 30         add al, $30
0522+  1099 23            mov ah, al
0523+  109A 19 00         mov al, 0
0524+  109C 05 03         syscall sys_io  ; print coeff
0525+  109E             skip100:
0526+  109E E4            pop a
0527+  109F 22 00         mov ah, 0
0528+  10A1 26 0A 00      mov b, 10
0529+  10A4 AE            div a, b
0530+  10A5 D8            push b      ; save remainder
0531+  10A6 B9 00         cmp al, 0
0532+  10A8 C6 B2 10      je skip10
0533+  10AB 6A 30         add al, $30
0534+  10AD 23            mov ah, al
0535+  10AE 19 00         mov al, 0
0536+  10B0 05 03         syscall sys_io  ; print coeff
0537+  10B2             skip10:
0538+  10B2 E4            pop a
0539+  10B3 1B            mov al, bl
0540+  10B4 6A 30         add al, $30
0541+  10B6 23            mov ah, al
0542+  10B7 19 00         mov al, 0
0543+  10B9 05 03         syscall sys_io  ; print coeff
0544+  10BB E5            pop b
0545+  10BC E4            pop a
0546+  10BD 09            ret
0547+  10BE             
0548+  10BE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0549+  10BE             ; INPUT 8BIT HEX INTEGER
0550+  10BE             ; read 8bit integer into AL
0551+  10BE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0552+  10BE             scan_u8x:
0553+  10BE F8 04 00      enter 4
0554+  10C1 D8            push b
0555+  10C2 DA            push d
0556+  10C3             
0557+  10C3 FA FD FF      lea d, [bp + -3]
0558+  10C6 07 98 0E      call _gets        ; get number
0559+  10C9             
0560+  10C9 32            mov bl, [d]
0561+  10CA 37            mov bh, bl
0562+  10CB 33 01 00      mov bl, [d + 1]
0563+  10CE 07 4E 0E      call _atoi        ; convert to int in AL
0564+  10D1             
0565+  10D1 E7            pop d
0566+  10D2 E5            pop b
0567+  10D3 F9            leave
0568+  10D4 09            ret
0569+  10D5             
0570+  10D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  10D5             ; input decimal number
0572+  10D5             ; result in A
0573+  10D5             ; 655'\0'
0574+  10D5             ; low--------high
0575+  10D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0576+  10D5             scan_u16d:
0577+  10D5 F8 08 00      enter 8
0578+  10D8 E2            push si
0579+  10D9 D8            push b
0580+  10DA D9            push c
0581+  10DB DA            push d
0582+  10DC FA F9 FF      lea d, [bp +- 7]
0583+  10DF 07 98 0E      call _gets
0584+  10E2 07 F0 0D      call _strlen      ; get string length in C
0585+  10E5 7E            dec c
0586+  10E6 FD 4E         mov si, d
0587+  10E8 12            mov a, c
0588+  10E9 FD 99         shl a
0589+  10EB 3B 27 11      mov d, table_power
0590+  10EE 59            add d, a
0591+  10EF 38 00 00      mov c, 0
0592+  10F2             mul_loop:
0593+  10F2 F6            lodsb      ; load ASCII to al
0594+  10F3 B9 00         cmp al, 0
0595+  10F5 C6 08 11      je mul_exit
0596+  10F8 6F 30         sub al, $30    ; make into integer
0597+  10FA 22 00         mov ah, 0
0598+  10FC 2A            mov b, [d]
0599+  10FD AC            mul a, b      ; result in B since it fits in 16bits
0600+  10FE 11            mov a, b
0601+  10FF 28            mov b, c
0602+  1100 54            add a, b
0603+  1101 39            mov c, a
0604+  1102 63 02 00      sub d, 2
0605+  1105 0A F2 10      jmp mul_loop
0606+  1108             mul_exit:
0607+  1108 12            mov a, c
0608+  1109 E7            pop d
0609+  110A E6            pop c
0610+  110B E5            pop b
0611+  110C EF            pop si
0612+  110D F9            leave
0613+  110E 09            ret
0614+  110F             
0615+  110F             
0616+  110F 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0616+  1113 34 35 36 37 
0616+  1117 38 39 41 42 
0616+  111B 43 44 45 46 
0617+  111F 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0617+  1123 1B 5B 48 00 
0618+  1127             
0619+  1127             table_power:
0620+  1127 01 00         .dw 1
0621+  1129 0A 00         .dw 10
0622+  112B 64 00         .dw 100
0623+  112D E8 03         .dw 1000
0624+  112F 10 27         .dw 100001831   1131             ; --- END INLINE ASM BLOCK
1832   1131             
1833   1131 F9            leave
1834   1132 09            ret
1835   1133             
1836   1133             sqrt:
1837   1133 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1838   1136             ; $x 
1839   1136             ; $y 
1840   1136 52 04 00      sub sp, 4
1841   1139             ;; if (n <= 1) { 
1842   1139             _if25_cond:
1843   1139 FA 05 00      lea d, [bp + 5] ; $n
1844   113C 2A            mov b, [d]
1845   113D             ; START RELATIONAL
1846   113D D7            push a
1847   113E 11            mov a, b
1848   113F 26 01 00      mov b, $1
1849   1142 B0            cmp a, b
1850   1143 FD 74         sle ; <=
1851   1145 E4            pop a
1852   1146             ; END RELATIONAL
1853   1146 C0 00 00      cmp b, 0
1854   1149 C6 55 11      je _if25_exit
1855   114C             _if25_true:
1856   114C             ;; return n; 
1857   114C FA 05 00      lea d, [bp + 5] ; $n
1858   114F 2A            mov b, [d]
1859   1150 F9            leave
1860   1151 09            ret
1861   1152 0A 55 11      jmp _if25_exit
1862   1155             _if25_exit:
1863   1155             ;; x = n; 
1864   1155 FA FF FF      lea d, [bp + -1] ; $x
1865   1158 DA            push d
1866   1159 FA 05 00      lea d, [bp + 5] ; $n
1867   115C 2A            mov b, [d]
1868   115D E7            pop d
1869   115E FD 43         mov [d], b
1870   1160             ;; y = (x + n / x) / 2; 
1871   1160 FA FD FF      lea d, [bp + -3] ; $y
1872   1163 DA            push d
1873   1164 FA FF FF      lea d, [bp + -1] ; $x
1874   1167 2A            mov b, [d]
1875   1168             ; START TERMS
1876   1168 D7            push a
1877   1169 11            mov a, b
1878   116A FA 05 00      lea d, [bp + 5] ; $n
1879   116D 2A            mov b, [d]
1880   116E             ; START FACTORS
1881   116E D7            push a
1882   116F 11            mov a, b
1883   1170 FA FF FF      lea d, [bp + -1] ; $x
1884   1173 2A            mov b, [d]
1885   1174 AE            div a, b
1886   1175 27            mov b, a
1887   1176 E4            pop a
1888   1177             ; END FACTORS
1889   1177 54            add a, b
1890   1178 27            mov b, a
1891   1179 E4            pop a
1892   117A             ; END TERMS
1893   117A             ; START FACTORS
1894   117A D7            push a
1895   117B 11            mov a, b
1896   117C 26 02 00      mov b, $2
1897   117F AE            div a, b
1898   1180 27            mov b, a
1899   1181 E4            pop a
1900   1182             ; END FACTORS
1901   1182 E7            pop d
1902   1183 FD 43         mov [d], b
1903   1185             ;; while (y < x) { 
1904   1185             _while26_cond:
1905   1185 FA FD FF      lea d, [bp + -3] ; $y
1906   1188 2A            mov b, [d]
1907   1189             ; START RELATIONAL
1908   1189 D7            push a
1909   118A 11            mov a, b
1910   118B FA FF FF      lea d, [bp + -1] ; $x
1911   118E 2A            mov b, [d]
1912   118F B0            cmp a, b
1913   1190 FD 73         slt ; < 
1914   1192 E4            pop a
1915   1193             ; END RELATIONAL
1916   1193 C0 00 00      cmp b, 0
1917   1196 C6 CC 11      je _while26_exit
1918   1199             _while26_block:
1919   1199             ;; x = y; 
1920   1199 FA FF FF      lea d, [bp + -1] ; $x
1921   119C DA            push d
1922   119D FA FD FF      lea d, [bp + -3] ; $y
1923   11A0 2A            mov b, [d]
1924   11A1 E7            pop d
1925   11A2 FD 43         mov [d], b
1926   11A4             ;; y = (x + n / x) / 2; 
1927   11A4 FA FD FF      lea d, [bp + -3] ; $y
1928   11A7 DA            push d
1929   11A8 FA FF FF      lea d, [bp + -1] ; $x
1930   11AB 2A            mov b, [d]
1931   11AC             ; START TERMS
1932   11AC D7            push a
1933   11AD 11            mov a, b
1934   11AE FA 05 00      lea d, [bp + 5] ; $n
1935   11B1 2A            mov b, [d]
1936   11B2             ; START FACTORS
1937   11B2 D7            push a
1938   11B3 11            mov a, b
1939   11B4 FA FF FF      lea d, [bp + -1] ; $x
1940   11B7 2A            mov b, [d]
1941   11B8 AE            div a, b
1942   11B9 27            mov b, a
1943   11BA E4            pop a
1944   11BB             ; END FACTORS
1945   11BB 54            add a, b
1946   11BC 27            mov b, a
1947   11BD E4            pop a
1948   11BE             ; END TERMS
1949   11BE             ; START FACTORS
1950   11BE D7            push a
1951   11BF 11            mov a, b
1952   11C0 26 02 00      mov b, $2
1953   11C3 AE            div a, b
1954   11C4 27            mov b, a
1955   11C5 E4            pop a
1956   11C6             ; END FACTORS
1957   11C6 E7            pop d
1958   11C7 FD 43         mov [d], b
1959   11C9 0A 85 11      jmp _while26_cond
1960   11CC             _while26_exit:
1961   11CC             ;; return x; 
1962   11CC FA FF FF      lea d, [bp + -1] ; $x
1963   11CF 2A            mov b, [d]
1964   11D0 F9            leave
1965   11D1 09            ret
1966   11D2             
1967   11D2             exp:
1968   11D2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1969   11D5             ; $i 
1970   11D5             ; $result 
1971   11D5 10 01 00      mov a, $1
1972   11D8 45 FD FF      mov [bp + -3], a
1973   11DB 52 04 00      sub sp, 4
1974   11DE             ;; for(i = 0; i < exp; i++){ 
1975   11DE             _for27_init:
1976   11DE FA FF FF      lea d, [bp + -1] ; $i
1977   11E1 DA            push d
1978   11E2 26 00 00      mov b, $0
1979   11E5 E7            pop d
1980   11E6 FD 43         mov [d], b
1981   11E8             _for27_cond:
1982   11E8 FA FF FF      lea d, [bp + -1] ; $i
1983   11EB 2A            mov b, [d]
1984   11EC             ; START RELATIONAL
1985   11EC D7            push a
1986   11ED 11            mov a, b
1987   11EE FA 05 00      lea d, [bp + 5] ; $exp
1988   11F1 2A            mov b, [d]
1989   11F2 B0            cmp a, b
1990   11F3 FD 73         slt ; < 
1991   11F5 E4            pop a
1992   11F6             ; END RELATIONAL
1993   11F6 C0 00 00      cmp b, 0
1994   11F9 C6 23 12      je _for27_exit
1995   11FC             _for27_block:
1996   11FC             ;; result = result * base; 
1997   11FC FA FD FF      lea d, [bp + -3] ; $result
1998   11FF DA            push d
1999   1200 FA FD FF      lea d, [bp + -3] ; $result
2000   1203 2A            mov b, [d]
2001   1204             ; START FACTORS
2002   1204 D7            push a
2003   1205 11            mov a, b
2004   1206 FA 07 00      lea d, [bp + 7] ; $base
2005   1209 2A            mov b, [d]
2006   120A AC            mul a, b ; *
2007   120B 11            mov a, b
2008   120C 27            mov b, a
2009   120D E4            pop a
2010   120E             ; END FACTORS
2011   120E E7            pop d
2012   120F FD 43         mov [d], b
2013   1211             _for27_update:
2014   1211 FA FF FF      lea d, [bp + -1] ; $i
2015   1214 2A            mov b, [d]
2016   1215 FD 79         mov g, b
2017   1217 FD 77         inc b
2018   1219 FA FF FF      lea d, [bp + -1] ; $i
2019   121C FD 43         mov [d], b
2020   121E FD 27         mov b, g
2021   1220 0A E8 11      jmp _for27_cond
2022   1223             _for27_exit:
2023   1223             ;; return result; 
2024   1223 FA FD FF      lea d, [bp + -3] ; $result
2025   1226 2A            mov b, [d]
2026   1227 F9            leave
2027   1228 09            ret
2028   1229             ; --- END TEXT BLOCK
2029   1229             
2030   1229             ; --- BEGIN DATA BLOCK
2031   1229 48 65 6C 6C __s0: .db "Hello: %s", 0
2031   122D 6F 3A 20 25 
2031   1231 73 00 
2032   1233 4A 6F 68 6E __s1: .db "John", 0
2032   1237 00 
2033   1238 55 6E 6B 6E __s2: .db "Unknown type size in va_arg() call. Size needs to be either 1 or 2.", 0
2033   123C 6F 77 6E 20 
2033   1240 74 79 70 65 
2033   1244 20 73 69 7A 
2033   1248 65 20 69 6E 
2033   124C 20 76 61 5F 
2033   1250 61 72 67 28 
2033   1254 29 20 63 61 
2033   1258 6C 6C 2E 20 
2033   125C 53 69 7A 65 
2033   1260 20 6E 65 65 
2033   1264 64 73 20 74 
2033   1268 6F 20 62 65 
2033   126C 20 65 69 74 
2033   1270 68 65 72 20 
2033   1274 31 20 6F 72 
2033   1278 20 32 2E 00 
2034   127C 45 72 72 6F __s3: .db "Error: Unknown argument type.\n", 0
2034   1280 72 3A 20 55 
2034   1284 6E 6B 6E 6F 
2034   1288 77 6E 20 61 
2034   128C 72 67 75 6D 
2034   1290 65 6E 74 20 
2034   1294 74 79 70 65 
2034   1298 2E 0A 00 
2035   129B 1B 5B 32 4A __s4: .db "\033[2J\033[H", 0
2035   129F 1B 5B 48 00 
2036   12A3             
2037   12A3 A5 12       _heap_top: .dw _heap
2038   12A5 00          _heap: .db 0
2039   12A6             ; --- END DATA BLOCK
2040   12A6             
2041   12A6             .end
tasm: Number of errors = 0
