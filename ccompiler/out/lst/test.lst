0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT SEGMENT
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; p++; 
0011   0408 3B 51 21      mov d, _p ; $p
0012   040B 2A            mov b, [d]
0013   040C 38 00 00      mov c, 0
0014   040F 11            mov a, b
0015   0410 FD 77         inc b
0016   0412 FD 77         inc b
0017   0414 3B 51 21      mov d, _p ; $p
0018   0417 FD 43         mov [d], b
0019   0419 27            mov b, a
0020   041A 05 0B         syscall sys_terminate_proc
0021   041C             
0022   041C             strcpy:
0023   041C F8 00 00      enter 0 ; (push bp; mov bp, sp)
0024   041F             ; char *psrc; 
0025   041F 52 02 00      sub sp, 2
0026   0422             ; char *pdest; 
0027   0422 52 02 00      sub sp, 2
0028   0425             ; psrc = src; 
0029   0425 FA FF FF      lea d, [bp + -1] ; $psrc
0030   0428 DA            push d
0031   0429 FA 07 00      lea d, [bp + 7] ; $src
0032   042C 2A            mov b, [d]
0033   042D 38 00 00      mov c, 0
0034   0430 E7            pop d
0035   0431 FD 43         mov [d], b
0036   0433             ; pdest = dest; 
0037   0433 FA FD FF      lea d, [bp + -3] ; $pdest
0038   0436 DA            push d
0039   0437 FA 05 00      lea d, [bp + 5] ; $dest
0040   043A 2A            mov b, [d]
0041   043B 38 00 00      mov c, 0
0042   043E E7            pop d
0043   043F FD 43         mov [d], b
0044   0441             ; while(*psrc) *pdest++ = *psrc++; 
0045   0441             _while1_cond:
0046   0441 FA FF FF      lea d, [bp + -1] ; $psrc
0047   0444 2A            mov b, [d]
0048   0445 38 00 00      mov c, 0
0049   0448 74            mov d, b
0050   0449 32            mov bl, [d]
0051   044A A7 00         mov bh, 0
0052   044C 38 00 00      mov c, 0
0053   044F C0 00 00      cmp b, 0
0054   0452 C6 83 04      je _while1_exit
0055   0455             _while1_block:
0056   0455             ; *pdest++ = *psrc++; 
0057   0455 FA FD FF      lea d, [bp + -3] ; $pdest
0058   0458 2A            mov b, [d]
0059   0459 38 00 00      mov c, 0
0060   045C FD 77         inc b
0061   045E FA FD FF      lea d, [bp + -3] ; $pdest
0062   0461 FD 3E         mov [d], bl
0063   0463 FD 7D         dec b
0064   0465 D8            push b
0065   0466 FA FF FF      lea d, [bp + -1] ; $psrc
0066   0469 2A            mov b, [d]
0067   046A 38 00 00      mov c, 0
0068   046D FD 77         inc b
0069   046F FA FF FF      lea d, [bp + -1] ; $psrc
0070   0472 FD 3E         mov [d], bl
0071   0474 FD 7D         dec b
0072   0476 74            mov d, b
0073   0477 32            mov bl, [d]
0074   0478 A7 00         mov bh, 0
0075   047A 38 00 00      mov c, 0
0076   047D E7            pop d
0077   047E FD 3E         mov [d], bl
0078   0480 0A 41 04      jmp _while1_cond
0079   0483             _while1_exit:
0080   0483             ; *pdest = '\0'; 
0081   0483 FA FD FF      lea d, [bp + -3] ; $pdest
0082   0486 2A            mov b, [d]
0083   0487 38 00 00      mov c, 0
0084   048A D8            push b
0085   048B FD 2E 00 00   mov32 cb, $00000000
0085   048F 00 00 
0086   0491 E7            pop d
0087   0492 FD 3E         mov [d], bl
0088   0494 F9            leave
0089   0495 09            ret
0090   0496             
0091   0496             strcmp:
0092   0496 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0093   0499             ; while (*s1 && (*s1 == *s2)) { 
0094   0499             _while2_cond:
0095   0499 FA 05 00      lea d, [bp + 5] ; $s1
0096   049C 2A            mov b, [d]
0097   049D 38 00 00      mov c, 0
0098   04A0 74            mov d, b
0099   04A1 32            mov bl, [d]
0100   04A2 A7 00         mov bh, 0
0101   04A4 38 00 00      mov c, 0
0102   04A7             ; --- START LOGICAL AND
0103   04A7 D7            push a
0104   04A8 11            mov a, b
0105   04A9 FA 05 00      lea d, [bp + 5] ; $s1
0106   04AC 2A            mov b, [d]
0107   04AD 38 00 00      mov c, 0
0108   04B0 74            mov d, b
0109   04B1 32            mov bl, [d]
0110   04B2 A7 00         mov bh, 0
0111   04B4 38 00 00      mov c, 0
0112   04B7             ; --- START RELATIONAL
0113   04B7 D7            push a
0114   04B8 11            mov a, b
0115   04B9 FA 07 00      lea d, [bp + 7] ; $s2
0116   04BC 2A            mov b, [d]
0117   04BD 38 00 00      mov c, 0
0118   04C0 74            mov d, b
0119   04C1 32            mov bl, [d]
0120   04C2 A7 00         mov bh, 0
0121   04C4 38 00 00      mov c, 0
0122   04C7 B0            cmp a, b
0123   04C8 FD 71         seq ; ==
0124   04CA E4            pop a
0125   04CB             ; --- END RELATIONAL
0126   04CB FD A7         sand a, b
0127   04CD E4            pop a
0128   04CE             ; --- END LOGICAL AND
0129   04CE C0 00 00      cmp b, 0
0130   04D1 C6 F7 04      je _while2_exit
0131   04D4             _while2_block:
0132   04D4             ; s1++; 
0133   04D4 FA 05 00      lea d, [bp + 5] ; $s1
0134   04D7 2A            mov b, [d]
0135   04D8 38 00 00      mov c, 0
0136   04DB FD 77         inc b
0137   04DD FA 05 00      lea d, [bp + 5] ; $s1
0138   04E0 FD 3E         mov [d], bl
0139   04E2 FD 7D         dec b
0140   04E4             ; s2++; 
0141   04E4 FA 07 00      lea d, [bp + 7] ; $s2
0142   04E7 2A            mov b, [d]
0143   04E8 38 00 00      mov c, 0
0144   04EB FD 77         inc b
0145   04ED FA 07 00      lea d, [bp + 7] ; $s2
0146   04F0 FD 3E         mov [d], bl
0147   04F2 FD 7D         dec b
0148   04F4 0A 99 04      jmp _while2_cond
0149   04F7             _while2_exit:
0150   04F7             ; return *s1 - *s2; 
0151   04F7 FA 05 00      lea d, [bp + 5] ; $s1
0152   04FA 2A            mov b, [d]
0153   04FB 38 00 00      mov c, 0
0154   04FE 74            mov d, b
0155   04FF 32            mov bl, [d]
0156   0500 A7 00         mov bh, 0
0157   0502 38 00 00      mov c, 0
0158   0505             ; --- START TERMS
0159   0505 D7            push a
0160   0506 11            mov a, b
0161   0507 FA 07 00      lea d, [bp + 7] ; $s2
0162   050A 2A            mov b, [d]
0163   050B 38 00 00      mov c, 0
0164   050E 74            mov d, b
0165   050F 32            mov bl, [d]
0166   0510 A7 00         mov bh, 0
0167   0512 38 00 00      mov c, 0
0168   0515 60            sub a, b
0169   0516 27            mov b, a
0170   0517 E4            pop a
0171   0518             ; --- END TERMS
0172   0518 F9            leave
0173   0519 09            ret
0174   051A             
0175   051A             strncmp:
0176   051A F8 00 00      enter 0 ; (push bp; mov bp, sp)
0177   051D F9            leave
0178   051E 09            ret
0179   051F             
0180   051F             strcat:
0181   051F F8 00 00      enter 0 ; (push bp; mov bp, sp)
0182   0522             ; int dest_len; 
0183   0522 52 02 00      sub sp, 2
0184   0525             ; int i; 
0185   0525 52 02 00      sub sp, 2
0186   0528             ; dest_len = strlen(dest); 
0187   0528 FA FF FF      lea d, [bp + -1] ; $dest_len
0188   052B DA            push d
0189   052C             ; --- START FUNCTION CALL
0190   052C FA 05 00      lea d, [bp + 5] ; $dest
0191   052F 2A            mov b, [d]
0192   0530 38 00 00      mov c, 0
0193   0533 FD AB         swp b
0194   0535 D8            push b
0195   0536 07 02 06      call strlen
0196   0539 51 02 00      add sp, 2
0197   053C             ; --- END FUNCTION CALL
0198   053C E7            pop d
0199   053D FD 43         mov [d], b
0200   053F             ; for (i = 0; src[i] != 0; i=i+1) { 
0201   053F             _for3_init:
0202   053F FA FD FF      lea d, [bp + -3] ; $i
0203   0542 DA            push d
0204   0543 FD 2E 00 00   mov32 cb, $00000000
0204   0547 00 00 
0205   0549 E7            pop d
0206   054A FD 43         mov [d], b
0207   054C             _for3_cond:
0208   054C FA 07 00      lea d, [bp + 7] ; $src
0209   054F FD 2A         mov d, [d]
0210   0551 D7            push a
0211   0552 DA            push d
0212   0553 FA FD FF      lea d, [bp + -3] ; $i
0213   0556 2A            mov b, [d]
0214   0557 38 00 00      mov c, 0
0215   055A E7            pop d
0216   055B FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0217   055F E4            pop a
0218   0560 32            mov bl, [d]
0219   0561 A7 00         mov bh, 0
0220   0563 38 00 00      mov c, 0
0221   0566             ; --- START RELATIONAL
0222   0566 D7            push a
0223   0567 11            mov a, b
0224   0568 FD 2E 00 00   mov32 cb, $00000000
0224   056C 00 00 
0225   056E B0            cmp a, b
0226   056F FD 72         sneq ; !=
0227   0571 E4            pop a
0228   0572             ; --- END RELATIONAL
0229   0572 C0 00 00      cmp b, 0
0230   0575 C6 D0 05      je _for3_exit
0231   0578             _for3_block:
0232   0578             ; dest[dest_len + i] = src[i]; 
0233   0578 FA 05 00      lea d, [bp + 5] ; $dest
0234   057B FD 2A         mov d, [d]
0235   057D D7            push a
0236   057E DA            push d
0237   057F FA FF FF      lea d, [bp + -1] ; $dest_len
0238   0582 2A            mov b, [d]
0239   0583 38 00 00      mov c, 0
0240   0586             ; --- START TERMS
0241   0586 D7            push a
0242   0587 11            mov a, b
0243   0588 FA FD FF      lea d, [bp + -3] ; $i
0244   058B 2A            mov b, [d]
0245   058C 38 00 00      mov c, 0
0246   058F 56            add b, a
0247   0590 E4            pop a
0248   0591             ; --- END TERMS
0249   0591 E7            pop d
0250   0592 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0251   0596 E4            pop a
0252   0597 DA            push d
0253   0598 FA 07 00      lea d, [bp + 7] ; $src
0254   059B FD 2A         mov d, [d]
0255   059D D7            push a
0256   059E DA            push d
0257   059F FA FD FF      lea d, [bp + -3] ; $i
0258   05A2 2A            mov b, [d]
0259   05A3 38 00 00      mov c, 0
0260   05A6 E7            pop d
0261   05A7 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0262   05AB E4            pop a
0263   05AC 32            mov bl, [d]
0264   05AD A7 00         mov bh, 0
0265   05AF 38 00 00      mov c, 0
0266   05B2 E7            pop d
0267   05B3 FD 3E         mov [d], bl
0268   05B5             _for3_update:
0269   05B5 FA FD FF      lea d, [bp + -3] ; $i
0270   05B8 DA            push d
0271   05B9 FA FD FF      lea d, [bp + -3] ; $i
0272   05BC 2A            mov b, [d]
0273   05BD 38 00 00      mov c, 0
0274   05C0             ; --- START TERMS
0275   05C0 D7            push a
0276   05C1 11            mov a, b
0277   05C2 FD 2E 01 00   mov32 cb, $00000001
0277   05C6 00 00 
0278   05C8 56            add b, a
0279   05C9 E4            pop a
0280   05CA             ; --- END TERMS
0281   05CA E7            pop d
0282   05CB FD 43         mov [d], b
0283   05CD 0A 4C 05      jmp _for3_cond
0284   05D0             _for3_exit:
0285   05D0             ; dest[dest_len + i] = 0; 
0286   05D0 FA 05 00      lea d, [bp + 5] ; $dest
0287   05D3 FD 2A         mov d, [d]
0288   05D5 D7            push a
0289   05D6 DA            push d
0290   05D7 FA FF FF      lea d, [bp + -1] ; $dest_len
0291   05DA 2A            mov b, [d]
0292   05DB 38 00 00      mov c, 0
0293   05DE             ; --- START TERMS
0294   05DE D7            push a
0295   05DF 11            mov a, b
0296   05E0 FA FD FF      lea d, [bp + -3] ; $i
0297   05E3 2A            mov b, [d]
0298   05E4 38 00 00      mov c, 0
0299   05E7 56            add b, a
0300   05E8 E4            pop a
0301   05E9             ; --- END TERMS
0302   05E9 E7            pop d
0303   05EA FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0304   05EE E4            pop a
0305   05EF DA            push d
0306   05F0 FD 2E 00 00   mov32 cb, $00000000
0306   05F4 00 00 
0307   05F6 E7            pop d
0308   05F7 FD 3E         mov [d], bl
0309   05F9             ; return dest; 
0310   05F9 FA 05 00      lea d, [bp + 5] ; $dest
0311   05FC 2A            mov b, [d]
0312   05FD 38 00 00      mov c, 0
0313   0600 F9            leave
0314   0601 09            ret
0315   0602             
0316   0602             strlen:
0317   0602 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0318   0605             ; int length; 
0319   0605 52 02 00      sub sp, 2
0320   0608             ; length = 0; 
0321   0608 FA FF FF      lea d, [bp + -1] ; $length
0322   060B DA            push d
0323   060C FD 2E 00 00   mov32 cb, $00000000
0323   0610 00 00 
0324   0612 E7            pop d
0325   0613 FD 43         mov [d], b
0326   0615             ; while (str[length] != 0) { 
0327   0615             _while4_cond:
0328   0615 FA 05 00      lea d, [bp + 5] ; $str
0329   0618 FD 2A         mov d, [d]
0330   061A D7            push a
0331   061B DA            push d
0332   061C FA FF FF      lea d, [bp + -1] ; $length
0333   061F 2A            mov b, [d]
0334   0620 38 00 00      mov c, 0
0335   0623 E7            pop d
0336   0624 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0337   0628 E4            pop a
0338   0629 32            mov bl, [d]
0339   062A A7 00         mov bh, 0
0340   062C 38 00 00      mov c, 0
0341   062F             ; --- START RELATIONAL
0342   062F D7            push a
0343   0630 11            mov a, b
0344   0631 FD 2E 00 00   mov32 cb, $00000000
0344   0635 00 00 
0345   0637 B0            cmp a, b
0346   0638 FD 72         sneq ; !=
0347   063A E4            pop a
0348   063B             ; --- END RELATIONAL
0349   063B C0 00 00      cmp b, 0
0350   063E C6 54 06      je _while4_exit
0351   0641             _while4_block:
0352   0641             ; length++; 
0353   0641 FA FF FF      lea d, [bp + -1] ; $length
0354   0644 2A            mov b, [d]
0355   0645 38 00 00      mov c, 0
0356   0648 11            mov a, b
0357   0649 FD 77         inc b
0358   064B FA FF FF      lea d, [bp + -1] ; $length
0359   064E FD 43         mov [d], b
0360   0650 27            mov b, a
0361   0651 0A 15 06      jmp _while4_cond
0362   0654             _while4_exit:
0363   0654             ; return length; 
0364   0654 FA FF FF      lea d, [bp + -1] ; $length
0365   0657 2A            mov b, [d]
0366   0658 38 00 00      mov c, 0
0367   065B F9            leave
0368   065C 09            ret
0369   065D             
0370   065D             exit:
0371   065D F8 00 00      enter 0 ; (push bp; mov bp, sp)
0372   0660             
0373   0660             ; --- BEGIN INLINE ASM SEGMENT
0374   0660 05 0B         syscall sys_terminate_proc
0375   0662             ; --- END INLINE ASM SEGMENT
0376   0662             
0377   0662 F9            leave
0378   0663 09            ret
0379   0664             
0380   0664             memset:
0381   0664 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0382   0667             ; int i; 
0383   0667 52 02 00      sub sp, 2
0384   066A             ; for(i = 0; i < size; i++){ 
0385   066A             _for5_init:
0386   066A FA FF FF      lea d, [bp + -1] ; $i
0387   066D DA            push d
0388   066E FD 2E 00 00   mov32 cb, $00000000
0388   0672 00 00 
0389   0674 E7            pop d
0390   0675 FD 43         mov [d], b
0391   0677             _for5_cond:
0392   0677 FA FF FF      lea d, [bp + -1] ; $i
0393   067A 2A            mov b, [d]
0394   067B 38 00 00      mov c, 0
0395   067E             ; --- START RELATIONAL
0396   067E D7            push a
0397   067F 11            mov a, b
0398   0680 FA 08 00      lea d, [bp + 8] ; $size
0399   0683 2A            mov b, [d]
0400   0684 38 00 00      mov c, 0
0401   0687 B0            cmp a, b
0402   0688 FD 73         slt ; < (signed)
0403   068A E4            pop a
0404   068B             ; --- END RELATIONAL
0405   068B C0 00 00      cmp b, 0
0406   068E C6 C3 06      je _for5_exit
0407   0691             _for5_block:
0408   0691             ; *(s+i) = c; 
0409   0691 FA 05 00      lea d, [bp + 5] ; $s
0410   0694 2A            mov b, [d]
0411   0695 38 00 00      mov c, 0
0412   0698             ; --- START TERMS
0413   0698 D7            push a
0414   0699 11            mov a, b
0415   069A FA FF FF      lea d, [bp + -1] ; $i
0416   069D 2A            mov b, [d]
0417   069E 38 00 00      mov c, 0
0418   06A1 56            add b, a
0419   06A2 E4            pop a
0420   06A3             ; --- END TERMS
0421   06A3 D8            push b
0422   06A4 FA 07 00      lea d, [bp + 7] ; $c
0423   06A7 32            mov bl, [d]
0424   06A8 A7 00         mov bh, 0
0425   06AA 38 00 00      mov c, 0
0426   06AD E7            pop d
0427   06AE FD 3E         mov [d], bl
0428   06B0             _for5_update:
0429   06B0 FA FF FF      lea d, [bp + -1] ; $i
0430   06B3 2A            mov b, [d]
0431   06B4 38 00 00      mov c, 0
0432   06B7 11            mov a, b
0433   06B8 FD 77         inc b
0434   06BA FA FF FF      lea d, [bp + -1] ; $i
0435   06BD FD 43         mov [d], b
0436   06BF 27            mov b, a
0437   06C0 0A 77 06      jmp _for5_cond
0438   06C3             _for5_exit:
0439   06C3             ; return s; 
0440   06C3 FA 05 00      lea d, [bp + 5] ; $s
0441   06C6 2A            mov b, [d]
0442   06C7 38 00 00      mov c, 0
0443   06CA F9            leave
0444   06CB 09            ret
0445   06CC             
0446   06CC             atoi:
0447   06CC F8 00 00      enter 0 ; (push bp; mov bp, sp)
0448   06CF             ; int result = 0;  // Initialize result 
0449   06CF 52 02 00      sub sp, 2
0450   06D2             ; --- START LOCAL VAR INITIALIZATION
0451   06D2 FA FF FF      lea d, [bp + -1] ; $result
0452   06D5 DA            push d
0453   06D6 FD 2E 00 00   mov32 cb, $00000000
0453   06DA 00 00 
0454   06DC E7            pop d
0455   06DD FD 43         mov [d], b
0456   06DF             ; --- END LOCAL VAR INITIALIZATION
0457   06DF             ; int sign = 1;    // Initialize sign as positive 
0458   06DF 52 02 00      sub sp, 2
0459   06E2             ; --- START LOCAL VAR INITIALIZATION
0460   06E2 FA FD FF      lea d, [bp + -3] ; $sign
0461   06E5 DA            push d
0462   06E6 FD 2E 01 00   mov32 cb, $00000001
0462   06EA 00 00 
0463   06EC E7            pop d
0464   06ED FD 43         mov [d], b
0465   06EF             ; --- END LOCAL VAR INITIALIZATION
0466   06EF             ; while (*str == ' ') str++; 
0467   06EF             _while6_cond:
0468   06EF FA 05 00      lea d, [bp + 5] ; $str
0469   06F2 2A            mov b, [d]
0470   06F3 38 00 00      mov c, 0
0471   06F6 74            mov d, b
0472   06F7 32            mov bl, [d]
0473   06F8 A7 00         mov bh, 0
0474   06FA 38 00 00      mov c, 0
0475   06FD             ; --- START RELATIONAL
0476   06FD D7            push a
0477   06FE 11            mov a, b
0478   06FF FD 2E 20 00   mov32 cb, $00000020
0478   0703 00 00 
0479   0705 B0            cmp a, b
0480   0706 FD 71         seq ; ==
0481   0708 E4            pop a
0482   0709             ; --- END RELATIONAL
0483   0709 C0 00 00      cmp b, 0
0484   070C C6 22 07      je _while6_exit
0485   070F             _while6_block:
0486   070F             ; str++; 
0487   070F FA 05 00      lea d, [bp + 5] ; $str
0488   0712 2A            mov b, [d]
0489   0713 38 00 00      mov c, 0
0490   0716 FD 77         inc b
0491   0718 FA 05 00      lea d, [bp + 5] ; $str
0492   071B FD 3E         mov [d], bl
0493   071D FD 7D         dec b
0494   071F 0A EF 06      jmp _while6_cond
0495   0722             _while6_exit:
0496   0722             ; if (*str == '-' || *str == '+') { 
0497   0722             _if7_cond:
0498   0722 FA 05 00      lea d, [bp + 5] ; $str
0499   0725 2A            mov b, [d]
0500   0726 38 00 00      mov c, 0
0501   0729 74            mov d, b
0502   072A 32            mov bl, [d]
0503   072B A7 00         mov bh, 0
0504   072D 38 00 00      mov c, 0
0505   0730             ; --- START RELATIONAL
0506   0730 D7            push a
0507   0731 11            mov a, b
0508   0732 FD 2E 2D 00   mov32 cb, $0000002d
0508   0736 00 00 
0509   0738 B0            cmp a, b
0510   0739 FD 71         seq ; ==
0511   073B E4            pop a
0512   073C             ; --- END RELATIONAL
0513   073C             ; --- START LOGICAL OR
0514   073C D7            push a
0515   073D 11            mov a, b
0516   073E FA 05 00      lea d, [bp + 5] ; $str
0517   0741 2A            mov b, [d]
0518   0742 38 00 00      mov c, 0
0519   0745 74            mov d, b
0520   0746 32            mov bl, [d]
0521   0747 A7 00         mov bh, 0
0522   0749 38 00 00      mov c, 0
0523   074C             ; --- START RELATIONAL
0524   074C D7            push a
0525   074D 11            mov a, b
0526   074E FD 2E 2B 00   mov32 cb, $0000002b
0526   0752 00 00 
0527   0754 B0            cmp a, b
0528   0755 FD 71         seq ; ==
0529   0757 E4            pop a
0530   0758             ; --- END RELATIONAL
0531   0758 FD A8         sor a, b ; ||
0532   075A E4            pop a
0533   075B             ; --- END LOGICAL OR
0534   075B C0 00 00      cmp b, 0
0535   075E C6 A6 07      je _if7_exit
0536   0761             _if7_true:
0537   0761             ; if (*str == '-') sign = -1; 
0538   0761             _if8_cond:
0539   0761 FA 05 00      lea d, [bp + 5] ; $str
0540   0764 2A            mov b, [d]
0541   0765 38 00 00      mov c, 0
0542   0768 74            mov d, b
0543   0769 32            mov bl, [d]
0544   076A A7 00         mov bh, 0
0545   076C 38 00 00      mov c, 0
0546   076F             ; --- START RELATIONAL
0547   076F D7            push a
0548   0770 11            mov a, b
0549   0771 FD 2E 2D 00   mov32 cb, $0000002d
0549   0775 00 00 
0550   0777 B0            cmp a, b
0551   0778 FD 71         seq ; ==
0552   077A E4            pop a
0553   077B             ; --- END RELATIONAL
0554   077B C0 00 00      cmp b, 0
0555   077E C6 93 07      je _if8_exit
0556   0781             _if8_true:
0557   0781             ; sign = -1; 
0558   0781 FA FD FF      lea d, [bp + -3] ; $sign
0559   0784 DA            push d
0560   0785 FD 2E 01 00   mov32 cb, $00000001
0560   0789 00 00 
0561   078B FD 97         neg b
0562   078D E7            pop d
0563   078E FD 43         mov [d], b
0564   0790 0A 93 07      jmp _if8_exit
0565   0793             _if8_exit:
0566   0793             ; str++; 
0567   0793 FA 05 00      lea d, [bp + 5] ; $str
0568   0796 2A            mov b, [d]
0569   0797 38 00 00      mov c, 0
0570   079A FD 77         inc b
0571   079C FA 05 00      lea d, [bp + 5] ; $str
0572   079F FD 3E         mov [d], bl
0573   07A1 FD 7D         dec b
0574   07A3 0A A6 07      jmp _if7_exit
0575   07A6             _if7_exit:
0576   07A6             ; while (*str >= '0' && *str <= '9') { 
0577   07A6             _while9_cond:
0578   07A6 FA 05 00      lea d, [bp + 5] ; $str
0579   07A9 2A            mov b, [d]
0580   07AA 38 00 00      mov c, 0
0581   07AD 74            mov d, b
0582   07AE 32            mov bl, [d]
0583   07AF A7 00         mov bh, 0
0584   07B1 38 00 00      mov c, 0
0585   07B4             ; --- START RELATIONAL
0586   07B4 D7            push a
0587   07B5 11            mov a, b
0588   07B6 FD 2E 30 00   mov32 cb, $00000030
0588   07BA 00 00 
0589   07BC B0            cmp a, b
0590   07BD FD 82         sgeu ; >= (unsigned)
0591   07BF E4            pop a
0592   07C0             ; --- END RELATIONAL
0593   07C0             ; --- START LOGICAL AND
0594   07C0 D7            push a
0595   07C1 11            mov a, b
0596   07C2 FA 05 00      lea d, [bp + 5] ; $str
0597   07C5 2A            mov b, [d]
0598   07C6 38 00 00      mov c, 0
0599   07C9 74            mov d, b
0600   07CA 32            mov bl, [d]
0601   07CB A7 00         mov bh, 0
0602   07CD 38 00 00      mov c, 0
0603   07D0             ; --- START RELATIONAL
0604   07D0 D7            push a
0605   07D1 11            mov a, b
0606   07D2 FD 2E 39 00   mov32 cb, $00000039
0606   07D6 00 00 
0607   07D8 B0            cmp a, b
0608   07D9 FD 76         sleu ; <= (unsigned)
0609   07DB E4            pop a
0610   07DC             ; --- END RELATIONAL
0611   07DC FD A7         sand a, b
0612   07DE E4            pop a
0613   07DF             ; --- END LOGICAL AND
0614   07DF C0 00 00      cmp b, 0
0615   07E2 C6 2F 08      je _while9_exit
0616   07E5             _while9_block:
0617   07E5             ; result = result * 10 + (*str - '0'); 
0618   07E5 FA FF FF      lea d, [bp + -1] ; $result
0619   07E8 DA            push d
0620   07E9 FA FF FF      lea d, [bp + -1] ; $result
0621   07EC 2A            mov b, [d]
0622   07ED 38 00 00      mov c, 0
0623   07F0             ; --- START FACTORS
0624   07F0 D7            push a
0625   07F1 11            mov a, b
0626   07F2 FD 2E 0A 00   mov32 cb, $0000000a
0626   07F6 00 00 
0627   07F8 AC            mul a, b ; *
0628   07F9 11            mov a, b
0629   07FA 27            mov b, a
0630   07FB E4            pop a
0631   07FC             ; --- END FACTORS
0632   07FC             ; --- START TERMS
0633   07FC D7            push a
0634   07FD 11            mov a, b
0635   07FE FA 05 00      lea d, [bp + 5] ; $str
0636   0801 2A            mov b, [d]
0637   0802 38 00 00      mov c, 0
0638   0805 74            mov d, b
0639   0806 32            mov bl, [d]
0640   0807 A7 00         mov bh, 0
0641   0809 38 00 00      mov c, 0
0642   080C             ; --- START TERMS
0643   080C D7            push a
0644   080D 11            mov a, b
0645   080E FD 2E 30 00   mov32 cb, $00000030
0645   0812 00 00 
0646   0814 60            sub a, b
0647   0815 27            mov b, a
0648   0816 E4            pop a
0649   0817             ; --- END TERMS
0650   0817 56            add b, a
0651   0818 E4            pop a
0652   0819             ; --- END TERMS
0653   0819 E7            pop d
0654   081A FD 43         mov [d], b
0655   081C             ; str++; 
0656   081C FA 05 00      lea d, [bp + 5] ; $str
0657   081F 2A            mov b, [d]
0658   0820 38 00 00      mov c, 0
0659   0823 FD 77         inc b
0660   0825 FA 05 00      lea d, [bp + 5] ; $str
0661   0828 FD 3E         mov [d], bl
0662   082A FD 7D         dec b
0663   082C 0A A6 07      jmp _while9_cond
0664   082F             _while9_exit:
0665   082F             ; return sign * result; 
0666   082F FA FD FF      lea d, [bp + -3] ; $sign
0667   0832 2A            mov b, [d]
0668   0833 38 00 00      mov c, 0
0669   0836             ; --- START FACTORS
0670   0836 D7            push a
0671   0837 11            mov a, b
0672   0838 FA FF FF      lea d, [bp + -1] ; $result
0673   083B 2A            mov b, [d]
0674   083C 38 00 00      mov c, 0
0675   083F AC            mul a, b ; *
0676   0840 11            mov a, b
0677   0841 27            mov b, a
0678   0842 E4            pop a
0679   0843             ; --- END FACTORS
0680   0843 F9            leave
0681   0844 09            ret
0682   0845             
0683   0845             rand:
0684   0845 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0685   0848             ; int  sec; 
0686   0848 52 02 00      sub sp, 2
0687   084B             
0688   084B             ; --- BEGIN INLINE ASM SEGMENT
0689   084B 19 00         mov al, 0
0690   084D 05 01         syscall sys_rtc					
0691   084F 1A            mov al, ah
0692   0850 FA FF FF      lea d, [bp + -1] ; $sec
0693   0853 1E            mov al, [d]
0694   0854 22 00         mov ah, 0
0695   0856             ; --- END INLINE ASM SEGMENT
0696   0856             
0697   0856             ; return sec; 
0698   0856 FA FF FF      lea d, [bp + -1] ; $sec
0699   0859 2A            mov b, [d]
0700   085A 38 00 00      mov c, 0
0701   085D F9            leave
0702   085E 09            ret
0703   085F             
0704   085F             alloc:
0705   085F F8 00 00      enter 0 ; (push bp; mov bp, sp)
0706   0862             ; heap_top = heap_top + bytes; 
0707   0862 3B 99 21      mov d, _heap_top ; $heap_top
0708   0865 DA            push d
0709   0866 3B 99 21      mov d, _heap_top ; $heap_top
0710   0869 2A            mov b, [d]
0711   086A 38 00 00      mov c, 0
0712   086D             ; --- START TERMS
0713   086D D7            push a
0714   086E 11            mov a, b
0715   086F FA 05 00      lea d, [bp + 5] ; $bytes
0716   0872 2A            mov b, [d]
0717   0873 38 00 00      mov c, 0
0718   0876 56            add b, a
0719   0877 E4            pop a
0720   0878             ; --- END TERMS
0721   0878 E7            pop d
0722   0879 FD 43         mov [d], b
0723   087B             ; return heap_top - bytes; 
0724   087B 3B 99 21      mov d, _heap_top ; $heap_top
0725   087E 2A            mov b, [d]
0726   087F 38 00 00      mov c, 0
0727   0882             ; --- START TERMS
0728   0882 D7            push a
0729   0883 11            mov a, b
0730   0884 FA 05 00      lea d, [bp + 5] ; $bytes
0731   0887 2A            mov b, [d]
0732   0888 38 00 00      mov c, 0
0733   088B 60            sub a, b
0734   088C 27            mov b, a
0735   088D E4            pop a
0736   088E             ; --- END TERMS
0737   088E F9            leave
0738   088F 09            ret
0739   0890             
0740   0890             free:
0741   0890 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0742   0893             ; return heap_top = heap_top - bytes; 
0743   0893 3B 99 21      mov d, _heap_top ; $heap_top
0744   0896 DA            push d
0745   0897 3B 99 21      mov d, _heap_top ; $heap_top
0746   089A 2A            mov b, [d]
0747   089B 38 00 00      mov c, 0
0748   089E             ; --- START TERMS
0749   089E D7            push a
0750   089F 11            mov a, b
0751   08A0 FA 05 00      lea d, [bp + 5] ; $bytes
0752   08A3 2A            mov b, [d]
0753   08A4 38 00 00      mov c, 0
0754   08A7 60            sub a, b
0755   08A8 27            mov b, a
0756   08A9 E4            pop a
0757   08AA             ; --- END TERMS
0758   08AA E7            pop d
0759   08AB FD 43         mov [d], b
0760   08AD F9            leave
0761   08AE 09            ret
0762   08AF             
0763   08AF             fopen:
0764   08AF F8 00 00      enter 0 ; (push bp; mov bp, sp)
0765   08B2             ; FILE *fp; 
0766   08B2 52 02 00      sub sp, 2
0767   08B5             ; static int max_handle = 0; 
0768   08B5 52 02 00      sub sp, 2
0769   08B8             ; fp = alloc(sizeof(FILE)); 
0770   08B8 FA FF FF      lea d, [bp + -1] ; $fp
0771   08BB DA            push d
0772   08BC             ; --- START FUNCTION CALL
0773   08BC 26 04 01      mov b, 260
0774   08BF FD AB         swp b
0775   08C1 D8            push b
0776   08C2 07 5F 08      call alloc
0777   08C5 51 02 00      add sp, 2
0778   08C8             ; --- END FUNCTION CALL
0779   08C8 E7            pop d
0780   08C9 FD 43         mov [d], b
0781   08CB             ; strcpy(fp->filename, filename); 
0782   08CB             ; --- START FUNCTION CALL
0783   08CB FA 05 00      lea d, [bp + 5] ; $filename
0784   08CE 2A            mov b, [d]
0785   08CF 38 00 00      mov c, 0
0786   08D2 FD AB         swp b
0787   08D4 D8            push b
0788   08D5 FA FF FF      lea d, [bp + -1] ; $fp
0789   08D8 FD 2A         mov d, [d]
0790   08DA 58 02 00      add d, 2
0791   08DD 2D            mov b, d
0792   08DE 38 00 00      mov c, 0
0793   08E1 FD AB         swp b
0794   08E3 D8            push b
0795   08E4 07 1C 04      call strcpy
0796   08E7 51 04 00      add sp, 4
0797   08EA             ; --- END FUNCTION CALL
0798   08EA             ; fp->handle = max_handle; 
0799   08EA FA FF FF      lea d, [bp + -1] ; $fp
0800   08ED FD 2A         mov d, [d]
0801   08EF 58 00 00      add d, 0
0802   08F2 DA            push d
0803   08F3 3B 53 21      mov d, st_fopen_max_handle ; static max_handle
0804   08F6 2A            mov b, [d]
0805   08F7 38 00 00      mov c, 0
0806   08FA E7            pop d
0807   08FB FD 43         mov [d], b
0808   08FD             ; fp->mode = mode; 
0809   08FD FA FF FF      lea d, [bp + -1] ; $fp
0810   0900 FD 2A         mov d, [d]
0811   0902 58 02 01      add d, 258
0812   0905 DA            push d
0813   0906 FA 07 00      lea d, [bp + 7] ; $mode
0814   0909 32            mov bl, [d]
0815   090A A7 00         mov bh, 0
0816   090C 38 00 00      mov c, 0
0817   090F E7            pop d
0818   0910 FD 3E         mov [d], bl
0819   0912             ; fp->loc = 0; 
0820   0912 FA FF FF      lea d, [bp + -1] ; $fp
0821   0915 FD 2A         mov d, [d]
0822   0917 58 03 01      add d, 259
0823   091A DA            push d
0824   091B FD 2E 00 00   mov32 cb, $00000000
0824   091F 00 00 
0825   0921 E7            pop d
0826   0922 FD 3E         mov [d], bl
0827   0924             ; max_handle++; 
0828   0924 3B 53 21      mov d, st_fopen_max_handle ; static max_handle
0829   0927 2A            mov b, [d]
0830   0928 38 00 00      mov c, 0
0831   092B 11            mov a, b
0832   092C FD 77         inc b
0833   092E 3B 53 21      mov d, st_fopen_max_handle ; static max_handle
0834   0931 FD 43         mov [d], b
0835   0933 27            mov b, a
0836   0934 F9            leave
0837   0935 09            ret
0838   0936             
0839   0936             fclose:
0840   0936 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0841   0939             ; free(sizeof(FILE)); 
0842   0939             ; --- START FUNCTION CALL
0843   0939 26 04 01      mov b, 260
0844   093C FD AB         swp b
0845   093E D8            push b
0846   093F 07 90 08      call free
0847   0942 51 02 00      add sp, 2
0848   0945             ; --- END FUNCTION CALL
0849   0945 F9            leave
0850   0946 09            ret
0851   0947             
0852   0947             printf:
0853   0947 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0854   094A             ; char *p, *format_p; 
0855   094A 52 02 00      sub sp, 2
0856   094D 52 02 00      sub sp, 2
0857   0950             ; format_p = format; 
0858   0950 FA FD FF      lea d, [bp + -3] ; $format_p
0859   0953 DA            push d
0860   0954 FA 05 00      lea d, [bp + 5] ; $format
0861   0957 2A            mov b, [d]
0862   0958 38 00 00      mov c, 0
0863   095B E7            pop d
0864   095C FD 43         mov [d], b
0865   095E             ; p = &format + 2; 
0866   095E FA FF FF      lea d, [bp + -1] ; $p
0867   0961 DA            push d
0868   0962 FA 05 00      lea d, [bp + 5] ; $format
0869   0965 2D            mov b, d
0870   0966             ; --- START TERMS
0871   0966 D7            push a
0872   0967 11            mov a, b
0873   0968 FD 2E 02 00   mov32 cb, $00000002
0873   096C 00 00 
0874   096E 56            add b, a
0875   096F E4            pop a
0876   0970             ; --- END TERMS
0877   0970 E7            pop d
0878   0971 FD 43         mov [d], b
0879   0973             ; for(;;){ 
0880   0973             _for10_init:
0881   0973             _for10_cond:
0882   0973             _for10_block:
0883   0973             ; if(!*format_p) break; 
0884   0973             _if11_cond:
0885   0973 FA FD FF      lea d, [bp + -3] ; $format_p
0886   0976 2A            mov b, [d]
0887   0977 38 00 00      mov c, 0
0888   097A 74            mov d, b
0889   097B 32            mov bl, [d]
0890   097C A7 00         mov bh, 0
0891   097E 38 00 00      mov c, 0
0892   0981 C0 00 00      cmp b, 0
0893   0984 FD 71         seq ; !
0894   0986 C0 00 00      cmp b, 0
0895   0989 C6 92 09      je _if11_else
0896   098C             _if11_true:
0897   098C             ; break; 
0898   098C 0A 23 0C      jmp _for10_exit ; for break
0899   098F 0A 20 0C      jmp _if11_exit
0900   0992             _if11_else:
0901   0992             ; if(*format_p == '%'){ 
0902   0992             _if12_cond:
0903   0992 FA FD FF      lea d, [bp + -3] ; $format_p
0904   0995 2A            mov b, [d]
0905   0996 38 00 00      mov c, 0
0906   0999 74            mov d, b
0907   099A 32            mov bl, [d]
0908   099B A7 00         mov bh, 0
0909   099D 38 00 00      mov c, 0
0910   09A0             ; --- START RELATIONAL
0911   09A0 D7            push a
0912   09A1 11            mov a, b
0913   09A2 FD 2E 25 00   mov32 cb, $00000025
0913   09A6 00 00 
0914   09A8 B0            cmp a, b
0915   09A9 FD 71         seq ; ==
0916   09AB E4            pop a
0917   09AC             ; --- END RELATIONAL
0918   09AC C0 00 00      cmp b, 0
0919   09AF C6 FB 0B      je _if12_else
0920   09B2             _if12_true:
0921   09B2             ; format_p++; 
0922   09B2 FA FD FF      lea d, [bp + -3] ; $format_p
0923   09B5 2A            mov b, [d]
0924   09B6 38 00 00      mov c, 0
0925   09B9 FD 77         inc b
0926   09BB FA FD FF      lea d, [bp + -3] ; $format_p
0927   09BE FD 3E         mov [d], bl
0928   09C0 FD 7D         dec b
0929   09C2             ; switch(*format_p){ 
0930   09C2             _switch13_expr:
0931   09C2 FA FD FF      lea d, [bp + -3] ; $format_p
0932   09C5 2A            mov b, [d]
0933   09C6 38 00 00      mov c, 0
0934   09C9 74            mov d, b
0935   09CA 32            mov bl, [d]
0936   09CB A7 00         mov bh, 0
0937   09CD 38 00 00      mov c, 0
0938   09D0             _switch13_comparisons:
0939   09D0 C1 6C         cmp bl, $6c
0940   09D2 C6 FE 09      je _switch13_case0
0941   09D5 C1 4C         cmp bl, $4c
0942   09D7 C6 FE 09      je _switch13_case1
0943   09DA C1 64         cmp bl, $64
0944   09DC C6 0E 0B      je _switch13_case2
0945   09DF C1 69         cmp bl, $69
0946   09E1 C6 0E 0B      je _switch13_case3
0947   09E4 C1 75         cmp bl, $75
0948   09E6 C6 3E 0B      je _switch13_case4
0949   09E9 C1 78         cmp bl, $78
0950   09EB C6 6E 0B      je _switch13_case5
0951   09EE C1 63         cmp bl, $63
0952   09F0 C6 92 0B      je _switch13_case6
0953   09F3 C1 73         cmp bl, $73
0954   09F5 C6 B7 0B      je _switch13_case7
0955   09F8 0A DC 0B      jmp _switch13_default
0956   09FB 0A E8 0B      jmp _switch13_exit
0957   09FE             _switch13_case0:
0958   09FE             _switch13_case1:
0959   09FE             ; format_p++; 
0960   09FE FA FD FF      lea d, [bp + -3] ; $format_p
0961   0A01 2A            mov b, [d]
0962   0A02 38 00 00      mov c, 0
0963   0A05 FD 77         inc b
0964   0A07 FA FD FF      lea d, [bp + -3] ; $format_p
0965   0A0A FD 3E         mov [d], bl
0966   0A0C FD 7D         dec b
0967   0A0E             ; if(*format_p == 'd' || *format_p == 'i') 
0968   0A0E             _if14_cond:
0969   0A0E FA FD FF      lea d, [bp + -3] ; $format_p
0970   0A11 2A            mov b, [d]
0971   0A12 38 00 00      mov c, 0
0972   0A15 74            mov d, b
0973   0A16 32            mov bl, [d]
0974   0A17 A7 00         mov bh, 0
0975   0A19 38 00 00      mov c, 0
0976   0A1C             ; --- START RELATIONAL
0977   0A1C D7            push a
0978   0A1D 11            mov a, b
0979   0A1E FD 2E 64 00   mov32 cb, $00000064
0979   0A22 00 00 
0980   0A24 B0            cmp a, b
0981   0A25 FD 71         seq ; ==
0982   0A27 E4            pop a
0983   0A28             ; --- END RELATIONAL
0984   0A28             ; --- START LOGICAL OR
0985   0A28 D7            push a
0986   0A29 11            mov a, b
0987   0A2A FA FD FF      lea d, [bp + -3] ; $format_p
0988   0A2D 2A            mov b, [d]
0989   0A2E 38 00 00      mov c, 0
0990   0A31 74            mov d, b
0991   0A32 32            mov bl, [d]
0992   0A33 A7 00         mov bh, 0
0993   0A35 38 00 00      mov c, 0
0994   0A38             ; --- START RELATIONAL
0995   0A38 D7            push a
0996   0A39 11            mov a, b
0997   0A3A FD 2E 69 00   mov32 cb, $00000069
0997   0A3E 00 00 
0998   0A40 B0            cmp a, b
0999   0A41 FD 71         seq ; ==
1000   0A43 E4            pop a
1001   0A44             ; --- END RELATIONAL
1002   0A44 FD A8         sor a, b ; ||
1003   0A46 E4            pop a
1004   0A47             ; --- END LOGICAL OR
1005   0A47 C0 00 00      cmp b, 0
1006   0A4A C6 6B 0A      je _if14_else
1007   0A4D             _if14_true:
1008   0A4D             ; print_signed_long(*(long *)p); 
1009   0A4D             ; --- START FUNCTION CALL
1010   0A4D FA FF FF      lea d, [bp + -1] ; $p
1011   0A50 2A            mov b, [d]
1012   0A51 38 00 00      mov c, 0
1013   0A54 74            mov d, b
1014   0A55 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1015   0A58 FD 39         mov c, b ; And place it into C
1016   0A5A 2A            mov b, [d] ; Lower Word in B
1017   0A5B 12            mov a, c
1018   0A5C FD AA         swp a
1019   0A5E D7            push a
1020   0A5F FD AB         swp b
1021   0A61 D8            push b
1022   0A62 07 F5 15      call print_signed_long
1023   0A65 51 04 00      add sp, 4
1024   0A68             ; --- END FUNCTION CALL
1025   0A68 0A F3 0A      jmp _if14_exit
1026   0A6B             _if14_else:
1027   0A6B             ; if(*format_p == 'u') 
1028   0A6B             _if15_cond:
1029   0A6B FA FD FF      lea d, [bp + -3] ; $format_p
1030   0A6E 2A            mov b, [d]
1031   0A6F 38 00 00      mov c, 0
1032   0A72 74            mov d, b
1033   0A73 32            mov bl, [d]
1034   0A74 A7 00         mov bh, 0
1035   0A76 38 00 00      mov c, 0
1036   0A79             ; --- START RELATIONAL
1037   0A79 D7            push a
1038   0A7A 11            mov a, b
1039   0A7B FD 2E 75 00   mov32 cb, $00000075
1039   0A7F 00 00 
1040   0A81 B0            cmp a, b
1041   0A82 FD 71         seq ; ==
1042   0A84 E4            pop a
1043   0A85             ; --- END RELATIONAL
1044   0A85 C0 00 00      cmp b, 0
1045   0A88 C6 A9 0A      je _if15_else
1046   0A8B             _if15_true:
1047   0A8B             ; print_unsigned_long(*(unsigned long *)p); 
1048   0A8B             ; --- START FUNCTION CALL
1049   0A8B FA FF FF      lea d, [bp + -1] ; $p
1050   0A8E 2A            mov b, [d]
1051   0A8F 38 00 00      mov c, 0
1052   0A92 74            mov d, b
1053   0A93 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1054   0A96 FD 39         mov c, b ; And place it into C
1055   0A98 2A            mov b, [d] ; Lower Word in B
1056   0A99 12            mov a, c
1057   0A9A FD AA         swp a
1058   0A9C D7            push a
1059   0A9D FD AB         swp b
1060   0A9F D8            push b
1061   0AA0 07 64 17      call print_unsigned_long
1062   0AA3 51 04 00      add sp, 4
1063   0AA6             ; --- END FUNCTION CALL
1064   0AA6 0A F3 0A      jmp _if15_exit
1065   0AA9             _if15_else:
1066   0AA9             ; if(*format_p == 'x') 
1067   0AA9             _if16_cond:
1068   0AA9 FA FD FF      lea d, [bp + -3] ; $format_p
1069   0AAC 2A            mov b, [d]
1070   0AAD 38 00 00      mov c, 0
1071   0AB0 74            mov d, b
1072   0AB1 32            mov bl, [d]
1073   0AB2 A7 00         mov bh, 0
1074   0AB4 38 00 00      mov c, 0
1075   0AB7             ; --- START RELATIONAL
1076   0AB7 D7            push a
1077   0AB8 11            mov a, b
1078   0AB9 FD 2E 78 00   mov32 cb, $00000078
1078   0ABD 00 00 
1079   0ABF B0            cmp a, b
1080   0AC0 FD 71         seq ; ==
1081   0AC2 E4            pop a
1082   0AC3             ; --- END RELATIONAL
1083   0AC3 C0 00 00      cmp b, 0
1084   0AC6 C6 E7 0A      je _if16_else
1085   0AC9             _if16_true:
1086   0AC9             ; printx32(*(long int *)p); 
1087   0AC9             ; --- START FUNCTION CALL
1088   0AC9 FA FF FF      lea d, [bp + -1] ; $p
1089   0ACC 2A            mov b, [d]
1090   0ACD 38 00 00      mov c, 0
1091   0AD0 74            mov d, b
1092   0AD1 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1093   0AD4 FD 39         mov c, b ; And place it into C
1094   0AD6 2A            mov b, [d] ; Lower Word in B
1095   0AD7 12            mov a, c
1096   0AD8 FD AA         swp a
1097   0ADA D7            push a
1098   0ADB FD AB         swp b
1099   0ADD D8            push b
1100   0ADE 07 C8 12      call printx32
1101   0AE1 51 04 00      add sp, 4
1102   0AE4             ; --- END FUNCTION CALL
1103   0AE4 0A F3 0A      jmp _if16_exit
1104   0AE7             _if16_else:
1105   0AE7             ; err("Unexpected format in printf."); 
1106   0AE7             ; --- START FUNCTION CALL
1107   0AE7 26 55 21      mov b, _s0 ; "Unexpected format in printf."
1108   0AEA FD AB         swp b
1109   0AEC D8            push b
1110   0AED 07 B3 12      call err
1111   0AF0 51 02 00      add sp, 2
1112   0AF3             ; --- END FUNCTION CALL
1113   0AF3             _if16_exit:
1114   0AF3             _if15_exit:
1115   0AF3             _if14_exit:
1116   0AF3             ; p = p + 4; 
1117   0AF3 FA FF FF      lea d, [bp + -1] ; $p
1118   0AF6 DA            push d
1119   0AF7 FA FF FF      lea d, [bp + -1] ; $p
1120   0AFA 2A            mov b, [d]
1121   0AFB 38 00 00      mov c, 0
1122   0AFE             ; --- START TERMS
1123   0AFE D7            push a
1124   0AFF 11            mov a, b
1125   0B00 FD 2E 04 00   mov32 cb, $00000004
1125   0B04 00 00 
1126   0B06 56            add b, a
1127   0B07 E4            pop a
1128   0B08             ; --- END TERMS
1129   0B08 E7            pop d
1130   0B09 FD 43         mov [d], b
1131   0B0B             ; break; 
1132   0B0B 0A E8 0B      jmp _switch13_exit ; case break
1133   0B0E             _switch13_case2:
1134   0B0E             _switch13_case3:
1135   0B0E             ; print_signed(*(int*)p); 
1136   0B0E             ; --- START FUNCTION CALL
1137   0B0E FA FF FF      lea d, [bp + -1] ; $p
1138   0B11 2A            mov b, [d]
1139   0B12 38 00 00      mov c, 0
1140   0B15 74            mov d, b
1141   0B16 2A            mov b, [d]
1142   0B17 38 00 00      mov c, 0
1143   0B1A FD AB         swp b
1144   0B1C D8            push b
1145   0B1D 07 BC 14      call print_signed
1146   0B20 51 02 00      add sp, 2
1147   0B23             ; --- END FUNCTION CALL
1148   0B23             ; p = p + 2; 
1149   0B23 FA FF FF      lea d, [bp + -1] ; $p
1150   0B26 DA            push d
1151   0B27 FA FF FF      lea d, [bp + -1] ; $p
1152   0B2A 2A            mov b, [d]
1153   0B2B 38 00 00      mov c, 0
1154   0B2E             ; --- START TERMS
1155   0B2E D7            push a
1156   0B2F 11            mov a, b
1157   0B30 FD 2E 02 00   mov32 cb, $00000002
1157   0B34 00 00 
1158   0B36 56            add b, a
1159   0B37 E4            pop a
1160   0B38             ; --- END TERMS
1161   0B38 E7            pop d
1162   0B39 FD 43         mov [d], b
1163   0B3B             ; break; 
1164   0B3B 0A E8 0B      jmp _switch13_exit ; case break
1165   0B3E             _switch13_case4:
1166   0B3E             ; print_unsigned(*(unsigned int*)p); 
1167   0B3E             ; --- START FUNCTION CALL
1168   0B3E FA FF FF      lea d, [bp + -1] ; $p
1169   0B41 2A            mov b, [d]
1170   0B42 38 00 00      mov c, 0
1171   0B45 74            mov d, b
1172   0B46 2A            mov b, [d]
1173   0B47 38 00 00      mov c, 0
1174   0B4A FD AB         swp b
1175   0B4C D8            push b
1176   0B4D 07 D8 19      call print_unsigned
1177   0B50 51 02 00      add sp, 2
1178   0B53             ; --- END FUNCTION CALL
1179   0B53             ; p = p + 2; 
1180   0B53 FA FF FF      lea d, [bp + -1] ; $p
1181   0B56 DA            push d
1182   0B57 FA FF FF      lea d, [bp + -1] ; $p
1183   0B5A 2A            mov b, [d]
1184   0B5B 38 00 00      mov c, 0
1185   0B5E             ; --- START TERMS
1186   0B5E D7            push a
1187   0B5F 11            mov a, b
1188   0B60 FD 2E 02 00   mov32 cb, $00000002
1188   0B64 00 00 
1189   0B66 56            add b, a
1190   0B67 E4            pop a
1191   0B68             ; --- END TERMS
1192   0B68 E7            pop d
1193   0B69 FD 43         mov [d], b
1194   0B6B             ; break; 
1195   0B6B 0A E8 0B      jmp _switch13_exit ; case break
1196   0B6E             _switch13_case5:
1197   0B6E             
1198   0B6E             ; --- BEGIN INLINE ASM SEGMENT
1199   0B6E FA FF FF      lea d, [bp + -1] ; $p
1200   0B71 FD 2A         mov d, [d]
1201   0B73 2A            mov b, [d]
1202   0B74 07 51 20      call print_u16x
1203   0B77             ; --- END INLINE ASM SEGMENT
1204   0B77             
1205   0B77             ; p = p + 2; 
1206   0B77 FA FF FF      lea d, [bp + -1] ; $p
1207   0B7A DA            push d
1208   0B7B FA FF FF      lea d, [bp + -1] ; $p
1209   0B7E 2A            mov b, [d]
1210   0B7F 38 00 00      mov c, 0
1211   0B82             ; --- START TERMS
1212   0B82 D7            push a
1213   0B83 11            mov a, b
1214   0B84 FD 2E 02 00   mov32 cb, $00000002
1214   0B88 00 00 
1215   0B8A 56            add b, a
1216   0B8B E4            pop a
1217   0B8C             ; --- END TERMS
1218   0B8C E7            pop d
1219   0B8D FD 43         mov [d], b
1220   0B8F             ; break; 
1221   0B8F 0A E8 0B      jmp _switch13_exit ; case break
1222   0B92             _switch13_case6:
1223   0B92             
1224   0B92             ; --- BEGIN INLINE ASM SEGMENT
1225   0B92 FA FF FF      lea d, [bp + -1] ; $p
1226   0B95 FD 2A         mov d, [d]
1227   0B97 1E            mov al, [d]
1228   0B98 23            mov ah, al
1229   0B99 07 AF 1E      call _putchar
1230   0B9C             ; --- END INLINE ASM SEGMENT
1231   0B9C             
1232   0B9C             ; p = p + 1; 
1233   0B9C FA FF FF      lea d, [bp + -1] ; $p
1234   0B9F DA            push d
1235   0BA0 FA FF FF      lea d, [bp + -1] ; $p
1236   0BA3 2A            mov b, [d]
1237   0BA4 38 00 00      mov c, 0
1238   0BA7             ; --- START TERMS
1239   0BA7 D7            push a
1240   0BA8 11            mov a, b
1241   0BA9 FD 2E 01 00   mov32 cb, $00000001
1241   0BAD 00 00 
1242   0BAF 56            add b, a
1243   0BB0 E4            pop a
1244   0BB1             ; --- END TERMS
1245   0BB1 E7            pop d
1246   0BB2 FD 43         mov [d], b
1247   0BB4             ; break; 
1248   0BB4 0A E8 0B      jmp _switch13_exit ; case break
1249   0BB7             _switch13_case7:
1250   0BB7             
1251   0BB7             ; --- BEGIN INLINE ASM SEGMENT
1252   0BB7 FA FF FF      lea d, [bp + -1] ; $p
1253   0BBA FD 2A         mov d, [d]
1254   0BBC FD 2A         mov d, [d]
1255   0BBE 07 F9 1F      call _puts
1256   0BC1             ; --- END INLINE ASM SEGMENT
1257   0BC1             
1258   0BC1             ; p = p + 2; 
1259   0BC1 FA FF FF      lea d, [bp + -1] ; $p
1260   0BC4 DA            push d
1261   0BC5 FA FF FF      lea d, [bp + -1] ; $p
1262   0BC8 2A            mov b, [d]
1263   0BC9 38 00 00      mov c, 0
1264   0BCC             ; --- START TERMS
1265   0BCC D7            push a
1266   0BCD 11            mov a, b
1267   0BCE FD 2E 02 00   mov32 cb, $00000002
1267   0BD2 00 00 
1268   0BD4 56            add b, a
1269   0BD5 E4            pop a
1270   0BD6             ; --- END TERMS
1271   0BD6 E7            pop d
1272   0BD7 FD 43         mov [d], b
1273   0BD9             ; break; 
1274   0BD9 0A E8 0B      jmp _switch13_exit ; case break
1275   0BDC             _switch13_default:
1276   0BDC             ; print("Error: Unknown argument type.\n"); 
1277   0BDC             ; --- START FUNCTION CALL
1278   0BDC 26 72 21      mov b, _s1 ; "Error: Unknown argument type.\n"
1279   0BDF FD AB         swp b
1280   0BE1 D8            push b
1281   0BE2 07 EE 1C      call print
1282   0BE5 51 02 00      add sp, 2
1283   0BE8             ; --- END FUNCTION CALL
1284   0BE8             _switch13_exit:
1285   0BE8             ; format_p++; 
1286   0BE8 FA FD FF      lea d, [bp + -3] ; $format_p
1287   0BEB 2A            mov b, [d]
1288   0BEC 38 00 00      mov c, 0
1289   0BEF FD 77         inc b
1290   0BF1 FA FD FF      lea d, [bp + -3] ; $format_p
1291   0BF4 FD 3E         mov [d], bl
1292   0BF6 FD 7D         dec b
1293   0BF8 0A 20 0C      jmp _if12_exit
1294   0BFB             _if12_else:
1295   0BFB             ; putchar(*format_p); 
1296   0BFB             ; --- START FUNCTION CALL
1297   0BFB FA FD FF      lea d, [bp + -3] ; $format_p
1298   0BFE 2A            mov b, [d]
1299   0BFF 38 00 00      mov c, 0
1300   0C02 74            mov d, b
1301   0C03 32            mov bl, [d]
1302   0C04 A7 00         mov bh, 0
1303   0C06 38 00 00      mov c, 0
1304   0C09 DD            push bl
1305   0C0A 07 A0 1C      call putchar
1306   0C0D 51 01 00      add sp, 1
1307   0C10             ; --- END FUNCTION CALL
1308   0C10             ; format_p++; 
1309   0C10 FA FD FF      lea d, [bp + -3] ; $format_p
1310   0C13 2A            mov b, [d]
1311   0C14 38 00 00      mov c, 0
1312   0C17 FD 77         inc b
1313   0C19 FA FD FF      lea d, [bp + -3] ; $format_p
1314   0C1C FD 3E         mov [d], bl
1315   0C1E FD 7D         dec b
1316   0C20             _if12_exit:
1317   0C20             _if11_exit:
1318   0C20             _for10_update:
1319   0C20 0A 73 09      jmp _for10_cond
1320   0C23             _for10_exit:
1321   0C23 F9            leave
1322   0C24 09            ret
1323   0C25             
1324   0C25             scanf:
1325   0C25 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1326   0C28             ; char *p, *format_p; 
1327   0C28 52 02 00      sub sp, 2
1328   0C2B 52 02 00      sub sp, 2
1329   0C2E             ; char c; 
1330   0C2E 52 01 00      sub sp, 1
1331   0C31             ; int i; 
1332   0C31 52 02 00      sub sp, 2
1333   0C34             ; char input_string[  512                    ]; 
1334   0C34 52 00 02      sub sp, 512
1335   0C37             ; format_p = format; 
1336   0C37 FA FD FF      lea d, [bp + -3] ; $format_p
1337   0C3A DA            push d
1338   0C3B FA 05 00      lea d, [bp + 5] ; $format
1339   0C3E 2A            mov b, [d]
1340   0C3F 38 00 00      mov c, 0
1341   0C42 E7            pop d
1342   0C43 FD 43         mov [d], b
1343   0C45             ; p = &format + 2; 
1344   0C45 FA FF FF      lea d, [bp + -1] ; $p
1345   0C48 DA            push d
1346   0C49 FA 05 00      lea d, [bp + 5] ; $format
1347   0C4C 2D            mov b, d
1348   0C4D             ; --- START TERMS
1349   0C4D D7            push a
1350   0C4E 11            mov a, b
1351   0C4F FD 2E 02 00   mov32 cb, $00000002
1351   0C53 00 00 
1352   0C55 56            add b, a
1353   0C56 E4            pop a
1354   0C57             ; --- END TERMS
1355   0C57 E7            pop d
1356   0C58 FD 43         mov [d], b
1357   0C5A             ; for(;;){ 
1358   0C5A             _for17_init:
1359   0C5A             _for17_cond:
1360   0C5A             _for17_block:
1361   0C5A             ; if(!*format_p) break; 
1362   0C5A             _if18_cond:
1363   0C5A FA FD FF      lea d, [bp + -3] ; $format_p
1364   0C5D 2A            mov b, [d]
1365   0C5E 38 00 00      mov c, 0
1366   0C61 74            mov d, b
1367   0C62 32            mov bl, [d]
1368   0C63 A7 00         mov bh, 0
1369   0C65 38 00 00      mov c, 0
1370   0C68 C0 00 00      cmp b, 0
1371   0C6B FD 71         seq ; !
1372   0C6D C0 00 00      cmp b, 0
1373   0C70 C6 79 0C      je _if18_else
1374   0C73             _if18_true:
1375   0C73             ; break; 
1376   0C73 0A 01 0F      jmp _for17_exit ; for break
1377   0C76 0A FE 0E      jmp _if18_exit
1378   0C79             _if18_else:
1379   0C79             ; if(*format_p == '%'){ 
1380   0C79             _if19_cond:
1381   0C79 FA FD FF      lea d, [bp + -3] ; $format_p
1382   0C7C 2A            mov b, [d]
1383   0C7D 38 00 00      mov c, 0
1384   0C80 74            mov d, b
1385   0C81 32            mov bl, [d]
1386   0C82 A7 00         mov bh, 0
1387   0C84 38 00 00      mov c, 0
1388   0C87             ; --- START RELATIONAL
1389   0C87 D7            push a
1390   0C88 11            mov a, b
1391   0C89 FD 2E 25 00   mov32 cb, $00000025
1391   0C8D 00 00 
1392   0C8F B0            cmp a, b
1393   0C90 FD 71         seq ; ==
1394   0C92 E4            pop a
1395   0C93             ; --- END RELATIONAL
1396   0C93 C0 00 00      cmp b, 0
1397   0C96 C6 D9 0E      je _if19_else
1398   0C99             _if19_true:
1399   0C99             ; format_p++; 
1400   0C99 FA FD FF      lea d, [bp + -3] ; $format_p
1401   0C9C 2A            mov b, [d]
1402   0C9D 38 00 00      mov c, 0
1403   0CA0 FD 77         inc b
1404   0CA2 FA FD FF      lea d, [bp + -3] ; $format_p
1405   0CA5 FD 3E         mov [d], bl
1406   0CA7 FD 7D         dec b
1407   0CA9             ; switch(*format_p){ 
1408   0CA9             _switch20_expr:
1409   0CA9 FA FD FF      lea d, [bp + -3] ; $format_p
1410   0CAC 2A            mov b, [d]
1411   0CAD 38 00 00      mov c, 0
1412   0CB0 74            mov d, b
1413   0CB1 32            mov bl, [d]
1414   0CB2 A7 00         mov bh, 0
1415   0CB4 38 00 00      mov c, 0
1416   0CB7             _switch20_comparisons:
1417   0CB7 C1 6C         cmp bl, $6c
1418   0CB9 C6 E5 0C      je _switch20_case0
1419   0CBC C1 4C         cmp bl, $4c
1420   0CBE C6 E5 0C      je _switch20_case1
1421   0CC1 C1 64         cmp bl, $64
1422   0CC3 C6 A4 0D      je _switch20_case2
1423   0CC6 C1 69         cmp bl, $69
1424   0CC8 C6 A4 0D      je _switch20_case3
1425   0CCB C1 75         cmp bl, $75
1426   0CCD C6 DD 0D      je _switch20_case4
1427   0CD0 C1 78         cmp bl, $78
1428   0CD2 C6 16 0E      je _switch20_case5
1429   0CD5 C1 63         cmp bl, $63
1430   0CD7 C6 31 0E      je _switch20_case6
1431   0CDA C1 73         cmp bl, $73
1432   0CDC C6 73 0E      je _switch20_case7
1433   0CDF 0A BA 0E      jmp _switch20_default
1434   0CE2 0A C6 0E      jmp _switch20_exit
1435   0CE5             _switch20_case0:
1436   0CE5             _switch20_case1:
1437   0CE5             ; format_p++; 
1438   0CE5 FA FD FF      lea d, [bp + -3] ; $format_p
1439   0CE8 2A            mov b, [d]
1440   0CE9 38 00 00      mov c, 0
1441   0CEC FD 77         inc b
1442   0CEE FA FD FF      lea d, [bp + -3] ; $format_p
1443   0CF1 FD 3E         mov [d], bl
1444   0CF3 FD 7D         dec b
1445   0CF5             ; if(*format_p == 'd' || *format_p == 'i'); 
1446   0CF5             _if21_cond:
1447   0CF5 FA FD FF      lea d, [bp + -3] ; $format_p
1448   0CF8 2A            mov b, [d]
1449   0CF9 38 00 00      mov c, 0
1450   0CFC 74            mov d, b
1451   0CFD 32            mov bl, [d]
1452   0CFE A7 00         mov bh, 0
1453   0D00 38 00 00      mov c, 0
1454   0D03             ; --- START RELATIONAL
1455   0D03 D7            push a
1456   0D04 11            mov a, b
1457   0D05 FD 2E 64 00   mov32 cb, $00000064
1457   0D09 00 00 
1458   0D0B B0            cmp a, b
1459   0D0C FD 71         seq ; ==
1460   0D0E E4            pop a
1461   0D0F             ; --- END RELATIONAL
1462   0D0F             ; --- START LOGICAL OR
1463   0D0F D7            push a
1464   0D10 11            mov a, b
1465   0D11 FA FD FF      lea d, [bp + -3] ; $format_p
1466   0D14 2A            mov b, [d]
1467   0D15 38 00 00      mov c, 0
1468   0D18 74            mov d, b
1469   0D19 32            mov bl, [d]
1470   0D1A A7 00         mov bh, 0
1471   0D1C 38 00 00      mov c, 0
1472   0D1F             ; --- START RELATIONAL
1473   0D1F D7            push a
1474   0D20 11            mov a, b
1475   0D21 FD 2E 69 00   mov32 cb, $00000069
1475   0D25 00 00 
1476   0D27 B0            cmp a, b
1477   0D28 FD 71         seq ; ==
1478   0D2A E4            pop a
1479   0D2B             ; --- END RELATIONAL
1480   0D2B FD A8         sor a, b ; ||
1481   0D2D E4            pop a
1482   0D2E             ; --- END LOGICAL OR
1483   0D2E C0 00 00      cmp b, 0
1484   0D31 C6 37 0D      je _if21_else
1485   0D34             _if21_true:
1486   0D34             ; ; 
1487   0D34 0A 89 0D      jmp _if21_exit
1488   0D37             _if21_else:
1489   0D37             ; if(*format_p == 'u'); 
1490   0D37             _if22_cond:
1491   0D37 FA FD FF      lea d, [bp + -3] ; $format_p
1492   0D3A 2A            mov b, [d]
1493   0D3B 38 00 00      mov c, 0
1494   0D3E 74            mov d, b
1495   0D3F 32            mov bl, [d]
1496   0D40 A7 00         mov bh, 0
1497   0D42 38 00 00      mov c, 0
1498   0D45             ; --- START RELATIONAL
1499   0D45 D7            push a
1500   0D46 11            mov a, b
1501   0D47 FD 2E 75 00   mov32 cb, $00000075
1501   0D4B 00 00 
1502   0D4D B0            cmp a, b
1503   0D4E FD 71         seq ; ==
1504   0D50 E4            pop a
1505   0D51             ; --- END RELATIONAL
1506   0D51 C0 00 00      cmp b, 0
1507   0D54 C6 5A 0D      je _if22_else
1508   0D57             _if22_true:
1509   0D57             ; ; 
1510   0D57 0A 89 0D      jmp _if22_exit
1511   0D5A             _if22_else:
1512   0D5A             ; if(*format_p == 'x'); 
1513   0D5A             _if23_cond:
1514   0D5A FA FD FF      lea d, [bp + -3] ; $format_p
1515   0D5D 2A            mov b, [d]
1516   0D5E 38 00 00      mov c, 0
1517   0D61 74            mov d, b
1518   0D62 32            mov bl, [d]
1519   0D63 A7 00         mov bh, 0
1520   0D65 38 00 00      mov c, 0
1521   0D68             ; --- START RELATIONAL
1522   0D68 D7            push a
1523   0D69 11            mov a, b
1524   0D6A FD 2E 78 00   mov32 cb, $00000078
1524   0D6E 00 00 
1525   0D70 B0            cmp a, b
1526   0D71 FD 71         seq ; ==
1527   0D73 E4            pop a
1528   0D74             ; --- END RELATIONAL
1529   0D74 C0 00 00      cmp b, 0
1530   0D77 C6 7D 0D      je _if23_else
1531   0D7A             _if23_true:
1532   0D7A             ; ; 
1533   0D7A 0A 89 0D      jmp _if23_exit
1534   0D7D             _if23_else:
1535   0D7D             ; err("Unexpected format in printf."); 
1536   0D7D             ; --- START FUNCTION CALL
1537   0D7D 26 55 21      mov b, _s0 ; "Unexpected format in printf."
1538   0D80 FD AB         swp b
1539   0D82 D8            push b
1540   0D83 07 B3 12      call err
1541   0D86 51 02 00      add sp, 2
1542   0D89             ; --- END FUNCTION CALL
1543   0D89             _if23_exit:
1544   0D89             _if22_exit:
1545   0D89             _if21_exit:
1546   0D89             ; p = p + 4; 
1547   0D89 FA FF FF      lea d, [bp + -1] ; $p
1548   0D8C DA            push d
1549   0D8D FA FF FF      lea d, [bp + -1] ; $p
1550   0D90 2A            mov b, [d]
1551   0D91 38 00 00      mov c, 0
1552   0D94             ; --- START TERMS
1553   0D94 D7            push a
1554   0D95 11            mov a, b
1555   0D96 FD 2E 04 00   mov32 cb, $00000004
1555   0D9A 00 00 
1556   0D9C 56            add b, a
1557   0D9D E4            pop a
1558   0D9E             ; --- END TERMS
1559   0D9E E7            pop d
1560   0D9F FD 43         mov [d], b
1561   0DA1             ; break; 
1562   0DA1 0A C6 0E      jmp _switch20_exit ; case break
1563   0DA4             _switch20_case2:
1564   0DA4             _switch20_case3:
1565   0DA4             ; i = scann(); 
1566   0DA4 FA FA FF      lea d, [bp + -6] ; $i
1567   0DA7 DA            push d
1568   0DA8             ; --- START FUNCTION CALL
1569   0DA8 07 C6 1C      call scann
1570   0DAB E7            pop d
1571   0DAC FD 43         mov [d], b
1572   0DAE             ; **(int **)p = i; 
1573   0DAE FA FF FF      lea d, [bp + -1] ; $p
1574   0DB1 2A            mov b, [d]
1575   0DB2 38 00 00      mov c, 0
1576   0DB5 74            mov d, b
1577   0DB6 2A            mov b, [d]
1578   0DB7 D8            push b
1579   0DB8 FA FA FF      lea d, [bp + -6] ; $i
1580   0DBB 2A            mov b, [d]
1581   0DBC 38 00 00      mov c, 0
1582   0DBF E7            pop d
1583   0DC0 FD 43         mov [d], b
1584   0DC2             ; p = p + 2; 
1585   0DC2 FA FF FF      lea d, [bp + -1] ; $p
1586   0DC5 DA            push d
1587   0DC6 FA FF FF      lea d, [bp + -1] ; $p
1588   0DC9 2A            mov b, [d]
1589   0DCA 38 00 00      mov c, 0
1590   0DCD             ; --- START TERMS
1591   0DCD D7            push a
1592   0DCE 11            mov a, b
1593   0DCF FD 2E 02 00   mov32 cb, $00000002
1593   0DD3 00 00 
1594   0DD5 56            add b, a
1595   0DD6 E4            pop a
1596   0DD7             ; --- END TERMS
1597   0DD7 E7            pop d
1598   0DD8 FD 43         mov [d], b
1599   0DDA             ; break; 
1600   0DDA 0A C6 0E      jmp _switch20_exit ; case break
1601   0DDD             _switch20_case4:
1602   0DDD             ; i = scann(); 
1603   0DDD FA FA FF      lea d, [bp + -6] ; $i
1604   0DE0 DA            push d
1605   0DE1             ; --- START FUNCTION CALL
1606   0DE1 07 C6 1C      call scann
1607   0DE4 E7            pop d
1608   0DE5 FD 43         mov [d], b
1609   0DE7             ; **(int **)p = i; 
1610   0DE7 FA FF FF      lea d, [bp + -1] ; $p
1611   0DEA 2A            mov b, [d]
1612   0DEB 38 00 00      mov c, 0
1613   0DEE 74            mov d, b
1614   0DEF 2A            mov b, [d]
1615   0DF0 D8            push b
1616   0DF1 FA FA FF      lea d, [bp + -6] ; $i
1617   0DF4 2A            mov b, [d]
1618   0DF5 38 00 00      mov c, 0
1619   0DF8 E7            pop d
1620   0DF9 FD 43         mov [d], b
1621   0DFB             ; p = p + 2; 
1622   0DFB FA FF FF      lea d, [bp + -1] ; $p
1623   0DFE DA            push d
1624   0DFF FA FF FF      lea d, [bp + -1] ; $p
1625   0E02 2A            mov b, [d]
1626   0E03 38 00 00      mov c, 0
1627   0E06             ; --- START TERMS
1628   0E06 D7            push a
1629   0E07 11            mov a, b
1630   0E08 FD 2E 02 00   mov32 cb, $00000002
1630   0E0C 00 00 
1631   0E0E 56            add b, a
1632   0E0F E4            pop a
1633   0E10             ; --- END TERMS
1634   0E10 E7            pop d
1635   0E11 FD 43         mov [d], b
1636   0E13             ; break; 
1637   0E13 0A C6 0E      jmp _switch20_exit ; case break
1638   0E16             _switch20_case5:
1639   0E16             ; p = p + 2; 
1640   0E16 FA FF FF      lea d, [bp + -1] ; $p
1641   0E19 DA            push d
1642   0E1A FA FF FF      lea d, [bp + -1] ; $p
1643   0E1D 2A            mov b, [d]
1644   0E1E 38 00 00      mov c, 0
1645   0E21             ; --- START TERMS
1646   0E21 D7            push a
1647   0E22 11            mov a, b
1648   0E23 FD 2E 02 00   mov32 cb, $00000002
1648   0E27 00 00 
1649   0E29 56            add b, a
1650   0E2A E4            pop a
1651   0E2B             ; --- END TERMS
1652   0E2B E7            pop d
1653   0E2C FD 43         mov [d], b
1654   0E2E             ; break; 
1655   0E2E 0A C6 0E      jmp _switch20_exit ; case break
1656   0E31             _switch20_case6:
1657   0E31             ; c = getchar(); 
1658   0E31 FA FC FF      lea d, [bp + -4] ; $c
1659   0E34 DA            push d
1660   0E35             ; --- START FUNCTION CALL
1661   0E35 07 AD 1C      call getchar
1662   0E38 E7            pop d
1663   0E39 FD 3E         mov [d], bl
1664   0E3B             ; **(char **)p = *(char *)c; 
1665   0E3B FA FF FF      lea d, [bp + -1] ; $p
1666   0E3E 2A            mov b, [d]
1667   0E3F 38 00 00      mov c, 0
1668   0E42 74            mov d, b
1669   0E43 2A            mov b, [d]
1670   0E44 D8            push b
1671   0E45 FA FC FF      lea d, [bp + -4] ; $c
1672   0E48 32            mov bl, [d]
1673   0E49 A7 00         mov bh, 0
1674   0E4B 38 00 00      mov c, 0
1675   0E4E 74            mov d, b
1676   0E4F 32            mov bl, [d]
1677   0E50 A7 00         mov bh, 0
1678   0E52 38 00 00      mov c, 0
1679   0E55 E7            pop d
1680   0E56 FD 43         mov [d], b
1681   0E58             ; p = p + 1; 
1682   0E58 FA FF FF      lea d, [bp + -1] ; $p
1683   0E5B DA            push d
1684   0E5C FA FF FF      lea d, [bp + -1] ; $p
1685   0E5F 2A            mov b, [d]
1686   0E60 38 00 00      mov c, 0
1687   0E63             ; --- START TERMS
1688   0E63 D7            push a
1689   0E64 11            mov a, b
1690   0E65 FD 2E 01 00   mov32 cb, $00000001
1690   0E69 00 00 
1691   0E6B 56            add b, a
1692   0E6C E4            pop a
1693   0E6D             ; --- END TERMS
1694   0E6D E7            pop d
1695   0E6E FD 43         mov [d], b
1696   0E70             ; break; 
1697   0E70 0A C6 0E      jmp _switch20_exit ; case break
1698   0E73             _switch20_case7:
1699   0E73             ; gets(input_string); 
1700   0E73             ; --- START FUNCTION CALL
1701   0E73 FA FA FD      lea d, [bp + -518] ; $input_string
1702   0E76 2D            mov b, d
1703   0E77 38 00 00      mov c, 0
1704   0E7A FD AB         swp b
1705   0E7C D8            push b
1706   0E7D 07 9F 14      call gets
1707   0E80 51 02 00      add sp, 2
1708   0E83             ; --- END FUNCTION CALL
1709   0E83             ; strcpy(*(char **)p, input_string); 
1710   0E83             ; --- START FUNCTION CALL
1711   0E83 FA FA FD      lea d, [bp + -518] ; $input_string
1712   0E86 2D            mov b, d
1713   0E87 38 00 00      mov c, 0
1714   0E8A FD AB         swp b
1715   0E8C D8            push b
1716   0E8D FA FF FF      lea d, [bp + -1] ; $p
1717   0E90 2A            mov b, [d]
1718   0E91 38 00 00      mov c, 0
1719   0E94 74            mov d, b
1720   0E95 2A            mov b, [d]
1721   0E96 FD AB         swp b
1722   0E98 D8            push b
1723   0E99 07 1C 04      call strcpy
1724   0E9C 51 04 00      add sp, 4
1725   0E9F             ; --- END FUNCTION CALL
1726   0E9F             ; p = p + 2; 
1727   0E9F FA FF FF      lea d, [bp + -1] ; $p
1728   0EA2 DA            push d
1729   0EA3 FA FF FF      lea d, [bp + -1] ; $p
1730   0EA6 2A            mov b, [d]
1731   0EA7 38 00 00      mov c, 0
1732   0EAA             ; --- START TERMS
1733   0EAA D7            push a
1734   0EAB 11            mov a, b
1735   0EAC FD 2E 02 00   mov32 cb, $00000002
1735   0EB0 00 00 
1736   0EB2 56            add b, a
1737   0EB3 E4            pop a
1738   0EB4             ; --- END TERMS
1739   0EB4 E7            pop d
1740   0EB5 FD 43         mov [d], b
1741   0EB7             ; break; 
1742   0EB7 0A C6 0E      jmp _switch20_exit ; case break
1743   0EBA             _switch20_default:
1744   0EBA             ; print("Error: Unknown argument type.\n"); 
1745   0EBA             ; --- START FUNCTION CALL
1746   0EBA 26 72 21      mov b, _s1 ; "Error: Unknown argument type.\n"
1747   0EBD FD AB         swp b
1748   0EBF D8            push b
1749   0EC0 07 EE 1C      call print
1750   0EC3 51 02 00      add sp, 2
1751   0EC6             ; --- END FUNCTION CALL
1752   0EC6             _switch20_exit:
1753   0EC6             ; format_p++; 
1754   0EC6 FA FD FF      lea d, [bp + -3] ; $format_p
1755   0EC9 2A            mov b, [d]
1756   0ECA 38 00 00      mov c, 0
1757   0ECD FD 77         inc b
1758   0ECF FA FD FF      lea d, [bp + -3] ; $format_p
1759   0ED2 FD 3E         mov [d], bl
1760   0ED4 FD 7D         dec b
1761   0ED6 0A FE 0E      jmp _if19_exit
1762   0ED9             _if19_else:
1763   0ED9             ; putchar(*format_p); 
1764   0ED9             ; --- START FUNCTION CALL
1765   0ED9 FA FD FF      lea d, [bp + -3] ; $format_p
1766   0EDC 2A            mov b, [d]
1767   0EDD 38 00 00      mov c, 0
1768   0EE0 74            mov d, b
1769   0EE1 32            mov bl, [d]
1770   0EE2 A7 00         mov bh, 0
1771   0EE4 38 00 00      mov c, 0
1772   0EE7 DD            push bl
1773   0EE8 07 A0 1C      call putchar
1774   0EEB 51 01 00      add sp, 1
1775   0EEE             ; --- END FUNCTION CALL
1776   0EEE             ; format_p++; 
1777   0EEE FA FD FF      lea d, [bp + -3] ; $format_p
1778   0EF1 2A            mov b, [d]
1779   0EF2 38 00 00      mov c, 0
1780   0EF5 FD 77         inc b
1781   0EF7 FA FD FF      lea d, [bp + -3] ; $format_p
1782   0EFA FD 3E         mov [d], bl
1783   0EFC FD 7D         dec b
1784   0EFE             _if19_exit:
1785   0EFE             _if18_exit:
1786   0EFE             _for17_update:
1787   0EFE 0A 5A 0C      jmp _for17_cond
1788   0F01             _for17_exit:
1789   0F01 F9            leave
1790   0F02 09            ret
1791   0F03             
1792   0F03             sprintf:
1793   0F03 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1794   0F06             ; char *p, *format_p; 
1795   0F06 52 02 00      sub sp, 2
1796   0F09 52 02 00      sub sp, 2
1797   0F0C             ; char *sp; 
1798   0F0C 52 02 00      sub sp, 2
1799   0F0F             ; sp = dest; 
1800   0F0F FA FB FF      lea d, [bp + -5] ; $sp
1801   0F12 DA            push d
1802   0F13 FA 05 00      lea d, [bp + 5] ; $dest
1803   0F16 2A            mov b, [d]
1804   0F17 38 00 00      mov c, 0
1805   0F1A E7            pop d
1806   0F1B FD 43         mov [d], b
1807   0F1D             ; format_p = format; 
1808   0F1D FA FD FF      lea d, [bp + -3] ; $format_p
1809   0F20 DA            push d
1810   0F21 FA 07 00      lea d, [bp + 7] ; $format
1811   0F24 2A            mov b, [d]
1812   0F25 38 00 00      mov c, 0
1813   0F28 E7            pop d
1814   0F29 FD 43         mov [d], b
1815   0F2B             ; p = &format + 2; 
1816   0F2B FA FF FF      lea d, [bp + -1] ; $p
1817   0F2E DA            push d
1818   0F2F FA 07 00      lea d, [bp + 7] ; $format
1819   0F32 2D            mov b, d
1820   0F33             ; --- START TERMS
1821   0F33 D7            push a
1822   0F34 11            mov a, b
1823   0F35 FD 2E 02 00   mov32 cb, $00000002
1823   0F39 00 00 
1824   0F3B 56            add b, a
1825   0F3C E4            pop a
1826   0F3D             ; --- END TERMS
1827   0F3D E7            pop d
1828   0F3E FD 43         mov [d], b
1829   0F40             ; for(;;){ 
1830   0F40             _for24_init:
1831   0F40             _for24_cond:
1832   0F40             _for24_block:
1833   0F40             ; if(!*format_p) break; 
1834   0F40             _if25_cond:
1835   0F40 FA FD FF      lea d, [bp + -3] ; $format_p
1836   0F43 2A            mov b, [d]
1837   0F44 38 00 00      mov c, 0
1838   0F47 74            mov d, b
1839   0F48 32            mov bl, [d]
1840   0F49 A7 00         mov bh, 0
1841   0F4B 38 00 00      mov c, 0
1842   0F4E C0 00 00      cmp b, 0
1843   0F51 FD 71         seq ; !
1844   0F53 C0 00 00      cmp b, 0
1845   0F56 C6 5F 0F      je _if25_else
1846   0F59             _if25_true:
1847   0F59             ; break; 
1848   0F59 0A 8D 12      jmp _for24_exit ; for break
1849   0F5C 0A 8A 12      jmp _if25_exit
1850   0F5F             _if25_else:
1851   0F5F             ; if(*format_p == '%'){ 
1852   0F5F             _if26_cond:
1853   0F5F FA FD FF      lea d, [bp + -3] ; $format_p
1854   0F62 2A            mov b, [d]
1855   0F63 38 00 00      mov c, 0
1856   0F66 74            mov d, b
1857   0F67 32            mov bl, [d]
1858   0F68 A7 00         mov bh, 0
1859   0F6A 38 00 00      mov c, 0
1860   0F6D             ; --- START RELATIONAL
1861   0F6D D7            push a
1862   0F6E 11            mov a, b
1863   0F6F FD 2E 25 00   mov32 cb, $00000025
1863   0F73 00 00 
1864   0F75 B0            cmp a, b
1865   0F76 FD 71         seq ; ==
1866   0F78 E4            pop a
1867   0F79             ; --- END RELATIONAL
1868   0F79 C0 00 00      cmp b, 0
1869   0F7C C6 5F 12      je _if26_else
1870   0F7F             _if26_true:
1871   0F7F             ; format_p++; 
1872   0F7F FA FD FF      lea d, [bp + -3] ; $format_p
1873   0F82 2A            mov b, [d]
1874   0F83 38 00 00      mov c, 0
1875   0F86 FD 77         inc b
1876   0F88 FA FD FF      lea d, [bp + -3] ; $format_p
1877   0F8B FD 3E         mov [d], bl
1878   0F8D FD 7D         dec b
1879   0F8F             ; switch(*format_p){ 
1880   0F8F             _switch27_expr:
1881   0F8F FA FD FF      lea d, [bp + -3] ; $format_p
1882   0F92 2A            mov b, [d]
1883   0F93 38 00 00      mov c, 0
1884   0F96 74            mov d, b
1885   0F97 32            mov bl, [d]
1886   0F98 A7 00         mov bh, 0
1887   0F9A 38 00 00      mov c, 0
1888   0F9D             _switch27_comparisons:
1889   0F9D C1 6C         cmp bl, $6c
1890   0F9F C6 CB 0F      je _switch27_case0
1891   0FA2 C1 4C         cmp bl, $4c
1892   0FA4 C6 CB 0F      je _switch27_case1
1893   0FA7 C1 64         cmp bl, $64
1894   0FA9 C6 DB 10      je _switch27_case2
1895   0FAC C1 69         cmp bl, $69
1896   0FAE C6 DB 10      je _switch27_case3
1897   0FB1 C1 75         cmp bl, $75
1898   0FB3 C6 27 11      je _switch27_case4
1899   0FB6 C1 78         cmp bl, $78
1900   0FB8 C6 73 11      je _switch27_case5
1901   0FBB C1 63         cmp bl, $63
1902   0FBD C6 97 11      je _switch27_case6
1903   0FC0 C1 73         cmp bl, $73
1904   0FC2 C6 D4 11      je _switch27_case7
1905   0FC5 0A 40 12      jmp _switch27_default
1906   0FC8 0A 4C 12      jmp _switch27_exit
1907   0FCB             _switch27_case0:
1908   0FCB             _switch27_case1:
1909   0FCB             ; format_p++; 
1910   0FCB FA FD FF      lea d, [bp + -3] ; $format_p
1911   0FCE 2A            mov b, [d]
1912   0FCF 38 00 00      mov c, 0
1913   0FD2 FD 77         inc b
1914   0FD4 FA FD FF      lea d, [bp + -3] ; $format_p
1915   0FD7 FD 3E         mov [d], bl
1916   0FD9 FD 7D         dec b
1917   0FDB             ; if(*format_p == 'd' || *format_p == 'i') 
1918   0FDB             _if28_cond:
1919   0FDB FA FD FF      lea d, [bp + -3] ; $format_p
1920   0FDE 2A            mov b, [d]
1921   0FDF 38 00 00      mov c, 0
1922   0FE2 74            mov d, b
1923   0FE3 32            mov bl, [d]
1924   0FE4 A7 00         mov bh, 0
1925   0FE6 38 00 00      mov c, 0
1926   0FE9             ; --- START RELATIONAL
1927   0FE9 D7            push a
1928   0FEA 11            mov a, b
1929   0FEB FD 2E 64 00   mov32 cb, $00000064
1929   0FEF 00 00 
1930   0FF1 B0            cmp a, b
1931   0FF2 FD 71         seq ; ==
1932   0FF4 E4            pop a
1933   0FF5             ; --- END RELATIONAL
1934   0FF5             ; --- START LOGICAL OR
1935   0FF5 D7            push a
1936   0FF6 11            mov a, b
1937   0FF7 FA FD FF      lea d, [bp + -3] ; $format_p
1938   0FFA 2A            mov b, [d]
1939   0FFB 38 00 00      mov c, 0
1940   0FFE 74            mov d, b
1941   0FFF 32            mov bl, [d]
1942   1000 A7 00         mov bh, 0
1943   1002 38 00 00      mov c, 0
1944   1005             ; --- START RELATIONAL
1945   1005 D7            push a
1946   1006 11            mov a, b
1947   1007 FD 2E 69 00   mov32 cb, $00000069
1947   100B 00 00 
1948   100D B0            cmp a, b
1949   100E FD 71         seq ; ==
1950   1010 E4            pop a
1951   1011             ; --- END RELATIONAL
1952   1011 FD A8         sor a, b ; ||
1953   1013 E4            pop a
1954   1014             ; --- END LOGICAL OR
1955   1014 C0 00 00      cmp b, 0
1956   1017 C6 38 10      je _if28_else
1957   101A             _if28_true:
1958   101A             ; print_signed_long(*(long *)p); 
1959   101A             ; --- START FUNCTION CALL
1960   101A FA FF FF      lea d, [bp + -1] ; $p
1961   101D 2A            mov b, [d]
1962   101E 38 00 00      mov c, 0
1963   1021 74            mov d, b
1964   1022 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1965   1025 FD 39         mov c, b ; And place it into C
1966   1027 2A            mov b, [d] ; Lower Word in B
1967   1028 12            mov a, c
1968   1029 FD AA         swp a
1969   102B D7            push a
1970   102C FD AB         swp b
1971   102E D8            push b
1972   102F 07 F5 15      call print_signed_long
1973   1032 51 04 00      add sp, 4
1974   1035             ; --- END FUNCTION CALL
1975   1035 0A C0 10      jmp _if28_exit
1976   1038             _if28_else:
1977   1038             ; if(*format_p == 'u') 
1978   1038             _if29_cond:
1979   1038 FA FD FF      lea d, [bp + -3] ; $format_p
1980   103B 2A            mov b, [d]
1981   103C 38 00 00      mov c, 0
1982   103F 74            mov d, b
1983   1040 32            mov bl, [d]
1984   1041 A7 00         mov bh, 0
1985   1043 38 00 00      mov c, 0
1986   1046             ; --- START RELATIONAL
1987   1046 D7            push a
1988   1047 11            mov a, b
1989   1048 FD 2E 75 00   mov32 cb, $00000075
1989   104C 00 00 
1990   104E B0            cmp a, b
1991   104F FD 71         seq ; ==
1992   1051 E4            pop a
1993   1052             ; --- END RELATIONAL
1994   1052 C0 00 00      cmp b, 0
1995   1055 C6 76 10      je _if29_else
1996   1058             _if29_true:
1997   1058             ; print_unsigned_long(*(unsigned long *)p); 
1998   1058             ; --- START FUNCTION CALL
1999   1058 FA FF FF      lea d, [bp + -1] ; $p
2000   105B 2A            mov b, [d]
2001   105C 38 00 00      mov c, 0
2002   105F 74            mov d, b
2003   1060 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2004   1063 FD 39         mov c, b ; And place it into C
2005   1065 2A            mov b, [d] ; Lower Word in B
2006   1066 12            mov a, c
2007   1067 FD AA         swp a
2008   1069 D7            push a
2009   106A FD AB         swp b
2010   106C D8            push b
2011   106D 07 64 17      call print_unsigned_long
2012   1070 51 04 00      add sp, 4
2013   1073             ; --- END FUNCTION CALL
2014   1073 0A C0 10      jmp _if29_exit
2015   1076             _if29_else:
2016   1076             ; if(*format_p == 'x') 
2017   1076             _if30_cond:
2018   1076 FA FD FF      lea d, [bp + -3] ; $format_p
2019   1079 2A            mov b, [d]
2020   107A 38 00 00      mov c, 0
2021   107D 74            mov d, b
2022   107E 32            mov bl, [d]
2023   107F A7 00         mov bh, 0
2024   1081 38 00 00      mov c, 0
2025   1084             ; --- START RELATIONAL
2026   1084 D7            push a
2027   1085 11            mov a, b
2028   1086 FD 2E 78 00   mov32 cb, $00000078
2028   108A 00 00 
2029   108C B0            cmp a, b
2030   108D FD 71         seq ; ==
2031   108F E4            pop a
2032   1090             ; --- END RELATIONAL
2033   1090 C0 00 00      cmp b, 0
2034   1093 C6 B4 10      je _if30_else
2035   1096             _if30_true:
2036   1096             ; printx32(*(long int *)p); 
2037   1096             ; --- START FUNCTION CALL
2038   1096 FA FF FF      lea d, [bp + -1] ; $p
2039   1099 2A            mov b, [d]
2040   109A 38 00 00      mov c, 0
2041   109D 74            mov d, b
2042   109E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2043   10A1 FD 39         mov c, b ; And place it into C
2044   10A3 2A            mov b, [d] ; Lower Word in B
2045   10A4 12            mov a, c
2046   10A5 FD AA         swp a
2047   10A7 D7            push a
2048   10A8 FD AB         swp b
2049   10AA D8            push b
2050   10AB 07 C8 12      call printx32
2051   10AE 51 04 00      add sp, 4
2052   10B1             ; --- END FUNCTION CALL
2053   10B1 0A C0 10      jmp _if30_exit
2054   10B4             _if30_else:
2055   10B4             ; err("Unexpected format in printf."); 
2056   10B4             ; --- START FUNCTION CALL
2057   10B4 26 55 21      mov b, _s0 ; "Unexpected format in printf."
2058   10B7 FD AB         swp b
2059   10B9 D8            push b
2060   10BA 07 B3 12      call err
2061   10BD 51 02 00      add sp, 2
2062   10C0             ; --- END FUNCTION CALL
2063   10C0             _if30_exit:
2064   10C0             _if29_exit:
2065   10C0             _if28_exit:
2066   10C0             ; p = p + 4; 
2067   10C0 FA FF FF      lea d, [bp + -1] ; $p
2068   10C3 DA            push d
2069   10C4 FA FF FF      lea d, [bp + -1] ; $p
2070   10C7 2A            mov b, [d]
2071   10C8 38 00 00      mov c, 0
2072   10CB             ; --- START TERMS
2073   10CB D7            push a
2074   10CC 11            mov a, b
2075   10CD FD 2E 04 00   mov32 cb, $00000004
2075   10D1 00 00 
2076   10D3 56            add b, a
2077   10D4 E4            pop a
2078   10D5             ; --- END TERMS
2079   10D5 E7            pop d
2080   10D6 FD 43         mov [d], b
2081   10D8             ; break; 
2082   10D8 0A 4C 12      jmp _switch27_exit ; case break
2083   10DB             _switch27_case2:
2084   10DB             _switch27_case3:
2085   10DB             ; sp = sp + sprint_signed(sp, *(int*)p); 
2086   10DB FA FB FF      lea d, [bp + -5] ; $sp
2087   10DE DA            push d
2088   10DF FA FB FF      lea d, [bp + -5] ; $sp
2089   10E2 2A            mov b, [d]
2090   10E3 38 00 00      mov c, 0
2091   10E6             ; --- START TERMS
2092   10E6 D7            push a
2093   10E7 11            mov a, b
2094   10E8             ; --- START FUNCTION CALL
2095   10E8 FA FF FF      lea d, [bp + -1] ; $p
2096   10EB 2A            mov b, [d]
2097   10EC 38 00 00      mov c, 0
2098   10EF 74            mov d, b
2099   10F0 2A            mov b, [d]
2100   10F1 38 00 00      mov c, 0
2101   10F4 FD AB         swp b
2102   10F6 D8            push b
2103   10F7 FA FB FF      lea d, [bp + -5] ; $sp
2104   10FA 2A            mov b, [d]
2105   10FB 38 00 00      mov c, 0
2106   10FE FD AB         swp b
2107   1100 D8            push b
2108   1101 07 D8 1A      call sprint_signed
2109   1104 51 04 00      add sp, 4
2110   1107             ; --- END FUNCTION CALL
2111   1107 56            add b, a
2112   1108 E4            pop a
2113   1109             ; --- END TERMS
2114   1109 E7            pop d
2115   110A FD 43         mov [d], b
2116   110C             ; p = p + 2; 
2117   110C FA FF FF      lea d, [bp + -1] ; $p
2118   110F DA            push d
2119   1110 FA FF FF      lea d, [bp + -1] ; $p
2120   1113 2A            mov b, [d]
2121   1114 38 00 00      mov c, 0
2122   1117             ; --- START TERMS
2123   1117 D7            push a
2124   1118 11            mov a, b
2125   1119 FD 2E 02 00   mov32 cb, $00000002
2125   111D 00 00 
2126   111F 56            add b, a
2127   1120 E4            pop a
2128   1121             ; --- END TERMS
2129   1121 E7            pop d
2130   1122 FD 43         mov [d], b
2131   1124             ; break; 
2132   1124 0A 4C 12      jmp _switch27_exit ; case break
2133   1127             _switch27_case4:
2134   1127             ; sp = sp + sprint_unsigned(sp, *(unsigned int*)p); 
2135   1127 FA FB FF      lea d, [bp + -5] ; $sp
2136   112A DA            push d
2137   112B FA FB FF      lea d, [bp + -5] ; $sp
2138   112E 2A            mov b, [d]
2139   112F 38 00 00      mov c, 0
2140   1132             ; --- START TERMS
2141   1132 D7            push a
2142   1133 11            mov a, b
2143   1134             ; --- START FUNCTION CALL
2144   1134 FA FF FF      lea d, [bp + -1] ; $p
2145   1137 2A            mov b, [d]
2146   1138 38 00 00      mov c, 0
2147   113B 74            mov d, b
2148   113C 2A            mov b, [d]
2149   113D 38 00 00      mov c, 0
2150   1140 FD AB         swp b
2151   1142 D8            push b
2152   1143 FA FB FF      lea d, [bp + -5] ; $sp
2153   1146 2A            mov b, [d]
2154   1147 38 00 00      mov c, 0
2155   114A FD AB         swp b
2156   114C D8            push b
2157   114D 07 80 18      call sprint_unsigned
2158   1150 51 04 00      add sp, 4
2159   1153             ; --- END FUNCTION CALL
2160   1153 56            add b, a
2161   1154 E4            pop a
2162   1155             ; --- END TERMS
2163   1155 E7            pop d
2164   1156 FD 43         mov [d], b
2165   1158             ; p = p + 2; 
2166   1158 FA FF FF      lea d, [bp + -1] ; $p
2167   115B DA            push d
2168   115C FA FF FF      lea d, [bp + -1] ; $p
2169   115F 2A            mov b, [d]
2170   1160 38 00 00      mov c, 0
2171   1163             ; --- START TERMS
2172   1163 D7            push a
2173   1164 11            mov a, b
2174   1165 FD 2E 02 00   mov32 cb, $00000002
2174   1169 00 00 
2175   116B 56            add b, a
2176   116C E4            pop a
2177   116D             ; --- END TERMS
2178   116D E7            pop d
2179   116E FD 43         mov [d], b
2180   1170             ; break; 
2181   1170 0A 4C 12      jmp _switch27_exit ; case break
2182   1173             _switch27_case5:
2183   1173             
2184   1173             ; --- BEGIN INLINE ASM SEGMENT
2185   1173 FA FF FF      lea d, [bp + -1] ; $p
2186   1176 FD 2A         mov d, [d]
2187   1178 2A            mov b, [d]
2188   1179 07 51 20      call print_u16x
2189   117C             ; --- END INLINE ASM SEGMENT
2190   117C             
2191   117C             ; p = p + 2; 
2192   117C FA FF FF      lea d, [bp + -1] ; $p
2193   117F DA            push d
2194   1180 FA FF FF      lea d, [bp + -1] ; $p
2195   1183 2A            mov b, [d]
2196   1184 38 00 00      mov c, 0
2197   1187             ; --- START TERMS
2198   1187 D7            push a
2199   1188 11            mov a, b
2200   1189 FD 2E 02 00   mov32 cb, $00000002
2200   118D 00 00 
2201   118F 56            add b, a
2202   1190 E4            pop a
2203   1191             ; --- END TERMS
2204   1191 E7            pop d
2205   1192 FD 43         mov [d], b
2206   1194             ; break; 
2207   1194 0A 4C 12      jmp _switch27_exit ; case break
2208   1197             _switch27_case6:
2209   1197             ; *sp++ = *(char *)p; 
2210   1197 FA FB FF      lea d, [bp + -5] ; $sp
2211   119A 2A            mov b, [d]
2212   119B 38 00 00      mov c, 0
2213   119E FD 77         inc b
2214   11A0 FA FB FF      lea d, [bp + -5] ; $sp
2215   11A3 FD 3E         mov [d], bl
2216   11A5 FD 7D         dec b
2217   11A7 D8            push b
2218   11A8 FA FF FF      lea d, [bp + -1] ; $p
2219   11AB 2A            mov b, [d]
2220   11AC 38 00 00      mov c, 0
2221   11AF 74            mov d, b
2222   11B0 32            mov bl, [d]
2223   11B1 A7 00         mov bh, 0
2224   11B3 38 00 00      mov c, 0
2225   11B6 E7            pop d
2226   11B7 FD 3E         mov [d], bl
2227   11B9             ; p = p + 1; 
2228   11B9 FA FF FF      lea d, [bp + -1] ; $p
2229   11BC DA            push d
2230   11BD FA FF FF      lea d, [bp + -1] ; $p
2231   11C0 2A            mov b, [d]
2232   11C1 38 00 00      mov c, 0
2233   11C4             ; --- START TERMS
2234   11C4 D7            push a
2235   11C5 11            mov a, b
2236   11C6 FD 2E 01 00   mov32 cb, $00000001
2236   11CA 00 00 
2237   11CC 56            add b, a
2238   11CD E4            pop a
2239   11CE             ; --- END TERMS
2240   11CE E7            pop d
2241   11CF FD 43         mov [d], b
2242   11D1             ; break; 
2243   11D1 0A 4C 12      jmp _switch27_exit ; case break
2244   11D4             _switch27_case7:
2245   11D4             ; int len = strlen(*(char **)p); 
2246   11D4 52 02 00      sub sp, 2
2247   11D7             ; --- START LOCAL VAR INITIALIZATION
2248   11D7 FA F9 FF      lea d, [bp + -7] ; $len
2249   11DA DA            push d
2250   11DB             ; --- START FUNCTION CALL
2251   11DB FA FF FF      lea d, [bp + -1] ; $p
2252   11DE 2A            mov b, [d]
2253   11DF 38 00 00      mov c, 0
2254   11E2 74            mov d, b
2255   11E3 2A            mov b, [d]
2256   11E4 FD AB         swp b
2257   11E6 D8            push b
2258   11E7 07 02 06      call strlen
2259   11EA 51 02 00      add sp, 2
2260   11ED             ; --- END FUNCTION CALL
2261   11ED E7            pop d
2262   11EE FD 43         mov [d], b
2263   11F0             ; --- END LOCAL VAR INITIALIZATION
2264   11F0             ; strcpy(sp, *(char **)p); 
2265   11F0             ; --- START FUNCTION CALL
2266   11F0 FA FF FF      lea d, [bp + -1] ; $p
2267   11F3 2A            mov b, [d]
2268   11F4 38 00 00      mov c, 0
2269   11F7 74            mov d, b
2270   11F8 2A            mov b, [d]
2271   11F9 FD AB         swp b
2272   11FB D8            push b
2273   11FC FA FB FF      lea d, [bp + -5] ; $sp
2274   11FF 2A            mov b, [d]
2275   1200 38 00 00      mov c, 0
2276   1203 FD AB         swp b
2277   1205 D8            push b
2278   1206 07 1C 04      call strcpy
2279   1209 51 04 00      add sp, 4
2280   120C             ; --- END FUNCTION CALL
2281   120C             ; sp = sp + len; 
2282   120C FA FB FF      lea d, [bp + -5] ; $sp
2283   120F DA            push d
2284   1210 FA FB FF      lea d, [bp + -5] ; $sp
2285   1213 2A            mov b, [d]
2286   1214 38 00 00      mov c, 0
2287   1217             ; --- START TERMS
2288   1217 D7            push a
2289   1218 11            mov a, b
2290   1219 FA F9 FF      lea d, [bp + -7] ; $len
2291   121C 2A            mov b, [d]
2292   121D 38 00 00      mov c, 0
2293   1220 56            add b, a
2294   1221 E4            pop a
2295   1222             ; --- END TERMS
2296   1222 E7            pop d
2297   1223 FD 43         mov [d], b
2298   1225             ; p = p + 2; 
2299   1225 FA FF FF      lea d, [bp + -1] ; $p
2300   1228 DA            push d
2301   1229 FA FF FF      lea d, [bp + -1] ; $p
2302   122C 2A            mov b, [d]
2303   122D 38 00 00      mov c, 0
2304   1230             ; --- START TERMS
2305   1230 D7            push a
2306   1231 11            mov a, b
2307   1232 FD 2E 02 00   mov32 cb, $00000002
2307   1236 00 00 
2308   1238 56            add b, a
2309   1239 E4            pop a
2310   123A             ; --- END TERMS
2311   123A E7            pop d
2312   123B FD 43         mov [d], b
2313   123D             ; break; 
2314   123D 0A 4C 12      jmp _switch27_exit ; case break
2315   1240             _switch27_default:
2316   1240             ; print("Error: Unknown argument type.\n"); 
2317   1240             ; --- START FUNCTION CALL
2318   1240 26 72 21      mov b, _s1 ; "Error: Unknown argument type.\n"
2319   1243 FD AB         swp b
2320   1245 D8            push b
2321   1246 07 EE 1C      call print
2322   1249 51 02 00      add sp, 2
2323   124C             ; --- END FUNCTION CALL
2324   124C             _switch27_exit:
2325   124C             ; format_p++; 
2326   124C FA FD FF      lea d, [bp + -3] ; $format_p
2327   124F 2A            mov b, [d]
2328   1250 38 00 00      mov c, 0
2329   1253 FD 77         inc b
2330   1255 FA FD FF      lea d, [bp + -3] ; $format_p
2331   1258 FD 3E         mov [d], bl
2332   125A FD 7D         dec b
2333   125C 0A 8A 12      jmp _if26_exit
2334   125F             _if26_else:
2335   125F             ; *sp++ = *format_p++; 
2336   125F FA FB FF      lea d, [bp + -5] ; $sp
2337   1262 2A            mov b, [d]
2338   1263 38 00 00      mov c, 0
2339   1266 FD 77         inc b
2340   1268 FA FB FF      lea d, [bp + -5] ; $sp
2341   126B FD 3E         mov [d], bl
2342   126D FD 7D         dec b
2343   126F D8            push b
2344   1270 FA FD FF      lea d, [bp + -3] ; $format_p
2345   1273 2A            mov b, [d]
2346   1274 38 00 00      mov c, 0
2347   1277 FD 77         inc b
2348   1279 FA FD FF      lea d, [bp + -3] ; $format_p
2349   127C FD 3E         mov [d], bl
2350   127E FD 7D         dec b
2351   1280 74            mov d, b
2352   1281 32            mov bl, [d]
2353   1282 A7 00         mov bh, 0
2354   1284 38 00 00      mov c, 0
2355   1287 E7            pop d
2356   1288 FD 3E         mov [d], bl
2357   128A             _if26_exit:
2358   128A             _if25_exit:
2359   128A             _for24_update:
2360   128A 0A 40 0F      jmp _for24_cond
2361   128D             _for24_exit:
2362   128D             ; *sp = '\0'; 
2363   128D FA FB FF      lea d, [bp + -5] ; $sp
2364   1290 2A            mov b, [d]
2365   1291 38 00 00      mov c, 0
2366   1294 D8            push b
2367   1295 FD 2E 00 00   mov32 cb, $00000000
2367   1299 00 00 
2368   129B E7            pop d
2369   129C FD 3E         mov [d], bl
2370   129E             ; return sp - dest; // return total number of chars written 
2371   129E FA FB FF      lea d, [bp + -5] ; $sp
2372   12A1 2A            mov b, [d]
2373   12A2 38 00 00      mov c, 0
2374   12A5             ; --- START TERMS
2375   12A5 D7            push a
2376   12A6 11            mov a, b
2377   12A7 FA 05 00      lea d, [bp + 5] ; $dest
2378   12AA 2A            mov b, [d]
2379   12AB 38 00 00      mov c, 0
2380   12AE 60            sub a, b
2381   12AF 27            mov b, a
2382   12B0 E4            pop a
2383   12B1             ; --- END TERMS
2384   12B1 F9            leave
2385   12B2 09            ret
2386   12B3             
2387   12B3             err:
2388   12B3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2389   12B6             ; print(e); 
2390   12B6             ; --- START FUNCTION CALL
2391   12B6 FA 05 00      lea d, [bp + 5] ; $e
2392   12B9 2A            mov b, [d]
2393   12BA 38 00 00      mov c, 0
2394   12BD FD AB         swp b
2395   12BF D8            push b
2396   12C0 07 EE 1C      call print
2397   12C3 51 02 00      add sp, 2
2398   12C6             ; --- END FUNCTION CALL
2399   12C6 F9            leave
2400   12C7 09            ret
2401   12C8             
2402   12C8             printx32:
2403   12C8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2404   12CB             
2405   12CB             ; --- BEGIN INLINE ASM SEGMENT
2406   12CB FA 05 00      lea d, [bp + 5] ; $hex
2407   12CE 2B 02 00      mov b, [d+2]
2408   12D1 07 51 20      call print_u16x
2409   12D4 2A            mov b, [d]
2410   12D5 07 51 20      call print_u16x
2411   12D8             ; --- END INLINE ASM SEGMENT
2412   12D8             
2413   12D8 F9            leave
2414   12D9 09            ret
2415   12DA             
2416   12DA             printx16:
2417   12DA F8 00 00      enter 0 ; (push bp; mov bp, sp)
2418   12DD             
2419   12DD             ; --- BEGIN INLINE ASM SEGMENT
2420   12DD FA 05 00      lea d, [bp + 5] ; $hex
2421   12E0 2A            mov b, [d]
2422   12E1 07 51 20      call print_u16x
2423   12E4             ; --- END INLINE ASM SEGMENT
2424   12E4             
2425   12E4 F9            leave
2426   12E5 09            ret
2427   12E6             
2428   12E6             printx8:
2429   12E6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2430   12E9             
2431   12E9             ; --- BEGIN INLINE ASM SEGMENT
2432   12E9 FA 05 00      lea d, [bp + 5] ; $hex
2433   12EC 32            mov bl, [d]
2434   12ED 07 95 20      call print_u8x
2435   12F0             ; --- END INLINE ASM SEGMENT
2436   12F0             
2437   12F0 F9            leave
2438   12F1 09            ret
2439   12F2             
2440   12F2             hex_str_to_int:
2441   12F2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2442   12F5             ; int value = 0; 
2443   12F5 52 02 00      sub sp, 2
2444   12F8             ; --- START LOCAL VAR INITIALIZATION
2445   12F8 FA FF FF      lea d, [bp + -1] ; $value
2446   12FB DA            push d
2447   12FC FD 2E 00 00   mov32 cb, $00000000
2447   1300 00 00 
2448   1302 E7            pop d
2449   1303 FD 43         mov [d], b
2450   1305             ; --- END LOCAL VAR INITIALIZATION
2451   1305             ; int i; 
2452   1305 52 02 00      sub sp, 2
2453   1308             ; char hex_char; 
2454   1308 52 01 00      sub sp, 1
2455   130B             ; int len; 
2456   130B 52 02 00      sub sp, 2
2457   130E             ; len = strlen(hex_string); 
2458   130E FA FA FF      lea d, [bp + -6] ; $len
2459   1311 DA            push d
2460   1312             ; --- START FUNCTION CALL
2461   1312 FA 05 00      lea d, [bp + 5] ; $hex_string
2462   1315 2A            mov b, [d]
2463   1316 38 00 00      mov c, 0
2464   1319 FD AB         swp b
2465   131B D8            push b
2466   131C 07 02 06      call strlen
2467   131F 51 02 00      add sp, 2
2468   1322             ; --- END FUNCTION CALL
2469   1322 E7            pop d
2470   1323 FD 43         mov [d], b
2471   1325             ; for (i = 0; i < len; i++) { 
2472   1325             _for31_init:
2473   1325 FA FD FF      lea d, [bp + -3] ; $i
2474   1328 DA            push d
2475   1329 FD 2E 00 00   mov32 cb, $00000000
2475   132D 00 00 
2476   132F E7            pop d
2477   1330 FD 43         mov [d], b
2478   1332             _for31_cond:
2479   1332 FA FD FF      lea d, [bp + -3] ; $i
2480   1335 2A            mov b, [d]
2481   1336 38 00 00      mov c, 0
2482   1339             ; --- START RELATIONAL
2483   1339 D7            push a
2484   133A 11            mov a, b
2485   133B FA FA FF      lea d, [bp + -6] ; $len
2486   133E 2A            mov b, [d]
2487   133F 38 00 00      mov c, 0
2488   1342 B0            cmp a, b
2489   1343 FD 73         slt ; < (signed)
2490   1345 E4            pop a
2491   1346             ; --- END RELATIONAL
2492   1346 C0 00 00      cmp b, 0
2493   1349 C6 96 14      je _for31_exit
2494   134C             _for31_block:
2495   134C             ; hex_char = hex_string[i]; 
2496   134C FA FC FF      lea d, [bp + -4] ; $hex_char
2497   134F DA            push d
2498   1350 FA 05 00      lea d, [bp + 5] ; $hex_string
2499   1353 FD 2A         mov d, [d]
2500   1355 D7            push a
2501   1356 DA            push d
2502   1357 FA FD FF      lea d, [bp + -3] ; $i
2503   135A 2A            mov b, [d]
2504   135B 38 00 00      mov c, 0
2505   135E E7            pop d
2506   135F FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
2507   1363 E4            pop a
2508   1364 32            mov bl, [d]
2509   1365 A7 00         mov bh, 0
2510   1367 38 00 00      mov c, 0
2511   136A E7            pop d
2512   136B FD 3E         mov [d], bl
2513   136D             ; if (hex_char >= 'a' && hex_char <= 'f')  
2514   136D             _if32_cond:
2515   136D FA FC FF      lea d, [bp + -4] ; $hex_char
2516   1370 32            mov bl, [d]
2517   1371 A7 00         mov bh, 0
2518   1373 38 00 00      mov c, 0
2519   1376             ; --- START RELATIONAL
2520   1376 D7            push a
2521   1377 11            mov a, b
2522   1378 FD 2E 61 00   mov32 cb, $00000061
2522   137C 00 00 
2523   137E B0            cmp a, b
2524   137F FD 80         sge ; >=
2525   1381 E4            pop a
2526   1382             ; --- END RELATIONAL
2527   1382             ; --- START LOGICAL AND
2528   1382 D7            push a
2529   1383 11            mov a, b
2530   1384 FA FC FF      lea d, [bp + -4] ; $hex_char
2531   1387 32            mov bl, [d]
2532   1388 A7 00         mov bh, 0
2533   138A 38 00 00      mov c, 0
2534   138D             ; --- START RELATIONAL
2535   138D D7            push a
2536   138E 11            mov a, b
2537   138F FD 2E 66 00   mov32 cb, $00000066
2537   1393 00 00 
2538   1395 B0            cmp a, b
2539   1396 FD 74         sle ; <= (signed)
2540   1398 E4            pop a
2541   1399             ; --- END RELATIONAL
2542   1399 FD A7         sand a, b
2543   139B E4            pop a
2544   139C             ; --- END LOGICAL AND
2545   139C C0 00 00      cmp b, 0
2546   139F C6 DF 13      je _if32_else
2547   13A2             _if32_true:
2548   13A2             ; value = (value * 16) + (hex_char - 'a' + 10); 
2549   13A2 FA FF FF      lea d, [bp + -1] ; $value
2550   13A5 DA            push d
2551   13A6 FA FF FF      lea d, [bp + -1] ; $value
2552   13A9 2A            mov b, [d]
2553   13AA 38 00 00      mov c, 0
2554   13AD             ; --- START FACTORS
2555   13AD D7            push a
2556   13AE 11            mov a, b
2557   13AF FD 2E 10 00   mov32 cb, $00000010
2557   13B3 00 00 
2558   13B5 AC            mul a, b ; *
2559   13B6 11            mov a, b
2560   13B7 27            mov b, a
2561   13B8 E4            pop a
2562   13B9             ; --- END FACTORS
2563   13B9             ; --- START TERMS
2564   13B9 D7            push a
2565   13BA 11            mov a, b
2566   13BB FA FC FF      lea d, [bp + -4] ; $hex_char
2567   13BE 32            mov bl, [d]
2568   13BF A7 00         mov bh, 0
2569   13C1 38 00 00      mov c, 0
2570   13C4             ; --- START TERMS
2571   13C4 D7            push a
2572   13C5 11            mov a, b
2573   13C6 FD 2E 61 00   mov32 cb, $00000061
2573   13CA 00 00 
2574   13CC 60            sub a, b
2575   13CD 27            mov b, a
2576   13CE 11            mov a, b
2577   13CF FD 2E 0A 00   mov32 cb, $0000000a
2577   13D3 00 00 
2578   13D5 56            add b, a
2579   13D6 E4            pop a
2580   13D7             ; --- END TERMS
2581   13D7 56            add b, a
2582   13D8 E4            pop a
2583   13D9             ; --- END TERMS
2584   13D9 E7            pop d
2585   13DA FD 43         mov [d], b
2586   13DC 0A 83 14      jmp _if32_exit
2587   13DF             _if32_else:
2588   13DF             ; if (hex_char >= 'A' && hex_char <= 'F')  
2589   13DF             _if33_cond:
2590   13DF FA FC FF      lea d, [bp + -4] ; $hex_char
2591   13E2 32            mov bl, [d]
2592   13E3 A7 00         mov bh, 0
2593   13E5 38 00 00      mov c, 0
2594   13E8             ; --- START RELATIONAL
2595   13E8 D7            push a
2596   13E9 11            mov a, b
2597   13EA FD 2E 41 00   mov32 cb, $00000041
2597   13EE 00 00 
2598   13F0 B0            cmp a, b
2599   13F1 FD 80         sge ; >=
2600   13F3 E4            pop a
2601   13F4             ; --- END RELATIONAL
2602   13F4             ; --- START LOGICAL AND
2603   13F4 D7            push a
2604   13F5 11            mov a, b
2605   13F6 FA FC FF      lea d, [bp + -4] ; $hex_char
2606   13F9 32            mov bl, [d]
2607   13FA A7 00         mov bh, 0
2608   13FC 38 00 00      mov c, 0
2609   13FF             ; --- START RELATIONAL
2610   13FF D7            push a
2611   1400 11            mov a, b
2612   1401 FD 2E 46 00   mov32 cb, $00000046
2612   1405 00 00 
2613   1407 B0            cmp a, b
2614   1408 FD 74         sle ; <= (signed)
2615   140A E4            pop a
2616   140B             ; --- END RELATIONAL
2617   140B FD A7         sand a, b
2618   140D E4            pop a
2619   140E             ; --- END LOGICAL AND
2620   140E C0 00 00      cmp b, 0
2621   1411 C6 51 14      je _if33_else
2622   1414             _if33_true:
2623   1414             ; value = (value * 16) + (hex_char - 'A' + 10); 
2624   1414 FA FF FF      lea d, [bp + -1] ; $value
2625   1417 DA            push d
2626   1418 FA FF FF      lea d, [bp + -1] ; $value
2627   141B 2A            mov b, [d]
2628   141C 38 00 00      mov c, 0
2629   141F             ; --- START FACTORS
2630   141F D7            push a
2631   1420 11            mov a, b
2632   1421 FD 2E 10 00   mov32 cb, $00000010
2632   1425 00 00 
2633   1427 AC            mul a, b ; *
2634   1428 11            mov a, b
2635   1429 27            mov b, a
2636   142A E4            pop a
2637   142B             ; --- END FACTORS
2638   142B             ; --- START TERMS
2639   142B D7            push a
2640   142C 11            mov a, b
2641   142D FA FC FF      lea d, [bp + -4] ; $hex_char
2642   1430 32            mov bl, [d]
2643   1431 A7 00         mov bh, 0
2644   1433 38 00 00      mov c, 0
2645   1436             ; --- START TERMS
2646   1436 D7            push a
2647   1437 11            mov a, b
2648   1438 FD 2E 41 00   mov32 cb, $00000041
2648   143C 00 00 
2649   143E 60            sub a, b
2650   143F 27            mov b, a
2651   1440 11            mov a, b
2652   1441 FD 2E 0A 00   mov32 cb, $0000000a
2652   1445 00 00 
2653   1447 56            add b, a
2654   1448 E4            pop a
2655   1449             ; --- END TERMS
2656   1449 56            add b, a
2657   144A E4            pop a
2658   144B             ; --- END TERMS
2659   144B E7            pop d
2660   144C FD 43         mov [d], b
2661   144E 0A 83 14      jmp _if33_exit
2662   1451             _if33_else:
2663   1451             ; value = (value * 16) + (hex_char - '0'); 
2664   1451 FA FF FF      lea d, [bp + -1] ; $value
2665   1454 DA            push d
2666   1455 FA FF FF      lea d, [bp + -1] ; $value
2667   1458 2A            mov b, [d]
2668   1459 38 00 00      mov c, 0
2669   145C             ; --- START FACTORS
2670   145C D7            push a
2671   145D 11            mov a, b
2672   145E FD 2E 10 00   mov32 cb, $00000010
2672   1462 00 00 
2673   1464 AC            mul a, b ; *
2674   1465 11            mov a, b
2675   1466 27            mov b, a
2676   1467 E4            pop a
2677   1468             ; --- END FACTORS
2678   1468             ; --- START TERMS
2679   1468 D7            push a
2680   1469 11            mov a, b
2681   146A FA FC FF      lea d, [bp + -4] ; $hex_char
2682   146D 32            mov bl, [d]
2683   146E A7 00         mov bh, 0
2684   1470 38 00 00      mov c, 0
2685   1473             ; --- START TERMS
2686   1473 D7            push a
2687   1474 11            mov a, b
2688   1475 FD 2E 30 00   mov32 cb, $00000030
2688   1479 00 00 
2689   147B 60            sub a, b
2690   147C 27            mov b, a
2691   147D E4            pop a
2692   147E             ; --- END TERMS
2693   147E 56            add b, a
2694   147F E4            pop a
2695   1480             ; --- END TERMS
2696   1480 E7            pop d
2697   1481 FD 43         mov [d], b
2698   1483             _if33_exit:
2699   1483             _if32_exit:
2700   1483             _for31_update:
2701   1483 FA FD FF      lea d, [bp + -3] ; $i
2702   1486 2A            mov b, [d]
2703   1487 38 00 00      mov c, 0
2704   148A 11            mov a, b
2705   148B FD 77         inc b
2706   148D FA FD FF      lea d, [bp + -3] ; $i
2707   1490 FD 43         mov [d], b
2708   1492 27            mov b, a
2709   1493 0A 32 13      jmp _for31_cond
2710   1496             _for31_exit:
2711   1496             ; return value; 
2712   1496 FA FF FF      lea d, [bp + -1] ; $value
2713   1499 2A            mov b, [d]
2714   149A 38 00 00      mov c, 0
2715   149D F9            leave
2716   149E 09            ret
2717   149F             
2718   149F             gets:
2719   149F F8 00 00      enter 0 ; (push bp; mov bp, sp)
2720   14A2             
2721   14A2             ; --- BEGIN INLINE ASM SEGMENT
2722   14A2 FA 05 00      lea d, [bp + 5] ; $s
2723   14A5 15            mov a, [d]
2724   14A6 3C            mov d, a
2725   14A7 07 B6 1E      call _gets
2726   14AA             ; --- END INLINE ASM SEGMENT
2727   14AA             
2728   14AA             ; return strlen(s); 
2729   14AA             ; --- START FUNCTION CALL
2730   14AA FA 05 00      lea d, [bp + 5] ; $s
2731   14AD 2A            mov b, [d]
2732   14AE 38 00 00      mov c, 0
2733   14B1 FD AB         swp b
2734   14B3 D8            push b
2735   14B4 07 02 06      call strlen
2736   14B7 51 02 00      add sp, 2
2737   14BA             ; --- END FUNCTION CALL
2738   14BA F9            leave
2739   14BB 09            ret
2740   14BC             
2741   14BC             print_signed:
2742   14BC F8 00 00      enter 0 ; (push bp; mov bp, sp)
2743   14BF             ; char digits[5]; 
2744   14BF 52 05 00      sub sp, 5
2745   14C2             ; int i = 0; 
2746   14C2 52 02 00      sub sp, 2
2747   14C5             ; --- START LOCAL VAR INITIALIZATION
2748   14C5 FA FA FF      lea d, [bp + -6] ; $i
2749   14C8 DA            push d
2750   14C9 FD 2E 00 00   mov32 cb, $00000000
2750   14CD 00 00 
2751   14CF E7            pop d
2752   14D0 FD 43         mov [d], b
2753   14D2             ; --- END LOCAL VAR INITIALIZATION
2754   14D2             ; if (num < 0) { 
2755   14D2             _if34_cond:
2756   14D2 FA 05 00      lea d, [bp + 5] ; $num
2757   14D5 2A            mov b, [d]
2758   14D6 38 00 00      mov c, 0
2759   14D9             ; --- START RELATIONAL
2760   14D9 D7            push a
2761   14DA 11            mov a, b
2762   14DB FD 2E 00 00   mov32 cb, $00000000
2762   14DF 00 00 
2763   14E1 B0            cmp a, b
2764   14E2 FD 73         slt ; < (signed)
2765   14E4 E4            pop a
2766   14E5             ; --- END RELATIONAL
2767   14E5 C0 00 00      cmp b, 0
2768   14E8 C6 0B 15      je _if34_else
2769   14EB             _if34_true:
2770   14EB             ; putchar('-'); 
2771   14EB             ; --- START FUNCTION CALL
2772   14EB FD 2E 2D 00   mov32 cb, $0000002d
2772   14EF 00 00 
2773   14F1 DD            push bl
2774   14F2 07 A0 1C      call putchar
2775   14F5 51 01 00      add sp, 1
2776   14F8             ; --- END FUNCTION CALL
2777   14F8             ; num = -num; 
2778   14F8 FA 05 00      lea d, [bp + 5] ; $num
2779   14FB DA            push d
2780   14FC FA 05 00      lea d, [bp + 5] ; $num
2781   14FF 2A            mov b, [d]
2782   1500 38 00 00      mov c, 0
2783   1503 FD 97         neg b
2784   1505 E7            pop d
2785   1506 FD 43         mov [d], b
2786   1508 0A 36 15      jmp _if34_exit
2787   150B             _if34_else:
2788   150B             ; if (num == 0) { 
2789   150B             _if35_cond:
2790   150B FA 05 00      lea d, [bp + 5] ; $num
2791   150E 2A            mov b, [d]
2792   150F 38 00 00      mov c, 0
2793   1512             ; --- START RELATIONAL
2794   1512 D7            push a
2795   1513 11            mov a, b
2796   1514 FD 2E 00 00   mov32 cb, $00000000
2796   1518 00 00 
2797   151A B0            cmp a, b
2798   151B FD 71         seq ; ==
2799   151D E4            pop a
2800   151E             ; --- END RELATIONAL
2801   151E C0 00 00      cmp b, 0
2802   1521 C6 36 15      je _if35_exit
2803   1524             _if35_true:
2804   1524             ; putchar('0'); 
2805   1524             ; --- START FUNCTION CALL
2806   1524 FD 2E 30 00   mov32 cb, $00000030
2806   1528 00 00 
2807   152A DD            push bl
2808   152B 07 A0 1C      call putchar
2809   152E 51 01 00      add sp, 1
2810   1531             ; --- END FUNCTION CALL
2811   1531             ; return; 
2812   1531 F9            leave
2813   1532 09            ret
2814   1533 0A 36 15      jmp _if35_exit
2815   1536             _if35_exit:
2816   1536             _if34_exit:
2817   1536             ; while (num > 0) { 
2818   1536             _while36_cond:
2819   1536 FA 05 00      lea d, [bp + 5] ; $num
2820   1539 2A            mov b, [d]
2821   153A 38 00 00      mov c, 0
2822   153D             ; --- START RELATIONAL
2823   153D D7            push a
2824   153E 11            mov a, b
2825   153F FD 2E 00 00   mov32 cb, $00000000
2825   1543 00 00 
2826   1545 B0            cmp a, b
2827   1546 FD 7F         sgt ; >
2828   1548 E4            pop a
2829   1549             ; --- END RELATIONAL
2830   1549 C0 00 00      cmp b, 0
2831   154C C6 AB 15      je _while36_exit
2832   154F             _while36_block:
2833   154F             ; digits[i] = '0' + (num % 10); 
2834   154F FA FC FF      lea d, [bp + -4] ; $digits
2835   1552 D7            push a
2836   1553 DA            push d
2837   1554 FA FA FF      lea d, [bp + -6] ; $i
2838   1557 2A            mov b, [d]
2839   1558 38 00 00      mov c, 0
2840   155B E7            pop d
2841   155C 5A            add d, b
2842   155D E4            pop a
2843   155E DA            push d
2844   155F FD 2E 30 00   mov32 cb, $00000030
2844   1563 00 00 
2845   1565             ; --- START TERMS
2846   1565 D7            push a
2847   1566 11            mov a, b
2848   1567 FA 05 00      lea d, [bp + 5] ; $num
2849   156A 2A            mov b, [d]
2850   156B 38 00 00      mov c, 0
2851   156E             ; --- START FACTORS
2852   156E D7            push a
2853   156F 11            mov a, b
2854   1570 FD 2E 0A 00   mov32 cb, $0000000a
2854   1574 00 00 
2855   1576 AE            div a, b ; 
2856   1577 11            mov a, b
2857   1578 27            mov b, a
2858   1579 E4            pop a
2859   157A             ; --- END FACTORS
2860   157A 56            add b, a
2861   157B E4            pop a
2862   157C             ; --- END TERMS
2863   157C E7            pop d
2864   157D FD 3E         mov [d], bl
2865   157F             ; num = num / 10; 
2866   157F FA 05 00      lea d, [bp + 5] ; $num
2867   1582 DA            push d
2868   1583 FA 05 00      lea d, [bp + 5] ; $num
2869   1586 2A            mov b, [d]
2870   1587 38 00 00      mov c, 0
2871   158A             ; --- START FACTORS
2872   158A D7            push a
2873   158B 11            mov a, b
2874   158C FD 2E 0A 00   mov32 cb, $0000000a
2874   1590 00 00 
2875   1592 AE            div a, b
2876   1593 27            mov b, a
2877   1594 E4            pop a
2878   1595             ; --- END FACTORS
2879   1595 E7            pop d
2880   1596 FD 43         mov [d], b
2881   1598             ; i++; 
2882   1598 FA FA FF      lea d, [bp + -6] ; $i
2883   159B 2A            mov b, [d]
2884   159C 38 00 00      mov c, 0
2885   159F 11            mov a, b
2886   15A0 FD 77         inc b
2887   15A2 FA FA FF      lea d, [bp + -6] ; $i
2888   15A5 FD 43         mov [d], b
2889   15A7 27            mov b, a
2890   15A8 0A 36 15      jmp _while36_cond
2891   15AB             _while36_exit:
2892   15AB             ; while (i > 0) { 
2893   15AB             _while37_cond:
2894   15AB FA FA FF      lea d, [bp + -6] ; $i
2895   15AE 2A            mov b, [d]
2896   15AF 38 00 00      mov c, 0
2897   15B2             ; --- START RELATIONAL
2898   15B2 D7            push a
2899   15B3 11            mov a, b
2900   15B4 FD 2E 00 00   mov32 cb, $00000000
2900   15B8 00 00 
2901   15BA B0            cmp a, b
2902   15BB FD 7F         sgt ; >
2903   15BD E4            pop a
2904   15BE             ; --- END RELATIONAL
2905   15BE C0 00 00      cmp b, 0
2906   15C1 C6 F3 15      je _while37_exit
2907   15C4             _while37_block:
2908   15C4             ; i--; 
2909   15C4 FA FA FF      lea d, [bp + -6] ; $i
2910   15C7 2A            mov b, [d]
2911   15C8 38 00 00      mov c, 0
2912   15CB FD 7D         dec b
2913   15CD FA FA FF      lea d, [bp + -6] ; $i
2914   15D0 FD 43         mov [d], b
2915   15D2 FD 77         inc b
2916   15D4             ; putchar(digits[i]); 
2917   15D4             ; --- START FUNCTION CALL
2918   15D4 FA FC FF      lea d, [bp + -4] ; $digits
2919   15D7 D7            push a
2920   15D8 DA            push d
2921   15D9 FA FA FF      lea d, [bp + -6] ; $i
2922   15DC 2A            mov b, [d]
2923   15DD 38 00 00      mov c, 0
2924   15E0 E7            pop d
2925   15E1 5A            add d, b
2926   15E2 E4            pop a
2927   15E3 32            mov bl, [d]
2928   15E4 A7 00         mov bh, 0
2929   15E6 38 00 00      mov c, 0
2930   15E9 DD            push bl
2931   15EA 07 A0 1C      call putchar
2932   15ED 51 01 00      add sp, 1
2933   15F0             ; --- END FUNCTION CALL
2934   15F0 0A AB 15      jmp _while37_cond
2935   15F3             _while37_exit:
2936   15F3 F9            leave
2937   15F4 09            ret
2938   15F5             
2939   15F5             print_signed_long:
2940   15F5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2941   15F8             ; char digits[10]; 
2942   15F8 52 0A 00      sub sp, 10
2943   15FB             ; int i = 0; 
2944   15FB 52 02 00      sub sp, 2
2945   15FE             ; --- START LOCAL VAR INITIALIZATION
2946   15FE FA F5 FF      lea d, [bp + -11] ; $i
2947   1601 DA            push d
2948   1602 FD 2E 00 00   mov32 cb, $00000000
2948   1606 00 00 
2949   1608 E7            pop d
2950   1609 FD 43         mov [d], b
2951   160B             ; --- END LOCAL VAR INITIALIZATION
2952   160B             ; if (num < 0) { 
2953   160B             _if38_cond:
2954   160B FA 05 00      lea d, [bp + 5] ; $num
2955   160E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2956   1611 FD 39         mov c, b ; And place it into C
2957   1613 2A            mov b, [d] ; Lower Word in B
2958   1614             ; --- START RELATIONAL
2959   1614 D7            push a
2960   1615 FD D8         push g
2961   1617 11            mov a, b
2962   1618 FD 7A         mov g, c
2963   161A FD 2E 00 00   mov32 cb, $00000000
2963   161E 00 00 
2964   1620 FD AF         cmp32 ga, cb
2965   1622 FD 73         slt ; <
2966   1624 FD F1         pop g
2967   1626 E4            pop a
2968   1627             ; --- END RELATIONAL
2969   1627 C0 00 00      cmp b, 0
2970   162A C6 5E 16      je _if38_else
2971   162D             _if38_true:
2972   162D             ; putchar('-'); 
2973   162D             ; --- START FUNCTION CALL
2974   162D FD 2E 2D 00   mov32 cb, $0000002d
2974   1631 00 00 
2975   1633 DD            push bl
2976   1634 07 A0 1C      call putchar
2977   1637 51 01 00      add sp, 1
2978   163A             ; --- END FUNCTION CALL
2979   163A             ; num = -num; 
2980   163A FA 05 00      lea d, [bp + 5] ; $num
2981   163D DA            push d
2982   163E FA 05 00      lea d, [bp + 5] ; $num
2983   1641 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2984   1644 FD 39         mov c, b ; And place it into C
2985   1646 2A            mov b, [d] ; Lower Word in B
2986   1647 12            mov a, c
2987   1648 95            not a
2988   1649 97            not b
2989   164A 55 01 00      add b, 1
2990   164D 5B 00 00      adc a, 0
2991   1650 39            mov c, a
2992   1651 E7            pop d
2993   1652 FD 43         mov [d], b
2994   1654 26 00 00      mov b, 0
2995   1657 FD 44 02 00   mov [d + 2], b
2996   165B 0A 92 16      jmp _if38_exit
2997   165E             _if38_else:
2998   165E             ; if (num == 0) { 
2999   165E             _if39_cond:
3000   165E FA 05 00      lea d, [bp + 5] ; $num
3001   1661 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3002   1664 FD 39         mov c, b ; And place it into C
3003   1666 2A            mov b, [d] ; Lower Word in B
3004   1667             ; --- START RELATIONAL
3005   1667 D7            push a
3006   1668 FD D8         push g
3007   166A 11            mov a, b
3008   166B FD 7A         mov g, c
3009   166D FD 2E 00 00   mov32 cb, $00000000
3009   1671 00 00 
3010   1673 FD AF         cmp32 ga, cb
3011   1675 FD 71         seq ; ==
3012   1677 FD F1         pop g
3013   1679 E4            pop a
3014   167A             ; --- END RELATIONAL
3015   167A C0 00 00      cmp b, 0
3016   167D C6 92 16      je _if39_exit
3017   1680             _if39_true:
3018   1680             ; putchar('0'); 
3019   1680             ; --- START FUNCTION CALL
3020   1680 FD 2E 30 00   mov32 cb, $00000030
3020   1684 00 00 
3021   1686 DD            push bl
3022   1687 07 A0 1C      call putchar
3023   168A 51 01 00      add sp, 1
3024   168D             ; --- END FUNCTION CALL
3025   168D             ; return; 
3026   168D F9            leave
3027   168E 09            ret
3028   168F 0A 92 16      jmp _if39_exit
3029   1692             _if39_exit:
3030   1692             _if38_exit:
3031   1692             ; while (num > 0) { 
3032   1692             _while40_cond:
3033   1692 FA 05 00      lea d, [bp + 5] ; $num
3034   1695 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3035   1698 FD 39         mov c, b ; And place it into C
3036   169A 2A            mov b, [d] ; Lower Word in B
3037   169B             ; --- START RELATIONAL
3038   169B D7            push a
3039   169C FD D8         push g
3040   169E 11            mov a, b
3041   169F FD 7A         mov g, c
3042   16A1 FD 2E 00 00   mov32 cb, $00000000
3042   16A5 00 00 
3043   16A7 FD AF         cmp32 ga, cb
3044   16A9 FD 7F         sgt
3045   16AB FD F1         pop g
3046   16AD E4            pop a
3047   16AE             ; --- END RELATIONAL
3048   16AE C0 00 00      cmp b, 0
3049   16B1 C6 1A 17      je _while40_exit
3050   16B4             _while40_block:
3051   16B4             ; digits[i] = '0' + (num % 10); 
3052   16B4 FA F7 FF      lea d, [bp + -9] ; $digits
3053   16B7 D7            push a
3054   16B8 DA            push d
3055   16B9 FA F5 FF      lea d, [bp + -11] ; $i
3056   16BC 2A            mov b, [d]
3057   16BD 38 00 00      mov c, 0
3058   16C0 E7            pop d
3059   16C1 5A            add d, b
3060   16C2 E4            pop a
3061   16C3 DA            push d
3062   16C4 FD 2E 30 00   mov32 cb, $00000030
3062   16C8 00 00 
3063   16CA             ; --- START TERMS
3064   16CA D7            push a
3065   16CB 11            mov a, b
3066   16CC FA 05 00      lea d, [bp + 5] ; $num
3067   16CF 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3068   16D2 FD 39         mov c, b ; And place it into C
3069   16D4 2A            mov b, [d] ; Lower Word in B
3070   16D5             ; --- START FACTORS
3071   16D5 D7            push a
3072   16D6 11            mov a, b
3073   16D7 FD 2E 0A 00   mov32 cb, $0000000a
3073   16DB 00 00 
3074   16DD AE            div a, b ; 
3075   16DE 11            mov a, b
3076   16DF 27            mov b, a
3077   16E0 E4            pop a
3078   16E1             ; --- END FACTORS
3079   16E1 FD 15         add32 cb, ga
3080   16E3 E4            pop a
3081   16E4             ; --- END TERMS
3082   16E4 E7            pop d
3083   16E5 FD 3E         mov [d], bl
3084   16E7             ; num = num / 10; 
3085   16E7 FA 05 00      lea d, [bp + 5] ; $num
3086   16EA DA            push d
3087   16EB FA 05 00      lea d, [bp + 5] ; $num
3088   16EE 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3089   16F1 FD 39         mov c, b ; And place it into C
3090   16F3 2A            mov b, [d] ; Lower Word in B
3091   16F4             ; --- START FACTORS
3092   16F4 D7            push a
3093   16F5 11            mov a, b
3094   16F6 FD 2E 0A 00   mov32 cb, $0000000a
3094   16FA 00 00 
3095   16FC AE            div a, b
3096   16FD 27            mov b, a
3097   16FE E4            pop a
3098   16FF             ; --- END FACTORS
3099   16FF E7            pop d
3100   1700 FD 43         mov [d], b
3101   1702 28            mov b, c
3102   1703 FD 44 02 00   mov [d + 2], b
3103   1707             ; i++; 
3104   1707 FA F5 FF      lea d, [bp + -11] ; $i
3105   170A 2A            mov b, [d]
3106   170B 38 00 00      mov c, 0
3107   170E 11            mov a, b
3108   170F FD 77         inc b
3109   1711 FA F5 FF      lea d, [bp + -11] ; $i
3110   1714 FD 43         mov [d], b
3111   1716 27            mov b, a
3112   1717 0A 92 16      jmp _while40_cond
3113   171A             _while40_exit:
3114   171A             ; while (i > 0) { 
3115   171A             _while41_cond:
3116   171A FA F5 FF      lea d, [bp + -11] ; $i
3117   171D 2A            mov b, [d]
3118   171E 38 00 00      mov c, 0
3119   1721             ; --- START RELATIONAL
3120   1721 D7            push a
3121   1722 11            mov a, b
3122   1723 FD 2E 00 00   mov32 cb, $00000000
3122   1727 00 00 
3123   1729 B0            cmp a, b
3124   172A FD 7F         sgt ; >
3125   172C E4            pop a
3126   172D             ; --- END RELATIONAL
3127   172D C0 00 00      cmp b, 0
3128   1730 C6 62 17      je _while41_exit
3129   1733             _while41_block:
3130   1733             ; i--; 
3131   1733 FA F5 FF      lea d, [bp + -11] ; $i
3132   1736 2A            mov b, [d]
3133   1737 38 00 00      mov c, 0
3134   173A FD 7D         dec b
3135   173C FA F5 FF      lea d, [bp + -11] ; $i
3136   173F FD 43         mov [d], b
3137   1741 FD 77         inc b
3138   1743             ; putchar(digits[i]); 
3139   1743             ; --- START FUNCTION CALL
3140   1743 FA F7 FF      lea d, [bp + -9] ; $digits
3141   1746 D7            push a
3142   1747 DA            push d
3143   1748 FA F5 FF      lea d, [bp + -11] ; $i
3144   174B 2A            mov b, [d]
3145   174C 38 00 00      mov c, 0
3146   174F E7            pop d
3147   1750 5A            add d, b
3148   1751 E4            pop a
3149   1752 32            mov bl, [d]
3150   1753 A7 00         mov bh, 0
3151   1755 38 00 00      mov c, 0
3152   1758 DD            push bl
3153   1759 07 A0 1C      call putchar
3154   175C 51 01 00      add sp, 1
3155   175F             ; --- END FUNCTION CALL
3156   175F 0A 1A 17      jmp _while41_cond
3157   1762             _while41_exit:
3158   1762 F9            leave
3159   1763 09            ret
3160   1764             
3161   1764             print_unsigned_long:
3162   1764 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3163   1767             ; char digits[10]; 
3164   1767 52 0A 00      sub sp, 10
3165   176A             ; int i; 
3166   176A 52 02 00      sub sp, 2
3167   176D             ; i = 0; 
3168   176D FA F5 FF      lea d, [bp + -11] ; $i
3169   1770 DA            push d
3170   1771 FD 2E 00 00   mov32 cb, $00000000
3170   1775 00 00 
3171   1777 E7            pop d
3172   1778 FD 43         mov [d], b
3173   177A             ; if(num == 0){ 
3174   177A             _if42_cond:
3175   177A FA 05 00      lea d, [bp + 5] ; $num
3176   177D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3177   1780 FD 39         mov c, b ; And place it into C
3178   1782 2A            mov b, [d] ; Lower Word in B
3179   1783             ; --- START RELATIONAL
3180   1783 D7            push a
3181   1784 FD D8         push g
3182   1786 11            mov a, b
3183   1787 FD 7A         mov g, c
3184   1789 FD 2E 00 00   mov32 cb, $00000000
3184   178D 00 00 
3185   178F FD AF         cmp32 ga, cb
3186   1791 FD 71         seq ; ==
3187   1793 FD F1         pop g
3188   1795 E4            pop a
3189   1796             ; --- END RELATIONAL
3190   1796 C0 00 00      cmp b, 0
3191   1799 C6 AE 17      je _if42_exit
3192   179C             _if42_true:
3193   179C             ; putchar('0'); 
3194   179C             ; --- START FUNCTION CALL
3195   179C FD 2E 30 00   mov32 cb, $00000030
3195   17A0 00 00 
3196   17A2 DD            push bl
3197   17A3 07 A0 1C      call putchar
3198   17A6 51 01 00      add sp, 1
3199   17A9             ; --- END FUNCTION CALL
3200   17A9             ; return; 
3201   17A9 F9            leave
3202   17AA 09            ret
3203   17AB 0A AE 17      jmp _if42_exit
3204   17AE             _if42_exit:
3205   17AE             ; while (num > 0) { 
3206   17AE             _while43_cond:
3207   17AE FA 05 00      lea d, [bp + 5] ; $num
3208   17B1 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3209   17B4 FD 39         mov c, b ; And place it into C
3210   17B6 2A            mov b, [d] ; Lower Word in B
3211   17B7             ; --- START RELATIONAL
3212   17B7 D7            push a
3213   17B8 FD D8         push g
3214   17BA 11            mov a, b
3215   17BB FD 7A         mov g, c
3216   17BD FD 2E 00 00   mov32 cb, $00000000
3216   17C1 00 00 
3217   17C3 FD AF         cmp32 ga, cb
3218   17C5 FD 81         sgu
3219   17C7 FD F1         pop g
3220   17C9 E4            pop a
3221   17CA             ; --- END RELATIONAL
3222   17CA C0 00 00      cmp b, 0
3223   17CD C6 36 18      je _while43_exit
3224   17D0             _while43_block:
3225   17D0             ; digits[i] = '0' + (num % 10); 
3226   17D0 FA F7 FF      lea d, [bp + -9] ; $digits
3227   17D3 D7            push a
3228   17D4 DA            push d
3229   17D5 FA F5 FF      lea d, [bp + -11] ; $i
3230   17D8 2A            mov b, [d]
3231   17D9 38 00 00      mov c, 0
3232   17DC E7            pop d
3233   17DD 5A            add d, b
3234   17DE E4            pop a
3235   17DF DA            push d
3236   17E0 FD 2E 30 00   mov32 cb, $00000030
3236   17E4 00 00 
3237   17E6             ; --- START TERMS
3238   17E6 D7            push a
3239   17E7 11            mov a, b
3240   17E8 FA 05 00      lea d, [bp + 5] ; $num
3241   17EB 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3242   17EE FD 39         mov c, b ; And place it into C
3243   17F0 2A            mov b, [d] ; Lower Word in B
3244   17F1             ; --- START FACTORS
3245   17F1 D7            push a
3246   17F2 11            mov a, b
3247   17F3 FD 2E 0A 00   mov32 cb, $0000000a
3247   17F7 00 00 
3248   17F9 AE            div a, b ; 
3249   17FA 11            mov a, b
3250   17FB 27            mov b, a
3251   17FC E4            pop a
3252   17FD             ; --- END FACTORS
3253   17FD FD 15         add32 cb, ga
3254   17FF E4            pop a
3255   1800             ; --- END TERMS
3256   1800 E7            pop d
3257   1801 FD 3E         mov [d], bl
3258   1803             ; num = num / 10; 
3259   1803 FA 05 00      lea d, [bp + 5] ; $num
3260   1806 DA            push d
3261   1807 FA 05 00      lea d, [bp + 5] ; $num
3262   180A 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3263   180D FD 39         mov c, b ; And place it into C
3264   180F 2A            mov b, [d] ; Lower Word in B
3265   1810             ; --- START FACTORS
3266   1810 D7            push a
3267   1811 11            mov a, b
3268   1812 FD 2E 0A 00   mov32 cb, $0000000a
3268   1816 00 00 
3269   1818 AE            div a, b
3270   1819 27            mov b, a
3271   181A E4            pop a
3272   181B             ; --- END FACTORS
3273   181B E7            pop d
3274   181C FD 43         mov [d], b
3275   181E 28            mov b, c
3276   181F FD 44 02 00   mov [d + 2], b
3277   1823             ; i++; 
3278   1823 FA F5 FF      lea d, [bp + -11] ; $i
3279   1826 2A            mov b, [d]
3280   1827 38 00 00      mov c, 0
3281   182A 11            mov a, b
3282   182B FD 77         inc b
3283   182D FA F5 FF      lea d, [bp + -11] ; $i
3284   1830 FD 43         mov [d], b
3285   1832 27            mov b, a
3286   1833 0A AE 17      jmp _while43_cond
3287   1836             _while43_exit:
3288   1836             ; while (i > 0) { 
3289   1836             _while44_cond:
3290   1836 FA F5 FF      lea d, [bp + -11] ; $i
3291   1839 2A            mov b, [d]
3292   183A 38 00 00      mov c, 0
3293   183D             ; --- START RELATIONAL
3294   183D D7            push a
3295   183E 11            mov a, b
3296   183F FD 2E 00 00   mov32 cb, $00000000
3296   1843 00 00 
3297   1845 B0            cmp a, b
3298   1846 FD 7F         sgt ; >
3299   1848 E4            pop a
3300   1849             ; --- END RELATIONAL
3301   1849 C0 00 00      cmp b, 0
3302   184C C6 7E 18      je _while44_exit
3303   184F             _while44_block:
3304   184F             ; i--; 
3305   184F FA F5 FF      lea d, [bp + -11] ; $i
3306   1852 2A            mov b, [d]
3307   1853 38 00 00      mov c, 0
3308   1856 FD 7D         dec b
3309   1858 FA F5 FF      lea d, [bp + -11] ; $i
3310   185B FD 43         mov [d], b
3311   185D FD 77         inc b
3312   185F             ; putchar(digits[i]); 
3313   185F             ; --- START FUNCTION CALL
3314   185F FA F7 FF      lea d, [bp + -9] ; $digits
3315   1862 D7            push a
3316   1863 DA            push d
3317   1864 FA F5 FF      lea d, [bp + -11] ; $i
3318   1867 2A            mov b, [d]
3319   1868 38 00 00      mov c, 0
3320   186B E7            pop d
3321   186C 5A            add d, b
3322   186D E4            pop a
3323   186E 32            mov bl, [d]
3324   186F A7 00         mov bh, 0
3325   1871 38 00 00      mov c, 0
3326   1874 DD            push bl
3327   1875 07 A0 1C      call putchar
3328   1878 51 01 00      add sp, 1
3329   187B             ; --- END FUNCTION CALL
3330   187B 0A 36 18      jmp _while44_cond
3331   187E             _while44_exit:
3332   187E F9            leave
3333   187F 09            ret
3334   1880             
3335   1880             sprint_unsigned:
3336   1880 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3337   1883             ; char digits[5]; 
3338   1883 52 05 00      sub sp, 5
3339   1886             ; int i; 
3340   1886 52 02 00      sub sp, 2
3341   1889             ; int len = 0; 
3342   1889 52 02 00      sub sp, 2
3343   188C             ; --- START LOCAL VAR INITIALIZATION
3344   188C FA F8 FF      lea d, [bp + -8] ; $len
3345   188F DA            push d
3346   1890 FD 2E 00 00   mov32 cb, $00000000
3346   1894 00 00 
3347   1896 E7            pop d
3348   1897 FD 43         mov [d], b
3349   1899             ; --- END LOCAL VAR INITIALIZATION
3350   1899             ; i = 0; 
3351   1899 FA FA FF      lea d, [bp + -6] ; $i
3352   189C DA            push d
3353   189D FD 2E 00 00   mov32 cb, $00000000
3353   18A1 00 00 
3354   18A3 E7            pop d
3355   18A4 FD 43         mov [d], b
3356   18A6             ; if(num == 0){ 
3357   18A6             _if45_cond:
3358   18A6 FA 07 00      lea d, [bp + 7] ; $num
3359   18A9 2A            mov b, [d]
3360   18AA 38 00 00      mov c, 0
3361   18AD             ; --- START RELATIONAL
3362   18AD D7            push a
3363   18AE 11            mov a, b
3364   18AF FD 2E 00 00   mov32 cb, $00000000
3364   18B3 00 00 
3365   18B5 B0            cmp a, b
3366   18B6 FD 71         seq ; ==
3367   18B8 E4            pop a
3368   18B9             ; --- END RELATIONAL
3369   18B9 C0 00 00      cmp b, 0
3370   18BC C6 E4 18      je _if45_exit
3371   18BF             _if45_true:
3372   18BF             ; *dest++ = '0'; 
3373   18BF FA 05 00      lea d, [bp + 5] ; $dest
3374   18C2 2A            mov b, [d]
3375   18C3 38 00 00      mov c, 0
3376   18C6 FD 77         inc b
3377   18C8 FA 05 00      lea d, [bp + 5] ; $dest
3378   18CB FD 3E         mov [d], bl
3379   18CD FD 7D         dec b
3380   18CF D8            push b
3381   18D0 FD 2E 30 00   mov32 cb, $00000030
3381   18D4 00 00 
3382   18D6 E7            pop d
3383   18D7 FD 3E         mov [d], bl
3384   18D9             ; return 1; 
3385   18D9 FD 2E 01 00   mov32 cb, $00000001
3385   18DD 00 00 
3386   18DF F9            leave
3387   18E0 09            ret
3388   18E1 0A E4 18      jmp _if45_exit
3389   18E4             _if45_exit:
3390   18E4             ; while (num > 0) { 
3391   18E4             _while46_cond:
3392   18E4 FA 07 00      lea d, [bp + 7] ; $num
3393   18E7 2A            mov b, [d]
3394   18E8 38 00 00      mov c, 0
3395   18EB             ; --- START RELATIONAL
3396   18EB D7            push a
3397   18EC 11            mov a, b
3398   18ED FD 2E 00 00   mov32 cb, $00000000
3398   18F1 00 00 
3399   18F3 B0            cmp a, b
3400   18F4 FD 81         sgu ; > (unsigned)
3401   18F6 E4            pop a
3402   18F7             ; --- END RELATIONAL
3403   18F7 C0 00 00      cmp b, 0
3404   18FA C6 59 19      je _while46_exit
3405   18FD             _while46_block:
3406   18FD             ; digits[i] = '0' + (num % 10); 
3407   18FD FA FC FF      lea d, [bp + -4] ; $digits
3408   1900 D7            push a
3409   1901 DA            push d
3410   1902 FA FA FF      lea d, [bp + -6] ; $i
3411   1905 2A            mov b, [d]
3412   1906 38 00 00      mov c, 0
3413   1909 E7            pop d
3414   190A 5A            add d, b
3415   190B E4            pop a
3416   190C DA            push d
3417   190D FD 2E 30 00   mov32 cb, $00000030
3417   1911 00 00 
3418   1913             ; --- START TERMS
3419   1913 D7            push a
3420   1914 11            mov a, b
3421   1915 FA 07 00      lea d, [bp + 7] ; $num
3422   1918 2A            mov b, [d]
3423   1919 38 00 00      mov c, 0
3424   191C             ; --- START FACTORS
3425   191C D7            push a
3426   191D 11            mov a, b
3427   191E FD 2E 0A 00   mov32 cb, $0000000a
3427   1922 00 00 
3428   1924 AE            div a, b ; 
3429   1925 11            mov a, b
3430   1926 27            mov b, a
3431   1927 E4            pop a
3432   1928             ; --- END FACTORS
3433   1928 56            add b, a
3434   1929 E4            pop a
3435   192A             ; --- END TERMS
3436   192A E7            pop d
3437   192B FD 3E         mov [d], bl
3438   192D             ; num = num / 10; 
3439   192D FA 07 00      lea d, [bp + 7] ; $num
3440   1930 DA            push d
3441   1931 FA 07 00      lea d, [bp + 7] ; $num
3442   1934 2A            mov b, [d]
3443   1935 38 00 00      mov c, 0
3444   1938             ; --- START FACTORS
3445   1938 D7            push a
3446   1939 11            mov a, b
3447   193A FD 2E 0A 00   mov32 cb, $0000000a
3447   193E 00 00 
3448   1940 AE            div a, b
3449   1941 27            mov b, a
3450   1942 E4            pop a
3451   1943             ; --- END FACTORS
3452   1943 E7            pop d
3453   1944 FD 43         mov [d], b
3454   1946             ; i++; 
3455   1946 FA FA FF      lea d, [bp + -6] ; $i
3456   1949 2A            mov b, [d]
3457   194A 38 00 00      mov c, 0
3458   194D 11            mov a, b
3459   194E FD 77         inc b
3460   1950 FA FA FF      lea d, [bp + -6] ; $i
3461   1953 FD 43         mov [d], b
3462   1955 27            mov b, a
3463   1956 0A E4 18      jmp _while46_cond
3464   1959             _while46_exit:
3465   1959             ; while (i > 0) { 
3466   1959             _while47_cond:
3467   1959 FA FA FF      lea d, [bp + -6] ; $i
3468   195C 2A            mov b, [d]
3469   195D 38 00 00      mov c, 0
3470   1960             ; --- START RELATIONAL
3471   1960 D7            push a
3472   1961 11            mov a, b
3473   1962 FD 2E 00 00   mov32 cb, $00000000
3473   1966 00 00 
3474   1968 B0            cmp a, b
3475   1969 FD 7F         sgt ; >
3476   196B E4            pop a
3477   196C             ; --- END RELATIONAL
3478   196C C0 00 00      cmp b, 0
3479   196F C6 BE 19      je _while47_exit
3480   1972             _while47_block:
3481   1972             ; i--; 
3482   1972 FA FA FF      lea d, [bp + -6] ; $i
3483   1975 2A            mov b, [d]
3484   1976 38 00 00      mov c, 0
3485   1979 FD 7D         dec b
3486   197B FA FA FF      lea d, [bp + -6] ; $i
3487   197E FD 43         mov [d], b
3488   1980 FD 77         inc b
3489   1982             ; *dest++ = digits[i]; 
3490   1982 FA 05 00      lea d, [bp + 5] ; $dest
3491   1985 2A            mov b, [d]
3492   1986 38 00 00      mov c, 0
3493   1989 FD 77         inc b
3494   198B FA 05 00      lea d, [bp + 5] ; $dest
3495   198E FD 3E         mov [d], bl
3496   1990 FD 7D         dec b
3497   1992 D8            push b
3498   1993 FA FC FF      lea d, [bp + -4] ; $digits
3499   1996 D7            push a
3500   1997 DA            push d
3501   1998 FA FA FF      lea d, [bp + -6] ; $i
3502   199B 2A            mov b, [d]
3503   199C 38 00 00      mov c, 0
3504   199F E7            pop d
3505   19A0 5A            add d, b
3506   19A1 E4            pop a
3507   19A2 32            mov bl, [d]
3508   19A3 A7 00         mov bh, 0
3509   19A5 38 00 00      mov c, 0
3510   19A8 E7            pop d
3511   19A9 FD 3E         mov [d], bl
3512   19AB             ; len++; 
3513   19AB FA F8 FF      lea d, [bp + -8] ; $len
3514   19AE 2A            mov b, [d]
3515   19AF 38 00 00      mov c, 0
3516   19B2 11            mov a, b
3517   19B3 FD 77         inc b
3518   19B5 FA F8 FF      lea d, [bp + -8] ; $len
3519   19B8 FD 43         mov [d], b
3520   19BA 27            mov b, a
3521   19BB 0A 59 19      jmp _while47_cond
3522   19BE             _while47_exit:
3523   19BE             ; *dest = '\0'; 
3524   19BE FA 05 00      lea d, [bp + 5] ; $dest
3525   19C1 2A            mov b, [d]
3526   19C2 38 00 00      mov c, 0
3527   19C5 D8            push b
3528   19C6 FD 2E 00 00   mov32 cb, $00000000
3528   19CA 00 00 
3529   19CC E7            pop d
3530   19CD FD 3E         mov [d], bl
3531   19CF             ; return len; 
3532   19CF FA F8 FF      lea d, [bp + -8] ; $len
3533   19D2 2A            mov b, [d]
3534   19D3 38 00 00      mov c, 0
3535   19D6 F9            leave
3536   19D7 09            ret
3537   19D8             
3538   19D8             print_unsigned:
3539   19D8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3540   19DB             ; char digits[5]; 
3541   19DB 52 05 00      sub sp, 5
3542   19DE             ; int i; 
3543   19DE 52 02 00      sub sp, 2
3544   19E1             ; i = 0; 
3545   19E1 FA FA FF      lea d, [bp + -6] ; $i
3546   19E4 DA            push d
3547   19E5 FD 2E 00 00   mov32 cb, $00000000
3547   19E9 00 00 
3548   19EB E7            pop d
3549   19EC FD 43         mov [d], b
3550   19EE             ; if(num == 0){ 
3551   19EE             _if48_cond:
3552   19EE FA 05 00      lea d, [bp + 5] ; $num
3553   19F1 2A            mov b, [d]
3554   19F2 38 00 00      mov c, 0
3555   19F5             ; --- START RELATIONAL
3556   19F5 D7            push a
3557   19F6 11            mov a, b
3558   19F7 FD 2E 00 00   mov32 cb, $00000000
3558   19FB 00 00 
3559   19FD B0            cmp a, b
3560   19FE FD 71         seq ; ==
3561   1A00 E4            pop a
3562   1A01             ; --- END RELATIONAL
3563   1A01 C0 00 00      cmp b, 0
3564   1A04 C6 19 1A      je _if48_exit
3565   1A07             _if48_true:
3566   1A07             ; putchar('0'); 
3567   1A07             ; --- START FUNCTION CALL
3568   1A07 FD 2E 30 00   mov32 cb, $00000030
3568   1A0B 00 00 
3569   1A0D DD            push bl
3570   1A0E 07 A0 1C      call putchar
3571   1A11 51 01 00      add sp, 1
3572   1A14             ; --- END FUNCTION CALL
3573   1A14             ; return; 
3574   1A14 F9            leave
3575   1A15 09            ret
3576   1A16 0A 19 1A      jmp _if48_exit
3577   1A19             _if48_exit:
3578   1A19             ; while (num > 0) { 
3579   1A19             _while49_cond:
3580   1A19 FA 05 00      lea d, [bp + 5] ; $num
3581   1A1C 2A            mov b, [d]
3582   1A1D 38 00 00      mov c, 0
3583   1A20             ; --- START RELATIONAL
3584   1A20 D7            push a
3585   1A21 11            mov a, b
3586   1A22 FD 2E 00 00   mov32 cb, $00000000
3586   1A26 00 00 
3587   1A28 B0            cmp a, b
3588   1A29 FD 81         sgu ; > (unsigned)
3589   1A2B E4            pop a
3590   1A2C             ; --- END RELATIONAL
3591   1A2C C0 00 00      cmp b, 0
3592   1A2F C6 8E 1A      je _while49_exit
3593   1A32             _while49_block:
3594   1A32             ; digits[i] = '0' + (num % 10); 
3595   1A32 FA FC FF      lea d, [bp + -4] ; $digits
3596   1A35 D7            push a
3597   1A36 DA            push d
3598   1A37 FA FA FF      lea d, [bp + -6] ; $i
3599   1A3A 2A            mov b, [d]
3600   1A3B 38 00 00      mov c, 0
3601   1A3E E7            pop d
3602   1A3F 5A            add d, b
3603   1A40 E4            pop a
3604   1A41 DA            push d
3605   1A42 FD 2E 30 00   mov32 cb, $00000030
3605   1A46 00 00 
3606   1A48             ; --- START TERMS
3607   1A48 D7            push a
3608   1A49 11            mov a, b
3609   1A4A FA 05 00      lea d, [bp + 5] ; $num
3610   1A4D 2A            mov b, [d]
3611   1A4E 38 00 00      mov c, 0
3612   1A51             ; --- START FACTORS
3613   1A51 D7            push a
3614   1A52 11            mov a, b
3615   1A53 FD 2E 0A 00   mov32 cb, $0000000a
3615   1A57 00 00 
3616   1A59 AE            div a, b ; 
3617   1A5A 11            mov a, b
3618   1A5B 27            mov b, a
3619   1A5C E4            pop a
3620   1A5D             ; --- END FACTORS
3621   1A5D 56            add b, a
3622   1A5E E4            pop a
3623   1A5F             ; --- END TERMS
3624   1A5F E7            pop d
3625   1A60 FD 3E         mov [d], bl
3626   1A62             ; num = num / 10; 
3627   1A62 FA 05 00      lea d, [bp + 5] ; $num
3628   1A65 DA            push d
3629   1A66 FA 05 00      lea d, [bp + 5] ; $num
3630   1A69 2A            mov b, [d]
3631   1A6A 38 00 00      mov c, 0
3632   1A6D             ; --- START FACTORS
3633   1A6D D7            push a
3634   1A6E 11            mov a, b
3635   1A6F FD 2E 0A 00   mov32 cb, $0000000a
3635   1A73 00 00 
3636   1A75 AE            div a, b
3637   1A76 27            mov b, a
3638   1A77 E4            pop a
3639   1A78             ; --- END FACTORS
3640   1A78 E7            pop d
3641   1A79 FD 43         mov [d], b
3642   1A7B             ; i++; 
3643   1A7B FA FA FF      lea d, [bp + -6] ; $i
3644   1A7E 2A            mov b, [d]
3645   1A7F 38 00 00      mov c, 0
3646   1A82 11            mov a, b
3647   1A83 FD 77         inc b
3648   1A85 FA FA FF      lea d, [bp + -6] ; $i
3649   1A88 FD 43         mov [d], b
3650   1A8A 27            mov b, a
3651   1A8B 0A 19 1A      jmp _while49_cond
3652   1A8E             _while49_exit:
3653   1A8E             ; while (i > 0) { 
3654   1A8E             _while50_cond:
3655   1A8E FA FA FF      lea d, [bp + -6] ; $i
3656   1A91 2A            mov b, [d]
3657   1A92 38 00 00      mov c, 0
3658   1A95             ; --- START RELATIONAL
3659   1A95 D7            push a
3660   1A96 11            mov a, b
3661   1A97 FD 2E 00 00   mov32 cb, $00000000
3661   1A9B 00 00 
3662   1A9D B0            cmp a, b
3663   1A9E FD 7F         sgt ; >
3664   1AA0 E4            pop a
3665   1AA1             ; --- END RELATIONAL
3666   1AA1 C0 00 00      cmp b, 0
3667   1AA4 C6 D6 1A      je _while50_exit
3668   1AA7             _while50_block:
3669   1AA7             ; i--; 
3670   1AA7 FA FA FF      lea d, [bp + -6] ; $i
3671   1AAA 2A            mov b, [d]
3672   1AAB 38 00 00      mov c, 0
3673   1AAE FD 7D         dec b
3674   1AB0 FA FA FF      lea d, [bp + -6] ; $i
3675   1AB3 FD 43         mov [d], b
3676   1AB5 FD 77         inc b
3677   1AB7             ; putchar(digits[i]); 
3678   1AB7             ; --- START FUNCTION CALL
3679   1AB7 FA FC FF      lea d, [bp + -4] ; $digits
3680   1ABA D7            push a
3681   1ABB DA            push d
3682   1ABC FA FA FF      lea d, [bp + -6] ; $i
3683   1ABF 2A            mov b, [d]
3684   1AC0 38 00 00      mov c, 0
3685   1AC3 E7            pop d
3686   1AC4 5A            add d, b
3687   1AC5 E4            pop a
3688   1AC6 32            mov bl, [d]
3689   1AC7 A7 00         mov bh, 0
3690   1AC9 38 00 00      mov c, 0
3691   1ACC DD            push bl
3692   1ACD 07 A0 1C      call putchar
3693   1AD0 51 01 00      add sp, 1
3694   1AD3             ; --- END FUNCTION CALL
3695   1AD3 0A 8E 1A      jmp _while50_cond
3696   1AD6             _while50_exit:
3697   1AD6 F9            leave
3698   1AD7 09            ret
3699   1AD8             
3700   1AD8             sprint_signed:
3701   1AD8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3702   1ADB             ; char digits[5]; 
3703   1ADB 52 05 00      sub sp, 5
3704   1ADE             ; int i = 0; 
3705   1ADE 52 02 00      sub sp, 2
3706   1AE1             ; --- START LOCAL VAR INITIALIZATION
3707   1AE1 FA FA FF      lea d, [bp + -6] ; $i
3708   1AE4 DA            push d
3709   1AE5 FD 2E 00 00   mov32 cb, $00000000
3709   1AE9 00 00 
3710   1AEB E7            pop d
3711   1AEC FD 43         mov [d], b
3712   1AEE             ; --- END LOCAL VAR INITIALIZATION
3713   1AEE             ; int len = 0; 
3714   1AEE 52 02 00      sub sp, 2
3715   1AF1             ; --- START LOCAL VAR INITIALIZATION
3716   1AF1 FA F8 FF      lea d, [bp + -8] ; $len
3717   1AF4 DA            push d
3718   1AF5 FD 2E 00 00   mov32 cb, $00000000
3718   1AF9 00 00 
3719   1AFB E7            pop d
3720   1AFC FD 43         mov [d], b
3721   1AFE             ; --- END LOCAL VAR INITIALIZATION
3722   1AFE             ; if (num < 0) { 
3723   1AFE             _if51_cond:
3724   1AFE FA 07 00      lea d, [bp + 7] ; $num
3725   1B01 2A            mov b, [d]
3726   1B02 38 00 00      mov c, 0
3727   1B05             ; --- START RELATIONAL
3728   1B05 D7            push a
3729   1B06 11            mov a, b
3730   1B07 FD 2E 00 00   mov32 cb, $00000000
3730   1B0B 00 00 
3731   1B0D B0            cmp a, b
3732   1B0E FD 73         slt ; < (signed)
3733   1B10 E4            pop a
3734   1B11             ; --- END RELATIONAL
3735   1B11 C0 00 00      cmp b, 0
3736   1B14 C6 54 1B      je _if51_else
3737   1B17             _if51_true:
3738   1B17             ; *dest++ = '-'; 
3739   1B17 FA 05 00      lea d, [bp + 5] ; $dest
3740   1B1A 2A            mov b, [d]
3741   1B1B 38 00 00      mov c, 0
3742   1B1E FD 77         inc b
3743   1B20 FA 05 00      lea d, [bp + 5] ; $dest
3744   1B23 FD 3E         mov [d], bl
3745   1B25 FD 7D         dec b
3746   1B27 D8            push b
3747   1B28 FD 2E 2D 00   mov32 cb, $0000002d
3747   1B2C 00 00 
3748   1B2E E7            pop d
3749   1B2F FD 3E         mov [d], bl
3750   1B31             ; num = -num; 
3751   1B31 FA 07 00      lea d, [bp + 7] ; $num
3752   1B34 DA            push d
3753   1B35 FA 07 00      lea d, [bp + 7] ; $num
3754   1B38 2A            mov b, [d]
3755   1B39 38 00 00      mov c, 0
3756   1B3C FD 97         neg b
3757   1B3E E7            pop d
3758   1B3F FD 43         mov [d], b
3759   1B41             ; len++; 
3760   1B41 FA F8 FF      lea d, [bp + -8] ; $len
3761   1B44 2A            mov b, [d]
3762   1B45 38 00 00      mov c, 0
3763   1B48 11            mov a, b
3764   1B49 FD 77         inc b
3765   1B4B FA F8 FF      lea d, [bp + -8] ; $len
3766   1B4E FD 43         mov [d], b
3767   1B50 27            mov b, a
3768   1B51 0A A3 1B      jmp _if51_exit
3769   1B54             _if51_else:
3770   1B54             ; if (num == 0) { 
3771   1B54             _if52_cond:
3772   1B54 FA 07 00      lea d, [bp + 7] ; $num
3773   1B57 2A            mov b, [d]
3774   1B58 38 00 00      mov c, 0
3775   1B5B             ; --- START RELATIONAL
3776   1B5B D7            push a
3777   1B5C 11            mov a, b
3778   1B5D FD 2E 00 00   mov32 cb, $00000000
3778   1B61 00 00 
3779   1B63 B0            cmp a, b
3780   1B64 FD 71         seq ; ==
3781   1B66 E4            pop a
3782   1B67             ; --- END RELATIONAL
3783   1B67 C0 00 00      cmp b, 0
3784   1B6A C6 A3 1B      je _if52_exit
3785   1B6D             _if52_true:
3786   1B6D             ; *dest++ = '0'; 
3787   1B6D FA 05 00      lea d, [bp + 5] ; $dest
3788   1B70 2A            mov b, [d]
3789   1B71 38 00 00      mov c, 0
3790   1B74 FD 77         inc b
3791   1B76 FA 05 00      lea d, [bp + 5] ; $dest
3792   1B79 FD 3E         mov [d], bl
3793   1B7B FD 7D         dec b
3794   1B7D D8            push b
3795   1B7E FD 2E 30 00   mov32 cb, $00000030
3795   1B82 00 00 
3796   1B84 E7            pop d
3797   1B85 FD 3E         mov [d], bl
3798   1B87             ; *dest = '\0'; 
3799   1B87 FA 05 00      lea d, [bp + 5] ; $dest
3800   1B8A 2A            mov b, [d]
3801   1B8B 38 00 00      mov c, 0
3802   1B8E D8            push b
3803   1B8F FD 2E 00 00   mov32 cb, $00000000
3803   1B93 00 00 
3804   1B95 E7            pop d
3805   1B96 FD 3E         mov [d], bl
3806   1B98             ; return 1; 
3807   1B98 FD 2E 01 00   mov32 cb, $00000001
3807   1B9C 00 00 
3808   1B9E F9            leave
3809   1B9F 09            ret
3810   1BA0 0A A3 1B      jmp _if52_exit
3811   1BA3             _if52_exit:
3812   1BA3             _if51_exit:
3813   1BA3             ; while (num > 0) { 
3814   1BA3             _while53_cond:
3815   1BA3 FA 07 00      lea d, [bp + 7] ; $num
3816   1BA6 2A            mov b, [d]
3817   1BA7 38 00 00      mov c, 0
3818   1BAA             ; --- START RELATIONAL
3819   1BAA D7            push a
3820   1BAB 11            mov a, b
3821   1BAC FD 2E 00 00   mov32 cb, $00000000
3821   1BB0 00 00 
3822   1BB2 B0            cmp a, b
3823   1BB3 FD 7F         sgt ; >
3824   1BB5 E4            pop a
3825   1BB6             ; --- END RELATIONAL
3826   1BB6 C0 00 00      cmp b, 0
3827   1BB9 C6 18 1C      je _while53_exit
3828   1BBC             _while53_block:
3829   1BBC             ; digits[i] = '0' + (num % 10); 
3830   1BBC FA FC FF      lea d, [bp + -4] ; $digits
3831   1BBF D7            push a
3832   1BC0 DA            push d
3833   1BC1 FA FA FF      lea d, [bp + -6] ; $i
3834   1BC4 2A            mov b, [d]
3835   1BC5 38 00 00      mov c, 0
3836   1BC8 E7            pop d
3837   1BC9 5A            add d, b
3838   1BCA E4            pop a
3839   1BCB DA            push d
3840   1BCC FD 2E 30 00   mov32 cb, $00000030
3840   1BD0 00 00 
3841   1BD2             ; --- START TERMS
3842   1BD2 D7            push a
3843   1BD3 11            mov a, b
3844   1BD4 FA 07 00      lea d, [bp + 7] ; $num
3845   1BD7 2A            mov b, [d]
3846   1BD8 38 00 00      mov c, 0
3847   1BDB             ; --- START FACTORS
3848   1BDB D7            push a
3849   1BDC 11            mov a, b
3850   1BDD FD 2E 0A 00   mov32 cb, $0000000a
3850   1BE1 00 00 
3851   1BE3 AE            div a, b ; 
3852   1BE4 11            mov a, b
3853   1BE5 27            mov b, a
3854   1BE6 E4            pop a
3855   1BE7             ; --- END FACTORS
3856   1BE7 56            add b, a
3857   1BE8 E4            pop a
3858   1BE9             ; --- END TERMS
3859   1BE9 E7            pop d
3860   1BEA FD 3E         mov [d], bl
3861   1BEC             ; num = num / 10; 
3862   1BEC FA 07 00      lea d, [bp + 7] ; $num
3863   1BEF DA            push d
3864   1BF0 FA 07 00      lea d, [bp + 7] ; $num
3865   1BF3 2A            mov b, [d]
3866   1BF4 38 00 00      mov c, 0
3867   1BF7             ; --- START FACTORS
3868   1BF7 D7            push a
3869   1BF8 11            mov a, b
3870   1BF9 FD 2E 0A 00   mov32 cb, $0000000a
3870   1BFD 00 00 
3871   1BFF AE            div a, b
3872   1C00 27            mov b, a
3873   1C01 E4            pop a
3874   1C02             ; --- END FACTORS
3875   1C02 E7            pop d
3876   1C03 FD 43         mov [d], b
3877   1C05             ; i++; 
3878   1C05 FA FA FF      lea d, [bp + -6] ; $i
3879   1C08 2A            mov b, [d]
3880   1C09 38 00 00      mov c, 0
3881   1C0C 11            mov a, b
3882   1C0D FD 77         inc b
3883   1C0F FA FA FF      lea d, [bp + -6] ; $i
3884   1C12 FD 43         mov [d], b
3885   1C14 27            mov b, a
3886   1C15 0A A3 1B      jmp _while53_cond
3887   1C18             _while53_exit:
3888   1C18             ; while (i > 0) { 
3889   1C18             _while54_cond:
3890   1C18 FA FA FF      lea d, [bp + -6] ; $i
3891   1C1B 2A            mov b, [d]
3892   1C1C 38 00 00      mov c, 0
3893   1C1F             ; --- START RELATIONAL
3894   1C1F D7            push a
3895   1C20 11            mov a, b
3896   1C21 FD 2E 00 00   mov32 cb, $00000000
3896   1C25 00 00 
3897   1C27 B0            cmp a, b
3898   1C28 FD 7F         sgt ; >
3899   1C2A E4            pop a
3900   1C2B             ; --- END RELATIONAL
3901   1C2B C0 00 00      cmp b, 0
3902   1C2E C6 7D 1C      je _while54_exit
3903   1C31             _while54_block:
3904   1C31             ; i--; 
3905   1C31 FA FA FF      lea d, [bp + -6] ; $i
3906   1C34 2A            mov b, [d]
3907   1C35 38 00 00      mov c, 0
3908   1C38 FD 7D         dec b
3909   1C3A FA FA FF      lea d, [bp + -6] ; $i
3910   1C3D FD 43         mov [d], b
3911   1C3F FD 77         inc b
3912   1C41             ; *dest++ = digits[i]; 
3913   1C41 FA 05 00      lea d, [bp + 5] ; $dest
3914   1C44 2A            mov b, [d]
3915   1C45 38 00 00      mov c, 0
3916   1C48 FD 77         inc b
3917   1C4A FA 05 00      lea d, [bp + 5] ; $dest
3918   1C4D FD 3E         mov [d], bl
3919   1C4F FD 7D         dec b
3920   1C51 D8            push b
3921   1C52 FA FC FF      lea d, [bp + -4] ; $digits
3922   1C55 D7            push a
3923   1C56 DA            push d
3924   1C57 FA FA FF      lea d, [bp + -6] ; $i
3925   1C5A 2A            mov b, [d]
3926   1C5B 38 00 00      mov c, 0
3927   1C5E E7            pop d
3928   1C5F 5A            add d, b
3929   1C60 E4            pop a
3930   1C61 32            mov bl, [d]
3931   1C62 A7 00         mov bh, 0
3932   1C64 38 00 00      mov c, 0
3933   1C67 E7            pop d
3934   1C68 FD 3E         mov [d], bl
3935   1C6A             ; len++; 
3936   1C6A FA F8 FF      lea d, [bp + -8] ; $len
3937   1C6D 2A            mov b, [d]
3938   1C6E 38 00 00      mov c, 0
3939   1C71 11            mov a, b
3940   1C72 FD 77         inc b
3941   1C74 FA F8 FF      lea d, [bp + -8] ; $len
3942   1C77 FD 43         mov [d], b
3943   1C79 27            mov b, a
3944   1C7A 0A 18 1C      jmp _while54_cond
3945   1C7D             _while54_exit:
3946   1C7D             ; *dest = '\0'; 
3947   1C7D FA 05 00      lea d, [bp + 5] ; $dest
3948   1C80 2A            mov b, [d]
3949   1C81 38 00 00      mov c, 0
3950   1C84 D8            push b
3951   1C85 FD 2E 00 00   mov32 cb, $00000000
3951   1C89 00 00 
3952   1C8B E7            pop d
3953   1C8C FD 3E         mov [d], bl
3954   1C8E             ; return len; 
3955   1C8E FA F8 FF      lea d, [bp + -8] ; $len
3956   1C91 2A            mov b, [d]
3957   1C92 38 00 00      mov c, 0
3958   1C95 F9            leave
3959   1C96 09            ret
3960   1C97             
3961   1C97             date:
3962   1C97 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3963   1C9A             
3964   1C9A             ; --- BEGIN INLINE ASM SEGMENT
3965   1C9A 19 00         mov al, 0 
3966   1C9C 05 07         syscall sys_datetime
3967   1C9E             ; --- END INLINE ASM SEGMENT
3968   1C9E             
3969   1C9E F9            leave
3970   1C9F 09            ret
3971   1CA0             
3972   1CA0             putchar:
3973   1CA0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3974   1CA3             
3975   1CA3             ; --- BEGIN INLINE ASM SEGMENT
3976   1CA3 FA 05 00      lea d, [bp + 5] ; $c
3977   1CA6 1E            mov al, [d]
3978   1CA7 23            mov ah, al
3979   1CA8 07 AF 1E      call _putchar
3980   1CAB             ; --- END INLINE ASM SEGMENT
3981   1CAB             
3982   1CAB F9            leave
3983   1CAC 09            ret
3984   1CAD             
3985   1CAD             getchar:
3986   1CAD F8 00 00      enter 0 ; (push bp; mov bp, sp)
3987   1CB0             ; char c; 
3988   1CB0 52 01 00      sub sp, 1
3989   1CB3             
3990   1CB3             ; --- BEGIN INLINE ASM SEGMENT
3991   1CB3 07 A8 1E      call getch
3992   1CB6 1A            mov al, ah
3993   1CB7 FA 00 00      lea d, [bp + 0] ; $c
3994   1CBA 3E            mov [d], al
3995   1CBB             ; --- END INLINE ASM SEGMENT
3996   1CBB             
3997   1CBB             ; return c; 
3998   1CBB FA 00 00      lea d, [bp + 0] ; $c
3999   1CBE 32            mov bl, [d]
4000   1CBF A7 00         mov bh, 0
4001   1CC1 38 00 00      mov c, 0
4002   1CC4 F9            leave
4003   1CC5 09            ret
4004   1CC6             
4005   1CC6             scann:
4006   1CC6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4007   1CC9             ; int m; 
4008   1CC9 52 02 00      sub sp, 2
4009   1CCC             
4010   1CCC             ; --- BEGIN INLINE ASM SEGMENT
4011   1CCC 07 F3 20      call scan_u16d
4012   1CCF FA FF FF      lea d, [bp + -1] ; $m
4013   1CD2 43            mov [d], a
4014   1CD3             ; --- END INLINE ASM SEGMENT
4015   1CD3             
4016   1CD3             ; return m; 
4017   1CD3 FA FF FF      lea d, [bp + -1] ; $m
4018   1CD6 2A            mov b, [d]
4019   1CD7 38 00 00      mov c, 0
4020   1CDA F9            leave
4021   1CDB 09            ret
4022   1CDC             
4023   1CDC             puts:
4024   1CDC F8 00 00      enter 0 ; (push bp; mov bp, sp)
4025   1CDF             
4026   1CDF             ; --- BEGIN INLINE ASM SEGMENT
4027   1CDF FA 05 00      lea d, [bp + 5] ; $s
4028   1CE2 15            mov a, [d]
4029   1CE3 3C            mov d, a
4030   1CE4 07 F9 1F      call _puts
4031   1CE7 10 00 0A      mov a, $0A00
4032   1CEA 05 03         syscall sys_io
4033   1CEC             ; --- END INLINE ASM SEGMENT
4034   1CEC             
4035   1CEC F9            leave
4036   1CED 09            ret
4037   1CEE             
4038   1CEE             print:
4039   1CEE F8 00 00      enter 0 ; (push bp; mov bp, sp)
4040   1CF1             
4041   1CF1             ; --- BEGIN INLINE ASM SEGMENT
4042   1CF1 FA 05 00      lea d, [bp + 5] ; $s
4043   1CF4 FD 2A         mov d, [d]
4044   1CF6 07 F9 1F      call _puts
4045   1CF9             ; --- END INLINE ASM SEGMENT
4046   1CF9             
4047   1CF9 F9            leave
4048   1CFA 09            ret
4049   1CFB             
4050   1CFB             getparam:
4051   1CFB F8 00 00      enter 0 ; (push bp; mov bp, sp)
4052   1CFE             ; char data; 
4053   1CFE 52 01 00      sub sp, 1
4054   1D01             
4055   1D01             ; --- BEGIN INLINE ASM SEGMENT
4056   1D01 19 04         mov al, 4
4057   1D03 FA 05 00      lea d, [bp + 5] ; $address
4058   1D06 FD 2A         mov d, [d]
4059   1D08 05 0C         syscall sys_system
4060   1D0A FA 00 00      lea d, [bp + 0] ; $data
4061   1D0D FD 3E         mov [d], bl
4062   1D0F             ; --- END INLINE ASM SEGMENT
4063   1D0F             
4064   1D0F             ; return data; 
4065   1D0F FA 00 00      lea d, [bp + 0] ; $data
4066   1D12 32            mov bl, [d]
4067   1D13 A7 00         mov bh, 0
4068   1D15 38 00 00      mov c, 0
4069   1D18 F9            leave
4070   1D19 09            ret
4071   1D1A             
4072   1D1A             clear:
4073   1D1A F8 00 00      enter 0 ; (push bp; mov bp, sp)
4074   1D1D             ; print("\033[2J\033[H"); 
4075   1D1D             ; --- START FUNCTION CALL
4076   1D1D 26 91 21      mov b, _s2 ; "\033[2J\033[H"
4077   1D20 FD AB         swp b
4078   1D22 D8            push b
4079   1D23 07 EE 1C      call print
4080   1D26 51 02 00      add sp, 2
4081   1D29             ; --- END FUNCTION CALL
4082   1D29 F9            leave
4083   1D2A 09            ret
4084   1D2B             
4085   1D2B             abs:
4086   1D2B F8 00 00      enter 0 ; (push bp; mov bp, sp)
4087   1D2E             ; return i < 0 ? -i : i; 
4088   1D2E             _ternary55_cond:
4089   1D2E FA 05 00      lea d, [bp + 5] ; $i
4090   1D31 2A            mov b, [d]
4091   1D32 38 00 00      mov c, 0
4092   1D35             ; --- START RELATIONAL
4093   1D35 D7            push a
4094   1D36 11            mov a, b
4095   1D37 FD 2E 00 00   mov32 cb, $00000000
4095   1D3B 00 00 
4096   1D3D B0            cmp a, b
4097   1D3E FD 73         slt ; < (signed)
4098   1D40 E4            pop a
4099   1D41             ; --- END RELATIONAL
4100   1D41 C0 00 00      cmp b, 0
4101   1D44 C6 53 1D      je _ternary55_false
4102   1D47             _ternary55_true:
4103   1D47 FA 05 00      lea d, [bp + 5] ; $i
4104   1D4A 2A            mov b, [d]
4105   1D4B 38 00 00      mov c, 0
4106   1D4E FD 97         neg b
4107   1D50 0A 5A 1D      jmp _ternary55_exit
4108   1D53             _ternary55_false:
4109   1D53 FA 05 00      lea d, [bp + 5] ; $i
4110   1D56 2A            mov b, [d]
4111   1D57 38 00 00      mov c, 0
4112   1D5A             _ternary55_exit:
4113   1D5A F9            leave
4114   1D5B 09            ret
4115   1D5C             
4116   1D5C             loadfile:
4117   1D5C F8 00 00      enter 0 ; (push bp; mov bp, sp)
4118   1D5F             
4119   1D5F             ; --- BEGIN INLINE ASM SEGMENT
4120   1D5F FA 07 00      lea d, [bp + 7] ; $destination
4121   1D62 15            mov a, [d]
4122   1D63 4F            mov di, a
4123   1D64 FA 05 00      lea d, [bp + 5] ; $filename
4124   1D67 FD 2A         mov d, [d]
4125   1D69 19 14         mov al, 20
4126   1D6B 05 04         syscall sys_filesystem
4127   1D6D             ; --- END INLINE ASM SEGMENT
4128   1D6D             
4129   1D6D F9            leave
4130   1D6E 09            ret
4131   1D6F             
4132   1D6F             create_file:
4133   1D6F F8 00 00      enter 0 ; (push bp; mov bp, sp)
4134   1D72 F9            leave
4135   1D73 09            ret
4136   1D74             
4137   1D74             delete_file:
4138   1D74 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4139   1D77             
4140   1D77             ; --- BEGIN INLINE ASM SEGMENT
4141   1D77 FA 05 00      lea d, [bp + 5] ; $filename
4142   1D7A 19 0A         mov al, 10
4143   1D7C 05 04         syscall sys_filesystem
4144   1D7E             ; --- END INLINE ASM SEGMENT
4145   1D7E             
4146   1D7E F9            leave
4147   1D7F 09            ret
4148   1D80             
4149   1D80             load_hex:
4150   1D80 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4151   1D83             ; char *temp; 
4152   1D83 52 02 00      sub sp, 2
4153   1D86             ; temp = alloc(32768); 
4154   1D86 FA FF FF      lea d, [bp + -1] ; $temp
4155   1D89 DA            push d
4156   1D8A             ; --- START FUNCTION CALL
4157   1D8A FD 2E 00 80   mov32 cb, $00008000
4157   1D8E 00 00 
4158   1D90 FD AB         swp b
4159   1D92 D8            push b
4160   1D93 07 5F 08      call alloc
4161   1D96 51 02 00      add sp, 2
4162   1D99             ; --- END FUNCTION CALL
4163   1D99 E7            pop d
4164   1D9A FD 43         mov [d], b
4165   1D9C             
4166   1D9C             ; --- BEGIN INLINE ASM SEGMENT
4167   1D9C               
4168   1D9C               
4169   1D9C               
4170   1D9C             _load_hex:
4171   1D9C FA 05 00      lea d, [bp + 5] ; $destination
4172   1D9F FD 2A         mov d, [d]
4173   1DA1 FD 50         mov di, d
4174   1DA3 FA FF FF      lea d, [bp + -1] ; $temp
4175   1DA6 FD 2A         mov d, [d]
4176   1DA8 38 00 00      mov c, 0
4177   1DAB 48            mov a, sp
4178   1DAC 77            inc a
4179   1DAD 3C            mov d, a          
4180   1DAE 07 B6 1E      call _gets        
4181   1DB1 4D            mov si, a
4182   1DB2             __load_hex_loop:
4183   1DB2 F6            lodsb             
4184   1DB3 B9 00         cmp al, 0         
4185   1DB5 C6 C3 1D      jz __load_hex_ret
4186   1DB8 36            mov bh, al
4187   1DB9 F6            lodsb
4188   1DBA 2F            mov bl, al
4189   1DBB 07 6D 1E      call _atoi        
4190   1DBE F7            stosb             
4191   1DBF 78            inc c
4192   1DC0 0A B2 1D      jmp __load_hex_loop
4193   1DC3             __load_hex_ret:
4194   1DC3             ; --- END INLINE ASM SEGMENT
4195   1DC3             
4196   1DC3 F9            leave
4197   1DC4 09            ret
4198   1DC5             
4199   1DC5             include_stdio_asm:
4200   1DC5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4201   1DC8             
4202   1DC8             ; --- BEGIN INLINE ASM SEGMENT
4203   1DC8             .include "lib/asm/stdio.asm"
0001+  1DC8             ;-----------------------------------------------------------------------------
0002+  1DC8             ; stdio.s
0003+  1DC8             ;-----------------------------------------------------------------------------
0004+  1DC8             .include "lib/asm/string.asm"
0001++ 1DC8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 1DC8             ; string.s
0003++ 1DC8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 1DC8             
0005++ 1DC8             
0006++ 1DC8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 1DC8             ; _strrev
0008++ 1DC8             ; reverse a string
0009++ 1DC8             ; D = string address
0010++ 1DC8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 1DC8             ; 01234
0012++ 1DC8             _strrev:
0013++ 1DC8 4B          	pusha
0014++ 1DC9 07 0F 1E    	call _strlen	; length in C
0015++ 1DCC 12          	mov a, c
0016++ 1DCD AF 01 00    	cmp a, 1
0017++ 1DD0 D0 EA 1D    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 1DD3 7D          	dec a
0019++ 1DD4 FD 4E       	mov si, d	; beginning of string
0020++ 1DD6 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 1DD8 59          	add d, a	; end of string
0022++ 1DD9 12          	mov a, c
0023++ 1DDA FD 9B       	shr a		; divide by 2
0024++ 1DDC 39          	mov c, a	; C now counts the steps
0025++ 1DDD             _strrev_L0:
0026++ 1DDD 32          	mov bl, [d]	; save load right-side char into BL
0027++ 1DDE F6          	lodsb		; load left-side char into AL; increase SI
0028++ 1DDF 3E          	mov [d], al	; store left char into right side
0029++ 1DE0 1B          	mov al, bl
0030++ 1DE1 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 1DE2 7E          	dec c
0032++ 1DE3 7F          	dec d
0033++ 1DE4 C2 00 00    	cmp c, 0
0034++ 1DE7 C7 DD 1D    	jne _strrev_L0
0035++ 1DEA             _strrev_end:
0036++ 1DEA 4C          	popa
0037++ 1DEB 09          	ret
0038++ 1DEC             	
0039++ 1DEC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 1DEC             ; _strchr
0041++ 1DEC             ; search string in D for char in AL
0042++ 1DEC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 1DEC             _strchr:
0044++ 1DEC             _strchr_L0:
0045++ 1DEC 32          	mov bl, [d]
0046++ 1DED C1 00       	cmp bl, 0
0047++ 1DEF C6 FA 1D    	je _strchr_end
0048++ 1DF2 BA          	cmp al, bl
0049++ 1DF3 C6 FA 1D    	je _strchr_end
0050++ 1DF6 79          	inc d
0051++ 1DF7 0A EC 1D    	jmp _strchr_L0
0052++ 1DFA             _strchr_end:
0053++ 1DFA 1B          	mov al, bl
0054++ 1DFB 09          	ret
0055++ 1DFC             
0056++ 1DFC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 1DFC             ; _strstr
0058++ 1DFC             ; find sub-string
0059++ 1DFC             ; str1 in SI
0060++ 1DFC             ; str2 in DI
0061++ 1DFC             ; SI points to end of source string
0062++ 1DFC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 1DFC             _strstr:
0064++ 1DFC DB          	push al
0065++ 1DFD DA          	push d
0066++ 1DFE E3          	push di
0067++ 1DFF             _strstr_loop:
0068++ 1DFF F3          	cmpsb					; compare a byte of the strings
0069++ 1E00 C7 0B 1E    	jne _strstr_ret
0070++ 1E03 FC 00 00    	lea d, [di + 0]
0071++ 1E06 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1E08 C7 FF 1D    	jne _strstr_loop				; equal chars but not at end
0073++ 1E0B             _strstr_ret:
0074++ 1E0B F0          	pop di
0075++ 1E0C E7          	pop d
0076++ 1E0D E8          	pop al
0077++ 1E0E 09          	ret
0078++ 1E0F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1E0F             ; length of null terminated string
0080++ 1E0F             ; result in C
0081++ 1E0F             ; pointer in D
0082++ 1E0F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1E0F             _strlen:
0084++ 1E0F DA          	push d
0085++ 1E10 38 00 00    	mov c, 0
0086++ 1E13             _strlen_L1:
0087++ 1E13 BD 00       	cmp byte [d], 0
0088++ 1E15 C6 1D 1E    	je _strlen_ret
0089++ 1E18 79          	inc d
0090++ 1E19 78          	inc c
0091++ 1E1A 0A 13 1E    	jmp _strlen_L1
0092++ 1E1D             _strlen_ret:
0093++ 1E1D E7          	pop d
0094++ 1E1E 09          	ret
0095++ 1E1F             
0096++ 1E1F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1E1F             ; STRCMP
0098++ 1E1F             ; compare two strings
0099++ 1E1F             ; str1 in SI
0100++ 1E1F             ; str2 in DI
0101++ 1E1F             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 1E1F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1E1F             _strcmp:
0104++ 1E1F DB          	push al
0105++ 1E20 DA          	push d
0106++ 1E21 E3          	push di
0107++ 1E22 E2          	push si
0108++ 1E23             _strcmp_loop:
0109++ 1E23 F3          	cmpsb					; compare a byte of the strings
0110++ 1E24 C7 2F 1E    	jne _strcmp_ret
0111++ 1E27 FB FF FF    	lea d, [si +- 1]
0112++ 1E2A BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1E2C C7 23 1E    	jne _strcmp_loop				; equal chars but not at end
0114++ 1E2F             _strcmp_ret:
0115++ 1E2F EF          	pop si
0116++ 1E30 F0          	pop di
0117++ 1E31 E7          	pop d
0118++ 1E32 E8          	pop al
0119++ 1E33 09          	ret
0120++ 1E34             
0121++ 1E34             
0122++ 1E34             ; STRCPY
0123++ 1E34             ; copy null terminated string from SI to DI
0124++ 1E34             ; source in SI
0125++ 1E34             ; destination in DI
0126++ 1E34             _strcpy:
0127++ 1E34 E2          	push si
0128++ 1E35 E3          	push di
0129++ 1E36 DB          	push al
0130++ 1E37             _strcpy_L1:
0131++ 1E37 F6          	lodsb
0132++ 1E38 F7          	stosb
0133++ 1E39 B9 00       	cmp al, 0
0134++ 1E3B C7 37 1E    	jne _strcpy_L1
0135++ 1E3E             _strcpy_end:
0136++ 1E3E E8          	pop al
0137++ 1E3F F0          	pop di
0138++ 1E40 EF          	pop si
0139++ 1E41 09          	ret
0140++ 1E42             
0141++ 1E42             ; STRCAT
0142++ 1E42             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 1E42             ; source in SI
0144++ 1E42             ; destination in DI
0145++ 1E42             _strcat:
0146++ 1E42 E2          	push si
0147++ 1E43 E3          	push di
0148++ 1E44 D7          	push a
0149++ 1E45 DA          	push d
0150++ 1E46 50          	mov a, di
0151++ 1E47 3C          	mov d, a
0152++ 1E48             _strcat_goto_end_L1:
0153++ 1E48 BD 00       	cmp byte[d], 0
0154++ 1E4A C6 51 1E    	je _strcat_start
0155++ 1E4D 79          	inc d
0156++ 1E4E 0A 48 1E    	jmp _strcat_goto_end_L1
0157++ 1E51             _strcat_start:
0158++ 1E51 FD 50       	mov di, d
0159++ 1E53             _strcat_L1:
0160++ 1E53 F6          	lodsb
0161++ 1E54 F7          	stosb
0162++ 1E55 B9 00       	cmp al, 0
0163++ 1E57 C7 53 1E    	jne _strcat_L1
0164++ 1E5A             _strcat_end:
0165++ 1E5A E7          	pop d
0166++ 1E5B E4          	pop a
0167++ 1E5C F0          	pop di
0168++ 1E5D EF          	pop si
0169++ 1E5E 09          	ret
0170++ 1E5F             
0171++ 1E5F             
0005+  1E5F             
0006+  1E5F             ;-----------------------------------------------------------------------------
0007+  1E5F             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0008+  1E5F             ; ASCII in BL
0009+  1E5F             ; result in AL
0010+  1E5F             ; ascii for F = 0100 0110
0011+  1E5F             ; ascii for 9 = 0011 1001
0012+  1E5F             ;-----------------------------------------------------------------------------
0013+  1E5F             hex_ascii_encode:
0014+  1E5F 1B            mov al, bl
0015+  1E60 93 40         test al, $40        ; test if letter or number
0016+  1E62 C7 68 1E      jnz hex_letter
0017+  1E65 87 0F         and al, $0F        ; get number
0018+  1E67 09            ret
0019+  1E68             hex_letter:
0020+  1E68 87 0F         and al, $0F        ; get letter
0021+  1E6A 6A 09         add al, 9
0022+  1E6C 09            ret
0023+  1E6D             
0024+  1E6D             ;-----------------------------------------------------------------------------
0025+  1E6D             ; ATOI
0026+  1E6D             ; 2 letter hex string in B
0027+  1E6D             ; 8bit integer returned in AL
0028+  1E6D             ;-----------------------------------------------------------------------------
0029+  1E6D             _atoi:
0030+  1E6D D8            push b
0031+  1E6E 07 5F 1E      call hex_ascii_encode      ; convert BL to 4bit code in AL
0032+  1E71 30            mov bl, bh
0033+  1E72 DB            push al          ; save a
0034+  1E73 07 5F 1E      call hex_ascii_encode
0035+  1E76 EA            pop bl  
0036+  1E77 FD 9E 04      shl al, 4
0037+  1E7A 8C            or al, bl
0038+  1E7B E5            pop b
0039+  1E7C 09            ret  
0040+  1E7D             
0041+  1E7D             
0042+  1E7D             ;-----------------------------------------------------------------------------
0043+  1E7D             ; ITOA
0044+  1E7D             ; 8bit value in BL
0045+  1E7D             ; 2 byte ASCII result in A
0046+  1E7D             ;-----------------------------------------------------------------------------
0047+  1E7D             _itoa:
0048+  1E7D DA            push d
0049+  1E7E D8            push b
0050+  1E7F A7 00         mov bh, 0
0051+  1E81 FD A4 04      shr bl, 4  
0052+  1E84 74            mov d, b
0053+  1E85 1F 2D 21      mov al, [d + s_hex_digits]
0054+  1E88 23            mov ah, al
0055+  1E89               
0056+  1E89 E5            pop b
0057+  1E8A D8            push b
0058+  1E8B A7 00         mov bh, 0
0059+  1E8D FD 87 0F      and bl, $0F
0060+  1E90 74            mov d, b
0061+  1E91 1F 2D 21      mov al, [d + s_hex_digits]
0062+  1E94 E5            pop b
0063+  1E95 E7            pop d
0064+  1E96 09            ret
0065+  1E97             
0066+  1E97             ;-----------------------------------------------------------------------------
0067+  1E97             ; HEX STRING TO BINARY
0068+  1E97             ; di = destination address
0069+  1E97             ; si = source
0070+  1E97             ;-----------------------------------------------------------------------------
0071+  1E97             _hex_to_int:
0072+  1E97             _hex_to_int_L1:
0073+  1E97 F6            lodsb          ; load from [SI] to AL
0074+  1E98 B9 00         cmp al, 0        ; check if ASCII 0
0075+  1E9A C6 A7 1E      jz _hex_to_int_ret
0076+  1E9D 36            mov bh, al
0077+  1E9E F6            lodsb
0078+  1E9F 2F            mov bl, al
0079+  1EA0 07 6D 1E      call _atoi        ; convert ASCII byte in B to int (to AL)
0080+  1EA3 F7            stosb          ; store AL to [DI]
0081+  1EA4 0A 97 1E      jmp _hex_to_int_L1
0082+  1EA7             _hex_to_int_ret:
0083+  1EA7 09            ret    
0084+  1EA8             
0085+  1EA8             ;-----------------------------------------------------------------------------
0086+  1EA8             ; GETCHAR
0087+  1EA8             ; char in ah
0088+  1EA8             ;-----------------------------------------------------------------------------
0089+  1EA8             getch:
0090+  1EA8 DB            push al
0091+  1EA9             getch_retry:
0092+  1EA9 19 01         mov al, 1
0093+  1EAB 05 03         syscall sys_io      ; receive in AH
0094+  1EAD E8            pop al
0095+  1EAE 09            ret
0096+  1EAF             
0097+  1EAF             ;-----------------------------------------------------------------------------
0098+  1EAF             ; PUTCHAR
0099+  1EAF             ; char in ah
0100+  1EAF             ;-----------------------------------------------------------------------------
0101+  1EAF             _putchar:
0102+  1EAF D7            push a
0103+  1EB0 19 00         mov al, 0
0104+  1EB2 05 03         syscall sys_io      ; char in AH
0105+  1EB4 E4            pop a
0106+  1EB5 09            ret
0107+  1EB6             
0108+  1EB6             ;-----------------------------------------------------------------------------
0109+  1EB6             ;; INPUT A STRING
0110+  1EB6             ;; terminates with null
0111+  1EB6             ;; pointer in D
0112+  1EB6             ;-----------------------------------------------------------------------------
0113+  1EB6             _gets:
0114+  1EB6 D7            push a
0115+  1EB7 DA            push d
0116+  1EB8             _gets_loop:
0117+  1EB8 19 01         mov al, 1
0118+  1EBA 05 03         syscall sys_io      ; receive in AH
0119+  1EBC B9 00         cmp al, 0        ; check error code (AL)
0120+  1EBE C6 B8 1E      je _gets_loop      ; if no char received, retry
0121+  1EC1             
0122+  1EC1 76 1B         cmp ah, 27
0123+  1EC3 C6 E4 1E      je _gets_ansi_esc
0124+  1EC6 76 0A         cmp ah, $0A        ; LF
0125+  1EC8 C6 4F 1F      je _gets_end
0126+  1ECB 76 0D         cmp ah, $0D        ; CR
0127+  1ECD C6 4F 1F      je _gets_end
0128+  1ED0 76 5C         cmp ah, $5C        ; '\\'
0129+  1ED2 C6 10 1F      je _gets_escape
0130+  1ED5               
0131+  1ED5 76 08         cmp ah, $08      ; check for backspace
0132+  1ED7 C6 E0 1E      je _gets_backspace
0133+  1EDA             
0134+  1EDA 1A            mov al, ah
0135+  1EDB 3E            mov [d], al
0136+  1EDC 79            inc d
0137+  1EDD 0A B8 1E      jmp _gets_loop
0138+  1EE0             _gets_backspace:
0139+  1EE0 7F            dec d
0140+  1EE1 0A B8 1E      jmp _gets_loop
0141+  1EE4             _gets_ansi_esc:
0142+  1EE4 19 01         mov al, 1
0143+  1EE6 05 03         syscall sys_io        ; receive in AH without echo
0144+  1EE8 B9 00         cmp al, 0          ; check error code (AL)
0145+  1EEA C6 E4 1E      je _gets_ansi_esc    ; if no char received, retry
0146+  1EED 76 5B         cmp ah, '['
0147+  1EEF C7 B8 1E      jne _gets_loop
0148+  1EF2             _gets_ansi_esc_2:
0149+  1EF2 19 01         mov al, 1
0150+  1EF4 05 03         syscall sys_io          ; receive in AH without echo
0151+  1EF6 B9 00         cmp al, 0            ; check error code (AL)
0152+  1EF8 C6 F2 1E      je _gets_ansi_esc_2  ; if no char received, retry
0153+  1EFB 76 44         cmp ah, 'D'
0154+  1EFD C6 08 1F      je _gets_left_arrow
0155+  1F00 76 43         cmp ah, 'C'
0156+  1F02 C6 0C 1F      je _gets_right_arrow
0157+  1F05 0A B8 1E      jmp _gets_loop
0158+  1F08             _gets_left_arrow:
0159+  1F08 7F            dec d
0160+  1F09 0A B8 1E      jmp _gets_loop
0161+  1F0C             _gets_right_arrow:
0162+  1F0C 79            inc d
0163+  1F0D 0A B8 1E      jmp _gets_loop
0164+  1F10             _gets_escape:
0165+  1F10 19 01         mov al, 1
0166+  1F12 05 03         syscall sys_io      ; receive in AH
0167+  1F14 B9 00         cmp al, 0        ; check error code (AL)
0168+  1F16 C6 10 1F      je _gets_escape      ; if no char received, retry
0169+  1F19 76 6E         cmp ah, 'n'
0170+  1F1B C6 3A 1F      je _gets_LF
0171+  1F1E 76 72         cmp ah, 'r'
0172+  1F20 C6 41 1F      je _gets_CR
0173+  1F23 76 30         cmp ah, '0'
0174+  1F25 C6 48 1F      je _gets_NULL
0175+  1F28 76 5C         cmp ah, $5C  ; '\'
0176+  1F2A C6 33 1F      je _gets_slash
0177+  1F2D 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0178+  1F2E 3E            mov [d], al
0179+  1F2F 79            inc d
0180+  1F30 0A B8 1E      jmp _gets_loop
0181+  1F33             _gets_slash:
0182+  1F33 19 5C         mov al, $5C
0183+  1F35 3E            mov [d], al
0184+  1F36 79            inc d
0185+  1F37 0A B8 1E      jmp _gets_loop
0186+  1F3A             _gets_LF:
0187+  1F3A 19 0A         mov al, $0A
0188+  1F3C 3E            mov [d], al
0189+  1F3D 79            inc d
0190+  1F3E 0A B8 1E      jmp _gets_loop
0191+  1F41             _gets_CR:
0192+  1F41 19 0D         mov al, $0D
0193+  1F43 3E            mov [d], al
0194+  1F44 79            inc d
0195+  1F45 0A B8 1E      jmp _gets_loop
0196+  1F48             _gets_NULL:
0197+  1F48 19 00         mov al, $00
0198+  1F4A 3E            mov [d], al
0199+  1F4B 79            inc d
0200+  1F4C 0A B8 1E      jmp _gets_loop
0201+  1F4F             _gets_end:
0202+  1F4F 19 00         mov al, 0
0203+  1F51 3E            mov [d], al        ; terminate string
0204+  1F52 E7            pop d
0205+  1F53 E4            pop a
0206+  1F54 09            ret
0207+  1F55             
0208+  1F55             ;-----------------------------------------------------------------------------
0209+  1F55             ;; INPUT TEXT
0210+  1F55             ;; terminated with CTRL+D
0211+  1F55             ;; pointer in D
0212+  1F55             ;-----------------------------------------------------------------------------
0213+  1F55             _gettxt:
0214+  1F55 D7            push a
0215+  1F56 DA            push d
0216+  1F57             _gettxt_loop:
0217+  1F57 19 01         mov al, 1
0218+  1F59 05 03         syscall sys_io      ; receive in AH
0219+  1F5B B9 00         cmp al, 0        ; check error code (AL)
0220+  1F5D C6 57 1F      je _gettxt_loop    ; if no char received, retry
0221+  1F60 76 04         cmp ah, 4      ; EOT
0222+  1F62 C6 A0 1F      je _gettxt_end
0223+  1F65 76 08         cmp ah, $08      ; check for backspace
0224+  1F67 C6 9C 1F      je _gettxt_backspace
0225+  1F6A 76 5C         cmp ah, $5C        ; '\'
0226+  1F6C C6 75 1F      je _gettxt_escape
0227+  1F6F 1A            mov al, ah
0228+  1F70 3E            mov [d], al
0229+  1F71 79            inc d
0230+  1F72 0A 57 1F      jmp _gettxt_loop
0231+  1F75             _gettxt_escape:
0232+  1F75 19 01         mov al, 1
0233+  1F77 05 03         syscall sys_io      ; receive in AH
0234+  1F79 B9 00         cmp al, 0        ; check error code (AL)
0235+  1F7B C6 75 1F      je _gettxt_escape    ; if no char received, retry
0236+  1F7E 76 6E         cmp ah, 'n'
0237+  1F80 C6 8E 1F      je _gettxt_LF
0238+  1F83 76 72         cmp ah, 'r'
0239+  1F85 C6 95 1F      je _gettxt_CR
0240+  1F88 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0241+  1F89 3E            mov [d], al
0242+  1F8A 79            inc d
0243+  1F8B 0A 57 1F      jmp _gettxt_loop
0244+  1F8E             _gettxt_LF:
0245+  1F8E 19 0A         mov al, $0A
0246+  1F90 3E            mov [d], al
0247+  1F91 79            inc d
0248+  1F92 0A 57 1F      jmp _gettxt_loop
0249+  1F95             _gettxt_CR:
0250+  1F95 19 0D         mov al, $0D
0251+  1F97 3E            mov [d], al
0252+  1F98 79            inc d
0253+  1F99 0A 57 1F      jmp _gettxt_loop
0254+  1F9C             _gettxt_backspace:
0255+  1F9C 7F            dec d
0256+  1F9D 0A 57 1F      jmp _gettxt_loop
0257+  1FA0             _gettxt_end:
0258+  1FA0 19 00         mov al, 0
0259+  1FA2 3E            mov [d], al        ; terminate string
0260+  1FA3 E7            pop d
0261+  1FA4 E4            pop a
0262+  1FA5 09            ret
0263+  1FA6             
0264+  1FA6             ;-----------------------------------------------------------------------------
0265+  1FA6             ; PRINT NEW LINE
0266+  1FA6             ;-----------------------------------------------------------------------------
0267+  1FA6             printnl:
0268+  1FA6 D7            push a
0269+  1FA7 10 00 0A      mov a, $0A00
0270+  1FAA 05 03         syscall sys_io
0271+  1FAC 10 00 0D      mov a, $0D00
0272+  1FAF 05 03         syscall sys_io
0273+  1FB1 E4            pop a
0274+  1FB2 09            ret
0275+  1FB3             
0276+  1FB3             ;-----------------------------------------------------------------------------
0277+  1FB3             ; _strtoint
0278+  1FB3             ; 4 digit hex string number in d
0279+  1FB3             ; integer returned in A
0280+  1FB3             ;-----------------------------------------------------------------------------
0281+  1FB3             _strtointx:
0282+  1FB3 D8            push b
0283+  1FB4 32            mov bl, [d]
0284+  1FB5 37            mov bh, bl
0285+  1FB6 33 01 00      mov bl, [d + 1]
0286+  1FB9 07 6D 1E      call _atoi        ; convert to int in AL
0287+  1FBC 23            mov ah, al        ; move to AH
0288+  1FBD 33 02 00      mov bl, [d + 2]
0289+  1FC0 37            mov bh, bl
0290+  1FC1 33 03 00      mov bl, [d + 3]
0291+  1FC4 07 6D 1E      call _atoi        ; convert to int in AL
0292+  1FC7 E5            pop b
0293+  1FC8 09            ret
0294+  1FC9             
0295+  1FC9             ;-----------------------------------------------------------------------------
0296+  1FC9             ; _strtoint
0297+  1FC9             ; 5 digit base10 string number in d
0298+  1FC9             ; integer returned in A
0299+  1FC9             ;-----------------------------------------------------------------------------
0300+  1FC9             _strtoint:
0301+  1FC9 E2            push si
0302+  1FCA D8            push b
0303+  1FCB D9            push c
0304+  1FCC DA            push d
0305+  1FCD 07 0F 1E      call _strlen      ; get string length in C
0306+  1FD0 7E            dec c
0307+  1FD1 FD 4E         mov si, d
0308+  1FD3 12            mov a, c
0309+  1FD4 FD 99         shl a
0310+  1FD6 3B 45 21      mov d, table_power
0311+  1FD9 59            add d, a
0312+  1FDA 38 00 00      mov c, 0
0313+  1FDD             _strtoint_L0:
0314+  1FDD F6            lodsb      ; load ASCII to al
0315+  1FDE B9 00         cmp al, 0
0316+  1FE0 C6 F3 1F      je _strtoint_end
0317+  1FE3 6F 30         sub al, $30    ; make into integer
0318+  1FE5 22 00         mov ah, 0
0319+  1FE7 2A            mov b, [d]
0320+  1FE8 AC            mul a, b      ; result in B since it fits in 16bits
0321+  1FE9 11            mov a, b
0322+  1FEA 28            mov b, c
0323+  1FEB 54            add a, b
0324+  1FEC 39            mov c, a
0325+  1FED 63 02 00      sub d, 2
0326+  1FF0 0A DD 1F      jmp _strtoint_L0
0327+  1FF3             _strtoint_end:
0328+  1FF3 12            mov a, c
0329+  1FF4 E7            pop d
0330+  1FF5 E6            pop c
0331+  1FF6 E5            pop b
0332+  1FF7 EF            pop si
0333+  1FF8 09            ret
0334+  1FF9             
0335+  1FF9             ;-----------------------------------------------------------------------------
0336+  1FF9             ; PRINT NULL TERMINATED STRING
0337+  1FF9             ; pointer in D
0338+  1FF9             ;-----------------------------------------------------------------------------
0339+  1FF9             _puts:
0340+  1FF9 D7            push a
0341+  1FFA DA            push d
0342+  1FFB             _puts_L1:
0343+  1FFB 1E            mov al, [d]
0344+  1FFC B9 00         cmp al, 0
0345+  1FFE C6 0A 20      jz _puts_END
0346+  2001 23            mov ah, al
0347+  2002 19 00         mov al, 0
0348+  2004 05 03         syscall sys_io
0349+  2006 79            inc d
0350+  2007 0A FB 1F      jmp _puts_L1
0351+  200A             _puts_END:
0352+  200A E7            pop d
0353+  200B E4            pop a
0354+  200C 09            ret
0355+  200D             
0356+  200D             ;-----------------------------------------------------------------------------
0357+  200D             ; PRINT N SIZE STRING
0358+  200D             ; pointer in D
0359+  200D             ; size in C
0360+  200D             ;-----------------------------------------------------------------------------
0361+  200D             _putsn:
0362+  200D DB            push al
0363+  200E DA            push d
0364+  200F D9            push c
0365+  2010             _putsn_L0:
0366+  2010 1E            mov al, [d]
0367+  2011 23            mov ah, al
0368+  2012 19 00         mov al, 0
0369+  2014 05 03         syscall sys_io
0370+  2016 79            inc d
0371+  2017 7E            dec c  
0372+  2018 C2 00 00      cmp c, 0
0373+  201B C7 10 20      jne _putsn_L0
0374+  201E             _putsn_end:
0375+  201E E6            pop c
0376+  201F E7            pop d
0377+  2020 E8            pop al
0378+  2021 09            ret
0379+  2022             
0380+  2022             ;-----------------------------------------------------------------------------
0381+  2022             ; print 16bit decimal number
0382+  2022             ; input number in A
0383+  2022             ;-----------------------------------------------------------------------------
0384+  2022             print_u16d:
0385+  2022 D7            push a
0386+  2023 D8            push b
0387+  2024 26 10 27      mov b, 10000
0388+  2027 AE            div a, b      ; get 10000's coeff.
0389+  2028 07 4A 20      call print_number
0390+  202B 11            mov a, b
0391+  202C 26 E8 03      mov b, 1000
0392+  202F AE            div a, b      ; get 1000's coeff.
0393+  2030 07 4A 20      call print_number
0394+  2033 11            mov a, b
0395+  2034 26 64 00      mov b, 100
0396+  2037 AE            div a, b
0397+  2038 07 4A 20      call print_number
0398+  203B 11            mov a, b
0399+  203C 26 0A 00      mov b, 10
0400+  203F AE            div a, b
0401+  2040 07 4A 20      call print_number
0402+  2043 1B            mov al, bl      ; 1's coeff in bl
0403+  2044 07 4A 20      call print_number
0404+  2047 E5            pop b
0405+  2048 E4            pop a
0406+  2049 09            ret
0407+  204A             
0408+  204A             ;-----------------------------------------------------------------------------
0409+  204A             ; print AL
0410+  204A             ;-----------------------------------------------------------------------------
0411+  204A             print_number:
0412+  204A 6A 30         add al, $30
0413+  204C 23            mov ah, al
0414+  204D 07 AF 1E      call _putchar
0415+  2050 09            ret
0416+  2051             
0417+  2051             ;-----------------------------------------------------------------------------
0418+  2051             ; PRINT 16BIT HEX INTEGER
0419+  2051             ; integer value in reg B
0420+  2051             ;-----------------------------------------------------------------------------
0421+  2051             print_u16x:
0422+  2051 D7            push a
0423+  2052 D8            push b
0424+  2053 DD            push bl
0425+  2054 30            mov bl, bh
0426+  2055 07 7D 1E      call _itoa        ; convert bh to char in A
0427+  2058 2F            mov bl, al        ; save al
0428+  2059 19 00         mov al, 0
0429+  205B 05 03         syscall sys_io        ; display AH
0430+  205D 24            mov ah, bl        ; retrieve al
0431+  205E 19 00         mov al, 0
0432+  2060 05 03         syscall sys_io        ; display AL
0433+  2062             
0434+  2062 EA            pop bl
0435+  2063 07 7D 1E      call _itoa        ; convert bh to char in A
0436+  2066 2F            mov bl, al        ; save al
0437+  2067 19 00         mov al, 0
0438+  2069 05 03         syscall sys_io        ; display AH
0439+  206B 24            mov ah, bl        ; retrieve al
0440+  206C 19 00         mov al, 0
0441+  206E 05 03         syscall sys_io        ; display AL
0442+  2070             
0443+  2070 E5            pop b
0444+  2071 E4            pop a
0445+  2072 09            ret
0446+  2073             
0447+  2073             ;-----------------------------------------------------------------------------
0448+  2073             ; INPUT 16BIT HEX INTEGER
0449+  2073             ; read 16bit integer into A
0450+  2073             ;-----------------------------------------------------------------------------
0451+  2073             scan_u16x:
0452+  2073 F8 10 00      enter 16
0453+  2076 D8            push b
0454+  2077 DA            push d
0455+  2078             
0456+  2078 FA F1 FF      lea d, [bp + -15]
0457+  207B 07 B6 1E      call _gets        ; get number
0458+  207E             
0459+  207E 32            mov bl, [d]
0460+  207F 37            mov bh, bl
0461+  2080 33 01 00      mov bl, [d + 1]
0462+  2083 07 6D 1E      call _atoi        ; convert to int in AL
0463+  2086 23            mov ah, al        ; move to AH
0464+  2087             
0465+  2087 33 02 00      mov bl, [d + 2]
0466+  208A 37            mov bh, bl
0467+  208B 33 03 00      mov bl, [d + 3]
0468+  208E 07 6D 1E      call _atoi        ; convert to int in AL
0469+  2091             
0470+  2091 E7            pop d
0471+  2092 E5            pop b
0472+  2093 F9            leave
0473+  2094 09            ret
0474+  2095             
0475+  2095             ;-----------------------------------------------------------------------------
0476+  2095             ; PRINT 8bit HEX INTEGER
0477+  2095             ; integer value in reg bl
0478+  2095             ;-----------------------------------------------------------------------------
0479+  2095             print_u8x:
0480+  2095 D7            push a
0481+  2096 DD            push bl
0482+  2097             
0483+  2097 07 7D 1E      call _itoa        ; convert bl to char in A
0484+  209A 2F            mov bl, al        ; save al
0485+  209B 19 00         mov al, 0
0486+  209D 05 03         syscall sys_io        ; display AH
0487+  209F 24            mov ah, bl        ; retrieve al
0488+  20A0 19 00         mov al, 0
0489+  20A2 05 03         syscall sys_io        ; display AL
0490+  20A4             
0491+  20A4 EA            pop bl
0492+  20A5 E4            pop a
0493+  20A6 09            ret
0494+  20A7             
0495+  20A7             ;-----------------------------------------------------------------------------
0496+  20A7             ; print 8bit decimal unsigned number
0497+  20A7             ; input number in AL
0498+  20A7             ;-----------------------------------------------------------------------------
0499+  20A7             print_u8d:
0500+  20A7 D7            push a
0501+  20A8 D8            push b
0502+  20A9             
0503+  20A9 22 00         mov ah, 0
0504+  20AB 26 64 00      mov b, 100
0505+  20AE AE            div a, b
0506+  20AF D8            push b      ; save remainder
0507+  20B0 B9 00         cmp al, 0
0508+  20B2 C6 BC 20      je skip100
0509+  20B5 6A 30         add al, $30
0510+  20B7 23            mov ah, al
0511+  20B8 19 00         mov al, 0
0512+  20BA 05 03         syscall sys_io  ; print coeff
0513+  20BC             skip100:
0514+  20BC E4            pop a
0515+  20BD 22 00         mov ah, 0
0516+  20BF 26 0A 00      mov b, 10
0517+  20C2 AE            div a, b
0518+  20C3 D8            push b      ; save remainder
0519+  20C4 B9 00         cmp al, 0
0520+  20C6 C6 D0 20      je skip10
0521+  20C9 6A 30         add al, $30
0522+  20CB 23            mov ah, al
0523+  20CC 19 00         mov al, 0
0524+  20CE 05 03         syscall sys_io  ; print coeff
0525+  20D0             skip10:
0526+  20D0 E4            pop a
0527+  20D1 1B            mov al, bl
0528+  20D2 6A 30         add al, $30
0529+  20D4 23            mov ah, al
0530+  20D5 19 00         mov al, 0
0531+  20D7 05 03         syscall sys_io  ; print coeff
0532+  20D9 E5            pop b
0533+  20DA E4            pop a
0534+  20DB 09            ret
0535+  20DC             
0536+  20DC             ;-----------------------------------------------------------------------------
0537+  20DC             ; INPUT 8BIT HEX INTEGER
0538+  20DC             ; read 8bit integer into AL
0539+  20DC             ;-----------------------------------------------------------------------------
0540+  20DC             scan_u8x:
0541+  20DC F8 04 00      enter 4
0542+  20DF D8            push b
0543+  20E0 DA            push d
0544+  20E1             
0545+  20E1 FA FD FF      lea d, [bp + -3]
0546+  20E4 07 B6 1E      call _gets        ; get number
0547+  20E7             
0548+  20E7 32            mov bl, [d]
0549+  20E8 37            mov bh, bl
0550+  20E9 33 01 00      mov bl, [d + 1]
0551+  20EC 07 6D 1E      call _atoi        ; convert to int in AL
0552+  20EF             
0553+  20EF E7            pop d
0554+  20F0 E5            pop b
0555+  20F1 F9            leave
0556+  20F2 09            ret
0557+  20F3             
0558+  20F3             ;-----------------------------------------------------------------------------
0559+  20F3             ; input decimal number
0560+  20F3             ; result in A
0561+  20F3             ; 655'\0'
0562+  20F3             ; low--------high
0563+  20F3             ;-----------------------------------------------------------------------------
0564+  20F3             scan_u16d:
0565+  20F3 F8 08 00      enter 8
0566+  20F6 E2            push si
0567+  20F7 D8            push b
0568+  20F8 D9            push c
0569+  20F9 DA            push d
0570+  20FA FA F9 FF      lea d, [bp +- 7]
0571+  20FD 07 B6 1E      call _gets
0572+  2100 07 0F 1E      call _strlen      ; get string length in C
0573+  2103 7E            dec c
0574+  2104 FD 4E         mov si, d
0575+  2106 12            mov a, c
0576+  2107 FD 99         shl a
0577+  2109 3B 45 21      mov d, table_power
0578+  210C 59            add d, a
0579+  210D 38 00 00      mov c, 0
0580+  2110             mul_loop:
0581+  2110 F6            lodsb      ; load ASCII to al
0582+  2111 B9 00         cmp al, 0
0583+  2113 C6 26 21      je mul_exit
0584+  2116 6F 30         sub al, $30    ; make into integer
0585+  2118 22 00         mov ah, 0
0586+  211A 2A            mov b, [d]
0587+  211B AC            mul a, b      ; result in B since it fits in 16bits
0588+  211C 11            mov a, b
0589+  211D 28            mov b, c
0590+  211E 54            add a, b
0591+  211F 39            mov c, a
0592+  2120 63 02 00      sub d, 2
0593+  2123 0A 10 21      jmp mul_loop
0594+  2126             mul_exit:
0595+  2126 12            mov a, c
0596+  2127 E7            pop d
0597+  2128 E6            pop c
0598+  2129 E5            pop b
0599+  212A EF            pop si
0600+  212B F9            leave
0601+  212C 09            ret
0602+  212D             
0603+  212D 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0603+  2131 34 35 36 37 
0603+  2135 38 39 41 42 
0603+  2139 43 44 45 46 
0604+  213D 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0604+  2141 1B 5B 48 00 
0605+  2145             
0606+  2145             table_power:
0607+  2145 01 00         .dw 1
0608+  2147 0A 00         .dw 10
0609+  2149 64 00         .dw 100
0610+  214B E8 03         .dw 1000
0611+  214D 10 27         .dw 100004204   214F             ; --- END INLINE ASM SEGMENT
4205   214F             
4206   214F F9            leave
4207   2150 09            ret
4208   2151             ; --- END TEXT SEGMENT
4209   2151             
4210   2151             ; --- BEGIN DATA SEGMENT
4211   2151 00 00       _p: .fill 2, 0
4212   2153 00 00       st_fopen_max_handle: .dw 0
4213   2155 55 6E 65 78 _s0: .db "Unexpected format in printf.", 0
4213   2159 70 65 63 74 
4213   215D 65 64 20 66 
4213   2161 6F 72 6D 61 
4213   2165 74 20 69 6E 
4213   2169 20 70 72 69 
4213   216D 6E 74 66 2E 
4213   2171 00 
4214   2172 45 72 72 6F _s1: .db "Error: Unknown argument type.\n", 0
4214   2176 72 3A 20 55 
4214   217A 6E 6B 6E 6F 
4214   217E 77 6E 20 61 
4214   2182 72 67 75 6D 
4214   2186 65 6E 74 20 
4214   218A 74 79 70 65 
4214   218E 2E 0A 00 
4215   2191 1B 5B 32 4A _s2: .db "\033[2J\033[H", 0
4215   2195 1B 5B 48 00 
4216   2199             
4217   2199 9B 21       _heap_top: .dw _heap
4218   219B 00          _heap: .db 0
4219   219C             ; --- END DATA SEGMENT
4220   219C             
4221   219C             .end
tasm: Number of errors = 0
