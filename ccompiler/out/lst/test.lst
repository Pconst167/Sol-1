0001   0000             ; --- FILENAME: test
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ;; print_unsigned_long(42672124L); 
0011   0408 26 FC 1F      mov b, $1ffc
0012   040B 38 8B 02      mov c, $28b
0013   040E FD 79         mov g, b
0014   0410 28            mov b, c
0015   0411 FD AB         swp b
0016   0413 D8            push b
0017   0414 FD 27         mov b, g
0018   0416 D8            push b
0019   0417 07 1F 04      call print_unsigned_long
0020   041A 51 04 00      add sp, 4
0021   041D 05 0B         syscall sys_terminate_proc
0022   041F             
0023   041F             print_unsigned_long:
0024   041F F8 00 00      enter 0 ; (push bp; mov bp, sp)
0025   0422             ; $p 
0026   0422 52 02 00      sub sp, 2
0027   0425             ;; p = &num; 
0028   0425 FA FF FF      lea d, [bp + -1] ; $p
0029   0428 DA            push d
0030   0429 FA 05 00      lea d, [bp + 5] ; $num
0031   042C 2D            mov b, d
0032   042D E7            pop d
0033   042E FD 43         mov [d], b
0034   0430             ;; printx8(*p); 
0035   0430 FA FF FF      lea d, [bp + -1] ; $p
0036   0433 2A            mov b, [d]
0037   0434 74            mov d, b
0038   0435 32            mov bl, [d]
0039   0436 A7 00         mov bh, 0
0040   0438 DD            push bl
0041   0439 07 86 04      call printx8
0042   043C 51 01 00      add sp, 1
0043   043F             ;; printx8(*(p+1)); 
0044   043F FA FF FF      lea d, [bp + -1] ; $p
0045   0442 2A            mov b, [d]
0046   0443             ; START TERMS
0047   0443 D7            push a
0048   0444 11            mov a, b
0049   0445 26 01 00      mov b, $1
0050   0448 54            add a, b
0051   0449 27            mov b, a
0052   044A E4            pop a
0053   044B             ; END TERMS
0054   044B 74            mov d, b
0055   044C 32            mov bl, [d]
0056   044D A7 00         mov bh, 0
0057   044F DD            push bl
0058   0450 07 86 04      call printx8
0059   0453 51 01 00      add sp, 1
0060   0456             ;; printx8(*(p+2)); 
0061   0456 FA FF FF      lea d, [bp + -1] ; $p
0062   0459 2A            mov b, [d]
0063   045A             ; START TERMS
0064   045A D7            push a
0065   045B 11            mov a, b
0066   045C 26 02 00      mov b, $2
0067   045F 54            add a, b
0068   0460 27            mov b, a
0069   0461 E4            pop a
0070   0462             ; END TERMS
0071   0462 74            mov d, b
0072   0463 32            mov bl, [d]
0073   0464 A7 00         mov bh, 0
0074   0466 DD            push bl
0075   0467 07 86 04      call printx8
0076   046A 51 01 00      add sp, 1
0077   046D             ;; printx8(*(p+3)); 
0078   046D FA FF FF      lea d, [bp + -1] ; $p
0079   0470 2A            mov b, [d]
0080   0471             ; START TERMS
0081   0471 D7            push a
0082   0472 11            mov a, b
0083   0473 26 03 00      mov b, $3
0084   0476 54            add a, b
0085   0477 27            mov b, a
0086   0478 E4            pop a
0087   0479             ; END TERMS
0088   0479 74            mov d, b
0089   047A 32            mov bl, [d]
0090   047B A7 00         mov bh, 0
0091   047D DD            push bl
0092   047E 07 86 04      call printx8
0093   0481 51 01 00      add sp, 1
0094   0484 F9            leave
0095   0485 09            ret
0096   0486             
0097   0486             printx8:
0098   0486 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0099   0489             
0100   0489             ; --- BEGIN INLINE ASM BLOCK
0101   0489 FA 05 00      lea d, [bp + 5] ; $hex
0102   048C 32            mov bl, [d]
0103   048D 07 7C 07      call print_u8x
0104   0490             ; --- END INLINE ASM BLOCK
0105   0490             
0106   0490 F9            leave
0107   0491 09            ret
0108   0492             
0109   0492             printx16:
0110   0492 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0111   0495             
0112   0495             ; --- BEGIN INLINE ASM BLOCK
0113   0495 FA 05 00      lea d, [bp + 5] ; $hex
0114   0498 2A            mov b, [d]
0115   0499 07 38 07      call print_u16x
0116   049C             ; --- END INLINE ASM BLOCK
0117   049C             
0118   049C F9            leave
0119   049D 09            ret
0120   049E             
0121   049E             putchar:
0122   049E F8 00 00      enter 0 ; (push bp; mov bp, sp)
0123   04A1             
0124   04A1             ; --- BEGIN INLINE ASM BLOCK
0125   04A1 FA 05 00      lea d, [bp + 5] ; $c
0126   04A4 1E            mov al, [d]
0127   04A5 23            mov ah, al
0128   04A6 07 96 05      call _putchar
0129   04A9             ; --- END INLINE ASM BLOCK
0130   04A9             
0131   04A9 F9            leave
0132   04AA 09            ret
0133   04AB             
0134   04AB             include_stdio_asm:
0135   04AB F8 00 00      enter 0 ; (push bp; mov bp, sp)
0136   04AE             
0137   04AE             ; --- BEGIN INLINE ASM BLOCK
0138   04AE             .include "lib/asm/stdio.asm"
0001+  04AE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  04AE             ; stdio.s
0003+  04AE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  04AE             .include "lib/asm/string.asm"
0001++ 04AE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 04AE             ; string.s
0003++ 04AE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 04AE             
0005++ 04AE             
0006++ 04AE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 04AE             ; _strrev
0008++ 04AE             ; reverse a string
0009++ 04AE             ; D = string address
0010++ 04AE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 04AE             ; 01234
0012++ 04AE             _strrev:
0013++ 04AE 4B          	pusha
0014++ 04AF 07 F5 04    	call _strlen	; length in C
0015++ 04B2 12          	mov a, c
0016++ 04B3 AF 01 00    	cmp a, 1
0017++ 04B6 D0 D0 04    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 04B9 7D          	dec a
0019++ 04BA FD 4E       	mov si, d	; beginning of string
0020++ 04BC FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 04BE 59          	add d, a	; end of string
0022++ 04BF 12          	mov a, c
0023++ 04C0 FD 9B       	shr a		; divide by 2
0024++ 04C2 39          	mov c, a	; C now counts the steps
0025++ 04C3             _strrev_L0:
0026++ 04C3 32          	mov bl, [d]	; save load right-side char into BL
0027++ 04C4 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 04C5 3E          	mov [d], al	; store left char into right side
0029++ 04C6 1B          	mov al, bl
0030++ 04C7 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 04C8 7E          	dec c
0032++ 04C9 7F          	dec d
0033++ 04CA C2 00 00    	cmp c, 0
0034++ 04CD C7 C3 04    	jne _strrev_L0
0035++ 04D0             _strrev_end:
0036++ 04D0 4C          	popa
0037++ 04D1 09          	ret
0038++ 04D2             	
0039++ 04D2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 04D2             ; _strchr
0041++ 04D2             ; search string in D for char in AL
0042++ 04D2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 04D2             _strchr:
0044++ 04D2             _strchr_L0:
0045++ 04D2 32          	mov bl, [d]
0046++ 04D3 C1 00       	cmp bl, 0
0047++ 04D5 C6 E0 04    	je _strchr_end
0048++ 04D8 BA          	cmp al, bl
0049++ 04D9 C6 E0 04    	je _strchr_end
0050++ 04DC 79          	inc d
0051++ 04DD 0A D2 04    	jmp _strchr_L0
0052++ 04E0             _strchr_end:
0053++ 04E0 1B          	mov al, bl
0054++ 04E1 09          	ret
0055++ 04E2             
0056++ 04E2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 04E2             ; _strstr
0058++ 04E2             ; find sub-string
0059++ 04E2             ; str1 in SI
0060++ 04E2             ; str2 in DI
0061++ 04E2             ; SI points to end of source string
0062++ 04E2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 04E2             _strstr:
0064++ 04E2 DB          	push al
0065++ 04E3 DA          	push d
0066++ 04E4 E3          	push di
0067++ 04E5             _strstr_loop:
0068++ 04E5 F3          	cmpsb					; compare a byte of the strings
0069++ 04E6 C7 F1 04    	jne _strstr_ret
0070++ 04E9 FC 00 00    	lea d, [di + 0]
0071++ 04EC BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 04EE C7 E5 04    	jne _strstr_loop				; equal chars but not at end
0073++ 04F1             _strstr_ret:
0074++ 04F1 F0          	pop di
0075++ 04F2 E7          	pop d
0076++ 04F3 E8          	pop al
0077++ 04F4 09          	ret
0078++ 04F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 04F5             ; length of null terminated string
0080++ 04F5             ; result in C
0081++ 04F5             ; pointer in D
0082++ 04F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 04F5             _strlen:
0084++ 04F5 DA          	push d
0085++ 04F6 38 00 00    	mov c, 0
0086++ 04F9             _strlen_L1:
0087++ 04F9 BD 00       	cmp byte [d], 0
0088++ 04FB C6 03 05    	je _strlen_ret
0089++ 04FE 79          	inc d
0090++ 04FF 78          	inc c
0091++ 0500 0A F9 04    	jmp _strlen_L1
0092++ 0503             _strlen_ret:
0093++ 0503 E7          	pop d
0094++ 0504 09          	ret
0095++ 0505             
0096++ 0505             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0505             ; STRCMP
0098++ 0505             ; compare two strings
0099++ 0505             ; str1 in SI
0100++ 0505             ; str2 in DI
0101++ 0505             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0505             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0505             _strcmp:
0104++ 0505 DB          	push al
0105++ 0506 DA          	push d
0106++ 0507 E3          	push di
0107++ 0508 E2          	push si
0108++ 0509             _strcmp_loop:
0109++ 0509 F3          	cmpsb					; compare a byte of the strings
0110++ 050A C7 15 05    	jne _strcmp_ret
0111++ 050D FB FF FF    	lea d, [si +- 1]
0112++ 0510 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0512 C7 09 05    	jne _strcmp_loop				; equal chars but not at end
0114++ 0515             _strcmp_ret:
0115++ 0515 EF          	pop si
0116++ 0516 F0          	pop di
0117++ 0517 E7          	pop d
0118++ 0518 E8          	pop al
0119++ 0519 09          	ret
0120++ 051A             
0121++ 051A             
0122++ 051A             ; STRCPY
0123++ 051A             ; copy null terminated string from SI to DI
0124++ 051A             ; source in SI
0125++ 051A             ; destination in DI
0126++ 051A             _strcpy:
0127++ 051A E2          	push si
0128++ 051B E3          	push di
0129++ 051C DB          	push al
0130++ 051D             _strcpy_L1:
0131++ 051D F6          	lodsb
0132++ 051E F7          	stosb
0133++ 051F B9 00       	cmp al, 0
0134++ 0521 C7 1D 05    	jne _strcpy_L1
0135++ 0524             _strcpy_end:
0136++ 0524 E8          	pop al
0137++ 0525 F0          	pop di
0138++ 0526 EF          	pop si
0139++ 0527 09          	ret
0140++ 0528             
0141++ 0528             ; STRCAT
0142++ 0528             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0528             ; source in SI
0144++ 0528             ; destination in DI
0145++ 0528             _strcat:
0146++ 0528 E2          	push si
0147++ 0529 E3          	push di
0148++ 052A D7          	push a
0149++ 052B DA          	push d
0150++ 052C 50          	mov a, di
0151++ 052D 3C          	mov d, a
0152++ 052E             _strcat_goto_end_L1:
0153++ 052E BD 00       	cmp byte[d], 0
0154++ 0530 C6 37 05    	je _strcat_start
0155++ 0533 79          	inc d
0156++ 0534 0A 2E 05    	jmp _strcat_goto_end_L1
0157++ 0537             _strcat_start:
0158++ 0537 FD 50       	mov di, d
0159++ 0539             _strcat_L1:
0160++ 0539 F6          	lodsb
0161++ 053A F7          	stosb
0162++ 053B B9 00       	cmp al, 0
0163++ 053D C7 39 05    	jne _strcat_L1
0164++ 0540             _strcat_end:
0165++ 0540 E7          	pop d
0166++ 0541 E4          	pop a
0167++ 0542 F0          	pop di
0168++ 0543 EF          	pop si
0169++ 0544 09          	ret
0170++ 0545             
0171++ 0545             
0005+  0545             
0006+  0545             
0007+  0545             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  0545             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  0545             ; ASCII in BL
0010+  0545             ; result in AL
0011+  0545             ; ascii for F = 0100 0110
0012+  0545             ; ascii for 9 = 0011 1001
0013+  0545             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  0545             hex_ascii_encode:
0015+  0545 1B            mov al, bl
0016+  0546 93 40         test al, $40        ; test if letter or number
0017+  0548 C7 4E 05      jnz hex_letter
0018+  054B 87 0F         and al, $0F        ; get number
0019+  054D 09            ret
0020+  054E             hex_letter:
0021+  054E 87 0F         and al, $0F        ; get letter
0022+  0550 6A 09         add al, 9
0023+  0552 09            ret
0024+  0553             
0025+  0553             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0553             ; ATOI
0027+  0553             ; 2 letter hex string in B
0028+  0553             ; 8bit integer returned in AL
0029+  0553             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  0553             _atoi:
0031+  0553 D8            push b
0032+  0554 07 45 05      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  0557 30            mov bl, bh
0034+  0558 DB            push al          ; save a
0035+  0559 07 45 05      call hex_ascii_encode
0036+  055C EA            pop bl  
0037+  055D FD 9E 04      shl al, 4
0038+  0560 8C            or al, bl
0039+  0561 E5            pop b
0040+  0562 09            ret  
0041+  0563             
0042+  0563             
0043+  0563             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  0563             ; scanf
0045+  0563             ; no need for explanations!
0046+  0563             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  0563             scanf:
0048+  0563 09            ret
0049+  0564             
0050+  0564             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0564             ; ITOA
0052+  0564             ; 8bit value in BL
0053+  0564             ; 2 byte ASCII result in A
0054+  0564             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0564             _itoa:
0056+  0564 DA            push d
0057+  0565 D8            push b
0058+  0566 A7 00         mov bh, 0
0059+  0568 FD A4 04      shr bl, 4  
0060+  056B 74            mov d, b
0061+  056C 1F 14 08      mov al, [d + s_hex_digits]
0062+  056F 23            mov ah, al
0063+  0570               
0064+  0570 E5            pop b
0065+  0571 D8            push b
0066+  0572 A7 00         mov bh, 0
0067+  0574 FD 87 0F      and bl, $0F
0068+  0577 74            mov d, b
0069+  0578 1F 14 08      mov al, [d + s_hex_digits]
0070+  057B E5            pop b
0071+  057C E7            pop d
0072+  057D 09            ret
0073+  057E             
0074+  057E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  057E             ; HEX STRING TO BINARY
0076+  057E             ; di = destination address
0077+  057E             ; si = source
0078+  057E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  057E             _hex_to_int:
0080+  057E             _hex_to_int_L1:
0081+  057E F6            lodsb          ; load from [SI] to AL
0082+  057F B9 00         cmp al, 0        ; check if ASCII 0
0083+  0581 C6 8E 05      jz _hex_to_int_ret
0084+  0584 36            mov bh, al
0085+  0585 F6            lodsb
0086+  0586 2F            mov bl, al
0087+  0587 07 53 05      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  058A F7            stosb          ; store AL to [DI]
0089+  058B 0A 7E 05      jmp _hex_to_int_L1
0090+  058E             _hex_to_int_ret:
0091+  058E 09            ret    
0092+  058F             
0093+  058F             
0094+  058F             
0095+  058F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  058F             ; GETCHAR
0097+  058F             ; char in ah
0098+  058F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  058F             getch:
0100+  058F DB            push al
0101+  0590             getch_retry:
0102+  0590 19 01         mov al, 1
0103+  0592 05 03         syscall sys_io      ; receive in AH
0104+  0594 E8            pop al
0105+  0595 09            ret
0106+  0596             
0107+  0596             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  0596             ; PUTCHAR
0109+  0596             ; char in ah
0110+  0596             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0596             _putchar:
0112+  0596 D7            push a
0113+  0597 19 00         mov al, 0
0114+  0599 05 03         syscall sys_io      ; char in AH
0115+  059B E4            pop a
0116+  059C 09            ret
0117+  059D             
0118+  059D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  059D             ;; INPUT A STRING
0120+  059D             ;; terminates with null
0121+  059D             ;; pointer in D
0122+  059D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  059D             _gets:
0124+  059D D7            push a
0125+  059E DA            push d
0126+  059F             _gets_loop:
0127+  059F 19 01         mov al, 1
0128+  05A1 05 03         syscall sys_io      ; receive in AH
0129+  05A3 B9 00         cmp al, 0        ; check error code (AL)
0130+  05A5 C6 9F 05      je _gets_loop      ; if no char received, retry
0131+  05A8             
0132+  05A8 76 1B         cmp ah, 27
0133+  05AA C6 CB 05      je _gets_ansi_esc
0134+  05AD 76 0A         cmp ah, $0A        ; LF
0135+  05AF C6 36 06      je _gets_end
0136+  05B2 76 0D         cmp ah, $0D        ; CR
0137+  05B4 C6 36 06      je _gets_end
0138+  05B7 76 5C         cmp ah, $5C        ; '\\'
0139+  05B9 C6 F7 05      je _gets_escape
0140+  05BC               
0141+  05BC 76 08         cmp ah, $08      ; check for backspace
0142+  05BE C6 C7 05      je _gets_backspace
0143+  05C1             
0144+  05C1 1A            mov al, ah
0145+  05C2 3E            mov [d], al
0146+  05C3 79            inc d
0147+  05C4 0A 9F 05      jmp _gets_loop
0148+  05C7             _gets_backspace:
0149+  05C7 7F            dec d
0150+  05C8 0A 9F 05      jmp _gets_loop
0151+  05CB             _gets_ansi_esc:
0152+  05CB 19 01         mov al, 1
0153+  05CD 05 03         syscall sys_io        ; receive in AH without echo
0154+  05CF B9 00         cmp al, 0          ; check error code (AL)
0155+  05D1 C6 CB 05      je _gets_ansi_esc    ; if no char received, retry
0156+  05D4 76 5B         cmp ah, '['
0157+  05D6 C7 9F 05      jne _gets_loop
0158+  05D9             _gets_ansi_esc_2:
0159+  05D9 19 01         mov al, 1
0160+  05DB 05 03         syscall sys_io          ; receive in AH without echo
0161+  05DD B9 00         cmp al, 0            ; check error code (AL)
0162+  05DF C6 D9 05      je _gets_ansi_esc_2  ; if no char received, retry
0163+  05E2 76 44         cmp ah, 'D'
0164+  05E4 C6 EF 05      je _gets_left_arrow
0165+  05E7 76 43         cmp ah, 'C'
0166+  05E9 C6 F3 05      je _gets_right_arrow
0167+  05EC 0A 9F 05      jmp _gets_loop
0168+  05EF             _gets_left_arrow:
0169+  05EF 7F            dec d
0170+  05F0 0A 9F 05      jmp _gets_loop
0171+  05F3             _gets_right_arrow:
0172+  05F3 79            inc d
0173+  05F4 0A 9F 05      jmp _gets_loop
0174+  05F7             _gets_escape:
0175+  05F7 19 01         mov al, 1
0176+  05F9 05 03         syscall sys_io      ; receive in AH
0177+  05FB B9 00         cmp al, 0        ; check error code (AL)
0178+  05FD C6 F7 05      je _gets_escape      ; if no char received, retry
0179+  0600 76 6E         cmp ah, 'n'
0180+  0602 C6 21 06      je _gets_LF
0181+  0605 76 72         cmp ah, 'r'
0182+  0607 C6 28 06      je _gets_CR
0183+  060A 76 30         cmp ah, '0'
0184+  060C C6 2F 06      je _gets_NULL
0185+  060F 76 5C         cmp ah, $5C  ; '\'
0186+  0611 C6 1A 06      je _gets_slash
0187+  0614 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0188+  0615 3E            mov [d], al
0189+  0616 79            inc d
0190+  0617 0A 9F 05      jmp _gets_loop
0191+  061A             _gets_slash:
0192+  061A 19 5C         mov al, $5C
0193+  061C 3E            mov [d], al
0194+  061D 79            inc d
0195+  061E 0A 9F 05      jmp _gets_loop
0196+  0621             _gets_LF:
0197+  0621 19 0A         mov al, $0A
0198+  0623 3E            mov [d], al
0199+  0624 79            inc d
0200+  0625 0A 9F 05      jmp _gets_loop
0201+  0628             _gets_CR:
0202+  0628 19 0D         mov al, $0D
0203+  062A 3E            mov [d], al
0204+  062B 79            inc d
0205+  062C 0A 9F 05      jmp _gets_loop
0206+  062F             _gets_NULL:
0207+  062F 19 00         mov al, $00
0208+  0631 3E            mov [d], al
0209+  0632 79            inc d
0210+  0633 0A 9F 05      jmp _gets_loop
0211+  0636             _gets_end:
0212+  0636 19 00         mov al, 0
0213+  0638 3E            mov [d], al        ; terminate string
0214+  0639 E7            pop d
0215+  063A E4            pop a
0216+  063B 09            ret
0217+  063C             
0218+  063C             
0219+  063C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0220+  063C             ;; INPUT TEXT
0221+  063C             ;; terminated with CTRL+D
0222+  063C             ;; pointer in D
0223+  063C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0224+  063C             _gettxt:
0225+  063C D7            push a
0226+  063D DA            push d
0227+  063E             _gettxt_loop:
0228+  063E 19 01         mov al, 1
0229+  0640 05 03         syscall sys_io      ; receive in AH
0230+  0642 B9 00         cmp al, 0        ; check error code (AL)
0231+  0644 C6 3E 06      je _gettxt_loop    ; if no char received, retry
0232+  0647 76 04         cmp ah, 4      ; EOT
0233+  0649 C6 87 06      je _gettxt_end
0234+  064C 76 08         cmp ah, $08      ; check for backspace
0235+  064E C6 83 06      je _gettxt_backspace
0236+  0651 76 5C         cmp ah, $5C        ; '\'
0237+  0653 C6 5C 06      je _gettxt_escape
0238+  0656 1A            mov al, ah
0239+  0657 3E            mov [d], al
0240+  0658 79            inc d
0241+  0659 0A 3E 06      jmp _gettxt_loop
0242+  065C             _gettxt_escape:
0243+  065C 19 01         mov al, 1
0244+  065E 05 03         syscall sys_io      ; receive in AH
0245+  0660 B9 00         cmp al, 0        ; check error code (AL)
0246+  0662 C6 5C 06      je _gettxt_escape    ; if no char received, retry
0247+  0665 76 6E         cmp ah, 'n'
0248+  0667 C6 75 06      je _gettxt_LF
0249+  066A 76 72         cmp ah, 'r'
0250+  066C C6 7C 06      je _gettxt_CR
0251+  066F 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0252+  0670 3E            mov [d], al
0253+  0671 79            inc d
0254+  0672 0A 3E 06      jmp _gettxt_loop
0255+  0675             _gettxt_LF:
0256+  0675 19 0A         mov al, $0A
0257+  0677 3E            mov [d], al
0258+  0678 79            inc d
0259+  0679 0A 3E 06      jmp _gettxt_loop
0260+  067C             _gettxt_CR:
0261+  067C 19 0D         mov al, $0D
0262+  067E 3E            mov [d], al
0263+  067F 79            inc d
0264+  0680 0A 3E 06      jmp _gettxt_loop
0265+  0683             _gettxt_backspace:
0266+  0683 7F            dec d
0267+  0684 0A 3E 06      jmp _gettxt_loop
0268+  0687             _gettxt_end:
0269+  0687 19 00         mov al, 0
0270+  0689 3E            mov [d], al        ; terminate string
0271+  068A E7            pop d
0272+  068B E4            pop a
0273+  068C 09            ret
0274+  068D             
0275+  068D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  068D             ; PRINT NEW LINE
0277+  068D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0278+  068D             printnl:
0279+  068D D7            push a
0280+  068E 10 00 0A      mov a, $0A00
0281+  0691 05 03         syscall sys_io
0282+  0693 10 00 0D      mov a, $0D00
0283+  0696 05 03         syscall sys_io
0284+  0698 E4            pop a
0285+  0699 09            ret
0286+  069A             
0287+  069A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  069A             ; _strtoint
0289+  069A             ; 4 digit hex string number in d
0290+  069A             ; integer returned in A
0291+  069A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0292+  069A             _strtointx:
0293+  069A D8            push b
0294+  069B 32            mov bl, [d]
0295+  069C 37            mov bh, bl
0296+  069D 33 01 00      mov bl, [d + 1]
0297+  06A0 07 53 05      call _atoi        ; convert to int in AL
0298+  06A3 23            mov ah, al        ; move to AH
0299+  06A4 33 02 00      mov bl, [d + 2]
0300+  06A7 37            mov bh, bl
0301+  06A8 33 03 00      mov bl, [d + 3]
0302+  06AB 07 53 05      call _atoi        ; convert to int in AL
0303+  06AE E5            pop b
0304+  06AF 09            ret
0305+  06B0             
0306+  06B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0307+  06B0             ; _strtoint
0308+  06B0             ; 5 digit base10 string number in d
0309+  06B0             ; integer returned in A
0310+  06B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0311+  06B0             _strtoint:
0312+  06B0 E2            push si
0313+  06B1 D8            push b
0314+  06B2 D9            push c
0315+  06B3 DA            push d
0316+  06B4 07 F5 04      call _strlen      ; get string length in C
0317+  06B7 7E            dec c
0318+  06B8 FD 4E         mov si, d
0319+  06BA 12            mov a, c
0320+  06BB FD 99         shl a
0321+  06BD 3B 2C 08      mov d, table_power
0322+  06C0 59            add d, a
0323+  06C1 38 00 00      mov c, 0
0324+  06C4             _strtoint_L0:
0325+  06C4 F6            lodsb      ; load ASCII to al
0326+  06C5 B9 00         cmp al, 0
0327+  06C7 C6 DA 06      je _strtoint_end
0328+  06CA 6F 30         sub al, $30    ; make into integer
0329+  06CC 22 00         mov ah, 0
0330+  06CE 2A            mov b, [d]
0331+  06CF AC            mul a, b      ; result in B since it fits in 16bits
0332+  06D0 11            mov a, b
0333+  06D1 28            mov b, c
0334+  06D2 54            add a, b
0335+  06D3 39            mov c, a
0336+  06D4 63 02 00      sub d, 2
0337+  06D7 0A C4 06      jmp _strtoint_L0
0338+  06DA             _strtoint_end:
0339+  06DA 12            mov a, c
0340+  06DB E7            pop d
0341+  06DC E6            pop c
0342+  06DD E5            pop b
0343+  06DE EF            pop si
0344+  06DF 09            ret
0345+  06E0             
0346+  06E0             
0347+  06E0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0348+  06E0             ; PRINT NULL TERMINATED STRING
0349+  06E0             ; pointer in D
0350+  06E0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0351+  06E0             _puts:
0352+  06E0 D7            push a
0353+  06E1 DA            push d
0354+  06E2             _puts_L1:
0355+  06E2 1E            mov al, [d]
0356+  06E3 B9 00         cmp al, 0
0357+  06E5 C6 F1 06      jz _puts_END
0358+  06E8 23            mov ah, al
0359+  06E9 19 00         mov al, 0
0360+  06EB 05 03         syscall sys_io
0361+  06ED 79            inc d
0362+  06EE 0A E2 06      jmp _puts_L1
0363+  06F1             _puts_END:
0364+  06F1 E7            pop d
0365+  06F2 E4            pop a
0366+  06F3 09            ret
0367+  06F4             
0368+  06F4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0369+  06F4             ; PRINT N SIZE STRING
0370+  06F4             ; pointer in D
0371+  06F4             ; size in C
0372+  06F4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0373+  06F4             _putsn:
0374+  06F4 DB            push al
0375+  06F5 DA            push d
0376+  06F6 D9            push c
0377+  06F7             _putsn_L0:
0378+  06F7 1E            mov al, [d]
0379+  06F8 23            mov ah, al
0380+  06F9 19 00         mov al, 0
0381+  06FB 05 03         syscall sys_io
0382+  06FD 79            inc d
0383+  06FE 7E            dec c  
0384+  06FF C2 00 00      cmp c, 0
0385+  0702 C7 F7 06      jne _putsn_L0
0386+  0705             _putsn_end:
0387+  0705 E6            pop c
0388+  0706 E7            pop d
0389+  0707 E8            pop al
0390+  0708 09            ret
0391+  0709             
0392+  0709             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0393+  0709             ; print 16bit decimal number
0394+  0709             ; input number in A
0395+  0709             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0396+  0709             print_u16d:
0397+  0709 D7            push a
0398+  070A D8            push b
0399+  070B 26 10 27      mov b, 10000
0400+  070E AE            div a, b      ; get 10000's coeff.
0401+  070F 07 31 07      call print_number
0402+  0712 11            mov a, b
0403+  0713 26 E8 03      mov b, 1000
0404+  0716 AE            div a, b      ; get 1000's coeff.
0405+  0717 07 31 07      call print_number
0406+  071A 11            mov a, b
0407+  071B 26 64 00      mov b, 100
0408+  071E AE            div a, b
0409+  071F 07 31 07      call print_number
0410+  0722 11            mov a, b
0411+  0723 26 0A 00      mov b, 10
0412+  0726 AE            div a, b
0413+  0727 07 31 07      call print_number
0414+  072A 1B            mov al, bl      ; 1's coeff in bl
0415+  072B 07 31 07      call print_number
0416+  072E E5            pop b
0417+  072F E4            pop a
0418+  0730 09            ret
0419+  0731             
0420+  0731             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0421+  0731             ; print AL
0422+  0731             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0423+  0731             print_number:
0424+  0731 6A 30         add al, $30
0425+  0733 23            mov ah, al
0426+  0734 07 96 05      call _putchar
0427+  0737 09            ret
0428+  0738             
0429+  0738             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0430+  0738             ; PRINT 16BIT HEX INTEGER
0431+  0738             ; integer value in reg B
0432+  0738             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  0738             print_u16x:
0434+  0738 D7            push a
0435+  0739 D8            push b
0436+  073A DD            push bl
0437+  073B 30            mov bl, bh
0438+  073C 07 64 05      call _itoa        ; convert bh to char in A
0439+  073F 2F            mov bl, al        ; save al
0440+  0740 19 00         mov al, 0
0441+  0742 05 03         syscall sys_io        ; display AH
0442+  0744 24            mov ah, bl        ; retrieve al
0443+  0745 19 00         mov al, 0
0444+  0747 05 03         syscall sys_io        ; display AL
0445+  0749             
0446+  0749 EA            pop bl
0447+  074A 07 64 05      call _itoa        ; convert bh to char in A
0448+  074D 2F            mov bl, al        ; save al
0449+  074E 19 00         mov al, 0
0450+  0750 05 03         syscall sys_io        ; display AH
0451+  0752 24            mov ah, bl        ; retrieve al
0452+  0753 19 00         mov al, 0
0453+  0755 05 03         syscall sys_io        ; display AL
0454+  0757             
0455+  0757 E5            pop b
0456+  0758 E4            pop a
0457+  0759 09            ret
0458+  075A             
0459+  075A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0460+  075A             ; INPUT 16BIT HEX INTEGER
0461+  075A             ; read 16bit integer into A
0462+  075A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0463+  075A             scan_u16x:
0464+  075A F8 10 00      enter 16
0465+  075D D8            push b
0466+  075E DA            push d
0467+  075F             
0468+  075F FA F1 FF      lea d, [bp + -15]
0469+  0762 07 9D 05      call _gets        ; get number
0470+  0765             
0471+  0765 32            mov bl, [d]
0472+  0766 37            mov bh, bl
0473+  0767 33 01 00      mov bl, [d + 1]
0474+  076A 07 53 05      call _atoi        ; convert to int in AL
0475+  076D 23            mov ah, al        ; move to AH
0476+  076E             
0477+  076E 33 02 00      mov bl, [d + 2]
0478+  0771 37            mov bh, bl
0479+  0772 33 03 00      mov bl, [d + 3]
0480+  0775 07 53 05      call _atoi        ; convert to int in AL
0481+  0778             
0482+  0778 E7            pop d
0483+  0779 E5            pop b
0484+  077A F9            leave
0485+  077B 09            ret
0486+  077C             
0487+  077C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0488+  077C             ; PRINT 8bit HEX INTEGER
0489+  077C             ; integer value in reg bl
0490+  077C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0491+  077C             print_u8x:
0492+  077C D7            push a
0493+  077D DD            push bl
0494+  077E             
0495+  077E 07 64 05      call _itoa        ; convert bl to char in A
0496+  0781 2F            mov bl, al        ; save al
0497+  0782 19 00         mov al, 0
0498+  0784 05 03         syscall sys_io        ; display AH
0499+  0786 24            mov ah, bl        ; retrieve al
0500+  0787 19 00         mov al, 0
0501+  0789 05 03         syscall sys_io        ; display AL
0502+  078B             
0503+  078B EA            pop bl
0504+  078C E4            pop a
0505+  078D 09            ret
0506+  078E             
0507+  078E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0508+  078E             ; print 8bit decimal unsigned number
0509+  078E             ; input number in AL
0510+  078E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0511+  078E             print_u8d:
0512+  078E D7            push a
0513+  078F D8            push b
0514+  0790             
0515+  0790 22 00         mov ah, 0
0516+  0792 26 64 00      mov b, 100
0517+  0795 AE            div a, b
0518+  0796 D8            push b      ; save remainder
0519+  0797 B9 00         cmp al, 0
0520+  0799 C6 A3 07      je skip100
0521+  079C 6A 30         add al, $30
0522+  079E 23            mov ah, al
0523+  079F 19 00         mov al, 0
0524+  07A1 05 03         syscall sys_io  ; print coeff
0525+  07A3             skip100:
0526+  07A3 E4            pop a
0527+  07A4 22 00         mov ah, 0
0528+  07A6 26 0A 00      mov b, 10
0529+  07A9 AE            div a, b
0530+  07AA D8            push b      ; save remainder
0531+  07AB B9 00         cmp al, 0
0532+  07AD C6 B7 07      je skip10
0533+  07B0 6A 30         add al, $30
0534+  07B2 23            mov ah, al
0535+  07B3 19 00         mov al, 0
0536+  07B5 05 03         syscall sys_io  ; print coeff
0537+  07B7             skip10:
0538+  07B7 E4            pop a
0539+  07B8 1B            mov al, bl
0540+  07B9 6A 30         add al, $30
0541+  07BB 23            mov ah, al
0542+  07BC 19 00         mov al, 0
0543+  07BE 05 03         syscall sys_io  ; print coeff
0544+  07C0 E5            pop b
0545+  07C1 E4            pop a
0546+  07C2 09            ret
0547+  07C3             
0548+  07C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0549+  07C3             ; INPUT 8BIT HEX INTEGER
0550+  07C3             ; read 8bit integer into AL
0551+  07C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0552+  07C3             scan_u8x:
0553+  07C3 F8 04 00      enter 4
0554+  07C6 D8            push b
0555+  07C7 DA            push d
0556+  07C8             
0557+  07C8 FA FD FF      lea d, [bp + -3]
0558+  07CB 07 9D 05      call _gets        ; get number
0559+  07CE             
0560+  07CE 32            mov bl, [d]
0561+  07CF 37            mov bh, bl
0562+  07D0 33 01 00      mov bl, [d + 1]
0563+  07D3 07 53 05      call _atoi        ; convert to int in AL
0564+  07D6             
0565+  07D6 E7            pop d
0566+  07D7 E5            pop b
0567+  07D8 F9            leave
0568+  07D9 09            ret
0569+  07DA             
0570+  07DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  07DA             ; input decimal number
0572+  07DA             ; result in A
0573+  07DA             ; 655'\0'
0574+  07DA             ; low--------high
0575+  07DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0576+  07DA             scan_u16d:
0577+  07DA F8 08 00      enter 8
0578+  07DD E2            push si
0579+  07DE D8            push b
0580+  07DF D9            push c
0581+  07E0 DA            push d
0582+  07E1 FA F9 FF      lea d, [bp +- 7]
0583+  07E4 07 9D 05      call _gets
0584+  07E7 07 F5 04      call _strlen      ; get string length in C
0585+  07EA 7E            dec c
0586+  07EB FD 4E         mov si, d
0587+  07ED 12            mov a, c
0588+  07EE FD 99         shl a
0589+  07F0 3B 2C 08      mov d, table_power
0590+  07F3 59            add d, a
0591+  07F4 38 00 00      mov c, 0
0592+  07F7             mul_loop:
0593+  07F7 F6            lodsb      ; load ASCII to al
0594+  07F8 B9 00         cmp al, 0
0595+  07FA C6 0D 08      je mul_exit
0596+  07FD 6F 30         sub al, $30    ; make into integer
0597+  07FF 22 00         mov ah, 0
0598+  0801 2A            mov b, [d]
0599+  0802 AC            mul a, b      ; result in B since it fits in 16bits
0600+  0803 11            mov a, b
0601+  0804 28            mov b, c
0602+  0805 54            add a, b
0603+  0806 39            mov c, a
0604+  0807 63 02 00      sub d, 2
0605+  080A 0A F7 07      jmp mul_loop
0606+  080D             mul_exit:
0607+  080D 12            mov a, c
0608+  080E E7            pop d
0609+  080F E6            pop c
0610+  0810 E5            pop b
0611+  0811 EF            pop si
0612+  0812 F9            leave
0613+  0813 09            ret
0614+  0814             
0615+  0814             
0616+  0814 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0616+  0818 34 35 36 37 
0616+  081C 38 39 41 42 
0616+  0820 43 44 45 46 
0617+  0824 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0617+  0828 1B 5B 48 00 
0618+  082C             
0619+  082C             table_power:
0620+  082C 01 00         .dw 1
0621+  082E 0A 00         .dw 10
0622+  0830 64 00         .dw 100
0623+  0832 E8 03         .dw 1000
0624+  0834 10 27         .dw 100000139   0836             ; --- END INLINE ASM BLOCK
0140   0836             
0141   0836 F9            leave
0142   0837 09            ret
0143   0838             ; --- END TEXT BLOCK
0144   0838             
0145   0838             ; --- BEGIN DATA BLOCK
0146   0838             
0147   0838 3A 08       _heap_top: .dw _heap
0148   083A 00          _heap: .db 0
0149   083B             ; --- END DATA BLOCK
0150   083B             
0151   083B             .end
tasm: Number of errors = 0
