0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT SEGMENT
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; 120 + myfunc(1); 
0011   0408 FD 2E 78 00   mov32 cb, $00000078
0011   040C 00 00 
0012   040E             ; --- START TERMS
0013   040E D7            push a
0014   040F 11            mov a, b
0015   0410             ; --- START FUNCTION CALL
0016   0410 FD 2E 01 00   mov32 cb, $00000001
0016   0414 00 00 
0017   0416 FD AB         swp b
0018   0418 D8            push b
0019   0419 07 62 04      call myfunc
0020   041C 51 02 00      add sp, 2
0021   041F             ; --- END FUNCTION CALL
0022   041F 56            add b, a
0023   0420 E4            pop a
0024   0421             ; --- END TERMS
0025   0421             ; printf("Hello"); 
0026   0421             ; --- START FUNCTION CALL
0027   0421 26 8E 11      mov b, _s0 ; "Hello"
0028   0424 FD AB         swp b
0029   0426 D8            push b
0030   0427 07 F3 07      call printf
0031   042A 51 02 00      add sp, 2
0032   042D             ; --- END FUNCTION CALL
0033   042D             ; print_signed(123); 
0034   042D             ; --- START FUNCTION CALL
0035   042D FD 2E 7B 00   mov32 cb, $0000007b
0035   0431 00 00 
0036   0433 FD AB         swp b
0037   0435 D8            push b
0038   0436 07 9D 0D      call print_signed
0039   0439 51 02 00      add sp, 2
0040   043C             ; --- END FUNCTION CALL
0041   043C             ; strcpy("Hello", "World"); 
0042   043C             ; --- START FUNCTION CALL
0043   043C 26 94 11      mov b, _s1 ; "World"
0044   043F FD AB         swp b
0045   0441 D8            push b
0046   0442 26 8E 11      mov b, _s0 ; "Hello"
0047   0445 FD AB         swp b
0048   0447 D8            push b
0049   0448 07 D6 0F      call strcpy
0050   044B 51 04 00      add sp, 4
0051   044E             ; --- END FUNCTION CALL
0052   044E             ; strcat("Hi", "Hello"); 
0053   044E             ; --- START FUNCTION CALL
0054   044E 26 8E 11      mov b, _s0 ; "Hello"
0055   0451 FD AB         swp b
0056   0453 D8            push b
0057   0454 26 9A 11      mov b, _s2 ; "Hi"
0058   0457 FD AB         swp b
0059   0459 D8            push b
0060   045A 07 50 10      call strcat
0061   045D 51 04 00      add sp, 4
0062   0460             ; --- END FUNCTION CALL
0063   0460 05 0B         syscall sys_terminate_proc
0064   0462             
0065   0462             myfunc:
0066   0462 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0067   0465 F9            leave
0068   0466 09            ret
0069   0467             
0070   0467             include_stdio_asm:
0071   0467 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0072   046A             
0073   046A             ; --- BEGIN INLINE ASM SEGMENT
0074   046A             .include "lib/asm/stdio.asm"
0001+  046A             ;-----------------------------------------------------------------------------
0002+  046A             ; stdio.s
0003+  046A             ;-----------------------------------------------------------------------------
0004+  046A             .include "lib/asm/string.asm"
0001++ 046A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 046A             ; string.s
0003++ 046A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 046A             
0005++ 046A             
0006++ 046A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 046A             ; _strrev
0008++ 046A             ; reverse a string
0009++ 046A             ; D = string address
0010++ 046A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 046A             ; 01234
0012++ 046A             _strrev:
0013++ 046A 4B          	pusha
0014++ 046B 07 B1 04    	call _strlen	; length in C
0015++ 046E 12          	mov a, c
0016++ 046F AF 01 00    	cmp a, 1
0017++ 0472 D0 8C 04    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 0475 7D          	dec a
0019++ 0476 FD 4E       	mov si, d	; beginning of string
0020++ 0478 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 047A 59          	add d, a	; end of string
0022++ 047B 12          	mov a, c
0023++ 047C FD 9B       	shr a		; divide by 2
0024++ 047E 39          	mov c, a	; C now counts the steps
0025++ 047F             _strrev_L0:
0026++ 047F 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0480 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0481 3E          	mov [d], al	; store left char into right side
0029++ 0482 1B          	mov al, bl
0030++ 0483 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0484 7E          	dec c
0032++ 0485 7F          	dec d
0033++ 0486 C2 00 00    	cmp c, 0
0034++ 0489 C7 7F 04    	jne _strrev_L0
0035++ 048C             _strrev_end:
0036++ 048C 4C          	popa
0037++ 048D 09          	ret
0038++ 048E             	
0039++ 048E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 048E             ; _strchr
0041++ 048E             ; search string in D for char in AL
0042++ 048E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 048E             _strchr:
0044++ 048E             _strchr_L0:
0045++ 048E 32          	mov bl, [d]
0046++ 048F C1 00       	cmp bl, 0
0047++ 0491 C6 9C 04    	je _strchr_end
0048++ 0494 BA          	cmp al, bl
0049++ 0495 C6 9C 04    	je _strchr_end
0050++ 0498 79          	inc d
0051++ 0499 0A 8E 04    	jmp _strchr_L0
0052++ 049C             _strchr_end:
0053++ 049C 1B          	mov al, bl
0054++ 049D 09          	ret
0055++ 049E             
0056++ 049E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 049E             ; _strstr
0058++ 049E             ; find sub-string
0059++ 049E             ; str1 in SI
0060++ 049E             ; str2 in DI
0061++ 049E             ; SI points to end of source string
0062++ 049E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 049E             _strstr:
0064++ 049E DB          	push al
0065++ 049F DA          	push d
0066++ 04A0 E3          	push di
0067++ 04A1             _strstr_loop:
0068++ 04A1 F3          	cmpsb					; compare a byte of the strings
0069++ 04A2 C7 AD 04    	jne _strstr_ret
0070++ 04A5 FC 00 00    	lea d, [di + 0]
0071++ 04A8 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 04AA C7 A1 04    	jne _strstr_loop				; equal chars but not at end
0073++ 04AD             _strstr_ret:
0074++ 04AD F0          	pop di
0075++ 04AE E7          	pop d
0076++ 04AF E8          	pop al
0077++ 04B0 09          	ret
0078++ 04B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 04B1             ; length of null terminated string
0080++ 04B1             ; result in C
0081++ 04B1             ; pointer in D
0082++ 04B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 04B1             _strlen:
0084++ 04B1 DA          	push d
0085++ 04B2 38 00 00    	mov c, 0
0086++ 04B5             _strlen_L1:
0087++ 04B5 BD 00       	cmp byte [d], 0
0088++ 04B7 C6 BF 04    	je _strlen_ret
0089++ 04BA 79          	inc d
0090++ 04BB 78          	inc c
0091++ 04BC 0A B5 04    	jmp _strlen_L1
0092++ 04BF             _strlen_ret:
0093++ 04BF E7          	pop d
0094++ 04C0 09          	ret
0095++ 04C1             
0096++ 04C1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 04C1             ; STRCMP
0098++ 04C1             ; compare two strings
0099++ 04C1             ; str1 in SI
0100++ 04C1             ; str2 in DI
0101++ 04C1             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 04C1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 04C1             _strcmp:
0104++ 04C1 DB          	push al
0105++ 04C2 DA          	push d
0106++ 04C3 E3          	push di
0107++ 04C4 E2          	push si
0108++ 04C5             _strcmp_loop:
0109++ 04C5 F3          	cmpsb					; compare a byte of the strings
0110++ 04C6 C7 D1 04    	jne _strcmp_ret
0111++ 04C9 FB FF FF    	lea d, [si +- 1]
0112++ 04CC BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 04CE C7 C5 04    	jne _strcmp_loop				; equal chars but not at end
0114++ 04D1             _strcmp_ret:
0115++ 04D1 EF          	pop si
0116++ 04D2 F0          	pop di
0117++ 04D3 E7          	pop d
0118++ 04D4 E8          	pop al
0119++ 04D5 09          	ret
0120++ 04D6             
0121++ 04D6             
0122++ 04D6             ; STRCPY
0123++ 04D6             ; copy null terminated string from SI to DI
0124++ 04D6             ; source in SI
0125++ 04D6             ; destination in DI
0126++ 04D6             _strcpy:
0127++ 04D6 E2          	push si
0128++ 04D7 E3          	push di
0129++ 04D8 DB          	push al
0130++ 04D9             _strcpy_L1:
0131++ 04D9 F6          	lodsb
0132++ 04DA F7          	stosb
0133++ 04DB B9 00       	cmp al, 0
0134++ 04DD C7 D9 04    	jne _strcpy_L1
0135++ 04E0             _strcpy_end:
0136++ 04E0 E8          	pop al
0137++ 04E1 F0          	pop di
0138++ 04E2 EF          	pop si
0139++ 04E3 09          	ret
0140++ 04E4             
0141++ 04E4             ; STRCAT
0142++ 04E4             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 04E4             ; source in SI
0144++ 04E4             ; destination in DI
0145++ 04E4             _strcat:
0146++ 04E4 E2          	push si
0147++ 04E5 E3          	push di
0148++ 04E6 D7          	push a
0149++ 04E7 DA          	push d
0150++ 04E8 50          	mov a, di
0151++ 04E9 3C          	mov d, a
0152++ 04EA             _strcat_goto_end_L1:
0153++ 04EA BD 00       	cmp byte[d], 0
0154++ 04EC C6 F3 04    	je _strcat_start
0155++ 04EF 79          	inc d
0156++ 04F0 0A EA 04    	jmp _strcat_goto_end_L1
0157++ 04F3             _strcat_start:
0158++ 04F3 FD 50       	mov di, d
0159++ 04F5             _strcat_L1:
0160++ 04F5 F6          	lodsb
0161++ 04F6 F7          	stosb
0162++ 04F7 B9 00       	cmp al, 0
0163++ 04F9 C7 F5 04    	jne _strcat_L1
0164++ 04FC             _strcat_end:
0165++ 04FC E7          	pop d
0166++ 04FD E4          	pop a
0167++ 04FE F0          	pop di
0168++ 04FF EF          	pop si
0169++ 0500 09          	ret
0170++ 0501             
0171++ 0501             
0005+  0501             
0006+  0501             ;-----------------------------------------------------------------------------
0007+  0501             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0008+  0501             ; ASCII in BL
0009+  0501             ; result in AL
0010+  0501             ; ascii for F = 0100 0110
0011+  0501             ; ascii for 9 = 0011 1001
0012+  0501             ;-----------------------------------------------------------------------------
0013+  0501             hex_ascii_encode:
0014+  0501 1B            mov al, bl
0015+  0502 93 40         test al, $40        ; test if letter or number
0016+  0504 C7 0A 05      jnz hex_letter
0017+  0507 87 0F         and al, $0F        ; get number
0018+  0509 09            ret
0019+  050A             hex_letter:
0020+  050A 87 0F         and al, $0F        ; get letter
0021+  050C 6A 09         add al, 9
0022+  050E 09            ret
0023+  050F             
0024+  050F             ;-----------------------------------------------------------------------------
0025+  050F             ; ATOI
0026+  050F             ; 2 letter hex string in B
0027+  050F             ; 8bit integer returned in AL
0028+  050F             ;-----------------------------------------------------------------------------
0029+  050F             _atoi:
0030+  050F D8            push b
0031+  0510 07 01 05      call hex_ascii_encode      ; convert BL to 4bit code in AL
0032+  0513 30            mov bl, bh
0033+  0514 DB            push al          ; save a
0034+  0515 07 01 05      call hex_ascii_encode
0035+  0518 EA            pop bl  
0036+  0519 FD 9E 04      shl al, 4
0037+  051C 8C            or al, bl
0038+  051D E5            pop b
0039+  051E 09            ret  
0040+  051F             
0041+  051F             
0042+  051F             ;-----------------------------------------------------------------------------
0043+  051F             ; ITOA
0044+  051F             ; 8bit value in BL
0045+  051F             ; 2 byte ASCII result in A
0046+  051F             ;-----------------------------------------------------------------------------
0047+  051F             _itoa:
0048+  051F DA            push d
0049+  0520 D8            push b
0050+  0521 A7 00         mov bh, 0
0051+  0523 FD A4 04      shr bl, 4  
0052+  0526 74            mov d, b
0053+  0527 1F CF 07      mov al, [d + s_hex_digits]
0054+  052A 23            mov ah, al
0055+  052B               
0056+  052B E5            pop b
0057+  052C D8            push b
0058+  052D A7 00         mov bh, 0
0059+  052F FD 87 0F      and bl, $0F
0060+  0532 74            mov d, b
0061+  0533 1F CF 07      mov al, [d + s_hex_digits]
0062+  0536 E5            pop b
0063+  0537 E7            pop d
0064+  0538 09            ret
0065+  0539             
0066+  0539             ;-----------------------------------------------------------------------------
0067+  0539             ; HEX STRING TO BINARY
0068+  0539             ; di = destination address
0069+  0539             ; si = source
0070+  0539             ;-----------------------------------------------------------------------------
0071+  0539             _hex_to_int:
0072+  0539             _hex_to_int_L1:
0073+  0539 F6            lodsb          ; load from [SI] to AL
0074+  053A B9 00         cmp al, 0        ; check if ASCII 0
0075+  053C C6 49 05      jz _hex_to_int_ret
0076+  053F 36            mov bh, al
0077+  0540 F6            lodsb
0078+  0541 2F            mov bl, al
0079+  0542 07 0F 05      call _atoi        ; convert ASCII byte in B to int (to AL)
0080+  0545 F7            stosb          ; store AL to [DI]
0081+  0546 0A 39 05      jmp _hex_to_int_L1
0082+  0549             _hex_to_int_ret:
0083+  0549 09            ret    
0084+  054A             
0085+  054A             ;-----------------------------------------------------------------------------
0086+  054A             ; GETCHAR
0087+  054A             ; char in ah
0088+  054A             ;-----------------------------------------------------------------------------
0089+  054A             getch:
0090+  054A DB            push al
0091+  054B             getch_retry:
0092+  054B 19 01         mov al, 1
0093+  054D 05 03         syscall sys_io      ; receive in AH
0094+  054F E8            pop al
0095+  0550 09            ret
0096+  0551             
0097+  0551             ;-----------------------------------------------------------------------------
0098+  0551             ; PUTCHAR
0099+  0551             ; char in ah
0100+  0551             ;-----------------------------------------------------------------------------
0101+  0551             _putchar:
0102+  0551 D7            push a
0103+  0552 19 00         mov al, 0
0104+  0554 05 03         syscall sys_io      ; char in AH
0105+  0556 E4            pop a
0106+  0557 09            ret
0107+  0558             
0108+  0558             ;-----------------------------------------------------------------------------
0109+  0558             ;; INPUT A STRING
0110+  0558             ;; terminates with null
0111+  0558             ;; pointer in D
0112+  0558             ;-----------------------------------------------------------------------------
0113+  0558             _gets:
0114+  0558 D7            push a
0115+  0559 DA            push d
0116+  055A             _gets_loop:
0117+  055A 19 01         mov al, 1
0118+  055C 05 03         syscall sys_io      ; receive in AH
0119+  055E B9 00         cmp al, 0        ; check error code (AL)
0120+  0560 C6 5A 05      je _gets_loop      ; if no char received, retry
0121+  0563             
0122+  0563 76 1B         cmp ah, 27
0123+  0565 C6 86 05      je _gets_ansi_esc
0124+  0568 76 0A         cmp ah, $0A        ; LF
0125+  056A C6 F1 05      je _gets_end
0126+  056D 76 0D         cmp ah, $0D        ; CR
0127+  056F C6 F1 05      je _gets_end
0128+  0572 76 5C         cmp ah, $5C        ; '\\'
0129+  0574 C6 B2 05      je _gets_escape
0130+  0577               
0131+  0577 76 08         cmp ah, $08      ; check for backspace
0132+  0579 C6 82 05      je _gets_backspace
0133+  057C             
0134+  057C 1A            mov al, ah
0135+  057D 3E            mov [d], al
0136+  057E 79            inc d
0137+  057F 0A 5A 05      jmp _gets_loop
0138+  0582             _gets_backspace:
0139+  0582 7F            dec d
0140+  0583 0A 5A 05      jmp _gets_loop
0141+  0586             _gets_ansi_esc:
0142+  0586 19 01         mov al, 1
0143+  0588 05 03         syscall sys_io        ; receive in AH without echo
0144+  058A B9 00         cmp al, 0          ; check error code (AL)
0145+  058C C6 86 05      je _gets_ansi_esc    ; if no char received, retry
0146+  058F 76 5B         cmp ah, '['
0147+  0591 C7 5A 05      jne _gets_loop
0148+  0594             _gets_ansi_esc_2:
0149+  0594 19 01         mov al, 1
0150+  0596 05 03         syscall sys_io          ; receive in AH without echo
0151+  0598 B9 00         cmp al, 0            ; check error code (AL)
0152+  059A C6 94 05      je _gets_ansi_esc_2  ; if no char received, retry
0153+  059D 76 44         cmp ah, 'D'
0154+  059F C6 AA 05      je _gets_left_arrow
0155+  05A2 76 43         cmp ah, 'C'
0156+  05A4 C6 AE 05      je _gets_right_arrow
0157+  05A7 0A 5A 05      jmp _gets_loop
0158+  05AA             _gets_left_arrow:
0159+  05AA 7F            dec d
0160+  05AB 0A 5A 05      jmp _gets_loop
0161+  05AE             _gets_right_arrow:
0162+  05AE 79            inc d
0163+  05AF 0A 5A 05      jmp _gets_loop
0164+  05B2             _gets_escape:
0165+  05B2 19 01         mov al, 1
0166+  05B4 05 03         syscall sys_io      ; receive in AH
0167+  05B6 B9 00         cmp al, 0        ; check error code (AL)
0168+  05B8 C6 B2 05      je _gets_escape      ; if no char received, retry
0169+  05BB 76 6E         cmp ah, 'n'
0170+  05BD C6 DC 05      je _gets_LF
0171+  05C0 76 72         cmp ah, 'r'
0172+  05C2 C6 E3 05      je _gets_CR
0173+  05C5 76 30         cmp ah, '0'
0174+  05C7 C6 EA 05      je _gets_NULL
0175+  05CA 76 5C         cmp ah, $5C  ; '\'
0176+  05CC C6 D5 05      je _gets_slash
0177+  05CF 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0178+  05D0 3E            mov [d], al
0179+  05D1 79            inc d
0180+  05D2 0A 5A 05      jmp _gets_loop
0181+  05D5             _gets_slash:
0182+  05D5 19 5C         mov al, $5C
0183+  05D7 3E            mov [d], al
0184+  05D8 79            inc d
0185+  05D9 0A 5A 05      jmp _gets_loop
0186+  05DC             _gets_LF:
0187+  05DC 19 0A         mov al, $0A
0188+  05DE 3E            mov [d], al
0189+  05DF 79            inc d
0190+  05E0 0A 5A 05      jmp _gets_loop
0191+  05E3             _gets_CR:
0192+  05E3 19 0D         mov al, $0D
0193+  05E5 3E            mov [d], al
0194+  05E6 79            inc d
0195+  05E7 0A 5A 05      jmp _gets_loop
0196+  05EA             _gets_NULL:
0197+  05EA 19 00         mov al, $00
0198+  05EC 3E            mov [d], al
0199+  05ED 79            inc d
0200+  05EE 0A 5A 05      jmp _gets_loop
0201+  05F1             _gets_end:
0202+  05F1 19 00         mov al, 0
0203+  05F3 3E            mov [d], al        ; terminate string
0204+  05F4 E7            pop d
0205+  05F5 E4            pop a
0206+  05F6 09            ret
0207+  05F7             
0208+  05F7             ;-----------------------------------------------------------------------------
0209+  05F7             ;; INPUT TEXT
0210+  05F7             ;; terminated with CTRL+D
0211+  05F7             ;; pointer in D
0212+  05F7             ;-----------------------------------------------------------------------------
0213+  05F7             _gettxt:
0214+  05F7 D7            push a
0215+  05F8 DA            push d
0216+  05F9             _gettxt_loop:
0217+  05F9 19 01         mov al, 1
0218+  05FB 05 03         syscall sys_io      ; receive in AH
0219+  05FD B9 00         cmp al, 0        ; check error code (AL)
0220+  05FF C6 F9 05      je _gettxt_loop    ; if no char received, retry
0221+  0602 76 04         cmp ah, 4      ; EOT
0222+  0604 C6 42 06      je _gettxt_end
0223+  0607 76 08         cmp ah, $08      ; check for backspace
0224+  0609 C6 3E 06      je _gettxt_backspace
0225+  060C 76 5C         cmp ah, $5C        ; '\'
0226+  060E C6 17 06      je _gettxt_escape
0227+  0611 1A            mov al, ah
0228+  0612 3E            mov [d], al
0229+  0613 79            inc d
0230+  0614 0A F9 05      jmp _gettxt_loop
0231+  0617             _gettxt_escape:
0232+  0617 19 01         mov al, 1
0233+  0619 05 03         syscall sys_io      ; receive in AH
0234+  061B B9 00         cmp al, 0        ; check error code (AL)
0235+  061D C6 17 06      je _gettxt_escape    ; if no char received, retry
0236+  0620 76 6E         cmp ah, 'n'
0237+  0622 C6 30 06      je _gettxt_LF
0238+  0625 76 72         cmp ah, 'r'
0239+  0627 C6 37 06      je _gettxt_CR
0240+  062A 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0241+  062B 3E            mov [d], al
0242+  062C 79            inc d
0243+  062D 0A F9 05      jmp _gettxt_loop
0244+  0630             _gettxt_LF:
0245+  0630 19 0A         mov al, $0A
0246+  0632 3E            mov [d], al
0247+  0633 79            inc d
0248+  0634 0A F9 05      jmp _gettxt_loop
0249+  0637             _gettxt_CR:
0250+  0637 19 0D         mov al, $0D
0251+  0639 3E            mov [d], al
0252+  063A 79            inc d
0253+  063B 0A F9 05      jmp _gettxt_loop
0254+  063E             _gettxt_backspace:
0255+  063E 7F            dec d
0256+  063F 0A F9 05      jmp _gettxt_loop
0257+  0642             _gettxt_end:
0258+  0642 19 00         mov al, 0
0259+  0644 3E            mov [d], al        ; terminate string
0260+  0645 E7            pop d
0261+  0646 E4            pop a
0262+  0647 09            ret
0263+  0648             
0264+  0648             ;-----------------------------------------------------------------------------
0265+  0648             ; PRINT NEW LINE
0266+  0648             ;-----------------------------------------------------------------------------
0267+  0648             printnl:
0268+  0648 D7            push a
0269+  0649 10 00 0A      mov a, $0A00
0270+  064C 05 03         syscall sys_io
0271+  064E 10 00 0D      mov a, $0D00
0272+  0651 05 03         syscall sys_io
0273+  0653 E4            pop a
0274+  0654 09            ret
0275+  0655             
0276+  0655             ;-----------------------------------------------------------------------------
0277+  0655             ; _strtoint
0278+  0655             ; 4 digit hex string number in d
0279+  0655             ; integer returned in A
0280+  0655             ;-----------------------------------------------------------------------------
0281+  0655             _strtointx:
0282+  0655 D8            push b
0283+  0656 32            mov bl, [d]
0284+  0657 37            mov bh, bl
0285+  0658 33 01 00      mov bl, [d + 1]
0286+  065B 07 0F 05      call _atoi        ; convert to int in AL
0287+  065E 23            mov ah, al        ; move to AH
0288+  065F 33 02 00      mov bl, [d + 2]
0289+  0662 37            mov bh, bl
0290+  0663 33 03 00      mov bl, [d + 3]
0291+  0666 07 0F 05      call _atoi        ; convert to int in AL
0292+  0669 E5            pop b
0293+  066A 09            ret
0294+  066B             
0295+  066B             ;-----------------------------------------------------------------------------
0296+  066B             ; _strtoint
0297+  066B             ; 5 digit base10 string number in d
0298+  066B             ; integer returned in A
0299+  066B             ;-----------------------------------------------------------------------------
0300+  066B             _strtoint:
0301+  066B E2            push si
0302+  066C D8            push b
0303+  066D D9            push c
0304+  066E DA            push d
0305+  066F 07 B1 04      call _strlen      ; get string length in C
0306+  0672 7E            dec c
0307+  0673 FD 4E         mov si, d
0308+  0675 12            mov a, c
0309+  0676 FD 99         shl a
0310+  0678 3B E7 07      mov d, table_power
0311+  067B 59            add d, a
0312+  067C 38 00 00      mov c, 0
0313+  067F             _strtoint_L0:
0314+  067F F6            lodsb      ; load ASCII to al
0315+  0680 B9 00         cmp al, 0
0316+  0682 C6 95 06      je _strtoint_end
0317+  0685 6F 30         sub al, $30    ; make into integer
0318+  0687 22 00         mov ah, 0
0319+  0689 2A            mov b, [d]
0320+  068A AC            mul a, b      ; result in B since it fits in 16bits
0321+  068B 11            mov a, b
0322+  068C 28            mov b, c
0323+  068D 54            add a, b
0324+  068E 39            mov c, a
0325+  068F 63 02 00      sub d, 2
0326+  0692 0A 7F 06      jmp _strtoint_L0
0327+  0695             _strtoint_end:
0328+  0695 12            mov a, c
0329+  0696 E7            pop d
0330+  0697 E6            pop c
0331+  0698 E5            pop b
0332+  0699 EF            pop si
0333+  069A 09            ret
0334+  069B             
0335+  069B             ;-----------------------------------------------------------------------------
0336+  069B             ; PRINT NULL TERMINATED STRING
0337+  069B             ; pointer in D
0338+  069B             ;-----------------------------------------------------------------------------
0339+  069B             _puts:
0340+  069B D7            push a
0341+  069C DA            push d
0342+  069D             _puts_L1:
0343+  069D 1E            mov al, [d]
0344+  069E B9 00         cmp al, 0
0345+  06A0 C6 AC 06      jz _puts_END
0346+  06A3 23            mov ah, al
0347+  06A4 19 00         mov al, 0
0348+  06A6 05 03         syscall sys_io
0349+  06A8 79            inc d
0350+  06A9 0A 9D 06      jmp _puts_L1
0351+  06AC             _puts_END:
0352+  06AC E7            pop d
0353+  06AD E4            pop a
0354+  06AE 09            ret
0355+  06AF             
0356+  06AF             ;-----------------------------------------------------------------------------
0357+  06AF             ; PRINT N SIZE STRING
0358+  06AF             ; pointer in D
0359+  06AF             ; size in C
0360+  06AF             ;-----------------------------------------------------------------------------
0361+  06AF             _putsn:
0362+  06AF DB            push al
0363+  06B0 DA            push d
0364+  06B1 D9            push c
0365+  06B2             _putsn_L0:
0366+  06B2 1E            mov al, [d]
0367+  06B3 23            mov ah, al
0368+  06B4 19 00         mov al, 0
0369+  06B6 05 03         syscall sys_io
0370+  06B8 79            inc d
0371+  06B9 7E            dec c  
0372+  06BA C2 00 00      cmp c, 0
0373+  06BD C7 B2 06      jne _putsn_L0
0374+  06C0             _putsn_end:
0375+  06C0 E6            pop c
0376+  06C1 E7            pop d
0377+  06C2 E8            pop al
0378+  06C3 09            ret
0379+  06C4             
0380+  06C4             ;-----------------------------------------------------------------------------
0381+  06C4             ; print 16bit decimal number
0382+  06C4             ; input number in A
0383+  06C4             ;-----------------------------------------------------------------------------
0384+  06C4             print_u16d:
0385+  06C4 D7            push a
0386+  06C5 D8            push b
0387+  06C6 26 10 27      mov b, 10000
0388+  06C9 AE            div a, b      ; get 10000's coeff.
0389+  06CA 07 EC 06      call print_number
0390+  06CD 11            mov a, b
0391+  06CE 26 E8 03      mov b, 1000
0392+  06D1 AE            div a, b      ; get 1000's coeff.
0393+  06D2 07 EC 06      call print_number
0394+  06D5 11            mov a, b
0395+  06D6 26 64 00      mov b, 100
0396+  06D9 AE            div a, b
0397+  06DA 07 EC 06      call print_number
0398+  06DD 11            mov a, b
0399+  06DE 26 0A 00      mov b, 10
0400+  06E1 AE            div a, b
0401+  06E2 07 EC 06      call print_number
0402+  06E5 1B            mov al, bl      ; 1's coeff in bl
0403+  06E6 07 EC 06      call print_number
0404+  06E9 E5            pop b
0405+  06EA E4            pop a
0406+  06EB 09            ret
0407+  06EC             
0408+  06EC             ;-----------------------------------------------------------------------------
0409+  06EC             ; print AL
0410+  06EC             ;-----------------------------------------------------------------------------
0411+  06EC             print_number:
0412+  06EC 6A 30         add al, $30
0413+  06EE 23            mov ah, al
0414+  06EF 07 51 05      call _putchar
0415+  06F2 09            ret
0416+  06F3             
0417+  06F3             ;-----------------------------------------------------------------------------
0418+  06F3             ; PRINT 16BIT HEX INTEGER
0419+  06F3             ; integer value in reg B
0420+  06F3             ;-----------------------------------------------------------------------------
0421+  06F3             print_u16x:
0422+  06F3 D7            push a
0423+  06F4 D8            push b
0424+  06F5 DD            push bl
0425+  06F6 30            mov bl, bh
0426+  06F7 07 1F 05      call _itoa        ; convert bh to char in A
0427+  06FA 2F            mov bl, al        ; save al
0428+  06FB 19 00         mov al, 0
0429+  06FD 05 03         syscall sys_io        ; display AH
0430+  06FF 24            mov ah, bl        ; retrieve al
0431+  0700 19 00         mov al, 0
0432+  0702 05 03         syscall sys_io        ; display AL
0433+  0704             
0434+  0704 EA            pop bl
0435+  0705 07 1F 05      call _itoa        ; convert bh to char in A
0436+  0708 2F            mov bl, al        ; save al
0437+  0709 19 00         mov al, 0
0438+  070B 05 03         syscall sys_io        ; display AH
0439+  070D 24            mov ah, bl        ; retrieve al
0440+  070E 19 00         mov al, 0
0441+  0710 05 03         syscall sys_io        ; display AL
0442+  0712             
0443+  0712 E5            pop b
0444+  0713 E4            pop a
0445+  0714 09            ret
0446+  0715             
0447+  0715             ;-----------------------------------------------------------------------------
0448+  0715             ; INPUT 16BIT HEX INTEGER
0449+  0715             ; read 16bit integer into A
0450+  0715             ;-----------------------------------------------------------------------------
0451+  0715             scan_u16x:
0452+  0715 F8 10 00      enter 16
0453+  0718 D8            push b
0454+  0719 DA            push d
0455+  071A             
0456+  071A FA F1 FF      lea d, [bp + -15]
0457+  071D 07 58 05      call _gets        ; get number
0458+  0720             
0459+  0720 32            mov bl, [d]
0460+  0721 37            mov bh, bl
0461+  0722 33 01 00      mov bl, [d + 1]
0462+  0725 07 0F 05      call _atoi        ; convert to int in AL
0463+  0728 23            mov ah, al        ; move to AH
0464+  0729             
0465+  0729 33 02 00      mov bl, [d + 2]
0466+  072C 37            mov bh, bl
0467+  072D 33 03 00      mov bl, [d + 3]
0468+  0730 07 0F 05      call _atoi        ; convert to int in AL
0469+  0733             
0470+  0733 E7            pop d
0471+  0734 E5            pop b
0472+  0735 F9            leave
0473+  0736 09            ret
0474+  0737             
0475+  0737             ;-----------------------------------------------------------------------------
0476+  0737             ; PRINT 8bit HEX INTEGER
0477+  0737             ; integer value in reg bl
0478+  0737             ;-----------------------------------------------------------------------------
0479+  0737             print_u8x:
0480+  0737 D7            push a
0481+  0738 DD            push bl
0482+  0739             
0483+  0739 07 1F 05      call _itoa        ; convert bl to char in A
0484+  073C 2F            mov bl, al        ; save al
0485+  073D 19 00         mov al, 0
0486+  073F 05 03         syscall sys_io        ; display AH
0487+  0741 24            mov ah, bl        ; retrieve al
0488+  0742 19 00         mov al, 0
0489+  0744 05 03         syscall sys_io        ; display AL
0490+  0746             
0491+  0746 EA            pop bl
0492+  0747 E4            pop a
0493+  0748 09            ret
0494+  0749             
0495+  0749             ;-----------------------------------------------------------------------------
0496+  0749             ; print 8bit decimal unsigned number
0497+  0749             ; input number in AL
0498+  0749             ;-----------------------------------------------------------------------------
0499+  0749             print_u8d:
0500+  0749 D7            push a
0501+  074A D8            push b
0502+  074B             
0503+  074B 22 00         mov ah, 0
0504+  074D 26 64 00      mov b, 100
0505+  0750 AE            div a, b
0506+  0751 D8            push b      ; save remainder
0507+  0752 B9 00         cmp al, 0
0508+  0754 C6 5E 07      je skip100
0509+  0757 6A 30         add al, $30
0510+  0759 23            mov ah, al
0511+  075A 19 00         mov al, 0
0512+  075C 05 03         syscall sys_io  ; print coeff
0513+  075E             skip100:
0514+  075E E4            pop a
0515+  075F 22 00         mov ah, 0
0516+  0761 26 0A 00      mov b, 10
0517+  0764 AE            div a, b
0518+  0765 D8            push b      ; save remainder
0519+  0766 B9 00         cmp al, 0
0520+  0768 C6 72 07      je skip10
0521+  076B 6A 30         add al, $30
0522+  076D 23            mov ah, al
0523+  076E 19 00         mov al, 0
0524+  0770 05 03         syscall sys_io  ; print coeff
0525+  0772             skip10:
0526+  0772 E4            pop a
0527+  0773 1B            mov al, bl
0528+  0774 6A 30         add al, $30
0529+  0776 23            mov ah, al
0530+  0777 19 00         mov al, 0
0531+  0779 05 03         syscall sys_io  ; print coeff
0532+  077B E5            pop b
0533+  077C E4            pop a
0534+  077D 09            ret
0535+  077E             
0536+  077E             ;-----------------------------------------------------------------------------
0537+  077E             ; INPUT 8BIT HEX INTEGER
0538+  077E             ; read 8bit integer into AL
0539+  077E             ;-----------------------------------------------------------------------------
0540+  077E             scan_u8x:
0541+  077E F8 04 00      enter 4
0542+  0781 D8            push b
0543+  0782 DA            push d
0544+  0783             
0545+  0783 FA FD FF      lea d, [bp + -3]
0546+  0786 07 58 05      call _gets        ; get number
0547+  0789             
0548+  0789 32            mov bl, [d]
0549+  078A 37            mov bh, bl
0550+  078B 33 01 00      mov bl, [d + 1]
0551+  078E 07 0F 05      call _atoi        ; convert to int in AL
0552+  0791             
0553+  0791 E7            pop d
0554+  0792 E5            pop b
0555+  0793 F9            leave
0556+  0794 09            ret
0557+  0795             
0558+  0795             ;-----------------------------------------------------------------------------
0559+  0795             ; input decimal number
0560+  0795             ; result in A
0561+  0795             ; 655'\0'
0562+  0795             ; low--------high
0563+  0795             ;-----------------------------------------------------------------------------
0564+  0795             scan_u16d:
0565+  0795 F8 08 00      enter 8
0566+  0798 E2            push si
0567+  0799 D8            push b
0568+  079A D9            push c
0569+  079B DA            push d
0570+  079C FA F9 FF      lea d, [bp +- 7]
0571+  079F 07 58 05      call _gets
0572+  07A2 07 B1 04      call _strlen      ; get string length in C
0573+  07A5 7E            dec c
0574+  07A6 FD 4E         mov si, d
0575+  07A8 12            mov a, c
0576+  07A9 FD 99         shl a
0577+  07AB 3B E7 07      mov d, table_power
0578+  07AE 59            add d, a
0579+  07AF 38 00 00      mov c, 0
0580+  07B2             mul_loop:
0581+  07B2 F6            lodsb      ; load ASCII to al
0582+  07B3 B9 00         cmp al, 0
0583+  07B5 C6 C8 07      je mul_exit
0584+  07B8 6F 30         sub al, $30    ; make into integer
0585+  07BA 22 00         mov ah, 0
0586+  07BC 2A            mov b, [d]
0587+  07BD AC            mul a, b      ; result in B since it fits in 16bits
0588+  07BE 11            mov a, b
0589+  07BF 28            mov b, c
0590+  07C0 54            add a, b
0591+  07C1 39            mov c, a
0592+  07C2 63 02 00      sub d, 2
0593+  07C5 0A B2 07      jmp mul_loop
0594+  07C8             mul_exit:
0595+  07C8 12            mov a, c
0596+  07C9 E7            pop d
0597+  07CA E6            pop c
0598+  07CB E5            pop b
0599+  07CC EF            pop si
0600+  07CD F9            leave
0601+  07CE 09            ret
0602+  07CF             
0603+  07CF 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0603+  07D3 34 35 36 37 
0603+  07D7 38 39 41 42 
0603+  07DB 43 44 45 46 
0604+  07DF 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0604+  07E3 1B 5B 48 00 
0605+  07E7             
0606+  07E7             table_power:
0607+  07E7 01 00         .dw 1
0608+  07E9 0A 00         .dw 10
0609+  07EB 64 00         .dw 100
0610+  07ED E8 03         .dw 1000
0611+  07EF 10 27         .dw 100000075   07F1             ; --- END INLINE ASM SEGMENT
0076   07F1             
0077   07F1 F9            leave
0078   07F2 09            ret
0079   07F3             
0080   07F3             printf:
0081   07F3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0082   07F6             ; char *p, *format_p; 
0083   07F6 52 02 00      sub sp, 2
0084   07F9 52 02 00      sub sp, 2
0085   07FC             ; format_p = format; 
0086   07FC FA FD FF      lea d, [bp + -3] ; $format_p
0087   07FF DA            push d
0088   0800 FA 05 00      lea d, [bp + 5] ; $format
0089   0803 2A            mov b, [d]
0090   0804 38 00 00      mov c, 0
0091   0807 E7            pop d
0092   0808 FD 43         mov [d], b
0093   080A             ; p = &format + 2; 
0094   080A FA FF FF      lea d, [bp + -1] ; $p
0095   080D DA            push d
0096   080E FA 05 00      lea d, [bp + 5] ; $format
0097   0811 2D            mov b, d
0098   0812             ; --- START TERMS
0099   0812 D7            push a
0100   0813 11            mov a, b
0101   0814 FD 2E 02 00   mov32 cb, $00000002
0101   0818 00 00 
0102   081A 56            add b, a
0103   081B E4            pop a
0104   081C             ; --- END TERMS
0105   081C E7            pop d
0106   081D FD 43         mov [d], b
0107   081F             ; for(;;){ 
0108   081F             _for1_init:
0109   081F             _for1_cond:
0110   081F             _for1_block:
0111   081F             ; if(!*format_p) break; 
0112   081F             _if2_cond:
0113   081F FA FD FF      lea d, [bp + -3] ; $format_p
0114   0822 2A            mov b, [d]
0115   0823 38 00 00      mov c, 0
0116   0826 74            mov d, b
0117   0827 32            mov bl, [d]
0118   0828 A7 00         mov bh, 0
0119   082A 38 00 00      mov c, 0
0120   082D C0 00 00      cmp b, 0
0121   0830 FD 71         seq ; !
0122   0832 C0 00 00      cmp b, 0
0123   0835 C6 3E 08      je _if2_else
0124   0838             _if2_TRUE:
0125   0838             ; break; 
0126   0838 0A CF 0A      jmp _for1_exit ; for break
0127   083B 0A CC 0A      jmp _if2_exit
0128   083E             _if2_else:
0129   083E             ; if(*format_p == '%'){ 
0130   083E             _if3_cond:
0131   083E FA FD FF      lea d, [bp + -3] ; $format_p
0132   0841 2A            mov b, [d]
0133   0842 38 00 00      mov c, 0
0134   0845 74            mov d, b
0135   0846 32            mov bl, [d]
0136   0847 A7 00         mov bh, 0
0137   0849 38 00 00      mov c, 0
0138   084C             ; --- START RELATIONAL
0139   084C D7            push a
0140   084D 11            mov a, b
0141   084E FD 2E 25 00   mov32 cb, $00000025
0141   0852 00 00 
0142   0854 B0            cmp a, b
0143   0855 FD 71         seq ; ==
0144   0857 E4            pop a
0145   0858             ; --- END RELATIONAL
0146   0858 C0 00 00      cmp b, 0
0147   085B C6 A7 0A      je _if3_else
0148   085E             _if3_TRUE:
0149   085E             ; format_p++; 
0150   085E FA FD FF      lea d, [bp + -3] ; $format_p
0151   0861 2A            mov b, [d]
0152   0862 38 00 00      mov c, 0
0153   0865 FD 77         inc b
0154   0867 FA FD FF      lea d, [bp + -3] ; $format_p
0155   086A FD 43         mov [d], b
0156   086C FD 7D         dec b
0157   086E             ; switch(*format_p){ 
0158   086E             _switch4_expr:
0159   086E FA FD FF      lea d, [bp + -3] ; $format_p
0160   0871 2A            mov b, [d]
0161   0872 38 00 00      mov c, 0
0162   0875 74            mov d, b
0163   0876 32            mov bl, [d]
0164   0877 A7 00         mov bh, 0
0165   0879 38 00 00      mov c, 0
0166   087C             _switch4_comparisons:
0167   087C C1 6C         cmp bl, $6c
0168   087E C6 AA 08      je _switch4_case0
0169   0881 C1 4C         cmp bl, $4c
0170   0883 C6 AA 08      je _switch4_case1
0171   0886 C1 64         cmp bl, $64
0172   0888 C6 BA 09      je _switch4_case2
0173   088B C1 69         cmp bl, $69
0174   088D C6 BA 09      je _switch4_case3
0175   0890 C1 75         cmp bl, $75
0176   0892 C6 EA 09      je _switch4_case4
0177   0895 C1 78         cmp bl, $78
0178   0897 C6 1A 0A      je _switch4_case5
0179   089A C1 63         cmp bl, $63
0180   089C C6 3E 0A      je _switch4_case6
0181   089F C1 73         cmp bl, $73
0182   08A1 C6 63 0A      je _switch4_case7
0183   08A4 0A 88 0A      jmp _switch4_default
0184   08A7 0A 94 0A      jmp _switch4_exit
0185   08AA             _switch4_case0:
0186   08AA             _switch4_case1:
0187   08AA             ; format_p++; 
0188   08AA FA FD FF      lea d, [bp + -3] ; $format_p
0189   08AD 2A            mov b, [d]
0190   08AE 38 00 00      mov c, 0
0191   08B1 FD 77         inc b
0192   08B3 FA FD FF      lea d, [bp + -3] ; $format_p
0193   08B6 FD 43         mov [d], b
0194   08B8 FD 7D         dec b
0195   08BA             ; if(*format_p == 'd' || *format_p == 'i') 
0196   08BA             _if5_cond:
0197   08BA FA FD FF      lea d, [bp + -3] ; $format_p
0198   08BD 2A            mov b, [d]
0199   08BE 38 00 00      mov c, 0
0200   08C1 74            mov d, b
0201   08C2 32            mov bl, [d]
0202   08C3 A7 00         mov bh, 0
0203   08C5 38 00 00      mov c, 0
0204   08C8             ; --- START RELATIONAL
0205   08C8 D7            push a
0206   08C9 11            mov a, b
0207   08CA FD 2E 64 00   mov32 cb, $00000064
0207   08CE 00 00 
0208   08D0 B0            cmp a, b
0209   08D1 FD 71         seq ; ==
0210   08D3 E4            pop a
0211   08D4             ; --- END RELATIONAL
0212   08D4             ; --- START LOGICAL OR
0213   08D4 D7            push a
0214   08D5 11            mov a, b
0215   08D6 FA FD FF      lea d, [bp + -3] ; $format_p
0216   08D9 2A            mov b, [d]
0217   08DA 38 00 00      mov c, 0
0218   08DD 74            mov d, b
0219   08DE 32            mov bl, [d]
0220   08DF A7 00         mov bh, 0
0221   08E1 38 00 00      mov c, 0
0222   08E4             ; --- START RELATIONAL
0223   08E4 D7            push a
0224   08E5 11            mov a, b
0225   08E6 FD 2E 69 00   mov32 cb, $00000069
0225   08EA 00 00 
0226   08EC B0            cmp a, b
0227   08ED FD 71         seq ; ==
0228   08EF E4            pop a
0229   08F0             ; --- END RELATIONAL
0230   08F0 FD A8         sor a, b ; ||
0231   08F2 E4            pop a
0232   08F3             ; --- END LOGICAL OR
0233   08F3 C0 00 00      cmp b, 0
0234   08F6 C6 17 09      je _if5_else
0235   08F9             _if5_TRUE:
0236   08F9             ; print_signed_long(*(long *)p); 
0237   08F9             ; --- START FUNCTION CALL
0238   08F9 FA FF FF      lea d, [bp + -1] ; $p
0239   08FC 2A            mov b, [d]
0240   08FD 38 00 00      mov c, 0
0241   0900 74            mov d, b
0242   0901 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0243   0904 FD 39         mov c, b ; And place it into C
0244   0906 2A            mov b, [d] ; Lower Word in B
0245   0907 12            mov a, c
0246   0908 FD AA         swp a
0247   090A D7            push a
0248   090B FD AB         swp b
0249   090D D8            push b
0250   090E 07 D1 0A      call print_signed_long
0251   0911 51 04 00      add sp, 4
0252   0914             ; --- END FUNCTION CALL
0253   0914 0A 9F 09      jmp _if5_exit
0254   0917             _if5_else:
0255   0917             ; if(*format_p == 'u') 
0256   0917             _if6_cond:
0257   0917 FA FD FF      lea d, [bp + -3] ; $format_p
0258   091A 2A            mov b, [d]
0259   091B 38 00 00      mov c, 0
0260   091E 74            mov d, b
0261   091F 32            mov bl, [d]
0262   0920 A7 00         mov bh, 0
0263   0922 38 00 00      mov c, 0
0264   0925             ; --- START RELATIONAL
0265   0925 D7            push a
0266   0926 11            mov a, b
0267   0927 FD 2E 75 00   mov32 cb, $00000075
0267   092B 00 00 
0268   092D B0            cmp a, b
0269   092E FD 71         seq ; ==
0270   0930 E4            pop a
0271   0931             ; --- END RELATIONAL
0272   0931 C0 00 00      cmp b, 0
0273   0934 C6 55 09      je _if6_else
0274   0937             _if6_TRUE:
0275   0937             ; print_unsigned_long(*(unsigned long *)p); 
0276   0937             ; --- START FUNCTION CALL
0277   0937 FA FF FF      lea d, [bp + -1] ; $p
0278   093A 2A            mov b, [d]
0279   093B 38 00 00      mov c, 0
0280   093E 74            mov d, b
0281   093F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0282   0942 FD 39         mov c, b ; And place it into C
0283   0944 2A            mov b, [d] ; Lower Word in B
0284   0945 12            mov a, c
0285   0946 FD AA         swp a
0286   0948 D7            push a
0287   0949 FD AB         swp b
0288   094B D8            push b
0289   094C 07 4D 0C      call print_unsigned_long
0290   094F 51 04 00      add sp, 4
0291   0952             ; --- END FUNCTION CALL
0292   0952 0A 9F 09      jmp _if6_exit
0293   0955             _if6_else:
0294   0955             ; if(*format_p == 'x') 
0295   0955             _if7_cond:
0296   0955 FA FD FF      lea d, [bp + -3] ; $format_p
0297   0958 2A            mov b, [d]
0298   0959 38 00 00      mov c, 0
0299   095C 74            mov d, b
0300   095D 32            mov bl, [d]
0301   095E A7 00         mov bh, 0
0302   0960 38 00 00      mov c, 0
0303   0963             ; --- START RELATIONAL
0304   0963 D7            push a
0305   0964 11            mov a, b
0306   0965 FD 2E 78 00   mov32 cb, $00000078
0306   0969 00 00 
0307   096B B0            cmp a, b
0308   096C FD 71         seq ; ==
0309   096E E4            pop a
0310   096F             ; --- END RELATIONAL
0311   096F C0 00 00      cmp b, 0
0312   0972 C6 93 09      je _if7_else
0313   0975             _if7_TRUE:
0314   0975             ; printx32(*(long int *)p); 
0315   0975             ; --- START FUNCTION CALL
0316   0975 FA FF FF      lea d, [bp + -1] ; $p
0317   0978 2A            mov b, [d]
0318   0979 38 00 00      mov c, 0
0319   097C 74            mov d, b
0320   097D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0321   0980 FD 39         mov c, b ; And place it into C
0322   0982 2A            mov b, [d] ; Lower Word in B
0323   0983 12            mov a, c
0324   0984 FD AA         swp a
0325   0986 D7            push a
0326   0987 FD AB         swp b
0327   0989 D8            push b
0328   098A 07 69 0D      call printx32
0329   098D 51 04 00      add sp, 4
0330   0990             ; --- END FUNCTION CALL
0331   0990 0A 9F 09      jmp _if7_exit
0332   0993             _if7_else:
0333   0993             ; err("Unexpected format in printf."); 
0334   0993             ; --- START FUNCTION CALL
0335   0993 26 9D 11      mov b, _s3 ; "Unexpected format in printf."
0336   0996 FD AB         swp b
0337   0998 D8            push b
0338   0999 07 7B 0D      call err
0339   099C 51 02 00      add sp, 2
0340   099F             ; --- END FUNCTION CALL
0341   099F             _if7_exit:
0342   099F             _if6_exit:
0343   099F             _if5_exit:
0344   099F             ; p = p + 4; 
0345   099F FA FF FF      lea d, [bp + -1] ; $p
0346   09A2 DA            push d
0347   09A3 FA FF FF      lea d, [bp + -1] ; $p
0348   09A6 2A            mov b, [d]
0349   09A7 38 00 00      mov c, 0
0350   09AA             ; --- START TERMS
0351   09AA D7            push a
0352   09AB 11            mov a, b
0353   09AC FD 2E 04 00   mov32 cb, $00000004
0353   09B0 00 00 
0354   09B2 56            add b, a
0355   09B3 E4            pop a
0356   09B4             ; --- END TERMS
0357   09B4 E7            pop d
0358   09B5 FD 43         mov [d], b
0359   09B7             ; break; 
0360   09B7 0A 94 0A      jmp _switch4_exit ; case break
0361   09BA             _switch4_case2:
0362   09BA             _switch4_case3:
0363   09BA             ; print_signed(*(int*)p); 
0364   09BA             ; --- START FUNCTION CALL
0365   09BA FA FF FF      lea d, [bp + -1] ; $p
0366   09BD 2A            mov b, [d]
0367   09BE 38 00 00      mov c, 0
0368   09C1 74            mov d, b
0369   09C2 2A            mov b, [d]
0370   09C3 38 00 00      mov c, 0
0371   09C6 FD AB         swp b
0372   09C8 D8            push b
0373   09C9 07 9D 0D      call print_signed
0374   09CC 51 02 00      add sp, 2
0375   09CF             ; --- END FUNCTION CALL
0376   09CF             ; p = p + 2; 
0377   09CF FA FF FF      lea d, [bp + -1] ; $p
0378   09D2 DA            push d
0379   09D3 FA FF FF      lea d, [bp + -1] ; $p
0380   09D6 2A            mov b, [d]
0381   09D7 38 00 00      mov c, 0
0382   09DA             ; --- START TERMS
0383   09DA D7            push a
0384   09DB 11            mov a, b
0385   09DC FD 2E 02 00   mov32 cb, $00000002
0385   09E0 00 00 
0386   09E2 56            add b, a
0387   09E3 E4            pop a
0388   09E4             ; --- END TERMS
0389   09E4 E7            pop d
0390   09E5 FD 43         mov [d], b
0391   09E7             ; break; 
0392   09E7 0A 94 0A      jmp _switch4_exit ; case break
0393   09EA             _switch4_case4:
0394   09EA             ; print_unsigned(*(unsigned int*)p); 
0395   09EA             ; --- START FUNCTION CALL
0396   09EA FA FF FF      lea d, [bp + -1] ; $p
0397   09ED 2A            mov b, [d]
0398   09EE 38 00 00      mov c, 0
0399   09F1 74            mov d, b
0400   09F2 2A            mov b, [d]
0401   09F3 38 00 00      mov c, 0
0402   09F6 FD AB         swp b
0403   09F8 D8            push b
0404   09F9 07 D6 0E      call print_unsigned
0405   09FC 51 02 00      add sp, 2
0406   09FF             ; --- END FUNCTION CALL
0407   09FF             ; p = p + 2; 
0408   09FF FA FF FF      lea d, [bp + -1] ; $p
0409   0A02 DA            push d
0410   0A03 FA FF FF      lea d, [bp + -1] ; $p
0411   0A06 2A            mov b, [d]
0412   0A07 38 00 00      mov c, 0
0413   0A0A             ; --- START TERMS
0414   0A0A D7            push a
0415   0A0B 11            mov a, b
0416   0A0C FD 2E 02 00   mov32 cb, $00000002
0416   0A10 00 00 
0417   0A12 56            add b, a
0418   0A13 E4            pop a
0419   0A14             ; --- END TERMS
0420   0A14 E7            pop d
0421   0A15 FD 43         mov [d], b
0422   0A17             ; break; 
0423   0A17 0A 94 0A      jmp _switch4_exit ; case break
0424   0A1A             _switch4_case5:
0425   0A1A             
0426   0A1A             ; --- BEGIN INLINE ASM SEGMENT
0427   0A1A FA FF FF      lea d, [bp + -1] ; $p
0428   0A1D FD 2A         mov d, [d]
0429   0A1F 2A            mov b, [d]
0430   0A20 07 F3 06      call print_u16x
0431   0A23             ; --- END INLINE ASM SEGMENT
0432   0A23             
0433   0A23             ; p = p + 2; 
0434   0A23 FA FF FF      lea d, [bp + -1] ; $p
0435   0A26 DA            push d
0436   0A27 FA FF FF      lea d, [bp + -1] ; $p
0437   0A2A 2A            mov b, [d]
0438   0A2B 38 00 00      mov c, 0
0439   0A2E             ; --- START TERMS
0440   0A2E D7            push a
0441   0A2F 11            mov a, b
0442   0A30 FD 2E 02 00   mov32 cb, $00000002
0442   0A34 00 00 
0443   0A36 56            add b, a
0444   0A37 E4            pop a
0445   0A38             ; --- END TERMS
0446   0A38 E7            pop d
0447   0A39 FD 43         mov [d], b
0448   0A3B             ; break; 
0449   0A3B 0A 94 0A      jmp _switch4_exit ; case break
0450   0A3E             _switch4_case6:
0451   0A3E             
0452   0A3E             ; --- BEGIN INLINE ASM SEGMENT
0453   0A3E FA FF FF      lea d, [bp + -1] ; $p
0454   0A41 FD 2A         mov d, [d]
0455   0A43 1E            mov al, [d]
0456   0A44 23            mov ah, al
0457   0A45 07 51 05      call _putchar
0458   0A48             ; --- END INLINE ASM SEGMENT
0459   0A48             
0460   0A48             ; p = p + 1; 
0461   0A48 FA FF FF      lea d, [bp + -1] ; $p
0462   0A4B DA            push d
0463   0A4C FA FF FF      lea d, [bp + -1] ; $p
0464   0A4F 2A            mov b, [d]
0465   0A50 38 00 00      mov c, 0
0466   0A53             ; --- START TERMS
0467   0A53 D7            push a
0468   0A54 11            mov a, b
0469   0A55 FD 2E 01 00   mov32 cb, $00000001
0469   0A59 00 00 
0470   0A5B 56            add b, a
0471   0A5C E4            pop a
0472   0A5D             ; --- END TERMS
0473   0A5D E7            pop d
0474   0A5E FD 43         mov [d], b
0475   0A60             ; break; 
0476   0A60 0A 94 0A      jmp _switch4_exit ; case break
0477   0A63             _switch4_case7:
0478   0A63             
0479   0A63             ; --- BEGIN INLINE ASM SEGMENT
0480   0A63 FA FF FF      lea d, [bp + -1] ; $p
0481   0A66 FD 2A         mov d, [d]
0482   0A68 FD 2A         mov d, [d]
0483   0A6A 07 9B 06      call _puts
0484   0A6D             ; --- END INLINE ASM SEGMENT
0485   0A6D             
0486   0A6D             ; p = p + 2; 
0487   0A6D FA FF FF      lea d, [bp + -1] ; $p
0488   0A70 DA            push d
0489   0A71 FA FF FF      lea d, [bp + -1] ; $p
0490   0A74 2A            mov b, [d]
0491   0A75 38 00 00      mov c, 0
0492   0A78             ; --- START TERMS
0493   0A78 D7            push a
0494   0A79 11            mov a, b
0495   0A7A FD 2E 02 00   mov32 cb, $00000002
0495   0A7E 00 00 
0496   0A80 56            add b, a
0497   0A81 E4            pop a
0498   0A82             ; --- END TERMS
0499   0A82 E7            pop d
0500   0A83 FD 43         mov [d], b
0501   0A85             ; break; 
0502   0A85 0A 94 0A      jmp _switch4_exit ; case break
0503   0A88             _switch4_default:
0504   0A88             ; print("Error: Unknown argument type.\n"); 
0505   0A88             ; --- START FUNCTION CALL
0506   0A88 26 BA 11      mov b, _s4 ; "Error: Unknown argument type.\n"
0507   0A8B FD AB         swp b
0508   0A8D D8            push b
0509   0A8E 07 90 0D      call print
0510   0A91 51 02 00      add sp, 2
0511   0A94             ; --- END FUNCTION CALL
0512   0A94             _switch4_exit:
0513   0A94             ; format_p++; 
0514   0A94 FA FD FF      lea d, [bp + -3] ; $format_p
0515   0A97 2A            mov b, [d]
0516   0A98 38 00 00      mov c, 0
0517   0A9B FD 77         inc b
0518   0A9D FA FD FF      lea d, [bp + -3] ; $format_p
0519   0AA0 FD 43         mov [d], b
0520   0AA2 FD 7D         dec b
0521   0AA4 0A CC 0A      jmp _if3_exit
0522   0AA7             _if3_else:
0523   0AA7             ; putchar(*format_p); 
0524   0AA7             ; --- START FUNCTION CALL
0525   0AA7 FA FD FF      lea d, [bp + -3] ; $format_p
0526   0AAA 2A            mov b, [d]
0527   0AAB 38 00 00      mov c, 0
0528   0AAE 74            mov d, b
0529   0AAF 32            mov bl, [d]
0530   0AB0 A7 00         mov bh, 0
0531   0AB2 38 00 00      mov c, 0
0532   0AB5 DD            push bl
0533   0AB6 07 40 0C      call putchar
0534   0AB9 51 01 00      add sp, 1
0535   0ABC             ; --- END FUNCTION CALL
0536   0ABC             ; format_p++; 
0537   0ABC FA FD FF      lea d, [bp + -3] ; $format_p
0538   0ABF 2A            mov b, [d]
0539   0AC0 38 00 00      mov c, 0
0540   0AC3 FD 77         inc b
0541   0AC5 FA FD FF      lea d, [bp + -3] ; $format_p
0542   0AC8 FD 43         mov [d], b
0543   0ACA FD 7D         dec b
0544   0ACC             _if3_exit:
0545   0ACC             _if2_exit:
0546   0ACC             _for1_update:
0547   0ACC 0A 1F 08      jmp _for1_cond
0548   0ACF             _for1_exit:
0549   0ACF F9            leave
0550   0AD0 09            ret
0551   0AD1             
0552   0AD1             print_signed_long:
0553   0AD1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0554   0AD4             ; char digits[10]; 
0555   0AD4 52 0A 00      sub sp, 10
0556   0AD7             ; int i = 0; 
0557   0AD7 52 02 00      sub sp, 2
0558   0ADA             ; --- START LOCAL VAR INITIALIZATION
0559   0ADA FA F5 FF      lea d, [bp + -11] ; $i
0560   0ADD DA            push d
0561   0ADE FD 2E 00 00   mov32 cb, $00000000
0561   0AE2 00 00 
0562   0AE4 E7            pop d
0563   0AE5 FD 43         mov [d], b
0564   0AE7             ; --- END LOCAL VAR INITIALIZATION
0565   0AE7             ; if (num < 0) { 
0566   0AE7             _if8_cond:
0567   0AE7 FA 05 00      lea d, [bp + 5] ; $num
0568   0AEA 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0569   0AED FD 39         mov c, b ; And place it into C
0570   0AEF 2A            mov b, [d] ; Lower Word in B
0571   0AF0             ; --- START RELATIONAL
0572   0AF0 D7            push a
0573   0AF1 FD D8         push g
0574   0AF3 11            mov a, b
0575   0AF4 FD 7A         mov g, c
0576   0AF6 FD 2E 00 00   mov32 cb, $00000000
0576   0AFA 00 00 
0577   0AFC FD AF         cmp32 ga, cb
0578   0AFE FD 73         slt ; <
0579   0B00 FD F1         pop g
0580   0B02 E4            pop a
0581   0B03             ; --- END RELATIONAL
0582   0B03 C0 00 00      cmp b, 0
0583   0B06 C6 3A 0B      je _if8_else
0584   0B09             _if8_TRUE:
0585   0B09             ; putchar('-'); 
0586   0B09             ; --- START FUNCTION CALL
0587   0B09 FD 2E 2D 00   mov32 cb, $0000002d
0587   0B0D 00 00 
0588   0B0F DD            push bl
0589   0B10 07 40 0C      call putchar
0590   0B13 51 01 00      add sp, 1
0591   0B16             ; --- END FUNCTION CALL
0592   0B16             ; num = -num; 
0593   0B16 FA 05 00      lea d, [bp + 5] ; $num
0594   0B19 DA            push d
0595   0B1A FA 05 00      lea d, [bp + 5] ; $num
0596   0B1D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0597   0B20 FD 39         mov c, b ; And place it into C
0598   0B22 2A            mov b, [d] ; Lower Word in B
0599   0B23 12            mov a, c
0600   0B24 95            not a
0601   0B25 97            not b
0602   0B26 55 01 00      add b, 1
0603   0B29 5B 00 00      adc a, 0
0604   0B2C 39            mov c, a
0605   0B2D E7            pop d
0606   0B2E FD 43         mov [d], b
0607   0B30 26 00 00      mov b, 0
0608   0B33 FD 44 02 00   mov [d + 2], b
0609   0B37 0A 6E 0B      jmp _if8_exit
0610   0B3A             _if8_else:
0611   0B3A             ; if (num == 0) { 
0612   0B3A             _if9_cond:
0613   0B3A FA 05 00      lea d, [bp + 5] ; $num
0614   0B3D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0615   0B40 FD 39         mov c, b ; And place it into C
0616   0B42 2A            mov b, [d] ; Lower Word in B
0617   0B43             ; --- START RELATIONAL
0618   0B43 D7            push a
0619   0B44 FD D8         push g
0620   0B46 11            mov a, b
0621   0B47 FD 7A         mov g, c
0622   0B49 FD 2E 00 00   mov32 cb, $00000000
0622   0B4D 00 00 
0623   0B4F FD AF         cmp32 ga, cb
0624   0B51 FD 71         seq ; ==
0625   0B53 FD F1         pop g
0626   0B55 E4            pop a
0627   0B56             ; --- END RELATIONAL
0628   0B56 C0 00 00      cmp b, 0
0629   0B59 C6 6E 0B      je _if9_exit
0630   0B5C             _if9_TRUE:
0631   0B5C             ; putchar('0'); 
0632   0B5C             ; --- START FUNCTION CALL
0633   0B5C FD 2E 30 00   mov32 cb, $00000030
0633   0B60 00 00 
0634   0B62 DD            push bl
0635   0B63 07 40 0C      call putchar
0636   0B66 51 01 00      add sp, 1
0637   0B69             ; --- END FUNCTION CALL
0638   0B69             ; return; 
0639   0B69 F9            leave
0640   0B6A 09            ret
0641   0B6B 0A 6E 0B      jmp _if9_exit
0642   0B6E             _if9_exit:
0643   0B6E             _if8_exit:
0644   0B6E             ; while (num > 0) { 
0645   0B6E             _while10_cond:
0646   0B6E FA 05 00      lea d, [bp + 5] ; $num
0647   0B71 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0648   0B74 FD 39         mov c, b ; And place it into C
0649   0B76 2A            mov b, [d] ; Lower Word in B
0650   0B77             ; --- START RELATIONAL
0651   0B77 D7            push a
0652   0B78 FD D8         push g
0653   0B7A 11            mov a, b
0654   0B7B FD 7A         mov g, c
0655   0B7D FD 2E 00 00   mov32 cb, $00000000
0655   0B81 00 00 
0656   0B83 FD AF         cmp32 ga, cb
0657   0B85 FD 7F         sgt
0658   0B87 FD F1         pop g
0659   0B89 E4            pop a
0660   0B8A             ; --- END RELATIONAL
0661   0B8A C0 00 00      cmp b, 0
0662   0B8D C6 F6 0B      je _while10_exit
0663   0B90             _while10_block:
0664   0B90             ; digits[i] = '0' + (num % 10); 
0665   0B90 FA F7 FF      lea d, [bp + -9] ; $digits
0666   0B93 D7            push a
0667   0B94 DA            push d
0668   0B95 FA F5 FF      lea d, [bp + -11] ; $i
0669   0B98 2A            mov b, [d]
0670   0B99 38 00 00      mov c, 0
0671   0B9C E7            pop d
0672   0B9D 5A            add d, b
0673   0B9E E4            pop a
0674   0B9F DA            push d
0675   0BA0 FD 2E 30 00   mov32 cb, $00000030
0675   0BA4 00 00 
0676   0BA6             ; --- START TERMS
0677   0BA6 D7            push a
0678   0BA7 11            mov a, b
0679   0BA8 FA 05 00      lea d, [bp + 5] ; $num
0680   0BAB 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0681   0BAE FD 39         mov c, b ; And place it into C
0682   0BB0 2A            mov b, [d] ; Lower Word in B
0683   0BB1             ; --- START FACTORS
0684   0BB1 D7            push a
0685   0BB2 11            mov a, b
0686   0BB3 FD 2E 0A 00   mov32 cb, $0000000a
0686   0BB7 00 00 
0687   0BB9 AE            div a, b ; 
0688   0BBA 11            mov a, b
0689   0BBB 27            mov b, a
0690   0BBC E4            pop a
0691   0BBD             ; --- END FACTORS
0692   0BBD FD 15         add32 cb, ga
0693   0BBF E4            pop a
0694   0BC0             ; --- END TERMS
0695   0BC0 E7            pop d
0696   0BC1 FD 3E         mov [d], bl
0697   0BC3             ; num = num / 10; 
0698   0BC3 FA 05 00      lea d, [bp + 5] ; $num
0699   0BC6 DA            push d
0700   0BC7 FA 05 00      lea d, [bp + 5] ; $num
0701   0BCA 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0702   0BCD FD 39         mov c, b ; And place it into C
0703   0BCF 2A            mov b, [d] ; Lower Word in B
0704   0BD0             ; --- START FACTORS
0705   0BD0 D7            push a
0706   0BD1 11            mov a, b
0707   0BD2 FD 2E 0A 00   mov32 cb, $0000000a
0707   0BD6 00 00 
0708   0BD8 AE            div a, b
0709   0BD9 27            mov b, a
0710   0BDA E4            pop a
0711   0BDB             ; --- END FACTORS
0712   0BDB E7            pop d
0713   0BDC FD 43         mov [d], b
0714   0BDE 28            mov b, c
0715   0BDF FD 44 02 00   mov [d + 2], b
0716   0BE3             ; i++; 
0717   0BE3 FA F5 FF      lea d, [bp + -11] ; $i
0718   0BE6 2A            mov b, [d]
0719   0BE7 38 00 00      mov c, 0
0720   0BEA 11            mov a, b
0721   0BEB FD 77         inc b
0722   0BED FA F5 FF      lea d, [bp + -11] ; $i
0723   0BF0 FD 43         mov [d], b
0724   0BF2 27            mov b, a
0725   0BF3 0A 6E 0B      jmp _while10_cond
0726   0BF6             _while10_exit:
0727   0BF6             ; while (i > 0) { 
0728   0BF6             _while11_cond:
0729   0BF6 FA F5 FF      lea d, [bp + -11] ; $i
0730   0BF9 2A            mov b, [d]
0731   0BFA 38 00 00      mov c, 0
0732   0BFD             ; --- START RELATIONAL
0733   0BFD D7            push a
0734   0BFE 11            mov a, b
0735   0BFF FD 2E 00 00   mov32 cb, $00000000
0735   0C03 00 00 
0736   0C05 B0            cmp a, b
0737   0C06 FD 7F         sgt ; >
0738   0C08 E4            pop a
0739   0C09             ; --- END RELATIONAL
0740   0C09 C0 00 00      cmp b, 0
0741   0C0C C6 3E 0C      je _while11_exit
0742   0C0F             _while11_block:
0743   0C0F             ; i--; 
0744   0C0F FA F5 FF      lea d, [bp + -11] ; $i
0745   0C12 2A            mov b, [d]
0746   0C13 38 00 00      mov c, 0
0747   0C16 11            mov a, b
0748   0C17 FD 7D         dec b
0749   0C19 FA F5 FF      lea d, [bp + -11] ; $i
0750   0C1C FD 43         mov [d], b
0751   0C1E 27            mov b, a
0752   0C1F             ; putchar(digits[i]); 
0753   0C1F             ; --- START FUNCTION CALL
0754   0C1F FA F7 FF      lea d, [bp + -9] ; $digits
0755   0C22 D7            push a
0756   0C23 DA            push d
0757   0C24 FA F5 FF      lea d, [bp + -11] ; $i
0758   0C27 2A            mov b, [d]
0759   0C28 38 00 00      mov c, 0
0760   0C2B E7            pop d
0761   0C2C 5A            add d, b
0762   0C2D E4            pop a
0763   0C2E 32            mov bl, [d]
0764   0C2F A7 00         mov bh, 0
0765   0C31 38 00 00      mov c, 0
0766   0C34 DD            push bl
0767   0C35 07 40 0C      call putchar
0768   0C38 51 01 00      add sp, 1
0769   0C3B             ; --- END FUNCTION CALL
0770   0C3B 0A F6 0B      jmp _while11_cond
0771   0C3E             _while11_exit:
0772   0C3E F9            leave
0773   0C3F 09            ret
0774   0C40             
0775   0C40             putchar:
0776   0C40 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0777   0C43             
0778   0C43             ; --- BEGIN INLINE ASM SEGMENT
0779   0C43 FA 05 00      lea d, [bp + 5] ; $c
0780   0C46 1E            mov al, [d]
0781   0C47 23            mov ah, al
0782   0C48 07 51 05      call _putchar
0783   0C4B             ; --- END INLINE ASM SEGMENT
0784   0C4B             
0785   0C4B F9            leave
0786   0C4C 09            ret
0787   0C4D             
0788   0C4D             print_unsigned_long:
0789   0C4D F8 00 00      enter 0 ; (push bp; mov bp, sp)
0790   0C50             ; char digits[10]; 
0791   0C50 52 0A 00      sub sp, 10
0792   0C53             ; int i; 
0793   0C53 52 02 00      sub sp, 2
0794   0C56             ; i = 0; 
0795   0C56 FA F5 FF      lea d, [bp + -11] ; $i
0796   0C59 DA            push d
0797   0C5A FD 2E 00 00   mov32 cb, $00000000
0797   0C5E 00 00 
0798   0C60 E7            pop d
0799   0C61 FD 43         mov [d], b
0800   0C63             ; if(num == 0){ 
0801   0C63             _if12_cond:
0802   0C63 FA 05 00      lea d, [bp + 5] ; $num
0803   0C66 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0804   0C69 FD 39         mov c, b ; And place it into C
0805   0C6B 2A            mov b, [d] ; Lower Word in B
0806   0C6C             ; --- START RELATIONAL
0807   0C6C D7            push a
0808   0C6D FD D8         push g
0809   0C6F 11            mov a, b
0810   0C70 FD 7A         mov g, c
0811   0C72 FD 2E 00 00   mov32 cb, $00000000
0811   0C76 00 00 
0812   0C78 FD AF         cmp32 ga, cb
0813   0C7A FD 71         seq ; ==
0814   0C7C FD F1         pop g
0815   0C7E E4            pop a
0816   0C7F             ; --- END RELATIONAL
0817   0C7F C0 00 00      cmp b, 0
0818   0C82 C6 97 0C      je _if12_exit
0819   0C85             _if12_TRUE:
0820   0C85             ; putchar('0'); 
0821   0C85             ; --- START FUNCTION CALL
0822   0C85 FD 2E 30 00   mov32 cb, $00000030
0822   0C89 00 00 
0823   0C8B DD            push bl
0824   0C8C 07 40 0C      call putchar
0825   0C8F 51 01 00      add sp, 1
0826   0C92             ; --- END FUNCTION CALL
0827   0C92             ; return; 
0828   0C92 F9            leave
0829   0C93 09            ret
0830   0C94 0A 97 0C      jmp _if12_exit
0831   0C97             _if12_exit:
0832   0C97             ; while (num > 0) { 
0833   0C97             _while13_cond:
0834   0C97 FA 05 00      lea d, [bp + 5] ; $num
0835   0C9A 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0836   0C9D FD 39         mov c, b ; And place it into C
0837   0C9F 2A            mov b, [d] ; Lower Word in B
0838   0CA0             ; --- START RELATIONAL
0839   0CA0 D7            push a
0840   0CA1 FD D8         push g
0841   0CA3 11            mov a, b
0842   0CA4 FD 7A         mov g, c
0843   0CA6 FD 2E 00 00   mov32 cb, $00000000
0843   0CAA 00 00 
0844   0CAC FD AF         cmp32 ga, cb
0845   0CAE FD 81         sgu
0846   0CB0 FD F1         pop g
0847   0CB2 E4            pop a
0848   0CB3             ; --- END RELATIONAL
0849   0CB3 C0 00 00      cmp b, 0
0850   0CB6 C6 1F 0D      je _while13_exit
0851   0CB9             _while13_block:
0852   0CB9             ; digits[i] = '0' + (num % 10); 
0853   0CB9 FA F7 FF      lea d, [bp + -9] ; $digits
0854   0CBC D7            push a
0855   0CBD DA            push d
0856   0CBE FA F5 FF      lea d, [bp + -11] ; $i
0857   0CC1 2A            mov b, [d]
0858   0CC2 38 00 00      mov c, 0
0859   0CC5 E7            pop d
0860   0CC6 5A            add d, b
0861   0CC7 E4            pop a
0862   0CC8 DA            push d
0863   0CC9 FD 2E 30 00   mov32 cb, $00000030
0863   0CCD 00 00 
0864   0CCF             ; --- START TERMS
0865   0CCF D7            push a
0866   0CD0 11            mov a, b
0867   0CD1 FA 05 00      lea d, [bp + 5] ; $num
0868   0CD4 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0869   0CD7 FD 39         mov c, b ; And place it into C
0870   0CD9 2A            mov b, [d] ; Lower Word in B
0871   0CDA             ; --- START FACTORS
0872   0CDA D7            push a
0873   0CDB 11            mov a, b
0874   0CDC FD 2E 0A 00   mov32 cb, $0000000a
0874   0CE0 00 00 
0875   0CE2 AE            div a, b ; 
0876   0CE3 11            mov a, b
0877   0CE4 27            mov b, a
0878   0CE5 E4            pop a
0879   0CE6             ; --- END FACTORS
0880   0CE6 FD 15         add32 cb, ga
0881   0CE8 E4            pop a
0882   0CE9             ; --- END TERMS
0883   0CE9 E7            pop d
0884   0CEA FD 3E         mov [d], bl
0885   0CEC             ; num = num / 10; 
0886   0CEC FA 05 00      lea d, [bp + 5] ; $num
0887   0CEF DA            push d
0888   0CF0 FA 05 00      lea d, [bp + 5] ; $num
0889   0CF3 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0890   0CF6 FD 39         mov c, b ; And place it into C
0891   0CF8 2A            mov b, [d] ; Lower Word in B
0892   0CF9             ; --- START FACTORS
0893   0CF9 D7            push a
0894   0CFA 11            mov a, b
0895   0CFB FD 2E 0A 00   mov32 cb, $0000000a
0895   0CFF 00 00 
0896   0D01 AE            div a, b
0897   0D02 27            mov b, a
0898   0D03 E4            pop a
0899   0D04             ; --- END FACTORS
0900   0D04 E7            pop d
0901   0D05 FD 43         mov [d], b
0902   0D07 28            mov b, c
0903   0D08 FD 44 02 00   mov [d + 2], b
0904   0D0C             ; i++; 
0905   0D0C FA F5 FF      lea d, [bp + -11] ; $i
0906   0D0F 2A            mov b, [d]
0907   0D10 38 00 00      mov c, 0
0908   0D13 11            mov a, b
0909   0D14 FD 77         inc b
0910   0D16 FA F5 FF      lea d, [bp + -11] ; $i
0911   0D19 FD 43         mov [d], b
0912   0D1B 27            mov b, a
0913   0D1C 0A 97 0C      jmp _while13_cond
0914   0D1F             _while13_exit:
0915   0D1F             ; while (i > 0) { 
0916   0D1F             _while14_cond:
0917   0D1F FA F5 FF      lea d, [bp + -11] ; $i
0918   0D22 2A            mov b, [d]
0919   0D23 38 00 00      mov c, 0
0920   0D26             ; --- START RELATIONAL
0921   0D26 D7            push a
0922   0D27 11            mov a, b
0923   0D28 FD 2E 00 00   mov32 cb, $00000000
0923   0D2C 00 00 
0924   0D2E B0            cmp a, b
0925   0D2F FD 7F         sgt ; >
0926   0D31 E4            pop a
0927   0D32             ; --- END RELATIONAL
0928   0D32 C0 00 00      cmp b, 0
0929   0D35 C6 67 0D      je _while14_exit
0930   0D38             _while14_block:
0931   0D38             ; i--; 
0932   0D38 FA F5 FF      lea d, [bp + -11] ; $i
0933   0D3B 2A            mov b, [d]
0934   0D3C 38 00 00      mov c, 0
0935   0D3F 11            mov a, b
0936   0D40 FD 7D         dec b
0937   0D42 FA F5 FF      lea d, [bp + -11] ; $i
0938   0D45 FD 43         mov [d], b
0939   0D47 27            mov b, a
0940   0D48             ; putchar(digits[i]); 
0941   0D48             ; --- START FUNCTION CALL
0942   0D48 FA F7 FF      lea d, [bp + -9] ; $digits
0943   0D4B D7            push a
0944   0D4C DA            push d
0945   0D4D FA F5 FF      lea d, [bp + -11] ; $i
0946   0D50 2A            mov b, [d]
0947   0D51 38 00 00      mov c, 0
0948   0D54 E7            pop d
0949   0D55 5A            add d, b
0950   0D56 E4            pop a
0951   0D57 32            mov bl, [d]
0952   0D58 A7 00         mov bh, 0
0953   0D5A 38 00 00      mov c, 0
0954   0D5D DD            push bl
0955   0D5E 07 40 0C      call putchar
0956   0D61 51 01 00      add sp, 1
0957   0D64             ; --- END FUNCTION CALL
0958   0D64 0A 1F 0D      jmp _while14_cond
0959   0D67             _while14_exit:
0960   0D67 F9            leave
0961   0D68 09            ret
0962   0D69             
0963   0D69             printx32:
0964   0D69 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0965   0D6C             
0966   0D6C             ; --- BEGIN INLINE ASM SEGMENT
0967   0D6C FA 05 00      lea d, [bp + 5] ; $hex
0968   0D6F 2B 02 00      mov b, [d+2]
0969   0D72 07 F3 06      call print_u16x
0970   0D75 2A            mov b, [d]
0971   0D76 07 F3 06      call print_u16x
0972   0D79             ; --- END INLINE ASM SEGMENT
0973   0D79             
0974   0D79 F9            leave
0975   0D7A 09            ret
0976   0D7B             
0977   0D7B             err:
0978   0D7B F8 00 00      enter 0 ; (push bp; mov bp, sp)
0979   0D7E             ; print(e); 
0980   0D7E             ; --- START FUNCTION CALL
0981   0D7E FA 05 00      lea d, [bp + 5] ; $e
0982   0D81 2A            mov b, [d]
0983   0D82 38 00 00      mov c, 0
0984   0D85 FD AB         swp b
0985   0D87 D8            push b
0986   0D88 07 90 0D      call print
0987   0D8B 51 02 00      add sp, 2
0988   0D8E             ; --- END FUNCTION CALL
0989   0D8E F9            leave
0990   0D8F 09            ret
0991   0D90             
0992   0D90             print:
0993   0D90 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0994   0D93             
0995   0D93             ; --- BEGIN INLINE ASM SEGMENT
0996   0D93 FA 05 00      lea d, [bp + 5] ; $s
0997   0D96 FD 2A         mov d, [d]
0998   0D98 07 9B 06      call _puts
0999   0D9B             ; --- END INLINE ASM SEGMENT
1000   0D9B             
1001   0D9B F9            leave
1002   0D9C 09            ret
1003   0D9D             
1004   0D9D             print_signed:
1005   0D9D F8 00 00      enter 0 ; (push bp; mov bp, sp)
1006   0DA0             ; char digits[5]; 
1007   0DA0 52 05 00      sub sp, 5
1008   0DA3             ; int i = 0; 
1009   0DA3 52 02 00      sub sp, 2
1010   0DA6             ; --- START LOCAL VAR INITIALIZATION
1011   0DA6 FA FA FF      lea d, [bp + -6] ; $i
1012   0DA9 DA            push d
1013   0DAA FD 2E 00 00   mov32 cb, $00000000
1013   0DAE 00 00 
1014   0DB0 E7            pop d
1015   0DB1 FD 43         mov [d], b
1016   0DB3             ; --- END LOCAL VAR INITIALIZATION
1017   0DB3             ; if (num < 0) { 
1018   0DB3             _if15_cond:
1019   0DB3 FA 05 00      lea d, [bp + 5] ; $num
1020   0DB6 2A            mov b, [d]
1021   0DB7 38 00 00      mov c, 0
1022   0DBA             ; --- START RELATIONAL
1023   0DBA D7            push a
1024   0DBB 11            mov a, b
1025   0DBC FD 2E 00 00   mov32 cb, $00000000
1025   0DC0 00 00 
1026   0DC2 B0            cmp a, b
1027   0DC3 FD 73         slt ; < (signed)
1028   0DC5 E4            pop a
1029   0DC6             ; --- END RELATIONAL
1030   0DC6 C0 00 00      cmp b, 0
1031   0DC9 C6 EC 0D      je _if15_else
1032   0DCC             _if15_TRUE:
1033   0DCC             ; putchar('-'); 
1034   0DCC             ; --- START FUNCTION CALL
1035   0DCC FD 2E 2D 00   mov32 cb, $0000002d
1035   0DD0 00 00 
1036   0DD2 DD            push bl
1037   0DD3 07 40 0C      call putchar
1038   0DD6 51 01 00      add sp, 1
1039   0DD9             ; --- END FUNCTION CALL
1040   0DD9             ; num = -num; 
1041   0DD9 FA 05 00      lea d, [bp + 5] ; $num
1042   0DDC DA            push d
1043   0DDD FA 05 00      lea d, [bp + 5] ; $num
1044   0DE0 2A            mov b, [d]
1045   0DE1 38 00 00      mov c, 0
1046   0DE4 FD 97         neg b
1047   0DE6 E7            pop d
1048   0DE7 FD 43         mov [d], b
1049   0DE9 0A 17 0E      jmp _if15_exit
1050   0DEC             _if15_else:
1051   0DEC             ; if (num == 0) { 
1052   0DEC             _if16_cond:
1053   0DEC FA 05 00      lea d, [bp + 5] ; $num
1054   0DEF 2A            mov b, [d]
1055   0DF0 38 00 00      mov c, 0
1056   0DF3             ; --- START RELATIONAL
1057   0DF3 D7            push a
1058   0DF4 11            mov a, b
1059   0DF5 FD 2E 00 00   mov32 cb, $00000000
1059   0DF9 00 00 
1060   0DFB B0            cmp a, b
1061   0DFC FD 71         seq ; ==
1062   0DFE E4            pop a
1063   0DFF             ; --- END RELATIONAL
1064   0DFF C0 00 00      cmp b, 0
1065   0E02 C6 17 0E      je _if16_exit
1066   0E05             _if16_TRUE:
1067   0E05             ; putchar('0'); 
1068   0E05             ; --- START FUNCTION CALL
1069   0E05 FD 2E 30 00   mov32 cb, $00000030
1069   0E09 00 00 
1070   0E0B DD            push bl
1071   0E0C 07 40 0C      call putchar
1072   0E0F 51 01 00      add sp, 1
1073   0E12             ; --- END FUNCTION CALL
1074   0E12             ; return; 
1075   0E12 F9            leave
1076   0E13 09            ret
1077   0E14 0A 17 0E      jmp _if16_exit
1078   0E17             _if16_exit:
1079   0E17             _if15_exit:
1080   0E17             ; while (num > 0) { 
1081   0E17             _while17_cond:
1082   0E17 FA 05 00      lea d, [bp + 5] ; $num
1083   0E1A 2A            mov b, [d]
1084   0E1B 38 00 00      mov c, 0
1085   0E1E             ; --- START RELATIONAL
1086   0E1E D7            push a
1087   0E1F 11            mov a, b
1088   0E20 FD 2E 00 00   mov32 cb, $00000000
1088   0E24 00 00 
1089   0E26 B0            cmp a, b
1090   0E27 FD 7F         sgt ; >
1091   0E29 E4            pop a
1092   0E2A             ; --- END RELATIONAL
1093   0E2A C0 00 00      cmp b, 0
1094   0E2D C6 8C 0E      je _while17_exit
1095   0E30             _while17_block:
1096   0E30             ; digits[i] = '0' + (num % 10); 
1097   0E30 FA FC FF      lea d, [bp + -4] ; $digits
1098   0E33 D7            push a
1099   0E34 DA            push d
1100   0E35 FA FA FF      lea d, [bp + -6] ; $i
1101   0E38 2A            mov b, [d]
1102   0E39 38 00 00      mov c, 0
1103   0E3C E7            pop d
1104   0E3D 5A            add d, b
1105   0E3E E4            pop a
1106   0E3F DA            push d
1107   0E40 FD 2E 30 00   mov32 cb, $00000030
1107   0E44 00 00 
1108   0E46             ; --- START TERMS
1109   0E46 D7            push a
1110   0E47 11            mov a, b
1111   0E48 FA 05 00      lea d, [bp + 5] ; $num
1112   0E4B 2A            mov b, [d]
1113   0E4C 38 00 00      mov c, 0
1114   0E4F             ; --- START FACTORS
1115   0E4F D7            push a
1116   0E50 11            mov a, b
1117   0E51 FD 2E 0A 00   mov32 cb, $0000000a
1117   0E55 00 00 
1118   0E57 AE            div a, b ; 
1119   0E58 11            mov a, b
1120   0E59 27            mov b, a
1121   0E5A E4            pop a
1122   0E5B             ; --- END FACTORS
1123   0E5B 56            add b, a
1124   0E5C E4            pop a
1125   0E5D             ; --- END TERMS
1126   0E5D E7            pop d
1127   0E5E FD 3E         mov [d], bl
1128   0E60             ; num = num / 10; 
1129   0E60 FA 05 00      lea d, [bp + 5] ; $num
1130   0E63 DA            push d
1131   0E64 FA 05 00      lea d, [bp + 5] ; $num
1132   0E67 2A            mov b, [d]
1133   0E68 38 00 00      mov c, 0
1134   0E6B             ; --- START FACTORS
1135   0E6B D7            push a
1136   0E6C 11            mov a, b
1137   0E6D FD 2E 0A 00   mov32 cb, $0000000a
1137   0E71 00 00 
1138   0E73 AE            div a, b
1139   0E74 27            mov b, a
1140   0E75 E4            pop a
1141   0E76             ; --- END FACTORS
1142   0E76 E7            pop d
1143   0E77 FD 43         mov [d], b
1144   0E79             ; i++; 
1145   0E79 FA FA FF      lea d, [bp + -6] ; $i
1146   0E7C 2A            mov b, [d]
1147   0E7D 38 00 00      mov c, 0
1148   0E80 11            mov a, b
1149   0E81 FD 77         inc b
1150   0E83 FA FA FF      lea d, [bp + -6] ; $i
1151   0E86 FD 43         mov [d], b
1152   0E88 27            mov b, a
1153   0E89 0A 17 0E      jmp _while17_cond
1154   0E8C             _while17_exit:
1155   0E8C             ; while (i > 0) { 
1156   0E8C             _while18_cond:
1157   0E8C FA FA FF      lea d, [bp + -6] ; $i
1158   0E8F 2A            mov b, [d]
1159   0E90 38 00 00      mov c, 0
1160   0E93             ; --- START RELATIONAL
1161   0E93 D7            push a
1162   0E94 11            mov a, b
1163   0E95 FD 2E 00 00   mov32 cb, $00000000
1163   0E99 00 00 
1164   0E9B B0            cmp a, b
1165   0E9C FD 7F         sgt ; >
1166   0E9E E4            pop a
1167   0E9F             ; --- END RELATIONAL
1168   0E9F C0 00 00      cmp b, 0
1169   0EA2 C6 D4 0E      je _while18_exit
1170   0EA5             _while18_block:
1171   0EA5             ; i--; 
1172   0EA5 FA FA FF      lea d, [bp + -6] ; $i
1173   0EA8 2A            mov b, [d]
1174   0EA9 38 00 00      mov c, 0
1175   0EAC 11            mov a, b
1176   0EAD FD 7D         dec b
1177   0EAF FA FA FF      lea d, [bp + -6] ; $i
1178   0EB2 FD 43         mov [d], b
1179   0EB4 27            mov b, a
1180   0EB5             ; putchar(digits[i]); 
1181   0EB5             ; --- START FUNCTION CALL
1182   0EB5 FA FC FF      lea d, [bp + -4] ; $digits
1183   0EB8 D7            push a
1184   0EB9 DA            push d
1185   0EBA FA FA FF      lea d, [bp + -6] ; $i
1186   0EBD 2A            mov b, [d]
1187   0EBE 38 00 00      mov c, 0
1188   0EC1 E7            pop d
1189   0EC2 5A            add d, b
1190   0EC3 E4            pop a
1191   0EC4 32            mov bl, [d]
1192   0EC5 A7 00         mov bh, 0
1193   0EC7 38 00 00      mov c, 0
1194   0ECA DD            push bl
1195   0ECB 07 40 0C      call putchar
1196   0ECE 51 01 00      add sp, 1
1197   0ED1             ; --- END FUNCTION CALL
1198   0ED1 0A 8C 0E      jmp _while18_cond
1199   0ED4             _while18_exit:
1200   0ED4 F9            leave
1201   0ED5 09            ret
1202   0ED6             
1203   0ED6             print_unsigned:
1204   0ED6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1205   0ED9             ; char digits[5]; 
1206   0ED9 52 05 00      sub sp, 5
1207   0EDC             ; int i; 
1208   0EDC 52 02 00      sub sp, 2
1209   0EDF             ; i = 0; 
1210   0EDF FA FA FF      lea d, [bp + -6] ; $i
1211   0EE2 DA            push d
1212   0EE3 FD 2E 00 00   mov32 cb, $00000000
1212   0EE7 00 00 
1213   0EE9 E7            pop d
1214   0EEA FD 43         mov [d], b
1215   0EEC             ; if(num == 0){ 
1216   0EEC             _if19_cond:
1217   0EEC FA 05 00      lea d, [bp + 5] ; $num
1218   0EEF 2A            mov b, [d]
1219   0EF0 38 00 00      mov c, 0
1220   0EF3             ; --- START RELATIONAL
1221   0EF3 D7            push a
1222   0EF4 11            mov a, b
1223   0EF5 FD 2E 00 00   mov32 cb, $00000000
1223   0EF9 00 00 
1224   0EFB B0            cmp a, b
1225   0EFC FD 71         seq ; ==
1226   0EFE E4            pop a
1227   0EFF             ; --- END RELATIONAL
1228   0EFF C0 00 00      cmp b, 0
1229   0F02 C6 17 0F      je _if19_exit
1230   0F05             _if19_TRUE:
1231   0F05             ; putchar('0'); 
1232   0F05             ; --- START FUNCTION CALL
1233   0F05 FD 2E 30 00   mov32 cb, $00000030
1233   0F09 00 00 
1234   0F0B DD            push bl
1235   0F0C 07 40 0C      call putchar
1236   0F0F 51 01 00      add sp, 1
1237   0F12             ; --- END FUNCTION CALL
1238   0F12             ; return; 
1239   0F12 F9            leave
1240   0F13 09            ret
1241   0F14 0A 17 0F      jmp _if19_exit
1242   0F17             _if19_exit:
1243   0F17             ; while (num > 0) { 
1244   0F17             _while20_cond:
1245   0F17 FA 05 00      lea d, [bp + 5] ; $num
1246   0F1A 2A            mov b, [d]
1247   0F1B 38 00 00      mov c, 0
1248   0F1E             ; --- START RELATIONAL
1249   0F1E D7            push a
1250   0F1F 11            mov a, b
1251   0F20 FD 2E 00 00   mov32 cb, $00000000
1251   0F24 00 00 
1252   0F26 B0            cmp a, b
1253   0F27 FD 81         sgu ; > (unsigned)
1254   0F29 E4            pop a
1255   0F2A             ; --- END RELATIONAL
1256   0F2A C0 00 00      cmp b, 0
1257   0F2D C6 8C 0F      je _while20_exit
1258   0F30             _while20_block:
1259   0F30             ; digits[i] = '0' + (num % 10); 
1260   0F30 FA FC FF      lea d, [bp + -4] ; $digits
1261   0F33 D7            push a
1262   0F34 DA            push d
1263   0F35 FA FA FF      lea d, [bp + -6] ; $i
1264   0F38 2A            mov b, [d]
1265   0F39 38 00 00      mov c, 0
1266   0F3C E7            pop d
1267   0F3D 5A            add d, b
1268   0F3E E4            pop a
1269   0F3F DA            push d
1270   0F40 FD 2E 30 00   mov32 cb, $00000030
1270   0F44 00 00 
1271   0F46             ; --- START TERMS
1272   0F46 D7            push a
1273   0F47 11            mov a, b
1274   0F48 FA 05 00      lea d, [bp + 5] ; $num
1275   0F4B 2A            mov b, [d]
1276   0F4C 38 00 00      mov c, 0
1277   0F4F             ; --- START FACTORS
1278   0F4F D7            push a
1279   0F50 11            mov a, b
1280   0F51 FD 2E 0A 00   mov32 cb, $0000000a
1280   0F55 00 00 
1281   0F57 AE            div a, b ; 
1282   0F58 11            mov a, b
1283   0F59 27            mov b, a
1284   0F5A E4            pop a
1285   0F5B             ; --- END FACTORS
1286   0F5B 56            add b, a
1287   0F5C E4            pop a
1288   0F5D             ; --- END TERMS
1289   0F5D E7            pop d
1290   0F5E FD 3E         mov [d], bl
1291   0F60             ; num = num / 10; 
1292   0F60 FA 05 00      lea d, [bp + 5] ; $num
1293   0F63 DA            push d
1294   0F64 FA 05 00      lea d, [bp + 5] ; $num
1295   0F67 2A            mov b, [d]
1296   0F68 38 00 00      mov c, 0
1297   0F6B             ; --- START FACTORS
1298   0F6B D7            push a
1299   0F6C 11            mov a, b
1300   0F6D FD 2E 0A 00   mov32 cb, $0000000a
1300   0F71 00 00 
1301   0F73 AE            div a, b
1302   0F74 27            mov b, a
1303   0F75 E4            pop a
1304   0F76             ; --- END FACTORS
1305   0F76 E7            pop d
1306   0F77 FD 43         mov [d], b
1307   0F79             ; i++; 
1308   0F79 FA FA FF      lea d, [bp + -6] ; $i
1309   0F7C 2A            mov b, [d]
1310   0F7D 38 00 00      mov c, 0
1311   0F80 11            mov a, b
1312   0F81 FD 77         inc b
1313   0F83 FA FA FF      lea d, [bp + -6] ; $i
1314   0F86 FD 43         mov [d], b
1315   0F88 27            mov b, a
1316   0F89 0A 17 0F      jmp _while20_cond
1317   0F8C             _while20_exit:
1318   0F8C             ; while (i > 0) { 
1319   0F8C             _while21_cond:
1320   0F8C FA FA FF      lea d, [bp + -6] ; $i
1321   0F8F 2A            mov b, [d]
1322   0F90 38 00 00      mov c, 0
1323   0F93             ; --- START RELATIONAL
1324   0F93 D7            push a
1325   0F94 11            mov a, b
1326   0F95 FD 2E 00 00   mov32 cb, $00000000
1326   0F99 00 00 
1327   0F9B B0            cmp a, b
1328   0F9C FD 7F         sgt ; >
1329   0F9E E4            pop a
1330   0F9F             ; --- END RELATIONAL
1331   0F9F C0 00 00      cmp b, 0
1332   0FA2 C6 D4 0F      je _while21_exit
1333   0FA5             _while21_block:
1334   0FA5             ; i--; 
1335   0FA5 FA FA FF      lea d, [bp + -6] ; $i
1336   0FA8 2A            mov b, [d]
1337   0FA9 38 00 00      mov c, 0
1338   0FAC 11            mov a, b
1339   0FAD FD 7D         dec b
1340   0FAF FA FA FF      lea d, [bp + -6] ; $i
1341   0FB2 FD 43         mov [d], b
1342   0FB4 27            mov b, a
1343   0FB5             ; putchar(digits[i]); 
1344   0FB5             ; --- START FUNCTION CALL
1345   0FB5 FA FC FF      lea d, [bp + -4] ; $digits
1346   0FB8 D7            push a
1347   0FB9 DA            push d
1348   0FBA FA FA FF      lea d, [bp + -6] ; $i
1349   0FBD 2A            mov b, [d]
1350   0FBE 38 00 00      mov c, 0
1351   0FC1 E7            pop d
1352   0FC2 5A            add d, b
1353   0FC3 E4            pop a
1354   0FC4 32            mov bl, [d]
1355   0FC5 A7 00         mov bh, 0
1356   0FC7 38 00 00      mov c, 0
1357   0FCA DD            push bl
1358   0FCB 07 40 0C      call putchar
1359   0FCE 51 01 00      add sp, 1
1360   0FD1             ; --- END FUNCTION CALL
1361   0FD1 0A 8C 0F      jmp _while21_cond
1362   0FD4             _while21_exit:
1363   0FD4 F9            leave
1364   0FD5 09            ret
1365   0FD6             
1366   0FD6             strcpy:
1367   0FD6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1368   0FD9             ; char *psrc; 
1369   0FD9 52 02 00      sub sp, 2
1370   0FDC             ; char *pdest; 
1371   0FDC 52 02 00      sub sp, 2
1372   0FDF             ; psrc = src; 
1373   0FDF FA FF FF      lea d, [bp + -1] ; $psrc
1374   0FE2 DA            push d
1375   0FE3 FA 07 00      lea d, [bp + 7] ; $src
1376   0FE6 2A            mov b, [d]
1377   0FE7 38 00 00      mov c, 0
1378   0FEA E7            pop d
1379   0FEB FD 43         mov [d], b
1380   0FED             ; pdest = dest; 
1381   0FED FA FD FF      lea d, [bp + -3] ; $pdest
1382   0FF0 DA            push d
1383   0FF1 FA 05 00      lea d, [bp + 5] ; $dest
1384   0FF4 2A            mov b, [d]
1385   0FF5 38 00 00      mov c, 0
1386   0FF8 E7            pop d
1387   0FF9 FD 43         mov [d], b
1388   0FFB             ; while(*psrc) *pdest++ = *psrc++; 
1389   0FFB             _while22_cond:
1390   0FFB FA FF FF      lea d, [bp + -1] ; $psrc
1391   0FFE 2A            mov b, [d]
1392   0FFF 38 00 00      mov c, 0
1393   1002 74            mov d, b
1394   1003 32            mov bl, [d]
1395   1004 A7 00         mov bh, 0
1396   1006 38 00 00      mov c, 0
1397   1009 C0 00 00      cmp b, 0
1398   100C C6 3D 10      je _while22_exit
1399   100F             _while22_block:
1400   100F             ; *pdest++ = *psrc++; 
1401   100F FA FD FF      lea d, [bp + -3] ; $pdest
1402   1012 2A            mov b, [d]
1403   1013 38 00 00      mov c, 0
1404   1016 FD 77         inc b
1405   1018 FA FD FF      lea d, [bp + -3] ; $pdest
1406   101B FD 43         mov [d], b
1407   101D FD 7D         dec b
1408   101F D8            push b
1409   1020 FA FF FF      lea d, [bp + -1] ; $psrc
1410   1023 2A            mov b, [d]
1411   1024 38 00 00      mov c, 0
1412   1027 FD 77         inc b
1413   1029 FA FF FF      lea d, [bp + -1] ; $psrc
1414   102C FD 43         mov [d], b
1415   102E FD 7D         dec b
1416   1030 74            mov d, b
1417   1031 32            mov bl, [d]
1418   1032 A7 00         mov bh, 0
1419   1034 38 00 00      mov c, 0
1420   1037 E7            pop d
1421   1038 FD 3E         mov [d], bl
1422   103A 0A FB 0F      jmp _while22_cond
1423   103D             _while22_exit:
1424   103D             ; *pdest = '\0'; 
1425   103D FA FD FF      lea d, [bp + -3] ; $pdest
1426   1040 2A            mov b, [d]
1427   1041 38 00 00      mov c, 0
1428   1044 D8            push b
1429   1045 FD 2E 00 00   mov32 cb, $00000000
1429   1049 00 00 
1430   104B E7            pop d
1431   104C FD 3E         mov [d], bl
1432   104E F9            leave
1433   104F 09            ret
1434   1050             
1435   1050             strcat:
1436   1050 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1437   1053             ; int dest_len; 
1438   1053 52 02 00      sub sp, 2
1439   1056             ; int i; 
1440   1056 52 02 00      sub sp, 2
1441   1059             ; dest_len = strlen(dest); 
1442   1059 FA FF FF      lea d, [bp + -1] ; $dest_len
1443   105C DA            push d
1444   105D             ; --- START FUNCTION CALL
1445   105D FA 05 00      lea d, [bp + 5] ; $dest
1446   1060 2A            mov b, [d]
1447   1061 38 00 00      mov c, 0
1448   1064 FD AB         swp b
1449   1066 D8            push b
1450   1067 07 33 11      call strlen
1451   106A 51 02 00      add sp, 2
1452   106D             ; --- END FUNCTION CALL
1453   106D E7            pop d
1454   106E FD 43         mov [d], b
1455   1070             ; for (i = 0; src[i] != 0; i=i+1) { 
1456   1070             _for23_init:
1457   1070 FA FD FF      lea d, [bp + -3] ; $i
1458   1073 DA            push d
1459   1074 FD 2E 00 00   mov32 cb, $00000000
1459   1078 00 00 
1460   107A E7            pop d
1461   107B FD 43         mov [d], b
1462   107D             _for23_cond:
1463   107D FA 07 00      lea d, [bp + 7] ; $src
1464   1080 FD 2A         mov d, [d]
1465   1082 D7            push a
1466   1083 DA            push d
1467   1084 FA FD FF      lea d, [bp + -3] ; $i
1468   1087 2A            mov b, [d]
1469   1088 38 00 00      mov c, 0
1470   108B E7            pop d
1471   108C FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
1472   1090 E4            pop a
1473   1091 32            mov bl, [d]
1474   1092 A7 00         mov bh, 0
1475   1094 38 00 00      mov c, 0
1476   1097             ; --- START RELATIONAL
1477   1097 D7            push a
1478   1098 11            mov a, b
1479   1099 FD 2E 00 00   mov32 cb, $00000000
1479   109D 00 00 
1480   109F B0            cmp a, b
1481   10A0 FD 72         sneq ; !=
1482   10A2 E4            pop a
1483   10A3             ; --- END RELATIONAL
1484   10A3 C0 00 00      cmp b, 0
1485   10A6 C6 01 11      je _for23_exit
1486   10A9             _for23_block:
1487   10A9             ; dest[dest_len + i] = src[i]; 
1488   10A9 FA 05 00      lea d, [bp + 5] ; $dest
1489   10AC FD 2A         mov d, [d]
1490   10AE D7            push a
1491   10AF DA            push d
1492   10B0 FA FF FF      lea d, [bp + -1] ; $dest_len
1493   10B3 2A            mov b, [d]
1494   10B4 38 00 00      mov c, 0
1495   10B7             ; --- START TERMS
1496   10B7 D7            push a
1497   10B8 11            mov a, b
1498   10B9 FA FD FF      lea d, [bp + -3] ; $i
1499   10BC 2A            mov b, [d]
1500   10BD 38 00 00      mov c, 0
1501   10C0 56            add b, a
1502   10C1 E4            pop a
1503   10C2             ; --- END TERMS
1504   10C2 E7            pop d
1505   10C3 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
1506   10C7 E4            pop a
1507   10C8 DA            push d
1508   10C9 FA 07 00      lea d, [bp + 7] ; $src
1509   10CC FD 2A         mov d, [d]
1510   10CE D7            push a
1511   10CF DA            push d
1512   10D0 FA FD FF      lea d, [bp + -3] ; $i
1513   10D3 2A            mov b, [d]
1514   10D4 38 00 00      mov c, 0
1515   10D7 E7            pop d
1516   10D8 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
1517   10DC E4            pop a
1518   10DD 32            mov bl, [d]
1519   10DE A7 00         mov bh, 0
1520   10E0 38 00 00      mov c, 0
1521   10E3 E7            pop d
1522   10E4 FD 3E         mov [d], bl
1523   10E6             _for23_update:
1524   10E6 FA FD FF      lea d, [bp + -3] ; $i
1525   10E9 DA            push d
1526   10EA FA FD FF      lea d, [bp + -3] ; $i
1527   10ED 2A            mov b, [d]
1528   10EE 38 00 00      mov c, 0
1529   10F1             ; --- START TERMS
1530   10F1 D7            push a
1531   10F2 11            mov a, b
1532   10F3 FD 2E 01 00   mov32 cb, $00000001
1532   10F7 00 00 
1533   10F9 56            add b, a
1534   10FA E4            pop a
1535   10FB             ; --- END TERMS
1536   10FB E7            pop d
1537   10FC FD 43         mov [d], b
1538   10FE 0A 7D 10      jmp _for23_cond
1539   1101             _for23_exit:
1540   1101             ; dest[dest_len + i] = 0; 
1541   1101 FA 05 00      lea d, [bp + 5] ; $dest
1542   1104 FD 2A         mov d, [d]
1543   1106 D7            push a
1544   1107 DA            push d
1545   1108 FA FF FF      lea d, [bp + -1] ; $dest_len
1546   110B 2A            mov b, [d]
1547   110C 38 00 00      mov c, 0
1548   110F             ; --- START TERMS
1549   110F D7            push a
1550   1110 11            mov a, b
1551   1111 FA FD FF      lea d, [bp + -3] ; $i
1552   1114 2A            mov b, [d]
1553   1115 38 00 00      mov c, 0
1554   1118 56            add b, a
1555   1119 E4            pop a
1556   111A             ; --- END TERMS
1557   111A E7            pop d
1558   111B FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
1559   111F E4            pop a
1560   1120 DA            push d
1561   1121 FD 2E 00 00   mov32 cb, $00000000
1561   1125 00 00 
1562   1127 E7            pop d
1563   1128 FD 3E         mov [d], bl
1564   112A             ; return dest; 
1565   112A FA 05 00      lea d, [bp + 5] ; $dest
1566   112D 2A            mov b, [d]
1567   112E 38 00 00      mov c, 0
1568   1131 F9            leave
1569   1132 09            ret
1570   1133             
1571   1133             strlen:
1572   1133 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1573   1136             ; int length; 
1574   1136 52 02 00      sub sp, 2
1575   1139             ; length = 0; 
1576   1139 FA FF FF      lea d, [bp + -1] ; $length
1577   113C DA            push d
1578   113D FD 2E 00 00   mov32 cb, $00000000
1578   1141 00 00 
1579   1143 E7            pop d
1580   1144 FD 43         mov [d], b
1581   1146             ; while (str[length] != 0) { 
1582   1146             _while24_cond:
1583   1146 FA 05 00      lea d, [bp + 5] ; $str
1584   1149 FD 2A         mov d, [d]
1585   114B D7            push a
1586   114C DA            push d
1587   114D FA FF FF      lea d, [bp + -1] ; $length
1588   1150 2A            mov b, [d]
1589   1151 38 00 00      mov c, 0
1590   1154 E7            pop d
1591   1155 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
1592   1159 E4            pop a
1593   115A 32            mov bl, [d]
1594   115B A7 00         mov bh, 0
1595   115D 38 00 00      mov c, 0
1596   1160             ; --- START RELATIONAL
1597   1160 D7            push a
1598   1161 11            mov a, b
1599   1162 FD 2E 00 00   mov32 cb, $00000000
1599   1166 00 00 
1600   1168 B0            cmp a, b
1601   1169 FD 72         sneq ; !=
1602   116B E4            pop a
1603   116C             ; --- END RELATIONAL
1604   116C C0 00 00      cmp b, 0
1605   116F C6 85 11      je _while24_exit
1606   1172             _while24_block:
1607   1172             ; length++; 
1608   1172 FA FF FF      lea d, [bp + -1] ; $length
1609   1175 2A            mov b, [d]
1610   1176 38 00 00      mov c, 0
1611   1179 11            mov a, b
1612   117A FD 77         inc b
1613   117C FA FF FF      lea d, [bp + -1] ; $length
1614   117F FD 43         mov [d], b
1615   1181 27            mov b, a
1616   1182 0A 46 11      jmp _while24_cond
1617   1185             _while24_exit:
1618   1185             ; return length; 
1619   1185 FA FF FF      lea d, [bp + -1] ; $length
1620   1188 2A            mov b, [d]
1621   1189 38 00 00      mov c, 0
1622   118C F9            leave
1623   118D 09            ret
1624   118E             ; --- END TEXT SEGMENT
1625   118E             
1626   118E             ; --- BEGIN DATA SEGMENT
1627   118E 48 65 6C 6C _s0: .db "Hello", 0
1627   1192 6F 00 
1628   1194 57 6F 72 6C _s1: .db "World", 0
1628   1198 64 00 
1629   119A 48 69 00    _s2: .db "Hi", 0
1630   119D 55 6E 65 78 _s3: .db "Unexpected format in printf.", 0
1630   11A1 70 65 63 74 
1630   11A5 65 64 20 66 
1630   11A9 6F 72 6D 61 
1630   11AD 74 20 69 6E 
1630   11B1 20 70 72 69 
1630   11B5 6E 74 66 2E 
1630   11B9 00 
1631   11BA 45 72 72 6F _s4: .db "Error: Unknown argument type.\n", 0
1631   11BE 72 3A 20 55 
1631   11C2 6E 6B 6E 6F 
1631   11C6 77 6E 20 61 
1631   11CA 72 67 75 6D 
1631   11CE 65 6E 74 20 
1631   11D2 74 79 70 65 
1631   11D6 2E 0A 00 
1632   11D9             
1633   11D9 DB 11       _heap_top: .dw _heap
1634   11DB 00          _heap: .db 0
1635   11DC             ; --- END DATA SEGMENT
1636   11DC             
1637   11DC             .end
tasm: Number of errors = 0
