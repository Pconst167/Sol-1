0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT SEGMENT
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; int i = 100; 
0011   0408 52 02 00      sub sp, 2
0012   040B             ; --- START LOCAL VAR INITIALIZATION
0013   040B FA FF FF      lea d, [bp + -1] ; $i
0014   040E DA            push d
0015   040F FD 2E 64 00   mov32 cb, $00000064
0015   0413 00 00 
0016   0415 E7            pop d
0017   0416 FD 43         mov [d], b
0018   0418             ; --- END LOCAL VAR INITIALIZATION
0019   0418             ; int j = -200; 
0020   0418 52 02 00      sub sp, 2
0021   041B             ; --- START LOCAL VAR INITIALIZATION
0022   041B FA FD FF      lea d, [bp + -3] ; $j
0023   041E DA            push d
0024   041F FD 2E C8 00   mov32 cb, $000000c8
0024   0423 00 00 
0025   0425 FD 97         neg b
0026   0427 E7            pop d
0027   0428 FD 43         mov [d], b
0028   042A             ; --- END LOCAL VAR INITIALIZATION
0029   042A             ; printx16(i); 
0030   042A             ; --- START FUNCTION CALL
0031   042A FA FF FF      lea d, [bp + -1] ; $i
0032   042D 2A            mov b, [d]
0033   042E 38 00 00      mov c, 0
0034   0431 FD AB         swp b
0035   0433 D8            push b
0036   0434 07 C3 04      call printx16
0037   0437 51 02 00      add sp, 2
0038   043A             ; --- END FUNCTION CALL
0039   043A             ; print("\n"); 
0040   043A             ; --- START FUNCTION CALL
0041   043A 26 8E 05      mov b, _s0 ; "\n"
0042   043D FD AB         swp b
0043   043F D8            push b
0044   0440 07 15 05      call print
0045   0443 51 02 00      add sp, 2
0046   0446             ; --- END FUNCTION CALL
0047   0446             ; printx16(j); 
0048   0446             ; --- START FUNCTION CALL
0049   0446 FA FD FF      lea d, [bp + -3] ; $j
0050   0449 2A            mov b, [d]
0051   044A 38 00 00      mov c, 0
0052   044D FD AB         swp b
0053   044F D8            push b
0054   0450 07 C3 04      call printx16
0055   0453 51 02 00      add sp, 2
0056   0456             ; --- END FUNCTION CALL
0057   0456             ; print("\n"); 
0058   0456             ; --- START FUNCTION CALL
0059   0456 26 8E 05      mov b, _s0 ; "\n"
0060   0459 FD AB         swp b
0061   045B D8            push b
0062   045C 07 15 05      call print
0063   045F 51 02 00      add sp, 2
0064   0462             ; --- END FUNCTION CALL
0065   0462             ; printx32(i*j); 
0066   0462             ; --- START FUNCTION CALL
0067   0462 FA FF FF      lea d, [bp + -1] ; $i
0068   0465 2A            mov b, [d]
0069   0466 38 00 00      mov c, 0
0070   0469             ; --- START FACTORS
0071   0469 D7            push a
0072   046A FD D8         push g
0073   046C 11            mov a, b
0074   046D FD 7A         mov g, c
0075   046F FA FD FF      lea d, [bp + -3] ; $j
0076   0472 2A            mov b, [d]
0077   0473 38 00 00      mov c, 0
0078   0476 D7            push a     ; save left operand
0079   0477 8E            xor a, b   ; xor sign bits
0080   0478 FD AA         swp a      ; swap bytes
0081   047A 83            mov cl, al ; save result of xor into 'dl'
0082   047B E4            pop a      ; restore left side operator
0083   047C DF            push cl    ; save result of xor above
0084   047D FD AA         swp a  
0085   047F 93 80         test al, $80  
0086   0481 FD AA         swp a  
0087   0483 C6 88 04      jz skip_invert_a_0  
0088   0486 FD 95          neg a 
0089   0488             skip_invert_a_0:   
0090   0488 FD AB         swp b
0091   048A FD 93 80      test bl, $80  
0092   048D FD AB         swp b
0093   048F C6 94 04      jz skip_invert_b_0  
0094   0492 FD 97          neg b 
0095   0494             skip_invert_b_0:   
0096   0494 AC            mul a, b ; *
0097   0495 FD 78         mov g, a
0098   0497 11            mov a, b
0099   0498 EA            pop bl
0100   0499 FD 93 80      test bl, $80
0101   049C C6 AE 04      jz _same_signs_0
0102   049F 27            mov b, a
0103   04A0 FD 12         mov a, g
0104   04A2 95            not a
0105   04A3 97            not b
0106   04A4 55 01 00      add b, 1
0107   04A7 5B 00 00      adc a, 0
0108   04AA 39            mov c, a
0109   04AB FD 7A         mov g, c
0110   04AD 11            mov a, b
0111   04AE             _same_signs_0:
0112   04AE FD 38         mov c, g
0113   04B0 27            mov b, a
0114   04B1 FD F1         pop g
0115   04B3 E4            pop a
0116   04B4             ; --- END FACTORS
0117   04B4 12            mov a, c
0118   04B5 FD AA         swp a
0119   04B7 D7            push a
0120   04B8 FD AB         swp b
0121   04BA D8            push b
0122   04BB 07 2E 05      call printx32
0123   04BE 51 04 00      add sp, 4
0124   04C1             ; --- END FUNCTION CALL
0125   04C1 05 0B         syscall sys_terminate_proc
0126   04C3             
0127   04C3             printx16:
0128   04C3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0129   04C6             ; --- BEGIN INLINE ASM SEGMENT
0130   04C6 FA 05 00      lea d, [bp + 5] ; $hex
0131   04C9 2A            mov b, [d]
0132   04CA             print_u16x_printx16:
0133   04CA DD            push bl
0134   04CB 30            mov bl, bh
0135   04CC 07 E9 04      call _itoa_printx16        
0136   04CF 2F            mov bl, al        
0137   04D0 19 00         mov al, 0
0138   04D2 05 03         syscall sys_io        
0139   04D4 24            mov ah, bl        
0140   04D5 19 00         mov al, 0
0141   04D7 05 03         syscall sys_io        
0142   04D9 EA            pop bl
0143   04DA 07 E9 04      call _itoa_printx16        
0144   04DD 2F            mov bl, al        
0145   04DE 19 00         mov al, 0
0146   04E0 05 03         syscall sys_io        
0147   04E2 24            mov ah, bl        
0148   04E3 19 00         mov al, 0
0149   04E5 05 03         syscall sys_io        
0150   04E7             ; --- END INLINE ASM SEGMENT
0151   04E7             ; return; 
0152   04E7 F9            leave
0153   04E8 09            ret
0154   04E9             ; --- BEGIN INLINE ASM SEGMENT
0155   04E9             _itoa_printx16:
0156   04E9 DA            push d
0157   04EA D8            push b
0158   04EB A7 00         mov bh, 0
0159   04ED FD A4 04      shr bl, 4  
0160   04F0 74            mov d, b
0161   04F1 1F 03 05      mov al, [d + s_hex_digits_printx16]
0162   04F4 23            mov ah, al
0163   04F5 E5            pop b
0164   04F6 D8            push b
0165   04F7 A7 00         mov bh, 0
0166   04F9 FD 87 0F      and bl, $0F
0167   04FC 74            mov d, b
0168   04FD 1F 03 05      mov al, [d + s_hex_digits_printx16]
0169   0500 E5            pop b
0170   0501 E7            pop d
0171   0502 09            ret
0172   0503 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
0172   0507 34 35 36 37 
0172   050B 38 39 41 42 
0172   050F 43 44 45 46 
0173   0513             ; --- END INLINE ASM SEGMENT
0174   0513 F9            leave
0175   0514 09            ret
0176   0515             
0177   0515             print:
0178   0515 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0179   0518             ; --- BEGIN INLINE ASM SEGMENT
0180   0518 FA 05 00      lea d, [bp + 5] ; $s
0181   051B FD 2A         mov d, [d]
0182   051D             _puts_L1_print:
0183   051D 1E            mov al, [d]
0184   051E B9 00         cmp al, 0
0185   0520 C6 2C 05      jz _puts_END_print
0186   0523 23            mov ah, al
0187   0524 19 00         mov al, 0
0188   0526 05 03         syscall sys_io
0189   0528 79            inc d
0190   0529 0A 1D 05      jmp _puts_L1_print
0191   052C             _puts_END_print:
0192   052C             ; --- END INLINE ASM SEGMENT
0193   052C F9            leave
0194   052D 09            ret
0195   052E             
0196   052E             printx32:
0197   052E F8 00 00      enter 0 ; (push bp; mov bp, sp)
0198   0531             ; --- BEGIN INLINE ASM SEGMENT
0199   0531 FA 05 00      lea d, [bp + 5] ; $hex
0200   0534 2B 02 00      mov b, [d+2]
0201   0537 07 40 05      call print_u16x_printx32
0202   053A 2A            mov b, [d]
0203   053B 07 40 05      call print_u16x_printx32
0204   053E             ; --- END INLINE ASM SEGMENT
0205   053E             ; return; 
0206   053E F9            leave
0207   053F 09            ret
0208   0540             ; --- BEGIN INLINE ASM SEGMENT
0209   0540             print_u16x_printx32:
0210   0540 D7            push a
0211   0541 D8            push b
0212   0542 DD            push bl
0213   0543 30            mov bl, bh
0214   0544 07 62 05      call _itoa_printx32        
0215   0547 2F            mov bl, al        
0216   0548 19 00         mov al, 0
0217   054A 05 03         syscall sys_io        
0218   054C 24            mov ah, bl        
0219   054D 19 00         mov al, 0
0220   054F 05 03         syscall sys_io        
0221   0551 EA            pop bl
0222   0552 07 62 05      call _itoa_printx32        
0223   0555 2F            mov bl, al        
0224   0556 19 00         mov al, 0
0225   0558 05 03         syscall sys_io        
0226   055A 24            mov ah, bl        
0227   055B 19 00         mov al, 0
0228   055D 05 03         syscall sys_io        
0229   055F E5            pop b
0230   0560 E4            pop a
0231   0561 09            ret
0232   0562             _itoa_printx32:
0233   0562 DA            push d
0234   0563 D8            push b
0235   0564 A7 00         mov bh, 0
0236   0566 FD A4 04      shr bl, 4  
0237   0569 74            mov d, b
0238   056A 1F 7C 05      mov al, [d + s_hex_digits_printx32]
0239   056D 23            mov ah, al
0240   056E E5            pop b
0241   056F D8            push b
0242   0570 A7 00         mov bh, 0
0243   0572 FD 87 0F      and bl, $0F
0244   0575 74            mov d, b
0245   0576 1F 7C 05      mov al, [d + s_hex_digits_printx32]
0246   0579 E5            pop b
0247   057A E7            pop d
0248   057B 09            ret
0249   057C 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
0249   0580 34 35 36 37 
0249   0584 38 39 41 42 
0249   0588 43 44 45 46 
0250   058C             ; --- END INLINE ASM SEGMENT
0251   058C F9            leave
0252   058D 09            ret
0253   058E             ; --- END TEXT SEGMENT
0254   058E             
0255   058E             ; --- BEGIN DATA SEGMENT
0256   058E 0A 00       _s0: .db "\n", 0
0257   0590             
0258   0590 92 05       _heap_top: .dw _heap
0259   0592 00          _heap: .db 0
0260   0593             ; --- END DATA SEGMENT
0261   0593             
0262   0593             .end
tasm: Number of errors = 0
