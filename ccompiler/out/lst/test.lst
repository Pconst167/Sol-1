0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT SEGMENT
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; 1L || 'A'; 
0011   0408 FD 2E 01 00   mov32 cb, $00000001
0011   040C 00 00 
0012   040E             ; --- START LOGICAL OR
0013   040E D7            push a
0014   040F FD D8         push g
0015   0411 11            mov a, b
0016   0412 FD 7A         mov g, c
0017   0414 FD 2E 41 00   mov32 cb, $00000041
0017   0418 00 00 
0018   041A 38 00 00      mov c, 0
0019   041D FD B2         sor32 ga, cb
0020   041F FD F1         pop g
0021   0421 E4            pop a
0022   0422             ; --- END LOGICAL OR
0023   0422 05 0B         syscall sys_terminate_proc
0024   0424             
0025   0424             strcpy:
0026   0424 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0027   0427             ; char *psrc; 
0028   0427 52 02 00      sub sp, 2
0029   042A             ; char *pdest; 
0030   042A 52 02 00      sub sp, 2
0031   042D             ; psrc = src; 
0032   042D FA FF FF      lea d, [bp + -1] ; $psrc
0033   0430 DA            push d
0034   0431 FA 07 00      lea d, [bp + 7] ; $src
0035   0434 2A            mov b, [d]
0036   0435 38 00 00      mov c, 0
0037   0438 E7            pop d
0038   0439 FD 43         mov [d], b
0039   043B             ; pdest = dest; 
0040   043B FA FD FF      lea d, [bp + -3] ; $pdest
0041   043E DA            push d
0042   043F FA 05 00      lea d, [bp + 5] ; $dest
0043   0442 2A            mov b, [d]
0044   0443 38 00 00      mov c, 0
0045   0446 E7            pop d
0046   0447 FD 43         mov [d], b
0047   0449             ; while(*psrc) *pdest++ = *psrc++; 
0048   0449             _while1_cond:
0049   0449 FA FF FF      lea d, [bp + -1] ; $psrc
0050   044C 2A            mov b, [d]
0051   044D 38 00 00      mov c, 0
0052   0450 74            mov d, b
0053   0451 32            mov bl, [d]
0054   0452 A7 00         mov bh, 0
0055   0454 C0 00 00      cmp b, 0
0056   0457 C6 85 04      je _while1_exit
0057   045A             _while1_block:
0058   045A             ; *pdest++ = *psrc++; 
0059   045A FA FD FF      lea d, [bp + -3] ; $pdest
0060   045D 2A            mov b, [d]
0061   045E 38 00 00      mov c, 0
0062   0461 FD 77         inc b
0063   0463 FA FD FF      lea d, [bp + -3] ; $pdest
0064   0466 FD 43         mov [d], b
0065   0468 FD 7D         dec b
0066   046A D8            push b
0067   046B FA FF FF      lea d, [bp + -1] ; $psrc
0068   046E 2A            mov b, [d]
0069   046F 38 00 00      mov c, 0
0070   0472 FD 77         inc b
0071   0474 FA FF FF      lea d, [bp + -1] ; $psrc
0072   0477 FD 43         mov [d], b
0073   0479 FD 7D         dec b
0074   047B 74            mov d, b
0075   047C 32            mov bl, [d]
0076   047D A7 00         mov bh, 0
0077   047F E7            pop d
0078   0480 FD 3E         mov [d], bl
0079   0482 0A 49 04      jmp _while1_cond
0080   0485             _while1_exit:
0081   0485             ; *pdest = '\0'; 
0082   0485 FA FD FF      lea d, [bp + -3] ; $pdest
0083   0488 2A            mov b, [d]
0084   0489 38 00 00      mov c, 0
0085   048C D8            push b
0086   048D FD 2E 00 00   mov32 cb, $00000000
0086   0491 00 00 
0087   0493 E7            pop d
0088   0494 FD 3E         mov [d], bl
0089   0496 F9            leave
0090   0497 09            ret
0091   0498             
0092   0498             strcmp:
0093   0498 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0094   049B             ; while (*s1 && (*s1 == *s2)) { 
0095   049B             _while2_cond:
0096   049B FA 05 00      lea d, [bp + 5] ; $s1
0097   049E 2A            mov b, [d]
0098   049F 38 00 00      mov c, 0
0099   04A2 74            mov d, b
0100   04A3 32            mov bl, [d]
0101   04A4 A7 00         mov bh, 0
0102   04A6             ; --- START LOGICAL AND
0103   04A6 D7            push a
0104   04A7 11            mov a, b
0105   04A8 FA 05 00      lea d, [bp + 5] ; $s1
0106   04AB 2A            mov b, [d]
0107   04AC 38 00 00      mov c, 0
0108   04AF 74            mov d, b
0109   04B0 32            mov bl, [d]
0110   04B1 A7 00         mov bh, 0
0111   04B3             ; --- START RELATIONAL
0112   04B3 D7            push a
0113   04B4 11            mov a, b
0114   04B5 FA 07 00      lea d, [bp + 7] ; $s2
0115   04B8 2A            mov b, [d]
0116   04B9 38 00 00      mov c, 0
0117   04BC 74            mov d, b
0118   04BD 32            mov bl, [d]
0119   04BE A7 00         mov bh, 0
0120   04C0 B0            cmp a, b
0121   04C1 FD 71         seq ; ==
0122   04C3 E4            pop a
0123   04C4             ; --- END RELATIONAL
0124   04C4 FD A7         sand a, b
0125   04C6 E4            pop a
0126   04C7             ; --- END LOGICAL AND
0127   04C7 C0 00 00      cmp b, 0
0128   04CA C6 F0 04      je _while2_exit
0129   04CD             _while2_block:
0130   04CD             ; s1++; 
0131   04CD FA 05 00      lea d, [bp + 5] ; $s1
0132   04D0 2A            mov b, [d]
0133   04D1 38 00 00      mov c, 0
0134   04D4 FD 77         inc b
0135   04D6 FA 05 00      lea d, [bp + 5] ; $s1
0136   04D9 FD 43         mov [d], b
0137   04DB FD 7D         dec b
0138   04DD             ; s2++; 
0139   04DD FA 07 00      lea d, [bp + 7] ; $s2
0140   04E0 2A            mov b, [d]
0141   04E1 38 00 00      mov c, 0
0142   04E4 FD 77         inc b
0143   04E6 FA 07 00      lea d, [bp + 7] ; $s2
0144   04E9 FD 43         mov [d], b
0145   04EB FD 7D         dec b
0146   04ED 0A 9B 04      jmp _while2_cond
0147   04F0             _while2_exit:
0148   04F0             ; return *s1 - *s2; 
0149   04F0 FA 05 00      lea d, [bp + 5] ; $s1
0150   04F3 2A            mov b, [d]
0151   04F4 38 00 00      mov c, 0
0152   04F7 74            mov d, b
0153   04F8 32            mov bl, [d]
0154   04F9 A7 00         mov bh, 0
0155   04FB             ; --- START TERMS
0156   04FB D7            push a
0157   04FC 11            mov a, b
0158   04FD FA 07 00      lea d, [bp + 7] ; $s2
0159   0500 2A            mov b, [d]
0160   0501 38 00 00      mov c, 0
0161   0504 74            mov d, b
0162   0505 32            mov bl, [d]
0163   0506 A7 00         mov bh, 0
0164   0508 60            sub a, b
0165   0509 27            mov b, a
0166   050A E4            pop a
0167   050B             ; --- END TERMS
0168   050B F9            leave
0169   050C 09            ret
0170   050D             
0171   050D             strncmp:
0172   050D F8 00 00      enter 0 ; (push bp; mov bp, sp)
0173   0510 F9            leave
0174   0511 09            ret
0175   0512             
0176   0512             strcat:
0177   0512 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0178   0515             ; int dest_len; 
0179   0515 52 02 00      sub sp, 2
0180   0518             ; int i; 
0181   0518 52 02 00      sub sp, 2
0182   051B             ; dest_len = strlen(dest); 
0183   051B FA FF FF      lea d, [bp + -1] ; $dest_len
0184   051E DA            push d
0185   051F             ; --- START FUNCTION CALL
0186   051F FA 05 00      lea d, [bp + 5] ; $dest
0187   0522 2A            mov b, [d]
0188   0523 38 00 00      mov c, 0
0189   0526 FD AB         swp b
0190   0528 D8            push b
0191   0529 07 F5 05      call strlen
0192   052C 51 02 00      add sp, 2
0193   052F             ; --- END FUNCTION CALL
0194   052F E7            pop d
0195   0530 FD 43         mov [d], b
0196   0532             ; for (i = 0; src[i] != 0; i=i+1) { 
0197   0532             _for3_init:
0198   0532 FA FD FF      lea d, [bp + -3] ; $i
0199   0535 DA            push d
0200   0536 FD 2E 00 00   mov32 cb, $00000000
0200   053A 00 00 
0201   053C E7            pop d
0202   053D FD 43         mov [d], b
0203   053F             _for3_cond:
0204   053F FA 07 00      lea d, [bp + 7] ; $src
0205   0542 FD 2A         mov d, [d]
0206   0544 D7            push a
0207   0545 DA            push d
0208   0546 FA FD FF      lea d, [bp + -3] ; $i
0209   0549 2A            mov b, [d]
0210   054A 38 00 00      mov c, 0
0211   054D E7            pop d
0212   054E FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0213   0552 E4            pop a
0214   0553 32            mov bl, [d]
0215   0554 A7 00         mov bh, 0
0216   0556 38 00 00      mov c, 0
0217   0559             ; --- START RELATIONAL
0218   0559 D7            push a
0219   055A 11            mov a, b
0220   055B FD 2E 00 00   mov32 cb, $00000000
0220   055F 00 00 
0221   0561 B0            cmp a, b
0222   0562 FD 72         sneq ; !=
0223   0564 E4            pop a
0224   0565             ; --- END RELATIONAL
0225   0565 C0 00 00      cmp b, 0
0226   0568 C6 C3 05      je _for3_exit
0227   056B             _for3_block:
0228   056B             ; dest[dest_len + i] = src[i]; 
0229   056B FA 05 00      lea d, [bp + 5] ; $dest
0230   056E FD 2A         mov d, [d]
0231   0570 D7            push a
0232   0571 DA            push d
0233   0572 FA FF FF      lea d, [bp + -1] ; $dest_len
0234   0575 2A            mov b, [d]
0235   0576 38 00 00      mov c, 0
0236   0579             ; --- START TERMS
0237   0579 D7            push a
0238   057A 11            mov a, b
0239   057B FA FD FF      lea d, [bp + -3] ; $i
0240   057E 2A            mov b, [d]
0241   057F 38 00 00      mov c, 0
0242   0582 56            add b, a
0243   0583 E4            pop a
0244   0584             ; --- END TERMS
0245   0584 E7            pop d
0246   0585 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0247   0589 E4            pop a
0248   058A DA            push d
0249   058B FA 07 00      lea d, [bp + 7] ; $src
0250   058E FD 2A         mov d, [d]
0251   0590 D7            push a
0252   0591 DA            push d
0253   0592 FA FD FF      lea d, [bp + -3] ; $i
0254   0595 2A            mov b, [d]
0255   0596 38 00 00      mov c, 0
0256   0599 E7            pop d
0257   059A FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0258   059E E4            pop a
0259   059F 32            mov bl, [d]
0260   05A0 A7 00         mov bh, 0
0261   05A2 38 00 00      mov c, 0
0262   05A5 E7            pop d
0263   05A6 FD 3E         mov [d], bl
0264   05A8             _for3_update:
0265   05A8 FA FD FF      lea d, [bp + -3] ; $i
0266   05AB DA            push d
0267   05AC FA FD FF      lea d, [bp + -3] ; $i
0268   05AF 2A            mov b, [d]
0269   05B0 38 00 00      mov c, 0
0270   05B3             ; --- START TERMS
0271   05B3 D7            push a
0272   05B4 11            mov a, b
0273   05B5 FD 2E 01 00   mov32 cb, $00000001
0273   05B9 00 00 
0274   05BB 56            add b, a
0275   05BC E4            pop a
0276   05BD             ; --- END TERMS
0277   05BD E7            pop d
0278   05BE FD 43         mov [d], b
0279   05C0 0A 3F 05      jmp _for3_cond
0280   05C3             _for3_exit:
0281   05C3             ; dest[dest_len + i] = 0; 
0282   05C3 FA 05 00      lea d, [bp + 5] ; $dest
0283   05C6 FD 2A         mov d, [d]
0284   05C8 D7            push a
0285   05C9 DA            push d
0286   05CA FA FF FF      lea d, [bp + -1] ; $dest_len
0287   05CD 2A            mov b, [d]
0288   05CE 38 00 00      mov c, 0
0289   05D1             ; --- START TERMS
0290   05D1 D7            push a
0291   05D2 11            mov a, b
0292   05D3 FA FD FF      lea d, [bp + -3] ; $i
0293   05D6 2A            mov b, [d]
0294   05D7 38 00 00      mov c, 0
0295   05DA 56            add b, a
0296   05DB E4            pop a
0297   05DC             ; --- END TERMS
0298   05DC E7            pop d
0299   05DD FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0300   05E1 E4            pop a
0301   05E2 DA            push d
0302   05E3 FD 2E 00 00   mov32 cb, $00000000
0302   05E7 00 00 
0303   05E9 E7            pop d
0304   05EA FD 3E         mov [d], bl
0305   05EC             ; return dest; 
0306   05EC FA 05 00      lea d, [bp + 5] ; $dest
0307   05EF 2A            mov b, [d]
0308   05F0 38 00 00      mov c, 0
0309   05F3 F9            leave
0310   05F4 09            ret
0311   05F5             
0312   05F5             strlen:
0313   05F5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0314   05F8             ; int length; 
0315   05F8 52 02 00      sub sp, 2
0316   05FB             ; length = 0; 
0317   05FB FA FF FF      lea d, [bp + -1] ; $length
0318   05FE DA            push d
0319   05FF FD 2E 00 00   mov32 cb, $00000000
0319   0603 00 00 
0320   0605 E7            pop d
0321   0606 FD 43         mov [d], b
0322   0608             ; while (str[length] != 0) { 
0323   0608             _while4_cond:
0324   0608 FA 05 00      lea d, [bp + 5] ; $str
0325   060B FD 2A         mov d, [d]
0326   060D D7            push a
0327   060E DA            push d
0328   060F FA FF FF      lea d, [bp + -1] ; $length
0329   0612 2A            mov b, [d]
0330   0613 38 00 00      mov c, 0
0331   0616 E7            pop d
0332   0617 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0333   061B E4            pop a
0334   061C 32            mov bl, [d]
0335   061D A7 00         mov bh, 0
0336   061F 38 00 00      mov c, 0
0337   0622             ; --- START RELATIONAL
0338   0622 D7            push a
0339   0623 11            mov a, b
0340   0624 FD 2E 00 00   mov32 cb, $00000000
0340   0628 00 00 
0341   062A B0            cmp a, b
0342   062B FD 72         sneq ; !=
0343   062D E4            pop a
0344   062E             ; --- END RELATIONAL
0345   062E C0 00 00      cmp b, 0
0346   0631 C6 47 06      je _while4_exit
0347   0634             _while4_block:
0348   0634             ; length++; 
0349   0634 FA FF FF      lea d, [bp + -1] ; $length
0350   0637 2A            mov b, [d]
0351   0638 38 00 00      mov c, 0
0352   063B FD 77         inc b
0353   063D FA FF FF      lea d, [bp + -1] ; $length
0354   0640 FD 43         mov [d], b
0355   0642 FD 7D         dec b
0356   0644 0A 08 06      jmp _while4_cond
0357   0647             _while4_exit:
0358   0647             ; return length; 
0359   0647 FA FF FF      lea d, [bp + -1] ; $length
0360   064A 2A            mov b, [d]
0361   064B 38 00 00      mov c, 0
0362   064E F9            leave
0363   064F 09            ret
0364   0650             
0365   0650             exit:
0366   0650 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0367   0653             
0368   0653             ; --- BEGIN INLINE ASM SEGMENT
0369   0653 05 0B         syscall sys_terminate_proc
0370   0655             ; --- END INLINE ASM SEGMENT
0371   0655             
0372   0655 F9            leave
0373   0656 09            ret
0374   0657             
0375   0657             memset:
0376   0657 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0377   065A             ; int i; 
0378   065A 52 02 00      sub sp, 2
0379   065D             ; for(i = 0; i < size; i++){ 
0380   065D             _for5_init:
0381   065D FA FF FF      lea d, [bp + -1] ; $i
0382   0660 DA            push d
0383   0661 FD 2E 00 00   mov32 cb, $00000000
0383   0665 00 00 
0384   0667 E7            pop d
0385   0668 FD 43         mov [d], b
0386   066A             _for5_cond:
0387   066A FA FF FF      lea d, [bp + -1] ; $i
0388   066D 2A            mov b, [d]
0389   066E 38 00 00      mov c, 0
0390   0671             ; --- START RELATIONAL
0391   0671 D7            push a
0392   0672 11            mov a, b
0393   0673 FA 08 00      lea d, [bp + 8] ; $size
0394   0676 2A            mov b, [d]
0395   0677 38 00 00      mov c, 0
0396   067A B0            cmp a, b
0397   067B FD 73         slt ; < (signed)
0398   067D E4            pop a
0399   067E             ; --- END RELATIONAL
0400   067E C0 00 00      cmp b, 0
0401   0681 C6 B6 06      je _for5_exit
0402   0684             _for5_block:
0403   0684             ; *(s+i) = c; 
0404   0684 FA 05 00      lea d, [bp + 5] ; $s
0405   0687 2A            mov b, [d]
0406   0688 38 00 00      mov c, 0
0407   068B             ; --- START TERMS
0408   068B D7            push a
0409   068C 11            mov a, b
0410   068D FA FF FF      lea d, [bp + -1] ; $i
0411   0690 2A            mov b, [d]
0412   0691 38 00 00      mov c, 0
0413   0694 56            add b, a
0414   0695 E4            pop a
0415   0696             ; --- END TERMS
0416   0696 D8            push b
0417   0697 FA 07 00      lea d, [bp + 7] ; $c
0418   069A 32            mov bl, [d]
0419   069B A7 00         mov bh, 0
0420   069D 38 00 00      mov c, 0
0421   06A0 E7            pop d
0422   06A1 FD 3E         mov [d], bl
0423   06A3             _for5_update:
0424   06A3 FA FF FF      lea d, [bp + -1] ; $i
0425   06A6 2A            mov b, [d]
0426   06A7 38 00 00      mov c, 0
0427   06AA FD 77         inc b
0428   06AC FA FF FF      lea d, [bp + -1] ; $i
0429   06AF FD 43         mov [d], b
0430   06B1 FD 7D         dec b
0431   06B3 0A 6A 06      jmp _for5_cond
0432   06B6             _for5_exit:
0433   06B6             ; return s; 
0434   06B6 FA 05 00      lea d, [bp + 5] ; $s
0435   06B9 2A            mov b, [d]
0436   06BA 38 00 00      mov c, 0
0437   06BD F9            leave
0438   06BE 09            ret
0439   06BF             
0440   06BF             atoi:
0441   06BF F8 00 00      enter 0 ; (push bp; mov bp, sp)
0442   06C2             ; int result = 0;  // Initialize result 
0443   06C2 52 02 00      sub sp, 2
0444   06C5             ; --- START LOCAL VAR INITIALIZATION
0445   06C5 FA FF FF      lea d, [bp + -1] ; $result
0446   06C8 DA            push d
0447   06C9 FD 2E 00 00   mov32 cb, $00000000
0447   06CD 00 00 
0448   06CF E7            pop d
0449   06D0 FD 43         mov [d], b
0450   06D2             ; --- END LOCAL VAR INITIALIZATION
0451   06D2             ; int sign = 1;    // Initialize sign as positive 
0452   06D2 52 02 00      sub sp, 2
0453   06D5             ; --- START LOCAL VAR INITIALIZATION
0454   06D5 FA FD FF      lea d, [bp + -3] ; $sign
0455   06D8 DA            push d
0456   06D9 FD 2E 01 00   mov32 cb, $00000001
0456   06DD 00 00 
0457   06DF E7            pop d
0458   06E0 FD 43         mov [d], b
0459   06E2             ; --- END LOCAL VAR INITIALIZATION
0460   06E2             ; while (*str == ' ') str++; 
0461   06E2             _while6_cond:
0462   06E2 FA 05 00      lea d, [bp + 5] ; $str
0463   06E5 2A            mov b, [d]
0464   06E6 38 00 00      mov c, 0
0465   06E9 74            mov d, b
0466   06EA 32            mov bl, [d]
0467   06EB A7 00         mov bh, 0
0468   06ED             ; --- START RELATIONAL
0469   06ED D7            push a
0470   06EE 11            mov a, b
0471   06EF FD 2E 20 00   mov32 cb, $00000020
0471   06F3 00 00 
0472   06F5 B0            cmp a, b
0473   06F6 FD 71         seq ; ==
0474   06F8 E4            pop a
0475   06F9             ; --- END RELATIONAL
0476   06F9 C0 00 00      cmp b, 0
0477   06FC C6 12 07      je _while6_exit
0478   06FF             _while6_block:
0479   06FF             ; str++; 
0480   06FF FA 05 00      lea d, [bp + 5] ; $str
0481   0702 2A            mov b, [d]
0482   0703 38 00 00      mov c, 0
0483   0706 FD 77         inc b
0484   0708 FA 05 00      lea d, [bp + 5] ; $str
0485   070B FD 43         mov [d], b
0486   070D FD 7D         dec b
0487   070F 0A E2 06      jmp _while6_cond
0488   0712             _while6_exit:
0489   0712             ; if (*str == '-' || *str == '+') { 
0490   0712             _if7_cond:
0491   0712 FA 05 00      lea d, [bp + 5] ; $str
0492   0715 2A            mov b, [d]
0493   0716 38 00 00      mov c, 0
0494   0719 74            mov d, b
0495   071A 32            mov bl, [d]
0496   071B A7 00         mov bh, 0
0497   071D             ; --- START RELATIONAL
0498   071D D7            push a
0499   071E 11            mov a, b
0500   071F FD 2E 2D 00   mov32 cb, $0000002d
0500   0723 00 00 
0501   0725 B0            cmp a, b
0502   0726 FD 71         seq ; ==
0503   0728 E4            pop a
0504   0729             ; --- END RELATIONAL
0505   0729             ; --- START LOGICAL OR
0506   0729 D7            push a
0507   072A 11            mov a, b
0508   072B FA 05 00      lea d, [bp + 5] ; $str
0509   072E 2A            mov b, [d]
0510   072F 38 00 00      mov c, 0
0511   0732 74            mov d, b
0512   0733 32            mov bl, [d]
0513   0734 A7 00         mov bh, 0
0514   0736             ; --- START RELATIONAL
0515   0736 D7            push a
0516   0737 11            mov a, b
0517   0738 FD 2E 2B 00   mov32 cb, $0000002b
0517   073C 00 00 
0518   073E B0            cmp a, b
0519   073F FD 71         seq ; ==
0520   0741 E4            pop a
0521   0742             ; --- END RELATIONAL
0522   0742 FD A8         sor a, b ; ||
0523   0744 E4            pop a
0524   0745             ; --- END LOGICAL OR
0525   0745 C0 00 00      cmp b, 0
0526   0748 C6 8D 07      je _if7_exit
0527   074B             _if7_true:
0528   074B             ; if (*str == '-') sign = -1; 
0529   074B             _if8_cond:
0530   074B FA 05 00      lea d, [bp + 5] ; $str
0531   074E 2A            mov b, [d]
0532   074F 38 00 00      mov c, 0
0533   0752 74            mov d, b
0534   0753 32            mov bl, [d]
0535   0754 A7 00         mov bh, 0
0536   0756             ; --- START RELATIONAL
0537   0756 D7            push a
0538   0757 11            mov a, b
0539   0758 FD 2E 2D 00   mov32 cb, $0000002d
0539   075C 00 00 
0540   075E B0            cmp a, b
0541   075F FD 71         seq ; ==
0542   0761 E4            pop a
0543   0762             ; --- END RELATIONAL
0544   0762 C0 00 00      cmp b, 0
0545   0765 C6 7A 07      je _if8_exit
0546   0768             _if8_true:
0547   0768             ; sign = -1; 
0548   0768 FA FD FF      lea d, [bp + -3] ; $sign
0549   076B DA            push d
0550   076C FD 2E 01 00   mov32 cb, $00000001
0550   0770 00 00 
0551   0772 FD 97         neg b
0552   0774 E7            pop d
0553   0775 FD 43         mov [d], b
0554   0777 0A 7A 07      jmp _if8_exit
0555   077A             _if8_exit:
0556   077A             ; str++; 
0557   077A FA 05 00      lea d, [bp + 5] ; $str
0558   077D 2A            mov b, [d]
0559   077E 38 00 00      mov c, 0
0560   0781 FD 77         inc b
0561   0783 FA 05 00      lea d, [bp + 5] ; $str
0562   0786 FD 43         mov [d], b
0563   0788 FD 7D         dec b
0564   078A 0A 8D 07      jmp _if7_exit
0565   078D             _if7_exit:
0566   078D             ; while (*str >= '0' && *str <= '9') { 
0567   078D             _while9_cond:
0568   078D FA 05 00      lea d, [bp + 5] ; $str
0569   0790 2A            mov b, [d]
0570   0791 38 00 00      mov c, 0
0571   0794 74            mov d, b
0572   0795 32            mov bl, [d]
0573   0796 A7 00         mov bh, 0
0574   0798             ; --- START RELATIONAL
0575   0798 D7            push a
0576   0799 11            mov a, b
0577   079A FD 2E 30 00   mov32 cb, $00000030
0577   079E 00 00 
0578   07A0 B0            cmp a, b
0579   07A1 FD 82         sgeu ; >= (unsigned)
0580   07A3 E4            pop a
0581   07A4             ; --- END RELATIONAL
0582   07A4             ; --- START LOGICAL AND
0583   07A4 D7            push a
0584   07A5 11            mov a, b
0585   07A6 FA 05 00      lea d, [bp + 5] ; $str
0586   07A9 2A            mov b, [d]
0587   07AA 38 00 00      mov c, 0
0588   07AD 74            mov d, b
0589   07AE 32            mov bl, [d]
0590   07AF A7 00         mov bh, 0
0591   07B1             ; --- START RELATIONAL
0592   07B1 D7            push a
0593   07B2 11            mov a, b
0594   07B3 FD 2E 39 00   mov32 cb, $00000039
0594   07B7 00 00 
0595   07B9 B0            cmp a, b
0596   07BA FD 76         sleu ; <= (unsigned)
0597   07BC E4            pop a
0598   07BD             ; --- END RELATIONAL
0599   07BD FD A7         sand a, b
0600   07BF E4            pop a
0601   07C0             ; --- END LOGICAL AND
0602   07C0 C0 00 00      cmp b, 0
0603   07C3 C6 0D 08      je _while9_exit
0604   07C6             _while9_block:
0605   07C6             ; result = result * 10 + (*str - '0'); 
0606   07C6 FA FF FF      lea d, [bp + -1] ; $result
0607   07C9 DA            push d
0608   07CA FA FF FF      lea d, [bp + -1] ; $result
0609   07CD 2A            mov b, [d]
0610   07CE 38 00 00      mov c, 0
0611   07D1             ; --- START FACTORS
0612   07D1 D7            push a
0613   07D2 11            mov a, b
0614   07D3 FD 2E 0A 00   mov32 cb, $0000000a
0614   07D7 00 00 
0615   07D9 AC            mul a, b ; *
0616   07DA 11            mov a, b
0617   07DB 27            mov b, a
0618   07DC E4            pop a
0619   07DD             ; --- END FACTORS
0620   07DD             ; --- START TERMS
0621   07DD D7            push a
0622   07DE 11            mov a, b
0623   07DF FA 05 00      lea d, [bp + 5] ; $str
0624   07E2 2A            mov b, [d]
0625   07E3 38 00 00      mov c, 0
0626   07E6 74            mov d, b
0627   07E7 32            mov bl, [d]
0628   07E8 A7 00         mov bh, 0
0629   07EA             ; --- START TERMS
0630   07EA D7            push a
0631   07EB 11            mov a, b
0632   07EC FD 2E 30 00   mov32 cb, $00000030
0632   07F0 00 00 
0633   07F2 60            sub a, b
0634   07F3 27            mov b, a
0635   07F4 E4            pop a
0636   07F5             ; --- END TERMS
0637   07F5 56            add b, a
0638   07F6 E4            pop a
0639   07F7             ; --- END TERMS
0640   07F7 E7            pop d
0641   07F8 FD 43         mov [d], b
0642   07FA             ; str++; 
0643   07FA FA 05 00      lea d, [bp + 5] ; $str
0644   07FD 2A            mov b, [d]
0645   07FE 38 00 00      mov c, 0
0646   0801 FD 77         inc b
0647   0803 FA 05 00      lea d, [bp + 5] ; $str
0648   0806 FD 43         mov [d], b
0649   0808 FD 7D         dec b
0650   080A 0A 8D 07      jmp _while9_cond
0651   080D             _while9_exit:
0652   080D             ; return sign * result; 
0653   080D FA FD FF      lea d, [bp + -3] ; $sign
0654   0810 2A            mov b, [d]
0655   0811 38 00 00      mov c, 0
0656   0814             ; --- START FACTORS
0657   0814 D7            push a
0658   0815 11            mov a, b
0659   0816 FA FF FF      lea d, [bp + -1] ; $result
0660   0819 2A            mov b, [d]
0661   081A 38 00 00      mov c, 0
0662   081D AC            mul a, b ; *
0663   081E 11            mov a, b
0664   081F 27            mov b, a
0665   0820 E4            pop a
0666   0821             ; --- END FACTORS
0667   0821 F9            leave
0668   0822 09            ret
0669   0823             
0670   0823             rand:
0671   0823 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0672   0826             ; int  sec; 
0673   0826 52 02 00      sub sp, 2
0674   0829             
0675   0829             ; --- BEGIN INLINE ASM SEGMENT
0676   0829 19 00         mov al, 0
0677   082B 05 01         syscall sys_rtc					
0678   082D 1A            mov al, ah
0679   082E FA FF FF      lea d, [bp + -1] ; $sec
0680   0831 1E            mov al, [d]
0681   0832 22 00         mov ah, 0
0682   0834             ; --- END INLINE ASM SEGMENT
0683   0834             
0684   0834             ; return sec; 
0685   0834 FA FF FF      lea d, [bp + -1] ; $sec
0686   0837 2A            mov b, [d]
0687   0838 38 00 00      mov c, 0
0688   083B F9            leave
0689   083C 09            ret
0690   083D             
0691   083D             alloc:
0692   083D F8 00 00      enter 0 ; (push bp; mov bp, sp)
0693   0840             ; heap_top = heap_top + bytes; 
0694   0840 3B 32 21      mov d, _heap_top ; $heap_top
0695   0843 DA            push d
0696   0844 3B 32 21      mov d, _heap_top ; $heap_top
0697   0847 2A            mov b, [d]
0698   0848 38 00 00      mov c, 0
0699   084B             ; --- START TERMS
0700   084B D7            push a
0701   084C 11            mov a, b
0702   084D FA 05 00      lea d, [bp + 5] ; $bytes
0703   0850 2A            mov b, [d]
0704   0851 38 00 00      mov c, 0
0705   0854 56            add b, a
0706   0855 E4            pop a
0707   0856             ; --- END TERMS
0708   0856 E7            pop d
0709   0857 FD 43         mov [d], b
0710   0859             ; return heap_top - bytes; 
0711   0859 3B 32 21      mov d, _heap_top ; $heap_top
0712   085C 2A            mov b, [d]
0713   085D 38 00 00      mov c, 0
0714   0860             ; --- START TERMS
0715   0860 D7            push a
0716   0861 11            mov a, b
0717   0862 FA 05 00      lea d, [bp + 5] ; $bytes
0718   0865 2A            mov b, [d]
0719   0866 38 00 00      mov c, 0
0720   0869 60            sub a, b
0721   086A 27            mov b, a
0722   086B E4            pop a
0723   086C             ; --- END TERMS
0724   086C F9            leave
0725   086D 09            ret
0726   086E             
0727   086E             free:
0728   086E F8 00 00      enter 0 ; (push bp; mov bp, sp)
0729   0871             ; return heap_top = heap_top - bytes; 
0730   0871 3B 32 21      mov d, _heap_top ; $heap_top
0731   0874 DA            push d
0732   0875 3B 32 21      mov d, _heap_top ; $heap_top
0733   0878 2A            mov b, [d]
0734   0879 38 00 00      mov c, 0
0735   087C             ; --- START TERMS
0736   087C D7            push a
0737   087D 11            mov a, b
0738   087E FA 05 00      lea d, [bp + 5] ; $bytes
0739   0881 2A            mov b, [d]
0740   0882 38 00 00      mov c, 0
0741   0885 60            sub a, b
0742   0886 27            mov b, a
0743   0887 E4            pop a
0744   0888             ; --- END TERMS
0745   0888 E7            pop d
0746   0889 FD 43         mov [d], b
0747   088B F9            leave
0748   088C 09            ret
0749   088D             
0750   088D             fopen:
0751   088D F8 00 00      enter 0 ; (push bp; mov bp, sp)
0752   0890             ; FILE *fp; 
0753   0890 52 02 00      sub sp, 2
0754   0893             ; static int max_handle = 0; 
0755   0893 52 02 00      sub sp, 2
0756   0896             ; fp = alloc(sizeof(FILE)); 
0757   0896 FA FF FF      lea d, [bp + -1] ; $fp
0758   0899 DA            push d
0759   089A             ; --- START FUNCTION CALL
0760   089A 26 04 01      mov b, 260
0761   089D FD AB         swp b
0762   089F D8            push b
0763   08A0 07 3D 08      call alloc
0764   08A3 51 02 00      add sp, 2
0765   08A6             ; --- END FUNCTION CALL
0766   08A6 E7            pop d
0767   08A7 FD 43         mov [d], b
0768   08A9             ; strcpy(fp->filename, filename); 
0769   08A9             ; --- START FUNCTION CALL
0770   08A9 FA 05 00      lea d, [bp + 5] ; $filename
0771   08AC 2A            mov b, [d]
0772   08AD 38 00 00      mov c, 0
0773   08B0 FD AB         swp b
0774   08B2 D8            push b
0775   08B3 FA FF FF      lea d, [bp + -1] ; $fp
0776   08B6 FD 2A         mov d, [d]
0777   08B8 58 02 00      add d, 2
0778   08BB 2D            mov b, d
0779   08BC 38 00 00      mov c, 0
0780   08BF FD AB         swp b
0781   08C1 D8            push b
0782   08C2 07 24 04      call strcpy
0783   08C5 51 04 00      add sp, 4
0784   08C8             ; --- END FUNCTION CALL
0785   08C8             ; fp->handle = max_handle; 
0786   08C8 FA FF FF      lea d, [bp + -1] ; $fp
0787   08CB FD 2A         mov d, [d]
0788   08CD 58 00 00      add d, 0
0789   08D0 DA            push d
0790   08D1 3B EC 20      mov d, st_fopen_max_handle ; static max_handle
0791   08D4 2A            mov b, [d]
0792   08D5 38 00 00      mov c, 0
0793   08D8 E7            pop d
0794   08D9 FD 43         mov [d], b
0795   08DB             ; fp->mode = mode; 
0796   08DB FA FF FF      lea d, [bp + -1] ; $fp
0797   08DE FD 2A         mov d, [d]
0798   08E0 58 02 01      add d, 258
0799   08E3 DA            push d
0800   08E4 FA 07 00      lea d, [bp + 7] ; $mode
0801   08E7 32            mov bl, [d]
0802   08E8 A7 00         mov bh, 0
0803   08EA 38 00 00      mov c, 0
0804   08ED E7            pop d
0805   08EE FD 3E         mov [d], bl
0806   08F0             ; fp->loc = 0; 
0807   08F0 FA FF FF      lea d, [bp + -1] ; $fp
0808   08F3 FD 2A         mov d, [d]
0809   08F5 58 03 01      add d, 259
0810   08F8 DA            push d
0811   08F9 FD 2E 00 00   mov32 cb, $00000000
0811   08FD 00 00 
0812   08FF E7            pop d
0813   0900 FD 3E         mov [d], bl
0814   0902             ; max_handle++; 
0815   0902 3B EC 20      mov d, st_fopen_max_handle ; static max_handle
0816   0905 2A            mov b, [d]
0817   0906 38 00 00      mov c, 0
0818   0909 FD 77         inc b
0819   090B 3B EC 20      mov d, st_fopen_max_handle ; static max_handle
0820   090E FD 43         mov [d], b
0821   0910 FD 7D         dec b
0822   0912 F9            leave
0823   0913 09            ret
0824   0914             
0825   0914             fclose:
0826   0914 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0827   0917             ; free(sizeof(FILE)); 
0828   0917             ; --- START FUNCTION CALL
0829   0917 26 04 01      mov b, 260
0830   091A FD AB         swp b
0831   091C D8            push b
0832   091D 07 6E 08      call free
0833   0920 51 02 00      add sp, 2
0834   0923             ; --- END FUNCTION CALL
0835   0923 F9            leave
0836   0924 09            ret
0837   0925             
0838   0925             printf:
0839   0925 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0840   0928             ; char *p, *format_p; 
0841   0928 52 02 00      sub sp, 2
0842   092B 52 02 00      sub sp, 2
0843   092E             ; format_p = format; 
0844   092E FA FD FF      lea d, [bp + -3] ; $format_p
0845   0931 DA            push d
0846   0932 FA 05 00      lea d, [bp + 5] ; $format
0847   0935 2A            mov b, [d]
0848   0936 38 00 00      mov c, 0
0849   0939 E7            pop d
0850   093A FD 43         mov [d], b
0851   093C             ; p = &format + 2; 
0852   093C FA FF FF      lea d, [bp + -1] ; $p
0853   093F DA            push d
0854   0940 FA 05 00      lea d, [bp + 5] ; $format
0855   0943 2D            mov b, d
0856   0944             ; --- START TERMS
0857   0944 D7            push a
0858   0945 11            mov a, b
0859   0946 FD 2E 02 00   mov32 cb, $00000002
0859   094A 00 00 
0860   094C 56            add b, a
0861   094D E4            pop a
0862   094E             ; --- END TERMS
0863   094E E7            pop d
0864   094F FD 43         mov [d], b
0865   0951             ; for(;;){ 
0866   0951             _for10_init:
0867   0951             _for10_cond:
0868   0951             _for10_block:
0869   0951             ; if(!*format_p) break; 
0870   0951             _if11_cond:
0871   0951 FA FD FF      lea d, [bp + -3] ; $format_p
0872   0954 2A            mov b, [d]
0873   0955 38 00 00      mov c, 0
0874   0958 74            mov d, b
0875   0959 32            mov bl, [d]
0876   095A A7 00         mov bh, 0
0877   095C C0 00 00      cmp b, 0
0878   095F FD 71         seq ; !
0879   0961 C0 00 00      cmp b, 0
0880   0964 C6 6D 09      je _if11_else
0881   0967             _if11_true:
0882   0967             ; break; 
0883   0967 0A EB 0B      jmp _for10_exit ; for break
0884   096A 0A E8 0B      jmp _if11_exit
0885   096D             _if11_else:
0886   096D             ; if(*format_p == '%'){ 
0887   096D             _if12_cond:
0888   096D FA FD FF      lea d, [bp + -3] ; $format_p
0889   0970 2A            mov b, [d]
0890   0971 38 00 00      mov c, 0
0891   0974 74            mov d, b
0892   0975 32            mov bl, [d]
0893   0976 A7 00         mov bh, 0
0894   0978             ; --- START RELATIONAL
0895   0978 D7            push a
0896   0979 11            mov a, b
0897   097A FD 2E 25 00   mov32 cb, $00000025
0897   097E 00 00 
0898   0980 B0            cmp a, b
0899   0981 FD 71         seq ; ==
0900   0983 E4            pop a
0901   0984             ; --- END RELATIONAL
0902   0984 C0 00 00      cmp b, 0
0903   0987 C6 C6 0B      je _if12_else
0904   098A             _if12_true:
0905   098A             ; format_p++; 
0906   098A FA FD FF      lea d, [bp + -3] ; $format_p
0907   098D 2A            mov b, [d]
0908   098E 38 00 00      mov c, 0
0909   0991 FD 77         inc b
0910   0993 FA FD FF      lea d, [bp + -3] ; $format_p
0911   0996 FD 43         mov [d], b
0912   0998 FD 7D         dec b
0913   099A             ; switch(*format_p){ 
0914   099A             _switch13_expr:
0915   099A FA FD FF      lea d, [bp + -3] ; $format_p
0916   099D 2A            mov b, [d]
0917   099E 38 00 00      mov c, 0
0918   09A1 74            mov d, b
0919   09A2 32            mov bl, [d]
0920   09A3 A7 00         mov bh, 0
0921   09A5             _switch13_comparisons:
0922   09A5 C1 6C         cmp bl, $6c
0923   09A7 C6 D3 09      je _switch13_case0
0924   09AA C1 4C         cmp bl, $4c
0925   09AC C6 D3 09      je _switch13_case1
0926   09AF C1 64         cmp bl, $64
0927   09B1 C6 DF 0A      je _switch13_case2
0928   09B4 C1 69         cmp bl, $69
0929   09B6 C6 DF 0A      je _switch13_case3
0930   09B9 C1 75         cmp bl, $75
0931   09BB C6 0C 0B      je _switch13_case4
0932   09BE C1 78         cmp bl, $78
0933   09C0 C6 39 0B      je _switch13_case5
0934   09C3 C1 63         cmp bl, $63
0935   09C5 C6 5D 0B      je _switch13_case6
0936   09C8 C1 73         cmp bl, $73
0937   09CA C6 82 0B      je _switch13_case7
0938   09CD 0A A7 0B      jmp _switch13_default
0939   09D0 0A B3 0B      jmp _switch13_exit
0940   09D3             _switch13_case0:
0941   09D3             _switch13_case1:
0942   09D3             ; format_p++; 
0943   09D3 FA FD FF      lea d, [bp + -3] ; $format_p
0944   09D6 2A            mov b, [d]
0945   09D7 38 00 00      mov c, 0
0946   09DA FD 77         inc b
0947   09DC FA FD FF      lea d, [bp + -3] ; $format_p
0948   09DF FD 43         mov [d], b
0949   09E1 FD 7D         dec b
0950   09E3             ; if(*format_p == 'd' || *format_p == 'i') 
0951   09E3             _if14_cond:
0952   09E3 FA FD FF      lea d, [bp + -3] ; $format_p
0953   09E6 2A            mov b, [d]
0954   09E7 38 00 00      mov c, 0
0955   09EA 74            mov d, b
0956   09EB 32            mov bl, [d]
0957   09EC A7 00         mov bh, 0
0958   09EE             ; --- START RELATIONAL
0959   09EE D7            push a
0960   09EF 11            mov a, b
0961   09F0 FD 2E 64 00   mov32 cb, $00000064
0961   09F4 00 00 
0962   09F6 B0            cmp a, b
0963   09F7 FD 71         seq ; ==
0964   09F9 E4            pop a
0965   09FA             ; --- END RELATIONAL
0966   09FA             ; --- START LOGICAL OR
0967   09FA D7            push a
0968   09FB 11            mov a, b
0969   09FC FA FD FF      lea d, [bp + -3] ; $format_p
0970   09FF 2A            mov b, [d]
0971   0A00 38 00 00      mov c, 0
0972   0A03 74            mov d, b
0973   0A04 32            mov bl, [d]
0974   0A05 A7 00         mov bh, 0
0975   0A07             ; --- START RELATIONAL
0976   0A07 D7            push a
0977   0A08 11            mov a, b
0978   0A09 FD 2E 69 00   mov32 cb, $00000069
0978   0A0D 00 00 
0979   0A0F B0            cmp a, b
0980   0A10 FD 71         seq ; ==
0981   0A12 E4            pop a
0982   0A13             ; --- END RELATIONAL
0983   0A13 FD A8         sor a, b ; ||
0984   0A15 E4            pop a
0985   0A16             ; --- END LOGICAL OR
0986   0A16 C0 00 00      cmp b, 0
0987   0A19 C6 3D 0A      je _if14_else
0988   0A1C             _if14_true:
0989   0A1C             ; print_signed_long(*(long *)p); 
0990   0A1C             ; --- START FUNCTION CALL
0991   0A1C FA FF FF      lea d, [bp + -1] ; $p
0992   0A1F 2A            mov b, [d]
0993   0A20 38 00 00      mov c, 0
0994   0A23 AB            snex b
0995   0A24 FD 39         mov c, b
0996   0A26 74            mov d, b
0997   0A27 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0998   0A2A FD 39         mov c, b ; And place it into C
0999   0A2C 2A            mov b, [d] ; Lower Word in B
1000   0A2D 12            mov a, c
1001   0A2E FD AA         swp a
1002   0A30 D7            push a
1003   0A31 FD AB         swp b
1004   0A33 D8            push b
1005   0A34 07 89 15      call print_signed_long
1006   0A37 51 04 00      add sp, 4
1007   0A3A             ; --- END FUNCTION CALL
1008   0A3A 0A C4 0A      jmp _if14_exit
1009   0A3D             _if14_else:
1010   0A3D             ; if(*format_p == 'u') 
1011   0A3D             _if15_cond:
1012   0A3D FA FD FF      lea d, [bp + -3] ; $format_p
1013   0A40 2A            mov b, [d]
1014   0A41 38 00 00      mov c, 0
1015   0A44 74            mov d, b
1016   0A45 32            mov bl, [d]
1017   0A46 A7 00         mov bh, 0
1018   0A48             ; --- START RELATIONAL
1019   0A48 D7            push a
1020   0A49 11            mov a, b
1021   0A4A FD 2E 75 00   mov32 cb, $00000075
1021   0A4E 00 00 
1022   0A50 B0            cmp a, b
1023   0A51 FD 71         seq ; ==
1024   0A53 E4            pop a
1025   0A54             ; --- END RELATIONAL
1026   0A54 C0 00 00      cmp b, 0
1027   0A57 C6 7D 0A      je _if15_else
1028   0A5A             _if15_true:
1029   0A5A             ; print_unsigned_long(*(unsigned long *)p); 
1030   0A5A             ; --- START FUNCTION CALL
1031   0A5A FA FF FF      lea d, [bp + -1] ; $p
1032   0A5D 2A            mov b, [d]
1033   0A5E 38 00 00      mov c, 0
1034   0A61 A7 00         mov bh, 0
1035   0A63 38 00 00      mov c, 0
1036   0A66 74            mov d, b
1037   0A67 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1038   0A6A FD 39         mov c, b ; And place it into C
1039   0A6C 2A            mov b, [d] ; Lower Word in B
1040   0A6D 12            mov a, c
1041   0A6E FD AA         swp a
1042   0A70 D7            push a
1043   0A71 FD AB         swp b
1044   0A73 D8            push b
1045   0A74 07 F9 16      call print_unsigned_long
1046   0A77 51 04 00      add sp, 4
1047   0A7A             ; --- END FUNCTION CALL
1048   0A7A 0A C4 0A      jmp _if15_exit
1049   0A7D             _if15_else:
1050   0A7D             ; if(*format_p == 'x') 
1051   0A7D             _if16_cond:
1052   0A7D FA FD FF      lea d, [bp + -3] ; $format_p
1053   0A80 2A            mov b, [d]
1054   0A81 38 00 00      mov c, 0
1055   0A84 74            mov d, b
1056   0A85 32            mov bl, [d]
1057   0A86 A7 00         mov bh, 0
1058   0A88             ; --- START RELATIONAL
1059   0A88 D7            push a
1060   0A89 11            mov a, b
1061   0A8A FD 2E 78 00   mov32 cb, $00000078
1061   0A8E 00 00 
1062   0A90 B0            cmp a, b
1063   0A91 FD 71         seq ; ==
1064   0A93 E4            pop a
1065   0A94             ; --- END RELATIONAL
1066   0A94 C0 00 00      cmp b, 0
1067   0A97 C6 B8 0A      je _if16_else
1068   0A9A             _if16_true:
1069   0A9A             ; printx32(*(long int *)p); 
1070   0A9A             ; --- START FUNCTION CALL
1071   0A9A FA FF FF      lea d, [bp + -1] ; $p
1072   0A9D 2A            mov b, [d]
1073   0A9E 38 00 00      mov c, 0
1074   0AA1 74            mov d, b
1075   0AA2 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1076   0AA5 FD 39         mov c, b ; And place it into C
1077   0AA7 2A            mov b, [d] ; Lower Word in B
1078   0AA8 12            mov a, c
1079   0AA9 FD AA         swp a
1080   0AAB D7            push a
1081   0AAC FD AB         swp b
1082   0AAE D8            push b
1083   0AAF 07 5C 12      call printx32
1084   0AB2 51 04 00      add sp, 4
1085   0AB5             ; --- END FUNCTION CALL
1086   0AB5 0A C4 0A      jmp _if16_exit
1087   0AB8             _if16_else:
1088   0AB8             ; err("Unexpected format in printf."); 
1089   0AB8             ; --- START FUNCTION CALL
1090   0AB8 26 EE 20      mov b, _s0 ; "Unexpected format in printf."
1091   0ABB FD AB         swp b
1092   0ABD D8            push b
1093   0ABE 07 47 12      call err
1094   0AC1 51 02 00      add sp, 2
1095   0AC4             ; --- END FUNCTION CALL
1096   0AC4             _if16_exit:
1097   0AC4             _if15_exit:
1098   0AC4             _if14_exit:
1099   0AC4             ; p = p + 4; 
1100   0AC4 FA FF FF      lea d, [bp + -1] ; $p
1101   0AC7 DA            push d
1102   0AC8 FA FF FF      lea d, [bp + -1] ; $p
1103   0ACB 2A            mov b, [d]
1104   0ACC 38 00 00      mov c, 0
1105   0ACF             ; --- START TERMS
1106   0ACF D7            push a
1107   0AD0 11            mov a, b
1108   0AD1 FD 2E 04 00   mov32 cb, $00000004
1108   0AD5 00 00 
1109   0AD7 56            add b, a
1110   0AD8 E4            pop a
1111   0AD9             ; --- END TERMS
1112   0AD9 E7            pop d
1113   0ADA FD 43         mov [d], b
1114   0ADC             ; break; 
1115   0ADC 0A B3 0B      jmp _switch13_exit ; case break
1116   0ADF             _switch13_case2:
1117   0ADF             _switch13_case3:
1118   0ADF             ; print_signed(*(int*)p); 
1119   0ADF             ; --- START FUNCTION CALL
1120   0ADF FA FF FF      lea d, [bp + -1] ; $p
1121   0AE2 2A            mov b, [d]
1122   0AE3 38 00 00      mov c, 0
1123   0AE6 74            mov d, b
1124   0AE7 2A            mov b, [d]
1125   0AE8 FD AB         swp b
1126   0AEA D8            push b
1127   0AEB 07 50 14      call print_signed
1128   0AEE 51 02 00      add sp, 2
1129   0AF1             ; --- END FUNCTION CALL
1130   0AF1             ; p = p + 2; 
1131   0AF1 FA FF FF      lea d, [bp + -1] ; $p
1132   0AF4 DA            push d
1133   0AF5 FA FF FF      lea d, [bp + -1] ; $p
1134   0AF8 2A            mov b, [d]
1135   0AF9 38 00 00      mov c, 0
1136   0AFC             ; --- START TERMS
1137   0AFC D7            push a
1138   0AFD 11            mov a, b
1139   0AFE FD 2E 02 00   mov32 cb, $00000002
1139   0B02 00 00 
1140   0B04 56            add b, a
1141   0B05 E4            pop a
1142   0B06             ; --- END TERMS
1143   0B06 E7            pop d
1144   0B07 FD 43         mov [d], b
1145   0B09             ; break; 
1146   0B09 0A B3 0B      jmp _switch13_exit ; case break
1147   0B0C             _switch13_case4:
1148   0B0C             ; print_unsigned(*(unsigned int*)p); 
1149   0B0C             ; --- START FUNCTION CALL
1150   0B0C FA FF FF      lea d, [bp + -1] ; $p
1151   0B0F 2A            mov b, [d]
1152   0B10 38 00 00      mov c, 0
1153   0B13 74            mov d, b
1154   0B14 2A            mov b, [d]
1155   0B15 FD AB         swp b
1156   0B17 D8            push b
1157   0B18 07 73 19      call print_unsigned
1158   0B1B 51 02 00      add sp, 2
1159   0B1E             ; --- END FUNCTION CALL
1160   0B1E             ; p = p + 2; 
1161   0B1E FA FF FF      lea d, [bp + -1] ; $p
1162   0B21 DA            push d
1163   0B22 FA FF FF      lea d, [bp + -1] ; $p
1164   0B25 2A            mov b, [d]
1165   0B26 38 00 00      mov c, 0
1166   0B29             ; --- START TERMS
1167   0B29 D7            push a
1168   0B2A 11            mov a, b
1169   0B2B FD 2E 02 00   mov32 cb, $00000002
1169   0B2F 00 00 
1170   0B31 56            add b, a
1171   0B32 E4            pop a
1172   0B33             ; --- END TERMS
1173   0B33 E7            pop d
1174   0B34 FD 43         mov [d], b
1175   0B36             ; break; 
1176   0B36 0A B3 0B      jmp _switch13_exit ; case break
1177   0B39             _switch13_case5:
1178   0B39             
1179   0B39             ; --- BEGIN INLINE ASM SEGMENT
1180   0B39 FA FF FF      lea d, [bp + -1] ; $p
1181   0B3C FD 2A         mov d, [d]
1182   0B3E 2A            mov b, [d]
1183   0B3F 07 EC 1F      call print_u16x
1184   0B42             ; --- END INLINE ASM SEGMENT
1185   0B42             
1186   0B42             ; p = p + 2; 
1187   0B42 FA FF FF      lea d, [bp + -1] ; $p
1188   0B45 DA            push d
1189   0B46 FA FF FF      lea d, [bp + -1] ; $p
1190   0B49 2A            mov b, [d]
1191   0B4A 38 00 00      mov c, 0
1192   0B4D             ; --- START TERMS
1193   0B4D D7            push a
1194   0B4E 11            mov a, b
1195   0B4F FD 2E 02 00   mov32 cb, $00000002
1195   0B53 00 00 
1196   0B55 56            add b, a
1197   0B56 E4            pop a
1198   0B57             ; --- END TERMS
1199   0B57 E7            pop d
1200   0B58 FD 43         mov [d], b
1201   0B5A             ; break; 
1202   0B5A 0A B3 0B      jmp _switch13_exit ; case break
1203   0B5D             _switch13_case6:
1204   0B5D             
1205   0B5D             ; --- BEGIN INLINE ASM SEGMENT
1206   0B5D FA FF FF      lea d, [bp + -1] ; $p
1207   0B60 FD 2A         mov d, [d]
1208   0B62 1E            mov al, [d]
1209   0B63 23            mov ah, al
1210   0B64 07 4A 1E      call _putchar
1211   0B67             ; --- END INLINE ASM SEGMENT
1212   0B67             
1213   0B67             ; p = p + 1; 
1214   0B67 FA FF FF      lea d, [bp + -1] ; $p
1215   0B6A DA            push d
1216   0B6B FA FF FF      lea d, [bp + -1] ; $p
1217   0B6E 2A            mov b, [d]
1218   0B6F 38 00 00      mov c, 0
1219   0B72             ; --- START TERMS
1220   0B72 D7            push a
1221   0B73 11            mov a, b
1222   0B74 FD 2E 01 00   mov32 cb, $00000001
1222   0B78 00 00 
1223   0B7A 56            add b, a
1224   0B7B E4            pop a
1225   0B7C             ; --- END TERMS
1226   0B7C E7            pop d
1227   0B7D FD 43         mov [d], b
1228   0B7F             ; break; 
1229   0B7F 0A B3 0B      jmp _switch13_exit ; case break
1230   0B82             _switch13_case7:
1231   0B82             
1232   0B82             ; --- BEGIN INLINE ASM SEGMENT
1233   0B82 FA FF FF      lea d, [bp + -1] ; $p
1234   0B85 FD 2A         mov d, [d]
1235   0B87 FD 2A         mov d, [d]
1236   0B89 07 94 1F      call _puts
1237   0B8C             ; --- END INLINE ASM SEGMENT
1238   0B8C             
1239   0B8C             ; p = p + 2; 
1240   0B8C FA FF FF      lea d, [bp + -1] ; $p
1241   0B8F DA            push d
1242   0B90 FA FF FF      lea d, [bp + -1] ; $p
1243   0B93 2A            mov b, [d]
1244   0B94 38 00 00      mov c, 0
1245   0B97             ; --- START TERMS
1246   0B97 D7            push a
1247   0B98 11            mov a, b
1248   0B99 FD 2E 02 00   mov32 cb, $00000002
1248   0B9D 00 00 
1249   0B9F 56            add b, a
1250   0BA0 E4            pop a
1251   0BA1             ; --- END TERMS
1252   0BA1 E7            pop d
1253   0BA2 FD 43         mov [d], b
1254   0BA4             ; break; 
1255   0BA4 0A B3 0B      jmp _switch13_exit ; case break
1256   0BA7             _switch13_default:
1257   0BA7             ; print("Error: Unknown argument type.\n"); 
1258   0BA7             ; --- START FUNCTION CALL
1259   0BA7 26 0B 21      mov b, _s1 ; "Error: Unknown argument type.\n"
1260   0BAA FD AB         swp b
1261   0BAC D8            push b
1262   0BAD 07 89 1C      call print
1263   0BB0 51 02 00      add sp, 2
1264   0BB3             ; --- END FUNCTION CALL
1265   0BB3             _switch13_exit:
1266   0BB3             ; format_p++; 
1267   0BB3 FA FD FF      lea d, [bp + -3] ; $format_p
1268   0BB6 2A            mov b, [d]
1269   0BB7 38 00 00      mov c, 0
1270   0BBA FD 77         inc b
1271   0BBC FA FD FF      lea d, [bp + -3] ; $format_p
1272   0BBF FD 43         mov [d], b
1273   0BC1 FD 7D         dec b
1274   0BC3 0A E8 0B      jmp _if12_exit
1275   0BC6             _if12_else:
1276   0BC6             ; putchar(*format_p); 
1277   0BC6             ; --- START FUNCTION CALL
1278   0BC6 FA FD FF      lea d, [bp + -3] ; $format_p
1279   0BC9 2A            mov b, [d]
1280   0BCA 38 00 00      mov c, 0
1281   0BCD 74            mov d, b
1282   0BCE 32            mov bl, [d]
1283   0BCF A7 00         mov bh, 0
1284   0BD1 DD            push bl
1285   0BD2 07 3B 1C      call putchar
1286   0BD5 51 01 00      add sp, 1
1287   0BD8             ; --- END FUNCTION CALL
1288   0BD8             ; format_p++; 
1289   0BD8 FA FD FF      lea d, [bp + -3] ; $format_p
1290   0BDB 2A            mov b, [d]
1291   0BDC 38 00 00      mov c, 0
1292   0BDF FD 77         inc b
1293   0BE1 FA FD FF      lea d, [bp + -3] ; $format_p
1294   0BE4 FD 43         mov [d], b
1295   0BE6 FD 7D         dec b
1296   0BE8             _if12_exit:
1297   0BE8             _if11_exit:
1298   0BE8             _for10_update:
1299   0BE8 0A 51 09      jmp _for10_cond
1300   0BEB             _for10_exit:
1301   0BEB F9            leave
1302   0BEC 09            ret
1303   0BED             
1304   0BED             scanf:
1305   0BED F8 00 00      enter 0 ; (push bp; mov bp, sp)
1306   0BF0             ; char *p, *format_p; 
1307   0BF0 52 02 00      sub sp, 2
1308   0BF3 52 02 00      sub sp, 2
1309   0BF6             ; char c; 
1310   0BF6 52 01 00      sub sp, 1
1311   0BF9             ; int i; 
1312   0BF9 52 02 00      sub sp, 2
1313   0BFC             ; char input_string[  512                    ]; 
1314   0BFC 52 00 02      sub sp, 512
1315   0BFF             ; format_p = format; 
1316   0BFF FA FD FF      lea d, [bp + -3] ; $format_p
1317   0C02 DA            push d
1318   0C03 FA 05 00      lea d, [bp + 5] ; $format
1319   0C06 2A            mov b, [d]
1320   0C07 38 00 00      mov c, 0
1321   0C0A E7            pop d
1322   0C0B FD 43         mov [d], b
1323   0C0D             ; p = &format + 2; 
1324   0C0D FA FF FF      lea d, [bp + -1] ; $p
1325   0C10 DA            push d
1326   0C11 FA 05 00      lea d, [bp + 5] ; $format
1327   0C14 2D            mov b, d
1328   0C15             ; --- START TERMS
1329   0C15 D7            push a
1330   0C16 11            mov a, b
1331   0C17 FD 2E 02 00   mov32 cb, $00000002
1331   0C1B 00 00 
1332   0C1D 56            add b, a
1333   0C1E E4            pop a
1334   0C1F             ; --- END TERMS
1335   0C1F E7            pop d
1336   0C20 FD 43         mov [d], b
1337   0C22             ; for(;;){ 
1338   0C22             _for17_init:
1339   0C22             _for17_cond:
1340   0C22             _for17_block:
1341   0C22             ; if(!*format_p) break; 
1342   0C22             _if18_cond:
1343   0C22 FA FD FF      lea d, [bp + -3] ; $format_p
1344   0C25 2A            mov b, [d]
1345   0C26 38 00 00      mov c, 0
1346   0C29 74            mov d, b
1347   0C2A 32            mov bl, [d]
1348   0C2B A7 00         mov bh, 0
1349   0C2D C0 00 00      cmp b, 0
1350   0C30 FD 71         seq ; !
1351   0C32 C0 00 00      cmp b, 0
1352   0C35 C6 3E 0C      je _if18_else
1353   0C38             _if18_true:
1354   0C38             ; break; 
1355   0C38 0A AE 0E      jmp _for17_exit ; for break
1356   0C3B 0A AB 0E      jmp _if18_exit
1357   0C3E             _if18_else:
1358   0C3E             ; if(*format_p == '%'){ 
1359   0C3E             _if19_cond:
1360   0C3E FA FD FF      lea d, [bp + -3] ; $format_p
1361   0C41 2A            mov b, [d]
1362   0C42 38 00 00      mov c, 0
1363   0C45 74            mov d, b
1364   0C46 32            mov bl, [d]
1365   0C47 A7 00         mov bh, 0
1366   0C49             ; --- START RELATIONAL
1367   0C49 D7            push a
1368   0C4A 11            mov a, b
1369   0C4B FD 2E 25 00   mov32 cb, $00000025
1369   0C4F 00 00 
1370   0C51 B0            cmp a, b
1371   0C52 FD 71         seq ; ==
1372   0C54 E4            pop a
1373   0C55             ; --- END RELATIONAL
1374   0C55 C0 00 00      cmp b, 0
1375   0C58 C6 89 0E      je _if19_else
1376   0C5B             _if19_true:
1377   0C5B             ; format_p++; 
1378   0C5B FA FD FF      lea d, [bp + -3] ; $format_p
1379   0C5E 2A            mov b, [d]
1380   0C5F 38 00 00      mov c, 0
1381   0C62 FD 77         inc b
1382   0C64 FA FD FF      lea d, [bp + -3] ; $format_p
1383   0C67 FD 43         mov [d], b
1384   0C69 FD 7D         dec b
1385   0C6B             ; switch(*format_p){ 
1386   0C6B             _switch20_expr:
1387   0C6B FA FD FF      lea d, [bp + -3] ; $format_p
1388   0C6E 2A            mov b, [d]
1389   0C6F 38 00 00      mov c, 0
1390   0C72 74            mov d, b
1391   0C73 32            mov bl, [d]
1392   0C74 A7 00         mov bh, 0
1393   0C76             _switch20_comparisons:
1394   0C76 C1 6C         cmp bl, $6c
1395   0C78 C6 A4 0C      je _switch20_case0
1396   0C7B C1 4C         cmp bl, $4c
1397   0C7D C6 A4 0C      je _switch20_case1
1398   0C80 C1 64         cmp bl, $64
1399   0C82 C6 57 0D      je _switch20_case2
1400   0C85 C1 69         cmp bl, $69
1401   0C87 C6 57 0D      je _switch20_case3
1402   0C8A C1 75         cmp bl, $75
1403   0C8C C6 90 0D      je _switch20_case4
1404   0C8F C1 78         cmp bl, $78
1405   0C91 C6 C9 0D      je _switch20_case5
1406   0C94 C1 63         cmp bl, $63
1407   0C96 C6 E4 0D      je _switch20_case6
1408   0C99 C1 73         cmp bl, $73
1409   0C9B C6 23 0E      je _switch20_case7
1410   0C9E 0A 6A 0E      jmp _switch20_default
1411   0CA1 0A 76 0E      jmp _switch20_exit
1412   0CA4             _switch20_case0:
1413   0CA4             _switch20_case1:
1414   0CA4             ; format_p++; 
1415   0CA4 FA FD FF      lea d, [bp + -3] ; $format_p
1416   0CA7 2A            mov b, [d]
1417   0CA8 38 00 00      mov c, 0
1418   0CAB FD 77         inc b
1419   0CAD FA FD FF      lea d, [bp + -3] ; $format_p
1420   0CB0 FD 43         mov [d], b
1421   0CB2 FD 7D         dec b
1422   0CB4             ; if(*format_p == 'd' || *format_p == 'i'); 
1423   0CB4             _if21_cond:
1424   0CB4 FA FD FF      lea d, [bp + -3] ; $format_p
1425   0CB7 2A            mov b, [d]
1426   0CB8 38 00 00      mov c, 0
1427   0CBB 74            mov d, b
1428   0CBC 32            mov bl, [d]
1429   0CBD A7 00         mov bh, 0
1430   0CBF             ; --- START RELATIONAL
1431   0CBF D7            push a
1432   0CC0 11            mov a, b
1433   0CC1 FD 2E 64 00   mov32 cb, $00000064
1433   0CC5 00 00 
1434   0CC7 B0            cmp a, b
1435   0CC8 FD 71         seq ; ==
1436   0CCA E4            pop a
1437   0CCB             ; --- END RELATIONAL
1438   0CCB             ; --- START LOGICAL OR
1439   0CCB D7            push a
1440   0CCC 11            mov a, b
1441   0CCD FA FD FF      lea d, [bp + -3] ; $format_p
1442   0CD0 2A            mov b, [d]
1443   0CD1 38 00 00      mov c, 0
1444   0CD4 74            mov d, b
1445   0CD5 32            mov bl, [d]
1446   0CD6 A7 00         mov bh, 0
1447   0CD8             ; --- START RELATIONAL
1448   0CD8 D7            push a
1449   0CD9 11            mov a, b
1450   0CDA FD 2E 69 00   mov32 cb, $00000069
1450   0CDE 00 00 
1451   0CE0 B0            cmp a, b
1452   0CE1 FD 71         seq ; ==
1453   0CE3 E4            pop a
1454   0CE4             ; --- END RELATIONAL
1455   0CE4 FD A8         sor a, b ; ||
1456   0CE6 E4            pop a
1457   0CE7             ; --- END LOGICAL OR
1458   0CE7 C0 00 00      cmp b, 0
1459   0CEA C6 F0 0C      je _if21_else
1460   0CED             _if21_true:
1461   0CED             ; ; 
1462   0CED 0A 3C 0D      jmp _if21_exit
1463   0CF0             _if21_else:
1464   0CF0             ; if(*format_p == 'u'); 
1465   0CF0             _if22_cond:
1466   0CF0 FA FD FF      lea d, [bp + -3] ; $format_p
1467   0CF3 2A            mov b, [d]
1468   0CF4 38 00 00      mov c, 0
1469   0CF7 74            mov d, b
1470   0CF8 32            mov bl, [d]
1471   0CF9 A7 00         mov bh, 0
1472   0CFB             ; --- START RELATIONAL
1473   0CFB D7            push a
1474   0CFC 11            mov a, b
1475   0CFD FD 2E 75 00   mov32 cb, $00000075
1475   0D01 00 00 
1476   0D03 B0            cmp a, b
1477   0D04 FD 71         seq ; ==
1478   0D06 E4            pop a
1479   0D07             ; --- END RELATIONAL
1480   0D07 C0 00 00      cmp b, 0
1481   0D0A C6 10 0D      je _if22_else
1482   0D0D             _if22_true:
1483   0D0D             ; ; 
1484   0D0D 0A 3C 0D      jmp _if22_exit
1485   0D10             _if22_else:
1486   0D10             ; if(*format_p == 'x'); 
1487   0D10             _if23_cond:
1488   0D10 FA FD FF      lea d, [bp + -3] ; $format_p
1489   0D13 2A            mov b, [d]
1490   0D14 38 00 00      mov c, 0
1491   0D17 74            mov d, b
1492   0D18 32            mov bl, [d]
1493   0D19 A7 00         mov bh, 0
1494   0D1B             ; --- START RELATIONAL
1495   0D1B D7            push a
1496   0D1C 11            mov a, b
1497   0D1D FD 2E 78 00   mov32 cb, $00000078
1497   0D21 00 00 
1498   0D23 B0            cmp a, b
1499   0D24 FD 71         seq ; ==
1500   0D26 E4            pop a
1501   0D27             ; --- END RELATIONAL
1502   0D27 C0 00 00      cmp b, 0
1503   0D2A C6 30 0D      je _if23_else
1504   0D2D             _if23_true:
1505   0D2D             ; ; 
1506   0D2D 0A 3C 0D      jmp _if23_exit
1507   0D30             _if23_else:
1508   0D30             ; err("Unexpected format in printf."); 
1509   0D30             ; --- START FUNCTION CALL
1510   0D30 26 EE 20      mov b, _s0 ; "Unexpected format in printf."
1511   0D33 FD AB         swp b
1512   0D35 D8            push b
1513   0D36 07 47 12      call err
1514   0D39 51 02 00      add sp, 2
1515   0D3C             ; --- END FUNCTION CALL
1516   0D3C             _if23_exit:
1517   0D3C             _if22_exit:
1518   0D3C             _if21_exit:
1519   0D3C             ; p = p + 4; 
1520   0D3C FA FF FF      lea d, [bp + -1] ; $p
1521   0D3F DA            push d
1522   0D40 FA FF FF      lea d, [bp + -1] ; $p
1523   0D43 2A            mov b, [d]
1524   0D44 38 00 00      mov c, 0
1525   0D47             ; --- START TERMS
1526   0D47 D7            push a
1527   0D48 11            mov a, b
1528   0D49 FD 2E 04 00   mov32 cb, $00000004
1528   0D4D 00 00 
1529   0D4F 56            add b, a
1530   0D50 E4            pop a
1531   0D51             ; --- END TERMS
1532   0D51 E7            pop d
1533   0D52 FD 43         mov [d], b
1534   0D54             ; break; 
1535   0D54 0A 76 0E      jmp _switch20_exit ; case break
1536   0D57             _switch20_case2:
1537   0D57             _switch20_case3:
1538   0D57             ; i = scann(); 
1539   0D57 FA FA FF      lea d, [bp + -6] ; $i
1540   0D5A DA            push d
1541   0D5B             ; --- START FUNCTION CALL
1542   0D5B 07 61 1C      call scann
1543   0D5E E7            pop d
1544   0D5F FD 43         mov [d], b
1545   0D61             ; **(int **)p = i; 
1546   0D61 FA FF FF      lea d, [bp + -1] ; $p
1547   0D64 2A            mov b, [d]
1548   0D65 38 00 00      mov c, 0
1549   0D68 74            mov d, b
1550   0D69 2A            mov b, [d]
1551   0D6A D8            push b
1552   0D6B FA FA FF      lea d, [bp + -6] ; $i
1553   0D6E 2A            mov b, [d]
1554   0D6F 38 00 00      mov c, 0
1555   0D72 E7            pop d
1556   0D73 FD 43         mov [d], b
1557   0D75             ; p = p + 2; 
1558   0D75 FA FF FF      lea d, [bp + -1] ; $p
1559   0D78 DA            push d
1560   0D79 FA FF FF      lea d, [bp + -1] ; $p
1561   0D7C 2A            mov b, [d]
1562   0D7D 38 00 00      mov c, 0
1563   0D80             ; --- START TERMS
1564   0D80 D7            push a
1565   0D81 11            mov a, b
1566   0D82 FD 2E 02 00   mov32 cb, $00000002
1566   0D86 00 00 
1567   0D88 56            add b, a
1568   0D89 E4            pop a
1569   0D8A             ; --- END TERMS
1570   0D8A E7            pop d
1571   0D8B FD 43         mov [d], b
1572   0D8D             ; break; 
1573   0D8D 0A 76 0E      jmp _switch20_exit ; case break
1574   0D90             _switch20_case4:
1575   0D90             ; i = scann(); 
1576   0D90 FA FA FF      lea d, [bp + -6] ; $i
1577   0D93 DA            push d
1578   0D94             ; --- START FUNCTION CALL
1579   0D94 07 61 1C      call scann
1580   0D97 E7            pop d
1581   0D98 FD 43         mov [d], b
1582   0D9A             ; **(int **)p = i; 
1583   0D9A FA FF FF      lea d, [bp + -1] ; $p
1584   0D9D 2A            mov b, [d]
1585   0D9E 38 00 00      mov c, 0
1586   0DA1 74            mov d, b
1587   0DA2 2A            mov b, [d]
1588   0DA3 D8            push b
1589   0DA4 FA FA FF      lea d, [bp + -6] ; $i
1590   0DA7 2A            mov b, [d]
1591   0DA8 38 00 00      mov c, 0
1592   0DAB E7            pop d
1593   0DAC FD 43         mov [d], b
1594   0DAE             ; p = p + 2; 
1595   0DAE FA FF FF      lea d, [bp + -1] ; $p
1596   0DB1 DA            push d
1597   0DB2 FA FF FF      lea d, [bp + -1] ; $p
1598   0DB5 2A            mov b, [d]
1599   0DB6 38 00 00      mov c, 0
1600   0DB9             ; --- START TERMS
1601   0DB9 D7            push a
1602   0DBA 11            mov a, b
1603   0DBB FD 2E 02 00   mov32 cb, $00000002
1603   0DBF 00 00 
1604   0DC1 56            add b, a
1605   0DC2 E4            pop a
1606   0DC3             ; --- END TERMS
1607   0DC3 E7            pop d
1608   0DC4 FD 43         mov [d], b
1609   0DC6             ; break; 
1610   0DC6 0A 76 0E      jmp _switch20_exit ; case break
1611   0DC9             _switch20_case5:
1612   0DC9             ; p = p + 2; 
1613   0DC9 FA FF FF      lea d, [bp + -1] ; $p
1614   0DCC DA            push d
1615   0DCD FA FF FF      lea d, [bp + -1] ; $p
1616   0DD0 2A            mov b, [d]
1617   0DD1 38 00 00      mov c, 0
1618   0DD4             ; --- START TERMS
1619   0DD4 D7            push a
1620   0DD5 11            mov a, b
1621   0DD6 FD 2E 02 00   mov32 cb, $00000002
1621   0DDA 00 00 
1622   0DDC 56            add b, a
1623   0DDD E4            pop a
1624   0DDE             ; --- END TERMS
1625   0DDE E7            pop d
1626   0DDF FD 43         mov [d], b
1627   0DE1             ; break; 
1628   0DE1 0A 76 0E      jmp _switch20_exit ; case break
1629   0DE4             _switch20_case6:
1630   0DE4             ; c = getchar(); 
1631   0DE4 FA FC FF      lea d, [bp + -4] ; $c
1632   0DE7 DA            push d
1633   0DE8             ; --- START FUNCTION CALL
1634   0DE8 07 48 1C      call getchar
1635   0DEB E7            pop d
1636   0DEC FD 3E         mov [d], bl
1637   0DEE             ; **(char **)p = *(char *)c; 
1638   0DEE FA FF FF      lea d, [bp + -1] ; $p
1639   0DF1 2A            mov b, [d]
1640   0DF2 38 00 00      mov c, 0
1641   0DF5 74            mov d, b
1642   0DF6 2A            mov b, [d]
1643   0DF7 D8            push b
1644   0DF8 FA FC FF      lea d, [bp + -4] ; $c
1645   0DFB 32            mov bl, [d]
1646   0DFC A7 00         mov bh, 0
1647   0DFE 38 00 00      mov c, 0
1648   0E01 74            mov d, b
1649   0E02 32            mov bl, [d]
1650   0E03 A7 00         mov bh, 0
1651   0E05 E7            pop d
1652   0E06 FD 43         mov [d], b
1653   0E08             ; p = p + 1; 
1654   0E08 FA FF FF      lea d, [bp + -1] ; $p
1655   0E0B DA            push d
1656   0E0C FA FF FF      lea d, [bp + -1] ; $p
1657   0E0F 2A            mov b, [d]
1658   0E10 38 00 00      mov c, 0
1659   0E13             ; --- START TERMS
1660   0E13 D7            push a
1661   0E14 11            mov a, b
1662   0E15 FD 2E 01 00   mov32 cb, $00000001
1662   0E19 00 00 
1663   0E1B 56            add b, a
1664   0E1C E4            pop a
1665   0E1D             ; --- END TERMS
1666   0E1D E7            pop d
1667   0E1E FD 43         mov [d], b
1668   0E20             ; break; 
1669   0E20 0A 76 0E      jmp _switch20_exit ; case break
1670   0E23             _switch20_case7:
1671   0E23             ; gets(input_string); 
1672   0E23             ; --- START FUNCTION CALL
1673   0E23 FA FA FD      lea d, [bp + -518] ; $input_string
1674   0E26 2D            mov b, d
1675   0E27 38 00 00      mov c, 0
1676   0E2A FD AB         swp b
1677   0E2C D8            push b
1678   0E2D 07 33 14      call gets
1679   0E30 51 02 00      add sp, 2
1680   0E33             ; --- END FUNCTION CALL
1681   0E33             ; strcpy(*(char **)p, input_string); 
1682   0E33             ; --- START FUNCTION CALL
1683   0E33 FA FA FD      lea d, [bp + -518] ; $input_string
1684   0E36 2D            mov b, d
1685   0E37 38 00 00      mov c, 0
1686   0E3A FD AB         swp b
1687   0E3C D8            push b
1688   0E3D FA FF FF      lea d, [bp + -1] ; $p
1689   0E40 2A            mov b, [d]
1690   0E41 38 00 00      mov c, 0
1691   0E44 74            mov d, b
1692   0E45 2A            mov b, [d]
1693   0E46 FD AB         swp b
1694   0E48 D8            push b
1695   0E49 07 24 04      call strcpy
1696   0E4C 51 04 00      add sp, 4
1697   0E4F             ; --- END FUNCTION CALL
1698   0E4F             ; p = p + 2; 
1699   0E4F FA FF FF      lea d, [bp + -1] ; $p
1700   0E52 DA            push d
1701   0E53 FA FF FF      lea d, [bp + -1] ; $p
1702   0E56 2A            mov b, [d]
1703   0E57 38 00 00      mov c, 0
1704   0E5A             ; --- START TERMS
1705   0E5A D7            push a
1706   0E5B 11            mov a, b
1707   0E5C FD 2E 02 00   mov32 cb, $00000002
1707   0E60 00 00 
1708   0E62 56            add b, a
1709   0E63 E4            pop a
1710   0E64             ; --- END TERMS
1711   0E64 E7            pop d
1712   0E65 FD 43         mov [d], b
1713   0E67             ; break; 
1714   0E67 0A 76 0E      jmp _switch20_exit ; case break
1715   0E6A             _switch20_default:
1716   0E6A             ; print("Error: Unknown argument type.\n"); 
1717   0E6A             ; --- START FUNCTION CALL
1718   0E6A 26 0B 21      mov b, _s1 ; "Error: Unknown argument type.\n"
1719   0E6D FD AB         swp b
1720   0E6F D8            push b
1721   0E70 07 89 1C      call print
1722   0E73 51 02 00      add sp, 2
1723   0E76             ; --- END FUNCTION CALL
1724   0E76             _switch20_exit:
1725   0E76             ; format_p++; 
1726   0E76 FA FD FF      lea d, [bp + -3] ; $format_p
1727   0E79 2A            mov b, [d]
1728   0E7A 38 00 00      mov c, 0
1729   0E7D FD 77         inc b
1730   0E7F FA FD FF      lea d, [bp + -3] ; $format_p
1731   0E82 FD 43         mov [d], b
1732   0E84 FD 7D         dec b
1733   0E86 0A AB 0E      jmp _if19_exit
1734   0E89             _if19_else:
1735   0E89             ; putchar(*format_p); 
1736   0E89             ; --- START FUNCTION CALL
1737   0E89 FA FD FF      lea d, [bp + -3] ; $format_p
1738   0E8C 2A            mov b, [d]
1739   0E8D 38 00 00      mov c, 0
1740   0E90 74            mov d, b
1741   0E91 32            mov bl, [d]
1742   0E92 A7 00         mov bh, 0
1743   0E94 DD            push bl
1744   0E95 07 3B 1C      call putchar
1745   0E98 51 01 00      add sp, 1
1746   0E9B             ; --- END FUNCTION CALL
1747   0E9B             ; format_p++; 
1748   0E9B FA FD FF      lea d, [bp + -3] ; $format_p
1749   0E9E 2A            mov b, [d]
1750   0E9F 38 00 00      mov c, 0
1751   0EA2 FD 77         inc b
1752   0EA4 FA FD FF      lea d, [bp + -3] ; $format_p
1753   0EA7 FD 43         mov [d], b
1754   0EA9 FD 7D         dec b
1755   0EAB             _if19_exit:
1756   0EAB             _if18_exit:
1757   0EAB             _for17_update:
1758   0EAB 0A 22 0C      jmp _for17_cond
1759   0EAE             _for17_exit:
1760   0EAE F9            leave
1761   0EAF 09            ret
1762   0EB0             
1763   0EB0             sprintf:
1764   0EB0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1765   0EB3             ; char *p, *format_p; 
1766   0EB3 52 02 00      sub sp, 2
1767   0EB6 52 02 00      sub sp, 2
1768   0EB9             ; char *sp; 
1769   0EB9 52 02 00      sub sp, 2
1770   0EBC             ; sp = dest; 
1771   0EBC FA FB FF      lea d, [bp + -5] ; $sp
1772   0EBF DA            push d
1773   0EC0 FA 05 00      lea d, [bp + 5] ; $dest
1774   0EC3 2A            mov b, [d]
1775   0EC4 38 00 00      mov c, 0
1776   0EC7 E7            pop d
1777   0EC8 FD 43         mov [d], b
1778   0ECA             ; format_p = format; 
1779   0ECA FA FD FF      lea d, [bp + -3] ; $format_p
1780   0ECD DA            push d
1781   0ECE FA 07 00      lea d, [bp + 7] ; $format
1782   0ED1 2A            mov b, [d]
1783   0ED2 38 00 00      mov c, 0
1784   0ED5 E7            pop d
1785   0ED6 FD 43         mov [d], b
1786   0ED8             ; p = &format + 2; 
1787   0ED8 FA FF FF      lea d, [bp + -1] ; $p
1788   0EDB DA            push d
1789   0EDC FA 07 00      lea d, [bp + 7] ; $format
1790   0EDF 2D            mov b, d
1791   0EE0             ; --- START TERMS
1792   0EE0 D7            push a
1793   0EE1 11            mov a, b
1794   0EE2 FD 2E 02 00   mov32 cb, $00000002
1794   0EE6 00 00 
1795   0EE8 56            add b, a
1796   0EE9 E4            pop a
1797   0EEA             ; --- END TERMS
1798   0EEA E7            pop d
1799   0EEB FD 43         mov [d], b
1800   0EED             ; for(;;){ 
1801   0EED             _for24_init:
1802   0EED             _for24_cond:
1803   0EED             _for24_block:
1804   0EED             ; if(!*format_p) break; 
1805   0EED             _if25_cond:
1806   0EED FA FD FF      lea d, [bp + -3] ; $format_p
1807   0EF0 2A            mov b, [d]
1808   0EF1 38 00 00      mov c, 0
1809   0EF4 74            mov d, b
1810   0EF5 32            mov bl, [d]
1811   0EF6 A7 00         mov bh, 0
1812   0EF8 C0 00 00      cmp b, 0
1813   0EFB FD 71         seq ; !
1814   0EFD C0 00 00      cmp b, 0
1815   0F00 C6 09 0F      je _if25_else
1816   0F03             _if25_true:
1817   0F03             ; break; 
1818   0F03 0A 21 12      jmp _for24_exit ; for break
1819   0F06 0A 1E 12      jmp _if25_exit
1820   0F09             _if25_else:
1821   0F09             ; if(*format_p == '%'){ 
1822   0F09             _if26_cond:
1823   0F09 FA FD FF      lea d, [bp + -3] ; $format_p
1824   0F0C 2A            mov b, [d]
1825   0F0D 38 00 00      mov c, 0
1826   0F10 74            mov d, b
1827   0F11 32            mov bl, [d]
1828   0F12 A7 00         mov bh, 0
1829   0F14             ; --- START RELATIONAL
1830   0F14 D7            push a
1831   0F15 11            mov a, b
1832   0F16 FD 2E 25 00   mov32 cb, $00000025
1832   0F1A 00 00 
1833   0F1C B0            cmp a, b
1834   0F1D FD 71         seq ; ==
1835   0F1F E4            pop a
1836   0F20             ; --- END RELATIONAL
1837   0F20 C0 00 00      cmp b, 0
1838   0F23 C6 F6 11      je _if26_else
1839   0F26             _if26_true:
1840   0F26             ; format_p++; 
1841   0F26 FA FD FF      lea d, [bp + -3] ; $format_p
1842   0F29 2A            mov b, [d]
1843   0F2A 38 00 00      mov c, 0
1844   0F2D FD 77         inc b
1845   0F2F FA FD FF      lea d, [bp + -3] ; $format_p
1846   0F32 FD 43         mov [d], b
1847   0F34 FD 7D         dec b
1848   0F36             ; switch(*format_p){ 
1849   0F36             _switch27_expr:
1850   0F36 FA FD FF      lea d, [bp + -3] ; $format_p
1851   0F39 2A            mov b, [d]
1852   0F3A 38 00 00      mov c, 0
1853   0F3D 74            mov d, b
1854   0F3E 32            mov bl, [d]
1855   0F3F A7 00         mov bh, 0
1856   0F41             _switch27_comparisons:
1857   0F41 C1 6C         cmp bl, $6c
1858   0F43 C6 6F 0F      je _switch27_case0
1859   0F46 C1 4C         cmp bl, $4c
1860   0F48 C6 6F 0F      je _switch27_case1
1861   0F4B C1 64         cmp bl, $64
1862   0F4D C6 7B 10      je _switch27_case2
1863   0F50 C1 69         cmp bl, $69
1864   0F52 C6 7B 10      je _switch27_case3
1865   0F55 C1 75         cmp bl, $75
1866   0F57 C6 C4 10      je _switch27_case4
1867   0F5A C1 78         cmp bl, $78
1868   0F5C C6 0D 11      je _switch27_case5
1869   0F5F C1 63         cmp bl, $63
1870   0F61 C6 31 11      je _switch27_case6
1871   0F64 C1 73         cmp bl, $73
1872   0F66 C6 6B 11      je _switch27_case7
1873   0F69 0A D7 11      jmp _switch27_default
1874   0F6C 0A E3 11      jmp _switch27_exit
1875   0F6F             _switch27_case0:
1876   0F6F             _switch27_case1:
1877   0F6F             ; format_p++; 
1878   0F6F FA FD FF      lea d, [bp + -3] ; $format_p
1879   0F72 2A            mov b, [d]
1880   0F73 38 00 00      mov c, 0
1881   0F76 FD 77         inc b
1882   0F78 FA FD FF      lea d, [bp + -3] ; $format_p
1883   0F7B FD 43         mov [d], b
1884   0F7D FD 7D         dec b
1885   0F7F             ; if(*format_p == 'd' || *format_p == 'i') 
1886   0F7F             _if28_cond:
1887   0F7F FA FD FF      lea d, [bp + -3] ; $format_p
1888   0F82 2A            mov b, [d]
1889   0F83 38 00 00      mov c, 0
1890   0F86 74            mov d, b
1891   0F87 32            mov bl, [d]
1892   0F88 A7 00         mov bh, 0
1893   0F8A             ; --- START RELATIONAL
1894   0F8A D7            push a
1895   0F8B 11            mov a, b
1896   0F8C FD 2E 64 00   mov32 cb, $00000064
1896   0F90 00 00 
1897   0F92 B0            cmp a, b
1898   0F93 FD 71         seq ; ==
1899   0F95 E4            pop a
1900   0F96             ; --- END RELATIONAL
1901   0F96             ; --- START LOGICAL OR
1902   0F96 D7            push a
1903   0F97 11            mov a, b
1904   0F98 FA FD FF      lea d, [bp + -3] ; $format_p
1905   0F9B 2A            mov b, [d]
1906   0F9C 38 00 00      mov c, 0
1907   0F9F 74            mov d, b
1908   0FA0 32            mov bl, [d]
1909   0FA1 A7 00         mov bh, 0
1910   0FA3             ; --- START RELATIONAL
1911   0FA3 D7            push a
1912   0FA4 11            mov a, b
1913   0FA5 FD 2E 69 00   mov32 cb, $00000069
1913   0FA9 00 00 
1914   0FAB B0            cmp a, b
1915   0FAC FD 71         seq ; ==
1916   0FAE E4            pop a
1917   0FAF             ; --- END RELATIONAL
1918   0FAF FD A8         sor a, b ; ||
1919   0FB1 E4            pop a
1920   0FB2             ; --- END LOGICAL OR
1921   0FB2 C0 00 00      cmp b, 0
1922   0FB5 C6 D9 0F      je _if28_else
1923   0FB8             _if28_true:
1924   0FB8             ; print_signed_long(*(long *)p); 
1925   0FB8             ; --- START FUNCTION CALL
1926   0FB8 FA FF FF      lea d, [bp + -1] ; $p
1927   0FBB 2A            mov b, [d]
1928   0FBC 38 00 00      mov c, 0
1929   0FBF AB            snex b
1930   0FC0 FD 39         mov c, b
1931   0FC2 74            mov d, b
1932   0FC3 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1933   0FC6 FD 39         mov c, b ; And place it into C
1934   0FC8 2A            mov b, [d] ; Lower Word in B
1935   0FC9 12            mov a, c
1936   0FCA FD AA         swp a
1937   0FCC D7            push a
1938   0FCD FD AB         swp b
1939   0FCF D8            push b
1940   0FD0 07 89 15      call print_signed_long
1941   0FD3 51 04 00      add sp, 4
1942   0FD6             ; --- END FUNCTION CALL
1943   0FD6 0A 60 10      jmp _if28_exit
1944   0FD9             _if28_else:
1945   0FD9             ; if(*format_p == 'u') 
1946   0FD9             _if29_cond:
1947   0FD9 FA FD FF      lea d, [bp + -3] ; $format_p
1948   0FDC 2A            mov b, [d]
1949   0FDD 38 00 00      mov c, 0
1950   0FE0 74            mov d, b
1951   0FE1 32            mov bl, [d]
1952   0FE2 A7 00         mov bh, 0
1953   0FE4             ; --- START RELATIONAL
1954   0FE4 D7            push a
1955   0FE5 11            mov a, b
1956   0FE6 FD 2E 75 00   mov32 cb, $00000075
1956   0FEA 00 00 
1957   0FEC B0            cmp a, b
1958   0FED FD 71         seq ; ==
1959   0FEF E4            pop a
1960   0FF0             ; --- END RELATIONAL
1961   0FF0 C0 00 00      cmp b, 0
1962   0FF3 C6 19 10      je _if29_else
1963   0FF6             _if29_true:
1964   0FF6             ; print_unsigned_long(*(unsigned long *)p); 
1965   0FF6             ; --- START FUNCTION CALL
1966   0FF6 FA FF FF      lea d, [bp + -1] ; $p
1967   0FF9 2A            mov b, [d]
1968   0FFA 38 00 00      mov c, 0
1969   0FFD A7 00         mov bh, 0
1970   0FFF 38 00 00      mov c, 0
1971   1002 74            mov d, b
1972   1003 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1973   1006 FD 39         mov c, b ; And place it into C
1974   1008 2A            mov b, [d] ; Lower Word in B
1975   1009 12            mov a, c
1976   100A FD AA         swp a
1977   100C D7            push a
1978   100D FD AB         swp b
1979   100F D8            push b
1980   1010 07 F9 16      call print_unsigned_long
1981   1013 51 04 00      add sp, 4
1982   1016             ; --- END FUNCTION CALL
1983   1016 0A 60 10      jmp _if29_exit
1984   1019             _if29_else:
1985   1019             ; if(*format_p == 'x') 
1986   1019             _if30_cond:
1987   1019 FA FD FF      lea d, [bp + -3] ; $format_p
1988   101C 2A            mov b, [d]
1989   101D 38 00 00      mov c, 0
1990   1020 74            mov d, b
1991   1021 32            mov bl, [d]
1992   1022 A7 00         mov bh, 0
1993   1024             ; --- START RELATIONAL
1994   1024 D7            push a
1995   1025 11            mov a, b
1996   1026 FD 2E 78 00   mov32 cb, $00000078
1996   102A 00 00 
1997   102C B0            cmp a, b
1998   102D FD 71         seq ; ==
1999   102F E4            pop a
2000   1030             ; --- END RELATIONAL
2001   1030 C0 00 00      cmp b, 0
2002   1033 C6 54 10      je _if30_else
2003   1036             _if30_true:
2004   1036             ; printx32(*(long int *)p); 
2005   1036             ; --- START FUNCTION CALL
2006   1036 FA FF FF      lea d, [bp + -1] ; $p
2007   1039 2A            mov b, [d]
2008   103A 38 00 00      mov c, 0
2009   103D 74            mov d, b
2010   103E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2011   1041 FD 39         mov c, b ; And place it into C
2012   1043 2A            mov b, [d] ; Lower Word in B
2013   1044 12            mov a, c
2014   1045 FD AA         swp a
2015   1047 D7            push a
2016   1048 FD AB         swp b
2017   104A D8            push b
2018   104B 07 5C 12      call printx32
2019   104E 51 04 00      add sp, 4
2020   1051             ; --- END FUNCTION CALL
2021   1051 0A 60 10      jmp _if30_exit
2022   1054             _if30_else:
2023   1054             ; err("Unexpected format in printf."); 
2024   1054             ; --- START FUNCTION CALL
2025   1054 26 EE 20      mov b, _s0 ; "Unexpected format in printf."
2026   1057 FD AB         swp b
2027   1059 D8            push b
2028   105A 07 47 12      call err
2029   105D 51 02 00      add sp, 2
2030   1060             ; --- END FUNCTION CALL
2031   1060             _if30_exit:
2032   1060             _if29_exit:
2033   1060             _if28_exit:
2034   1060             ; p = p + 4; 
2035   1060 FA FF FF      lea d, [bp + -1] ; $p
2036   1063 DA            push d
2037   1064 FA FF FF      lea d, [bp + -1] ; $p
2038   1067 2A            mov b, [d]
2039   1068 38 00 00      mov c, 0
2040   106B             ; --- START TERMS
2041   106B D7            push a
2042   106C 11            mov a, b
2043   106D FD 2E 04 00   mov32 cb, $00000004
2043   1071 00 00 
2044   1073 56            add b, a
2045   1074 E4            pop a
2046   1075             ; --- END TERMS
2047   1075 E7            pop d
2048   1076 FD 43         mov [d], b
2049   1078             ; break; 
2050   1078 0A E3 11      jmp _switch27_exit ; case break
2051   107B             _switch27_case2:
2052   107B             _switch27_case3:
2053   107B             ; sp = sp + sprint_signed(sp, *(int*)p); 
2054   107B FA FB FF      lea d, [bp + -5] ; $sp
2055   107E DA            push d
2056   107F FA FB FF      lea d, [bp + -5] ; $sp
2057   1082 2A            mov b, [d]
2058   1083 38 00 00      mov c, 0
2059   1086             ; --- START TERMS
2060   1086 D7            push a
2061   1087 11            mov a, b
2062   1088             ; --- START FUNCTION CALL
2063   1088 FA FF FF      lea d, [bp + -1] ; $p
2064   108B 2A            mov b, [d]
2065   108C 38 00 00      mov c, 0
2066   108F 74            mov d, b
2067   1090 2A            mov b, [d]
2068   1091 FD AB         swp b
2069   1093 D8            push b
2070   1094 FA FB FF      lea d, [bp + -5] ; $sp
2071   1097 2A            mov b, [d]
2072   1098 38 00 00      mov c, 0
2073   109B FD AB         swp b
2074   109D D8            push b
2075   109E 07 73 1A      call sprint_signed
2076   10A1 51 04 00      add sp, 4
2077   10A4             ; --- END FUNCTION CALL
2078   10A4 56            add b, a
2079   10A5 E4            pop a
2080   10A6             ; --- END TERMS
2081   10A6 E7            pop d
2082   10A7 FD 43         mov [d], b
2083   10A9             ; p = p + 2; 
2084   10A9 FA FF FF      lea d, [bp + -1] ; $p
2085   10AC DA            push d
2086   10AD FA FF FF      lea d, [bp + -1] ; $p
2087   10B0 2A            mov b, [d]
2088   10B1 38 00 00      mov c, 0
2089   10B4             ; --- START TERMS
2090   10B4 D7            push a
2091   10B5 11            mov a, b
2092   10B6 FD 2E 02 00   mov32 cb, $00000002
2092   10BA 00 00 
2093   10BC 56            add b, a
2094   10BD E4            pop a
2095   10BE             ; --- END TERMS
2096   10BE E7            pop d
2097   10BF FD 43         mov [d], b
2098   10C1             ; break; 
2099   10C1 0A E3 11      jmp _switch27_exit ; case break
2100   10C4             _switch27_case4:
2101   10C4             ; sp = sp + sprint_unsigned(sp, *(unsigned int*)p); 
2102   10C4 FA FB FF      lea d, [bp + -5] ; $sp
2103   10C7 DA            push d
2104   10C8 FA FB FF      lea d, [bp + -5] ; $sp
2105   10CB 2A            mov b, [d]
2106   10CC 38 00 00      mov c, 0
2107   10CF             ; --- START TERMS
2108   10CF D7            push a
2109   10D0 11            mov a, b
2110   10D1             ; --- START FUNCTION CALL
2111   10D1 FA FF FF      lea d, [bp + -1] ; $p
2112   10D4 2A            mov b, [d]
2113   10D5 38 00 00      mov c, 0
2114   10D8 74            mov d, b
2115   10D9 2A            mov b, [d]
2116   10DA FD AB         swp b
2117   10DC D8            push b
2118   10DD FA FB FF      lea d, [bp + -5] ; $sp
2119   10E0 2A            mov b, [d]
2120   10E1 38 00 00      mov c, 0
2121   10E4 FD AB         swp b
2122   10E6 D8            push b
2123   10E7 07 1B 18      call sprint_unsigned
2124   10EA 51 04 00      add sp, 4
2125   10ED             ; --- END FUNCTION CALL
2126   10ED 56            add b, a
2127   10EE E4            pop a
2128   10EF             ; --- END TERMS
2129   10EF E7            pop d
2130   10F0 FD 43         mov [d], b
2131   10F2             ; p = p + 2; 
2132   10F2 FA FF FF      lea d, [bp + -1] ; $p
2133   10F5 DA            push d
2134   10F6 FA FF FF      lea d, [bp + -1] ; $p
2135   10F9 2A            mov b, [d]
2136   10FA 38 00 00      mov c, 0
2137   10FD             ; --- START TERMS
2138   10FD D7            push a
2139   10FE 11            mov a, b
2140   10FF FD 2E 02 00   mov32 cb, $00000002
2140   1103 00 00 
2141   1105 56            add b, a
2142   1106 E4            pop a
2143   1107             ; --- END TERMS
2144   1107 E7            pop d
2145   1108 FD 43         mov [d], b
2146   110A             ; break; 
2147   110A 0A E3 11      jmp _switch27_exit ; case break
2148   110D             _switch27_case5:
2149   110D             
2150   110D             ; --- BEGIN INLINE ASM SEGMENT
2151   110D FA FF FF      lea d, [bp + -1] ; $p
2152   1110 FD 2A         mov d, [d]
2153   1112 2A            mov b, [d]
2154   1113 07 EC 1F      call print_u16x
2155   1116             ; --- END INLINE ASM SEGMENT
2156   1116             
2157   1116             ; p = p + 2; 
2158   1116 FA FF FF      lea d, [bp + -1] ; $p
2159   1119 DA            push d
2160   111A FA FF FF      lea d, [bp + -1] ; $p
2161   111D 2A            mov b, [d]
2162   111E 38 00 00      mov c, 0
2163   1121             ; --- START TERMS
2164   1121 D7            push a
2165   1122 11            mov a, b
2166   1123 FD 2E 02 00   mov32 cb, $00000002
2166   1127 00 00 
2167   1129 56            add b, a
2168   112A E4            pop a
2169   112B             ; --- END TERMS
2170   112B E7            pop d
2171   112C FD 43         mov [d], b
2172   112E             ; break; 
2173   112E 0A E3 11      jmp _switch27_exit ; case break
2174   1131             _switch27_case6:
2175   1131             ; *sp++ = *(char *)p; 
2176   1131 FA FB FF      lea d, [bp + -5] ; $sp
2177   1134 2A            mov b, [d]
2178   1135 38 00 00      mov c, 0
2179   1138 FD 77         inc b
2180   113A FA FB FF      lea d, [bp + -5] ; $sp
2181   113D FD 43         mov [d], b
2182   113F FD 7D         dec b
2183   1141 D8            push b
2184   1142 FA FF FF      lea d, [bp + -1] ; $p
2185   1145 2A            mov b, [d]
2186   1146 38 00 00      mov c, 0
2187   1149 74            mov d, b
2188   114A 32            mov bl, [d]
2189   114B A7 00         mov bh, 0
2190   114D E7            pop d
2191   114E FD 3E         mov [d], bl
2192   1150             ; p = p + 1; 
2193   1150 FA FF FF      lea d, [bp + -1] ; $p
2194   1153 DA            push d
2195   1154 FA FF FF      lea d, [bp + -1] ; $p
2196   1157 2A            mov b, [d]
2197   1158 38 00 00      mov c, 0
2198   115B             ; --- START TERMS
2199   115B D7            push a
2200   115C 11            mov a, b
2201   115D FD 2E 01 00   mov32 cb, $00000001
2201   1161 00 00 
2202   1163 56            add b, a
2203   1164 E4            pop a
2204   1165             ; --- END TERMS
2205   1165 E7            pop d
2206   1166 FD 43         mov [d], b
2207   1168             ; break; 
2208   1168 0A E3 11      jmp _switch27_exit ; case break
2209   116B             _switch27_case7:
2210   116B             ; int len = strlen(*(char **)p); 
2211   116B 52 02 00      sub sp, 2
2212   116E             ; --- START LOCAL VAR INITIALIZATION
2213   116E FA F9 FF      lea d, [bp + -7] ; $len
2214   1171 DA            push d
2215   1172             ; --- START FUNCTION CALL
2216   1172 FA FF FF      lea d, [bp + -1] ; $p
2217   1175 2A            mov b, [d]
2218   1176 38 00 00      mov c, 0
2219   1179 74            mov d, b
2220   117A 2A            mov b, [d]
2221   117B FD AB         swp b
2222   117D D8            push b
2223   117E 07 F5 05      call strlen
2224   1181 51 02 00      add sp, 2
2225   1184             ; --- END FUNCTION CALL
2226   1184 E7            pop d
2227   1185 FD 43         mov [d], b
2228   1187             ; --- END LOCAL VAR INITIALIZATION
2229   1187             ; strcpy(sp, *(char **)p); 
2230   1187             ; --- START FUNCTION CALL
2231   1187 FA FF FF      lea d, [bp + -1] ; $p
2232   118A 2A            mov b, [d]
2233   118B 38 00 00      mov c, 0
2234   118E 74            mov d, b
2235   118F 2A            mov b, [d]
2236   1190 FD AB         swp b
2237   1192 D8            push b
2238   1193 FA FB FF      lea d, [bp + -5] ; $sp
2239   1196 2A            mov b, [d]
2240   1197 38 00 00      mov c, 0
2241   119A FD AB         swp b
2242   119C D8            push b
2243   119D 07 24 04      call strcpy
2244   11A0 51 04 00      add sp, 4
2245   11A3             ; --- END FUNCTION CALL
2246   11A3             ; sp = sp + len; 
2247   11A3 FA FB FF      lea d, [bp + -5] ; $sp
2248   11A6 DA            push d
2249   11A7 FA FB FF      lea d, [bp + -5] ; $sp
2250   11AA 2A            mov b, [d]
2251   11AB 38 00 00      mov c, 0
2252   11AE             ; --- START TERMS
2253   11AE D7            push a
2254   11AF 11            mov a, b
2255   11B0 FA F9 FF      lea d, [bp + -7] ; $len
2256   11B3 2A            mov b, [d]
2257   11B4 38 00 00      mov c, 0
2258   11B7 56            add b, a
2259   11B8 E4            pop a
2260   11B9             ; --- END TERMS
2261   11B9 E7            pop d
2262   11BA FD 43         mov [d], b
2263   11BC             ; p = p + 2; 
2264   11BC FA FF FF      lea d, [bp + -1] ; $p
2265   11BF DA            push d
2266   11C0 FA FF FF      lea d, [bp + -1] ; $p
2267   11C3 2A            mov b, [d]
2268   11C4 38 00 00      mov c, 0
2269   11C7             ; --- START TERMS
2270   11C7 D7            push a
2271   11C8 11            mov a, b
2272   11C9 FD 2E 02 00   mov32 cb, $00000002
2272   11CD 00 00 
2273   11CF 56            add b, a
2274   11D0 E4            pop a
2275   11D1             ; --- END TERMS
2276   11D1 E7            pop d
2277   11D2 FD 43         mov [d], b
2278   11D4             ; break; 
2279   11D4 0A E3 11      jmp _switch27_exit ; case break
2280   11D7             _switch27_default:
2281   11D7             ; print("Error: Unknown argument type.\n"); 
2282   11D7             ; --- START FUNCTION CALL
2283   11D7 26 0B 21      mov b, _s1 ; "Error: Unknown argument type.\n"
2284   11DA FD AB         swp b
2285   11DC D8            push b
2286   11DD 07 89 1C      call print
2287   11E0 51 02 00      add sp, 2
2288   11E3             ; --- END FUNCTION CALL
2289   11E3             _switch27_exit:
2290   11E3             ; format_p++; 
2291   11E3 FA FD FF      lea d, [bp + -3] ; $format_p
2292   11E6 2A            mov b, [d]
2293   11E7 38 00 00      mov c, 0
2294   11EA FD 77         inc b
2295   11EC FA FD FF      lea d, [bp + -3] ; $format_p
2296   11EF FD 43         mov [d], b
2297   11F1 FD 7D         dec b
2298   11F3 0A 1E 12      jmp _if26_exit
2299   11F6             _if26_else:
2300   11F6             ; *sp++ = *format_p++; 
2301   11F6 FA FB FF      lea d, [bp + -5] ; $sp
2302   11F9 2A            mov b, [d]
2303   11FA 38 00 00      mov c, 0
2304   11FD FD 77         inc b
2305   11FF FA FB FF      lea d, [bp + -5] ; $sp
2306   1202 FD 43         mov [d], b
2307   1204 FD 7D         dec b
2308   1206 D8            push b
2309   1207 FA FD FF      lea d, [bp + -3] ; $format_p
2310   120A 2A            mov b, [d]
2311   120B 38 00 00      mov c, 0
2312   120E FD 77         inc b
2313   1210 FA FD FF      lea d, [bp + -3] ; $format_p
2314   1213 FD 43         mov [d], b
2315   1215 FD 7D         dec b
2316   1217 74            mov d, b
2317   1218 32            mov bl, [d]
2318   1219 A7 00         mov bh, 0
2319   121B E7            pop d
2320   121C FD 3E         mov [d], bl
2321   121E             _if26_exit:
2322   121E             _if25_exit:
2323   121E             _for24_update:
2324   121E 0A ED 0E      jmp _for24_cond
2325   1221             _for24_exit:
2326   1221             ; *sp = '\0'; 
2327   1221 FA FB FF      lea d, [bp + -5] ; $sp
2328   1224 2A            mov b, [d]
2329   1225 38 00 00      mov c, 0
2330   1228 D8            push b
2331   1229 FD 2E 00 00   mov32 cb, $00000000
2331   122D 00 00 
2332   122F E7            pop d
2333   1230 FD 3E         mov [d], bl
2334   1232             ; return sp - dest; // return total number of chars written 
2335   1232 FA FB FF      lea d, [bp + -5] ; $sp
2336   1235 2A            mov b, [d]
2337   1236 38 00 00      mov c, 0
2338   1239             ; --- START TERMS
2339   1239 D7            push a
2340   123A 11            mov a, b
2341   123B FA 05 00      lea d, [bp + 5] ; $dest
2342   123E 2A            mov b, [d]
2343   123F 38 00 00      mov c, 0
2344   1242 60            sub a, b
2345   1243 27            mov b, a
2346   1244 E4            pop a
2347   1245             ; --- END TERMS
2348   1245 F9            leave
2349   1246 09            ret
2350   1247             
2351   1247             err:
2352   1247 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2353   124A             ; print(e); 
2354   124A             ; --- START FUNCTION CALL
2355   124A FA 05 00      lea d, [bp + 5] ; $e
2356   124D 2A            mov b, [d]
2357   124E 38 00 00      mov c, 0
2358   1251 FD AB         swp b
2359   1253 D8            push b
2360   1254 07 89 1C      call print
2361   1257 51 02 00      add sp, 2
2362   125A             ; --- END FUNCTION CALL
2363   125A F9            leave
2364   125B 09            ret
2365   125C             
2366   125C             printx32:
2367   125C F8 00 00      enter 0 ; (push bp; mov bp, sp)
2368   125F             
2369   125F             ; --- BEGIN INLINE ASM SEGMENT
2370   125F FA 05 00      lea d, [bp + 5] ; $hex
2371   1262 2B 02 00      mov b, [d+2]
2372   1265 07 EC 1F      call print_u16x
2373   1268 2A            mov b, [d]
2374   1269 07 EC 1F      call print_u16x
2375   126C             ; --- END INLINE ASM SEGMENT
2376   126C             
2377   126C F9            leave
2378   126D 09            ret
2379   126E             
2380   126E             printx16:
2381   126E F8 00 00      enter 0 ; (push bp; mov bp, sp)
2382   1271             
2383   1271             ; --- BEGIN INLINE ASM SEGMENT
2384   1271 FA 05 00      lea d, [bp + 5] ; $hex
2385   1274 2A            mov b, [d]
2386   1275 07 EC 1F      call print_u16x
2387   1278             ; --- END INLINE ASM SEGMENT
2388   1278             
2389   1278 F9            leave
2390   1279 09            ret
2391   127A             
2392   127A             printx8:
2393   127A F8 00 00      enter 0 ; (push bp; mov bp, sp)
2394   127D             
2395   127D             ; --- BEGIN INLINE ASM SEGMENT
2396   127D FA 05 00      lea d, [bp + 5] ; $hex
2397   1280 32            mov bl, [d]
2398   1281 07 30 20      call print_u8x
2399   1284             ; --- END INLINE ASM SEGMENT
2400   1284             
2401   1284 F9            leave
2402   1285 09            ret
2403   1286             
2404   1286             hex_str_to_int:
2405   1286 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2406   1289             ; int value = 0; 
2407   1289 52 02 00      sub sp, 2
2408   128C             ; --- START LOCAL VAR INITIALIZATION
2409   128C FA FF FF      lea d, [bp + -1] ; $value
2410   128F DA            push d
2411   1290 FD 2E 00 00   mov32 cb, $00000000
2411   1294 00 00 
2412   1296 E7            pop d
2413   1297 FD 43         mov [d], b
2414   1299             ; --- END LOCAL VAR INITIALIZATION
2415   1299             ; int i; 
2416   1299 52 02 00      sub sp, 2
2417   129C             ; char hex_char; 
2418   129C 52 01 00      sub sp, 1
2419   129F             ; int len; 
2420   129F 52 02 00      sub sp, 2
2421   12A2             ; len = strlen(hex_string); 
2422   12A2 FA FA FF      lea d, [bp + -6] ; $len
2423   12A5 DA            push d
2424   12A6             ; --- START FUNCTION CALL
2425   12A6 FA 05 00      lea d, [bp + 5] ; $hex_string
2426   12A9 2A            mov b, [d]
2427   12AA 38 00 00      mov c, 0
2428   12AD FD AB         swp b
2429   12AF D8            push b
2430   12B0 07 F5 05      call strlen
2431   12B3 51 02 00      add sp, 2
2432   12B6             ; --- END FUNCTION CALL
2433   12B6 E7            pop d
2434   12B7 FD 43         mov [d], b
2435   12B9             ; for (i = 0; i < len; i++) { 
2436   12B9             _for31_init:
2437   12B9 FA FD FF      lea d, [bp + -3] ; $i
2438   12BC DA            push d
2439   12BD FD 2E 00 00   mov32 cb, $00000000
2439   12C1 00 00 
2440   12C3 E7            pop d
2441   12C4 FD 43         mov [d], b
2442   12C6             _for31_cond:
2443   12C6 FA FD FF      lea d, [bp + -3] ; $i
2444   12C9 2A            mov b, [d]
2445   12CA 38 00 00      mov c, 0
2446   12CD             ; --- START RELATIONAL
2447   12CD D7            push a
2448   12CE 11            mov a, b
2449   12CF FA FA FF      lea d, [bp + -6] ; $len
2450   12D2 2A            mov b, [d]
2451   12D3 38 00 00      mov c, 0
2452   12D6 B0            cmp a, b
2453   12D7 FD 73         slt ; < (signed)
2454   12D9 E4            pop a
2455   12DA             ; --- END RELATIONAL
2456   12DA C0 00 00      cmp b, 0
2457   12DD C6 2A 14      je _for31_exit
2458   12E0             _for31_block:
2459   12E0             ; hex_char = hex_string[i]; 
2460   12E0 FA FC FF      lea d, [bp + -4] ; $hex_char
2461   12E3 DA            push d
2462   12E4 FA 05 00      lea d, [bp + 5] ; $hex_string
2463   12E7 FD 2A         mov d, [d]
2464   12E9 D7            push a
2465   12EA DA            push d
2466   12EB FA FD FF      lea d, [bp + -3] ; $i
2467   12EE 2A            mov b, [d]
2468   12EF 38 00 00      mov c, 0
2469   12F2 E7            pop d
2470   12F3 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
2471   12F7 E4            pop a
2472   12F8 32            mov bl, [d]
2473   12F9 A7 00         mov bh, 0
2474   12FB 38 00 00      mov c, 0
2475   12FE E7            pop d
2476   12FF FD 3E         mov [d], bl
2477   1301             ; if (hex_char >= 'a' && hex_char <= 'f')  
2478   1301             _if32_cond:
2479   1301 FA FC FF      lea d, [bp + -4] ; $hex_char
2480   1304 32            mov bl, [d]
2481   1305 A7 00         mov bh, 0
2482   1307 38 00 00      mov c, 0
2483   130A             ; --- START RELATIONAL
2484   130A D7            push a
2485   130B 11            mov a, b
2486   130C FD 2E 61 00   mov32 cb, $00000061
2486   1310 00 00 
2487   1312 B0            cmp a, b
2488   1313 FD 80         sge ; >=
2489   1315 E4            pop a
2490   1316             ; --- END RELATIONAL
2491   1316             ; --- START LOGICAL AND
2492   1316 D7            push a
2493   1317 11            mov a, b
2494   1318 FA FC FF      lea d, [bp + -4] ; $hex_char
2495   131B 32            mov bl, [d]
2496   131C A7 00         mov bh, 0
2497   131E 38 00 00      mov c, 0
2498   1321             ; --- START RELATIONAL
2499   1321 D7            push a
2500   1322 11            mov a, b
2501   1323 FD 2E 66 00   mov32 cb, $00000066
2501   1327 00 00 
2502   1329 B0            cmp a, b
2503   132A FD 74         sle ; <= (signed)
2504   132C E4            pop a
2505   132D             ; --- END RELATIONAL
2506   132D FD A7         sand a, b
2507   132F E4            pop a
2508   1330             ; --- END LOGICAL AND
2509   1330 C0 00 00      cmp b, 0
2510   1333 C6 73 13      je _if32_else
2511   1336             _if32_true:
2512   1336             ; value = (value * 16) + (hex_char - 'a' + 10); 
2513   1336 FA FF FF      lea d, [bp + -1] ; $value
2514   1339 DA            push d
2515   133A FA FF FF      lea d, [bp + -1] ; $value
2516   133D 2A            mov b, [d]
2517   133E 38 00 00      mov c, 0
2518   1341             ; --- START FACTORS
2519   1341 D7            push a
2520   1342 11            mov a, b
2521   1343 FD 2E 10 00   mov32 cb, $00000010
2521   1347 00 00 
2522   1349 AC            mul a, b ; *
2523   134A 11            mov a, b
2524   134B 27            mov b, a
2525   134C E4            pop a
2526   134D             ; --- END FACTORS
2527   134D             ; --- START TERMS
2528   134D D7            push a
2529   134E 11            mov a, b
2530   134F FA FC FF      lea d, [bp + -4] ; $hex_char
2531   1352 32            mov bl, [d]
2532   1353 A7 00         mov bh, 0
2533   1355 38 00 00      mov c, 0
2534   1358             ; --- START TERMS
2535   1358 D7            push a
2536   1359 11            mov a, b
2537   135A FD 2E 61 00   mov32 cb, $00000061
2537   135E 00 00 
2538   1360 60            sub a, b
2539   1361 27            mov b, a
2540   1362 11            mov a, b
2541   1363 FD 2E 0A 00   mov32 cb, $0000000a
2541   1367 00 00 
2542   1369 56            add b, a
2543   136A E4            pop a
2544   136B             ; --- END TERMS
2545   136B 56            add b, a
2546   136C E4            pop a
2547   136D             ; --- END TERMS
2548   136D E7            pop d
2549   136E FD 43         mov [d], b
2550   1370 0A 17 14      jmp _if32_exit
2551   1373             _if32_else:
2552   1373             ; if (hex_char >= 'A' && hex_char <= 'F')  
2553   1373             _if33_cond:
2554   1373 FA FC FF      lea d, [bp + -4] ; $hex_char
2555   1376 32            mov bl, [d]
2556   1377 A7 00         mov bh, 0
2557   1379 38 00 00      mov c, 0
2558   137C             ; --- START RELATIONAL
2559   137C D7            push a
2560   137D 11            mov a, b
2561   137E FD 2E 41 00   mov32 cb, $00000041
2561   1382 00 00 
2562   1384 B0            cmp a, b
2563   1385 FD 80         sge ; >=
2564   1387 E4            pop a
2565   1388             ; --- END RELATIONAL
2566   1388             ; --- START LOGICAL AND
2567   1388 D7            push a
2568   1389 11            mov a, b
2569   138A FA FC FF      lea d, [bp + -4] ; $hex_char
2570   138D 32            mov bl, [d]
2571   138E A7 00         mov bh, 0
2572   1390 38 00 00      mov c, 0
2573   1393             ; --- START RELATIONAL
2574   1393 D7            push a
2575   1394 11            mov a, b
2576   1395 FD 2E 46 00   mov32 cb, $00000046
2576   1399 00 00 
2577   139B B0            cmp a, b
2578   139C FD 74         sle ; <= (signed)
2579   139E E4            pop a
2580   139F             ; --- END RELATIONAL
2581   139F FD A7         sand a, b
2582   13A1 E4            pop a
2583   13A2             ; --- END LOGICAL AND
2584   13A2 C0 00 00      cmp b, 0
2585   13A5 C6 E5 13      je _if33_else
2586   13A8             _if33_true:
2587   13A8             ; value = (value * 16) + (hex_char - 'A' + 10); 
2588   13A8 FA FF FF      lea d, [bp + -1] ; $value
2589   13AB DA            push d
2590   13AC FA FF FF      lea d, [bp + -1] ; $value
2591   13AF 2A            mov b, [d]
2592   13B0 38 00 00      mov c, 0
2593   13B3             ; --- START FACTORS
2594   13B3 D7            push a
2595   13B4 11            mov a, b
2596   13B5 FD 2E 10 00   mov32 cb, $00000010
2596   13B9 00 00 
2597   13BB AC            mul a, b ; *
2598   13BC 11            mov a, b
2599   13BD 27            mov b, a
2600   13BE E4            pop a
2601   13BF             ; --- END FACTORS
2602   13BF             ; --- START TERMS
2603   13BF D7            push a
2604   13C0 11            mov a, b
2605   13C1 FA FC FF      lea d, [bp + -4] ; $hex_char
2606   13C4 32            mov bl, [d]
2607   13C5 A7 00         mov bh, 0
2608   13C7 38 00 00      mov c, 0
2609   13CA             ; --- START TERMS
2610   13CA D7            push a
2611   13CB 11            mov a, b
2612   13CC FD 2E 41 00   mov32 cb, $00000041
2612   13D0 00 00 
2613   13D2 60            sub a, b
2614   13D3 27            mov b, a
2615   13D4 11            mov a, b
2616   13D5 FD 2E 0A 00   mov32 cb, $0000000a
2616   13D9 00 00 
2617   13DB 56            add b, a
2618   13DC E4            pop a
2619   13DD             ; --- END TERMS
2620   13DD 56            add b, a
2621   13DE E4            pop a
2622   13DF             ; --- END TERMS
2623   13DF E7            pop d
2624   13E0 FD 43         mov [d], b
2625   13E2 0A 17 14      jmp _if33_exit
2626   13E5             _if33_else:
2627   13E5             ; value = (value * 16) + (hex_char - '0'); 
2628   13E5 FA FF FF      lea d, [bp + -1] ; $value
2629   13E8 DA            push d
2630   13E9 FA FF FF      lea d, [bp + -1] ; $value
2631   13EC 2A            mov b, [d]
2632   13ED 38 00 00      mov c, 0
2633   13F0             ; --- START FACTORS
2634   13F0 D7            push a
2635   13F1 11            mov a, b
2636   13F2 FD 2E 10 00   mov32 cb, $00000010
2636   13F6 00 00 
2637   13F8 AC            mul a, b ; *
2638   13F9 11            mov a, b
2639   13FA 27            mov b, a
2640   13FB E4            pop a
2641   13FC             ; --- END FACTORS
2642   13FC             ; --- START TERMS
2643   13FC D7            push a
2644   13FD 11            mov a, b
2645   13FE FA FC FF      lea d, [bp + -4] ; $hex_char
2646   1401 32            mov bl, [d]
2647   1402 A7 00         mov bh, 0
2648   1404 38 00 00      mov c, 0
2649   1407             ; --- START TERMS
2650   1407 D7            push a
2651   1408 11            mov a, b
2652   1409 FD 2E 30 00   mov32 cb, $00000030
2652   140D 00 00 
2653   140F 60            sub a, b
2654   1410 27            mov b, a
2655   1411 E4            pop a
2656   1412             ; --- END TERMS
2657   1412 56            add b, a
2658   1413 E4            pop a
2659   1414             ; --- END TERMS
2660   1414 E7            pop d
2661   1415 FD 43         mov [d], b
2662   1417             _if33_exit:
2663   1417             _if32_exit:
2664   1417             _for31_update:
2665   1417 FA FD FF      lea d, [bp + -3] ; $i
2666   141A 2A            mov b, [d]
2667   141B 38 00 00      mov c, 0
2668   141E FD 77         inc b
2669   1420 FA FD FF      lea d, [bp + -3] ; $i
2670   1423 FD 43         mov [d], b
2671   1425 FD 7D         dec b
2672   1427 0A C6 12      jmp _for31_cond
2673   142A             _for31_exit:
2674   142A             ; return value; 
2675   142A FA FF FF      lea d, [bp + -1] ; $value
2676   142D 2A            mov b, [d]
2677   142E 38 00 00      mov c, 0
2678   1431 F9            leave
2679   1432 09            ret
2680   1433             
2681   1433             gets:
2682   1433 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2683   1436             
2684   1436             ; --- BEGIN INLINE ASM SEGMENT
2685   1436 FA 05 00      lea d, [bp + 5] ; $s
2686   1439 15            mov a, [d]
2687   143A 3C            mov d, a
2688   143B 07 51 1E      call _gets
2689   143E             ; --- END INLINE ASM SEGMENT
2690   143E             
2691   143E             ; return strlen(s); 
2692   143E             ; --- START FUNCTION CALL
2693   143E FA 05 00      lea d, [bp + 5] ; $s
2694   1441 2A            mov b, [d]
2695   1442 38 00 00      mov c, 0
2696   1445 FD AB         swp b
2697   1447 D8            push b
2698   1448 07 F5 05      call strlen
2699   144B 51 02 00      add sp, 2
2700   144E             ; --- END FUNCTION CALL
2701   144E F9            leave
2702   144F 09            ret
2703   1450             
2704   1450             print_signed:
2705   1450 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2706   1453             ; char digits[5]; 
2707   1453 52 05 00      sub sp, 5
2708   1456             ; int i = 0; 
2709   1456 52 02 00      sub sp, 2
2710   1459             ; --- START LOCAL VAR INITIALIZATION
2711   1459 FA FA FF      lea d, [bp + -6] ; $i
2712   145C DA            push d
2713   145D FD 2E 00 00   mov32 cb, $00000000
2713   1461 00 00 
2714   1463 E7            pop d
2715   1464 FD 43         mov [d], b
2716   1466             ; --- END LOCAL VAR INITIALIZATION
2717   1466             ; if (num < 0) { 
2718   1466             _if34_cond:
2719   1466 FA 05 00      lea d, [bp + 5] ; $num
2720   1469 2A            mov b, [d]
2721   146A 38 00 00      mov c, 0
2722   146D             ; --- START RELATIONAL
2723   146D D7            push a
2724   146E 11            mov a, b
2725   146F FD 2E 00 00   mov32 cb, $00000000
2725   1473 00 00 
2726   1475 B0            cmp a, b
2727   1476 FD 73         slt ; < (signed)
2728   1478 E4            pop a
2729   1479             ; --- END RELATIONAL
2730   1479 C0 00 00      cmp b, 0
2731   147C C6 9F 14      je _if34_else
2732   147F             _if34_true:
2733   147F             ; putchar('-'); 
2734   147F             ; --- START FUNCTION CALL
2735   147F FD 2E 2D 00   mov32 cb, $0000002d
2735   1483 00 00 
2736   1485 DD            push bl
2737   1486 07 3B 1C      call putchar
2738   1489 51 01 00      add sp, 1
2739   148C             ; --- END FUNCTION CALL
2740   148C             ; num = -num; 
2741   148C FA 05 00      lea d, [bp + 5] ; $num
2742   148F DA            push d
2743   1490 FA 05 00      lea d, [bp + 5] ; $num
2744   1493 2A            mov b, [d]
2745   1494 38 00 00      mov c, 0
2746   1497 FD 97         neg b
2747   1499 E7            pop d
2748   149A FD 43         mov [d], b
2749   149C 0A CA 14      jmp _if34_exit
2750   149F             _if34_else:
2751   149F             ; if (num == 0) { 
2752   149F             _if35_cond:
2753   149F FA 05 00      lea d, [bp + 5] ; $num
2754   14A2 2A            mov b, [d]
2755   14A3 38 00 00      mov c, 0
2756   14A6             ; --- START RELATIONAL
2757   14A6 D7            push a
2758   14A7 11            mov a, b
2759   14A8 FD 2E 00 00   mov32 cb, $00000000
2759   14AC 00 00 
2760   14AE B0            cmp a, b
2761   14AF FD 71         seq ; ==
2762   14B1 E4            pop a
2763   14B2             ; --- END RELATIONAL
2764   14B2 C0 00 00      cmp b, 0
2765   14B5 C6 CA 14      je _if35_exit
2766   14B8             _if35_true:
2767   14B8             ; putchar('0'); 
2768   14B8             ; --- START FUNCTION CALL
2769   14B8 FD 2E 30 00   mov32 cb, $00000030
2769   14BC 00 00 
2770   14BE DD            push bl
2771   14BF 07 3B 1C      call putchar
2772   14C2 51 01 00      add sp, 1
2773   14C5             ; --- END FUNCTION CALL
2774   14C5             ; return; 
2775   14C5 F9            leave
2776   14C6 09            ret
2777   14C7 0A CA 14      jmp _if35_exit
2778   14CA             _if35_exit:
2779   14CA             _if34_exit:
2780   14CA             ; while (num > 0) { 
2781   14CA             _while36_cond:
2782   14CA FA 05 00      lea d, [bp + 5] ; $num
2783   14CD 2A            mov b, [d]
2784   14CE 38 00 00      mov c, 0
2785   14D1             ; --- START RELATIONAL
2786   14D1 D7            push a
2787   14D2 11            mov a, b
2788   14D3 FD 2E 00 00   mov32 cb, $00000000
2788   14D7 00 00 
2789   14D9 B0            cmp a, b
2790   14DA FD 7F         sgt ; >
2791   14DC E4            pop a
2792   14DD             ; --- END RELATIONAL
2793   14DD C0 00 00      cmp b, 0
2794   14E0 C6 3F 15      je _while36_exit
2795   14E3             _while36_block:
2796   14E3             ; digits[i] = '0' + (num % 10); 
2797   14E3 FA FC FF      lea d, [bp + -4] ; $digits
2798   14E6 D7            push a
2799   14E7 DA            push d
2800   14E8 FA FA FF      lea d, [bp + -6] ; $i
2801   14EB 2A            mov b, [d]
2802   14EC 38 00 00      mov c, 0
2803   14EF E7            pop d
2804   14F0 5A            add d, b
2805   14F1 E4            pop a
2806   14F2 DA            push d
2807   14F3 FD 2E 30 00   mov32 cb, $00000030
2807   14F7 00 00 
2808   14F9             ; --- START TERMS
2809   14F9 D7            push a
2810   14FA 11            mov a, b
2811   14FB FA 05 00      lea d, [bp + 5] ; $num
2812   14FE 2A            mov b, [d]
2813   14FF 38 00 00      mov c, 0
2814   1502             ; --- START FACTORS
2815   1502 D7            push a
2816   1503 11            mov a, b
2817   1504 FD 2E 0A 00   mov32 cb, $0000000a
2817   1508 00 00 
2818   150A AE            div a, b ; 
2819   150B 11            mov a, b
2820   150C 27            mov b, a
2821   150D E4            pop a
2822   150E             ; --- END FACTORS
2823   150E 56            add b, a
2824   150F E4            pop a
2825   1510             ; --- END TERMS
2826   1510 E7            pop d
2827   1511 FD 3E         mov [d], bl
2828   1513             ; num = num / 10; 
2829   1513 FA 05 00      lea d, [bp + 5] ; $num
2830   1516 DA            push d
2831   1517 FA 05 00      lea d, [bp + 5] ; $num
2832   151A 2A            mov b, [d]
2833   151B 38 00 00      mov c, 0
2834   151E             ; --- START FACTORS
2835   151E D7            push a
2836   151F 11            mov a, b
2837   1520 FD 2E 0A 00   mov32 cb, $0000000a
2837   1524 00 00 
2838   1526 AE            div a, b
2839   1527 27            mov b, a
2840   1528 E4            pop a
2841   1529             ; --- END FACTORS
2842   1529 E7            pop d
2843   152A FD 43         mov [d], b
2844   152C             ; i++; 
2845   152C FA FA FF      lea d, [bp + -6] ; $i
2846   152F 2A            mov b, [d]
2847   1530 38 00 00      mov c, 0
2848   1533 FD 77         inc b
2849   1535 FA FA FF      lea d, [bp + -6] ; $i
2850   1538 FD 43         mov [d], b
2851   153A FD 7D         dec b
2852   153C 0A CA 14      jmp _while36_cond
2853   153F             _while36_exit:
2854   153F             ; while (i > 0) { 
2855   153F             _while37_cond:
2856   153F FA FA FF      lea d, [bp + -6] ; $i
2857   1542 2A            mov b, [d]
2858   1543 38 00 00      mov c, 0
2859   1546             ; --- START RELATIONAL
2860   1546 D7            push a
2861   1547 11            mov a, b
2862   1548 FD 2E 00 00   mov32 cb, $00000000
2862   154C 00 00 
2863   154E B0            cmp a, b
2864   154F FD 7F         sgt ; >
2865   1551 E4            pop a
2866   1552             ; --- END RELATIONAL
2867   1552 C0 00 00      cmp b, 0
2868   1555 C6 87 15      je _while37_exit
2869   1558             _while37_block:
2870   1558             ; i--; 
2871   1558 FA FA FF      lea d, [bp + -6] ; $i
2872   155B 2A            mov b, [d]
2873   155C 38 00 00      mov c, 0
2874   155F FD 7D         dec b
2875   1561 FA FA FF      lea d, [bp + -6] ; $i
2876   1564 FD 43         mov [d], b
2877   1566 FD 77         inc b
2878   1568             ; putchar(digits[i]); 
2879   1568             ; --- START FUNCTION CALL
2880   1568 FA FC FF      lea d, [bp + -4] ; $digits
2881   156B D7            push a
2882   156C DA            push d
2883   156D FA FA FF      lea d, [bp + -6] ; $i
2884   1570 2A            mov b, [d]
2885   1571 38 00 00      mov c, 0
2886   1574 E7            pop d
2887   1575 5A            add d, b
2888   1576 E4            pop a
2889   1577 32            mov bl, [d]
2890   1578 A7 00         mov bh, 0
2891   157A 38 00 00      mov c, 0
2892   157D DD            push bl
2893   157E 07 3B 1C      call putchar
2894   1581 51 01 00      add sp, 1
2895   1584             ; --- END FUNCTION CALL
2896   1584 0A 3F 15      jmp _while37_cond
2897   1587             _while37_exit:
2898   1587 F9            leave
2899   1588 09            ret
2900   1589             
2901   1589             print_signed_long:
2902   1589 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2903   158C             ; char digits[10]; 
2904   158C 52 0A 00      sub sp, 10
2905   158F             ; int i = 0; 
2906   158F 52 02 00      sub sp, 2
2907   1592             ; --- START LOCAL VAR INITIALIZATION
2908   1592 FA F5 FF      lea d, [bp + -11] ; $i
2909   1595 DA            push d
2910   1596 FD 2E 00 00   mov32 cb, $00000000
2910   159A 00 00 
2911   159C E7            pop d
2912   159D FD 43         mov [d], b
2913   159F             ; --- END LOCAL VAR INITIALIZATION
2914   159F             ; if (num < 0) { 
2915   159F             _if38_cond:
2916   159F FA 05 00      lea d, [bp + 5] ; $num
2917   15A2 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2918   15A5 FD 39         mov c, b ; And place it into C
2919   15A7 2A            mov b, [d] ; Lower Word in B
2920   15A8             ; --- START RELATIONAL
2921   15A8 D7            push a
2922   15A9 FD D8         push g
2923   15AB 11            mov a, b
2924   15AC FD 7A         mov g, c
2925   15AE FD 2E 00 00   mov32 cb, $00000000
2925   15B2 00 00 
2926   15B4 38 00 00      mov c, 0
2927   15B7 FD AF         cmp32 ga, cb
2928   15B9 FD 73         slt ; <
2929   15BB FD F1         pop g
2930   15BD E4            pop a
2931   15BE             ; --- END RELATIONAL
2932   15BE C0 00 00      cmp b, 0
2933   15C1 C6 ED 15      je _if38_else
2934   15C4             _if38_true:
2935   15C4             ; putchar('-'); 
2936   15C4             ; --- START FUNCTION CALL
2937   15C4 FD 2E 2D 00   mov32 cb, $0000002d
2937   15C8 00 00 
2938   15CA DD            push bl
2939   15CB 07 3B 1C      call putchar
2940   15CE 51 01 00      add sp, 1
2941   15D1             ; --- END FUNCTION CALL
2942   15D1             ; num = -num; 
2943   15D1 FA 05 00      lea d, [bp + 5] ; $num
2944   15D4 DA            push d
2945   15D5 FA 05 00      lea d, [bp + 5] ; $num
2946   15D8 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2947   15DB FD 39         mov c, b ; And place it into C
2948   15DD 2A            mov b, [d] ; Lower Word in B
2949   15DE FD 97         neg b
2950   15E0 E7            pop d
2951   15E1 FD 43         mov [d], b
2952   15E3 26 00 00      mov b, 0
2953   15E6 FD 44 02 00   mov [d + 2], b
2954   15EA 0A 24 16      jmp _if38_exit
2955   15ED             _if38_else:
2956   15ED             ; if (num == 0) { 
2957   15ED             _if39_cond:
2958   15ED FA 05 00      lea d, [bp + 5] ; $num
2959   15F0 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2960   15F3 FD 39         mov c, b ; And place it into C
2961   15F5 2A            mov b, [d] ; Lower Word in B
2962   15F6             ; --- START RELATIONAL
2963   15F6 D7            push a
2964   15F7 FD D8         push g
2965   15F9 11            mov a, b
2966   15FA FD 7A         mov g, c
2967   15FC FD 2E 00 00   mov32 cb, $00000000
2967   1600 00 00 
2968   1602 38 00 00      mov c, 0
2969   1605 FD AF         cmp32 ga, cb
2970   1607 FD 71         seq ; ==
2971   1609 FD F1         pop g
2972   160B E4            pop a
2973   160C             ; --- END RELATIONAL
2974   160C C0 00 00      cmp b, 0
2975   160F C6 24 16      je _if39_exit
2976   1612             _if39_true:
2977   1612             ; putchar('0'); 
2978   1612             ; --- START FUNCTION CALL
2979   1612 FD 2E 30 00   mov32 cb, $00000030
2979   1616 00 00 
2980   1618 DD            push bl
2981   1619 07 3B 1C      call putchar
2982   161C 51 01 00      add sp, 1
2983   161F             ; --- END FUNCTION CALL
2984   161F             ; return; 
2985   161F F9            leave
2986   1620 09            ret
2987   1621 0A 24 16      jmp _if39_exit
2988   1624             _if39_exit:
2989   1624             _if38_exit:
2990   1624             ; while (num > 0) { 
2991   1624             _while40_cond:
2992   1624 FA 05 00      lea d, [bp + 5] ; $num
2993   1627 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2994   162A FD 39         mov c, b ; And place it into C
2995   162C 2A            mov b, [d] ; Lower Word in B
2996   162D             ; --- START RELATIONAL
2997   162D D7            push a
2998   162E FD D8         push g
2999   1630 11            mov a, b
3000   1631 FD 7A         mov g, c
3001   1633 FD 2E 00 00   mov32 cb, $00000000
3001   1637 00 00 
3002   1639 38 00 00      mov c, 0
3003   163C FD AF         cmp32 ga, cb
3004   163E FD 7F         sgt
3005   1640 FD F1         pop g
3006   1642 E4            pop a
3007   1643             ; --- END RELATIONAL
3008   1643 C0 00 00      cmp b, 0
3009   1646 C6 AF 16      je _while40_exit
3010   1649             _while40_block:
3011   1649             ; digits[i] = '0' + (num % 10); 
3012   1649 FA F7 FF      lea d, [bp + -9] ; $digits
3013   164C D7            push a
3014   164D DA            push d
3015   164E FA F5 FF      lea d, [bp + -11] ; $i
3016   1651 2A            mov b, [d]
3017   1652 38 00 00      mov c, 0
3018   1655 E7            pop d
3019   1656 5A            add d, b
3020   1657 E4            pop a
3021   1658 DA            push d
3022   1659 FD 2E 30 00   mov32 cb, $00000030
3022   165D 00 00 
3023   165F             ; --- START TERMS
3024   165F D7            push a
3025   1660 11            mov a, b
3026   1661 FA 05 00      lea d, [bp + 5] ; $num
3027   1664 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3028   1667 FD 39         mov c, b ; And place it into C
3029   1669 2A            mov b, [d] ; Lower Word in B
3030   166A             ; --- START FACTORS
3031   166A D7            push a
3032   166B 11            mov a, b
3033   166C FD 2E 0A 00   mov32 cb, $0000000a
3033   1670 00 00 
3034   1672 AE            div a, b ; 
3035   1673 11            mov a, b
3036   1674 27            mov b, a
3037   1675 E4            pop a
3038   1676             ; --- END FACTORS
3039   1676 FD 15         add32 cb, ga
3040   1678 E4            pop a
3041   1679             ; --- END TERMS
3042   1679 E7            pop d
3043   167A FD 3E         mov [d], bl
3044   167C             ; num = num / 10; 
3045   167C FA 05 00      lea d, [bp + 5] ; $num
3046   167F DA            push d
3047   1680 FA 05 00      lea d, [bp + 5] ; $num
3048   1683 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3049   1686 FD 39         mov c, b ; And place it into C
3050   1688 2A            mov b, [d] ; Lower Word in B
3051   1689             ; --- START FACTORS
3052   1689 D7            push a
3053   168A 11            mov a, b
3054   168B FD 2E 0A 00   mov32 cb, $0000000a
3054   168F 00 00 
3055   1691 AE            div a, b
3056   1692 27            mov b, a
3057   1693 E4            pop a
3058   1694             ; --- END FACTORS
3059   1694 E7            pop d
3060   1695 FD 43         mov [d], b
3061   1697 28            mov b, c
3062   1698 FD 44 02 00   mov [d + 2], b
3063   169C             ; i++; 
3064   169C FA F5 FF      lea d, [bp + -11] ; $i
3065   169F 2A            mov b, [d]
3066   16A0 38 00 00      mov c, 0
3067   16A3 FD 77         inc b
3068   16A5 FA F5 FF      lea d, [bp + -11] ; $i
3069   16A8 FD 43         mov [d], b
3070   16AA FD 7D         dec b
3071   16AC 0A 24 16      jmp _while40_cond
3072   16AF             _while40_exit:
3073   16AF             ; while (i > 0) { 
3074   16AF             _while41_cond:
3075   16AF FA F5 FF      lea d, [bp + -11] ; $i
3076   16B2 2A            mov b, [d]
3077   16B3 38 00 00      mov c, 0
3078   16B6             ; --- START RELATIONAL
3079   16B6 D7            push a
3080   16B7 11            mov a, b
3081   16B8 FD 2E 00 00   mov32 cb, $00000000
3081   16BC 00 00 
3082   16BE B0            cmp a, b
3083   16BF FD 7F         sgt ; >
3084   16C1 E4            pop a
3085   16C2             ; --- END RELATIONAL
3086   16C2 C0 00 00      cmp b, 0
3087   16C5 C6 F7 16      je _while41_exit
3088   16C8             _while41_block:
3089   16C8             ; i--; 
3090   16C8 FA F5 FF      lea d, [bp + -11] ; $i
3091   16CB 2A            mov b, [d]
3092   16CC 38 00 00      mov c, 0
3093   16CF FD 7D         dec b
3094   16D1 FA F5 FF      lea d, [bp + -11] ; $i
3095   16D4 FD 43         mov [d], b
3096   16D6 FD 77         inc b
3097   16D8             ; putchar(digits[i]); 
3098   16D8             ; --- START FUNCTION CALL
3099   16D8 FA F7 FF      lea d, [bp + -9] ; $digits
3100   16DB D7            push a
3101   16DC DA            push d
3102   16DD FA F5 FF      lea d, [bp + -11] ; $i
3103   16E0 2A            mov b, [d]
3104   16E1 38 00 00      mov c, 0
3105   16E4 E7            pop d
3106   16E5 5A            add d, b
3107   16E6 E4            pop a
3108   16E7 32            mov bl, [d]
3109   16E8 A7 00         mov bh, 0
3110   16EA 38 00 00      mov c, 0
3111   16ED DD            push bl
3112   16EE 07 3B 1C      call putchar
3113   16F1 51 01 00      add sp, 1
3114   16F4             ; --- END FUNCTION CALL
3115   16F4 0A AF 16      jmp _while41_cond
3116   16F7             _while41_exit:
3117   16F7 F9            leave
3118   16F8 09            ret
3119   16F9             
3120   16F9             print_unsigned_long:
3121   16F9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3122   16FC             ; char digits[10]; 
3123   16FC 52 0A 00      sub sp, 10
3124   16FF             ; int i; 
3125   16FF 52 02 00      sub sp, 2
3126   1702             ; i = 0; 
3127   1702 FA F5 FF      lea d, [bp + -11] ; $i
3128   1705 DA            push d
3129   1706 FD 2E 00 00   mov32 cb, $00000000
3129   170A 00 00 
3130   170C E7            pop d
3131   170D FD 43         mov [d], b
3132   170F             ; if(num == 0){ 
3133   170F             _if42_cond:
3134   170F FA 05 00      lea d, [bp + 5] ; $num
3135   1712 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3136   1715 FD 39         mov c, b ; And place it into C
3137   1717 2A            mov b, [d] ; Lower Word in B
3138   1718             ; --- START RELATIONAL
3139   1718 D7            push a
3140   1719 FD D8         push g
3141   171B 11            mov a, b
3142   171C FD 7A         mov g, c
3143   171E FD 2E 00 00   mov32 cb, $00000000
3143   1722 00 00 
3144   1724 38 00 00      mov c, 0
3145   1727 FD AF         cmp32 ga, cb
3146   1729 FD 71         seq ; ==
3147   172B FD F1         pop g
3148   172D E4            pop a
3149   172E             ; --- END RELATIONAL
3150   172E C0 00 00      cmp b, 0
3151   1731 C6 46 17      je _if42_exit
3152   1734             _if42_true:
3153   1734             ; putchar('0'); 
3154   1734             ; --- START FUNCTION CALL
3155   1734 FD 2E 30 00   mov32 cb, $00000030
3155   1738 00 00 
3156   173A DD            push bl
3157   173B 07 3B 1C      call putchar
3158   173E 51 01 00      add sp, 1
3159   1741             ; --- END FUNCTION CALL
3160   1741             ; return; 
3161   1741 F9            leave
3162   1742 09            ret
3163   1743 0A 46 17      jmp _if42_exit
3164   1746             _if42_exit:
3165   1746             ; while (num > 0) { 
3166   1746             _while43_cond:
3167   1746 FA 05 00      lea d, [bp + 5] ; $num
3168   1749 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3169   174C FD 39         mov c, b ; And place it into C
3170   174E 2A            mov b, [d] ; Lower Word in B
3171   174F             ; --- START RELATIONAL
3172   174F D7            push a
3173   1750 FD D8         push g
3174   1752 11            mov a, b
3175   1753 FD 7A         mov g, c
3176   1755 FD 2E 00 00   mov32 cb, $00000000
3176   1759 00 00 
3177   175B 38 00 00      mov c, 0
3178   175E FD AF         cmp32 ga, cb
3179   1760 FD 81         sgu
3180   1762 FD F1         pop g
3181   1764 E4            pop a
3182   1765             ; --- END RELATIONAL
3183   1765 C0 00 00      cmp b, 0
3184   1768 C6 D1 17      je _while43_exit
3185   176B             _while43_block:
3186   176B             ; digits[i] = '0' + (num % 10); 
3187   176B FA F7 FF      lea d, [bp + -9] ; $digits
3188   176E D7            push a
3189   176F DA            push d
3190   1770 FA F5 FF      lea d, [bp + -11] ; $i
3191   1773 2A            mov b, [d]
3192   1774 38 00 00      mov c, 0
3193   1777 E7            pop d
3194   1778 5A            add d, b
3195   1779 E4            pop a
3196   177A DA            push d
3197   177B FD 2E 30 00   mov32 cb, $00000030
3197   177F 00 00 
3198   1781             ; --- START TERMS
3199   1781 D7            push a
3200   1782 11            mov a, b
3201   1783 FA 05 00      lea d, [bp + 5] ; $num
3202   1786 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3203   1789 FD 39         mov c, b ; And place it into C
3204   178B 2A            mov b, [d] ; Lower Word in B
3205   178C             ; --- START FACTORS
3206   178C D7            push a
3207   178D 11            mov a, b
3208   178E FD 2E 0A 00   mov32 cb, $0000000a
3208   1792 00 00 
3209   1794 AE            div a, b ; 
3210   1795 11            mov a, b
3211   1796 27            mov b, a
3212   1797 E4            pop a
3213   1798             ; --- END FACTORS
3214   1798 FD 15         add32 cb, ga
3215   179A E4            pop a
3216   179B             ; --- END TERMS
3217   179B E7            pop d
3218   179C FD 3E         mov [d], bl
3219   179E             ; num = num / 10; 
3220   179E FA 05 00      lea d, [bp + 5] ; $num
3221   17A1 DA            push d
3222   17A2 FA 05 00      lea d, [bp + 5] ; $num
3223   17A5 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3224   17A8 FD 39         mov c, b ; And place it into C
3225   17AA 2A            mov b, [d] ; Lower Word in B
3226   17AB             ; --- START FACTORS
3227   17AB D7            push a
3228   17AC 11            mov a, b
3229   17AD FD 2E 0A 00   mov32 cb, $0000000a
3229   17B1 00 00 
3230   17B3 AE            div a, b
3231   17B4 27            mov b, a
3232   17B5 E4            pop a
3233   17B6             ; --- END FACTORS
3234   17B6 E7            pop d
3235   17B7 FD 43         mov [d], b
3236   17B9 28            mov b, c
3237   17BA FD 44 02 00   mov [d + 2], b
3238   17BE             ; i++; 
3239   17BE FA F5 FF      lea d, [bp + -11] ; $i
3240   17C1 2A            mov b, [d]
3241   17C2 38 00 00      mov c, 0
3242   17C5 FD 77         inc b
3243   17C7 FA F5 FF      lea d, [bp + -11] ; $i
3244   17CA FD 43         mov [d], b
3245   17CC FD 7D         dec b
3246   17CE 0A 46 17      jmp _while43_cond
3247   17D1             _while43_exit:
3248   17D1             ; while (i > 0) { 
3249   17D1             _while44_cond:
3250   17D1 FA F5 FF      lea d, [bp + -11] ; $i
3251   17D4 2A            mov b, [d]
3252   17D5 38 00 00      mov c, 0
3253   17D8             ; --- START RELATIONAL
3254   17D8 D7            push a
3255   17D9 11            mov a, b
3256   17DA FD 2E 00 00   mov32 cb, $00000000
3256   17DE 00 00 
3257   17E0 B0            cmp a, b
3258   17E1 FD 7F         sgt ; >
3259   17E3 E4            pop a
3260   17E4             ; --- END RELATIONAL
3261   17E4 C0 00 00      cmp b, 0
3262   17E7 C6 19 18      je _while44_exit
3263   17EA             _while44_block:
3264   17EA             ; i--; 
3265   17EA FA F5 FF      lea d, [bp + -11] ; $i
3266   17ED 2A            mov b, [d]
3267   17EE 38 00 00      mov c, 0
3268   17F1 FD 7D         dec b
3269   17F3 FA F5 FF      lea d, [bp + -11] ; $i
3270   17F6 FD 43         mov [d], b
3271   17F8 FD 77         inc b
3272   17FA             ; putchar(digits[i]); 
3273   17FA             ; --- START FUNCTION CALL
3274   17FA FA F7 FF      lea d, [bp + -9] ; $digits
3275   17FD D7            push a
3276   17FE DA            push d
3277   17FF FA F5 FF      lea d, [bp + -11] ; $i
3278   1802 2A            mov b, [d]
3279   1803 38 00 00      mov c, 0
3280   1806 E7            pop d
3281   1807 5A            add d, b
3282   1808 E4            pop a
3283   1809 32            mov bl, [d]
3284   180A A7 00         mov bh, 0
3285   180C 38 00 00      mov c, 0
3286   180F DD            push bl
3287   1810 07 3B 1C      call putchar
3288   1813 51 01 00      add sp, 1
3289   1816             ; --- END FUNCTION CALL
3290   1816 0A D1 17      jmp _while44_cond
3291   1819             _while44_exit:
3292   1819 F9            leave
3293   181A 09            ret
3294   181B             
3295   181B             sprint_unsigned:
3296   181B F8 00 00      enter 0 ; (push bp; mov bp, sp)
3297   181E             ; char digits[5]; 
3298   181E 52 05 00      sub sp, 5
3299   1821             ; int i; 
3300   1821 52 02 00      sub sp, 2
3301   1824             ; int len = 0; 
3302   1824 52 02 00      sub sp, 2
3303   1827             ; --- START LOCAL VAR INITIALIZATION
3304   1827 FA F8 FF      lea d, [bp + -8] ; $len
3305   182A DA            push d
3306   182B FD 2E 00 00   mov32 cb, $00000000
3306   182F 00 00 
3307   1831 E7            pop d
3308   1832 FD 43         mov [d], b
3309   1834             ; --- END LOCAL VAR INITIALIZATION
3310   1834             ; i = 0; 
3311   1834 FA FA FF      lea d, [bp + -6] ; $i
3312   1837 DA            push d
3313   1838 FD 2E 00 00   mov32 cb, $00000000
3313   183C 00 00 
3314   183E E7            pop d
3315   183F FD 43         mov [d], b
3316   1841             ; if(num == 0){ 
3317   1841             _if45_cond:
3318   1841 FA 07 00      lea d, [bp + 7] ; $num
3319   1844 2A            mov b, [d]
3320   1845 38 00 00      mov c, 0
3321   1848             ; --- START RELATIONAL
3322   1848 D7            push a
3323   1849 11            mov a, b
3324   184A FD 2E 00 00   mov32 cb, $00000000
3324   184E 00 00 
3325   1850 B0            cmp a, b
3326   1851 FD 71         seq ; ==
3327   1853 E4            pop a
3328   1854             ; --- END RELATIONAL
3329   1854 C0 00 00      cmp b, 0
3330   1857 C6 7F 18      je _if45_exit
3331   185A             _if45_true:
3332   185A             ; *dest++ = '0'; 
3333   185A FA 05 00      lea d, [bp + 5] ; $dest
3334   185D 2A            mov b, [d]
3335   185E 38 00 00      mov c, 0
3336   1861 FD 77         inc b
3337   1863 FA 05 00      lea d, [bp + 5] ; $dest
3338   1866 FD 43         mov [d], b
3339   1868 FD 7D         dec b
3340   186A D8            push b
3341   186B FD 2E 30 00   mov32 cb, $00000030
3341   186F 00 00 
3342   1871 E7            pop d
3343   1872 FD 3E         mov [d], bl
3344   1874             ; return 1; 
3345   1874 FD 2E 01 00   mov32 cb, $00000001
3345   1878 00 00 
3346   187A F9            leave
3347   187B 09            ret
3348   187C 0A 7F 18      jmp _if45_exit
3349   187F             _if45_exit:
3350   187F             ; while (num > 0) { 
3351   187F             _while46_cond:
3352   187F FA 07 00      lea d, [bp + 7] ; $num
3353   1882 2A            mov b, [d]
3354   1883 38 00 00      mov c, 0
3355   1886             ; --- START RELATIONAL
3356   1886 D7            push a
3357   1887 11            mov a, b
3358   1888 FD 2E 00 00   mov32 cb, $00000000
3358   188C 00 00 
3359   188E B0            cmp a, b
3360   188F FD 81         sgu ; > (unsigned)
3361   1891 E4            pop a
3362   1892             ; --- END RELATIONAL
3363   1892 C0 00 00      cmp b, 0
3364   1895 C6 F4 18      je _while46_exit
3365   1898             _while46_block:
3366   1898             ; digits[i] = '0' + (num % 10); 
3367   1898 FA FC FF      lea d, [bp + -4] ; $digits
3368   189B D7            push a
3369   189C DA            push d
3370   189D FA FA FF      lea d, [bp + -6] ; $i
3371   18A0 2A            mov b, [d]
3372   18A1 38 00 00      mov c, 0
3373   18A4 E7            pop d
3374   18A5 5A            add d, b
3375   18A6 E4            pop a
3376   18A7 DA            push d
3377   18A8 FD 2E 30 00   mov32 cb, $00000030
3377   18AC 00 00 
3378   18AE             ; --- START TERMS
3379   18AE D7            push a
3380   18AF 11            mov a, b
3381   18B0 FA 07 00      lea d, [bp + 7] ; $num
3382   18B3 2A            mov b, [d]
3383   18B4 38 00 00      mov c, 0
3384   18B7             ; --- START FACTORS
3385   18B7 D7            push a
3386   18B8 11            mov a, b
3387   18B9 FD 2E 0A 00   mov32 cb, $0000000a
3387   18BD 00 00 
3388   18BF AE            div a, b ; 
3389   18C0 11            mov a, b
3390   18C1 27            mov b, a
3391   18C2 E4            pop a
3392   18C3             ; --- END FACTORS
3393   18C3 56            add b, a
3394   18C4 E4            pop a
3395   18C5             ; --- END TERMS
3396   18C5 E7            pop d
3397   18C6 FD 3E         mov [d], bl
3398   18C8             ; num = num / 10; 
3399   18C8 FA 07 00      lea d, [bp + 7] ; $num
3400   18CB DA            push d
3401   18CC FA 07 00      lea d, [bp + 7] ; $num
3402   18CF 2A            mov b, [d]
3403   18D0 38 00 00      mov c, 0
3404   18D3             ; --- START FACTORS
3405   18D3 D7            push a
3406   18D4 11            mov a, b
3407   18D5 FD 2E 0A 00   mov32 cb, $0000000a
3407   18D9 00 00 
3408   18DB AE            div a, b
3409   18DC 27            mov b, a
3410   18DD E4            pop a
3411   18DE             ; --- END FACTORS
3412   18DE E7            pop d
3413   18DF FD 43         mov [d], b
3414   18E1             ; i++; 
3415   18E1 FA FA FF      lea d, [bp + -6] ; $i
3416   18E4 2A            mov b, [d]
3417   18E5 38 00 00      mov c, 0
3418   18E8 FD 77         inc b
3419   18EA FA FA FF      lea d, [bp + -6] ; $i
3420   18ED FD 43         mov [d], b
3421   18EF FD 7D         dec b
3422   18F1 0A 7F 18      jmp _while46_cond
3423   18F4             _while46_exit:
3424   18F4             ; while (i > 0) { 
3425   18F4             _while47_cond:
3426   18F4 FA FA FF      lea d, [bp + -6] ; $i
3427   18F7 2A            mov b, [d]
3428   18F8 38 00 00      mov c, 0
3429   18FB             ; --- START RELATIONAL
3430   18FB D7            push a
3431   18FC 11            mov a, b
3432   18FD FD 2E 00 00   mov32 cb, $00000000
3432   1901 00 00 
3433   1903 B0            cmp a, b
3434   1904 FD 7F         sgt ; >
3435   1906 E4            pop a
3436   1907             ; --- END RELATIONAL
3437   1907 C0 00 00      cmp b, 0
3438   190A C6 59 19      je _while47_exit
3439   190D             _while47_block:
3440   190D             ; i--; 
3441   190D FA FA FF      lea d, [bp + -6] ; $i
3442   1910 2A            mov b, [d]
3443   1911 38 00 00      mov c, 0
3444   1914 FD 7D         dec b
3445   1916 FA FA FF      lea d, [bp + -6] ; $i
3446   1919 FD 43         mov [d], b
3447   191B FD 77         inc b
3448   191D             ; *dest++ = digits[i]; 
3449   191D FA 05 00      lea d, [bp + 5] ; $dest
3450   1920 2A            mov b, [d]
3451   1921 38 00 00      mov c, 0
3452   1924 FD 77         inc b
3453   1926 FA 05 00      lea d, [bp + 5] ; $dest
3454   1929 FD 43         mov [d], b
3455   192B FD 7D         dec b
3456   192D D8            push b
3457   192E FA FC FF      lea d, [bp + -4] ; $digits
3458   1931 D7            push a
3459   1932 DA            push d
3460   1933 FA FA FF      lea d, [bp + -6] ; $i
3461   1936 2A            mov b, [d]
3462   1937 38 00 00      mov c, 0
3463   193A E7            pop d
3464   193B 5A            add d, b
3465   193C E4            pop a
3466   193D 32            mov bl, [d]
3467   193E A7 00         mov bh, 0
3468   1940 38 00 00      mov c, 0
3469   1943 E7            pop d
3470   1944 FD 3E         mov [d], bl
3471   1946             ; len++; 
3472   1946 FA F8 FF      lea d, [bp + -8] ; $len
3473   1949 2A            mov b, [d]
3474   194A 38 00 00      mov c, 0
3475   194D FD 77         inc b
3476   194F FA F8 FF      lea d, [bp + -8] ; $len
3477   1952 FD 43         mov [d], b
3478   1954 FD 7D         dec b
3479   1956 0A F4 18      jmp _while47_cond
3480   1959             _while47_exit:
3481   1959             ; *dest = '\0'; 
3482   1959 FA 05 00      lea d, [bp + 5] ; $dest
3483   195C 2A            mov b, [d]
3484   195D 38 00 00      mov c, 0
3485   1960 D8            push b
3486   1961 FD 2E 00 00   mov32 cb, $00000000
3486   1965 00 00 
3487   1967 E7            pop d
3488   1968 FD 3E         mov [d], bl
3489   196A             ; return len; 
3490   196A FA F8 FF      lea d, [bp + -8] ; $len
3491   196D 2A            mov b, [d]
3492   196E 38 00 00      mov c, 0
3493   1971 F9            leave
3494   1972 09            ret
3495   1973             
3496   1973             print_unsigned:
3497   1973 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3498   1976             ; char digits[5]; 
3499   1976 52 05 00      sub sp, 5
3500   1979             ; int i; 
3501   1979 52 02 00      sub sp, 2
3502   197C             ; i = 0; 
3503   197C FA FA FF      lea d, [bp + -6] ; $i
3504   197F DA            push d
3505   1980 FD 2E 00 00   mov32 cb, $00000000
3505   1984 00 00 
3506   1986 E7            pop d
3507   1987 FD 43         mov [d], b
3508   1989             ; if(num == 0){ 
3509   1989             _if48_cond:
3510   1989 FA 05 00      lea d, [bp + 5] ; $num
3511   198C 2A            mov b, [d]
3512   198D 38 00 00      mov c, 0
3513   1990             ; --- START RELATIONAL
3514   1990 D7            push a
3515   1991 11            mov a, b
3516   1992 FD 2E 00 00   mov32 cb, $00000000
3516   1996 00 00 
3517   1998 B0            cmp a, b
3518   1999 FD 71         seq ; ==
3519   199B E4            pop a
3520   199C             ; --- END RELATIONAL
3521   199C C0 00 00      cmp b, 0
3522   199F C6 B4 19      je _if48_exit
3523   19A2             _if48_true:
3524   19A2             ; putchar('0'); 
3525   19A2             ; --- START FUNCTION CALL
3526   19A2 FD 2E 30 00   mov32 cb, $00000030
3526   19A6 00 00 
3527   19A8 DD            push bl
3528   19A9 07 3B 1C      call putchar
3529   19AC 51 01 00      add sp, 1
3530   19AF             ; --- END FUNCTION CALL
3531   19AF             ; return; 
3532   19AF F9            leave
3533   19B0 09            ret
3534   19B1 0A B4 19      jmp _if48_exit
3535   19B4             _if48_exit:
3536   19B4             ; while (num > 0) { 
3537   19B4             _while49_cond:
3538   19B4 FA 05 00      lea d, [bp + 5] ; $num
3539   19B7 2A            mov b, [d]
3540   19B8 38 00 00      mov c, 0
3541   19BB             ; --- START RELATIONAL
3542   19BB D7            push a
3543   19BC 11            mov a, b
3544   19BD FD 2E 00 00   mov32 cb, $00000000
3544   19C1 00 00 
3545   19C3 B0            cmp a, b
3546   19C4 FD 81         sgu ; > (unsigned)
3547   19C6 E4            pop a
3548   19C7             ; --- END RELATIONAL
3549   19C7 C0 00 00      cmp b, 0
3550   19CA C6 29 1A      je _while49_exit
3551   19CD             _while49_block:
3552   19CD             ; digits[i] = '0' + (num % 10); 
3553   19CD FA FC FF      lea d, [bp + -4] ; $digits
3554   19D0 D7            push a
3555   19D1 DA            push d
3556   19D2 FA FA FF      lea d, [bp + -6] ; $i
3557   19D5 2A            mov b, [d]
3558   19D6 38 00 00      mov c, 0
3559   19D9 E7            pop d
3560   19DA 5A            add d, b
3561   19DB E4            pop a
3562   19DC DA            push d
3563   19DD FD 2E 30 00   mov32 cb, $00000030
3563   19E1 00 00 
3564   19E3             ; --- START TERMS
3565   19E3 D7            push a
3566   19E4 11            mov a, b
3567   19E5 FA 05 00      lea d, [bp + 5] ; $num
3568   19E8 2A            mov b, [d]
3569   19E9 38 00 00      mov c, 0
3570   19EC             ; --- START FACTORS
3571   19EC D7            push a
3572   19ED 11            mov a, b
3573   19EE FD 2E 0A 00   mov32 cb, $0000000a
3573   19F2 00 00 
3574   19F4 AE            div a, b ; 
3575   19F5 11            mov a, b
3576   19F6 27            mov b, a
3577   19F7 E4            pop a
3578   19F8             ; --- END FACTORS
3579   19F8 56            add b, a
3580   19F9 E4            pop a
3581   19FA             ; --- END TERMS
3582   19FA E7            pop d
3583   19FB FD 3E         mov [d], bl
3584   19FD             ; num = num / 10; 
3585   19FD FA 05 00      lea d, [bp + 5] ; $num
3586   1A00 DA            push d
3587   1A01 FA 05 00      lea d, [bp + 5] ; $num
3588   1A04 2A            mov b, [d]
3589   1A05 38 00 00      mov c, 0
3590   1A08             ; --- START FACTORS
3591   1A08 D7            push a
3592   1A09 11            mov a, b
3593   1A0A FD 2E 0A 00   mov32 cb, $0000000a
3593   1A0E 00 00 
3594   1A10 AE            div a, b
3595   1A11 27            mov b, a
3596   1A12 E4            pop a
3597   1A13             ; --- END FACTORS
3598   1A13 E7            pop d
3599   1A14 FD 43         mov [d], b
3600   1A16             ; i++; 
3601   1A16 FA FA FF      lea d, [bp + -6] ; $i
3602   1A19 2A            mov b, [d]
3603   1A1A 38 00 00      mov c, 0
3604   1A1D FD 77         inc b
3605   1A1F FA FA FF      lea d, [bp + -6] ; $i
3606   1A22 FD 43         mov [d], b
3607   1A24 FD 7D         dec b
3608   1A26 0A B4 19      jmp _while49_cond
3609   1A29             _while49_exit:
3610   1A29             ; while (i > 0) { 
3611   1A29             _while50_cond:
3612   1A29 FA FA FF      lea d, [bp + -6] ; $i
3613   1A2C 2A            mov b, [d]
3614   1A2D 38 00 00      mov c, 0
3615   1A30             ; --- START RELATIONAL
3616   1A30 D7            push a
3617   1A31 11            mov a, b
3618   1A32 FD 2E 00 00   mov32 cb, $00000000
3618   1A36 00 00 
3619   1A38 B0            cmp a, b
3620   1A39 FD 7F         sgt ; >
3621   1A3B E4            pop a
3622   1A3C             ; --- END RELATIONAL
3623   1A3C C0 00 00      cmp b, 0
3624   1A3F C6 71 1A      je _while50_exit
3625   1A42             _while50_block:
3626   1A42             ; i--; 
3627   1A42 FA FA FF      lea d, [bp + -6] ; $i
3628   1A45 2A            mov b, [d]
3629   1A46 38 00 00      mov c, 0
3630   1A49 FD 7D         dec b
3631   1A4B FA FA FF      lea d, [bp + -6] ; $i
3632   1A4E FD 43         mov [d], b
3633   1A50 FD 77         inc b
3634   1A52             ; putchar(digits[i]); 
3635   1A52             ; --- START FUNCTION CALL
3636   1A52 FA FC FF      lea d, [bp + -4] ; $digits
3637   1A55 D7            push a
3638   1A56 DA            push d
3639   1A57 FA FA FF      lea d, [bp + -6] ; $i
3640   1A5A 2A            mov b, [d]
3641   1A5B 38 00 00      mov c, 0
3642   1A5E E7            pop d
3643   1A5F 5A            add d, b
3644   1A60 E4            pop a
3645   1A61 32            mov bl, [d]
3646   1A62 A7 00         mov bh, 0
3647   1A64 38 00 00      mov c, 0
3648   1A67 DD            push bl
3649   1A68 07 3B 1C      call putchar
3650   1A6B 51 01 00      add sp, 1
3651   1A6E             ; --- END FUNCTION CALL
3652   1A6E 0A 29 1A      jmp _while50_cond
3653   1A71             _while50_exit:
3654   1A71 F9            leave
3655   1A72 09            ret
3656   1A73             
3657   1A73             sprint_signed:
3658   1A73 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3659   1A76             ; char digits[5]; 
3660   1A76 52 05 00      sub sp, 5
3661   1A79             ; int i = 0; 
3662   1A79 52 02 00      sub sp, 2
3663   1A7C             ; --- START LOCAL VAR INITIALIZATION
3664   1A7C FA FA FF      lea d, [bp + -6] ; $i
3665   1A7F DA            push d
3666   1A80 FD 2E 00 00   mov32 cb, $00000000
3666   1A84 00 00 
3667   1A86 E7            pop d
3668   1A87 FD 43         mov [d], b
3669   1A89             ; --- END LOCAL VAR INITIALIZATION
3670   1A89             ; int len = 0; 
3671   1A89 52 02 00      sub sp, 2
3672   1A8C             ; --- START LOCAL VAR INITIALIZATION
3673   1A8C FA F8 FF      lea d, [bp + -8] ; $len
3674   1A8F DA            push d
3675   1A90 FD 2E 00 00   mov32 cb, $00000000
3675   1A94 00 00 
3676   1A96 E7            pop d
3677   1A97 FD 43         mov [d], b
3678   1A99             ; --- END LOCAL VAR INITIALIZATION
3679   1A99             ; if (num < 0) { 
3680   1A99             _if51_cond:
3681   1A99 FA 07 00      lea d, [bp + 7] ; $num
3682   1A9C 2A            mov b, [d]
3683   1A9D 38 00 00      mov c, 0
3684   1AA0             ; --- START RELATIONAL
3685   1AA0 D7            push a
3686   1AA1 11            mov a, b
3687   1AA2 FD 2E 00 00   mov32 cb, $00000000
3687   1AA6 00 00 
3688   1AA8 B0            cmp a, b
3689   1AA9 FD 73         slt ; < (signed)
3690   1AAB E4            pop a
3691   1AAC             ; --- END RELATIONAL
3692   1AAC C0 00 00      cmp b, 0
3693   1AAF C6 EF 1A      je _if51_else
3694   1AB2             _if51_true:
3695   1AB2             ; *dest++ = '-'; 
3696   1AB2 FA 05 00      lea d, [bp + 5] ; $dest
3697   1AB5 2A            mov b, [d]
3698   1AB6 38 00 00      mov c, 0
3699   1AB9 FD 77         inc b
3700   1ABB FA 05 00      lea d, [bp + 5] ; $dest
3701   1ABE FD 43         mov [d], b
3702   1AC0 FD 7D         dec b
3703   1AC2 D8            push b
3704   1AC3 FD 2E 2D 00   mov32 cb, $0000002d
3704   1AC7 00 00 
3705   1AC9 E7            pop d
3706   1ACA FD 3E         mov [d], bl
3707   1ACC             ; num = -num; 
3708   1ACC FA 07 00      lea d, [bp + 7] ; $num
3709   1ACF DA            push d
3710   1AD0 FA 07 00      lea d, [bp + 7] ; $num
3711   1AD3 2A            mov b, [d]
3712   1AD4 38 00 00      mov c, 0
3713   1AD7 FD 97         neg b
3714   1AD9 E7            pop d
3715   1ADA FD 43         mov [d], b
3716   1ADC             ; len++; 
3717   1ADC FA F8 FF      lea d, [bp + -8] ; $len
3718   1ADF 2A            mov b, [d]
3719   1AE0 38 00 00      mov c, 0
3720   1AE3 FD 77         inc b
3721   1AE5 FA F8 FF      lea d, [bp + -8] ; $len
3722   1AE8 FD 43         mov [d], b
3723   1AEA FD 7D         dec b
3724   1AEC 0A 3E 1B      jmp _if51_exit
3725   1AEF             _if51_else:
3726   1AEF             ; if (num == 0) { 
3727   1AEF             _if52_cond:
3728   1AEF FA 07 00      lea d, [bp + 7] ; $num
3729   1AF2 2A            mov b, [d]
3730   1AF3 38 00 00      mov c, 0
3731   1AF6             ; --- START RELATIONAL
3732   1AF6 D7            push a
3733   1AF7 11            mov a, b
3734   1AF8 FD 2E 00 00   mov32 cb, $00000000
3734   1AFC 00 00 
3735   1AFE B0            cmp a, b
3736   1AFF FD 71         seq ; ==
3737   1B01 E4            pop a
3738   1B02             ; --- END RELATIONAL
3739   1B02 C0 00 00      cmp b, 0
3740   1B05 C6 3E 1B      je _if52_exit
3741   1B08             _if52_true:
3742   1B08             ; *dest++ = '0'; 
3743   1B08 FA 05 00      lea d, [bp + 5] ; $dest
3744   1B0B 2A            mov b, [d]
3745   1B0C 38 00 00      mov c, 0
3746   1B0F FD 77         inc b
3747   1B11 FA 05 00      lea d, [bp + 5] ; $dest
3748   1B14 FD 43         mov [d], b
3749   1B16 FD 7D         dec b
3750   1B18 D8            push b
3751   1B19 FD 2E 30 00   mov32 cb, $00000030
3751   1B1D 00 00 
3752   1B1F E7            pop d
3753   1B20 FD 3E         mov [d], bl
3754   1B22             ; *dest = '\0'; 
3755   1B22 FA 05 00      lea d, [bp + 5] ; $dest
3756   1B25 2A            mov b, [d]
3757   1B26 38 00 00      mov c, 0
3758   1B29 D8            push b
3759   1B2A FD 2E 00 00   mov32 cb, $00000000
3759   1B2E 00 00 
3760   1B30 E7            pop d
3761   1B31 FD 3E         mov [d], bl
3762   1B33             ; return 1; 
3763   1B33 FD 2E 01 00   mov32 cb, $00000001
3763   1B37 00 00 
3764   1B39 F9            leave
3765   1B3A 09            ret
3766   1B3B 0A 3E 1B      jmp _if52_exit
3767   1B3E             _if52_exit:
3768   1B3E             _if51_exit:
3769   1B3E             ; while (num > 0) { 
3770   1B3E             _while53_cond:
3771   1B3E FA 07 00      lea d, [bp + 7] ; $num
3772   1B41 2A            mov b, [d]
3773   1B42 38 00 00      mov c, 0
3774   1B45             ; --- START RELATIONAL
3775   1B45 D7            push a
3776   1B46 11            mov a, b
3777   1B47 FD 2E 00 00   mov32 cb, $00000000
3777   1B4B 00 00 
3778   1B4D B0            cmp a, b
3779   1B4E FD 7F         sgt ; >
3780   1B50 E4            pop a
3781   1B51             ; --- END RELATIONAL
3782   1B51 C0 00 00      cmp b, 0
3783   1B54 C6 B3 1B      je _while53_exit
3784   1B57             _while53_block:
3785   1B57             ; digits[i] = '0' + (num % 10); 
3786   1B57 FA FC FF      lea d, [bp + -4] ; $digits
3787   1B5A D7            push a
3788   1B5B DA            push d
3789   1B5C FA FA FF      lea d, [bp + -6] ; $i
3790   1B5F 2A            mov b, [d]
3791   1B60 38 00 00      mov c, 0
3792   1B63 E7            pop d
3793   1B64 5A            add d, b
3794   1B65 E4            pop a
3795   1B66 DA            push d
3796   1B67 FD 2E 30 00   mov32 cb, $00000030
3796   1B6B 00 00 
3797   1B6D             ; --- START TERMS
3798   1B6D D7            push a
3799   1B6E 11            mov a, b
3800   1B6F FA 07 00      lea d, [bp + 7] ; $num
3801   1B72 2A            mov b, [d]
3802   1B73 38 00 00      mov c, 0
3803   1B76             ; --- START FACTORS
3804   1B76 D7            push a
3805   1B77 11            mov a, b
3806   1B78 FD 2E 0A 00   mov32 cb, $0000000a
3806   1B7C 00 00 
3807   1B7E AE            div a, b ; 
3808   1B7F 11            mov a, b
3809   1B80 27            mov b, a
3810   1B81 E4            pop a
3811   1B82             ; --- END FACTORS
3812   1B82 56            add b, a
3813   1B83 E4            pop a
3814   1B84             ; --- END TERMS
3815   1B84 E7            pop d
3816   1B85 FD 3E         mov [d], bl
3817   1B87             ; num = num / 10; 
3818   1B87 FA 07 00      lea d, [bp + 7] ; $num
3819   1B8A DA            push d
3820   1B8B FA 07 00      lea d, [bp + 7] ; $num
3821   1B8E 2A            mov b, [d]
3822   1B8F 38 00 00      mov c, 0
3823   1B92             ; --- START FACTORS
3824   1B92 D7            push a
3825   1B93 11            mov a, b
3826   1B94 FD 2E 0A 00   mov32 cb, $0000000a
3826   1B98 00 00 
3827   1B9A AE            div a, b
3828   1B9B 27            mov b, a
3829   1B9C E4            pop a
3830   1B9D             ; --- END FACTORS
3831   1B9D E7            pop d
3832   1B9E FD 43         mov [d], b
3833   1BA0             ; i++; 
3834   1BA0 FA FA FF      lea d, [bp + -6] ; $i
3835   1BA3 2A            mov b, [d]
3836   1BA4 38 00 00      mov c, 0
3837   1BA7 FD 77         inc b
3838   1BA9 FA FA FF      lea d, [bp + -6] ; $i
3839   1BAC FD 43         mov [d], b
3840   1BAE FD 7D         dec b
3841   1BB0 0A 3E 1B      jmp _while53_cond
3842   1BB3             _while53_exit:
3843   1BB3             ; while (i > 0) { 
3844   1BB3             _while54_cond:
3845   1BB3 FA FA FF      lea d, [bp + -6] ; $i
3846   1BB6 2A            mov b, [d]
3847   1BB7 38 00 00      mov c, 0
3848   1BBA             ; --- START RELATIONAL
3849   1BBA D7            push a
3850   1BBB 11            mov a, b
3851   1BBC FD 2E 00 00   mov32 cb, $00000000
3851   1BC0 00 00 
3852   1BC2 B0            cmp a, b
3853   1BC3 FD 7F         sgt ; >
3854   1BC5 E4            pop a
3855   1BC6             ; --- END RELATIONAL
3856   1BC6 C0 00 00      cmp b, 0
3857   1BC9 C6 18 1C      je _while54_exit
3858   1BCC             _while54_block:
3859   1BCC             ; i--; 
3860   1BCC FA FA FF      lea d, [bp + -6] ; $i
3861   1BCF 2A            mov b, [d]
3862   1BD0 38 00 00      mov c, 0
3863   1BD3 FD 7D         dec b
3864   1BD5 FA FA FF      lea d, [bp + -6] ; $i
3865   1BD8 FD 43         mov [d], b
3866   1BDA FD 77         inc b
3867   1BDC             ; *dest++ = digits[i]; 
3868   1BDC FA 05 00      lea d, [bp + 5] ; $dest
3869   1BDF 2A            mov b, [d]
3870   1BE0 38 00 00      mov c, 0
3871   1BE3 FD 77         inc b
3872   1BE5 FA 05 00      lea d, [bp + 5] ; $dest
3873   1BE8 FD 43         mov [d], b
3874   1BEA FD 7D         dec b
3875   1BEC D8            push b
3876   1BED FA FC FF      lea d, [bp + -4] ; $digits
3877   1BF0 D7            push a
3878   1BF1 DA            push d
3879   1BF2 FA FA FF      lea d, [bp + -6] ; $i
3880   1BF5 2A            mov b, [d]
3881   1BF6 38 00 00      mov c, 0
3882   1BF9 E7            pop d
3883   1BFA 5A            add d, b
3884   1BFB E4            pop a
3885   1BFC 32            mov bl, [d]
3886   1BFD A7 00         mov bh, 0
3887   1BFF 38 00 00      mov c, 0
3888   1C02 E7            pop d
3889   1C03 FD 3E         mov [d], bl
3890   1C05             ; len++; 
3891   1C05 FA F8 FF      lea d, [bp + -8] ; $len
3892   1C08 2A            mov b, [d]
3893   1C09 38 00 00      mov c, 0
3894   1C0C FD 77         inc b
3895   1C0E FA F8 FF      lea d, [bp + -8] ; $len
3896   1C11 FD 43         mov [d], b
3897   1C13 FD 7D         dec b
3898   1C15 0A B3 1B      jmp _while54_cond
3899   1C18             _while54_exit:
3900   1C18             ; *dest = '\0'; 
3901   1C18 FA 05 00      lea d, [bp + 5] ; $dest
3902   1C1B 2A            mov b, [d]
3903   1C1C 38 00 00      mov c, 0
3904   1C1F D8            push b
3905   1C20 FD 2E 00 00   mov32 cb, $00000000
3905   1C24 00 00 
3906   1C26 E7            pop d
3907   1C27 FD 3E         mov [d], bl
3908   1C29             ; return len; 
3909   1C29 FA F8 FF      lea d, [bp + -8] ; $len
3910   1C2C 2A            mov b, [d]
3911   1C2D 38 00 00      mov c, 0
3912   1C30 F9            leave
3913   1C31 09            ret
3914   1C32             
3915   1C32             date:
3916   1C32 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3917   1C35             
3918   1C35             ; --- BEGIN INLINE ASM SEGMENT
3919   1C35 19 00         mov al, 0 
3920   1C37 05 07         syscall sys_datetime
3921   1C39             ; --- END INLINE ASM SEGMENT
3922   1C39             
3923   1C39 F9            leave
3924   1C3A 09            ret
3925   1C3B             
3926   1C3B             putchar:
3927   1C3B F8 00 00      enter 0 ; (push bp; mov bp, sp)
3928   1C3E             
3929   1C3E             ; --- BEGIN INLINE ASM SEGMENT
3930   1C3E FA 05 00      lea d, [bp + 5] ; $c
3931   1C41 1E            mov al, [d]
3932   1C42 23            mov ah, al
3933   1C43 07 4A 1E      call _putchar
3934   1C46             ; --- END INLINE ASM SEGMENT
3935   1C46             
3936   1C46 F9            leave
3937   1C47 09            ret
3938   1C48             
3939   1C48             getchar:
3940   1C48 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3941   1C4B             ; char c; 
3942   1C4B 52 01 00      sub sp, 1
3943   1C4E             
3944   1C4E             ; --- BEGIN INLINE ASM SEGMENT
3945   1C4E 07 43 1E      call getch
3946   1C51 1A            mov al, ah
3947   1C52 FA 00 00      lea d, [bp + 0] ; $c
3948   1C55 3E            mov [d], al
3949   1C56             ; --- END INLINE ASM SEGMENT
3950   1C56             
3951   1C56             ; return c; 
3952   1C56 FA 00 00      lea d, [bp + 0] ; $c
3953   1C59 32            mov bl, [d]
3954   1C5A A7 00         mov bh, 0
3955   1C5C 38 00 00      mov c, 0
3956   1C5F F9            leave
3957   1C60 09            ret
3958   1C61             
3959   1C61             scann:
3960   1C61 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3961   1C64             ; int m; 
3962   1C64 52 02 00      sub sp, 2
3963   1C67             
3964   1C67             ; --- BEGIN INLINE ASM SEGMENT
3965   1C67 07 8E 20      call scan_u16d
3966   1C6A FA FF FF      lea d, [bp + -1] ; $m
3967   1C6D 43            mov [d], a
3968   1C6E             ; --- END INLINE ASM SEGMENT
3969   1C6E             
3970   1C6E             ; return m; 
3971   1C6E FA FF FF      lea d, [bp + -1] ; $m
3972   1C71 2A            mov b, [d]
3973   1C72 38 00 00      mov c, 0
3974   1C75 F9            leave
3975   1C76 09            ret
3976   1C77             
3977   1C77             puts:
3978   1C77 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3979   1C7A             
3980   1C7A             ; --- BEGIN INLINE ASM SEGMENT
3981   1C7A FA 05 00      lea d, [bp + 5] ; $s
3982   1C7D 15            mov a, [d]
3983   1C7E 3C            mov d, a
3984   1C7F 07 94 1F      call _puts
3985   1C82 10 00 0A      mov a, $0A00
3986   1C85 05 03         syscall sys_io
3987   1C87             ; --- END INLINE ASM SEGMENT
3988   1C87             
3989   1C87 F9            leave
3990   1C88 09            ret
3991   1C89             
3992   1C89             print:
3993   1C89 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3994   1C8C             
3995   1C8C             ; --- BEGIN INLINE ASM SEGMENT
3996   1C8C FA 05 00      lea d, [bp + 5] ; $s
3997   1C8F FD 2A         mov d, [d]
3998   1C91 07 94 1F      call _puts
3999   1C94             ; --- END INLINE ASM SEGMENT
4000   1C94             
4001   1C94 F9            leave
4002   1C95 09            ret
4003   1C96             
4004   1C96             getparam:
4005   1C96 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4006   1C99             ; char data; 
4007   1C99 52 01 00      sub sp, 1
4008   1C9C             
4009   1C9C             ; --- BEGIN INLINE ASM SEGMENT
4010   1C9C 19 04         mov al, 4
4011   1C9E FA 05 00      lea d, [bp + 5] ; $address
4012   1CA1 FD 2A         mov d, [d]
4013   1CA3 05 0C         syscall sys_system
4014   1CA5 FA 00 00      lea d, [bp + 0] ; $data
4015   1CA8 FD 3E         mov [d], bl
4016   1CAA             ; --- END INLINE ASM SEGMENT
4017   1CAA             
4018   1CAA             ; return data; 
4019   1CAA FA 00 00      lea d, [bp + 0] ; $data
4020   1CAD 32            mov bl, [d]
4021   1CAE A7 00         mov bh, 0
4022   1CB0 38 00 00      mov c, 0
4023   1CB3 F9            leave
4024   1CB4 09            ret
4025   1CB5             
4026   1CB5             clear:
4027   1CB5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4028   1CB8             ; print("\033[2J\033[H"); 
4029   1CB8             ; --- START FUNCTION CALL
4030   1CB8 26 2A 21      mov b, _s2 ; "\033[2J\033[H"
4031   1CBB FD AB         swp b
4032   1CBD D8            push b
4033   1CBE 07 89 1C      call print
4034   1CC1 51 02 00      add sp, 2
4035   1CC4             ; --- END FUNCTION CALL
4036   1CC4 F9            leave
4037   1CC5 09            ret
4038   1CC6             
4039   1CC6             abs:
4040   1CC6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4041   1CC9             ; return i < 0 ? -i : i; 
4042   1CC9             _ternary55_cond:
4043   1CC9 FA 05 00      lea d, [bp + 5] ; $i
4044   1CCC 2A            mov b, [d]
4045   1CCD 38 00 00      mov c, 0
4046   1CD0             ; --- START RELATIONAL
4047   1CD0 D7            push a
4048   1CD1 11            mov a, b
4049   1CD2 FD 2E 00 00   mov32 cb, $00000000
4049   1CD6 00 00 
4050   1CD8 B0            cmp a, b
4051   1CD9 FD 73         slt ; < (signed)
4052   1CDB E4            pop a
4053   1CDC             ; --- END RELATIONAL
4054   1CDC C0 00 00      cmp b, 0
4055   1CDF C6 EE 1C      je _ternary55_false
4056   1CE2             _ternary55_true:
4057   1CE2 FA 05 00      lea d, [bp + 5] ; $i
4058   1CE5 2A            mov b, [d]
4059   1CE6 38 00 00      mov c, 0
4060   1CE9 FD 97         neg b
4061   1CEB 0A F5 1C      jmp _ternary55_exit
4062   1CEE             _ternary55_false:
4063   1CEE FA 05 00      lea d, [bp + 5] ; $i
4064   1CF1 2A            mov b, [d]
4065   1CF2 38 00 00      mov c, 0
4066   1CF5             _ternary55_exit:
4067   1CF5 F9            leave
4068   1CF6 09            ret
4069   1CF7             
4070   1CF7             loadfile:
4071   1CF7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4072   1CFA             
4073   1CFA             ; --- BEGIN INLINE ASM SEGMENT
4074   1CFA FA 07 00      lea d, [bp + 7] ; $destination
4075   1CFD 15            mov a, [d]
4076   1CFE 4F            mov di, a
4077   1CFF FA 05 00      lea d, [bp + 5] ; $filename
4078   1D02 FD 2A         mov d, [d]
4079   1D04 19 14         mov al, 20
4080   1D06 05 04         syscall sys_filesystem
4081   1D08             ; --- END INLINE ASM SEGMENT
4082   1D08             
4083   1D08 F9            leave
4084   1D09 09            ret
4085   1D0A             
4086   1D0A             create_file:
4087   1D0A F8 00 00      enter 0 ; (push bp; mov bp, sp)
4088   1D0D F9            leave
4089   1D0E 09            ret
4090   1D0F             
4091   1D0F             delete_file:
4092   1D0F F8 00 00      enter 0 ; (push bp; mov bp, sp)
4093   1D12             
4094   1D12             ; --- BEGIN INLINE ASM SEGMENT
4095   1D12 FA 05 00      lea d, [bp + 5] ; $filename
4096   1D15 19 0A         mov al, 10
4097   1D17 05 04         syscall sys_filesystem
4098   1D19             ; --- END INLINE ASM SEGMENT
4099   1D19             
4100   1D19 F9            leave
4101   1D1A 09            ret
4102   1D1B             
4103   1D1B             load_hex:
4104   1D1B F8 00 00      enter 0 ; (push bp; mov bp, sp)
4105   1D1E             ; char *temp; 
4106   1D1E 52 02 00      sub sp, 2
4107   1D21             ; temp = alloc(32768); 
4108   1D21 FA FF FF      lea d, [bp + -1] ; $temp
4109   1D24 DA            push d
4110   1D25             ; --- START FUNCTION CALL
4111   1D25 FD 2E 00 80   mov32 cb, $00008000
4111   1D29 00 00 
4112   1D2B FD AB         swp b
4113   1D2D D8            push b
4114   1D2E 07 3D 08      call alloc
4115   1D31 51 02 00      add sp, 2
4116   1D34             ; --- END FUNCTION CALL
4117   1D34 E7            pop d
4118   1D35 FD 43         mov [d], b
4119   1D37             
4120   1D37             ; --- BEGIN INLINE ASM SEGMENT
4121   1D37               
4122   1D37               
4123   1D37               
4124   1D37             _load_hex:
4125   1D37 FA 05 00      lea d, [bp + 5] ; $destination
4126   1D3A FD 2A         mov d, [d]
4127   1D3C FD 50         mov di, d
4128   1D3E FA FF FF      lea d, [bp + -1] ; $temp
4129   1D41 FD 2A         mov d, [d]
4130   1D43 38 00 00      mov c, 0
4131   1D46 48            mov a, sp
4132   1D47 77            inc a
4133   1D48 3C            mov d, a          
4134   1D49 07 51 1E      call _gets        
4135   1D4C 4D            mov si, a
4136   1D4D             __load_hex_loop:
4137   1D4D F6            lodsb             
4138   1D4E B9 00         cmp al, 0         
4139   1D50 C6 5E 1D      jz __load_hex_ret
4140   1D53 36            mov bh, al
4141   1D54 F6            lodsb
4142   1D55 2F            mov bl, al
4143   1D56 07 08 1E      call _atoi        
4144   1D59 F7            stosb             
4145   1D5A 78            inc c
4146   1D5B 0A 4D 1D      jmp __load_hex_loop
4147   1D5E             __load_hex_ret:
4148   1D5E             ; --- END INLINE ASM SEGMENT
4149   1D5E             
4150   1D5E F9            leave
4151   1D5F 09            ret
4152   1D60             
4153   1D60             include_stdio_asm:
4154   1D60 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4155   1D63             
4156   1D63             ; --- BEGIN INLINE ASM SEGMENT
4157   1D63             .include "lib/asm/stdio.asm"
0001+  1D63             ;-----------------------------------------------------------------------------
0002+  1D63             ; stdio.s
0003+  1D63             ;-----------------------------------------------------------------------------
0004+  1D63             .include "lib/asm/string.asm"
0001++ 1D63             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 1D63             ; string.s
0003++ 1D63             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 1D63             
0005++ 1D63             
0006++ 1D63             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 1D63             ; _strrev
0008++ 1D63             ; reverse a string
0009++ 1D63             ; D = string address
0010++ 1D63             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 1D63             ; 01234
0012++ 1D63             _strrev:
0013++ 1D63 4B          	pusha
0014++ 1D64 07 AA 1D    	call _strlen	; length in C
0015++ 1D67 12          	mov a, c
0016++ 1D68 AF 01 00    	cmp a, 1
0017++ 1D6B D0 85 1D    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 1D6E 7D          	dec a
0019++ 1D6F FD 4E       	mov si, d	; beginning of string
0020++ 1D71 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 1D73 59          	add d, a	; end of string
0022++ 1D74 12          	mov a, c
0023++ 1D75 FD 9B       	shr a		; divide by 2
0024++ 1D77 39          	mov c, a	; C now counts the steps
0025++ 1D78             _strrev_L0:
0026++ 1D78 32          	mov bl, [d]	; save load right-side char into BL
0027++ 1D79 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 1D7A 3E          	mov [d], al	; store left char into right side
0029++ 1D7B 1B          	mov al, bl
0030++ 1D7C F7          	stosb		; store right-side char into left-side; increase DI
0031++ 1D7D 7E          	dec c
0032++ 1D7E 7F          	dec d
0033++ 1D7F C2 00 00    	cmp c, 0
0034++ 1D82 C7 78 1D    	jne _strrev_L0
0035++ 1D85             _strrev_end:
0036++ 1D85 4C          	popa
0037++ 1D86 09          	ret
0038++ 1D87             	
0039++ 1D87             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 1D87             ; _strchr
0041++ 1D87             ; search string in D for char in AL
0042++ 1D87             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 1D87             _strchr:
0044++ 1D87             _strchr_L0:
0045++ 1D87 32          	mov bl, [d]
0046++ 1D88 C1 00       	cmp bl, 0
0047++ 1D8A C6 95 1D    	je _strchr_end
0048++ 1D8D BA          	cmp al, bl
0049++ 1D8E C6 95 1D    	je _strchr_end
0050++ 1D91 79          	inc d
0051++ 1D92 0A 87 1D    	jmp _strchr_L0
0052++ 1D95             _strchr_end:
0053++ 1D95 1B          	mov al, bl
0054++ 1D96 09          	ret
0055++ 1D97             
0056++ 1D97             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 1D97             ; _strstr
0058++ 1D97             ; find sub-string
0059++ 1D97             ; str1 in SI
0060++ 1D97             ; str2 in DI
0061++ 1D97             ; SI points to end of source string
0062++ 1D97             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 1D97             _strstr:
0064++ 1D97 DB          	push al
0065++ 1D98 DA          	push d
0066++ 1D99 E3          	push di
0067++ 1D9A             _strstr_loop:
0068++ 1D9A F3          	cmpsb					; compare a byte of the strings
0069++ 1D9B C7 A6 1D    	jne _strstr_ret
0070++ 1D9E FC 00 00    	lea d, [di + 0]
0071++ 1DA1 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1DA3 C7 9A 1D    	jne _strstr_loop				; equal chars but not at end
0073++ 1DA6             _strstr_ret:
0074++ 1DA6 F0          	pop di
0075++ 1DA7 E7          	pop d
0076++ 1DA8 E8          	pop al
0077++ 1DA9 09          	ret
0078++ 1DAA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1DAA             ; length of null terminated string
0080++ 1DAA             ; result in C
0081++ 1DAA             ; pointer in D
0082++ 1DAA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1DAA             _strlen:
0084++ 1DAA DA          	push d
0085++ 1DAB 38 00 00    	mov c, 0
0086++ 1DAE             _strlen_L1:
0087++ 1DAE BD 00       	cmp byte [d], 0
0088++ 1DB0 C6 B8 1D    	je _strlen_ret
0089++ 1DB3 79          	inc d
0090++ 1DB4 78          	inc c
0091++ 1DB5 0A AE 1D    	jmp _strlen_L1
0092++ 1DB8             _strlen_ret:
0093++ 1DB8 E7          	pop d
0094++ 1DB9 09          	ret
0095++ 1DBA             
0096++ 1DBA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1DBA             ; STRCMP
0098++ 1DBA             ; compare two strings
0099++ 1DBA             ; str1 in SI
0100++ 1DBA             ; str2 in DI
0101++ 1DBA             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 1DBA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1DBA             _strcmp:
0104++ 1DBA DB          	push al
0105++ 1DBB DA          	push d
0106++ 1DBC E3          	push di
0107++ 1DBD E2          	push si
0108++ 1DBE             _strcmp_loop:
0109++ 1DBE F3          	cmpsb					; compare a byte of the strings
0110++ 1DBF C7 CA 1D    	jne _strcmp_ret
0111++ 1DC2 FB FF FF    	lea d, [si +- 1]
0112++ 1DC5 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1DC7 C7 BE 1D    	jne _strcmp_loop				; equal chars but not at end
0114++ 1DCA             _strcmp_ret:
0115++ 1DCA EF          	pop si
0116++ 1DCB F0          	pop di
0117++ 1DCC E7          	pop d
0118++ 1DCD E8          	pop al
0119++ 1DCE 09          	ret
0120++ 1DCF             
0121++ 1DCF             
0122++ 1DCF             ; STRCPY
0123++ 1DCF             ; copy null terminated string from SI to DI
0124++ 1DCF             ; source in SI
0125++ 1DCF             ; destination in DI
0126++ 1DCF             _strcpy:
0127++ 1DCF E2          	push si
0128++ 1DD0 E3          	push di
0129++ 1DD1 DB          	push al
0130++ 1DD2             _strcpy_L1:
0131++ 1DD2 F6          	lodsb
0132++ 1DD3 F7          	stosb
0133++ 1DD4 B9 00       	cmp al, 0
0134++ 1DD6 C7 D2 1D    	jne _strcpy_L1
0135++ 1DD9             _strcpy_end:
0136++ 1DD9 E8          	pop al
0137++ 1DDA F0          	pop di
0138++ 1DDB EF          	pop si
0139++ 1DDC 09          	ret
0140++ 1DDD             
0141++ 1DDD             ; STRCAT
0142++ 1DDD             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 1DDD             ; source in SI
0144++ 1DDD             ; destination in DI
0145++ 1DDD             _strcat:
0146++ 1DDD E2          	push si
0147++ 1DDE E3          	push di
0148++ 1DDF D7          	push a
0149++ 1DE0 DA          	push d
0150++ 1DE1 50          	mov a, di
0151++ 1DE2 3C          	mov d, a
0152++ 1DE3             _strcat_goto_end_L1:
0153++ 1DE3 BD 00       	cmp byte[d], 0
0154++ 1DE5 C6 EC 1D    	je _strcat_start
0155++ 1DE8 79          	inc d
0156++ 1DE9 0A E3 1D    	jmp _strcat_goto_end_L1
0157++ 1DEC             _strcat_start:
0158++ 1DEC FD 50       	mov di, d
0159++ 1DEE             _strcat_L1:
0160++ 1DEE F6          	lodsb
0161++ 1DEF F7          	stosb
0162++ 1DF0 B9 00       	cmp al, 0
0163++ 1DF2 C7 EE 1D    	jne _strcat_L1
0164++ 1DF5             _strcat_end:
0165++ 1DF5 E7          	pop d
0166++ 1DF6 E4          	pop a
0167++ 1DF7 F0          	pop di
0168++ 1DF8 EF          	pop si
0169++ 1DF9 09          	ret
0170++ 1DFA             
0171++ 1DFA             
0005+  1DFA             
0006+  1DFA             ;-----------------------------------------------------------------------------
0007+  1DFA             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0008+  1DFA             ; ASCII in BL
0009+  1DFA             ; result in AL
0010+  1DFA             ; ascii for F = 0100 0110
0011+  1DFA             ; ascii for 9 = 0011 1001
0012+  1DFA             ;-----------------------------------------------------------------------------
0013+  1DFA             hex_ascii_encode:
0014+  1DFA 1B            mov al, bl
0015+  1DFB 93 40         test al, $40        ; test if letter or number
0016+  1DFD C7 03 1E      jnz hex_letter
0017+  1E00 87 0F         and al, $0F        ; get number
0018+  1E02 09            ret
0019+  1E03             hex_letter:
0020+  1E03 87 0F         and al, $0F        ; get letter
0021+  1E05 6A 09         add al, 9
0022+  1E07 09            ret
0023+  1E08             
0024+  1E08             ;-----------------------------------------------------------------------------
0025+  1E08             ; ATOI
0026+  1E08             ; 2 letter hex string in B
0027+  1E08             ; 8bit integer returned in AL
0028+  1E08             ;-----------------------------------------------------------------------------
0029+  1E08             _atoi:
0030+  1E08 D8            push b
0031+  1E09 07 FA 1D      call hex_ascii_encode      ; convert BL to 4bit code in AL
0032+  1E0C 30            mov bl, bh
0033+  1E0D DB            push al          ; save a
0034+  1E0E 07 FA 1D      call hex_ascii_encode
0035+  1E11 EA            pop bl  
0036+  1E12 FD 9E 04      shl al, 4
0037+  1E15 8C            or al, bl
0038+  1E16 E5            pop b
0039+  1E17 09            ret  
0040+  1E18             
0041+  1E18             
0042+  1E18             ;-----------------------------------------------------------------------------
0043+  1E18             ; ITOA
0044+  1E18             ; 8bit value in BL
0045+  1E18             ; 2 byte ASCII result in A
0046+  1E18             ;-----------------------------------------------------------------------------
0047+  1E18             _itoa:
0048+  1E18 DA            push d
0049+  1E19 D8            push b
0050+  1E1A A7 00         mov bh, 0
0051+  1E1C FD A4 04      shr bl, 4  
0052+  1E1F 74            mov d, b
0053+  1E20 1F C8 20      mov al, [d + s_hex_digits]
0054+  1E23 23            mov ah, al
0055+  1E24               
0056+  1E24 E5            pop b
0057+  1E25 D8            push b
0058+  1E26 A7 00         mov bh, 0
0059+  1E28 FD 87 0F      and bl, $0F
0060+  1E2B 74            mov d, b
0061+  1E2C 1F C8 20      mov al, [d + s_hex_digits]
0062+  1E2F E5            pop b
0063+  1E30 E7            pop d
0064+  1E31 09            ret
0065+  1E32             
0066+  1E32             ;-----------------------------------------------------------------------------
0067+  1E32             ; HEX STRING TO BINARY
0068+  1E32             ; di = destination address
0069+  1E32             ; si = source
0070+  1E32             ;-----------------------------------------------------------------------------
0071+  1E32             _hex_to_int:
0072+  1E32             _hex_to_int_L1:
0073+  1E32 F6            lodsb          ; load from [SI] to AL
0074+  1E33 B9 00         cmp al, 0        ; check if ASCII 0
0075+  1E35 C6 42 1E      jz _hex_to_int_ret
0076+  1E38 36            mov bh, al
0077+  1E39 F6            lodsb
0078+  1E3A 2F            mov bl, al
0079+  1E3B 07 08 1E      call _atoi        ; convert ASCII byte in B to int (to AL)
0080+  1E3E F7            stosb          ; store AL to [DI]
0081+  1E3F 0A 32 1E      jmp _hex_to_int_L1
0082+  1E42             _hex_to_int_ret:
0083+  1E42 09            ret    
0084+  1E43             
0085+  1E43             ;-----------------------------------------------------------------------------
0086+  1E43             ; GETCHAR
0087+  1E43             ; char in ah
0088+  1E43             ;-----------------------------------------------------------------------------
0089+  1E43             getch:
0090+  1E43 DB            push al
0091+  1E44             getch_retry:
0092+  1E44 19 01         mov al, 1
0093+  1E46 05 03         syscall sys_io      ; receive in AH
0094+  1E48 E8            pop al
0095+  1E49 09            ret
0096+  1E4A             
0097+  1E4A             ;-----------------------------------------------------------------------------
0098+  1E4A             ; PUTCHAR
0099+  1E4A             ; char in ah
0100+  1E4A             ;-----------------------------------------------------------------------------
0101+  1E4A             _putchar:
0102+  1E4A D7            push a
0103+  1E4B 19 00         mov al, 0
0104+  1E4D 05 03         syscall sys_io      ; char in AH
0105+  1E4F E4            pop a
0106+  1E50 09            ret
0107+  1E51             
0108+  1E51             ;-----------------------------------------------------------------------------
0109+  1E51             ;; INPUT A STRING
0110+  1E51             ;; terminates with null
0111+  1E51             ;; pointer in D
0112+  1E51             ;-----------------------------------------------------------------------------
0113+  1E51             _gets:
0114+  1E51 D7            push a
0115+  1E52 DA            push d
0116+  1E53             _gets_loop:
0117+  1E53 19 01         mov al, 1
0118+  1E55 05 03         syscall sys_io      ; receive in AH
0119+  1E57 B9 00         cmp al, 0        ; check error code (AL)
0120+  1E59 C6 53 1E      je _gets_loop      ; if no char received, retry
0121+  1E5C             
0122+  1E5C 76 1B         cmp ah, 27
0123+  1E5E C6 7F 1E      je _gets_ansi_esc
0124+  1E61 76 0A         cmp ah, $0A        ; LF
0125+  1E63 C6 EA 1E      je _gets_end
0126+  1E66 76 0D         cmp ah, $0D        ; CR
0127+  1E68 C6 EA 1E      je _gets_end
0128+  1E6B 76 5C         cmp ah, $5C        ; '\\'
0129+  1E6D C6 AB 1E      je _gets_escape
0130+  1E70               
0131+  1E70 76 08         cmp ah, $08      ; check for backspace
0132+  1E72 C6 7B 1E      je _gets_backspace
0133+  1E75             
0134+  1E75 1A            mov al, ah
0135+  1E76 3E            mov [d], al
0136+  1E77 79            inc d
0137+  1E78 0A 53 1E      jmp _gets_loop
0138+  1E7B             _gets_backspace:
0139+  1E7B 7F            dec d
0140+  1E7C 0A 53 1E      jmp _gets_loop
0141+  1E7F             _gets_ansi_esc:
0142+  1E7F 19 01         mov al, 1
0143+  1E81 05 03         syscall sys_io        ; receive in AH without echo
0144+  1E83 B9 00         cmp al, 0          ; check error code (AL)
0145+  1E85 C6 7F 1E      je _gets_ansi_esc    ; if no char received, retry
0146+  1E88 76 5B         cmp ah, '['
0147+  1E8A C7 53 1E      jne _gets_loop
0148+  1E8D             _gets_ansi_esc_2:
0149+  1E8D 19 01         mov al, 1
0150+  1E8F 05 03         syscall sys_io          ; receive in AH without echo
0151+  1E91 B9 00         cmp al, 0            ; check error code (AL)
0152+  1E93 C6 8D 1E      je _gets_ansi_esc_2  ; if no char received, retry
0153+  1E96 76 44         cmp ah, 'D'
0154+  1E98 C6 A3 1E      je _gets_left_arrow
0155+  1E9B 76 43         cmp ah, 'C'
0156+  1E9D C6 A7 1E      je _gets_right_arrow
0157+  1EA0 0A 53 1E      jmp _gets_loop
0158+  1EA3             _gets_left_arrow:
0159+  1EA3 7F            dec d
0160+  1EA4 0A 53 1E      jmp _gets_loop
0161+  1EA7             _gets_right_arrow:
0162+  1EA7 79            inc d
0163+  1EA8 0A 53 1E      jmp _gets_loop
0164+  1EAB             _gets_escape:
0165+  1EAB 19 01         mov al, 1
0166+  1EAD 05 03         syscall sys_io      ; receive in AH
0167+  1EAF B9 00         cmp al, 0        ; check error code (AL)
0168+  1EB1 C6 AB 1E      je _gets_escape      ; if no char received, retry
0169+  1EB4 76 6E         cmp ah, 'n'
0170+  1EB6 C6 D5 1E      je _gets_LF
0171+  1EB9 76 72         cmp ah, 'r'
0172+  1EBB C6 DC 1E      je _gets_CR
0173+  1EBE 76 30         cmp ah, '0'
0174+  1EC0 C6 E3 1E      je _gets_NULL
0175+  1EC3 76 5C         cmp ah, $5C  ; '\'
0176+  1EC5 C6 CE 1E      je _gets_slash
0177+  1EC8 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0178+  1EC9 3E            mov [d], al
0179+  1ECA 79            inc d
0180+  1ECB 0A 53 1E      jmp _gets_loop
0181+  1ECE             _gets_slash:
0182+  1ECE 19 5C         mov al, $5C
0183+  1ED0 3E            mov [d], al
0184+  1ED1 79            inc d
0185+  1ED2 0A 53 1E      jmp _gets_loop
0186+  1ED5             _gets_LF:
0187+  1ED5 19 0A         mov al, $0A
0188+  1ED7 3E            mov [d], al
0189+  1ED8 79            inc d
0190+  1ED9 0A 53 1E      jmp _gets_loop
0191+  1EDC             _gets_CR:
0192+  1EDC 19 0D         mov al, $0D
0193+  1EDE 3E            mov [d], al
0194+  1EDF 79            inc d
0195+  1EE0 0A 53 1E      jmp _gets_loop
0196+  1EE3             _gets_NULL:
0197+  1EE3 19 00         mov al, $00
0198+  1EE5 3E            mov [d], al
0199+  1EE6 79            inc d
0200+  1EE7 0A 53 1E      jmp _gets_loop
0201+  1EEA             _gets_end:
0202+  1EEA 19 00         mov al, 0
0203+  1EEC 3E            mov [d], al        ; terminate string
0204+  1EED E7            pop d
0205+  1EEE E4            pop a
0206+  1EEF 09            ret
0207+  1EF0             
0208+  1EF0             ;-----------------------------------------------------------------------------
0209+  1EF0             ;; INPUT TEXT
0210+  1EF0             ;; terminated with CTRL+D
0211+  1EF0             ;; pointer in D
0212+  1EF0             ;-----------------------------------------------------------------------------
0213+  1EF0             _gettxt:
0214+  1EF0 D7            push a
0215+  1EF1 DA            push d
0216+  1EF2             _gettxt_loop:
0217+  1EF2 19 01         mov al, 1
0218+  1EF4 05 03         syscall sys_io      ; receive in AH
0219+  1EF6 B9 00         cmp al, 0        ; check error code (AL)
0220+  1EF8 C6 F2 1E      je _gettxt_loop    ; if no char received, retry
0221+  1EFB 76 04         cmp ah, 4      ; EOT
0222+  1EFD C6 3B 1F      je _gettxt_end
0223+  1F00 76 08         cmp ah, $08      ; check for backspace
0224+  1F02 C6 37 1F      je _gettxt_backspace
0225+  1F05 76 5C         cmp ah, $5C        ; '\'
0226+  1F07 C6 10 1F      je _gettxt_escape
0227+  1F0A 1A            mov al, ah
0228+  1F0B 3E            mov [d], al
0229+  1F0C 79            inc d
0230+  1F0D 0A F2 1E      jmp _gettxt_loop
0231+  1F10             _gettxt_escape:
0232+  1F10 19 01         mov al, 1
0233+  1F12 05 03         syscall sys_io      ; receive in AH
0234+  1F14 B9 00         cmp al, 0        ; check error code (AL)
0235+  1F16 C6 10 1F      je _gettxt_escape    ; if no char received, retry
0236+  1F19 76 6E         cmp ah, 'n'
0237+  1F1B C6 29 1F      je _gettxt_LF
0238+  1F1E 76 72         cmp ah, 'r'
0239+  1F20 C6 30 1F      je _gettxt_CR
0240+  1F23 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0241+  1F24 3E            mov [d], al
0242+  1F25 79            inc d
0243+  1F26 0A F2 1E      jmp _gettxt_loop
0244+  1F29             _gettxt_LF:
0245+  1F29 19 0A         mov al, $0A
0246+  1F2B 3E            mov [d], al
0247+  1F2C 79            inc d
0248+  1F2D 0A F2 1E      jmp _gettxt_loop
0249+  1F30             _gettxt_CR:
0250+  1F30 19 0D         mov al, $0D
0251+  1F32 3E            mov [d], al
0252+  1F33 79            inc d
0253+  1F34 0A F2 1E      jmp _gettxt_loop
0254+  1F37             _gettxt_backspace:
0255+  1F37 7F            dec d
0256+  1F38 0A F2 1E      jmp _gettxt_loop
0257+  1F3B             _gettxt_end:
0258+  1F3B 19 00         mov al, 0
0259+  1F3D 3E            mov [d], al        ; terminate string
0260+  1F3E E7            pop d
0261+  1F3F E4            pop a
0262+  1F40 09            ret
0263+  1F41             
0264+  1F41             ;-----------------------------------------------------------------------------
0265+  1F41             ; PRINT NEW LINE
0266+  1F41             ;-----------------------------------------------------------------------------
0267+  1F41             printnl:
0268+  1F41 D7            push a
0269+  1F42 10 00 0A      mov a, $0A00
0270+  1F45 05 03         syscall sys_io
0271+  1F47 10 00 0D      mov a, $0D00
0272+  1F4A 05 03         syscall sys_io
0273+  1F4C E4            pop a
0274+  1F4D 09            ret
0275+  1F4E             
0276+  1F4E             ;-----------------------------------------------------------------------------
0277+  1F4E             ; _strtoint
0278+  1F4E             ; 4 digit hex string number in d
0279+  1F4E             ; integer returned in A
0280+  1F4E             ;-----------------------------------------------------------------------------
0281+  1F4E             _strtointx:
0282+  1F4E D8            push b
0283+  1F4F 32            mov bl, [d]
0284+  1F50 37            mov bh, bl
0285+  1F51 33 01 00      mov bl, [d + 1]
0286+  1F54 07 08 1E      call _atoi        ; convert to int in AL
0287+  1F57 23            mov ah, al        ; move to AH
0288+  1F58 33 02 00      mov bl, [d + 2]
0289+  1F5B 37            mov bh, bl
0290+  1F5C 33 03 00      mov bl, [d + 3]
0291+  1F5F 07 08 1E      call _atoi        ; convert to int in AL
0292+  1F62 E5            pop b
0293+  1F63 09            ret
0294+  1F64             
0295+  1F64             ;-----------------------------------------------------------------------------
0296+  1F64             ; _strtoint
0297+  1F64             ; 5 digit base10 string number in d
0298+  1F64             ; integer returned in A
0299+  1F64             ;-----------------------------------------------------------------------------
0300+  1F64             _strtoint:
0301+  1F64 E2            push si
0302+  1F65 D8            push b
0303+  1F66 D9            push c
0304+  1F67 DA            push d
0305+  1F68 07 AA 1D      call _strlen      ; get string length in C
0306+  1F6B 7E            dec c
0307+  1F6C FD 4E         mov si, d
0308+  1F6E 12            mov a, c
0309+  1F6F FD 99         shl a
0310+  1F71 3B E0 20      mov d, table_power
0311+  1F74 59            add d, a
0312+  1F75 38 00 00      mov c, 0
0313+  1F78             _strtoint_L0:
0314+  1F78 F6            lodsb      ; load ASCII to al
0315+  1F79 B9 00         cmp al, 0
0316+  1F7B C6 8E 1F      je _strtoint_end
0317+  1F7E 6F 30         sub al, $30    ; make into integer
0318+  1F80 22 00         mov ah, 0
0319+  1F82 2A            mov b, [d]
0320+  1F83 AC            mul a, b      ; result in B since it fits in 16bits
0321+  1F84 11            mov a, b
0322+  1F85 28            mov b, c
0323+  1F86 54            add a, b
0324+  1F87 39            mov c, a
0325+  1F88 63 02 00      sub d, 2
0326+  1F8B 0A 78 1F      jmp _strtoint_L0
0327+  1F8E             _strtoint_end:
0328+  1F8E 12            mov a, c
0329+  1F8F E7            pop d
0330+  1F90 E6            pop c
0331+  1F91 E5            pop b
0332+  1F92 EF            pop si
0333+  1F93 09            ret
0334+  1F94             
0335+  1F94             ;-----------------------------------------------------------------------------
0336+  1F94             ; PRINT NULL TERMINATED STRING
0337+  1F94             ; pointer in D
0338+  1F94             ;-----------------------------------------------------------------------------
0339+  1F94             _puts:
0340+  1F94 D7            push a
0341+  1F95 DA            push d
0342+  1F96             _puts_L1:
0343+  1F96 1E            mov al, [d]
0344+  1F97 B9 00         cmp al, 0
0345+  1F99 C6 A5 1F      jz _puts_END
0346+  1F9C 23            mov ah, al
0347+  1F9D 19 00         mov al, 0
0348+  1F9F 05 03         syscall sys_io
0349+  1FA1 79            inc d
0350+  1FA2 0A 96 1F      jmp _puts_L1
0351+  1FA5             _puts_END:
0352+  1FA5 E7            pop d
0353+  1FA6 E4            pop a
0354+  1FA7 09            ret
0355+  1FA8             
0356+  1FA8             ;-----------------------------------------------------------------------------
0357+  1FA8             ; PRINT N SIZE STRING
0358+  1FA8             ; pointer in D
0359+  1FA8             ; size in C
0360+  1FA8             ;-----------------------------------------------------------------------------
0361+  1FA8             _putsn:
0362+  1FA8 DB            push al
0363+  1FA9 DA            push d
0364+  1FAA D9            push c
0365+  1FAB             _putsn_L0:
0366+  1FAB 1E            mov al, [d]
0367+  1FAC 23            mov ah, al
0368+  1FAD 19 00         mov al, 0
0369+  1FAF 05 03         syscall sys_io
0370+  1FB1 79            inc d
0371+  1FB2 7E            dec c  
0372+  1FB3 C2 00 00      cmp c, 0
0373+  1FB6 C7 AB 1F      jne _putsn_L0
0374+  1FB9             _putsn_end:
0375+  1FB9 E6            pop c
0376+  1FBA E7            pop d
0377+  1FBB E8            pop al
0378+  1FBC 09            ret
0379+  1FBD             
0380+  1FBD             ;-----------------------------------------------------------------------------
0381+  1FBD             ; print 16bit decimal number
0382+  1FBD             ; input number in A
0383+  1FBD             ;-----------------------------------------------------------------------------
0384+  1FBD             print_u16d:
0385+  1FBD D7            push a
0386+  1FBE D8            push b
0387+  1FBF 26 10 27      mov b, 10000
0388+  1FC2 AE            div a, b      ; get 10000's coeff.
0389+  1FC3 07 E5 1F      call print_number
0390+  1FC6 11            mov a, b
0391+  1FC7 26 E8 03      mov b, 1000
0392+  1FCA AE            div a, b      ; get 1000's coeff.
0393+  1FCB 07 E5 1F      call print_number
0394+  1FCE 11            mov a, b
0395+  1FCF 26 64 00      mov b, 100
0396+  1FD2 AE            div a, b
0397+  1FD3 07 E5 1F      call print_number
0398+  1FD6 11            mov a, b
0399+  1FD7 26 0A 00      mov b, 10
0400+  1FDA AE            div a, b
0401+  1FDB 07 E5 1F      call print_number
0402+  1FDE 1B            mov al, bl      ; 1's coeff in bl
0403+  1FDF 07 E5 1F      call print_number
0404+  1FE2 E5            pop b
0405+  1FE3 E4            pop a
0406+  1FE4 09            ret
0407+  1FE5             
0408+  1FE5             ;-----------------------------------------------------------------------------
0409+  1FE5             ; print AL
0410+  1FE5             ;-----------------------------------------------------------------------------
0411+  1FE5             print_number:
0412+  1FE5 6A 30         add al, $30
0413+  1FE7 23            mov ah, al
0414+  1FE8 07 4A 1E      call _putchar
0415+  1FEB 09            ret
0416+  1FEC             
0417+  1FEC             ;-----------------------------------------------------------------------------
0418+  1FEC             ; PRINT 16BIT HEX INTEGER
0419+  1FEC             ; integer value in reg B
0420+  1FEC             ;-----------------------------------------------------------------------------
0421+  1FEC             print_u16x:
0422+  1FEC D7            push a
0423+  1FED D8            push b
0424+  1FEE DD            push bl
0425+  1FEF 30            mov bl, bh
0426+  1FF0 07 18 1E      call _itoa        ; convert bh to char in A
0427+  1FF3 2F            mov bl, al        ; save al
0428+  1FF4 19 00         mov al, 0
0429+  1FF6 05 03         syscall sys_io        ; display AH
0430+  1FF8 24            mov ah, bl        ; retrieve al
0431+  1FF9 19 00         mov al, 0
0432+  1FFB 05 03         syscall sys_io        ; display AL
0433+  1FFD             
0434+  1FFD EA            pop bl
0435+  1FFE 07 18 1E      call _itoa        ; convert bh to char in A
0436+  2001 2F            mov bl, al        ; save al
0437+  2002 19 00         mov al, 0
0438+  2004 05 03         syscall sys_io        ; display AH
0439+  2006 24            mov ah, bl        ; retrieve al
0440+  2007 19 00         mov al, 0
0441+  2009 05 03         syscall sys_io        ; display AL
0442+  200B             
0443+  200B E5            pop b
0444+  200C E4            pop a
0445+  200D 09            ret
0446+  200E             
0447+  200E             ;-----------------------------------------------------------------------------
0448+  200E             ; INPUT 16BIT HEX INTEGER
0449+  200E             ; read 16bit integer into A
0450+  200E             ;-----------------------------------------------------------------------------
0451+  200E             scan_u16x:
0452+  200E F8 10 00      enter 16
0453+  2011 D8            push b
0454+  2012 DA            push d
0455+  2013             
0456+  2013 FA F1 FF      lea d, [bp + -15]
0457+  2016 07 51 1E      call _gets        ; get number
0458+  2019             
0459+  2019 32            mov bl, [d]
0460+  201A 37            mov bh, bl
0461+  201B 33 01 00      mov bl, [d + 1]
0462+  201E 07 08 1E      call _atoi        ; convert to int in AL
0463+  2021 23            mov ah, al        ; move to AH
0464+  2022             
0465+  2022 33 02 00      mov bl, [d + 2]
0466+  2025 37            mov bh, bl
0467+  2026 33 03 00      mov bl, [d + 3]
0468+  2029 07 08 1E      call _atoi        ; convert to int in AL
0469+  202C             
0470+  202C E7            pop d
0471+  202D E5            pop b
0472+  202E F9            leave
0473+  202F 09            ret
0474+  2030             
0475+  2030             ;-----------------------------------------------------------------------------
0476+  2030             ; PRINT 8bit HEX INTEGER
0477+  2030             ; integer value in reg bl
0478+  2030             ;-----------------------------------------------------------------------------
0479+  2030             print_u8x:
0480+  2030 D7            push a
0481+  2031 DD            push bl
0482+  2032             
0483+  2032 07 18 1E      call _itoa        ; convert bl to char in A
0484+  2035 2F            mov bl, al        ; save al
0485+  2036 19 00         mov al, 0
0486+  2038 05 03         syscall sys_io        ; display AH
0487+  203A 24            mov ah, bl        ; retrieve al
0488+  203B 19 00         mov al, 0
0489+  203D 05 03         syscall sys_io        ; display AL
0490+  203F             
0491+  203F EA            pop bl
0492+  2040 E4            pop a
0493+  2041 09            ret
0494+  2042             
0495+  2042             ;-----------------------------------------------------------------------------
0496+  2042             ; print 8bit decimal unsigned number
0497+  2042             ; input number in AL
0498+  2042             ;-----------------------------------------------------------------------------
0499+  2042             print_u8d:
0500+  2042 D7            push a
0501+  2043 D8            push b
0502+  2044             
0503+  2044 22 00         mov ah, 0
0504+  2046 26 64 00      mov b, 100
0505+  2049 AE            div a, b
0506+  204A D8            push b      ; save remainder
0507+  204B B9 00         cmp al, 0
0508+  204D C6 57 20      je skip100
0509+  2050 6A 30         add al, $30
0510+  2052 23            mov ah, al
0511+  2053 19 00         mov al, 0
0512+  2055 05 03         syscall sys_io  ; print coeff
0513+  2057             skip100:
0514+  2057 E4            pop a
0515+  2058 22 00         mov ah, 0
0516+  205A 26 0A 00      mov b, 10
0517+  205D AE            div a, b
0518+  205E D8            push b      ; save remainder
0519+  205F B9 00         cmp al, 0
0520+  2061 C6 6B 20      je skip10
0521+  2064 6A 30         add al, $30
0522+  2066 23            mov ah, al
0523+  2067 19 00         mov al, 0
0524+  2069 05 03         syscall sys_io  ; print coeff
0525+  206B             skip10:
0526+  206B E4            pop a
0527+  206C 1B            mov al, bl
0528+  206D 6A 30         add al, $30
0529+  206F 23            mov ah, al
0530+  2070 19 00         mov al, 0
0531+  2072 05 03         syscall sys_io  ; print coeff
0532+  2074 E5            pop b
0533+  2075 E4            pop a
0534+  2076 09            ret
0535+  2077             
0536+  2077             ;-----------------------------------------------------------------------------
0537+  2077             ; INPUT 8BIT HEX INTEGER
0538+  2077             ; read 8bit integer into AL
0539+  2077             ;-----------------------------------------------------------------------------
0540+  2077             scan_u8x:
0541+  2077 F8 04 00      enter 4
0542+  207A D8            push b
0543+  207B DA            push d
0544+  207C             
0545+  207C FA FD FF      lea d, [bp + -3]
0546+  207F 07 51 1E      call _gets        ; get number
0547+  2082             
0548+  2082 32            mov bl, [d]
0549+  2083 37            mov bh, bl
0550+  2084 33 01 00      mov bl, [d + 1]
0551+  2087 07 08 1E      call _atoi        ; convert to int in AL
0552+  208A             
0553+  208A E7            pop d
0554+  208B E5            pop b
0555+  208C F9            leave
0556+  208D 09            ret
0557+  208E             
0558+  208E             ;-----------------------------------------------------------------------------
0559+  208E             ; input decimal number
0560+  208E             ; result in A
0561+  208E             ; 655'\0'
0562+  208E             ; low--------high
0563+  208E             ;-----------------------------------------------------------------------------
0564+  208E             scan_u16d:
0565+  208E F8 08 00      enter 8
0566+  2091 E2            push si
0567+  2092 D8            push b
0568+  2093 D9            push c
0569+  2094 DA            push d
0570+  2095 FA F9 FF      lea d, [bp +- 7]
0571+  2098 07 51 1E      call _gets
0572+  209B 07 AA 1D      call _strlen      ; get string length in C
0573+  209E 7E            dec c
0574+  209F FD 4E         mov si, d
0575+  20A1 12            mov a, c
0576+  20A2 FD 99         shl a
0577+  20A4 3B E0 20      mov d, table_power
0578+  20A7 59            add d, a
0579+  20A8 38 00 00      mov c, 0
0580+  20AB             mul_loop:
0581+  20AB F6            lodsb      ; load ASCII to al
0582+  20AC B9 00         cmp al, 0
0583+  20AE C6 C1 20      je mul_exit
0584+  20B1 6F 30         sub al, $30    ; make into integer
0585+  20B3 22 00         mov ah, 0
0586+  20B5 2A            mov b, [d]
0587+  20B6 AC            mul a, b      ; result in B since it fits in 16bits
0588+  20B7 11            mov a, b
0589+  20B8 28            mov b, c
0590+  20B9 54            add a, b
0591+  20BA 39            mov c, a
0592+  20BB 63 02 00      sub d, 2
0593+  20BE 0A AB 20      jmp mul_loop
0594+  20C1             mul_exit:
0595+  20C1 12            mov a, c
0596+  20C2 E7            pop d
0597+  20C3 E6            pop c
0598+  20C4 E5            pop b
0599+  20C5 EF            pop si
0600+  20C6 F9            leave
0601+  20C7 09            ret
0602+  20C8             
0603+  20C8 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0603+  20CC 34 35 36 37 
0603+  20D0 38 39 41 42 
0603+  20D4 43 44 45 46 
0604+  20D8 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0604+  20DC 1B 5B 48 00 
0605+  20E0             
0606+  20E0             table_power:
0607+  20E0 01 00         .dw 1
0608+  20E2 0A 00         .dw 10
0609+  20E4 64 00         .dw 100
0610+  20E6 E8 03         .dw 1000
0611+  20E8 10 27         .dw 100004158   20EA             ; --- END INLINE ASM SEGMENT
4159   20EA             
4160   20EA F9            leave
4161   20EB 09            ret
4162   20EC             ; --- END TEXT SEGMENT
4163   20EC             
4164   20EC             ; --- BEGIN DATA SEGMENT
4165   20EC 00 00       st_fopen_max_handle: .dw 0
4166   20EE 55 6E 65 78 _s0: .db "Unexpected format in printf.", 0
4166   20F2 70 65 63 74 
4166   20F6 65 64 20 66 
4166   20FA 6F 72 6D 61 
4166   20FE 74 20 69 6E 
4166   2102 20 70 72 69 
4166   2106 6E 74 66 2E 
4166   210A 00 
4167   210B 45 72 72 6F _s1: .db "Error: Unknown argument type.\n", 0
4167   210F 72 3A 20 55 
4167   2113 6E 6B 6E 6F 
4167   2117 77 6E 20 61 
4167   211B 72 67 75 6D 
4167   211F 65 6E 74 20 
4167   2123 74 79 70 65 
4167   2127 2E 0A 00 
4168   212A 1B 5B 32 4A _s2: .db "\033[2J\033[H", 0
4168   212E 1B 5B 48 00 
4169   2132             
4170   2132 34 21       _heap_top: .dw _heap
4171   2134 00          _heap: .db 0
4172   2135             ; --- END DATA SEGMENT
4173   2135             
4174   2135             .end
tasm: Number of errors = 0
