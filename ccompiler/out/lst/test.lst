0001   0000             ; --- FILENAME: test
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ;; il0 = 0x80000000L; 
0011   0408 3B 4C 14      mov d, _il0 ; $il0
0012   040B DA            push d
0013   040C 26 00 00      mov b, 0
0014   040F 38 00 80      mov c, 32768
0015   0412 E7            pop d
0016   0413 FD 43         mov [d], b
0017   0415 28            mov b, c
0018   0416 FD 44 02 00   mov [d + 2], b
0019   041A             ;; il1 = 0x00000001L; 
0020   041A 3B 50 14      mov d, _il1 ; $il1
0021   041D DA            push d
0022   041E 26 01 00      mov b, 1
0023   0421 38 00 00      mov c, 0
0024   0424 E7            pop d
0025   0425 FD 43         mov [d], b
0026   0427 28            mov b, c
0027   0428 FD 44 02 00   mov [d + 2], b
0028   042C             ;; i0 = 0x8000; 
0029   042C 3B 54 14      mov d, _i0 ; $i0
0030   042F DA            push d
0031   0430 26 00 80      mov b, $8000
0032   0433 E7            pop d
0033   0434 FD 43         mov [d], b
0034   0436             ;; i1 = 0x0001; 
0035   0436 3B 56 14      mov d, _i1 ; $i1
0036   0439 DA            push d
0037   043A 26 01 00      mov b, $1
0038   043D E7            pop d
0039   043E FD 43         mov [d], b
0040   0440             ;; c0 = 'A'; 
0041   0440 3B 58 14      mov d, _c0 ; $c0
0042   0443 DA            push d
0043   0444 26 41 00      mov b, $41
0044   0447 E7            pop d
0045   0448 FD 3E         mov [d], bl
0046   044A             ;; c1 = 'Z'; 
0047   044A 3B 59 14      mov d, _c1 ; $c1
0048   044D DA            push d
0049   044E 26 5A 00      mov b, $5a
0050   0451 E7            pop d
0051   0452 FD 3E         mov [d], bl
0052   0454 05 0B         syscall sys_terminate_proc
0053   0456             
0054   0456             strcpy:
0055   0456 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0056   0459             ; $psrc 
0057   0459             ; $pdest 
0058   0459 52 04 00      sub sp, 4
0059   045C             ;; psrc = src; 
0060   045C FA FF FF      lea d, [bp + -1] ; $psrc
0061   045F DA            push d
0062   0460 FA 07 00      lea d, [bp + 7] ; $src
0063   0463 2A            mov b, [d]
0064   0464 E7            pop d
0065   0465 FD 43         mov [d], b
0066   0467             ;; pdest = dest; 
0067   0467 FA FD FF      lea d, [bp + -3] ; $pdest
0068   046A DA            push d
0069   046B FA 05 00      lea d, [bp + 5] ; $dest
0070   046E 2A            mov b, [d]
0071   046F E7            pop d
0072   0470 FD 43         mov [d], b
0073   0472             ;; while(*psrc) *pdest++ = *psrc++; 
0074   0472             _while1_cond:
0075   0472 FA FF FF      lea d, [bp + -1] ; $psrc
0076   0475 2A            mov b, [d]
0077   0476 74            mov d, b
0078   0477 32            mov bl, [d]
0079   0478 A7 00         mov bh, 0
0080   047A C0 00 00      cmp b, 0
0081   047D C6 A5 04      je _while1_exit
0082   0480             _while1_block:
0083   0480             ;; *pdest++ = *psrc++; 
0084   0480 FA FD FF      lea d, [bp + -3] ; $pdest
0085   0483 2A            mov b, [d]
0086   0484 D8            push b
0087   0485 FD 77         inc b
0088   0487 FA FD FF      lea d, [bp + -3] ; $pdest
0089   048A FD 43         mov [d], b
0090   048C E5            pop b
0091   048D D8            push b
0092   048E FA FF FF      lea d, [bp + -1] ; $psrc
0093   0491 2A            mov b, [d]
0094   0492 D8            push b
0095   0493 FD 77         inc b
0096   0495 FA FF FF      lea d, [bp + -1] ; $psrc
0097   0498 FD 43         mov [d], b
0098   049A E5            pop b
0099   049B 74            mov d, b
0100   049C 32            mov bl, [d]
0101   049D A7 00         mov bh, 0
0102   049F E7            pop d
0103   04A0 FD 3E         mov [d], bl
0104   04A2 0A 72 04      jmp _while1_cond
0105   04A5             _while1_exit:
0106   04A5             ;; *pdest = '\0'; 
0107   04A5 FA FD FF      lea d, [bp + -3] ; $pdest
0108   04A8 2A            mov b, [d]
0109   04A9 D8            push b
0110   04AA 26 00 00      mov b, $0
0111   04AD E7            pop d
0112   04AE FD 3E         mov [d], bl
0113   04B0 F9            leave
0114   04B1 09            ret
0115   04B2             
0116   04B2             strcmp:
0117   04B2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0118   04B5             ;; while (*s1 && (*s1 == *s2)) { 
0119   04B5             _while2_cond:
0120   04B5 FA 05 00      lea d, [bp + 5] ; $s1
0121   04B8 2A            mov b, [d]
0122   04B9 74            mov d, b
0123   04BA 32            mov bl, [d]
0124   04BB A7 00         mov bh, 0
0125   04BD D7            push a
0126   04BE 11            mov a, b
0127   04BF FA 05 00      lea d, [bp + 5] ; $s1
0128   04C2 2A            mov b, [d]
0129   04C3 74            mov d, b
0130   04C4 32            mov bl, [d]
0131   04C5 A7 00         mov bh, 0
0132   04C7             ; START RELATIONAL
0133   04C7 D7            push a
0134   04C8 11            mov a, b
0135   04C9 FA 07 00      lea d, [bp + 7] ; $s2
0136   04CC 2A            mov b, [d]
0137   04CD 74            mov d, b
0138   04CE 32            mov bl, [d]
0139   04CF A7 00         mov bh, 0
0140   04D1 B0            cmp a, b
0141   04D2 FD 71         seq ; ==
0142   04D4 E4            pop a
0143   04D5             ; END RELATIONAL
0144   04D5 FD A7         sand a, b
0145   04D7 E4            pop a
0146   04D8 C0 00 00      cmp b, 0
0147   04DB C6 FB 04      je _while2_exit
0148   04DE             _while2_block:
0149   04DE             ;; s1++; 
0150   04DE FA 05 00      lea d, [bp + 5] ; $s1
0151   04E1 2A            mov b, [d]
0152   04E2 D8            push b
0153   04E3 FD 77         inc b
0154   04E5 FA 05 00      lea d, [bp + 5] ; $s1
0155   04E8 FD 43         mov [d], b
0156   04EA E5            pop b
0157   04EB             ;; s2++; 
0158   04EB FA 07 00      lea d, [bp + 7] ; $s2
0159   04EE 2A            mov b, [d]
0160   04EF D8            push b
0161   04F0 FD 77         inc b
0162   04F2 FA 07 00      lea d, [bp + 7] ; $s2
0163   04F5 FD 43         mov [d], b
0164   04F7 E5            pop b
0165   04F8 0A B5 04      jmp _while2_cond
0166   04FB             _while2_exit:
0167   04FB             ;; return *s1 - *s2; 
0168   04FB FA 05 00      lea d, [bp + 5] ; $s1
0169   04FE 2A            mov b, [d]
0170   04FF 74            mov d, b
0171   0500 32            mov bl, [d]
0172   0501 A7 00         mov bh, 0
0173   0503             ; START TERMS
0174   0503 D7            push a
0175   0504 11            mov a, b
0176   0505 FA 07 00      lea d, [bp + 7] ; $s2
0177   0508 2A            mov b, [d]
0178   0509 74            mov d, b
0179   050A 32            mov bl, [d]
0180   050B A7 00         mov bh, 0
0181   050D 60            sub a, b
0182   050E 27            mov b, a
0183   050F E4            pop a
0184   0510             ; END TERMS
0185   0510 F9            leave
0186   0511 09            ret
0187   0512             
0188   0512             strcat:
0189   0512 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0190   0515             ; $dest_len 
0191   0515             ; $i 
0192   0515 52 04 00      sub sp, 4
0193   0518             ;; dest_len = strlen(dest); 
0194   0518 FA FF FF      lea d, [bp + -1] ; $dest_len
0195   051B DA            push d
0196   051C FA 05 00      lea d, [bp + 5] ; $dest
0197   051F 2A            mov b, [d]
0198   0520 FD AB         swp b
0199   0522 D8            push b
0200   0523 07 C5 05      call strlen
0201   0526 51 02 00      add sp, 2
0202   0529 E7            pop d
0203   052A FD 43         mov [d], b
0204   052C             ;; for (i = 0; src[i] != 0; i=i+1) { 
0205   052C             _for3_init:
0206   052C FA FD FF      lea d, [bp + -3] ; $i
0207   052F DA            push d
0208   0530 26 00 00      mov b, $0
0209   0533 E7            pop d
0210   0534 FD 43         mov [d], b
0211   0536             _for3_cond:
0212   0536 FA 07 00      lea d, [bp + 7] ; $src
0213   0539 FD 2A         mov d, [d]
0214   053B D7            push a
0215   053C DA            push d
0216   053D FA FD FF      lea d, [bp + -3] ; $i
0217   0540 2A            mov b, [d]
0218   0541 E7            pop d
0219   0542 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0220   0546 E4            pop a
0221   0547 32            mov bl, [d]
0222   0548 A7 00         mov bh, 0
0223   054A             ; START RELATIONAL
0224   054A D7            push a
0225   054B 11            mov a, b
0226   054C 26 00 00      mov b, $0
0227   054F B0            cmp a, b
0228   0550 FD 72         sneq ; !=
0229   0552 E4            pop a
0230   0553             ; END RELATIONAL
0231   0553 C0 00 00      cmp b, 0
0232   0556 C6 9F 05      je _for3_exit
0233   0559             _for3_block:
0234   0559             ;; dest[dest_len + i] = src[i]; 
0235   0559 FA 05 00      lea d, [bp + 5] ; $dest
0236   055C FD 2A         mov d, [d]
0237   055E D7            push a
0238   055F DA            push d
0239   0560 FA FF FF      lea d, [bp + -1] ; $dest_len
0240   0563 2A            mov b, [d]
0241   0564             ; START TERMS
0242   0564 D7            push a
0243   0565 11            mov a, b
0244   0566 FA FD FF      lea d, [bp + -3] ; $i
0245   0569 2A            mov b, [d]
0246   056A 56            add b, a
0247   056B E4            pop a
0248   056C             ; END TERMS
0249   056C E7            pop d
0250   056D FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0251   0571 E4            pop a
0252   0572 DA            push d
0253   0573 FA 07 00      lea d, [bp + 7] ; $src
0254   0576 FD 2A         mov d, [d]
0255   0578 D7            push a
0256   0579 DA            push d
0257   057A FA FD FF      lea d, [bp + -3] ; $i
0258   057D 2A            mov b, [d]
0259   057E E7            pop d
0260   057F FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0261   0583 E4            pop a
0262   0584 32            mov bl, [d]
0263   0585 A7 00         mov bh, 0
0264   0587 E7            pop d
0265   0588 FD 3E         mov [d], bl
0266   058A             _for3_update:
0267   058A FA FD FF      lea d, [bp + -3] ; $i
0268   058D DA            push d
0269   058E FA FD FF      lea d, [bp + -3] ; $i
0270   0591 2A            mov b, [d]
0271   0592             ; START TERMS
0272   0592 D7            push a
0273   0593 11            mov a, b
0274   0594 26 01 00      mov b, $1
0275   0597 56            add b, a
0276   0598 E4            pop a
0277   0599             ; END TERMS
0278   0599 E7            pop d
0279   059A FD 43         mov [d], b
0280   059C 0A 36 05      jmp _for3_cond
0281   059F             _for3_exit:
0282   059F             ;; dest[dest_len + i] = 0; 
0283   059F FA 05 00      lea d, [bp + 5] ; $dest
0284   05A2 FD 2A         mov d, [d]
0285   05A4 D7            push a
0286   05A5 DA            push d
0287   05A6 FA FF FF      lea d, [bp + -1] ; $dest_len
0288   05A9 2A            mov b, [d]
0289   05AA             ; START TERMS
0290   05AA D7            push a
0291   05AB 11            mov a, b
0292   05AC FA FD FF      lea d, [bp + -3] ; $i
0293   05AF 2A            mov b, [d]
0294   05B0 56            add b, a
0295   05B1 E4            pop a
0296   05B2             ; END TERMS
0297   05B2 E7            pop d
0298   05B3 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0299   05B7 E4            pop a
0300   05B8 DA            push d
0301   05B9 26 00 00      mov b, $0
0302   05BC E7            pop d
0303   05BD FD 3E         mov [d], bl
0304   05BF             ;; return dest; 
0305   05BF FA 05 00      lea d, [bp + 5] ; $dest
0306   05C2 2A            mov b, [d]
0307   05C3 F9            leave
0308   05C4 09            ret
0309   05C5             
0310   05C5             strlen:
0311   05C5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0312   05C8             ; $length 
0313   05C8 52 02 00      sub sp, 2
0314   05CB             ;; length = 0; 
0315   05CB FA FF FF      lea d, [bp + -1] ; $length
0316   05CE DA            push d
0317   05CF 26 00 00      mov b, $0
0318   05D2 E7            pop d
0319   05D3 FD 43         mov [d], b
0320   05D5             ;; while (str[length] != 0) { 
0321   05D5             _while4_cond:
0322   05D5 FA 05 00      lea d, [bp + 5] ; $str
0323   05D8 FD 2A         mov d, [d]
0324   05DA D7            push a
0325   05DB DA            push d
0326   05DC FA FF FF      lea d, [bp + -1] ; $length
0327   05DF 2A            mov b, [d]
0328   05E0 E7            pop d
0329   05E1 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0330   05E5 E4            pop a
0331   05E6 32            mov bl, [d]
0332   05E7 A7 00         mov bh, 0
0333   05E9             ; START RELATIONAL
0334   05E9 D7            push a
0335   05EA 11            mov a, b
0336   05EB 26 00 00      mov b, $0
0337   05EE B0            cmp a, b
0338   05EF FD 72         sneq ; !=
0339   05F1 E4            pop a
0340   05F2             ; END RELATIONAL
0341   05F2 C0 00 00      cmp b, 0
0342   05F5 C6 08 06      je _while4_exit
0343   05F8             _while4_block:
0344   05F8             ;; length++; 
0345   05F8 FA FF FF      lea d, [bp + -1] ; $length
0346   05FB 2A            mov b, [d]
0347   05FC D8            push b
0348   05FD FD 77         inc b
0349   05FF FA FF FF      lea d, [bp + -1] ; $length
0350   0602 FD 43         mov [d], b
0351   0604 E5            pop b
0352   0605 0A D5 05      jmp _while4_cond
0353   0608             _while4_exit:
0354   0608             ;; return length; 
0355   0608 FA FF FF      lea d, [bp + -1] ; $length
0356   060B 2A            mov b, [d]
0357   060C F9            leave
0358   060D 09            ret
0359   060E             
0360   060E             scanf:
0361   060E F8 00 00      enter 0 ; (push bp; mov bp, sp)
0362   0611             ; $p 
0363   0611             ; $format_p 
0364   0611             ; $c 
0365   0611             ; $i 
0366   0611             ; $input_string 
0367   0611 52 07 02      sub sp, 519
0368   0614             ;; format_p = format; 
0369   0614 FA FD FF      lea d, [bp + -3] ; $format_p
0370   0617 DA            push d
0371   0618 FA 05 00      lea d, [bp + 5] ; $format
0372   061B 2A            mov b, [d]
0373   061C E7            pop d
0374   061D FD 43         mov [d], b
0375   061F             ;; p = &format + 2; 
0376   061F FA FF FF      lea d, [bp + -1] ; $p
0377   0622 DA            push d
0378   0623 FA 05 00      lea d, [bp + 5] ; $format
0379   0626 2D            mov b, d
0380   0627             ; START TERMS
0381   0627 D7            push a
0382   0628 11            mov a, b
0383   0629 26 02 00      mov b, $2
0384   062C 56            add b, a
0385   062D E4            pop a
0386   062E             ; END TERMS
0387   062E E7            pop d
0388   062F FD 43         mov [d], b
0389   0631             ;; for(;;){ 
0390   0631             _for5_init:
0391   0631             _for5_cond:
0392   0631             _for5_block:
0393   0631             ;; if(!*format_p) break; 
0394   0631             _if6_cond:
0395   0631 FA FD FF      lea d, [bp + -3] ; $format_p
0396   0634 2A            mov b, [d]
0397   0635 74            mov d, b
0398   0636 32            mov bl, [d]
0399   0637 A7 00         mov bh, 0
0400   0639 C0 00 00      cmp b, 0
0401   063C FD 71         seq ; !
0402   063E C0 00 00      cmp b, 0
0403   0641 C6 4A 06      je _if6_else
0404   0644             _if6_true:
0405   0644             ;; break; 
0406   0644 0A 47 08      jmp _for5_exit ; for break
0407   0647 0A 44 08      jmp _if6_exit
0408   064A             _if6_else:
0409   064A             ;; if(*format_p == '%'){ 
0410   064A             _if7_cond:
0411   064A FA FD FF      lea d, [bp + -3] ; $format_p
0412   064D 2A            mov b, [d]
0413   064E 74            mov d, b
0414   064F 32            mov bl, [d]
0415   0650 A7 00         mov bh, 0
0416   0652             ; START RELATIONAL
0417   0652 D7            push a
0418   0653 11            mov a, b
0419   0654 26 25 00      mov b, $25
0420   0657 B0            cmp a, b
0421   0658 FD 71         seq ; ==
0422   065A E4            pop a
0423   065B             ; END RELATIONAL
0424   065B C0 00 00      cmp b, 0
0425   065E C6 28 08      je _if7_else
0426   0661             _if7_true:
0427   0661             ;; format_p++; 
0428   0661 FA FD FF      lea d, [bp + -3] ; $format_p
0429   0664 2A            mov b, [d]
0430   0665 D8            push b
0431   0666 FD 77         inc b
0432   0668 FA FD FF      lea d, [bp + -3] ; $format_p
0433   066B FD 43         mov [d], b
0434   066D E5            pop b
0435   066E             ;; switch(*format_p){ 
0436   066E             _switch8_expr:
0437   066E FA FD FF      lea d, [bp + -3] ; $format_p
0438   0671 2A            mov b, [d]
0439   0672 74            mov d, b
0440   0673 32            mov bl, [d]
0441   0674 A7 00         mov bh, 0
0442   0676             _switch8_comparisons:
0443   0676 C1 6C         cmp bl, $6c
0444   0678 C6 A4 06      je _switch8_case0
0445   067B C1 4C         cmp bl, $4c
0446   067D C6 A4 06      je _switch8_case1
0447   0680 C1 64         cmp bl, $64
0448   0682 C6 36 07      je _switch8_case2
0449   0685 C1 69         cmp bl, $69
0450   0687 C6 36 07      je _switch8_case3
0451   068A C1 75         cmp bl, $75
0452   068C C6 63 07      je _switch8_case4
0453   068F C1 78         cmp bl, $78
0454   0691 C6 90 07      je _switch8_case5
0455   0694 C1 63         cmp bl, $63
0456   0696 C6 A5 07      je _switch8_case6
0457   0699 C1 73         cmp bl, $73
0458   069B C6 D4 07      je _switch8_case7
0459   069E 0A 0C 08      jmp _switch8_default
0460   06A1 0A 18 08      jmp _switch8_exit
0461   06A4             _switch8_case0:
0462   06A4             _switch8_case1:
0463   06A4             ;; format_p++; 
0464   06A4 FA FD FF      lea d, [bp + -3] ; $format_p
0465   06A7 2A            mov b, [d]
0466   06A8 D8            push b
0467   06A9 FD 77         inc b
0468   06AB FA FD FF      lea d, [bp + -3] ; $format_p
0469   06AE FD 43         mov [d], b
0470   06B0 E5            pop b
0471   06B1             ;; if(*format_p == 'd' || *format_p == 'i'); 
0472   06B1             _if9_cond:
0473   06B1 FA FD FF      lea d, [bp + -3] ; $format_p
0474   06B4 2A            mov b, [d]
0475   06B5 74            mov d, b
0476   06B6 32            mov bl, [d]
0477   06B7 A7 00         mov bh, 0
0478   06B9             ; START RELATIONAL
0479   06B9 D7            push a
0480   06BA 11            mov a, b
0481   06BB 26 64 00      mov b, $64
0482   06BE B0            cmp a, b
0483   06BF FD 71         seq ; ==
0484   06C1 E4            pop a
0485   06C2             ; END RELATIONAL
0486   06C2 D7            push a
0487   06C3 11            mov a, b
0488   06C4 FA FD FF      lea d, [bp + -3] ; $format_p
0489   06C7 2A            mov b, [d]
0490   06C8 74            mov d, b
0491   06C9 32            mov bl, [d]
0492   06CA A7 00         mov bh, 0
0493   06CC             ; START RELATIONAL
0494   06CC D7            push a
0495   06CD 11            mov a, b
0496   06CE 26 69 00      mov b, $69
0497   06D1 B0            cmp a, b
0498   06D2 FD 71         seq ; ==
0499   06D4 E4            pop a
0500   06D5             ; END RELATIONAL
0501   06D5 FD A8         sor a, b ; ||
0502   06D7 E4            pop a
0503   06D8 C0 00 00      cmp b, 0
0504   06DB C6 E1 06      je _if9_else
0505   06DE             _if9_true:
0506   06DE             ;; ; 
0507   06DE 0A 21 07      jmp _if9_exit
0508   06E1             _if9_else:
0509   06E1             ;; if(*format_p == 'u'); 
0510   06E1             _if10_cond:
0511   06E1 FA FD FF      lea d, [bp + -3] ; $format_p
0512   06E4 2A            mov b, [d]
0513   06E5 74            mov d, b
0514   06E6 32            mov bl, [d]
0515   06E7 A7 00         mov bh, 0
0516   06E9             ; START RELATIONAL
0517   06E9 D7            push a
0518   06EA 11            mov a, b
0519   06EB 26 75 00      mov b, $75
0520   06EE B0            cmp a, b
0521   06EF FD 71         seq ; ==
0522   06F1 E4            pop a
0523   06F2             ; END RELATIONAL
0524   06F2 C0 00 00      cmp b, 0
0525   06F5 C6 FB 06      je _if10_else
0526   06F8             _if10_true:
0527   06F8             ;; ; 
0528   06F8 0A 21 07      jmp _if10_exit
0529   06FB             _if10_else:
0530   06FB             ;; if(*format_p == 'x'); 
0531   06FB             _if11_cond:
0532   06FB FA FD FF      lea d, [bp + -3] ; $format_p
0533   06FE 2A            mov b, [d]
0534   06FF 74            mov d, b
0535   0700 32            mov bl, [d]
0536   0701 A7 00         mov bh, 0
0537   0703             ; START RELATIONAL
0538   0703 D7            push a
0539   0704 11            mov a, b
0540   0705 26 78 00      mov b, $78
0541   0708 B0            cmp a, b
0542   0709 FD 71         seq ; ==
0543   070B E4            pop a
0544   070C             ; END RELATIONAL
0545   070C C0 00 00      cmp b, 0
0546   070F C6 15 07      je _if11_else
0547   0712             _if11_true:
0548   0712             ;; ; 
0549   0712 0A 21 07      jmp _if11_exit
0550   0715             _if11_else:
0551   0715             ;; err("Unexpected format in printf."); 
0552   0715 26 5A 14      mov b, __s0 ; "Unexpected format in printf."
0553   0718 FD AB         swp b
0554   071A D8            push b
0555   071B 07 90 0A      call err
0556   071E 51 02 00      add sp, 2
0557   0721             _if11_exit:
0558   0721             _if10_exit:
0559   0721             _if9_exit:
0560   0721             ;; p = p + 4; 
0561   0721 FA FF FF      lea d, [bp + -1] ; $p
0562   0724 DA            push d
0563   0725 FA FF FF      lea d, [bp + -1] ; $p
0564   0728 2A            mov b, [d]
0565   0729             ; START TERMS
0566   0729 D7            push a
0567   072A 11            mov a, b
0568   072B 26 04 00      mov b, $4
0569   072E 56            add b, a
0570   072F E4            pop a
0571   0730             ; END TERMS
0572   0730 E7            pop d
0573   0731 FD 43         mov [d], b
0574   0733             ;; break; 
0575   0733 0A 18 08      jmp _switch8_exit ; case break
0576   0736             _switch8_case2:
0577   0736             _switch8_case3:
0578   0736             ;; i = scann(); 
0579   0736 FA FA FF      lea d, [bp + -6] ; $i
0580   0739 DA            push d
0581   073A 07 61 10      call scann
0582   073D E7            pop d
0583   073E FD 43         mov [d], b
0584   0740             ;; **(int **)p = i; 
0585   0740 FA FF FF      lea d, [bp + -1] ; $p
0586   0743 2A            mov b, [d]
0587   0744 74            mov d, b
0588   0745 2A            mov b, [d]
0589   0746 D8            push b
0590   0747 FA FA FF      lea d, [bp + -6] ; $i
0591   074A 2A            mov b, [d]
0592   074B E7            pop d
0593   074C FD 43         mov [d], b
0594   074E             ;; p = p + 2; 
0595   074E FA FF FF      lea d, [bp + -1] ; $p
0596   0751 DA            push d
0597   0752 FA FF FF      lea d, [bp + -1] ; $p
0598   0755 2A            mov b, [d]
0599   0756             ; START TERMS
0600   0756 D7            push a
0601   0757 11            mov a, b
0602   0758 26 02 00      mov b, $2
0603   075B 56            add b, a
0604   075C E4            pop a
0605   075D             ; END TERMS
0606   075D E7            pop d
0607   075E FD 43         mov [d], b
0608   0760             ;; break; 
0609   0760 0A 18 08      jmp _switch8_exit ; case break
0610   0763             _switch8_case4:
0611   0763             ;; i = scann(); 
0612   0763 FA FA FF      lea d, [bp + -6] ; $i
0613   0766 DA            push d
0614   0767 07 61 10      call scann
0615   076A E7            pop d
0616   076B FD 43         mov [d], b
0617   076D             ;; **(int **)p = i; 
0618   076D FA FF FF      lea d, [bp + -1] ; $p
0619   0770 2A            mov b, [d]
0620   0771 74            mov d, b
0621   0772 2A            mov b, [d]
0622   0773 D8            push b
0623   0774 FA FA FF      lea d, [bp + -6] ; $i
0624   0777 2A            mov b, [d]
0625   0778 E7            pop d
0626   0779 FD 43         mov [d], b
0627   077B             ;; p = p + 2; 
0628   077B FA FF FF      lea d, [bp + -1] ; $p
0629   077E DA            push d
0630   077F FA FF FF      lea d, [bp + -1] ; $p
0631   0782 2A            mov b, [d]
0632   0783             ; START TERMS
0633   0783 D7            push a
0634   0784 11            mov a, b
0635   0785 26 02 00      mov b, $2
0636   0788 56            add b, a
0637   0789 E4            pop a
0638   078A             ; END TERMS
0639   078A E7            pop d
0640   078B FD 43         mov [d], b
0641   078D             ;; break; 
0642   078D 0A 18 08      jmp _switch8_exit ; case break
0643   0790             _switch8_case5:
0644   0790             ;; p = p + 2; 
0645   0790 FA FF FF      lea d, [bp + -1] ; $p
0646   0793 DA            push d
0647   0794 FA FF FF      lea d, [bp + -1] ; $p
0648   0797 2A            mov b, [d]
0649   0798             ; START TERMS
0650   0798 D7            push a
0651   0799 11            mov a, b
0652   079A 26 02 00      mov b, $2
0653   079D 56            add b, a
0654   079E E4            pop a
0655   079F             ; END TERMS
0656   079F E7            pop d
0657   07A0 FD 43         mov [d], b
0658   07A2             ;; break; 
0659   07A2 0A 18 08      jmp _switch8_exit ; case break
0660   07A5             _switch8_case6:
0661   07A5             ;; c = getchar(); 
0662   07A5 FA FC FF      lea d, [bp + -4] ; $c
0663   07A8 DA            push d
0664   07A9 07 4B 10      call getchar
0665   07AC E7            pop d
0666   07AD FD 3E         mov [d], bl
0667   07AF             ;; **(char **)p = c; 
0668   07AF FA FF FF      lea d, [bp + -1] ; $p
0669   07B2 2A            mov b, [d]
0670   07B3 74            mov d, b
0671   07B4 2A            mov b, [d]
0672   07B5 D8            push b
0673   07B6 FA FC FF      lea d, [bp + -4] ; $c
0674   07B9 32            mov bl, [d]
0675   07BA A7 00         mov bh, 0
0676   07BC E7            pop d
0677   07BD FD 43         mov [d], b
0678   07BF             ;; p = p + 2; 
0679   07BF FA FF FF      lea d, [bp + -1] ; $p
0680   07C2 DA            push d
0681   07C3 FA FF FF      lea d, [bp + -1] ; $p
0682   07C6 2A            mov b, [d]
0683   07C7             ; START TERMS
0684   07C7 D7            push a
0685   07C8 11            mov a, b
0686   07C9 26 02 00      mov b, $2
0687   07CC 56            add b, a
0688   07CD E4            pop a
0689   07CE             ; END TERMS
0690   07CE E7            pop d
0691   07CF FD 43         mov [d], b
0692   07D1             ;; break; 
0693   07D1 0A 18 08      jmp _switch8_exit ; case break
0694   07D4             _switch8_case7:
0695   07D4             ;; gets(input_string); 
0696   07D4 FA FA FD      lea d, [bp + -518] ; $input_string
0697   07D7 2D            mov b, d
0698   07D8 FD AB         swp b
0699   07DA D8            push b
0700   07DB 07 0F 0C      call gets
0701   07DE 51 02 00      add sp, 2
0702   07E1             ;; strcpy(*(char **)p, input_string); 
0703   07E1 FA FA FD      lea d, [bp + -518] ; $input_string
0704   07E4 2D            mov b, d
0705   07E5 FD AB         swp b
0706   07E7 D8            push b
0707   07E8 FA FF FF      lea d, [bp + -1] ; $p
0708   07EB 2A            mov b, [d]
0709   07EC 74            mov d, b
0710   07ED 2A            mov b, [d]
0711   07EE FD AB         swp b
0712   07F0 D8            push b
0713   07F1 07 56 04      call strcpy
0714   07F4 51 04 00      add sp, 4
0715   07F7             ;; p = p + 2; 
0716   07F7 FA FF FF      lea d, [bp + -1] ; $p
0717   07FA DA            push d
0718   07FB FA FF FF      lea d, [bp + -1] ; $p
0719   07FE 2A            mov b, [d]
0720   07FF             ; START TERMS
0721   07FF D7            push a
0722   0800 11            mov a, b
0723   0801 26 02 00      mov b, $2
0724   0804 56            add b, a
0725   0805 E4            pop a
0726   0806             ; END TERMS
0727   0806 E7            pop d
0728   0807 FD 43         mov [d], b
0729   0809             ;; break; 
0730   0809 0A 18 08      jmp _switch8_exit ; case break
0731   080C             _switch8_default:
0732   080C             ;; print("Error: Unknown argument type.\n"); 
0733   080C 26 77 14      mov b, __s1 ; "Error: Unknown argument type.\n"
0734   080F FD AB         swp b
0735   0811 D8            push b
0736   0812 07 86 10      call print
0737   0815 51 02 00      add sp, 2
0738   0818             _switch8_exit:
0739   0818             ;; format_p++; 
0740   0818 FA FD FF      lea d, [bp + -3] ; $format_p
0741   081B 2A            mov b, [d]
0742   081C D8            push b
0743   081D FD 77         inc b
0744   081F FA FD FF      lea d, [bp + -3] ; $format_p
0745   0822 FD 43         mov [d], b
0746   0824 E5            pop b
0747   0825 0A 44 08      jmp _if7_exit
0748   0828             _if7_else:
0749   0828             ;; putchar(*format_p); 
0750   0828 FA FD FF      lea d, [bp + -3] ; $format_p
0751   082B 2A            mov b, [d]
0752   082C 74            mov d, b
0753   082D 32            mov bl, [d]
0754   082E A7 00         mov bh, 0
0755   0830 DD            push bl
0756   0831 07 3E 10      call putchar
0757   0834 51 01 00      add sp, 1
0758   0837             ;; format_p++; 
0759   0837 FA FD FF      lea d, [bp + -3] ; $format_p
0760   083A 2A            mov b, [d]
0761   083B D8            push b
0762   083C FD 77         inc b
0763   083E FA FD FF      lea d, [bp + -3] ; $format_p
0764   0841 FD 43         mov [d], b
0765   0843 E5            pop b
0766   0844             _if7_exit:
0767   0844             _if6_exit:
0768   0844             _for5_update:
0769   0844 0A 31 06      jmp _for5_cond
0770   0847             _for5_exit:
0771   0847 F9            leave
0772   0848 09            ret
0773   0849             
0774   0849             printf:
0775   0849 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0776   084C             ; $p 
0777   084C             ; $format_p 
0778   084C 52 04 00      sub sp, 4
0779   084F             ;; format_p = format; 
0780   084F FA FD FF      lea d, [bp + -3] ; $format_p
0781   0852 DA            push d
0782   0853 FA 05 00      lea d, [bp + 5] ; $format
0783   0856 2A            mov b, [d]
0784   0857 E7            pop d
0785   0858 FD 43         mov [d], b
0786   085A             ;; p = &format + 2; 
0787   085A FA FF FF      lea d, [bp + -1] ; $p
0788   085D DA            push d
0789   085E FA 05 00      lea d, [bp + 5] ; $format
0790   0861 2D            mov b, d
0791   0862             ; START TERMS
0792   0862 D7            push a
0793   0863 11            mov a, b
0794   0864 26 02 00      mov b, $2
0795   0867 56            add b, a
0796   0868 E4            pop a
0797   0869             ; END TERMS
0798   0869 E7            pop d
0799   086A FD 43         mov [d], b
0800   086C             ;; for(;;){ 
0801   086C             _for12_init:
0802   086C             _for12_cond:
0803   086C             _for12_block:
0804   086C             ;; if(!*format_p) break; 
0805   086C             _if13_cond:
0806   086C FA FD FF      lea d, [bp + -3] ; $format_p
0807   086F 2A            mov b, [d]
0808   0870 74            mov d, b
0809   0871 32            mov bl, [d]
0810   0872 A7 00         mov bh, 0
0811   0874 C0 00 00      cmp b, 0
0812   0877 FD 71         seq ; !
0813   0879 C0 00 00      cmp b, 0
0814   087C C6 85 08      je _if13_else
0815   087F             _if13_true:
0816   087F             ;; break; 
0817   087F 0A 8E 0A      jmp _for12_exit ; for break
0818   0882 0A 8B 0A      jmp _if13_exit
0819   0885             _if13_else:
0820   0885             ;; if(*format_p == '%'){ 
0821   0885             _if14_cond:
0822   0885 FA FD FF      lea d, [bp + -3] ; $format_p
0823   0888 2A            mov b, [d]
0824   0889 74            mov d, b
0825   088A 32            mov bl, [d]
0826   088B A7 00         mov bh, 0
0827   088D             ; START RELATIONAL
0828   088D D7            push a
0829   088E 11            mov a, b
0830   088F 26 25 00      mov b, $25
0831   0892 B0            cmp a, b
0832   0893 FD 71         seq ; ==
0833   0895 E4            pop a
0834   0896             ; END RELATIONAL
0835   0896 C0 00 00      cmp b, 0
0836   0899 C6 6F 0A      je _if14_else
0837   089C             _if14_true:
0838   089C             ;; format_p++; 
0839   089C FA FD FF      lea d, [bp + -3] ; $format_p
0840   089F 2A            mov b, [d]
0841   08A0 D8            push b
0842   08A1 FD 77         inc b
0843   08A3 FA FD FF      lea d, [bp + -3] ; $format_p
0844   08A6 FD 43         mov [d], b
0845   08A8 E5            pop b
0846   08A9             ;; switch(*format_p){ 
0847   08A9             _switch15_expr:
0848   08A9 FA FD FF      lea d, [bp + -3] ; $format_p
0849   08AC 2A            mov b, [d]
0850   08AD 74            mov d, b
0851   08AE 32            mov bl, [d]
0852   08AF A7 00         mov bh, 0
0853   08B1             _switch15_comparisons:
0854   08B1 C1 6C         cmp bl, $6c
0855   08B3 C6 DF 08      je _switch15_case0
0856   08B6 C1 4C         cmp bl, $4c
0857   08B8 C6 DF 08      je _switch15_case1
0858   08BB C1 64         cmp bl, $64
0859   08BD C6 AF 09      je _switch15_case2
0860   08C0 C1 69         cmp bl, $69
0861   08C2 C6 AF 09      je _switch15_case3
0862   08C5 C1 75         cmp bl, $75
0863   08C7 C6 D3 09      je _switch15_case4
0864   08CA C1 78         cmp bl, $78
0865   08CC C6 F7 09      je _switch15_case5
0866   08CF C1 63         cmp bl, $63
0867   08D1 C6 15 0A      je _switch15_case6
0868   08D4 C1 73         cmp bl, $73
0869   08D6 C6 34 0A      je _switch15_case7
0870   08D9 0A 53 0A      jmp _switch15_default
0871   08DC 0A 5F 0A      jmp _switch15_exit
0872   08DF             _switch15_case0:
0873   08DF             _switch15_case1:
0874   08DF             ;; format_p++; 
0875   08DF FA FD FF      lea d, [bp + -3] ; $format_p
0876   08E2 2A            mov b, [d]
0877   08E3 D8            push b
0878   08E4 FD 77         inc b
0879   08E6 FA FD FF      lea d, [bp + -3] ; $format_p
0880   08E9 FD 43         mov [d], b
0881   08EB E5            pop b
0882   08EC             ;; if(*format_p == 'd' || *format_p == 'i') 
0883   08EC             _if16_cond:
0884   08EC FA FD FF      lea d, [bp + -3] ; $format_p
0885   08EF 2A            mov b, [d]
0886   08F0 74            mov d, b
0887   08F1 32            mov bl, [d]
0888   08F2 A7 00         mov bh, 0
0889   08F4             ; START RELATIONAL
0890   08F4 D7            push a
0891   08F5 11            mov a, b
0892   08F6 26 64 00      mov b, $64
0893   08F9 B0            cmp a, b
0894   08FA FD 71         seq ; ==
0895   08FC E4            pop a
0896   08FD             ; END RELATIONAL
0897   08FD D7            push a
0898   08FE 11            mov a, b
0899   08FF FA FD FF      lea d, [bp + -3] ; $format_p
0900   0902 2A            mov b, [d]
0901   0903 74            mov d, b
0902   0904 32            mov bl, [d]
0903   0905 A7 00         mov bh, 0
0904   0907             ; START RELATIONAL
0905   0907 D7            push a
0906   0908 11            mov a, b
0907   0909 26 69 00      mov b, $69
0908   090C B0            cmp a, b
0909   090D FD 71         seq ; ==
0910   090F E4            pop a
0911   0910             ; END RELATIONAL
0912   0910 FD A8         sor a, b ; ||
0913   0912 E4            pop a
0914   0913 C0 00 00      cmp b, 0
0915   0916 C6 2D 09      je _if16_else
0916   0919             _if16_true:
0917   0919             ;; print_signed_long(*(long *)p); 
0918   0919 FD 79         mov g, b
0919   091B 28            mov b, c
0920   091C FD AB         swp b
0921   091E D8            push b
0922   091F FD 27         mov b, g
0923   0921 FD AB         swp b
0924   0923 D8            push b
0925   0924 07 19 0D      call print_signed_long
0926   0927 51 04 00      add sp, 4
0927   092A 0A 9A 09      jmp _if16_exit
0928   092D             _if16_else:
0929   092D             ;; if(*format_p == 'u') 
0930   092D             _if17_cond:
0931   092D FA FD FF      lea d, [bp + -3] ; $format_p
0932   0930 2A            mov b, [d]
0933   0931 74            mov d, b
0934   0932 32            mov bl, [d]
0935   0933 A7 00         mov bh, 0
0936   0935             ; START RELATIONAL
0937   0935 D7            push a
0938   0936 11            mov a, b
0939   0937 26 75 00      mov b, $75
0940   093A B0            cmp a, b
0941   093B FD 71         seq ; ==
0942   093D E4            pop a
0943   093E             ; END RELATIONAL
0944   093E C0 00 00      cmp b, 0
0945   0941 C6 58 09      je _if17_else
0946   0944             _if17_true:
0947   0944             ;; print_unsigned_long(*(unsigned long *)p); 
0948   0944 FD 79         mov g, b
0949   0946 28            mov b, c
0950   0947 FD AB         swp b
0951   0949 D8            push b
0952   094A FD 27         mov b, g
0953   094C FD AB         swp b
0954   094E D8            push b
0955   094F 07 6F 0E      call print_unsigned_long
0956   0952 51 04 00      add sp, 4
0957   0955 0A 9A 09      jmp _if17_exit
0958   0958             _if17_else:
0959   0958             ;; if(*format_p == 'x') 
0960   0958             _if18_cond:
0961   0958 FA FD FF      lea d, [bp + -3] ; $format_p
0962   095B 2A            mov b, [d]
0963   095C 74            mov d, b
0964   095D 32            mov bl, [d]
0965   095E A7 00         mov bh, 0
0966   0960             ; START RELATIONAL
0967   0960 D7            push a
0968   0961 11            mov a, b
0969   0962 26 78 00      mov b, $78
0970   0965 B0            cmp a, b
0971   0966 FD 71         seq ; ==
0972   0968 E4            pop a
0973   0969             ; END RELATIONAL
0974   0969 C0 00 00      cmp b, 0
0975   096C C6 8E 09      je _if18_else
0976   096F             _if18_true:
0977   096F             ;; printx32(*(long int *)p); 
0978   096F FA FF FF      lea d, [bp + -1] ; $p
0979   0972 2A            mov b, [d]
0980   0973 74            mov d, b
0981   0974 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0982   0977 FD 39         mov c, b ; And place it into C
0983   0979 2A            mov b, [d] ; Lower Word in B
0984   097A FD 79         mov g, b
0985   097C 28            mov b, c
0986   097D FD AB         swp b
0987   097F D8            push b
0988   0980 FD 27         mov b, g
0989   0982 FD AB         swp b
0990   0984 D8            push b
0991   0985 07 A2 0A      call printx32
0992   0988 51 04 00      add sp, 4
0993   098B 0A 9A 09      jmp _if18_exit
0994   098E             _if18_else:
0995   098E             ;; err("Unexpected format in printf."); 
0996   098E 26 5A 14      mov b, __s0 ; "Unexpected format in printf."
0997   0991 FD AB         swp b
0998   0993 D8            push b
0999   0994 07 90 0A      call err
1000   0997 51 02 00      add sp, 2
1001   099A             _if18_exit:
1002   099A             _if17_exit:
1003   099A             _if16_exit:
1004   099A             ;; p = p + 4; 
1005   099A FA FF FF      lea d, [bp + -1] ; $p
1006   099D DA            push d
1007   099E FA FF FF      lea d, [bp + -1] ; $p
1008   09A1 2A            mov b, [d]
1009   09A2             ; START TERMS
1010   09A2 D7            push a
1011   09A3 11            mov a, b
1012   09A4 26 04 00      mov b, $4
1013   09A7 56            add b, a
1014   09A8 E4            pop a
1015   09A9             ; END TERMS
1016   09A9 E7            pop d
1017   09AA FD 43         mov [d], b
1018   09AC             ;; break; 
1019   09AC 0A 5F 0A      jmp _switch15_exit ; case break
1020   09AF             _switch15_case2:
1021   09AF             _switch15_case3:
1022   09AF             ;; print_signed(*(int*)p); 
1023   09AF FA FF FF      lea d, [bp + -1] ; $p
1024   09B2 2A            mov b, [d]
1025   09B3 74            mov d, b
1026   09B4 2A            mov b, [d]
1027   09B5 FD AB         swp b
1028   09B7 D8            push b
1029   09B8 07 29 0C      call print_signed
1030   09BB 51 02 00      add sp, 2
1031   09BE             ;; p = p + 2; 
1032   09BE FA FF FF      lea d, [bp + -1] ; $p
1033   09C1 DA            push d
1034   09C2 FA FF FF      lea d, [bp + -1] ; $p
1035   09C5 2A            mov b, [d]
1036   09C6             ; START TERMS
1037   09C6 D7            push a
1038   09C7 11            mov a, b
1039   09C8 26 02 00      mov b, $2
1040   09CB 56            add b, a
1041   09CC E4            pop a
1042   09CD             ; END TERMS
1043   09CD E7            pop d
1044   09CE FD 43         mov [d], b
1045   09D0             ;; break; 
1046   09D0 0A 5F 0A      jmp _switch15_exit ; case break
1047   09D3             _switch15_case4:
1048   09D3             ;; print_unsigned(*(unsigned int*)p); 
1049   09D3 FA FF FF      lea d, [bp + -1] ; $p
1050   09D6 2A            mov b, [d]
1051   09D7 74            mov d, b
1052   09D8 2A            mov b, [d]
1053   09D9 FD AB         swp b
1054   09DB D8            push b
1055   09DC 07 6E 0F      call print_unsigned
1056   09DF 51 02 00      add sp, 2
1057   09E2             ;; p = p + 2; 
1058   09E2 FA FF FF      lea d, [bp + -1] ; $p
1059   09E5 DA            push d
1060   09E6 FA FF FF      lea d, [bp + -1] ; $p
1061   09E9 2A            mov b, [d]
1062   09EA             ; START TERMS
1063   09EA D7            push a
1064   09EB 11            mov a, b
1065   09EC 26 02 00      mov b, $2
1066   09EF 56            add b, a
1067   09F0 E4            pop a
1068   09F1             ; END TERMS
1069   09F1 E7            pop d
1070   09F2 FD 43         mov [d], b
1071   09F4             ;; break; 
1072   09F4 0A 5F 0A      jmp _switch15_exit ; case break
1073   09F7             _switch15_case5:
1074   09F7             
1075   09F7             ; --- BEGIN INLINE ASM BLOCK
1076   09F7 FA FF FF      lea d, [bp + -1] ; $p
1077   09FA FD 2A         mov d, [d]
1078   09FC 2A            mov b, [d]
1079   09FD 07 4C 13      call print_u16x
1080   0A00             ; --- END INLINE ASM BLOCK
1081   0A00             
1082   0A00             ;; p = p + 2; 
1083   0A00 FA FF FF      lea d, [bp + -1] ; $p
1084   0A03 DA            push d
1085   0A04 FA FF FF      lea d, [bp + -1] ; $p
1086   0A07 2A            mov b, [d]
1087   0A08             ; START TERMS
1088   0A08 D7            push a
1089   0A09 11            mov a, b
1090   0A0A 26 02 00      mov b, $2
1091   0A0D 56            add b, a
1092   0A0E E4            pop a
1093   0A0F             ; END TERMS
1094   0A0F E7            pop d
1095   0A10 FD 43         mov [d], b
1096   0A12             ;; break; 
1097   0A12 0A 5F 0A      jmp _switch15_exit ; case break
1098   0A15             _switch15_case6:
1099   0A15             
1100   0A15             ; --- BEGIN INLINE ASM BLOCK
1101   0A15 FA FF FF      lea d, [bp + -1] ; $p
1102   0A18 FD 2A         mov d, [d]
1103   0A1A 1E            mov al, [d]
1104   0A1B 23            mov ah, al
1105   0A1C 07 AA 11      call _putchar
1106   0A1F             ; --- END INLINE ASM BLOCK
1107   0A1F             
1108   0A1F             ;; p = p + 2; 
1109   0A1F FA FF FF      lea d, [bp + -1] ; $p
1110   0A22 DA            push d
1111   0A23 FA FF FF      lea d, [bp + -1] ; $p
1112   0A26 2A            mov b, [d]
1113   0A27             ; START TERMS
1114   0A27 D7            push a
1115   0A28 11            mov a, b
1116   0A29 26 02 00      mov b, $2
1117   0A2C 56            add b, a
1118   0A2D E4            pop a
1119   0A2E             ; END TERMS
1120   0A2E E7            pop d
1121   0A2F FD 43         mov [d], b
1122   0A31             ;; break; 
1123   0A31 0A 5F 0A      jmp _switch15_exit ; case break
1124   0A34             _switch15_case7:
1125   0A34             
1126   0A34             ; --- BEGIN INLINE ASM BLOCK
1127   0A34 FA FF FF      lea d, [bp + -1] ; $p
1128   0A37 FD 2A         mov d, [d]
1129   0A39 FD 2A         mov d, [d]
1130   0A3B 07 F4 12      call _puts
1131   0A3E             ; --- END INLINE ASM BLOCK
1132   0A3E             
1133   0A3E             ;; p = p + 2; 
1134   0A3E FA FF FF      lea d, [bp + -1] ; $p
1135   0A41 DA            push d
1136   0A42 FA FF FF      lea d, [bp + -1] ; $p
1137   0A45 2A            mov b, [d]
1138   0A46             ; START TERMS
1139   0A46 D7            push a
1140   0A47 11            mov a, b
1141   0A48 26 02 00      mov b, $2
1142   0A4B 56            add b, a
1143   0A4C E4            pop a
1144   0A4D             ; END TERMS
1145   0A4D E7            pop d
1146   0A4E FD 43         mov [d], b
1147   0A50             ;; break; 
1148   0A50 0A 5F 0A      jmp _switch15_exit ; case break
1149   0A53             _switch15_default:
1150   0A53             ;; print("Error: Unknown argument type.\n"); 
1151   0A53 26 77 14      mov b, __s1 ; "Error: Unknown argument type.\n"
1152   0A56 FD AB         swp b
1153   0A58 D8            push b
1154   0A59 07 86 10      call print
1155   0A5C 51 02 00      add sp, 2
1156   0A5F             _switch15_exit:
1157   0A5F             ;; format_p++; 
1158   0A5F FA FD FF      lea d, [bp + -3] ; $format_p
1159   0A62 2A            mov b, [d]
1160   0A63 D8            push b
1161   0A64 FD 77         inc b
1162   0A66 FA FD FF      lea d, [bp + -3] ; $format_p
1163   0A69 FD 43         mov [d], b
1164   0A6B E5            pop b
1165   0A6C 0A 8B 0A      jmp _if14_exit
1166   0A6F             _if14_else:
1167   0A6F             ;; putchar(*format_p); 
1168   0A6F FA FD FF      lea d, [bp + -3] ; $format_p
1169   0A72 2A            mov b, [d]
1170   0A73 74            mov d, b
1171   0A74 32            mov bl, [d]
1172   0A75 A7 00         mov bh, 0
1173   0A77 DD            push bl
1174   0A78 07 3E 10      call putchar
1175   0A7B 51 01 00      add sp, 1
1176   0A7E             ;; format_p++; 
1177   0A7E FA FD FF      lea d, [bp + -3] ; $format_p
1178   0A81 2A            mov b, [d]
1179   0A82 D8            push b
1180   0A83 FD 77         inc b
1181   0A85 FA FD FF      lea d, [bp + -3] ; $format_p
1182   0A88 FD 43         mov [d], b
1183   0A8A E5            pop b
1184   0A8B             _if14_exit:
1185   0A8B             _if13_exit:
1186   0A8B             _for12_update:
1187   0A8B 0A 6C 08      jmp _for12_cond
1188   0A8E             _for12_exit:
1189   0A8E F9            leave
1190   0A8F 09            ret
1191   0A90             
1192   0A90             err:
1193   0A90 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1194   0A93             ;; print(e); 
1195   0A93 FA 05 00      lea d, [bp + 5] ; $e
1196   0A96 2A            mov b, [d]
1197   0A97 FD AB         swp b
1198   0A99 D8            push b
1199   0A9A 07 86 10      call print
1200   0A9D 51 02 00      add sp, 2
1201   0AA0 F9            leave
1202   0AA1 09            ret
1203   0AA2             
1204   0AA2             printx32:
1205   0AA2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1206   0AA5             
1207   0AA5             ; --- BEGIN INLINE ASM BLOCK
1208   0AA5 FA 05 00      lea d, [bp + 5] ; $hex
1209   0AA8 2B 02 00      mov b, [d+2]
1210   0AAB 07 4C 13      call print_u16x
1211   0AAE 2A            mov b, [d]
1212   0AAF 07 4C 13      call print_u16x
1213   0AB2             ; --- END INLINE ASM BLOCK
1214   0AB2             
1215   0AB2 F9            leave
1216   0AB3 09            ret
1217   0AB4             
1218   0AB4             printx16:
1219   0AB4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1220   0AB7             
1221   0AB7             ; --- BEGIN INLINE ASM BLOCK
1222   0AB7 FA 05 00      lea d, [bp + 5] ; $hex
1223   0ABA 2A            mov b, [d]
1224   0ABB 07 4C 13      call print_u16x
1225   0ABE             ; --- END INLINE ASM BLOCK
1226   0ABE             
1227   0ABE F9            leave
1228   0ABF 09            ret
1229   0AC0             
1230   0AC0             printx8:
1231   0AC0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1232   0AC3             
1233   0AC3             ; --- BEGIN INLINE ASM BLOCK
1234   0AC3 FA 05 00      lea d, [bp + 5] ; $hex
1235   0AC6 32            mov bl, [d]
1236   0AC7 07 90 13      call print_u8x
1237   0ACA             ; --- END INLINE ASM BLOCK
1238   0ACA             
1239   0ACA F9            leave
1240   0ACB 09            ret
1241   0ACC             
1242   0ACC             hex_str_to_int:
1243   0ACC F8 00 00      enter 0 ; (push bp; mov bp, sp)
1244   0ACF             ; $value 
1245   0ACF 10 00 00      mov a, $0
1246   0AD2 45 FF FF      mov [bp + -1], a
1247   0AD5             ; $i 
1248   0AD5             ; $hex_char 
1249   0AD5             ; $len 
1250   0AD5 52 07 00      sub sp, 7
1251   0AD8             ;; len = strlen(hex_string); 
1252   0AD8 FA FA FF      lea d, [bp + -6] ; $len
1253   0ADB DA            push d
1254   0ADC FA 05 00      lea d, [bp + 5] ; $hex_string
1255   0ADF 2A            mov b, [d]
1256   0AE0 FD AB         swp b
1257   0AE2 D8            push b
1258   0AE3 07 C5 05      call strlen
1259   0AE6 51 02 00      add sp, 2
1260   0AE9 E7            pop d
1261   0AEA FD 43         mov [d], b
1262   0AEC             ;; for (i = 0; i < len; i++) { 
1263   0AEC             _for19_init:
1264   0AEC FA FD FF      lea d, [bp + -3] ; $i
1265   0AEF DA            push d
1266   0AF0 26 00 00      mov b, $0
1267   0AF3 E7            pop d
1268   0AF4 FD 43         mov [d], b
1269   0AF6             _for19_cond:
1270   0AF6 FA FD FF      lea d, [bp + -3] ; $i
1271   0AF9 2A            mov b, [d]
1272   0AFA             ; START RELATIONAL
1273   0AFA D7            push a
1274   0AFB 11            mov a, b
1275   0AFC FA FA FF      lea d, [bp + -6] ; $len
1276   0AFF 2A            mov b, [d]
1277   0B00 B0            cmp a, b
1278   0B01 FD 73         slt ; <= (signed)
1279   0B03 E4            pop a
1280   0B04             ; END RELATIONAL
1281   0B04 C0 00 00      cmp b, 0
1282   0B07 C6 09 0C      je _for19_exit
1283   0B0A             _for19_block:
1284   0B0A             ;; hex_char = hex_string[i]; 
1285   0B0A FA FC FF      lea d, [bp + -4] ; $hex_char
1286   0B0D DA            push d
1287   0B0E FA 05 00      lea d, [bp + 5] ; $hex_string
1288   0B11 FD 2A         mov d, [d]
1289   0B13 D7            push a
1290   0B14 DA            push d
1291   0B15 FA FD FF      lea d, [bp + -3] ; $i
1292   0B18 2A            mov b, [d]
1293   0B19 E7            pop d
1294   0B1A FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
1295   0B1E E4            pop a
1296   0B1F 32            mov bl, [d]
1297   0B20 A7 00         mov bh, 0
1298   0B22 E7            pop d
1299   0B23 FD 3E         mov [d], bl
1300   0B25             ;; if (hex_char >= 'a' && hex_char <= 'f')  
1301   0B25             _if20_cond:
1302   0B25 FA FC FF      lea d, [bp + -4] ; $hex_char
1303   0B28 32            mov bl, [d]
1304   0B29 A7 00         mov bh, 0
1305   0B2B             ; START RELATIONAL
1306   0B2B D7            push a
1307   0B2C 11            mov a, b
1308   0B2D 26 61 00      mov b, $61
1309   0B30 B0            cmp a, b
1310   0B31 FD 80         sge ; >=
1311   0B33 E4            pop a
1312   0B34             ; END RELATIONAL
1313   0B34 D7            push a
1314   0B35 11            mov a, b
1315   0B36 FA FC FF      lea d, [bp + -4] ; $hex_char
1316   0B39 32            mov bl, [d]
1317   0B3A A7 00         mov bh, 0
1318   0B3C             ; START RELATIONAL
1319   0B3C D7            push a
1320   0B3D 11            mov a, b
1321   0B3E 26 66 00      mov b, $66
1322   0B41 B0            cmp a, b
1323   0B42 FD 73         slt ; <= (signed)
1324   0B44 E4            pop a
1325   0B45             ; END RELATIONAL
1326   0B45 FD A7         sand a, b
1327   0B47 E4            pop a
1328   0B48 C0 00 00      cmp b, 0
1329   0B4B C6 7C 0B      je _if20_else
1330   0B4E             _if20_true:
1331   0B4E             ;; value = (value * 16) + (hex_char - 'a' + 10); 
1332   0B4E FA FF FF      lea d, [bp + -1] ; $value
1333   0B51 DA            push d
1334   0B52 FA FF FF      lea d, [bp + -1] ; $value
1335   0B55 2A            mov b, [d]
1336   0B56             ; START FACTORS
1337   0B56 D7            push a
1338   0B57 11            mov a, b
1339   0B58 26 10 00      mov b, $10
1340   0B5B AC            mul a, b ; *
1341   0B5C 11            mov a, b
1342   0B5D 27            mov b, a
1343   0B5E E4            pop a
1344   0B5F             ; END FACTORS
1345   0B5F             ; START TERMS
1346   0B5F D7            push a
1347   0B60 11            mov a, b
1348   0B61 FA FC FF      lea d, [bp + -4] ; $hex_char
1349   0B64 32            mov bl, [d]
1350   0B65 A7 00         mov bh, 0
1351   0B67             ; START TERMS
1352   0B67 D7            push a
1353   0B68 11            mov a, b
1354   0B69 26 61 00      mov b, $61
1355   0B6C 60            sub a, b
1356   0B6D 27            mov b, a
1357   0B6E 11            mov a, b
1358   0B6F 26 0A 00      mov b, $a
1359   0B72 56            add b, a
1360   0B73 E4            pop a
1361   0B74             ; END TERMS
1362   0B74 56            add b, a
1363   0B75 E4            pop a
1364   0B76             ; END TERMS
1365   0B76 E7            pop d
1366   0B77 FD 43         mov [d], b
1367   0B79 0A F9 0B      jmp _if20_exit
1368   0B7C             _if20_else:
1369   0B7C             ;; if (hex_char >= 'A' && hex_char <= 'F')  
1370   0B7C             _if21_cond:
1371   0B7C FA FC FF      lea d, [bp + -4] ; $hex_char
1372   0B7F 32            mov bl, [d]
1373   0B80 A7 00         mov bh, 0
1374   0B82             ; START RELATIONAL
1375   0B82 D7            push a
1376   0B83 11            mov a, b
1377   0B84 26 41 00      mov b, $41
1378   0B87 B0            cmp a, b
1379   0B88 FD 80         sge ; >=
1380   0B8A E4            pop a
1381   0B8B             ; END RELATIONAL
1382   0B8B D7            push a
1383   0B8C 11            mov a, b
1384   0B8D FA FC FF      lea d, [bp + -4] ; $hex_char
1385   0B90 32            mov bl, [d]
1386   0B91 A7 00         mov bh, 0
1387   0B93             ; START RELATIONAL
1388   0B93 D7            push a
1389   0B94 11            mov a, b
1390   0B95 26 46 00      mov b, $46
1391   0B98 B0            cmp a, b
1392   0B99 FD 73         slt ; <= (signed)
1393   0B9B E4            pop a
1394   0B9C             ; END RELATIONAL
1395   0B9C FD A7         sand a, b
1396   0B9E E4            pop a
1397   0B9F C0 00 00      cmp b, 0
1398   0BA2 C6 D3 0B      je _if21_else
1399   0BA5             _if21_true:
1400   0BA5             ;; value = (value * 16) + (hex_char - 'A' + 10); 
1401   0BA5 FA FF FF      lea d, [bp + -1] ; $value
1402   0BA8 DA            push d
1403   0BA9 FA FF FF      lea d, [bp + -1] ; $value
1404   0BAC 2A            mov b, [d]
1405   0BAD             ; START FACTORS
1406   0BAD D7            push a
1407   0BAE 11            mov a, b
1408   0BAF 26 10 00      mov b, $10
1409   0BB2 AC            mul a, b ; *
1410   0BB3 11            mov a, b
1411   0BB4 27            mov b, a
1412   0BB5 E4            pop a
1413   0BB6             ; END FACTORS
1414   0BB6             ; START TERMS
1415   0BB6 D7            push a
1416   0BB7 11            mov a, b
1417   0BB8 FA FC FF      lea d, [bp + -4] ; $hex_char
1418   0BBB 32            mov bl, [d]
1419   0BBC A7 00         mov bh, 0
1420   0BBE             ; START TERMS
1421   0BBE D7            push a
1422   0BBF 11            mov a, b
1423   0BC0 26 41 00      mov b, $41
1424   0BC3 60            sub a, b
1425   0BC4 27            mov b, a
1426   0BC5 11            mov a, b
1427   0BC6 26 0A 00      mov b, $a
1428   0BC9 56            add b, a
1429   0BCA E4            pop a
1430   0BCB             ; END TERMS
1431   0BCB 56            add b, a
1432   0BCC E4            pop a
1433   0BCD             ; END TERMS
1434   0BCD E7            pop d
1435   0BCE FD 43         mov [d], b
1436   0BD0 0A F9 0B      jmp _if21_exit
1437   0BD3             _if21_else:
1438   0BD3             ;; value = (value * 16) + (hex_char - '0'); 
1439   0BD3 FA FF FF      lea d, [bp + -1] ; $value
1440   0BD6 DA            push d
1441   0BD7 FA FF FF      lea d, [bp + -1] ; $value
1442   0BDA 2A            mov b, [d]
1443   0BDB             ; START FACTORS
1444   0BDB D7            push a
1445   0BDC 11            mov a, b
1446   0BDD 26 10 00      mov b, $10
1447   0BE0 AC            mul a, b ; *
1448   0BE1 11            mov a, b
1449   0BE2 27            mov b, a
1450   0BE3 E4            pop a
1451   0BE4             ; END FACTORS
1452   0BE4             ; START TERMS
1453   0BE4 D7            push a
1454   0BE5 11            mov a, b
1455   0BE6 FA FC FF      lea d, [bp + -4] ; $hex_char
1456   0BE9 32            mov bl, [d]
1457   0BEA A7 00         mov bh, 0
1458   0BEC             ; START TERMS
1459   0BEC D7            push a
1460   0BED 11            mov a, b
1461   0BEE 26 30 00      mov b, $30
1462   0BF1 60            sub a, b
1463   0BF2 27            mov b, a
1464   0BF3 E4            pop a
1465   0BF4             ; END TERMS
1466   0BF4 56            add b, a
1467   0BF5 E4            pop a
1468   0BF6             ; END TERMS
1469   0BF6 E7            pop d
1470   0BF7 FD 43         mov [d], b
1471   0BF9             _if21_exit:
1472   0BF9             _if20_exit:
1473   0BF9             _for19_update:
1474   0BF9 FA FD FF      lea d, [bp + -3] ; $i
1475   0BFC 2A            mov b, [d]
1476   0BFD D8            push b
1477   0BFE FD 77         inc b
1478   0C00 FA FD FF      lea d, [bp + -3] ; $i
1479   0C03 FD 43         mov [d], b
1480   0C05 E5            pop b
1481   0C06 0A F6 0A      jmp _for19_cond
1482   0C09             _for19_exit:
1483   0C09             ;; return value; 
1484   0C09 FA FF FF      lea d, [bp + -1] ; $value
1485   0C0C 2A            mov b, [d]
1486   0C0D F9            leave
1487   0C0E 09            ret
1488   0C0F             
1489   0C0F             gets:
1490   0C0F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1491   0C12             
1492   0C12             ; --- BEGIN INLINE ASM BLOCK
1493   0C12 FA 05 00      lea d, [bp + 5] ; $s
1494   0C15 15            mov a, [d]
1495   0C16 3C            mov d, a
1496   0C17 07 B1 11      call _gets
1497   0C1A             ; --- END INLINE ASM BLOCK
1498   0C1A             
1499   0C1A             ;; return strlen(s); 
1500   0C1A FA 05 00      lea d, [bp + 5] ; $s
1501   0C1D 2A            mov b, [d]
1502   0C1E FD AB         swp b
1503   0C20 D8            push b
1504   0C21 07 C5 05      call strlen
1505   0C24 51 02 00      add sp, 2
1506   0C27 F9            leave
1507   0C28 09            ret
1508   0C29             
1509   0C29             print_signed:
1510   0C29 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1511   0C2C             ; $digits 
1512   0C2C             ; $i 
1513   0C2C 10 00 00      mov a, $0
1514   0C2F 45 FA FF      mov [bp + -6], a
1515   0C32 52 07 00      sub sp, 7
1516   0C35             ;; if (num < 0) { 
1517   0C35             _if22_cond:
1518   0C35 FA 05 00      lea d, [bp + 5] ; $num
1519   0C38 2A            mov b, [d]
1520   0C39             ; START RELATIONAL
1521   0C39 D7            push a
1522   0C3A 11            mov a, b
1523   0C3B 26 00 00      mov b, $0
1524   0C3E B0            cmp a, b
1525   0C3F FD 73         slt ; <= (signed)
1526   0C41 E4            pop a
1527   0C42             ; END RELATIONAL
1528   0C42 C0 00 00      cmp b, 0
1529   0C45 C6 62 0C      je _if22_else
1530   0C48             _if22_true:
1531   0C48             ;; putchar('-'); 
1532   0C48 26 2D 00      mov b, $2d
1533   0C4B DD            push bl
1534   0C4C 07 3E 10      call putchar
1535   0C4F 51 01 00      add sp, 1
1536   0C52             ;; num = -num; 
1537   0C52 FA 05 00      lea d, [bp + 5] ; $num
1538   0C55 DA            push d
1539   0C56 FA 05 00      lea d, [bp + 5] ; $num
1540   0C59 2A            mov b, [d]
1541   0C5A FD 97         neg b
1542   0C5C E7            pop d
1543   0C5D FD 43         mov [d], b
1544   0C5F 0A 84 0C      jmp _if22_exit
1545   0C62             _if22_else:
1546   0C62             ;; if (num == 0) { 
1547   0C62             _if23_cond:
1548   0C62 FA 05 00      lea d, [bp + 5] ; $num
1549   0C65 2A            mov b, [d]
1550   0C66             ; START RELATIONAL
1551   0C66 D7            push a
1552   0C67 11            mov a, b
1553   0C68 26 00 00      mov b, $0
1554   0C6B B0            cmp a, b
1555   0C6C FD 71         seq ; ==
1556   0C6E E4            pop a
1557   0C6F             ; END RELATIONAL
1558   0C6F C0 00 00      cmp b, 0
1559   0C72 C6 84 0C      je _if23_exit
1560   0C75             _if23_true:
1561   0C75             ;; putchar('0'); 
1562   0C75 26 30 00      mov b, $30
1563   0C78 DD            push bl
1564   0C79 07 3E 10      call putchar
1565   0C7C 51 01 00      add sp, 1
1566   0C7F             ;; return; 
1567   0C7F F9            leave
1568   0C80 09            ret
1569   0C81 0A 84 0C      jmp _if23_exit
1570   0C84             _if23_exit:
1571   0C84             _if22_exit:
1572   0C84             ;; while (num > 0) { 
1573   0C84             _while24_cond:
1574   0C84 FA 05 00      lea d, [bp + 5] ; $num
1575   0C87 2A            mov b, [d]
1576   0C88             ; START RELATIONAL
1577   0C88 D7            push a
1578   0C89 11            mov a, b
1579   0C8A 26 00 00      mov b, $0
1580   0C8D B0            cmp a, b
1581   0C8E FD 7F         sgt ; >
1582   0C90 E4            pop a
1583   0C91             ; END RELATIONAL
1584   0C91 C0 00 00      cmp b, 0
1585   0C94 C6 DE 0C      je _while24_exit
1586   0C97             _while24_block:
1587   0C97             ;; digits[i] = '0' + (num % 10); 
1588   0C97 FA FC FF      lea d, [bp + -4] ; $digits
1589   0C9A D7            push a
1590   0C9B DA            push d
1591   0C9C FA FA FF      lea d, [bp + -6] ; $i
1592   0C9F 2A            mov b, [d]
1593   0CA0 E7            pop d
1594   0CA1 5A            add d, b
1595   0CA2 E4            pop a
1596   0CA3 DA            push d
1597   0CA4 26 30 00      mov b, $30
1598   0CA7             ; START TERMS
1599   0CA7 D7            push a
1600   0CA8 11            mov a, b
1601   0CA9 FA 05 00      lea d, [bp + 5] ; $num
1602   0CAC 2A            mov b, [d]
1603   0CAD             ; START FACTORS
1604   0CAD D7            push a
1605   0CAE 11            mov a, b
1606   0CAF 26 0A 00      mov b, $a
1607   0CB2 AE            div a, b ; 
1608   0CB3 11            mov a, b
1609   0CB4 27            mov b, a
1610   0CB5 E4            pop a
1611   0CB6             ; END FACTORS
1612   0CB6 56            add b, a
1613   0CB7 E4            pop a
1614   0CB8             ; END TERMS
1615   0CB8 E7            pop d
1616   0CB9 FD 3E         mov [d], bl
1617   0CBB             ;; num = num / 10; 
1618   0CBB FA 05 00      lea d, [bp + 5] ; $num
1619   0CBE DA            push d
1620   0CBF FA 05 00      lea d, [bp + 5] ; $num
1621   0CC2 2A            mov b, [d]
1622   0CC3             ; START FACTORS
1623   0CC3 D7            push a
1624   0CC4 11            mov a, b
1625   0CC5 26 0A 00      mov b, $a
1626   0CC8 AE            div a, b
1627   0CC9 27            mov b, a
1628   0CCA E4            pop a
1629   0CCB             ; END FACTORS
1630   0CCB E7            pop d
1631   0CCC FD 43         mov [d], b
1632   0CCE             ;; i++; 
1633   0CCE FA FA FF      lea d, [bp + -6] ; $i
1634   0CD1 2A            mov b, [d]
1635   0CD2 D8            push b
1636   0CD3 FD 77         inc b
1637   0CD5 FA FA FF      lea d, [bp + -6] ; $i
1638   0CD8 FD 43         mov [d], b
1639   0CDA E5            pop b
1640   0CDB 0A 84 0C      jmp _while24_cond
1641   0CDE             _while24_exit:
1642   0CDE             ;; while (i > 0) { 
1643   0CDE             _while25_cond:
1644   0CDE FA FA FF      lea d, [bp + -6] ; $i
1645   0CE1 2A            mov b, [d]
1646   0CE2             ; START RELATIONAL
1647   0CE2 D7            push a
1648   0CE3 11            mov a, b
1649   0CE4 26 00 00      mov b, $0
1650   0CE7 B0            cmp a, b
1651   0CE8 FD 7F         sgt ; >
1652   0CEA E4            pop a
1653   0CEB             ; END RELATIONAL
1654   0CEB C0 00 00      cmp b, 0
1655   0CEE C6 17 0D      je _while25_exit
1656   0CF1             _while25_block:
1657   0CF1             ;; i--; 
1658   0CF1 FA FA FF      lea d, [bp + -6] ; $i
1659   0CF4 2A            mov b, [d]
1660   0CF5 D8            push b
1661   0CF6 FD 7D         dec b
1662   0CF8 FA FA FF      lea d, [bp + -6] ; $i
1663   0CFB FD 43         mov [d], b
1664   0CFD E5            pop b
1665   0CFE             ;; putchar(digits[i]); 
1666   0CFE FA FC FF      lea d, [bp + -4] ; $digits
1667   0D01 D7            push a
1668   0D02 DA            push d
1669   0D03 FA FA FF      lea d, [bp + -6] ; $i
1670   0D06 2A            mov b, [d]
1671   0D07 E7            pop d
1672   0D08 5A            add d, b
1673   0D09 E4            pop a
1674   0D0A 32            mov bl, [d]
1675   0D0B A7 00         mov bh, 0
1676   0D0D DD            push bl
1677   0D0E 07 3E 10      call putchar
1678   0D11 51 01 00      add sp, 1
1679   0D14 0A DE 0C      jmp _while25_cond
1680   0D17             _while25_exit:
1681   0D17 F9            leave
1682   0D18 09            ret
1683   0D19             
1684   0D19             print_signed_long:
1685   0D19 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1686   0D1C             ; $digits 
1687   0D1C             ; $i 
1688   0D1C 10 00 00      mov a, $0
1689   0D1F 45 F5 FF      mov [bp + -11], a
1690   0D22 52 0C 00      sub sp, 12
1691   0D25             ;; if (num < 0) { 
1692   0D25             _if26_cond:
1693   0D25 FA 05 00      lea d, [bp + 5] ; $num
1694   0D28 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1695   0D2B FD 39         mov c, b ; And place it into C
1696   0D2D 2A            mov b, [d] ; Lower Word in B
1697   0D2E             ; START RELATIONAL
1698   0D2E D7            push a
1699   0D2F FD D8         push g
1700   0D31 11            mov a, b
1701   0D32 FD 7A         mov g, c
1702   0D34 26 00 00      mov b, $0
1703   0D37 4D            mov si, a
1704   0D38 11            mov a, b
1705   0D39 4F            mov di, a
1706   0D3A FD 12         mov a, g
1707   0D3C 26 00 00      mov b, 0
1708   0D3F B0            cmp a, b
1709   0D40 FD 73         slt ; <
1710   0D42 D8            push b
1711   0D43 28            mov b, c
1712   0D44 FD 71         seq ; ==
1713   0D46 D8            push b
1714   0D47 50            mov a, di
1715   0D48 27            mov b, a
1716   0D49 4E            mov a, si
1717   0D4A B0            cmp a, b
1718   0D4B FD 73         slt ; <
1719   0D4D E4            pop a
1720   0D4E FD 92         and b, a
1721   0D50 E4            pop a
1722   0D51 FD 70         or b, a
1723   0D53               
1724   0D53 FD F1         pop g
1725   0D55 E4            pop a
1726   0D56             ; END RELATIONAL
1727   0D56 C0 00 00      cmp b, 0
1728   0D59 C6 80 0D      je _if26_else
1729   0D5C             _if26_true:
1730   0D5C             ;; putchar('-'); 
1731   0D5C 26 2D 00      mov b, $2d
1732   0D5F DD            push bl
1733   0D60 07 3E 10      call putchar
1734   0D63 51 01 00      add sp, 1
1735   0D66             ;; num = -num; 
1736   0D66 FA 05 00      lea d, [bp + 5] ; $num
1737   0D69 DA            push d
1738   0D6A FA 05 00      lea d, [bp + 5] ; $num
1739   0D6D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1740   0D70 FD 39         mov c, b ; And place it into C
1741   0D72 2A            mov b, [d] ; Lower Word in B
1742   0D73 FD 97         neg b
1743   0D75 E7            pop d
1744   0D76 FD 43         mov [d], b
1745   0D78 28            mov b, c
1746   0D79 FD 44 02 00   mov [d + 2], b
1747   0D7D 0A B9 0D      jmp _if26_exit
1748   0D80             _if26_else:
1749   0D80             ;; if (num == 0) { 
1750   0D80             _if27_cond:
1751   0D80 FA 05 00      lea d, [bp + 5] ; $num
1752   0D83 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1753   0D86 FD 39         mov c, b ; And place it into C
1754   0D88 2A            mov b, [d] ; Lower Word in B
1755   0D89             ; START RELATIONAL
1756   0D89 D7            push a
1757   0D8A FD D8         push g
1758   0D8C 11            mov a, b
1759   0D8D FD 7A         mov g, c
1760   0D8F 26 00 00      mov b, $0
1761   0D92 B0            cmp a, b
1762   0D93 FD 71         seq ; ==
1763   0D95 D8            push b
1764   0D96 10 00 00      mov a, 0
1765   0D99 FD 27         mov b, g
1766   0D9B B0            cmp a, b
1767   0D9C FD 71         seq ; ==
1768   0D9E E4            pop a
1769   0D9F FD A7         sand a, b
1770   0DA1 FD F1         pop g
1771   0DA3 E4            pop a
1772   0DA4             ; END RELATIONAL
1773   0DA4 C0 00 00      cmp b, 0
1774   0DA7 C6 B9 0D      je _if27_exit
1775   0DAA             _if27_true:
1776   0DAA             ;; putchar('0'); 
1777   0DAA 26 30 00      mov b, $30
1778   0DAD DD            push bl
1779   0DAE 07 3E 10      call putchar
1780   0DB1 51 01 00      add sp, 1
1781   0DB4             ;; return; 
1782   0DB4 F9            leave
1783   0DB5 09            ret
1784   0DB6 0A B9 0D      jmp _if27_exit
1785   0DB9             _if27_exit:
1786   0DB9             _if26_exit:
1787   0DB9             ;; while (num > 0) { 
1788   0DB9             _while28_cond:
1789   0DB9 FA 05 00      lea d, [bp + 5] ; $num
1790   0DBC 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1791   0DBF FD 39         mov c, b ; And place it into C
1792   0DC1 2A            mov b, [d] ; Lower Word in B
1793   0DC2             ; START RELATIONAL
1794   0DC2 D7            push a
1795   0DC3 FD D8         push g
1796   0DC5 11            mov a, b
1797   0DC6 FD 7A         mov g, c
1798   0DC8 26 00 00      mov b, $0
1799   0DCB B0            cmp a, b
1800   0DCC FD 7F         sgt ; >
1801   0DCE FD F1         pop g
1802   0DD0 E4            pop a
1803   0DD1             ; END RELATIONAL
1804   0DD1 C0 00 00      cmp b, 0
1805   0DD4 C6 34 0E      je _while28_exit
1806   0DD7             _while28_block:
1807   0DD7             ;; digits[i] = '0' + (num % 10); 
1808   0DD7 FA F7 FF      lea d, [bp + -9] ; $digits
1809   0DDA D7            push a
1810   0DDB DA            push d
1811   0DDC FA F5 FF      lea d, [bp + -11] ; $i
1812   0DDF 2A            mov b, [d]
1813   0DE0 E7            pop d
1814   0DE1 5A            add d, b
1815   0DE2 E4            pop a
1816   0DE3 DA            push d
1817   0DE4 26 30 00      mov b, $30
1818   0DE7             ; START TERMS
1819   0DE7 D7            push a
1820   0DE8 11            mov a, b
1821   0DE9 FA 05 00      lea d, [bp + 5] ; $num
1822   0DEC 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1823   0DEF FD 39         mov c, b ; And place it into C
1824   0DF1 2A            mov b, [d] ; Lower Word in B
1825   0DF2             ; START FACTORS
1826   0DF2 D7            push a
1827   0DF3 11            mov a, b
1828   0DF4 26 0A 00      mov b, $a
1829   0DF7 AE            div a, b ; 
1830   0DF8 11            mov a, b
1831   0DF9 27            mov b, a
1832   0DFA E4            pop a
1833   0DFB             ; END FACTORS
1834   0DFB 54            add a, b
1835   0DFC D7            push a
1836   0DFD FD 12         mov a, g
1837   0DFF 28            mov b, c
1838   0E00 5C            adc a, b
1839   0E01 39            mov c, a
1840   0E02 E5            pop b
1841   0E03 E4            pop a
1842   0E04             ; END TERMS
1843   0E04 E7            pop d
1844   0E05 FD 3E         mov [d], bl
1845   0E07             ;; num = num / 10; 
1846   0E07 FA 05 00      lea d, [bp + 5] ; $num
1847   0E0A DA            push d
1848   0E0B FA 05 00      lea d, [bp + 5] ; $num
1849   0E0E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1850   0E11 FD 39         mov c, b ; And place it into C
1851   0E13 2A            mov b, [d] ; Lower Word in B
1852   0E14             ; START FACTORS
1853   0E14 D7            push a
1854   0E15 11            mov a, b
1855   0E16 26 0A 00      mov b, $a
1856   0E19 AE            div a, b
1857   0E1A 27            mov b, a
1858   0E1B E4            pop a
1859   0E1C             ; END FACTORS
1860   0E1C E7            pop d
1861   0E1D FD 43         mov [d], b
1862   0E1F 28            mov b, c
1863   0E20 FD 44 02 00   mov [d + 2], b
1864   0E24             ;; i++; 
1865   0E24 FA F5 FF      lea d, [bp + -11] ; $i
1866   0E27 2A            mov b, [d]
1867   0E28 D8            push b
1868   0E29 FD 77         inc b
1869   0E2B FA F5 FF      lea d, [bp + -11] ; $i
1870   0E2E FD 43         mov [d], b
1871   0E30 E5            pop b
1872   0E31 0A B9 0D      jmp _while28_cond
1873   0E34             _while28_exit:
1874   0E34             ;; while (i > 0) { 
1875   0E34             _while29_cond:
1876   0E34 FA F5 FF      lea d, [bp + -11] ; $i
1877   0E37 2A            mov b, [d]
1878   0E38             ; START RELATIONAL
1879   0E38 D7            push a
1880   0E39 11            mov a, b
1881   0E3A 26 00 00      mov b, $0
1882   0E3D B0            cmp a, b
1883   0E3E FD 7F         sgt ; >
1884   0E40 E4            pop a
1885   0E41             ; END RELATIONAL
1886   0E41 C0 00 00      cmp b, 0
1887   0E44 C6 6D 0E      je _while29_exit
1888   0E47             _while29_block:
1889   0E47             ;; i--; 
1890   0E47 FA F5 FF      lea d, [bp + -11] ; $i
1891   0E4A 2A            mov b, [d]
1892   0E4B D8            push b
1893   0E4C FD 7D         dec b
1894   0E4E FA F5 FF      lea d, [bp + -11] ; $i
1895   0E51 FD 43         mov [d], b
1896   0E53 E5            pop b
1897   0E54             ;; putchar(digits[i]); 
1898   0E54 FA F7 FF      lea d, [bp + -9] ; $digits
1899   0E57 D7            push a
1900   0E58 DA            push d
1901   0E59 FA F5 FF      lea d, [bp + -11] ; $i
1902   0E5C 2A            mov b, [d]
1903   0E5D E7            pop d
1904   0E5E 5A            add d, b
1905   0E5F E4            pop a
1906   0E60 32            mov bl, [d]
1907   0E61 A7 00         mov bh, 0
1908   0E63 DD            push bl
1909   0E64 07 3E 10      call putchar
1910   0E67 51 01 00      add sp, 1
1911   0E6A 0A 34 0E      jmp _while29_cond
1912   0E6D             _while29_exit:
1913   0E6D F9            leave
1914   0E6E 09            ret
1915   0E6F             
1916   0E6F             print_unsigned_long:
1917   0E6F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1918   0E72             ; $digits 
1919   0E72             ; $i 
1920   0E72 52 0C 00      sub sp, 12
1921   0E75             ;; i = 0; 
1922   0E75 FA F5 FF      lea d, [bp + -11] ; $i
1923   0E78 DA            push d
1924   0E79 26 00 00      mov b, $0
1925   0E7C E7            pop d
1926   0E7D FD 43         mov [d], b
1927   0E7F             ;; if(num == 0){ 
1928   0E7F             _if30_cond:
1929   0E7F FA 05 00      lea d, [bp + 5] ; $num
1930   0E82 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1931   0E85 FD 39         mov c, b ; And place it into C
1932   0E87 2A            mov b, [d] ; Lower Word in B
1933   0E88             ; START RELATIONAL
1934   0E88 D7            push a
1935   0E89 FD D8         push g
1936   0E8B 11            mov a, b
1937   0E8C FD 7A         mov g, c
1938   0E8E 26 00 00      mov b, $0
1939   0E91 B0            cmp a, b
1940   0E92 FD 71         seq ; ==
1941   0E94 D8            push b
1942   0E95 10 00 00      mov a, 0
1943   0E98 FD 27         mov b, g
1944   0E9A B0            cmp a, b
1945   0E9B FD 71         seq ; ==
1946   0E9D E4            pop a
1947   0E9E FD A7         sand a, b
1948   0EA0 FD F1         pop g
1949   0EA2 E4            pop a
1950   0EA3             ; END RELATIONAL
1951   0EA3 C0 00 00      cmp b, 0
1952   0EA6 C6 B8 0E      je _if30_exit
1953   0EA9             _if30_true:
1954   0EA9             ;; putchar('0'); 
1955   0EA9 26 30 00      mov b, $30
1956   0EAC DD            push bl
1957   0EAD 07 3E 10      call putchar
1958   0EB0 51 01 00      add sp, 1
1959   0EB3             ;; return; 
1960   0EB3 F9            leave
1961   0EB4 09            ret
1962   0EB5 0A B8 0E      jmp _if30_exit
1963   0EB8             _if30_exit:
1964   0EB8             ;; while (num > 0) { 
1965   0EB8             _while31_cond:
1966   0EB8 FA 05 00      lea d, [bp + 5] ; $num
1967   0EBB 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1968   0EBE FD 39         mov c, b ; And place it into C
1969   0EC0 2A            mov b, [d] ; Lower Word in B
1970   0EC1             ; START RELATIONAL
1971   0EC1 D7            push a
1972   0EC2 FD D8         push g
1973   0EC4 11            mov a, b
1974   0EC5 FD 7A         mov g, c
1975   0EC7 26 00 00      mov b, $0
1976   0ECA B0            cmp a, b
1977   0ECB FD 81         sgu ; > (unsigned)
1978   0ECD FD F1         pop g
1979   0ECF E4            pop a
1980   0ED0             ; END RELATIONAL
1981   0ED0 C0 00 00      cmp b, 0
1982   0ED3 C6 33 0F      je _while31_exit
1983   0ED6             _while31_block:
1984   0ED6             ;; digits[i] = '0' + (num % 10); 
1985   0ED6 FA F7 FF      lea d, [bp + -9] ; $digits
1986   0ED9 D7            push a
1987   0EDA DA            push d
1988   0EDB FA F5 FF      lea d, [bp + -11] ; $i
1989   0EDE 2A            mov b, [d]
1990   0EDF E7            pop d
1991   0EE0 5A            add d, b
1992   0EE1 E4            pop a
1993   0EE2 DA            push d
1994   0EE3 26 30 00      mov b, $30
1995   0EE6             ; START TERMS
1996   0EE6 D7            push a
1997   0EE7 11            mov a, b
1998   0EE8 FA 05 00      lea d, [bp + 5] ; $num
1999   0EEB 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2000   0EEE FD 39         mov c, b ; And place it into C
2001   0EF0 2A            mov b, [d] ; Lower Word in B
2002   0EF1             ; START FACTORS
2003   0EF1 D7            push a
2004   0EF2 11            mov a, b
2005   0EF3 26 0A 00      mov b, $a
2006   0EF6 AE            div a, b ; 
2007   0EF7 11            mov a, b
2008   0EF8 27            mov b, a
2009   0EF9 E4            pop a
2010   0EFA             ; END FACTORS
2011   0EFA 54            add a, b
2012   0EFB D7            push a
2013   0EFC FD 12         mov a, g
2014   0EFE 28            mov b, c
2015   0EFF 5C            adc a, b
2016   0F00 39            mov c, a
2017   0F01 E5            pop b
2018   0F02 E4            pop a
2019   0F03             ; END TERMS
2020   0F03 E7            pop d
2021   0F04 FD 3E         mov [d], bl
2022   0F06             ;; num = num / 10; 
2023   0F06 FA 05 00      lea d, [bp + 5] ; $num
2024   0F09 DA            push d
2025   0F0A FA 05 00      lea d, [bp + 5] ; $num
2026   0F0D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2027   0F10 FD 39         mov c, b ; And place it into C
2028   0F12 2A            mov b, [d] ; Lower Word in B
2029   0F13             ; START FACTORS
2030   0F13 D7            push a
2031   0F14 11            mov a, b
2032   0F15 26 0A 00      mov b, $a
2033   0F18 AE            div a, b
2034   0F19 27            mov b, a
2035   0F1A E4            pop a
2036   0F1B             ; END FACTORS
2037   0F1B E7            pop d
2038   0F1C FD 43         mov [d], b
2039   0F1E 28            mov b, c
2040   0F1F FD 44 02 00   mov [d + 2], b
2041   0F23             ;; i++; 
2042   0F23 FA F5 FF      lea d, [bp + -11] ; $i
2043   0F26 2A            mov b, [d]
2044   0F27 D8            push b
2045   0F28 FD 77         inc b
2046   0F2A FA F5 FF      lea d, [bp + -11] ; $i
2047   0F2D FD 43         mov [d], b
2048   0F2F E5            pop b
2049   0F30 0A B8 0E      jmp _while31_cond
2050   0F33             _while31_exit:
2051   0F33             ;; while (i > 0) { 
2052   0F33             _while32_cond:
2053   0F33 FA F5 FF      lea d, [bp + -11] ; $i
2054   0F36 2A            mov b, [d]
2055   0F37             ; START RELATIONAL
2056   0F37 D7            push a
2057   0F38 11            mov a, b
2058   0F39 26 00 00      mov b, $0
2059   0F3C B0            cmp a, b
2060   0F3D FD 7F         sgt ; >
2061   0F3F E4            pop a
2062   0F40             ; END RELATIONAL
2063   0F40 C0 00 00      cmp b, 0
2064   0F43 C6 6C 0F      je _while32_exit
2065   0F46             _while32_block:
2066   0F46             ;; i--; 
2067   0F46 FA F5 FF      lea d, [bp + -11] ; $i
2068   0F49 2A            mov b, [d]
2069   0F4A D8            push b
2070   0F4B FD 7D         dec b
2071   0F4D FA F5 FF      lea d, [bp + -11] ; $i
2072   0F50 FD 43         mov [d], b
2073   0F52 E5            pop b
2074   0F53             ;; putchar(digits[i]); 
2075   0F53 FA F7 FF      lea d, [bp + -9] ; $digits
2076   0F56 D7            push a
2077   0F57 DA            push d
2078   0F58 FA F5 FF      lea d, [bp + -11] ; $i
2079   0F5B 2A            mov b, [d]
2080   0F5C E7            pop d
2081   0F5D 5A            add d, b
2082   0F5E E4            pop a
2083   0F5F 32            mov bl, [d]
2084   0F60 A7 00         mov bh, 0
2085   0F62 DD            push bl
2086   0F63 07 3E 10      call putchar
2087   0F66 51 01 00      add sp, 1
2088   0F69 0A 33 0F      jmp _while32_cond
2089   0F6C             _while32_exit:
2090   0F6C F9            leave
2091   0F6D 09            ret
2092   0F6E             
2093   0F6E             print_unsigned:
2094   0F6E F8 00 00      enter 0 ; (push bp; mov bp, sp)
2095   0F71             ; $digits 
2096   0F71             ; $i 
2097   0F71 52 07 00      sub sp, 7
2098   0F74             ;; i = 0; 
2099   0F74 FA FA FF      lea d, [bp + -6] ; $i
2100   0F77 DA            push d
2101   0F78 26 00 00      mov b, $0
2102   0F7B E7            pop d
2103   0F7C FD 43         mov [d], b
2104   0F7E             ;; if(num == 0){ 
2105   0F7E             _if33_cond:
2106   0F7E FA 05 00      lea d, [bp + 5] ; $num
2107   0F81 2A            mov b, [d]
2108   0F82             ; START RELATIONAL
2109   0F82 D7            push a
2110   0F83 11            mov a, b
2111   0F84 26 00 00      mov b, $0
2112   0F87 B0            cmp a, b
2113   0F88 FD 71         seq ; ==
2114   0F8A E4            pop a
2115   0F8B             ; END RELATIONAL
2116   0F8B C0 00 00      cmp b, 0
2117   0F8E C6 A0 0F      je _if33_exit
2118   0F91             _if33_true:
2119   0F91             ;; putchar('0'); 
2120   0F91 26 30 00      mov b, $30
2121   0F94 DD            push bl
2122   0F95 07 3E 10      call putchar
2123   0F98 51 01 00      add sp, 1
2124   0F9B             ;; return; 
2125   0F9B F9            leave
2126   0F9C 09            ret
2127   0F9D 0A A0 0F      jmp _if33_exit
2128   0FA0             _if33_exit:
2129   0FA0             ;; while (num > 0) { 
2130   0FA0             _while34_cond:
2131   0FA0 FA 05 00      lea d, [bp + 5] ; $num
2132   0FA3 2A            mov b, [d]
2133   0FA4             ; START RELATIONAL
2134   0FA4 D7            push a
2135   0FA5 11            mov a, b
2136   0FA6 26 00 00      mov b, $0
2137   0FA9 B0            cmp a, b
2138   0FAA FD 81         sgu ; > (unsigned)
2139   0FAC E4            pop a
2140   0FAD             ; END RELATIONAL
2141   0FAD C0 00 00      cmp b, 0
2142   0FB0 C6 FA 0F      je _while34_exit
2143   0FB3             _while34_block:
2144   0FB3             ;; digits[i] = '0' + (num % 10); 
2145   0FB3 FA FC FF      lea d, [bp + -4] ; $digits
2146   0FB6 D7            push a
2147   0FB7 DA            push d
2148   0FB8 FA FA FF      lea d, [bp + -6] ; $i
2149   0FBB 2A            mov b, [d]
2150   0FBC E7            pop d
2151   0FBD 5A            add d, b
2152   0FBE E4            pop a
2153   0FBF DA            push d
2154   0FC0 26 30 00      mov b, $30
2155   0FC3             ; START TERMS
2156   0FC3 D7            push a
2157   0FC4 11            mov a, b
2158   0FC5 FA 05 00      lea d, [bp + 5] ; $num
2159   0FC8 2A            mov b, [d]
2160   0FC9             ; START FACTORS
2161   0FC9 D7            push a
2162   0FCA 11            mov a, b
2163   0FCB 26 0A 00      mov b, $a
2164   0FCE AE            div a, b ; 
2165   0FCF 11            mov a, b
2166   0FD0 27            mov b, a
2167   0FD1 E4            pop a
2168   0FD2             ; END FACTORS
2169   0FD2 56            add b, a
2170   0FD3 E4            pop a
2171   0FD4             ; END TERMS
2172   0FD4 E7            pop d
2173   0FD5 FD 3E         mov [d], bl
2174   0FD7             ;; num = num / 10; 
2175   0FD7 FA 05 00      lea d, [bp + 5] ; $num
2176   0FDA DA            push d
2177   0FDB FA 05 00      lea d, [bp + 5] ; $num
2178   0FDE 2A            mov b, [d]
2179   0FDF             ; START FACTORS
2180   0FDF D7            push a
2181   0FE0 11            mov a, b
2182   0FE1 26 0A 00      mov b, $a
2183   0FE4 AE            div a, b
2184   0FE5 27            mov b, a
2185   0FE6 E4            pop a
2186   0FE7             ; END FACTORS
2187   0FE7 E7            pop d
2188   0FE8 FD 43         mov [d], b
2189   0FEA             ;; i++; 
2190   0FEA FA FA FF      lea d, [bp + -6] ; $i
2191   0FED 2A            mov b, [d]
2192   0FEE D8            push b
2193   0FEF FD 77         inc b
2194   0FF1 FA FA FF      lea d, [bp + -6] ; $i
2195   0FF4 FD 43         mov [d], b
2196   0FF6 E5            pop b
2197   0FF7 0A A0 0F      jmp _while34_cond
2198   0FFA             _while34_exit:
2199   0FFA             ;; while (i > 0) { 
2200   0FFA             _while35_cond:
2201   0FFA FA FA FF      lea d, [bp + -6] ; $i
2202   0FFD 2A            mov b, [d]
2203   0FFE             ; START RELATIONAL
2204   0FFE D7            push a
2205   0FFF 11            mov a, b
2206   1000 26 00 00      mov b, $0
2207   1003 B0            cmp a, b
2208   1004 FD 7F         sgt ; >
2209   1006 E4            pop a
2210   1007             ; END RELATIONAL
2211   1007 C0 00 00      cmp b, 0
2212   100A C6 33 10      je _while35_exit
2213   100D             _while35_block:
2214   100D             ;; i--; 
2215   100D FA FA FF      lea d, [bp + -6] ; $i
2216   1010 2A            mov b, [d]
2217   1011 D8            push b
2218   1012 FD 7D         dec b
2219   1014 FA FA FF      lea d, [bp + -6] ; $i
2220   1017 FD 43         mov [d], b
2221   1019 E5            pop b
2222   101A             ;; putchar(digits[i]); 
2223   101A FA FC FF      lea d, [bp + -4] ; $digits
2224   101D D7            push a
2225   101E DA            push d
2226   101F FA FA FF      lea d, [bp + -6] ; $i
2227   1022 2A            mov b, [d]
2228   1023 E7            pop d
2229   1024 5A            add d, b
2230   1025 E4            pop a
2231   1026 32            mov bl, [d]
2232   1027 A7 00         mov bh, 0
2233   1029 DD            push bl
2234   102A 07 3E 10      call putchar
2235   102D 51 01 00      add sp, 1
2236   1030 0A FA 0F      jmp _while35_cond
2237   1033             _while35_exit:
2238   1033 F9            leave
2239   1034 09            ret
2240   1035             
2241   1035             date:
2242   1035 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2243   1038             
2244   1038             ; --- BEGIN INLINE ASM BLOCK
2245   1038 19 00         mov al, 0 
2246   103A 05 07         syscall sys_datetime
2247   103C             ; --- END INLINE ASM BLOCK
2248   103C             
2249   103C F9            leave
2250   103D 09            ret
2251   103E             
2252   103E             putchar:
2253   103E F8 00 00      enter 0 ; (push bp; mov bp, sp)
2254   1041             
2255   1041             ; --- BEGIN INLINE ASM BLOCK
2256   1041 FA 05 00      lea d, [bp + 5] ; $c
2257   1044 1E            mov al, [d]
2258   1045 23            mov ah, al
2259   1046 07 AA 11      call _putchar
2260   1049             ; --- END INLINE ASM BLOCK
2261   1049             
2262   1049 F9            leave
2263   104A 09            ret
2264   104B             
2265   104B             getchar:
2266   104B F8 00 00      enter 0 ; (push bp; mov bp, sp)
2267   104E             ; $c 
2268   104E 52 01 00      sub sp, 1
2269   1051             
2270   1051             ; --- BEGIN INLINE ASM BLOCK
2271   1051 07 A3 11      call getch
2272   1054 1A            mov al, ah
2273   1055 FA 00 00      lea d, [bp + 0] ; $c
2274   1058 3E            mov [d], al
2275   1059             ; --- END INLINE ASM BLOCK
2276   1059             
2277   1059             ;; return c; 
2278   1059 FA 00 00      lea d, [bp + 0] ; $c
2279   105C 32            mov bl, [d]
2280   105D A7 00         mov bh, 0
2281   105F F9            leave
2282   1060 09            ret
2283   1061             
2284   1061             scann:
2285   1061 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2286   1064             ; $m 
2287   1064 52 02 00      sub sp, 2
2288   1067             
2289   1067             ; --- BEGIN INLINE ASM BLOCK
2290   1067 07 EE 13      call scan_u16d
2291   106A FA FF FF      lea d, [bp + -1] ; $m
2292   106D 43            mov [d], a
2293   106E             ; --- END INLINE ASM BLOCK
2294   106E             
2295   106E             ;; return m; 
2296   106E FA FF FF      lea d, [bp + -1] ; $m
2297   1071 2A            mov b, [d]
2298   1072 F9            leave
2299   1073 09            ret
2300   1074             
2301   1074             puts:
2302   1074 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2303   1077             
2304   1077             ; --- BEGIN INLINE ASM BLOCK
2305   1077 FA 05 00      lea d, [bp + 5] ; $s
2306   107A 15            mov a, [d]
2307   107B 3C            mov d, a
2308   107C 07 F4 12      call _puts
2309   107F 10 00 0A      mov a, $0A00
2310   1082 05 03         syscall sys_io
2311   1084             ; --- END INLINE ASM BLOCK
2312   1084             
2313   1084 F9            leave
2314   1085 09            ret
2315   1086             
2316   1086             print:
2317   1086 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2318   1089             
2319   1089             ; --- BEGIN INLINE ASM BLOCK
2320   1089 FA 05 00      lea d, [bp + 5] ; $s
2321   108C FD 2A         mov d, [d]
2322   108E 07 F4 12      call _puts
2323   1091             ; --- END INLINE ASM BLOCK
2324   1091             
2325   1091 F9            leave
2326   1092 09            ret
2327   1093             
2328   1093             getparam:
2329   1093 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2330   1096             ; $data 
2331   1096 52 01 00      sub sp, 1
2332   1099             
2333   1099             ; --- BEGIN INLINE ASM BLOCK
2334   1099 19 04         mov al, 4
2335   109B FA 05 00      lea d, [bp + 5] ; $address
2336   109E FD 2A         mov d, [d]
2337   10A0 05 0C         syscall sys_system
2338   10A2 FA 00 00      lea d, [bp + 0] ; $data
2339   10A5 FD 3E         mov [d], bl
2340   10A7             ; --- END INLINE ASM BLOCK
2341   10A7             
2342   10A7             ;; return data; 
2343   10A7 FA 00 00      lea d, [bp + 0] ; $data
2344   10AA 32            mov bl, [d]
2345   10AB A7 00         mov bh, 0
2346   10AD F9            leave
2347   10AE 09            ret
2348   10AF             
2349   10AF             clear:
2350   10AF F8 00 00      enter 0 ; (push bp; mov bp, sp)
2351   10B2             ;; print("\033[2J\033[H"); 
2352   10B2 26 96 14      mov b, __s2 ; "\033[2J\033[H"
2353   10B5 FD AB         swp b
2354   10B7 D8            push b
2355   10B8 07 86 10      call print
2356   10BB 51 02 00      add sp, 2
2357   10BE F9            leave
2358   10BF 09            ret
2359   10C0             
2360   10C0             include_stdio_asm:
2361   10C0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2362   10C3             
2363   10C3             ; --- BEGIN INLINE ASM BLOCK
2364   10C3             .include "lib/asm/stdio.asm"
0001+  10C3             ;-----------------------------------------------------------------------------
0002+  10C3             ; stdio.s
0003+  10C3             ;-----------------------------------------------------------------------------
0004+  10C3             .include "lib/asm/string.asm"
0001++ 10C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 10C3             ; string.s
0003++ 10C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 10C3             
0005++ 10C3             
0006++ 10C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 10C3             ; _strrev
0008++ 10C3             ; reverse a string
0009++ 10C3             ; D = string address
0010++ 10C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 10C3             ; 01234
0012++ 10C3             _strrev:
0013++ 10C3 4B          	pusha
0014++ 10C4 07 0A 11    	call _strlen	; length in C
0015++ 10C7 12          	mov a, c
0016++ 10C8 AF 01 00    	cmp a, 1
0017++ 10CB D0 E5 10    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 10CE 7D          	dec a
0019++ 10CF FD 4E       	mov si, d	; beginning of string
0020++ 10D1 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 10D3 59          	add d, a	; end of string
0022++ 10D4 12          	mov a, c
0023++ 10D5 FD 9B       	shr a		; divide by 2
0024++ 10D7 39          	mov c, a	; C now counts the steps
0025++ 10D8             _strrev_L0:
0026++ 10D8 32          	mov bl, [d]	; save load right-side char into BL
0027++ 10D9 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 10DA 3E          	mov [d], al	; store left char into right side
0029++ 10DB 1B          	mov al, bl
0030++ 10DC F7          	stosb		; store right-side char into left-side; increase DI
0031++ 10DD 7E          	dec c
0032++ 10DE 7F          	dec d
0033++ 10DF C2 00 00    	cmp c, 0
0034++ 10E2 C7 D8 10    	jne _strrev_L0
0035++ 10E5             _strrev_end:
0036++ 10E5 4C          	popa
0037++ 10E6 09          	ret
0038++ 10E7             	
0039++ 10E7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 10E7             ; _strchr
0041++ 10E7             ; search string in D for char in AL
0042++ 10E7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 10E7             _strchr:
0044++ 10E7             _strchr_L0:
0045++ 10E7 32          	mov bl, [d]
0046++ 10E8 C1 00       	cmp bl, 0
0047++ 10EA C6 F5 10    	je _strchr_end
0048++ 10ED BA          	cmp al, bl
0049++ 10EE C6 F5 10    	je _strchr_end
0050++ 10F1 79          	inc d
0051++ 10F2 0A E7 10    	jmp _strchr_L0
0052++ 10F5             _strchr_end:
0053++ 10F5 1B          	mov al, bl
0054++ 10F6 09          	ret
0055++ 10F7             
0056++ 10F7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 10F7             ; _strstr
0058++ 10F7             ; find sub-string
0059++ 10F7             ; str1 in SI
0060++ 10F7             ; str2 in DI
0061++ 10F7             ; SI points to end of source string
0062++ 10F7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 10F7             _strstr:
0064++ 10F7 DB          	push al
0065++ 10F8 DA          	push d
0066++ 10F9 E3          	push di
0067++ 10FA             _strstr_loop:
0068++ 10FA F3          	cmpsb					; compare a byte of the strings
0069++ 10FB C7 06 11    	jne _strstr_ret
0070++ 10FE FC 00 00    	lea d, [di + 0]
0071++ 1101 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1103 C7 FA 10    	jne _strstr_loop				; equal chars but not at end
0073++ 1106             _strstr_ret:
0074++ 1106 F0          	pop di
0075++ 1107 E7          	pop d
0076++ 1108 E8          	pop al
0077++ 1109 09          	ret
0078++ 110A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 110A             ; length of null terminated string
0080++ 110A             ; result in C
0081++ 110A             ; pointer in D
0082++ 110A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 110A             _strlen:
0084++ 110A DA          	push d
0085++ 110B 38 00 00    	mov c, 0
0086++ 110E             _strlen_L1:
0087++ 110E BD 00       	cmp byte [d], 0
0088++ 1110 C6 18 11    	je _strlen_ret
0089++ 1113 79          	inc d
0090++ 1114 78          	inc c
0091++ 1115 0A 0E 11    	jmp _strlen_L1
0092++ 1118             _strlen_ret:
0093++ 1118 E7          	pop d
0094++ 1119 09          	ret
0095++ 111A             
0096++ 111A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 111A             ; STRCMP
0098++ 111A             ; compare two strings
0099++ 111A             ; str1 in SI
0100++ 111A             ; str2 in DI
0101++ 111A             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 111A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 111A             _strcmp:
0104++ 111A DB          	push al
0105++ 111B DA          	push d
0106++ 111C E3          	push di
0107++ 111D E2          	push si
0108++ 111E             _strcmp_loop:
0109++ 111E F3          	cmpsb					; compare a byte of the strings
0110++ 111F C7 2A 11    	jne _strcmp_ret
0111++ 1122 FB FF FF    	lea d, [si +- 1]
0112++ 1125 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1127 C7 1E 11    	jne _strcmp_loop				; equal chars but not at end
0114++ 112A             _strcmp_ret:
0115++ 112A EF          	pop si
0116++ 112B F0          	pop di
0117++ 112C E7          	pop d
0118++ 112D E8          	pop al
0119++ 112E 09          	ret
0120++ 112F             
0121++ 112F             
0122++ 112F             ; STRCPY
0123++ 112F             ; copy null terminated string from SI to DI
0124++ 112F             ; source in SI
0125++ 112F             ; destination in DI
0126++ 112F             _strcpy:
0127++ 112F E2          	push si
0128++ 1130 E3          	push di
0129++ 1131 DB          	push al
0130++ 1132             _strcpy_L1:
0131++ 1132 F6          	lodsb
0132++ 1133 F7          	stosb
0133++ 1134 B9 00       	cmp al, 0
0134++ 1136 C7 32 11    	jne _strcpy_L1
0135++ 1139             _strcpy_end:
0136++ 1139 E8          	pop al
0137++ 113A F0          	pop di
0138++ 113B EF          	pop si
0139++ 113C 09          	ret
0140++ 113D             
0141++ 113D             ; STRCAT
0142++ 113D             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 113D             ; source in SI
0144++ 113D             ; destination in DI
0145++ 113D             _strcat:
0146++ 113D E2          	push si
0147++ 113E E3          	push di
0148++ 113F D7          	push a
0149++ 1140 DA          	push d
0150++ 1141 50          	mov a, di
0151++ 1142 3C          	mov d, a
0152++ 1143             _strcat_goto_end_L1:
0153++ 1143 BD 00       	cmp byte[d], 0
0154++ 1145 C6 4C 11    	je _strcat_start
0155++ 1148 79          	inc d
0156++ 1149 0A 43 11    	jmp _strcat_goto_end_L1
0157++ 114C             _strcat_start:
0158++ 114C FD 50       	mov di, d
0159++ 114E             _strcat_L1:
0160++ 114E F6          	lodsb
0161++ 114F F7          	stosb
0162++ 1150 B9 00       	cmp al, 0
0163++ 1152 C7 4E 11    	jne _strcat_L1
0164++ 1155             _strcat_end:
0165++ 1155 E7          	pop d
0166++ 1156 E4          	pop a
0167++ 1157 F0          	pop di
0168++ 1158 EF          	pop si
0169++ 1159 09          	ret
0170++ 115A             
0171++ 115A             
0005+  115A             
0006+  115A             ;-----------------------------------------------------------------------------
0007+  115A             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0008+  115A             ; ASCII in BL
0009+  115A             ; result in AL
0010+  115A             ; ascii for F = 0100 0110
0011+  115A             ; ascii for 9 = 0011 1001
0012+  115A             ;-----------------------------------------------------------------------------
0013+  115A             hex_ascii_encode:
0014+  115A 1B            mov al, bl
0015+  115B 93 40         test al, $40        ; test if letter or number
0016+  115D C7 63 11      jnz hex_letter
0017+  1160 87 0F         and al, $0F        ; get number
0018+  1162 09            ret
0019+  1163             hex_letter:
0020+  1163 87 0F         and al, $0F        ; get letter
0021+  1165 6A 09         add al, 9
0022+  1167 09            ret
0023+  1168             
0024+  1168             ;-----------------------------------------------------------------------------
0025+  1168             ; ATOI
0026+  1168             ; 2 letter hex string in B
0027+  1168             ; 8bit integer returned in AL
0028+  1168             ;-----------------------------------------------------------------------------
0029+  1168             _atoi:
0030+  1168 D8            push b
0031+  1169 07 5A 11      call hex_ascii_encode      ; convert BL to 4bit code in AL
0032+  116C 30            mov bl, bh
0033+  116D DB            push al          ; save a
0034+  116E 07 5A 11      call hex_ascii_encode
0035+  1171 EA            pop bl  
0036+  1172 FD 9E 04      shl al, 4
0037+  1175 8C            or al, bl
0038+  1176 E5            pop b
0039+  1177 09            ret  
0040+  1178             
0041+  1178             
0042+  1178             ;-----------------------------------------------------------------------------
0043+  1178             ; ITOA
0044+  1178             ; 8bit value in BL
0045+  1178             ; 2 byte ASCII result in A
0046+  1178             ;-----------------------------------------------------------------------------
0047+  1178             _itoa:
0048+  1178 DA            push d
0049+  1179 D8            push b
0050+  117A A7 00         mov bh, 0
0051+  117C FD A4 04      shr bl, 4  
0052+  117F 74            mov d, b
0053+  1180 1F 28 14      mov al, [d + s_hex_digits]
0054+  1183 23            mov ah, al
0055+  1184               
0056+  1184 E5            pop b
0057+  1185 D8            push b
0058+  1186 A7 00         mov bh, 0
0059+  1188 FD 87 0F      and bl, $0F
0060+  118B 74            mov d, b
0061+  118C 1F 28 14      mov al, [d + s_hex_digits]
0062+  118F E5            pop b
0063+  1190 E7            pop d
0064+  1191 09            ret
0065+  1192             
0066+  1192             ;-----------------------------------------------------------------------------
0067+  1192             ; HEX STRING TO BINARY
0068+  1192             ; di = destination address
0069+  1192             ; si = source
0070+  1192             ;-----------------------------------------------------------------------------
0071+  1192             _hex_to_int:
0072+  1192             _hex_to_int_L1:
0073+  1192 F6            lodsb          ; load from [SI] to AL
0074+  1193 B9 00         cmp al, 0        ; check if ASCII 0
0075+  1195 C6 A2 11      jz _hex_to_int_ret
0076+  1198 36            mov bh, al
0077+  1199 F6            lodsb
0078+  119A 2F            mov bl, al
0079+  119B 07 68 11      call _atoi        ; convert ASCII byte in B to int (to AL)
0080+  119E F7            stosb          ; store AL to [DI]
0081+  119F 0A 92 11      jmp _hex_to_int_L1
0082+  11A2             _hex_to_int_ret:
0083+  11A2 09            ret    
0084+  11A3             
0085+  11A3             ;-----------------------------------------------------------------------------
0086+  11A3             ; GETCHAR
0087+  11A3             ; char in ah
0088+  11A3             ;-----------------------------------------------------------------------------
0089+  11A3             getch:
0090+  11A3 DB            push al
0091+  11A4             getch_retry:
0092+  11A4 19 01         mov al, 1
0093+  11A6 05 03         syscall sys_io      ; receive in AH
0094+  11A8 E8            pop al
0095+  11A9 09            ret
0096+  11AA             
0097+  11AA             ;-----------------------------------------------------------------------------
0098+  11AA             ; PUTCHAR
0099+  11AA             ; char in ah
0100+  11AA             ;-----------------------------------------------------------------------------
0101+  11AA             _putchar:
0102+  11AA D7            push a
0103+  11AB 19 00         mov al, 0
0104+  11AD 05 03         syscall sys_io      ; char in AH
0105+  11AF E4            pop a
0106+  11B0 09            ret
0107+  11B1             
0108+  11B1             ;-----------------------------------------------------------------------------
0109+  11B1             ;; INPUT A STRING
0110+  11B1             ;; terminates with null
0111+  11B1             ;; pointer in D
0112+  11B1             ;-----------------------------------------------------------------------------
0113+  11B1             _gets:
0114+  11B1 D7            push a
0115+  11B2 DA            push d
0116+  11B3             _gets_loop:
0117+  11B3 19 01         mov al, 1
0118+  11B5 05 03         syscall sys_io      ; receive in AH
0119+  11B7 B9 00         cmp al, 0        ; check error code (AL)
0120+  11B9 C6 B3 11      je _gets_loop      ; if no char received, retry
0121+  11BC             
0122+  11BC 76 1B         cmp ah, 27
0123+  11BE C6 DF 11      je _gets_ansi_esc
0124+  11C1 76 0A         cmp ah, $0A        ; LF
0125+  11C3 C6 4A 12      je _gets_end
0126+  11C6 76 0D         cmp ah, $0D        ; CR
0127+  11C8 C6 4A 12      je _gets_end
0128+  11CB 76 5C         cmp ah, $5C        ; '\\'
0129+  11CD C6 0B 12      je _gets_escape
0130+  11D0               
0131+  11D0 76 08         cmp ah, $08      ; check for backspace
0132+  11D2 C6 DB 11      je _gets_backspace
0133+  11D5             
0134+  11D5 1A            mov al, ah
0135+  11D6 3E            mov [d], al
0136+  11D7 79            inc d
0137+  11D8 0A B3 11      jmp _gets_loop
0138+  11DB             _gets_backspace:
0139+  11DB 7F            dec d
0140+  11DC 0A B3 11      jmp _gets_loop
0141+  11DF             _gets_ansi_esc:
0142+  11DF 19 01         mov al, 1
0143+  11E1 05 03         syscall sys_io        ; receive in AH without echo
0144+  11E3 B9 00         cmp al, 0          ; check error code (AL)
0145+  11E5 C6 DF 11      je _gets_ansi_esc    ; if no char received, retry
0146+  11E8 76 5B         cmp ah, '['
0147+  11EA C7 B3 11      jne _gets_loop
0148+  11ED             _gets_ansi_esc_2:
0149+  11ED 19 01         mov al, 1
0150+  11EF 05 03         syscall sys_io          ; receive in AH without echo
0151+  11F1 B9 00         cmp al, 0            ; check error code (AL)
0152+  11F3 C6 ED 11      je _gets_ansi_esc_2  ; if no char received, retry
0153+  11F6 76 44         cmp ah, 'D'
0154+  11F8 C6 03 12      je _gets_left_arrow
0155+  11FB 76 43         cmp ah, 'C'
0156+  11FD C6 07 12      je _gets_right_arrow
0157+  1200 0A B3 11      jmp _gets_loop
0158+  1203             _gets_left_arrow:
0159+  1203 7F            dec d
0160+  1204 0A B3 11      jmp _gets_loop
0161+  1207             _gets_right_arrow:
0162+  1207 79            inc d
0163+  1208 0A B3 11      jmp _gets_loop
0164+  120B             _gets_escape:
0165+  120B 19 01         mov al, 1
0166+  120D 05 03         syscall sys_io      ; receive in AH
0167+  120F B9 00         cmp al, 0        ; check error code (AL)
0168+  1211 C6 0B 12      je _gets_escape      ; if no char received, retry
0169+  1214 76 6E         cmp ah, 'n'
0170+  1216 C6 35 12      je _gets_LF
0171+  1219 76 72         cmp ah, 'r'
0172+  121B C6 3C 12      je _gets_CR
0173+  121E 76 30         cmp ah, '0'
0174+  1220 C6 43 12      je _gets_NULL
0175+  1223 76 5C         cmp ah, $5C  ; '\'
0176+  1225 C6 2E 12      je _gets_slash
0177+  1228 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0178+  1229 3E            mov [d], al
0179+  122A 79            inc d
0180+  122B 0A B3 11      jmp _gets_loop
0181+  122E             _gets_slash:
0182+  122E 19 5C         mov al, $5C
0183+  1230 3E            mov [d], al
0184+  1231 79            inc d
0185+  1232 0A B3 11      jmp _gets_loop
0186+  1235             _gets_LF:
0187+  1235 19 0A         mov al, $0A
0188+  1237 3E            mov [d], al
0189+  1238 79            inc d
0190+  1239 0A B3 11      jmp _gets_loop
0191+  123C             _gets_CR:
0192+  123C 19 0D         mov al, $0D
0193+  123E 3E            mov [d], al
0194+  123F 79            inc d
0195+  1240 0A B3 11      jmp _gets_loop
0196+  1243             _gets_NULL:
0197+  1243 19 00         mov al, $00
0198+  1245 3E            mov [d], al
0199+  1246 79            inc d
0200+  1247 0A B3 11      jmp _gets_loop
0201+  124A             _gets_end:
0202+  124A 19 00         mov al, 0
0203+  124C 3E            mov [d], al        ; terminate string
0204+  124D E7            pop d
0205+  124E E4            pop a
0206+  124F 09            ret
0207+  1250             
0208+  1250             ;-----------------------------------------------------------------------------
0209+  1250             ;; INPUT TEXT
0210+  1250             ;; terminated with CTRL+D
0211+  1250             ;; pointer in D
0212+  1250             ;-----------------------------------------------------------------------------
0213+  1250             _gettxt:
0214+  1250 D7            push a
0215+  1251 DA            push d
0216+  1252             _gettxt_loop:
0217+  1252 19 01         mov al, 1
0218+  1254 05 03         syscall sys_io      ; receive in AH
0219+  1256 B9 00         cmp al, 0        ; check error code (AL)
0220+  1258 C6 52 12      je _gettxt_loop    ; if no char received, retry
0221+  125B 76 04         cmp ah, 4      ; EOT
0222+  125D C6 9B 12      je _gettxt_end
0223+  1260 76 08         cmp ah, $08      ; check for backspace
0224+  1262 C6 97 12      je _gettxt_backspace
0225+  1265 76 5C         cmp ah, $5C        ; '\'
0226+  1267 C6 70 12      je _gettxt_escape
0227+  126A 1A            mov al, ah
0228+  126B 3E            mov [d], al
0229+  126C 79            inc d
0230+  126D 0A 52 12      jmp _gettxt_loop
0231+  1270             _gettxt_escape:
0232+  1270 19 01         mov al, 1
0233+  1272 05 03         syscall sys_io      ; receive in AH
0234+  1274 B9 00         cmp al, 0        ; check error code (AL)
0235+  1276 C6 70 12      je _gettxt_escape    ; if no char received, retry
0236+  1279 76 6E         cmp ah, 'n'
0237+  127B C6 89 12      je _gettxt_LF
0238+  127E 76 72         cmp ah, 'r'
0239+  1280 C6 90 12      je _gettxt_CR
0240+  1283 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0241+  1284 3E            mov [d], al
0242+  1285 79            inc d
0243+  1286 0A 52 12      jmp _gettxt_loop
0244+  1289             _gettxt_LF:
0245+  1289 19 0A         mov al, $0A
0246+  128B 3E            mov [d], al
0247+  128C 79            inc d
0248+  128D 0A 52 12      jmp _gettxt_loop
0249+  1290             _gettxt_CR:
0250+  1290 19 0D         mov al, $0D
0251+  1292 3E            mov [d], al
0252+  1293 79            inc d
0253+  1294 0A 52 12      jmp _gettxt_loop
0254+  1297             _gettxt_backspace:
0255+  1297 7F            dec d
0256+  1298 0A 52 12      jmp _gettxt_loop
0257+  129B             _gettxt_end:
0258+  129B 19 00         mov al, 0
0259+  129D 3E            mov [d], al        ; terminate string
0260+  129E E7            pop d
0261+  129F E4            pop a
0262+  12A0 09            ret
0263+  12A1             
0264+  12A1             ;-----------------------------------------------------------------------------
0265+  12A1             ; PRINT NEW LINE
0266+  12A1             ;-----------------------------------------------------------------------------
0267+  12A1             printnl:
0268+  12A1 D7            push a
0269+  12A2 10 00 0A      mov a, $0A00
0270+  12A5 05 03         syscall sys_io
0271+  12A7 10 00 0D      mov a, $0D00
0272+  12AA 05 03         syscall sys_io
0273+  12AC E4            pop a
0274+  12AD 09            ret
0275+  12AE             
0276+  12AE             ;-----------------------------------------------------------------------------
0277+  12AE             ; _strtoint
0278+  12AE             ; 4 digit hex string number in d
0279+  12AE             ; integer returned in A
0280+  12AE             ;-----------------------------------------------------------------------------
0281+  12AE             _strtointx:
0282+  12AE D8            push b
0283+  12AF 32            mov bl, [d]
0284+  12B0 37            mov bh, bl
0285+  12B1 33 01 00      mov bl, [d + 1]
0286+  12B4 07 68 11      call _atoi        ; convert to int in AL
0287+  12B7 23            mov ah, al        ; move to AH
0288+  12B8 33 02 00      mov bl, [d + 2]
0289+  12BB 37            mov bh, bl
0290+  12BC 33 03 00      mov bl, [d + 3]
0291+  12BF 07 68 11      call _atoi        ; convert to int in AL
0292+  12C2 E5            pop b
0293+  12C3 09            ret
0294+  12C4             
0295+  12C4             ;-----------------------------------------------------------------------------
0296+  12C4             ; _strtoint
0297+  12C4             ; 5 digit base10 string number in d
0298+  12C4             ; integer returned in A
0299+  12C4             ;-----------------------------------------------------------------------------
0300+  12C4             _strtoint:
0301+  12C4 E2            push si
0302+  12C5 D8            push b
0303+  12C6 D9            push c
0304+  12C7 DA            push d
0305+  12C8 07 0A 11      call _strlen      ; get string length in C
0306+  12CB 7E            dec c
0307+  12CC FD 4E         mov si, d
0308+  12CE 12            mov a, c
0309+  12CF FD 99         shl a
0310+  12D1 3B 40 14      mov d, table_power
0311+  12D4 59            add d, a
0312+  12D5 38 00 00      mov c, 0
0313+  12D8             _strtoint_L0:
0314+  12D8 F6            lodsb      ; load ASCII to al
0315+  12D9 B9 00         cmp al, 0
0316+  12DB C6 EE 12      je _strtoint_end
0317+  12DE 6F 30         sub al, $30    ; make into integer
0318+  12E0 22 00         mov ah, 0
0319+  12E2 2A            mov b, [d]
0320+  12E3 AC            mul a, b      ; result in B since it fits in 16bits
0321+  12E4 11            mov a, b
0322+  12E5 28            mov b, c
0323+  12E6 54            add a, b
0324+  12E7 39            mov c, a
0325+  12E8 63 02 00      sub d, 2
0326+  12EB 0A D8 12      jmp _strtoint_L0
0327+  12EE             _strtoint_end:
0328+  12EE 12            mov a, c
0329+  12EF E7            pop d
0330+  12F0 E6            pop c
0331+  12F1 E5            pop b
0332+  12F2 EF            pop si
0333+  12F3 09            ret
0334+  12F4             
0335+  12F4             ;-----------------------------------------------------------------------------
0336+  12F4             ; PRINT NULL TERMINATED STRING
0337+  12F4             ; pointer in D
0338+  12F4             ;-----------------------------------------------------------------------------
0339+  12F4             _puts:
0340+  12F4 D7            push a
0341+  12F5 DA            push d
0342+  12F6             _puts_L1:
0343+  12F6 1E            mov al, [d]
0344+  12F7 B9 00         cmp al, 0
0345+  12F9 C6 05 13      jz _puts_END
0346+  12FC 23            mov ah, al
0347+  12FD 19 00         mov al, 0
0348+  12FF 05 03         syscall sys_io
0349+  1301 79            inc d
0350+  1302 0A F6 12      jmp _puts_L1
0351+  1305             _puts_END:
0352+  1305 E7            pop d
0353+  1306 E4            pop a
0354+  1307 09            ret
0355+  1308             
0356+  1308             ;-----------------------------------------------------------------------------
0357+  1308             ; PRINT N SIZE STRING
0358+  1308             ; pointer in D
0359+  1308             ; size in C
0360+  1308             ;-----------------------------------------------------------------------------
0361+  1308             _putsn:
0362+  1308 DB            push al
0363+  1309 DA            push d
0364+  130A D9            push c
0365+  130B             _putsn_L0:
0366+  130B 1E            mov al, [d]
0367+  130C 23            mov ah, al
0368+  130D 19 00         mov al, 0
0369+  130F 05 03         syscall sys_io
0370+  1311 79            inc d
0371+  1312 7E            dec c  
0372+  1313 C2 00 00      cmp c, 0
0373+  1316 C7 0B 13      jne _putsn_L0
0374+  1319             _putsn_end:
0375+  1319 E6            pop c
0376+  131A E7            pop d
0377+  131B E8            pop al
0378+  131C 09            ret
0379+  131D             
0380+  131D             ;-----------------------------------------------------------------------------
0381+  131D             ; print 16bit decimal number
0382+  131D             ; input number in A
0383+  131D             ;-----------------------------------------------------------------------------
0384+  131D             print_u16d:
0385+  131D D7            push a
0386+  131E D8            push b
0387+  131F 26 10 27      mov b, 10000
0388+  1322 AE            div a, b      ; get 10000's coeff.
0389+  1323 07 45 13      call print_number
0390+  1326 11            mov a, b
0391+  1327 26 E8 03      mov b, 1000
0392+  132A AE            div a, b      ; get 1000's coeff.
0393+  132B 07 45 13      call print_number
0394+  132E 11            mov a, b
0395+  132F 26 64 00      mov b, 100
0396+  1332 AE            div a, b
0397+  1333 07 45 13      call print_number
0398+  1336 11            mov a, b
0399+  1337 26 0A 00      mov b, 10
0400+  133A AE            div a, b
0401+  133B 07 45 13      call print_number
0402+  133E 1B            mov al, bl      ; 1's coeff in bl
0403+  133F 07 45 13      call print_number
0404+  1342 E5            pop b
0405+  1343 E4            pop a
0406+  1344 09            ret
0407+  1345             
0408+  1345             ;-----------------------------------------------------------------------------
0409+  1345             ; print AL
0410+  1345             ;-----------------------------------------------------------------------------
0411+  1345             print_number:
0412+  1345 6A 30         add al, $30
0413+  1347 23            mov ah, al
0414+  1348 07 AA 11      call _putchar
0415+  134B 09            ret
0416+  134C             
0417+  134C             ;-----------------------------------------------------------------------------
0418+  134C             ; PRINT 16BIT HEX INTEGER
0419+  134C             ; integer value in reg B
0420+  134C             ;-----------------------------------------------------------------------------
0421+  134C             print_u16x:
0422+  134C D7            push a
0423+  134D D8            push b
0424+  134E DD            push bl
0425+  134F 30            mov bl, bh
0426+  1350 07 78 11      call _itoa        ; convert bh to char in A
0427+  1353 2F            mov bl, al        ; save al
0428+  1354 19 00         mov al, 0
0429+  1356 05 03         syscall sys_io        ; display AH
0430+  1358 24            mov ah, bl        ; retrieve al
0431+  1359 19 00         mov al, 0
0432+  135B 05 03         syscall sys_io        ; display AL
0433+  135D             
0434+  135D EA            pop bl
0435+  135E 07 78 11      call _itoa        ; convert bh to char in A
0436+  1361 2F            mov bl, al        ; save al
0437+  1362 19 00         mov al, 0
0438+  1364 05 03         syscall sys_io        ; display AH
0439+  1366 24            mov ah, bl        ; retrieve al
0440+  1367 19 00         mov al, 0
0441+  1369 05 03         syscall sys_io        ; display AL
0442+  136B             
0443+  136B E5            pop b
0444+  136C E4            pop a
0445+  136D 09            ret
0446+  136E             
0447+  136E             ;-----------------------------------------------------------------------------
0448+  136E             ; INPUT 16BIT HEX INTEGER
0449+  136E             ; read 16bit integer into A
0450+  136E             ;-----------------------------------------------------------------------------
0451+  136E             scan_u16x:
0452+  136E F8 10 00      enter 16
0453+  1371 D8            push b
0454+  1372 DA            push d
0455+  1373             
0456+  1373 FA F1 FF      lea d, [bp + -15]
0457+  1376 07 B1 11      call _gets        ; get number
0458+  1379             
0459+  1379 32            mov bl, [d]
0460+  137A 37            mov bh, bl
0461+  137B 33 01 00      mov bl, [d + 1]
0462+  137E 07 68 11      call _atoi        ; convert to int in AL
0463+  1381 23            mov ah, al        ; move to AH
0464+  1382             
0465+  1382 33 02 00      mov bl, [d + 2]
0466+  1385 37            mov bh, bl
0467+  1386 33 03 00      mov bl, [d + 3]
0468+  1389 07 68 11      call _atoi        ; convert to int in AL
0469+  138C             
0470+  138C E7            pop d
0471+  138D E5            pop b
0472+  138E F9            leave
0473+  138F 09            ret
0474+  1390             
0475+  1390             ;-----------------------------------------------------------------------------
0476+  1390             ; PRINT 8bit HEX INTEGER
0477+  1390             ; integer value in reg bl
0478+  1390             ;-----------------------------------------------------------------------------
0479+  1390             print_u8x:
0480+  1390 D7            push a
0481+  1391 DD            push bl
0482+  1392             
0483+  1392 07 78 11      call _itoa        ; convert bl to char in A
0484+  1395 2F            mov bl, al        ; save al
0485+  1396 19 00         mov al, 0
0486+  1398 05 03         syscall sys_io        ; display AH
0487+  139A 24            mov ah, bl        ; retrieve al
0488+  139B 19 00         mov al, 0
0489+  139D 05 03         syscall sys_io        ; display AL
0490+  139F             
0491+  139F EA            pop bl
0492+  13A0 E4            pop a
0493+  13A1 09            ret
0494+  13A2             
0495+  13A2             ;-----------------------------------------------------------------------------
0496+  13A2             ; print 8bit decimal unsigned number
0497+  13A2             ; input number in AL
0498+  13A2             ;-----------------------------------------------------------------------------
0499+  13A2             print_u8d:
0500+  13A2 D7            push a
0501+  13A3 D8            push b
0502+  13A4             
0503+  13A4 22 00         mov ah, 0
0504+  13A6 26 64 00      mov b, 100
0505+  13A9 AE            div a, b
0506+  13AA D8            push b      ; save remainder
0507+  13AB B9 00         cmp al, 0
0508+  13AD C6 B7 13      je skip100
0509+  13B0 6A 30         add al, $30
0510+  13B2 23            mov ah, al
0511+  13B3 19 00         mov al, 0
0512+  13B5 05 03         syscall sys_io  ; print coeff
0513+  13B7             skip100:
0514+  13B7 E4            pop a
0515+  13B8 22 00         mov ah, 0
0516+  13BA 26 0A 00      mov b, 10
0517+  13BD AE            div a, b
0518+  13BE D8            push b      ; save remainder
0519+  13BF B9 00         cmp al, 0
0520+  13C1 C6 CB 13      je skip10
0521+  13C4 6A 30         add al, $30
0522+  13C6 23            mov ah, al
0523+  13C7 19 00         mov al, 0
0524+  13C9 05 03         syscall sys_io  ; print coeff
0525+  13CB             skip10:
0526+  13CB E4            pop a
0527+  13CC 1B            mov al, bl
0528+  13CD 6A 30         add al, $30
0529+  13CF 23            mov ah, al
0530+  13D0 19 00         mov al, 0
0531+  13D2 05 03         syscall sys_io  ; print coeff
0532+  13D4 E5            pop b
0533+  13D5 E4            pop a
0534+  13D6 09            ret
0535+  13D7             
0536+  13D7             ;-----------------------------------------------------------------------------
0537+  13D7             ; INPUT 8BIT HEX INTEGER
0538+  13D7             ; read 8bit integer into AL
0539+  13D7             ;-----------------------------------------------------------------------------
0540+  13D7             scan_u8x:
0541+  13D7 F8 04 00      enter 4
0542+  13DA D8            push b
0543+  13DB DA            push d
0544+  13DC             
0545+  13DC FA FD FF      lea d, [bp + -3]
0546+  13DF 07 B1 11      call _gets        ; get number
0547+  13E2             
0548+  13E2 32            mov bl, [d]
0549+  13E3 37            mov bh, bl
0550+  13E4 33 01 00      mov bl, [d + 1]
0551+  13E7 07 68 11      call _atoi        ; convert to int in AL
0552+  13EA             
0553+  13EA E7            pop d
0554+  13EB E5            pop b
0555+  13EC F9            leave
0556+  13ED 09            ret
0557+  13EE             
0558+  13EE             ;-----------------------------------------------------------------------------
0559+  13EE             ; input decimal number
0560+  13EE             ; result in A
0561+  13EE             ; 655'\0'
0562+  13EE             ; low--------high
0563+  13EE             ;-----------------------------------------------------------------------------
0564+  13EE             scan_u16d:
0565+  13EE F8 08 00      enter 8
0566+  13F1 E2            push si
0567+  13F2 D8            push b
0568+  13F3 D9            push c
0569+  13F4 DA            push d
0570+  13F5 FA F9 FF      lea d, [bp +- 7]
0571+  13F8 07 B1 11      call _gets
0572+  13FB 07 0A 11      call _strlen      ; get string length in C
0573+  13FE 7E            dec c
0574+  13FF FD 4E         mov si, d
0575+  1401 12            mov a, c
0576+  1402 FD 99         shl a
0577+  1404 3B 40 14      mov d, table_power
0578+  1407 59            add d, a
0579+  1408 38 00 00      mov c, 0
0580+  140B             mul_loop:
0581+  140B F6            lodsb      ; load ASCII to al
0582+  140C B9 00         cmp al, 0
0583+  140E C6 21 14      je mul_exit
0584+  1411 6F 30         sub al, $30    ; make into integer
0585+  1413 22 00         mov ah, 0
0586+  1415 2A            mov b, [d]
0587+  1416 AC            mul a, b      ; result in B since it fits in 16bits
0588+  1417 11            mov a, b
0589+  1418 28            mov b, c
0590+  1419 54            add a, b
0591+  141A 39            mov c, a
0592+  141B 63 02 00      sub d, 2
0593+  141E 0A 0B 14      jmp mul_loop
0594+  1421             mul_exit:
0595+  1421 12            mov a, c
0596+  1422 E7            pop d
0597+  1423 E6            pop c
0598+  1424 E5            pop b
0599+  1425 EF            pop si
0600+  1426 F9            leave
0601+  1427 09            ret
0602+  1428             
0603+  1428 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0603+  142C 34 35 36 37 
0603+  1430 38 39 41 42 
0603+  1434 43 44 45 46 
0604+  1438 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0604+  143C 1B 5B 48 00 
0605+  1440             
0606+  1440             table_power:
0607+  1440 01 00         .dw 1
0608+  1442 0A 00         .dw 10
0609+  1444 64 00         .dw 100
0610+  1446 E8 03         .dw 1000
0611+  1448 10 27         .dw 100002365   144A             ; --- END INLINE ASM BLOCK
2366   144A             
2367   144A F9            leave
2368   144B 09            ret
2369   144C             ; --- END TEXT BLOCK
2370   144C             
2371   144C             ; --- BEGIN DATA BLOCK
2372   144C 00 00 00 00 _il0: .fill 4, 0
2373   1450 00 00 00 00 _il1: .fill 4, 0
2374   1454 00 00       _i0: .fill 2, 0
2375   1456 00 00       _i1: .fill 2, 0
2376   1458 00          _c0: .fill 1, 0
2377   1459 00          _c1: .fill 1, 0
2378   145A 55 6E 65 78 __s0: .db "Unexpected format in printf.", 0
2378   145E 70 65 63 74 
2378   1462 65 64 20 66 
2378   1466 6F 72 6D 61 
2378   146A 74 20 69 6E 
2378   146E 20 70 72 69 
2378   1472 6E 74 66 2E 
2378   1476 00 
2379   1477 45 72 72 6F __s1: .db "Error: Unknown argument type.\n", 0
2379   147B 72 3A 20 55 
2379   147F 6E 6B 6E 6F 
2379   1483 77 6E 20 61 
2379   1487 72 67 75 6D 
2379   148B 65 6E 74 20 
2379   148F 74 79 70 65 
2379   1493 2E 0A 00 
2380   1496 1B 5B 32 4A __s2: .db "\033[2J\033[H", 0
2380   149A 1B 5B 48 00 
2381   149E             
2382   149E A0 14       _heap_top: .dw _heap
2383   14A0 00          _heap: .db 0
2384   14A1             ; --- END DATA BLOCK
2385   14A1             
2386   14A1             .end
tasm: Number of errors = 0
