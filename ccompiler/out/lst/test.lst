0001   0000             ; --- FILENAME: test
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ;; c = a + b; 
0011   0408 3B 04 11      mov d, _c ; $c
0012   040B DA            push d
0013   040C 3B FC 10      mov d, _a ; $a
0014   040F 2A            mov b, [d]
0015   0410             ; START TERMS
0016   0410 D7            push a
0017   0411 11            mov a, b
0018   0412 3B 00 11      mov d, _b ; $b
0019   0415 2A            mov b, [d]
0020   0416 54            add a, b
0021   0417 27            mov b, a
0022   0418 E4            pop a
0023   0419             ; END TERMS
0024   0419 E7            pop d
0025   041A FD 43         mov [d], b
0026   041C 05 0B         syscall sys_terminate_proc
0027   041E             
0028   041E             strcpy:
0029   041E F8 00 00      enter 0 ; (push bp; mov bp, sp)
0030   0421             ; $psrc 
0031   0421             ; $pdest 
0032   0421 52 04 00      sub sp, 4
0033   0424             ;; psrc = src; 
0034   0424 FA FF FF      lea d, [bp + -1] ; $psrc
0035   0427 DA            push d
0036   0428 FA 07 00      lea d, [bp + 7] ; $src
0037   042B 2A            mov b, [d]
0038   042C E7            pop d
0039   042D FD 43         mov [d], b
0040   042F             ;; pdest = dest; 
0041   042F FA FD FF      lea d, [bp + -3] ; $pdest
0042   0432 DA            push d
0043   0433 FA 05 00      lea d, [bp + 5] ; $dest
0044   0436 2A            mov b, [d]
0045   0437 E7            pop d
0046   0438 FD 43         mov [d], b
0047   043A             ;; while(*psrc) *pdest++ = *psrc++; 
0048   043A             _while1_cond:
0049   043A FA FF FF      lea d, [bp + -1] ; $psrc
0050   043D 2A            mov b, [d]
0051   043E 74            mov d, b
0052   043F 32            mov bl, [d]
0053   0440 A7 00         mov bh, 0
0054   0442 C0 00 00      cmp b, 0
0055   0445 C6 71 04      je _while1_exit
0056   0448             _while1_block:
0057   0448             ;; *pdest++ = *psrc++; 
0058   0448 FA FD FF      lea d, [bp + -3] ; $pdest
0059   044B 2A            mov b, [d]
0060   044C FD 79         mov g, b
0061   044E FD 77         inc b
0062   0450 FA FD FF      lea d, [bp + -3] ; $pdest
0063   0453 FD 43         mov [d], b
0064   0455 FD 27         mov b, g
0065   0457 D8            push b
0066   0458 FA FF FF      lea d, [bp + -1] ; $psrc
0067   045B 2A            mov b, [d]
0068   045C FD 79         mov g, b
0069   045E FD 77         inc b
0070   0460 FA FF FF      lea d, [bp + -1] ; $psrc
0071   0463 FD 43         mov [d], b
0072   0465 FD 27         mov b, g
0073   0467 74            mov d, b
0074   0468 32            mov bl, [d]
0075   0469 A7 00         mov bh, 0
0076   046B E7            pop d
0077   046C FD 3E         mov [d], bl
0078   046E 0A 3A 04      jmp _while1_cond
0079   0471             _while1_exit:
0080   0471             ;; *pdest = '\0'; 
0081   0471 FA FD FF      lea d, [bp + -3] ; $pdest
0082   0474 2A            mov b, [d]
0083   0475 D8            push b
0084   0476 26 00 00      mov b, $0
0085   0479 E7            pop d
0086   047A FD 3E         mov [d], bl
0087   047C F9            leave
0088   047D 09            ret
0089   047E             
0090   047E             strcmp:
0091   047E F8 00 00      enter 0 ; (push bp; mov bp, sp)
0092   0481             ;; while (*s1 && (*s1 == *s2)) { 
0093   0481             _while2_cond:
0094   0481 FA 05 00      lea d, [bp + 5] ; $s1
0095   0484 2A            mov b, [d]
0096   0485 74            mov d, b
0097   0486 32            mov bl, [d]
0098   0487 A7 00         mov bh, 0
0099   0489 D7            push a
0100   048A 11            mov a, b
0101   048B FA 05 00      lea d, [bp + 5] ; $s1
0102   048E 2A            mov b, [d]
0103   048F 74            mov d, b
0104   0490 32            mov bl, [d]
0105   0491 A7 00         mov bh, 0
0106   0493             ; START RELATIONAL
0107   0493 D7            push a
0108   0494 11            mov a, b
0109   0495 FA 07 00      lea d, [bp + 7] ; $s2
0110   0498 2A            mov b, [d]
0111   0499 74            mov d, b
0112   049A 32            mov bl, [d]
0113   049B A7 00         mov bh, 0
0114   049D B0            cmp a, b
0115   049E FD 71         seq ; ==
0116   04A0 E4            pop a
0117   04A1             ; END RELATIONAL
0118   04A1 FD A7         sand a, b ; &&
0119   04A3 E4            pop a
0120   04A4 C0 00 00      cmp b, 0
0121   04A7 C6 CB 04      je _while2_exit
0122   04AA             _while2_block:
0123   04AA             ;; s1++; 
0124   04AA FA 05 00      lea d, [bp + 5] ; $s1
0125   04AD 2A            mov b, [d]
0126   04AE FD 79         mov g, b
0127   04B0 FD 77         inc b
0128   04B2 FA 05 00      lea d, [bp + 5] ; $s1
0129   04B5 FD 43         mov [d], b
0130   04B7 FD 27         mov b, g
0131   04B9             ;; s2++; 
0132   04B9 FA 07 00      lea d, [bp + 7] ; $s2
0133   04BC 2A            mov b, [d]
0134   04BD FD 79         mov g, b
0135   04BF FD 77         inc b
0136   04C1 FA 07 00      lea d, [bp + 7] ; $s2
0137   04C4 FD 43         mov [d], b
0138   04C6 FD 27         mov b, g
0139   04C8 0A 81 04      jmp _while2_cond
0140   04CB             _while2_exit:
0141   04CB             ;; return *s1 - *s2; 
0142   04CB FA 05 00      lea d, [bp + 5] ; $s1
0143   04CE 2A            mov b, [d]
0144   04CF 74            mov d, b
0145   04D0 32            mov bl, [d]
0146   04D1 A7 00         mov bh, 0
0147   04D3             ; START TERMS
0148   04D3 D7            push a
0149   04D4 11            mov a, b
0150   04D5 FA 07 00      lea d, [bp + 7] ; $s2
0151   04D8 2A            mov b, [d]
0152   04D9 74            mov d, b
0153   04DA 32            mov bl, [d]
0154   04DB A7 00         mov bh, 0
0155   04DD 60            sub a, b
0156   04DE 27            mov b, a
0157   04DF E4            pop a
0158   04E0             ; END TERMS
0159   04E0 F9            leave
0160   04E1 09            ret
0161   04E2             
0162   04E2             strcat:
0163   04E2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0164   04E5             ; $dest_len 
0165   04E5             ; $i 
0166   04E5 52 04 00      sub sp, 4
0167   04E8             ;; dest_len = strlen(dest); 
0168   04E8 FA FF FF      lea d, [bp + -1] ; $dest_len
0169   04EB DA            push d
0170   04EC FA 05 00      lea d, [bp + 5] ; $dest
0171   04EF 2A            mov b, [d]
0172   04F0 FD AB         swp b
0173   04F2 D8            push b
0174   04F3 07 98 05      call strlen
0175   04F6 51 02 00      add sp, 2
0176   04F9 E7            pop d
0177   04FA FD 43         mov [d], b
0178   04FC             ;; for (i = 0; src[i] != 0; i=i+1) { 
0179   04FC             _for3_init:
0180   04FC FA FD FF      lea d, [bp + -3] ; $i
0181   04FF DA            push d
0182   0500 26 00 00      mov b, $0
0183   0503 E7            pop d
0184   0504 FD 43         mov [d], b
0185   0506             _for3_cond:
0186   0506 FA 07 00      lea d, [bp + 7] ; $src
0187   0509 FD 2A         mov d, [d]
0188   050B D7            push a
0189   050C DA            push d
0190   050D FA FD FF      lea d, [bp + -3] ; $i
0191   0510 2A            mov b, [d]
0192   0511 E7            pop d
0193   0512 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0194   0516 E4            pop a
0195   0517 32            mov bl, [d]
0196   0518 A7 00         mov bh, 0
0197   051A             ; START RELATIONAL
0198   051A D7            push a
0199   051B 11            mov a, b
0200   051C 26 00 00      mov b, $0
0201   051F B0            cmp a, b
0202   0520 FD 72         sneq ; !=
0203   0522 E4            pop a
0204   0523             ; END RELATIONAL
0205   0523 C0 00 00      cmp b, 0
0206   0526 C6 71 05      je _for3_exit
0207   0529             _for3_block:
0208   0529             ;; dest[dest_len + i] = src[i]; 
0209   0529 FA 05 00      lea d, [bp + 5] ; $dest
0210   052C FD 2A         mov d, [d]
0211   052E D7            push a
0212   052F DA            push d
0213   0530 FA FF FF      lea d, [bp + -1] ; $dest_len
0214   0533 2A            mov b, [d]
0215   0534             ; START TERMS
0216   0534 D7            push a
0217   0535 11            mov a, b
0218   0536 FA FD FF      lea d, [bp + -3] ; $i
0219   0539 2A            mov b, [d]
0220   053A 54            add a, b
0221   053B 27            mov b, a
0222   053C E4            pop a
0223   053D             ; END TERMS
0224   053D E7            pop d
0225   053E FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0226   0542 E4            pop a
0227   0543 DA            push d
0228   0544 FA 07 00      lea d, [bp + 7] ; $src
0229   0547 FD 2A         mov d, [d]
0230   0549 D7            push a
0231   054A DA            push d
0232   054B FA FD FF      lea d, [bp + -3] ; $i
0233   054E 2A            mov b, [d]
0234   054F E7            pop d
0235   0550 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0236   0554 E4            pop a
0237   0555 32            mov bl, [d]
0238   0556 A7 00         mov bh, 0
0239   0558 E7            pop d
0240   0559 FD 3E         mov [d], bl
0241   055B             _for3_update:
0242   055B FA FD FF      lea d, [bp + -3] ; $i
0243   055E DA            push d
0244   055F FA FD FF      lea d, [bp + -3] ; $i
0245   0562 2A            mov b, [d]
0246   0563             ; START TERMS
0247   0563 D7            push a
0248   0564 11            mov a, b
0249   0565 26 01 00      mov b, $1
0250   0568 54            add a, b
0251   0569 27            mov b, a
0252   056A E4            pop a
0253   056B             ; END TERMS
0254   056B E7            pop d
0255   056C FD 43         mov [d], b
0256   056E 0A 06 05      jmp _for3_cond
0257   0571             _for3_exit:
0258   0571             ;; dest[dest_len + i] = 0; 
0259   0571 FA 05 00      lea d, [bp + 5] ; $dest
0260   0574 FD 2A         mov d, [d]
0261   0576 D7            push a
0262   0577 DA            push d
0263   0578 FA FF FF      lea d, [bp + -1] ; $dest_len
0264   057B 2A            mov b, [d]
0265   057C             ; START TERMS
0266   057C D7            push a
0267   057D 11            mov a, b
0268   057E FA FD FF      lea d, [bp + -3] ; $i
0269   0581 2A            mov b, [d]
0270   0582 54            add a, b
0271   0583 27            mov b, a
0272   0584 E4            pop a
0273   0585             ; END TERMS
0274   0585 E7            pop d
0275   0586 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0276   058A E4            pop a
0277   058B DA            push d
0278   058C 26 00 00      mov b, $0
0279   058F E7            pop d
0280   0590 FD 3E         mov [d], bl
0281   0592             ;; return dest; 
0282   0592 FA 05 00      lea d, [bp + 5] ; $dest
0283   0595 2A            mov b, [d]
0284   0596 F9            leave
0285   0597 09            ret
0286   0598             
0287   0598             strlen:
0288   0598 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0289   059B             ; $length 
0290   059B 52 02 00      sub sp, 2
0291   059E             ;; length = 0; 
0292   059E FA FF FF      lea d, [bp + -1] ; $length
0293   05A1 DA            push d
0294   05A2 26 00 00      mov b, $0
0295   05A5 E7            pop d
0296   05A6 FD 43         mov [d], b
0297   05A8             ;; while (str[length] != 0) { 
0298   05A8             _while4_cond:
0299   05A8 FA 05 00      lea d, [bp + 5] ; $str
0300   05AB FD 2A         mov d, [d]
0301   05AD D7            push a
0302   05AE DA            push d
0303   05AF FA FF FF      lea d, [bp + -1] ; $length
0304   05B2 2A            mov b, [d]
0305   05B3 E7            pop d
0306   05B4 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0307   05B8 E4            pop a
0308   05B9 32            mov bl, [d]
0309   05BA A7 00         mov bh, 0
0310   05BC             ; START RELATIONAL
0311   05BC D7            push a
0312   05BD 11            mov a, b
0313   05BE 26 00 00      mov b, $0
0314   05C1 B0            cmp a, b
0315   05C2 FD 72         sneq ; !=
0316   05C4 E4            pop a
0317   05C5             ; END RELATIONAL
0318   05C5 C0 00 00      cmp b, 0
0319   05C8 C6 DD 05      je _while4_exit
0320   05CB             _while4_block:
0321   05CB             ;; length++; 
0322   05CB FA FF FF      lea d, [bp + -1] ; $length
0323   05CE 2A            mov b, [d]
0324   05CF FD 79         mov g, b
0325   05D1 FD 77         inc b
0326   05D3 FA FF FF      lea d, [bp + -1] ; $length
0327   05D6 FD 43         mov [d], b
0328   05D8 FD 27         mov b, g
0329   05DA 0A A8 05      jmp _while4_cond
0330   05DD             _while4_exit:
0331   05DD             ;; return length; 
0332   05DD FA FF FF      lea d, [bp + -1] ; $length
0333   05E0 2A            mov b, [d]
0334   05E1 F9            leave
0335   05E2 09            ret
0336   05E3             
0337   05E3             printf:
0338   05E3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0339   05E6             ; $p 
0340   05E6             ; $fp 
0341   05E6             ; $i 
0342   05E6 52 06 00      sub sp, 6
0343   05E9             ;; fp = format; 
0344   05E9 FA FD FF      lea d, [bp + -3] ; $fp
0345   05EC DA            push d
0346   05ED FA 05 00      lea d, [bp + 5] ; $format
0347   05F0 2A            mov b, [d]
0348   05F1 E7            pop d
0349   05F2 FD 43         mov [d], b
0350   05F4             ;; p = &format + 2; 
0351   05F4 FA FF FF      lea d, [bp + -1] ; $p
0352   05F7 DA            push d
0353   05F8 FA 05 00      lea d, [bp + 5] ; $format
0354   05FB 2D            mov b, d
0355   05FC             ; START TERMS
0356   05FC D7            push a
0357   05FD 11            mov a, b
0358   05FE 26 02 00      mov b, $2
0359   0601 54            add a, b
0360   0602 27            mov b, a
0361   0603 E4            pop a
0362   0604             ; END TERMS
0363   0604 E7            pop d
0364   0605 FD 43         mov [d], b
0365   0607             ;; for(;;){ 
0366   0607             _for5_init:
0367   0607             _for5_cond:
0368   0607             _for5_block:
0369   0607             ;; if(!*fp) break; 
0370   0607             _if6_cond:
0371   0607 FA FD FF      lea d, [bp + -3] ; $fp
0372   060A 2A            mov b, [d]
0373   060B 74            mov d, b
0374   060C 32            mov bl, [d]
0375   060D A7 00         mov bh, 0
0376   060F C0 00 00      cmp b, 0
0377   0612 FD 71         seq ; !
0378   0614 C0 00 00      cmp b, 0
0379   0617 C6 20 06      je _if6_else
0380   061A             _if6_true:
0381   061A             ;; break; 
0382   061A 0A 6A 07      jmp _for5_exit ; for break
0383   061D 0A 67 07      jmp _if6_exit
0384   0620             _if6_else:
0385   0620             ;; if(*fp == '%'){ 
0386   0620             _if7_cond:
0387   0620 FA FD FF      lea d, [bp + -3] ; $fp
0388   0623 2A            mov b, [d]
0389   0624 74            mov d, b
0390   0625 32            mov bl, [d]
0391   0626 A7 00         mov bh, 0
0392   0628             ; START RELATIONAL
0393   0628 D7            push a
0394   0629 11            mov a, b
0395   062A 26 25 00      mov b, $25
0396   062D B0            cmp a, b
0397   062E FD 71         seq ; ==
0398   0630 E4            pop a
0399   0631             ; END RELATIONAL
0400   0631 C0 00 00      cmp b, 0
0401   0634 C6 49 07      je _if7_else
0402   0637             _if7_true:
0403   0637             ;; fp++; 
0404   0637 FA FD FF      lea d, [bp + -3] ; $fp
0405   063A 2A            mov b, [d]
0406   063B FD 79         mov g, b
0407   063D FD 77         inc b
0408   063F FA FD FF      lea d, [bp + -3] ; $fp
0409   0642 FD 43         mov [d], b
0410   0644 FD 27         mov b, g
0411   0646             ;; switch(*fp){ 
0412   0646             _switch8_expr:
0413   0646 FA FD FF      lea d, [bp + -3] ; $fp
0414   0649 2A            mov b, [d]
0415   064A 74            mov d, b
0416   064B 32            mov bl, [d]
0417   064C A7 00         mov bh, 0
0418   064E             _switch8_comparisons:
0419   064E C1 64         cmp bl, $64
0420   0650 C6 72 06      je _switch8_case0
0421   0653 C1 69         cmp bl, $69
0422   0655 C6 72 06      je _switch8_case1
0423   0658 C1 75         cmp bl, $75
0424   065A C6 97 06      je _switch8_case2
0425   065D C1 78         cmp bl, $78
0426   065F C6 BC 06      je _switch8_case3
0427   0662 C1 63         cmp bl, $63
0428   0664 C6 E1 06      je _switch8_case4
0429   0667 C1 73         cmp bl, $73
0430   0669 C6 06 07      je _switch8_case5
0431   066C 0A 2B 07      jmp _switch8_default
0432   066F 0A 37 07      jmp _switch8_exit
0433   0672             _switch8_case0:
0434   0672             _switch8_case1:
0435   0672             ;; prints(*(int*)p); 
0436   0672 FA FF FF      lea d, [bp + -1] ; $p
0437   0675 2A            mov b, [d]
0438   0676 74            mov d, b
0439   0677 2A            mov b, [d]
0440   0678 FD AB         swp b
0441   067A D8            push b
0442   067B 07 FC 09      call prints
0443   067E 51 02 00      add sp, 2
0444   0681             ;; p = p + 2; 
0445   0681 FA FF FF      lea d, [bp + -1] ; $p
0446   0684 DA            push d
0447   0685 FA FF FF      lea d, [bp + -1] ; $p
0448   0688 2A            mov b, [d]
0449   0689             ; START TERMS
0450   0689 D7            push a
0451   068A 11            mov a, b
0452   068B 26 02 00      mov b, $2
0453   068E 54            add a, b
0454   068F 27            mov b, a
0455   0690 E4            pop a
0456   0691             ; END TERMS
0457   0691 E7            pop d
0458   0692 FD 43         mov [d], b
0459   0694             ;; break; 
0460   0694 0A 37 07      jmp _switch8_exit ; case break
0461   0697             _switch8_case2:
0462   0697             ;; printu(*(unsigned int*)p); 
0463   0697 FA FF FF      lea d, [bp + -1] ; $p
0464   069A 2A            mov b, [d]
0465   069B 74            mov d, b
0466   069C 2A            mov b, [d]
0467   069D FD AB         swp b
0468   069F D8            push b
0469   06A0 07 F1 0A      call printu
0470   06A3 51 02 00      add sp, 2
0471   06A6             ;; p = p + 2; 
0472   06A6 FA FF FF      lea d, [bp + -1] ; $p
0473   06A9 DA            push d
0474   06AA FA FF FF      lea d, [bp + -1] ; $p
0475   06AD 2A            mov b, [d]
0476   06AE             ; START TERMS
0477   06AE D7            push a
0478   06AF 11            mov a, b
0479   06B0 26 02 00      mov b, $2
0480   06B3 54            add a, b
0481   06B4 27            mov b, a
0482   06B5 E4            pop a
0483   06B6             ; END TERMS
0484   06B6 E7            pop d
0485   06B7 FD 43         mov [d], b
0486   06B9             ;; break; 
0487   06B9 0A 37 07      jmp _switch8_exit ; case break
0488   06BC             _switch8_case3:
0489   06BC             ;; printx16(*(unsigned int*)p); 
0490   06BC FA FF FF      lea d, [bp + -1] ; $p
0491   06BF 2A            mov b, [d]
0492   06C0 74            mov d, b
0493   06C1 2A            mov b, [d]
0494   06C2 FD AB         swp b
0495   06C4 D8            push b
0496   06C5 07 6C 07      call printx16
0497   06C8 51 02 00      add sp, 2
0498   06CB             ;; p = p + 2; 
0499   06CB FA FF FF      lea d, [bp + -1] ; $p
0500   06CE DA            push d
0501   06CF FA FF FF      lea d, [bp + -1] ; $p
0502   06D2 2A            mov b, [d]
0503   06D3             ; START TERMS
0504   06D3 D7            push a
0505   06D4 11            mov a, b
0506   06D5 26 02 00      mov b, $2
0507   06D8 54            add a, b
0508   06D9 27            mov b, a
0509   06DA E4            pop a
0510   06DB             ; END TERMS
0511   06DB E7            pop d
0512   06DC FD 43         mov [d], b
0513   06DE             ;; break; 
0514   06DE 0A 37 07      jmp _switch8_exit ; case break
0515   06E1             _switch8_case4:
0516   06E1             ;; putchar(*(char*)p); 
0517   06E1 FA FF FF      lea d, [bp + -1] ; $p
0518   06E4 2A            mov b, [d]
0519   06E5 74            mov d, b
0520   06E6 32            mov bl, [d]
0521   06E7 A7 00         mov bh, 0
0522   06E9 DD            push bl
0523   06EA 07 DD 0B      call putchar
0524   06ED 51 01 00      add sp, 1
0525   06F0             ;; p = p + 2; 
0526   06F0 FA FF FF      lea d, [bp + -1] ; $p
0527   06F3 DA            push d
0528   06F4 FA FF FF      lea d, [bp + -1] ; $p
0529   06F7 2A            mov b, [d]
0530   06F8             ; START TERMS
0531   06F8 D7            push a
0532   06F9 11            mov a, b
0533   06FA 26 02 00      mov b, $2
0534   06FD 54            add a, b
0535   06FE 27            mov b, a
0536   06FF E4            pop a
0537   0700             ; END TERMS
0538   0700 E7            pop d
0539   0701 FD 43         mov [d], b
0540   0703             ;; break; 
0541   0703 0A 37 07      jmp _switch8_exit ; case break
0542   0706             _switch8_case5:
0543   0706             ;; print(*(char**)p); 
0544   0706 FA FF FF      lea d, [bp + -1] ; $p
0545   0709 2A            mov b, [d]
0546   070A 74            mov d, b
0547   070B 2A            mov b, [d]
0548   070C FD AB         swp b
0549   070E D8            push b
0550   070F 07 25 0C      call print
0551   0712 51 02 00      add sp, 2
0552   0715             ;; p = p + 2; 
0553   0715 FA FF FF      lea d, [bp + -1] ; $p
0554   0718 DA            push d
0555   0719 FA FF FF      lea d, [bp + -1] ; $p
0556   071C 2A            mov b, [d]
0557   071D             ; START TERMS
0558   071D D7            push a
0559   071E 11            mov a, b
0560   071F 26 02 00      mov b, $2
0561   0722 54            add a, b
0562   0723 27            mov b, a
0563   0724 E4            pop a
0564   0725             ; END TERMS
0565   0725 E7            pop d
0566   0726 FD 43         mov [d], b
0567   0728             ;; break; 
0568   0728 0A 37 07      jmp _switch8_exit ; case break
0569   072B             _switch8_default:
0570   072B             ;; print("Error: Unknown argument type.\n"); 
0571   072B 26 08 11      mov b, __s0 ; "Error: Unknown argument type.\n"
0572   072E FD AB         swp b
0573   0730 D8            push b
0574   0731 07 25 0C      call print
0575   0734 51 02 00      add sp, 2
0576   0737             _switch8_exit:
0577   0737             ;; fp++; 
0578   0737 FA FD FF      lea d, [bp + -3] ; $fp
0579   073A 2A            mov b, [d]
0580   073B FD 79         mov g, b
0581   073D FD 77         inc b
0582   073F FA FD FF      lea d, [bp + -3] ; $fp
0583   0742 FD 43         mov [d], b
0584   0744 FD 27         mov b, g
0585   0746 0A 67 07      jmp _if7_exit
0586   0749             _if7_else:
0587   0749             ;; putchar(*fp); 
0588   0749 FA FD FF      lea d, [bp + -3] ; $fp
0589   074C 2A            mov b, [d]
0590   074D 74            mov d, b
0591   074E 32            mov bl, [d]
0592   074F A7 00         mov bh, 0
0593   0751 DD            push bl
0594   0752 07 DD 0B      call putchar
0595   0755 51 01 00      add sp, 1
0596   0758             ;; fp++; 
0597   0758 FA FD FF      lea d, [bp + -3] ; $fp
0598   075B 2A            mov b, [d]
0599   075C FD 79         mov g, b
0600   075E FD 77         inc b
0601   0760 FA FD FF      lea d, [bp + -3] ; $fp
0602   0763 FD 43         mov [d], b
0603   0765 FD 27         mov b, g
0604   0767             _if7_exit:
0605   0767             _if6_exit:
0606   0767             _for5_update:
0607   0767 0A 07 06      jmp _for5_cond
0608   076A             _for5_exit:
0609   076A F9            leave
0610   076B 09            ret
0611   076C             
0612   076C             printx16:
0613   076C F8 00 00      enter 0 ; (push bp; mov bp, sp)
0614   076F             
0615   076F             ; --- BEGIN INLINE ASM BLOCK
0616   076F FA 05 00      lea d, [bp + 5] ; $hex
0617   0772 2A            mov b, [d]
0618   0773 07 FC 0F      call print_u16x
0619   0776             ; --- END INLINE ASM BLOCK
0620   0776             
0621   0776 F9            leave
0622   0777 09            ret
0623   0778             
0624   0778             printx8:
0625   0778 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0626   077B             
0627   077B             ; --- BEGIN INLINE ASM BLOCK
0628   077B FA 05 00      lea d, [bp + 5] ; $hex
0629   077E 32            mov bl, [d]
0630   077F 07 40 10      call print_u8x
0631   0782             ; --- END INLINE ASM BLOCK
0632   0782             
0633   0782 F9            leave
0634   0783 09            ret
0635   0784             
0636   0784             hex_to_int:
0637   0784 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0638   0787             ; $value 
0639   0787 10 00 00      mov a, $0
0640   078A 45 FF FF      mov [bp + -1], a
0641   078D             ; $i 
0642   078D             ; $hex_char 
0643   078D             ; $len 
0644   078D 52 07 00      sub sp, 7
0645   0790             ;; len = strlen(hex_string); 
0646   0790 FA FA FF      lea d, [bp + -6] ; $len
0647   0793 DA            push d
0648   0794 FA 05 00      lea d, [bp + 5] ; $hex_string
0649   0797 2A            mov b, [d]
0650   0798 FD AB         swp b
0651   079A D8            push b
0652   079B 07 98 05      call strlen
0653   079E 51 02 00      add sp, 2
0654   07A1 E7            pop d
0655   07A2 FD 43         mov [d], b
0656   07A4             ;; for (i = 0; i < len; i++) { 
0657   07A4             _for9_init:
0658   07A4 FA FD FF      lea d, [bp + -3] ; $i
0659   07A7 DA            push d
0660   07A8 26 00 00      mov b, $0
0661   07AB E7            pop d
0662   07AC FD 43         mov [d], b
0663   07AE             _for9_cond:
0664   07AE FA FD FF      lea d, [bp + -3] ; $i
0665   07B1 2A            mov b, [d]
0666   07B2             ; START RELATIONAL
0667   07B2 D7            push a
0668   07B3 11            mov a, b
0669   07B4 FA FA FF      lea d, [bp + -6] ; $len
0670   07B7 2A            mov b, [d]
0671   07B8 B0            cmp a, b
0672   07B9 FD 73         slt ; < 
0673   07BB E4            pop a
0674   07BC             ; END RELATIONAL
0675   07BC C0 00 00      cmp b, 0
0676   07BF C6 C4 08      je _for9_exit
0677   07C2             _for9_block:
0678   07C2             ;; hex_char = hex_string[i]; 
0679   07C2 FA FC FF      lea d, [bp + -4] ; $hex_char
0680   07C5 DA            push d
0681   07C6 FA 05 00      lea d, [bp + 5] ; $hex_string
0682   07C9 FD 2A         mov d, [d]
0683   07CB D7            push a
0684   07CC DA            push d
0685   07CD FA FD FF      lea d, [bp + -3] ; $i
0686   07D0 2A            mov b, [d]
0687   07D1 E7            pop d
0688   07D2 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0689   07D6 E4            pop a
0690   07D7 32            mov bl, [d]
0691   07D8 A7 00         mov bh, 0
0692   07DA E7            pop d
0693   07DB FD 3E         mov [d], bl
0694   07DD             ;; if (hex_char >= 'a' && hex_char <= 'f')  
0695   07DD             _if10_cond:
0696   07DD FA FC FF      lea d, [bp + -4] ; $hex_char
0697   07E0 32            mov bl, [d]
0698   07E1 A7 00         mov bh, 0
0699   07E3             ; START RELATIONAL
0700   07E3 D7            push a
0701   07E4 11            mov a, b
0702   07E5 26 61 00      mov b, $61
0703   07E8 B0            cmp a, b
0704   07E9 FD 80         sge ; >=
0705   07EB E4            pop a
0706   07EC             ; END RELATIONAL
0707   07EC D7            push a
0708   07ED 11            mov a, b
0709   07EE FA FC FF      lea d, [bp + -4] ; $hex_char
0710   07F1 32            mov bl, [d]
0711   07F2 A7 00         mov bh, 0
0712   07F4             ; START RELATIONAL
0713   07F4 D7            push a
0714   07F5 11            mov a, b
0715   07F6 26 66 00      mov b, $66
0716   07F9 B0            cmp a, b
0717   07FA FD 74         sle ; <=
0718   07FC E4            pop a
0719   07FD             ; END RELATIONAL
0720   07FD FD A7         sand a, b ; &&
0721   07FF E4            pop a
0722   0800 C0 00 00      cmp b, 0
0723   0803 C6 34 08      je _if10_else
0724   0806             _if10_true:
0725   0806             ;; value = (value * 16) + (hex_char - 'a' + 10); 
0726   0806 FA FF FF      lea d, [bp + -1] ; $value
0727   0809 DA            push d
0728   080A FA FF FF      lea d, [bp + -1] ; $value
0729   080D 2A            mov b, [d]
0730   080E             ; START FACTORS
0731   080E D7            push a
0732   080F 11            mov a, b
0733   0810 26 10 00      mov b, $10
0734   0813 AC            mul a, b ; *
0735   0814 11            mov a, b
0736   0815 27            mov b, a
0737   0816 E4            pop a
0738   0817             ; END FACTORS
0739   0817             ; START TERMS
0740   0817 D7            push a
0741   0818 11            mov a, b
0742   0819 FA FC FF      lea d, [bp + -4] ; $hex_char
0743   081C 32            mov bl, [d]
0744   081D A7 00         mov bh, 0
0745   081F             ; START TERMS
0746   081F D7            push a
0747   0820 11            mov a, b
0748   0821 26 61 00      mov b, $61
0749   0824 60            sub a, b
0750   0825 26 0A 00      mov b, $a
0751   0828 54            add a, b
0752   0829 27            mov b, a
0753   082A E4            pop a
0754   082B             ; END TERMS
0755   082B 54            add a, b
0756   082C 27            mov b, a
0757   082D E4            pop a
0758   082E             ; END TERMS
0759   082E E7            pop d
0760   082F FD 43         mov [d], b
0761   0831 0A B2 08      jmp _if10_exit
0762   0834             _if10_else:
0763   0834             ;; if (hex_char >= 'A' && hex_char <= 'F')  
0764   0834             _if11_cond:
0765   0834 FA FC FF      lea d, [bp + -4] ; $hex_char
0766   0837 32            mov bl, [d]
0767   0838 A7 00         mov bh, 0
0768   083A             ; START RELATIONAL
0769   083A D7            push a
0770   083B 11            mov a, b
0771   083C 26 41 00      mov b, $41
0772   083F B0            cmp a, b
0773   0840 FD 80         sge ; >=
0774   0842 E4            pop a
0775   0843             ; END RELATIONAL
0776   0843 D7            push a
0777   0844 11            mov a, b
0778   0845 FA FC FF      lea d, [bp + -4] ; $hex_char
0779   0848 32            mov bl, [d]
0780   0849 A7 00         mov bh, 0
0781   084B             ; START RELATIONAL
0782   084B D7            push a
0783   084C 11            mov a, b
0784   084D 26 46 00      mov b, $46
0785   0850 B0            cmp a, b
0786   0851 FD 74         sle ; <=
0787   0853 E4            pop a
0788   0854             ; END RELATIONAL
0789   0854 FD A7         sand a, b ; &&
0790   0856 E4            pop a
0791   0857 C0 00 00      cmp b, 0
0792   085A C6 8B 08      je _if11_else
0793   085D             _if11_true:
0794   085D             ;; value = (value * 16) + (hex_char - 'A' + 10); 
0795   085D FA FF FF      lea d, [bp + -1] ; $value
0796   0860 DA            push d
0797   0861 FA FF FF      lea d, [bp + -1] ; $value
0798   0864 2A            mov b, [d]
0799   0865             ; START FACTORS
0800   0865 D7            push a
0801   0866 11            mov a, b
0802   0867 26 10 00      mov b, $10
0803   086A AC            mul a, b ; *
0804   086B 11            mov a, b
0805   086C 27            mov b, a
0806   086D E4            pop a
0807   086E             ; END FACTORS
0808   086E             ; START TERMS
0809   086E D7            push a
0810   086F 11            mov a, b
0811   0870 FA FC FF      lea d, [bp + -4] ; $hex_char
0812   0873 32            mov bl, [d]
0813   0874 A7 00         mov bh, 0
0814   0876             ; START TERMS
0815   0876 D7            push a
0816   0877 11            mov a, b
0817   0878 26 41 00      mov b, $41
0818   087B 60            sub a, b
0819   087C 26 0A 00      mov b, $a
0820   087F 54            add a, b
0821   0880 27            mov b, a
0822   0881 E4            pop a
0823   0882             ; END TERMS
0824   0882 54            add a, b
0825   0883 27            mov b, a
0826   0884 E4            pop a
0827   0885             ; END TERMS
0828   0885 E7            pop d
0829   0886 FD 43         mov [d], b
0830   0888 0A B2 08      jmp _if11_exit
0831   088B             _if11_else:
0832   088B             ;; value = (value * 16) + (hex_char - '0'); 
0833   088B FA FF FF      lea d, [bp + -1] ; $value
0834   088E DA            push d
0835   088F FA FF FF      lea d, [bp + -1] ; $value
0836   0892 2A            mov b, [d]
0837   0893             ; START FACTORS
0838   0893 D7            push a
0839   0894 11            mov a, b
0840   0895 26 10 00      mov b, $10
0841   0898 AC            mul a, b ; *
0842   0899 11            mov a, b
0843   089A 27            mov b, a
0844   089B E4            pop a
0845   089C             ; END FACTORS
0846   089C             ; START TERMS
0847   089C D7            push a
0848   089D 11            mov a, b
0849   089E FA FC FF      lea d, [bp + -4] ; $hex_char
0850   08A1 32            mov bl, [d]
0851   08A2 A7 00         mov bh, 0
0852   08A4             ; START TERMS
0853   08A4 D7            push a
0854   08A5 11            mov a, b
0855   08A6 26 30 00      mov b, $30
0856   08A9 60            sub a, b
0857   08AA 27            mov b, a
0858   08AB E4            pop a
0859   08AC             ; END TERMS
0860   08AC 54            add a, b
0861   08AD 27            mov b, a
0862   08AE E4            pop a
0863   08AF             ; END TERMS
0864   08AF E7            pop d
0865   08B0 FD 43         mov [d], b
0866   08B2             _if11_exit:
0867   08B2             _if10_exit:
0868   08B2             _for9_update:
0869   08B2 FA FD FF      lea d, [bp + -3] ; $i
0870   08B5 2A            mov b, [d]
0871   08B6 FD 79         mov g, b
0872   08B8 FD 77         inc b
0873   08BA FA FD FF      lea d, [bp + -3] ; $i
0874   08BD FD 43         mov [d], b
0875   08BF FD 27         mov b, g
0876   08C1 0A AE 07      jmp _for9_cond
0877   08C4             _for9_exit:
0878   08C4             ;; return value; 
0879   08C4 FA FF FF      lea d, [bp + -1] ; $value
0880   08C7 2A            mov b, [d]
0881   08C8 F9            leave
0882   08C9 09            ret
0883   08CA             
0884   08CA             atoi:
0885   08CA F8 00 00      enter 0 ; (push bp; mov bp, sp)
0886   08CD             ; $result 
0887   08CD 10 00 00      mov a, $0
0888   08D0 45 FF FF      mov [bp + -1], a
0889   08D3             ; $sign 
0890   08D3 10 01 00      mov a, $1
0891   08D6 45 FD FF      mov [bp + -3], a
0892   08D9 52 04 00      sub sp, 4
0893   08DC             ;; while (*str == ' ') str++; 
0894   08DC             _while12_cond:
0895   08DC FA 05 00      lea d, [bp + 5] ; $str
0896   08DF 2A            mov b, [d]
0897   08E0 74            mov d, b
0898   08E1 32            mov bl, [d]
0899   08E2 A7 00         mov bh, 0
0900   08E4             ; START RELATIONAL
0901   08E4 D7            push a
0902   08E5 11            mov a, b
0903   08E6 26 20 00      mov b, $20
0904   08E9 B0            cmp a, b
0905   08EA FD 71         seq ; ==
0906   08EC E4            pop a
0907   08ED             ; END RELATIONAL
0908   08ED C0 00 00      cmp b, 0
0909   08F0 C6 05 09      je _while12_exit
0910   08F3             _while12_block:
0911   08F3             ;; str++; 
0912   08F3 FA 05 00      lea d, [bp + 5] ; $str
0913   08F6 2A            mov b, [d]
0914   08F7 FD 79         mov g, b
0915   08F9 FD 77         inc b
0916   08FB FA 05 00      lea d, [bp + 5] ; $str
0917   08FE FD 43         mov [d], b
0918   0900 FD 27         mov b, g
0919   0902 0A DC 08      jmp _while12_cond
0920   0905             _while12_exit:
0921   0905             ;; if (*str == '-' || *str == '+') { 
0922   0905             _if13_cond:
0923   0905 FA 05 00      lea d, [bp + 5] ; $str
0924   0908 2A            mov b, [d]
0925   0909 74            mov d, b
0926   090A 32            mov bl, [d]
0927   090B A7 00         mov bh, 0
0928   090D             ; START RELATIONAL
0929   090D D7            push a
0930   090E 11            mov a, b
0931   090F 26 2D 00      mov b, $2d
0932   0912 B0            cmp a, b
0933   0913 FD 71         seq ; ==
0934   0915 E4            pop a
0935   0916             ; END RELATIONAL
0936   0916 D7            push a
0937   0917 11            mov a, b
0938   0918 FA 05 00      lea d, [bp + 5] ; $str
0939   091B 2A            mov b, [d]
0940   091C 74            mov d, b
0941   091D 32            mov bl, [d]
0942   091E A7 00         mov bh, 0
0943   0920             ; START RELATIONAL
0944   0920 D7            push a
0945   0921 11            mov a, b
0946   0922 26 2B 00      mov b, $2b
0947   0925 B0            cmp a, b
0948   0926 FD 71         seq ; ==
0949   0928 E4            pop a
0950   0929             ; END RELATIONAL
0951   0929 FD A8         sor a, b ; ||
0952   092B E4            pop a
0953   092C C0 00 00      cmp b, 0
0954   092F C6 6A 09      je _if13_exit
0955   0932             _if13_true:
0956   0932             ;; if (*str == '-') sign = -1; 
0957   0932             _if14_cond:
0958   0932 FA 05 00      lea d, [bp + 5] ; $str
0959   0935 2A            mov b, [d]
0960   0936 74            mov d, b
0961   0937 32            mov bl, [d]
0962   0938 A7 00         mov bh, 0
0963   093A             ; START RELATIONAL
0964   093A D7            push a
0965   093B 11            mov a, b
0966   093C 26 2D 00      mov b, $2d
0967   093F B0            cmp a, b
0968   0940 FD 71         seq ; ==
0969   0942 E4            pop a
0970   0943             ; END RELATIONAL
0971   0943 C0 00 00      cmp b, 0
0972   0946 C6 58 09      je _if14_exit
0973   0949             _if14_true:
0974   0949             ;; sign = -1; 
0975   0949 FA FD FF      lea d, [bp + -3] ; $sign
0976   094C DA            push d
0977   094D 26 01 00      mov b, $1
0978   0950 FD 97         neg b
0979   0952 E7            pop d
0980   0953 FD 43         mov [d], b
0981   0955 0A 58 09      jmp _if14_exit
0982   0958             _if14_exit:
0983   0958             ;; str++; 
0984   0958 FA 05 00      lea d, [bp + 5] ; $str
0985   095B 2A            mov b, [d]
0986   095C FD 79         mov g, b
0987   095E FD 77         inc b
0988   0960 FA 05 00      lea d, [bp + 5] ; $str
0989   0963 FD 43         mov [d], b
0990   0965 FD 27         mov b, g
0991   0967 0A 6A 09      jmp _if13_exit
0992   096A             _if13_exit:
0993   096A             ;; while (*str >= '0' && *str <= '9') { 
0994   096A             _while15_cond:
0995   096A FA 05 00      lea d, [bp + 5] ; $str
0996   096D 2A            mov b, [d]
0997   096E 74            mov d, b
0998   096F 32            mov bl, [d]
0999   0970 A7 00         mov bh, 0
1000   0972             ; START RELATIONAL
1001   0972 D7            push a
1002   0973 11            mov a, b
1003   0974 26 30 00      mov b, $30
1004   0977 B0            cmp a, b
1005   0978 FD 80         sge ; >=
1006   097A E4            pop a
1007   097B             ; END RELATIONAL
1008   097B D7            push a
1009   097C 11            mov a, b
1010   097D FA 05 00      lea d, [bp + 5] ; $str
1011   0980 2A            mov b, [d]
1012   0981 74            mov d, b
1013   0982 32            mov bl, [d]
1014   0983 A7 00         mov bh, 0
1015   0985             ; START RELATIONAL
1016   0985 D7            push a
1017   0986 11            mov a, b
1018   0987 26 39 00      mov b, $39
1019   098A B0            cmp a, b
1020   098B FD 74         sle ; <=
1021   098D E4            pop a
1022   098E             ; END RELATIONAL
1023   098E FD A7         sand a, b ; &&
1024   0990 E4            pop a
1025   0991 C0 00 00      cmp b, 0
1026   0994 C6 D2 09      je _while15_exit
1027   0997             _while15_block:
1028   0997             ;; result = result * 10 + (*str - '0'); 
1029   0997 FA FF FF      lea d, [bp + -1] ; $result
1030   099A DA            push d
1031   099B FA FF FF      lea d, [bp + -1] ; $result
1032   099E 2A            mov b, [d]
1033   099F             ; START FACTORS
1034   099F D7            push a
1035   09A0 11            mov a, b
1036   09A1 26 0A 00      mov b, $a
1037   09A4 AC            mul a, b ; *
1038   09A5 11            mov a, b
1039   09A6 27            mov b, a
1040   09A7 E4            pop a
1041   09A8             ; END FACTORS
1042   09A8             ; START TERMS
1043   09A8 D7            push a
1044   09A9 11            mov a, b
1045   09AA FA 05 00      lea d, [bp + 5] ; $str
1046   09AD 2A            mov b, [d]
1047   09AE 74            mov d, b
1048   09AF 32            mov bl, [d]
1049   09B0 A7 00         mov bh, 0
1050   09B2             ; START TERMS
1051   09B2 D7            push a
1052   09B3 11            mov a, b
1053   09B4 26 30 00      mov b, $30
1054   09B7 60            sub a, b
1055   09B8 27            mov b, a
1056   09B9 E4            pop a
1057   09BA             ; END TERMS
1058   09BA 54            add a, b
1059   09BB 27            mov b, a
1060   09BC E4            pop a
1061   09BD             ; END TERMS
1062   09BD E7            pop d
1063   09BE FD 43         mov [d], b
1064   09C0             ;; str++; 
1065   09C0 FA 05 00      lea d, [bp + 5] ; $str
1066   09C3 2A            mov b, [d]
1067   09C4 FD 79         mov g, b
1068   09C6 FD 77         inc b
1069   09C8 FA 05 00      lea d, [bp + 5] ; $str
1070   09CB FD 43         mov [d], b
1071   09CD FD 27         mov b, g
1072   09CF 0A 6A 09      jmp _while15_cond
1073   09D2             _while15_exit:
1074   09D2             ;; return sign * result; 
1075   09D2 FA FD FF      lea d, [bp + -3] ; $sign
1076   09D5 2A            mov b, [d]
1077   09D6             ; START FACTORS
1078   09D6 D7            push a
1079   09D7 11            mov a, b
1080   09D8 FA FF FF      lea d, [bp + -1] ; $result
1081   09DB 2A            mov b, [d]
1082   09DC AC            mul a, b ; *
1083   09DD 11            mov a, b
1084   09DE 27            mov b, a
1085   09DF E4            pop a
1086   09E0             ; END FACTORS
1087   09E0 F9            leave
1088   09E1 09            ret
1089   09E2             
1090   09E2             gets:
1091   09E2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1092   09E5             
1093   09E5             ; --- BEGIN INLINE ASM BLOCK
1094   09E5 FA 05 00      lea d, [bp + 5] ; $s
1095   09E8 15            mov a, [d]
1096   09E9 3C            mov d, a
1097   09EA 07 61 0E      call _gets
1098   09ED             ; --- END INLINE ASM BLOCK
1099   09ED             
1100   09ED             ;; return strlen(s); 
1101   09ED FA 05 00      lea d, [bp + 5] ; $s
1102   09F0 2A            mov b, [d]
1103   09F1 FD AB         swp b
1104   09F3 D8            push b
1105   09F4 07 98 05      call strlen
1106   09F7 51 02 00      add sp, 2
1107   09FA F9            leave
1108   09FB 09            ret
1109   09FC             
1110   09FC             prints:
1111   09FC F8 00 00      enter 0 ; (push bp; mov bp, sp)
1112   09FF             ; $digits 
1113   09FF             ; $i 
1114   09FF 10 00 00      mov a, $0
1115   0A02 45 FA FF      mov [bp + -6], a
1116   0A05 52 07 00      sub sp, 7
1117   0A08             ;; if (num < 0) { 
1118   0A08             _if16_cond:
1119   0A08 FA 05 00      lea d, [bp + 5] ; $num
1120   0A0B 2A            mov b, [d]
1121   0A0C             ; START RELATIONAL
1122   0A0C D7            push a
1123   0A0D 11            mov a, b
1124   0A0E 26 00 00      mov b, $0
1125   0A11 B0            cmp a, b
1126   0A12 FD 73         slt ; < 
1127   0A14 E4            pop a
1128   0A15             ; END RELATIONAL
1129   0A15 C0 00 00      cmp b, 0
1130   0A18 C6 35 0A      je _if16_else
1131   0A1B             _if16_true:
1132   0A1B             ;; putchar('-'); 
1133   0A1B 26 2D 00      mov b, $2d
1134   0A1E DD            push bl
1135   0A1F 07 DD 0B      call putchar
1136   0A22 51 01 00      add sp, 1
1137   0A25             ;; num = -num; 
1138   0A25 FA 05 00      lea d, [bp + 5] ; $num
1139   0A28 DA            push d
1140   0A29 FA 05 00      lea d, [bp + 5] ; $num
1141   0A2C 2A            mov b, [d]
1142   0A2D FD 97         neg b
1143   0A2F E7            pop d
1144   0A30 FD 43         mov [d], b
1145   0A32 0A 57 0A      jmp _if16_exit
1146   0A35             _if16_else:
1147   0A35             ;; if (num == 0) { 
1148   0A35             _if17_cond:
1149   0A35 FA 05 00      lea d, [bp + 5] ; $num
1150   0A38 2A            mov b, [d]
1151   0A39             ; START RELATIONAL
1152   0A39 D7            push a
1153   0A3A 11            mov a, b
1154   0A3B 26 00 00      mov b, $0
1155   0A3E B0            cmp a, b
1156   0A3F FD 71         seq ; ==
1157   0A41 E4            pop a
1158   0A42             ; END RELATIONAL
1159   0A42 C0 00 00      cmp b, 0
1160   0A45 C6 57 0A      je _if17_exit
1161   0A48             _if17_true:
1162   0A48             ;; putchar('0'); 
1163   0A48 26 30 00      mov b, $30
1164   0A4B DD            push bl
1165   0A4C 07 DD 0B      call putchar
1166   0A4F 51 01 00      add sp, 1
1167   0A52             ;; return; 
1168   0A52 F9            leave
1169   0A53 09            ret
1170   0A54 0A 57 0A      jmp _if17_exit
1171   0A57             _if17_exit:
1172   0A57             _if16_exit:
1173   0A57             ;; while (num > 0) { 
1174   0A57             _while18_cond:
1175   0A57 FA 05 00      lea d, [bp + 5] ; $num
1176   0A5A 2A            mov b, [d]
1177   0A5B             ; START RELATIONAL
1178   0A5B D7            push a
1179   0A5C 11            mov a, b
1180   0A5D 26 00 00      mov b, $0
1181   0A60 B0            cmp a, b
1182   0A61 FD 7F         sgt ; >
1183   0A63 E4            pop a
1184   0A64             ; END RELATIONAL
1185   0A64 C0 00 00      cmp b, 0
1186   0A67 C6 B4 0A      je _while18_exit
1187   0A6A             _while18_block:
1188   0A6A             ;; digits[i] = '0' + (num % 10); 
1189   0A6A FA FC FF      lea d, [bp + -4] ; $digits
1190   0A6D D7            push a
1191   0A6E DA            push d
1192   0A6F FA FA FF      lea d, [bp + -6] ; $i
1193   0A72 2A            mov b, [d]
1194   0A73 E7            pop d
1195   0A74 5A            add d, b
1196   0A75 E4            pop a
1197   0A76 DA            push d
1198   0A77 26 30 00      mov b, $30
1199   0A7A             ; START TERMS
1200   0A7A D7            push a
1201   0A7B 11            mov a, b
1202   0A7C FA 05 00      lea d, [bp + 5] ; $num
1203   0A7F 2A            mov b, [d]
1204   0A80             ; START FACTORS
1205   0A80 D7            push a
1206   0A81 11            mov a, b
1207   0A82 26 0A 00      mov b, $a
1208   0A85 AE            div a, b ; 
1209   0A86 11            mov a, b
1210   0A87 27            mov b, a
1211   0A88 E4            pop a
1212   0A89             ; END FACTORS
1213   0A89 54            add a, b
1214   0A8A 27            mov b, a
1215   0A8B E4            pop a
1216   0A8C             ; END TERMS
1217   0A8C E7            pop d
1218   0A8D FD 3E         mov [d], bl
1219   0A8F             ;; num = num / 10; 
1220   0A8F FA 05 00      lea d, [bp + 5] ; $num
1221   0A92 DA            push d
1222   0A93 FA 05 00      lea d, [bp + 5] ; $num
1223   0A96 2A            mov b, [d]
1224   0A97             ; START FACTORS
1225   0A97 D7            push a
1226   0A98 11            mov a, b
1227   0A99 26 0A 00      mov b, $a
1228   0A9C AE            div a, b
1229   0A9D 27            mov b, a
1230   0A9E E4            pop a
1231   0A9F             ; END FACTORS
1232   0A9F E7            pop d
1233   0AA0 FD 43         mov [d], b
1234   0AA2             ;; i++; 
1235   0AA2 FA FA FF      lea d, [bp + -6] ; $i
1236   0AA5 2A            mov b, [d]
1237   0AA6 FD 79         mov g, b
1238   0AA8 FD 77         inc b
1239   0AAA FA FA FF      lea d, [bp + -6] ; $i
1240   0AAD FD 43         mov [d], b
1241   0AAF FD 27         mov b, g
1242   0AB1 0A 57 0A      jmp _while18_cond
1243   0AB4             _while18_exit:
1244   0AB4             ;; while (i > 0) { 
1245   0AB4             _while19_cond:
1246   0AB4 FA FA FF      lea d, [bp + -6] ; $i
1247   0AB7 2A            mov b, [d]
1248   0AB8             ; START RELATIONAL
1249   0AB8 D7            push a
1250   0AB9 11            mov a, b
1251   0ABA 26 00 00      mov b, $0
1252   0ABD B0            cmp a, b
1253   0ABE FD 7F         sgt ; >
1254   0AC0 E4            pop a
1255   0AC1             ; END RELATIONAL
1256   0AC1 C0 00 00      cmp b, 0
1257   0AC4 C6 EF 0A      je _while19_exit
1258   0AC7             _while19_block:
1259   0AC7             ;; i--; 
1260   0AC7 FA FA FF      lea d, [bp + -6] ; $i
1261   0ACA 2A            mov b, [d]
1262   0ACB FD 79         mov g, b
1263   0ACD FD 7D         dec b
1264   0ACF FA FA FF      lea d, [bp + -6] ; $i
1265   0AD2 FD 43         mov [d], b
1266   0AD4 FD 27         mov b, g
1267   0AD6             ;; putchar(digits[i]); 
1268   0AD6 FA FC FF      lea d, [bp + -4] ; $digits
1269   0AD9 D7            push a
1270   0ADA DA            push d
1271   0ADB FA FA FF      lea d, [bp + -6] ; $i
1272   0ADE 2A            mov b, [d]
1273   0ADF E7            pop d
1274   0AE0 5A            add d, b
1275   0AE1 E4            pop a
1276   0AE2 32            mov bl, [d]
1277   0AE3 A7 00         mov bh, 0
1278   0AE5 DD            push bl
1279   0AE6 07 DD 0B      call putchar
1280   0AE9 51 01 00      add sp, 1
1281   0AEC 0A B4 0A      jmp _while19_cond
1282   0AEF             _while19_exit:
1283   0AEF F9            leave
1284   0AF0 09            ret
1285   0AF1             
1286   0AF1             printu:
1287   0AF1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1288   0AF4             ; $digits 
1289   0AF4             ; $i 
1290   0AF4 52 07 00      sub sp, 7
1291   0AF7             ;; i = 0; 
1292   0AF7 FA FA FF      lea d, [bp + -6] ; $i
1293   0AFA DA            push d
1294   0AFB 26 00 00      mov b, $0
1295   0AFE E7            pop d
1296   0AFF FD 43         mov [d], b
1297   0B01             ;; if(num == 0){ 
1298   0B01             _if20_cond:
1299   0B01 FA 05 00      lea d, [bp + 5] ; $num
1300   0B04 2A            mov b, [d]
1301   0B05             ; START RELATIONAL
1302   0B05 D7            push a
1303   0B06 11            mov a, b
1304   0B07 26 00 00      mov b, $0
1305   0B0A B0            cmp a, b
1306   0B0B FD 71         seq ; ==
1307   0B0D E4            pop a
1308   0B0E             ; END RELATIONAL
1309   0B0E C0 00 00      cmp b, 0
1310   0B11 C6 23 0B      je _if20_exit
1311   0B14             _if20_true:
1312   0B14             ;; putchar('0'); 
1313   0B14 26 30 00      mov b, $30
1314   0B17 DD            push bl
1315   0B18 07 DD 0B      call putchar
1316   0B1B 51 01 00      add sp, 1
1317   0B1E             ;; return; 
1318   0B1E F9            leave
1319   0B1F 09            ret
1320   0B20 0A 23 0B      jmp _if20_exit
1321   0B23             _if20_exit:
1322   0B23             ;; while (num > 0) { 
1323   0B23             _while21_cond:
1324   0B23 FA 05 00      lea d, [bp + 5] ; $num
1325   0B26 2A            mov b, [d]
1326   0B27             ; START RELATIONAL
1327   0B27 D7            push a
1328   0B28 11            mov a, b
1329   0B29 26 00 00      mov b, $0
1330   0B2C B0            cmp a, b
1331   0B2D FD 81         sgu ; > (unsigned)
1332   0B2F E4            pop a
1333   0B30             ; END RELATIONAL
1334   0B30 C0 00 00      cmp b, 0
1335   0B33 C6 80 0B      je _while21_exit
1336   0B36             _while21_block:
1337   0B36             ;; digits[i] = '0' + (num % 10); 
1338   0B36 FA FC FF      lea d, [bp + -4] ; $digits
1339   0B39 D7            push a
1340   0B3A DA            push d
1341   0B3B FA FA FF      lea d, [bp + -6] ; $i
1342   0B3E 2A            mov b, [d]
1343   0B3F E7            pop d
1344   0B40 5A            add d, b
1345   0B41 E4            pop a
1346   0B42 DA            push d
1347   0B43 26 30 00      mov b, $30
1348   0B46             ; START TERMS
1349   0B46 D7            push a
1350   0B47 11            mov a, b
1351   0B48 FA 05 00      lea d, [bp + 5] ; $num
1352   0B4B 2A            mov b, [d]
1353   0B4C             ; START FACTORS
1354   0B4C D7            push a
1355   0B4D 11            mov a, b
1356   0B4E 26 0A 00      mov b, $a
1357   0B51 AE            div a, b ; 
1358   0B52 11            mov a, b
1359   0B53 27            mov b, a
1360   0B54 E4            pop a
1361   0B55             ; END FACTORS
1362   0B55 54            add a, b
1363   0B56 27            mov b, a
1364   0B57 E4            pop a
1365   0B58             ; END TERMS
1366   0B58 E7            pop d
1367   0B59 FD 3E         mov [d], bl
1368   0B5B             ;; num = num / 10; 
1369   0B5B FA 05 00      lea d, [bp + 5] ; $num
1370   0B5E DA            push d
1371   0B5F FA 05 00      lea d, [bp + 5] ; $num
1372   0B62 2A            mov b, [d]
1373   0B63             ; START FACTORS
1374   0B63 D7            push a
1375   0B64 11            mov a, b
1376   0B65 26 0A 00      mov b, $a
1377   0B68 AE            div a, b
1378   0B69 27            mov b, a
1379   0B6A E4            pop a
1380   0B6B             ; END FACTORS
1381   0B6B E7            pop d
1382   0B6C FD 43         mov [d], b
1383   0B6E             ;; i++; 
1384   0B6E FA FA FF      lea d, [bp + -6] ; $i
1385   0B71 2A            mov b, [d]
1386   0B72 FD 79         mov g, b
1387   0B74 FD 77         inc b
1388   0B76 FA FA FF      lea d, [bp + -6] ; $i
1389   0B79 FD 43         mov [d], b
1390   0B7B FD 27         mov b, g
1391   0B7D 0A 23 0B      jmp _while21_cond
1392   0B80             _while21_exit:
1393   0B80             ;; while (i > 0) { 
1394   0B80             _while22_cond:
1395   0B80 FA FA FF      lea d, [bp + -6] ; $i
1396   0B83 2A            mov b, [d]
1397   0B84             ; START RELATIONAL
1398   0B84 D7            push a
1399   0B85 11            mov a, b
1400   0B86 26 00 00      mov b, $0
1401   0B89 B0            cmp a, b
1402   0B8A FD 7F         sgt ; >
1403   0B8C E4            pop a
1404   0B8D             ; END RELATIONAL
1405   0B8D C0 00 00      cmp b, 0
1406   0B90 C6 BB 0B      je _while22_exit
1407   0B93             _while22_block:
1408   0B93             ;; i--; 
1409   0B93 FA FA FF      lea d, [bp + -6] ; $i
1410   0B96 2A            mov b, [d]
1411   0B97 FD 79         mov g, b
1412   0B99 FD 7D         dec b
1413   0B9B FA FA FF      lea d, [bp + -6] ; $i
1414   0B9E FD 43         mov [d], b
1415   0BA0 FD 27         mov b, g
1416   0BA2             ;; putchar(digits[i]); 
1417   0BA2 FA FC FF      lea d, [bp + -4] ; $digits
1418   0BA5 D7            push a
1419   0BA6 DA            push d
1420   0BA7 FA FA FF      lea d, [bp + -6] ; $i
1421   0BAA 2A            mov b, [d]
1422   0BAB E7            pop d
1423   0BAC 5A            add d, b
1424   0BAD E4            pop a
1425   0BAE 32            mov bl, [d]
1426   0BAF A7 00         mov bh, 0
1427   0BB1 DD            push bl
1428   0BB2 07 DD 0B      call putchar
1429   0BB5 51 01 00      add sp, 1
1430   0BB8 0A 80 0B      jmp _while22_cond
1431   0BBB             _while22_exit:
1432   0BBB F9            leave
1433   0BBC 09            ret
1434   0BBD             
1435   0BBD             rand:
1436   0BBD F8 00 00      enter 0 ; (push bp; mov bp, sp)
1437   0BC0             ; $sec 
1438   0BC0 52 01 00      sub sp, 1
1439   0BC3             
1440   0BC3             ; --- BEGIN INLINE ASM BLOCK
1441   0BC3 19 00         mov al, 0
1442   0BC5 05 01         syscall sys_rtc					
1443   0BC7 1A            mov al, ah
1444   0BC8 FA 00 00      lea d, [bp + 0] ; $sec
1445   0BCB 1E            mov al, [d]
1446   0BCC             ; --- END INLINE ASM BLOCK
1447   0BCC             
1448   0BCC             ;; return sec; 
1449   0BCC FA 00 00      lea d, [bp + 0] ; $sec
1450   0BCF 32            mov bl, [d]
1451   0BD0 A7 00         mov bh, 0
1452   0BD2 F9            leave
1453   0BD3 09            ret
1454   0BD4             
1455   0BD4             date:
1456   0BD4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1457   0BD7             
1458   0BD7             ; --- BEGIN INLINE ASM BLOCK
1459   0BD7 19 00         mov al, 0 
1460   0BD9 05 07         syscall sys_datetime
1461   0BDB             ; --- END INLINE ASM BLOCK
1462   0BDB             
1463   0BDB F9            leave
1464   0BDC 09            ret
1465   0BDD             
1466   0BDD             putchar:
1467   0BDD F8 00 00      enter 0 ; (push bp; mov bp, sp)
1468   0BE0             
1469   0BE0             ; --- BEGIN INLINE ASM BLOCK
1470   0BE0 FA 05 00      lea d, [bp + 5] ; $c
1471   0BE3 1E            mov al, [d]
1472   0BE4 23            mov ah, al
1473   0BE5 07 5A 0E      call _putchar
1474   0BE8             ; --- END INLINE ASM BLOCK
1475   0BE8             
1476   0BE8 F9            leave
1477   0BE9 09            ret
1478   0BEA             
1479   0BEA             getchar:
1480   0BEA F8 00 00      enter 0 ; (push bp; mov bp, sp)
1481   0BED             ; $c 
1482   0BED 52 01 00      sub sp, 1
1483   0BF0             
1484   0BF0             ; --- BEGIN INLINE ASM BLOCK
1485   0BF0 07 53 0E      call getch
1486   0BF3 1A            mov al, ah
1487   0BF4 FA 00 00      lea d, [bp + 0] ; $c
1488   0BF7 3E            mov [d], al
1489   0BF8             ; --- END INLINE ASM BLOCK
1490   0BF8             
1491   0BF8             ;; return c; 
1492   0BF8 FA 00 00      lea d, [bp + 0] ; $c
1493   0BFB 32            mov bl, [d]
1494   0BFC A7 00         mov bh, 0
1495   0BFE F9            leave
1496   0BFF 09            ret
1497   0C00             
1498   0C00             scann:
1499   0C00 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1500   0C03             ; $m 
1501   0C03 52 02 00      sub sp, 2
1502   0C06             
1503   0C06             ; --- BEGIN INLINE ASM BLOCK
1504   0C06 07 9E 10      call scan_u16d
1505   0C09 FA FF FF      lea d, [bp + -1] ; $m
1506   0C0C 43            mov [d], a
1507   0C0D             ; --- END INLINE ASM BLOCK
1508   0C0D             
1509   0C0D             ;; return m; 
1510   0C0D FA FF FF      lea d, [bp + -1] ; $m
1511   0C10 2A            mov b, [d]
1512   0C11 F9            leave
1513   0C12 09            ret
1514   0C13             
1515   0C13             puts:
1516   0C13 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1517   0C16             
1518   0C16             ; --- BEGIN INLINE ASM BLOCK
1519   0C16 FA 05 00      lea d, [bp + 5] ; $s
1520   0C19 15            mov a, [d]
1521   0C1A 3C            mov d, a
1522   0C1B 07 A4 0F      call _puts
1523   0C1E 10 00 0A      mov a, $0A00
1524   0C21 05 03         syscall sys_io
1525   0C23             ; --- END INLINE ASM BLOCK
1526   0C23             
1527   0C23 F9            leave
1528   0C24 09            ret
1529   0C25             
1530   0C25             print:
1531   0C25 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1532   0C28             
1533   0C28             ; --- BEGIN INLINE ASM BLOCK
1534   0C28 FA 05 00      lea d, [bp + 5] ; $s
1535   0C2B FD 2A         mov d, [d]
1536   0C2D 07 A4 0F      call _puts
1537   0C30             ; --- END INLINE ASM BLOCK
1538   0C30             
1539   0C30 F9            leave
1540   0C31 09            ret
1541   0C32             
1542   0C32             loadfile:
1543   0C32 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1544   0C35             
1545   0C35             ; --- BEGIN INLINE ASM BLOCK
1546   0C35 FA 07 00      lea d, [bp + 7] ; $destination
1547   0C38 15            mov a, [d]
1548   0C39 4F            mov di, a
1549   0C3A FA 05 00      lea d, [bp + 5] ; $filename
1550   0C3D FD 2A         mov d, [d]
1551   0C3F 19 14         mov al, 20
1552   0C41 05 04         syscall sys_filesystem
1553   0C43             ; --- END INLINE ASM BLOCK
1554   0C43             
1555   0C43 F9            leave
1556   0C44 09            ret
1557   0C45             
1558   0C45             create_file:
1559   0C45 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1560   0C48 F9            leave
1561   0C49 09            ret
1562   0C4A             
1563   0C4A             delete_file:
1564   0C4A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1565   0C4D             
1566   0C4D             ; --- BEGIN INLINE ASM BLOCK
1567   0C4D FA 05 00      lea d, [bp + 5] ; $filename
1568   0C50 19 0A         mov al, 10
1569   0C52 05 04         syscall sys_filesystem
1570   0C54             ; --- END INLINE ASM BLOCK
1571   0C54             
1572   0C54 F9            leave
1573   0C55 09            ret
1574   0C56             
1575   0C56             fopen:
1576   0C56 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1577   0C59 F9            leave
1578   0C5A 09            ret
1579   0C5B             
1580   0C5B             fclose:
1581   0C5B F8 00 00      enter 0 ; (push bp; mov bp, sp)
1582   0C5E F9            leave
1583   0C5F 09            ret
1584   0C60             
1585   0C60             alloc:
1586   0C60 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1587   0C63             ;; heap_top = heap_top + bytes; 
1588   0C63 3B 31 11      mov d, _heap_top ; $heap_top
1589   0C66 DA            push d
1590   0C67 3B 31 11      mov d, _heap_top ; $heap_top
1591   0C6A 2A            mov b, [d]
1592   0C6B             ; START TERMS
1593   0C6B D7            push a
1594   0C6C 11            mov a, b
1595   0C6D FA 05 00      lea d, [bp + 5] ; $bytes
1596   0C70 2A            mov b, [d]
1597   0C71 54            add a, b
1598   0C72 27            mov b, a
1599   0C73 E4            pop a
1600   0C74             ; END TERMS
1601   0C74 E7            pop d
1602   0C75 FD 43         mov [d], b
1603   0C77             ;; return heap_top - bytes; 
1604   0C77 3B 31 11      mov d, _heap_top ; $heap_top
1605   0C7A 2A            mov b, [d]
1606   0C7B             ; START TERMS
1607   0C7B D7            push a
1608   0C7C 11            mov a, b
1609   0C7D FA 05 00      lea d, [bp + 5] ; $bytes
1610   0C80 2A            mov b, [d]
1611   0C81 60            sub a, b
1612   0C82 27            mov b, a
1613   0C83 E4            pop a
1614   0C84             ; END TERMS
1615   0C84 F9            leave
1616   0C85 09            ret
1617   0C86             
1618   0C86             free:
1619   0C86 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1620   0C89             ;; return heap_top = heap_top - bytes; 
1621   0C89 3B 31 11      mov d, _heap_top ; $heap_top
1622   0C8C DA            push d
1623   0C8D 3B 31 11      mov d, _heap_top ; $heap_top
1624   0C90 2A            mov b, [d]
1625   0C91             ; START TERMS
1626   0C91 D7            push a
1627   0C92 11            mov a, b
1628   0C93 FA 05 00      lea d, [bp + 5] ; $bytes
1629   0C96 2A            mov b, [d]
1630   0C97 60            sub a, b
1631   0C98 27            mov b, a
1632   0C99 E4            pop a
1633   0C9A             ; END TERMS
1634   0C9A E7            pop d
1635   0C9B FD 43         mov [d], b
1636   0C9D F9            leave
1637   0C9E 09            ret
1638   0C9F             
1639   0C9F             exit:
1640   0C9F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1641   0CA2             
1642   0CA2             ; --- BEGIN INLINE ASM BLOCK
1643   0CA2 05 0B         syscall sys_terminate_proc
1644   0CA4             ; --- END INLINE ASM BLOCK
1645   0CA4             
1646   0CA4 F9            leave
1647   0CA5 09            ret
1648   0CA6             
1649   0CA6             load_hex:
1650   0CA6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1651   0CA9             ; $temp 
1652   0CA9 52 02 00      sub sp, 2
1653   0CAC             ;; temp = alloc(32768); 
1654   0CAC FA FF FF      lea d, [bp + -1] ; $temp
1655   0CAF DA            push d
1656   0CB0 26 00 80      mov b, $8000
1657   0CB3 FD AB         swp b
1658   0CB5 D8            push b
1659   0CB6 07 60 0C      call alloc
1660   0CB9 51 02 00      add sp, 2
1661   0CBC E7            pop d
1662   0CBD FD 43         mov [d], b
1663   0CBF             
1664   0CBF             ; --- BEGIN INLINE ASM BLOCK
1665   0CBF               
1666   0CBF               
1667   0CBF               
1668   0CBF               
1669   0CBF               
1670   0CBF             _load_hex:
1671   0CBF D7            push a
1672   0CC0 D8            push b
1673   0CC1 DA            push d
1674   0CC2 E2            push si
1675   0CC3 E3            push di
1676   0CC4 52 00 80      sub sp, $8000      
1677   0CC7 38 00 00      mov c, 0
1678   0CCA 48            mov a, sp
1679   0CCB 77            inc a
1680   0CCC 3C            mov d, a          
1681   0CCD 07 61 0E      call _gets        
1682   0CD0 4D            mov si, a
1683   0CD1             __load_hex_loop:
1684   0CD1 F6            lodsb             
1685   0CD2 B9 00         cmp al, 0         
1686   0CD4 C6 E2 0C      jz __load_hex_ret
1687   0CD7 36            mov bh, al
1688   0CD8 F6            lodsb
1689   0CD9 2F            mov bl, al
1690   0CDA 07 17 0E      call _atoi        
1691   0CDD F7            stosb             
1692   0CDE 78            inc c
1693   0CDF 0A D1 0C      jmp __load_hex_loop
1694   0CE2             __load_hex_ret:
1695   0CE2 51 00 80      add sp, $8000
1696   0CE5 F0            pop di
1697   0CE6 EF            pop si
1698   0CE7 E7            pop d
1699   0CE8 E5            pop b
1700   0CE9 E4            pop a
1701   0CEA             ; --- END INLINE ASM BLOCK
1702   0CEA             
1703   0CEA F9            leave
1704   0CEB 09            ret
1705   0CEC             
1706   0CEC             getparam:
1707   0CEC F8 00 00      enter 0 ; (push bp; mov bp, sp)
1708   0CEF             ; $data 
1709   0CEF 52 01 00      sub sp, 1
1710   0CF2             
1711   0CF2             ; --- BEGIN INLINE ASM BLOCK
1712   0CF2 19 04         mov al, 4
1713   0CF4 FA 05 00      lea d, [bp + 5] ; $address
1714   0CF7 FD 2A         mov d, [d]
1715   0CF9 05 0C         syscall sys_system
1716   0CFB FA 00 00      lea d, [bp + 0] ; $data
1717   0CFE FD 3E         mov [d], bl
1718   0D00             ; --- END INLINE ASM BLOCK
1719   0D00             
1720   0D00             ;; return data; 
1721   0D00 FA 00 00      lea d, [bp + 0] ; $data
1722   0D03 32            mov bl, [d]
1723   0D04 A7 00         mov bh, 0
1724   0D06 F9            leave
1725   0D07 09            ret
1726   0D08             
1727   0D08             clear:
1728   0D08 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1729   0D0B             ;; print("\033[2J\033[H"); 
1730   0D0B 26 27 11      mov b, __s1 ; "\033[2J\033[H"
1731   0D0E FD AB         swp b
1732   0D10 D8            push b
1733   0D11 07 25 0C      call print
1734   0D14 51 02 00      add sp, 2
1735   0D17 F9            leave
1736   0D18 09            ret
1737   0D19             
1738   0D19             printun:
1739   0D19 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1740   0D1C             ;; print(prompt); 
1741   0D1C FA 05 00      lea d, [bp + 5] ; $prompt
1742   0D1F 2A            mov b, [d]
1743   0D20 FD AB         swp b
1744   0D22 D8            push b
1745   0D23 07 25 0C      call print
1746   0D26 51 02 00      add sp, 2
1747   0D29             ;; printu(n); 
1748   0D29 FA 07 00      lea d, [bp + 7] ; $n
1749   0D2C 2A            mov b, [d]
1750   0D2D FD AB         swp b
1751   0D2F D8            push b
1752   0D30 07 F1 0A      call printu
1753   0D33 51 02 00      add sp, 2
1754   0D36             ;; print("\n"); 
1755   0D36 26 2F 11      mov b, __s2 ; "\n"
1756   0D39 FD AB         swp b
1757   0D3B D8            push b
1758   0D3C 07 25 0C      call print
1759   0D3F 51 02 00      add sp, 2
1760   0D42 F9            leave
1761   0D43 09            ret
1762   0D44             
1763   0D44             printsn:
1764   0D44 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1765   0D47             ;; print(prompt); 
1766   0D47 FA 05 00      lea d, [bp + 5] ; $prompt
1767   0D4A 2A            mov b, [d]
1768   0D4B FD AB         swp b
1769   0D4D D8            push b
1770   0D4E 07 25 0C      call print
1771   0D51 51 02 00      add sp, 2
1772   0D54             ;; prints(n); 
1773   0D54 FA 07 00      lea d, [bp + 7] ; $n
1774   0D57 2A            mov b, [d]
1775   0D58 FD AB         swp b
1776   0D5A D8            push b
1777   0D5B 07 FC 09      call prints
1778   0D5E 51 02 00      add sp, 2
1779   0D61             ;; print("\n"); 
1780   0D61 26 2F 11      mov b, __s2 ; "\n"
1781   0D64 FD AB         swp b
1782   0D66 D8            push b
1783   0D67 07 25 0C      call print
1784   0D6A 51 02 00      add sp, 2
1785   0D6D F9            leave
1786   0D6E 09            ret
1787   0D6F             
1788   0D6F             include_stdio_asm:
1789   0D6F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1790   0D72             
1791   0D72             ; --- BEGIN INLINE ASM BLOCK
1792   0D72             .include "lib/asm/stdio.asm"
0001+  0D72             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0D72             ; stdio.s
0003+  0D72             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0D72             .include "lib/asm/string.asm"
0001++ 0D72             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0D72             ; string.s
0003++ 0D72             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0D72             
0005++ 0D72             
0006++ 0D72             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0D72             ; _strrev
0008++ 0D72             ; reverse a string
0009++ 0D72             ; D = string address
0010++ 0D72             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0D72             ; 01234
0012++ 0D72             _strrev:
0013++ 0D72 4B          	pusha
0014++ 0D73 07 B9 0D    	call _strlen	; length in C
0015++ 0D76 12          	mov a, c
0016++ 0D77 AF 01 00    	cmp a, 1
0017++ 0D7A D0 94 0D    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 0D7D 7D          	dec a
0019++ 0D7E FD 4E       	mov si, d	; beginning of string
0020++ 0D80 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0D82 59          	add d, a	; end of string
0022++ 0D83 12          	mov a, c
0023++ 0D84 FD 9B       	shr a		; divide by 2
0024++ 0D86 39          	mov c, a	; C now counts the steps
0025++ 0D87             _strrev_L0:
0026++ 0D87 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0D88 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0D89 3E          	mov [d], al	; store left char into right side
0029++ 0D8A 1B          	mov al, bl
0030++ 0D8B F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0D8C 7E          	dec c
0032++ 0D8D 7F          	dec d
0033++ 0D8E C2 00 00    	cmp c, 0
0034++ 0D91 C7 87 0D    	jne _strrev_L0
0035++ 0D94             _strrev_end:
0036++ 0D94 4C          	popa
0037++ 0D95 09          	ret
0038++ 0D96             	
0039++ 0D96             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0D96             ; _strchr
0041++ 0D96             ; search string in D for char in AL
0042++ 0D96             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0D96             _strchr:
0044++ 0D96             _strchr_L0:
0045++ 0D96 32          	mov bl, [d]
0046++ 0D97 C1 00       	cmp bl, 0
0047++ 0D99 C6 A4 0D    	je _strchr_end
0048++ 0D9C BA          	cmp al, bl
0049++ 0D9D C6 A4 0D    	je _strchr_end
0050++ 0DA0 79          	inc d
0051++ 0DA1 0A 96 0D    	jmp _strchr_L0
0052++ 0DA4             _strchr_end:
0053++ 0DA4 1B          	mov al, bl
0054++ 0DA5 09          	ret
0055++ 0DA6             
0056++ 0DA6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0DA6             ; _strstr
0058++ 0DA6             ; find sub-string
0059++ 0DA6             ; str1 in SI
0060++ 0DA6             ; str2 in DI
0061++ 0DA6             ; SI points to end of source string
0062++ 0DA6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0DA6             _strstr:
0064++ 0DA6 DB          	push al
0065++ 0DA7 DA          	push d
0066++ 0DA8 E3          	push di
0067++ 0DA9             _strstr_loop:
0068++ 0DA9 F3          	cmpsb					; compare a byte of the strings
0069++ 0DAA C7 B5 0D    	jne _strstr_ret
0070++ 0DAD FC 00 00    	lea d, [di + 0]
0071++ 0DB0 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0DB2 C7 A9 0D    	jne _strstr_loop				; equal chars but not at end
0073++ 0DB5             _strstr_ret:
0074++ 0DB5 F0          	pop di
0075++ 0DB6 E7          	pop d
0076++ 0DB7 E8          	pop al
0077++ 0DB8 09          	ret
0078++ 0DB9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0DB9             ; length of null terminated string
0080++ 0DB9             ; result in C
0081++ 0DB9             ; pointer in D
0082++ 0DB9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0DB9             _strlen:
0084++ 0DB9 DA          	push d
0085++ 0DBA 38 00 00    	mov c, 0
0086++ 0DBD             _strlen_L1:
0087++ 0DBD BD 00       	cmp byte [d], 0
0088++ 0DBF C6 C7 0D    	je _strlen_ret
0089++ 0DC2 79          	inc d
0090++ 0DC3 78          	inc c
0091++ 0DC4 0A BD 0D    	jmp _strlen_L1
0092++ 0DC7             _strlen_ret:
0093++ 0DC7 E7          	pop d
0094++ 0DC8 09          	ret
0095++ 0DC9             
0096++ 0DC9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0DC9             ; STRCMP
0098++ 0DC9             ; compare two strings
0099++ 0DC9             ; str1 in SI
0100++ 0DC9             ; str2 in DI
0101++ 0DC9             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0DC9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0DC9             _strcmp:
0104++ 0DC9 DB          	push al
0105++ 0DCA DA          	push d
0106++ 0DCB E3          	push di
0107++ 0DCC E2          	push si
0108++ 0DCD             _strcmp_loop:
0109++ 0DCD F3          	cmpsb					; compare a byte of the strings
0110++ 0DCE C7 D9 0D    	jne _strcmp_ret
0111++ 0DD1 FB FF FF    	lea d, [si +- 1]
0112++ 0DD4 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0DD6 C7 CD 0D    	jne _strcmp_loop				; equal chars but not at end
0114++ 0DD9             _strcmp_ret:
0115++ 0DD9 EF          	pop si
0116++ 0DDA F0          	pop di
0117++ 0DDB E7          	pop d
0118++ 0DDC E8          	pop al
0119++ 0DDD 09          	ret
0120++ 0DDE             
0121++ 0DDE             
0122++ 0DDE             ; STRCPY
0123++ 0DDE             ; copy null terminated string from SI to DI
0124++ 0DDE             ; source in SI
0125++ 0DDE             ; destination in DI
0126++ 0DDE             _strcpy:
0127++ 0DDE E2          	push si
0128++ 0DDF E3          	push di
0129++ 0DE0 DB          	push al
0130++ 0DE1             _strcpy_L1:
0131++ 0DE1 F6          	lodsb
0132++ 0DE2 F7          	stosb
0133++ 0DE3 B9 00       	cmp al, 0
0134++ 0DE5 C7 E1 0D    	jne _strcpy_L1
0135++ 0DE8             _strcpy_end:
0136++ 0DE8 E8          	pop al
0137++ 0DE9 F0          	pop di
0138++ 0DEA EF          	pop si
0139++ 0DEB 09          	ret
0140++ 0DEC             
0141++ 0DEC             ; STRCAT
0142++ 0DEC             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0DEC             ; source in SI
0144++ 0DEC             ; destination in DI
0145++ 0DEC             _strcat:
0146++ 0DEC E2          	push si
0147++ 0DED E3          	push di
0148++ 0DEE D7          	push a
0149++ 0DEF DA          	push d
0150++ 0DF0 50          	mov a, di
0151++ 0DF1 3C          	mov d, a
0152++ 0DF2             _strcat_goto_end_L1:
0153++ 0DF2 BD 00       	cmp byte[d], 0
0154++ 0DF4 C6 FB 0D    	je _strcat_start
0155++ 0DF7 79          	inc d
0156++ 0DF8 0A F2 0D    	jmp _strcat_goto_end_L1
0157++ 0DFB             _strcat_start:
0158++ 0DFB FD 50       	mov di, d
0159++ 0DFD             _strcat_L1:
0160++ 0DFD F6          	lodsb
0161++ 0DFE F7          	stosb
0162++ 0DFF B9 00       	cmp al, 0
0163++ 0E01 C7 FD 0D    	jne _strcat_L1
0164++ 0E04             _strcat_end:
0165++ 0E04 E7          	pop d
0166++ 0E05 E4          	pop a
0167++ 0E06 F0          	pop di
0168++ 0E07 EF          	pop si
0169++ 0E08 09          	ret
0170++ 0E09             
0171++ 0E09             
0005+  0E09             
0006+  0E09             
0007+  0E09             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  0E09             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  0E09             ; ASCII in BL
0010+  0E09             ; result in AL
0011+  0E09             ; ascii for F = 0100 0110
0012+  0E09             ; ascii for 9 = 0011 1001
0013+  0E09             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  0E09             hex_ascii_encode:
0015+  0E09 1B            mov al, bl
0016+  0E0A 93 40         test al, $40        ; test if letter or number
0017+  0E0C C7 12 0E      jnz hex_letter
0018+  0E0F 87 0F         and al, $0F        ; get number
0019+  0E11 09            ret
0020+  0E12             hex_letter:
0021+  0E12 87 0F         and al, $0F        ; get letter
0022+  0E14 6A 09         add al, 9
0023+  0E16 09            ret
0024+  0E17             
0025+  0E17             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0E17             ; ATOI
0027+  0E17             ; 2 letter hex string in B
0028+  0E17             ; 8bit integer returned in AL
0029+  0E17             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  0E17             _atoi:
0031+  0E17 D8            push b
0032+  0E18 07 09 0E      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  0E1B 30            mov bl, bh
0034+  0E1C DB            push al          ; save a
0035+  0E1D 07 09 0E      call hex_ascii_encode
0036+  0E20 EA            pop bl  
0037+  0E21 FD 9E 04      shl al, 4
0038+  0E24 8C            or al, bl
0039+  0E25 E5            pop b
0040+  0E26 09            ret  
0041+  0E27             
0042+  0E27             
0043+  0E27             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  0E27             ; scanf
0045+  0E27             ; no need for explanations!
0046+  0E27             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  0E27             scanf:
0048+  0E27 09            ret
0049+  0E28             
0050+  0E28             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0E28             ; ITOA
0052+  0E28             ; 8bit value in BL
0053+  0E28             ; 2 byte ASCII result in A
0054+  0E28             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0E28             _itoa:
0056+  0E28 DA            push d
0057+  0E29 D8            push b
0058+  0E2A A7 00         mov bh, 0
0059+  0E2C FD A4 04      shr bl, 4  
0060+  0E2F 74            mov d, b
0061+  0E30 1F D8 10      mov al, [d + s_hex_digits]
0062+  0E33 23            mov ah, al
0063+  0E34               
0064+  0E34 E5            pop b
0065+  0E35 D8            push b
0066+  0E36 A7 00         mov bh, 0
0067+  0E38 FD 87 0F      and bl, $0F
0068+  0E3B 74            mov d, b
0069+  0E3C 1F D8 10      mov al, [d + s_hex_digits]
0070+  0E3F E5            pop b
0071+  0E40 E7            pop d
0072+  0E41 09            ret
0073+  0E42             
0074+  0E42             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  0E42             ; HEX STRING TO BINARY
0076+  0E42             ; di = destination address
0077+  0E42             ; si = source
0078+  0E42             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  0E42             _hex_to_int:
0080+  0E42             _hex_to_int_L1:
0081+  0E42 F6            lodsb          ; load from [SI] to AL
0082+  0E43 B9 00         cmp al, 0        ; check if ASCII 0
0083+  0E45 C6 52 0E      jz _hex_to_int_ret
0084+  0E48 36            mov bh, al
0085+  0E49 F6            lodsb
0086+  0E4A 2F            mov bl, al
0087+  0E4B 07 17 0E      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  0E4E F7            stosb          ; store AL to [DI]
0089+  0E4F 0A 42 0E      jmp _hex_to_int_L1
0090+  0E52             _hex_to_int_ret:
0091+  0E52 09            ret    
0092+  0E53             
0093+  0E53             
0094+  0E53             
0095+  0E53             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  0E53             ; GETCHAR
0097+  0E53             ; char in ah
0098+  0E53             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  0E53             getch:
0100+  0E53 DB            push al
0101+  0E54             getch_retry:
0102+  0E54 19 01         mov al, 1
0103+  0E56 05 03         syscall sys_io      ; receive in AH
0104+  0E58 E8            pop al
0105+  0E59 09            ret
0106+  0E5A             
0107+  0E5A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  0E5A             ; PUTCHAR
0109+  0E5A             ; char in ah
0110+  0E5A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0E5A             _putchar:
0112+  0E5A D7            push a
0113+  0E5B 19 00         mov al, 0
0114+  0E5D 05 03         syscall sys_io      ; char in AH
0115+  0E5F E4            pop a
0116+  0E60 09            ret
0117+  0E61             
0118+  0E61             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  0E61             ;; INPUT A STRING
0120+  0E61             ;; terminates with null
0121+  0E61             ;; pointer in D
0122+  0E61             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  0E61             _gets:
0124+  0E61 D7            push a
0125+  0E62 DA            push d
0126+  0E63             _gets_loop:
0127+  0E63 19 01         mov al, 1
0128+  0E65 05 03         syscall sys_io      ; receive in AH
0129+  0E67 B9 00         cmp al, 0        ; check error code (AL)
0130+  0E69 C6 63 0E      je _gets_loop      ; if no char received, retry
0131+  0E6C             
0132+  0E6C 76 1B         cmp ah, 27
0133+  0E6E C6 8F 0E      je _gets_ansi_esc
0134+  0E71 76 0A         cmp ah, $0A        ; LF
0135+  0E73 C6 FA 0E      je _gets_end
0136+  0E76 76 0D         cmp ah, $0D        ; CR
0137+  0E78 C6 FA 0E      je _gets_end
0138+  0E7B 76 5C         cmp ah, $5C        ; '\\'
0139+  0E7D C6 BB 0E      je _gets_escape
0140+  0E80               
0141+  0E80 76 08         cmp ah, $08      ; check for backspace
0142+  0E82 C6 8B 0E      je _gets_backspace
0143+  0E85             
0144+  0E85 1A            mov al, ah
0145+  0E86 3E            mov [d], al
0146+  0E87 79            inc d
0147+  0E88 0A 63 0E      jmp _gets_loop
0148+  0E8B             _gets_backspace:
0149+  0E8B 7F            dec d
0150+  0E8C 0A 63 0E      jmp _gets_loop
0151+  0E8F             _gets_ansi_esc:
0152+  0E8F 19 01         mov al, 1
0153+  0E91 05 03         syscall sys_io        ; receive in AH without echo
0154+  0E93 B9 00         cmp al, 0          ; check error code (AL)
0155+  0E95 C6 8F 0E      je _gets_ansi_esc    ; if no char received, retry
0156+  0E98 76 5B         cmp ah, '['
0157+  0E9A C7 63 0E      jne _gets_loop
0158+  0E9D             _gets_ansi_esc_2:
0159+  0E9D 19 01         mov al, 1
0160+  0E9F 05 03         syscall sys_io          ; receive in AH without echo
0161+  0EA1 B9 00         cmp al, 0            ; check error code (AL)
0162+  0EA3 C6 9D 0E      je _gets_ansi_esc_2  ; if no char received, retry
0163+  0EA6 76 44         cmp ah, 'D'
0164+  0EA8 C6 B3 0E      je _gets_left_arrow
0165+  0EAB 76 43         cmp ah, 'C'
0166+  0EAD C6 B7 0E      je _gets_right_arrow
0167+  0EB0 0A 63 0E      jmp _gets_loop
0168+  0EB3             _gets_left_arrow:
0169+  0EB3 7F            dec d
0170+  0EB4 0A 63 0E      jmp _gets_loop
0171+  0EB7             _gets_right_arrow:
0172+  0EB7 79            inc d
0173+  0EB8 0A 63 0E      jmp _gets_loop
0174+  0EBB             _gets_escape:
0175+  0EBB 19 01         mov al, 1
0176+  0EBD 05 03         syscall sys_io      ; receive in AH
0177+  0EBF B9 00         cmp al, 0        ; check error code (AL)
0178+  0EC1 C6 BB 0E      je _gets_escape      ; if no char received, retry
0179+  0EC4 76 6E         cmp ah, 'n'
0180+  0EC6 C6 E5 0E      je _gets_LF
0181+  0EC9 76 72         cmp ah, 'r'
0182+  0ECB C6 EC 0E      je _gets_CR
0183+  0ECE 76 30         cmp ah, '0'
0184+  0ED0 C6 F3 0E      je _gets_NULL
0185+  0ED3 76 5C         cmp ah, $5C  ; '\'
0186+  0ED5 C6 DE 0E      je _gets_slash
0187+  0ED8 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0188+  0ED9 3E            mov [d], al
0189+  0EDA 79            inc d
0190+  0EDB 0A 63 0E      jmp _gets_loop
0191+  0EDE             _gets_slash:
0192+  0EDE 19 5C         mov al, $5C
0193+  0EE0 3E            mov [d], al
0194+  0EE1 79            inc d
0195+  0EE2 0A 63 0E      jmp _gets_loop
0196+  0EE5             _gets_LF:
0197+  0EE5 19 0A         mov al, $0A
0198+  0EE7 3E            mov [d], al
0199+  0EE8 79            inc d
0200+  0EE9 0A 63 0E      jmp _gets_loop
0201+  0EEC             _gets_CR:
0202+  0EEC 19 0D         mov al, $0D
0203+  0EEE 3E            mov [d], al
0204+  0EEF 79            inc d
0205+  0EF0 0A 63 0E      jmp _gets_loop
0206+  0EF3             _gets_NULL:
0207+  0EF3 19 00         mov al, $00
0208+  0EF5 3E            mov [d], al
0209+  0EF6 79            inc d
0210+  0EF7 0A 63 0E      jmp _gets_loop
0211+  0EFA             _gets_end:
0212+  0EFA 19 00         mov al, 0
0213+  0EFC 3E            mov [d], al        ; terminate string
0214+  0EFD E7            pop d
0215+  0EFE E4            pop a
0216+  0EFF 09            ret
0217+  0F00             
0218+  0F00             
0219+  0F00             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0220+  0F00             ;; INPUT TEXT
0221+  0F00             ;; terminated with CTRL+D
0222+  0F00             ;; pointer in D
0223+  0F00             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0224+  0F00             _gettxt:
0225+  0F00 D7            push a
0226+  0F01 DA            push d
0227+  0F02             _gettxt_loop:
0228+  0F02 19 01         mov al, 1
0229+  0F04 05 03         syscall sys_io      ; receive in AH
0230+  0F06 B9 00         cmp al, 0        ; check error code (AL)
0231+  0F08 C6 02 0F      je _gettxt_loop    ; if no char received, retry
0232+  0F0B 76 04         cmp ah, 4      ; EOT
0233+  0F0D C6 4B 0F      je _gettxt_end
0234+  0F10 76 08         cmp ah, $08      ; check for backspace
0235+  0F12 C6 47 0F      je _gettxt_backspace
0236+  0F15 76 5C         cmp ah, $5C        ; '\'
0237+  0F17 C6 20 0F      je _gettxt_escape
0238+  0F1A 1A            mov al, ah
0239+  0F1B 3E            mov [d], al
0240+  0F1C 79            inc d
0241+  0F1D 0A 02 0F      jmp _gettxt_loop
0242+  0F20             _gettxt_escape:
0243+  0F20 19 01         mov al, 1
0244+  0F22 05 03         syscall sys_io      ; receive in AH
0245+  0F24 B9 00         cmp al, 0        ; check error code (AL)
0246+  0F26 C6 20 0F      je _gettxt_escape    ; if no char received, retry
0247+  0F29 76 6E         cmp ah, 'n'
0248+  0F2B C6 39 0F      je _gettxt_LF
0249+  0F2E 76 72         cmp ah, 'r'
0250+  0F30 C6 40 0F      je _gettxt_CR
0251+  0F33 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0252+  0F34 3E            mov [d], al
0253+  0F35 79            inc d
0254+  0F36 0A 02 0F      jmp _gettxt_loop
0255+  0F39             _gettxt_LF:
0256+  0F39 19 0A         mov al, $0A
0257+  0F3B 3E            mov [d], al
0258+  0F3C 79            inc d
0259+  0F3D 0A 02 0F      jmp _gettxt_loop
0260+  0F40             _gettxt_CR:
0261+  0F40 19 0D         mov al, $0D
0262+  0F42 3E            mov [d], al
0263+  0F43 79            inc d
0264+  0F44 0A 02 0F      jmp _gettxt_loop
0265+  0F47             _gettxt_backspace:
0266+  0F47 7F            dec d
0267+  0F48 0A 02 0F      jmp _gettxt_loop
0268+  0F4B             _gettxt_end:
0269+  0F4B 19 00         mov al, 0
0270+  0F4D 3E            mov [d], al        ; terminate string
0271+  0F4E E7            pop d
0272+  0F4F E4            pop a
0273+  0F50 09            ret
0274+  0F51             
0275+  0F51             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  0F51             ; PRINT NEW LINE
0277+  0F51             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0278+  0F51             printnl:
0279+  0F51 D7            push a
0280+  0F52 10 00 0A      mov a, $0A00
0281+  0F55 05 03         syscall sys_io
0282+  0F57 10 00 0D      mov a, $0D00
0283+  0F5A 05 03         syscall sys_io
0284+  0F5C E4            pop a
0285+  0F5D 09            ret
0286+  0F5E             
0287+  0F5E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  0F5E             ; _strtoint
0289+  0F5E             ; 4 digit hex string number in d
0290+  0F5E             ; integer returned in A
0291+  0F5E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0292+  0F5E             _strtointx:
0293+  0F5E D8            push b
0294+  0F5F 32            mov bl, [d]
0295+  0F60 37            mov bh, bl
0296+  0F61 33 01 00      mov bl, [d + 1]
0297+  0F64 07 17 0E      call _atoi        ; convert to int in AL
0298+  0F67 23            mov ah, al        ; move to AH
0299+  0F68 33 02 00      mov bl, [d + 2]
0300+  0F6B 37            mov bh, bl
0301+  0F6C 33 03 00      mov bl, [d + 3]
0302+  0F6F 07 17 0E      call _atoi        ; convert to int in AL
0303+  0F72 E5            pop b
0304+  0F73 09            ret
0305+  0F74             
0306+  0F74             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0307+  0F74             ; _strtoint
0308+  0F74             ; 5 digit base10 string number in d
0309+  0F74             ; integer returned in A
0310+  0F74             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0311+  0F74             _strtoint:
0312+  0F74 E2            push si
0313+  0F75 D8            push b
0314+  0F76 D9            push c
0315+  0F77 DA            push d
0316+  0F78 07 B9 0D      call _strlen      ; get string length in C
0317+  0F7B 7E            dec c
0318+  0F7C FD 4E         mov si, d
0319+  0F7E 12            mov a, c
0320+  0F7F FD 99         shl a
0321+  0F81 3B F0 10      mov d, table_power
0322+  0F84 59            add d, a
0323+  0F85 38 00 00      mov c, 0
0324+  0F88             _strtoint_L0:
0325+  0F88 F6            lodsb      ; load ASCII to al
0326+  0F89 B9 00         cmp al, 0
0327+  0F8B C6 9E 0F      je _strtoint_end
0328+  0F8E 6F 30         sub al, $30    ; make into integer
0329+  0F90 22 00         mov ah, 0
0330+  0F92 2A            mov b, [d]
0331+  0F93 AC            mul a, b      ; result in B since it fits in 16bits
0332+  0F94 11            mov a, b
0333+  0F95 28            mov b, c
0334+  0F96 54            add a, b
0335+  0F97 39            mov c, a
0336+  0F98 63 02 00      sub d, 2
0337+  0F9B 0A 88 0F      jmp _strtoint_L0
0338+  0F9E             _strtoint_end:
0339+  0F9E 12            mov a, c
0340+  0F9F E7            pop d
0341+  0FA0 E6            pop c
0342+  0FA1 E5            pop b
0343+  0FA2 EF            pop si
0344+  0FA3 09            ret
0345+  0FA4             
0346+  0FA4             
0347+  0FA4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0348+  0FA4             ; PRINT NULL TERMINATED STRING
0349+  0FA4             ; pointer in D
0350+  0FA4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0351+  0FA4             _puts:
0352+  0FA4 D7            push a
0353+  0FA5 DA            push d
0354+  0FA6             _puts_L1:
0355+  0FA6 1E            mov al, [d]
0356+  0FA7 B9 00         cmp al, 0
0357+  0FA9 C6 B5 0F      jz _puts_END
0358+  0FAC 23            mov ah, al
0359+  0FAD 19 00         mov al, 0
0360+  0FAF 05 03         syscall sys_io
0361+  0FB1 79            inc d
0362+  0FB2 0A A6 0F      jmp _puts_L1
0363+  0FB5             _puts_END:
0364+  0FB5 E7            pop d
0365+  0FB6 E4            pop a
0366+  0FB7 09            ret
0367+  0FB8             
0368+  0FB8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0369+  0FB8             ; PRINT N SIZE STRING
0370+  0FB8             ; pointer in D
0371+  0FB8             ; size in C
0372+  0FB8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0373+  0FB8             _putsn:
0374+  0FB8 DB            push al
0375+  0FB9 DA            push d
0376+  0FBA D9            push c
0377+  0FBB             _putsn_L0:
0378+  0FBB 1E            mov al, [d]
0379+  0FBC 23            mov ah, al
0380+  0FBD 19 00         mov al, 0
0381+  0FBF 05 03         syscall sys_io
0382+  0FC1 79            inc d
0383+  0FC2 7E            dec c  
0384+  0FC3 C2 00 00      cmp c, 0
0385+  0FC6 C7 BB 0F      jne _putsn_L0
0386+  0FC9             _putsn_end:
0387+  0FC9 E6            pop c
0388+  0FCA E7            pop d
0389+  0FCB E8            pop al
0390+  0FCC 09            ret
0391+  0FCD             
0392+  0FCD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0393+  0FCD             ; print 16bit decimal number
0394+  0FCD             ; input number in A
0395+  0FCD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0396+  0FCD             print_u16d:
0397+  0FCD D7            push a
0398+  0FCE D8            push b
0399+  0FCF 26 10 27      mov b, 10000
0400+  0FD2 AE            div a, b      ; get 10000's coeff.
0401+  0FD3 07 F5 0F      call print_number
0402+  0FD6 11            mov a, b
0403+  0FD7 26 E8 03      mov b, 1000
0404+  0FDA AE            div a, b      ; get 1000's coeff.
0405+  0FDB 07 F5 0F      call print_number
0406+  0FDE 11            mov a, b
0407+  0FDF 26 64 00      mov b, 100
0408+  0FE2 AE            div a, b
0409+  0FE3 07 F5 0F      call print_number
0410+  0FE6 11            mov a, b
0411+  0FE7 26 0A 00      mov b, 10
0412+  0FEA AE            div a, b
0413+  0FEB 07 F5 0F      call print_number
0414+  0FEE 1B            mov al, bl      ; 1's coeff in bl
0415+  0FEF 07 F5 0F      call print_number
0416+  0FF2 E5            pop b
0417+  0FF3 E4            pop a
0418+  0FF4 09            ret
0419+  0FF5             
0420+  0FF5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0421+  0FF5             ; print AL
0422+  0FF5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0423+  0FF5             print_number:
0424+  0FF5 6A 30         add al, $30
0425+  0FF7 23            mov ah, al
0426+  0FF8 07 5A 0E      call _putchar
0427+  0FFB 09            ret
0428+  0FFC             
0429+  0FFC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0430+  0FFC             ; PRINT 16BIT HEX INTEGER
0431+  0FFC             ; integer value in reg B
0432+  0FFC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  0FFC             print_u16x:
0434+  0FFC D7            push a
0435+  0FFD D8            push b
0436+  0FFE DD            push bl
0437+  0FFF 30            mov bl, bh
0438+  1000 07 28 0E      call _itoa        ; convert bh to char in A
0439+  1003 2F            mov bl, al        ; save al
0440+  1004 19 00         mov al, 0
0441+  1006 05 03         syscall sys_io        ; display AH
0442+  1008 24            mov ah, bl        ; retrieve al
0443+  1009 19 00         mov al, 0
0444+  100B 05 03         syscall sys_io        ; display AL
0445+  100D             
0446+  100D EA            pop bl
0447+  100E 07 28 0E      call _itoa        ; convert bh to char in A
0448+  1011 2F            mov bl, al        ; save al
0449+  1012 19 00         mov al, 0
0450+  1014 05 03         syscall sys_io        ; display AH
0451+  1016 24            mov ah, bl        ; retrieve al
0452+  1017 19 00         mov al, 0
0453+  1019 05 03         syscall sys_io        ; display AL
0454+  101B             
0455+  101B E5            pop b
0456+  101C E4            pop a
0457+  101D 09            ret
0458+  101E             
0459+  101E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0460+  101E             ; INPUT 16BIT HEX INTEGER
0461+  101E             ; read 16bit integer into A
0462+  101E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0463+  101E             scan_u16x:
0464+  101E F8 10 00      enter 16
0465+  1021 D8            push b
0466+  1022 DA            push d
0467+  1023             
0468+  1023 FA F1 FF      lea d, [bp + -15]
0469+  1026 07 61 0E      call _gets        ; get number
0470+  1029             
0471+  1029 32            mov bl, [d]
0472+  102A 37            mov bh, bl
0473+  102B 33 01 00      mov bl, [d + 1]
0474+  102E 07 17 0E      call _atoi        ; convert to int in AL
0475+  1031 23            mov ah, al        ; move to AH
0476+  1032             
0477+  1032 33 02 00      mov bl, [d + 2]
0478+  1035 37            mov bh, bl
0479+  1036 33 03 00      mov bl, [d + 3]
0480+  1039 07 17 0E      call _atoi        ; convert to int in AL
0481+  103C             
0482+  103C E7            pop d
0483+  103D E5            pop b
0484+  103E F9            leave
0485+  103F 09            ret
0486+  1040             
0487+  1040             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0488+  1040             ; PRINT 8bit HEX INTEGER
0489+  1040             ; integer value in reg bl
0490+  1040             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0491+  1040             print_u8x:
0492+  1040 D7            push a
0493+  1041 DD            push bl
0494+  1042             
0495+  1042 07 28 0E      call _itoa        ; convert bl to char in A
0496+  1045 2F            mov bl, al        ; save al
0497+  1046 19 00         mov al, 0
0498+  1048 05 03         syscall sys_io        ; display AH
0499+  104A 24            mov ah, bl        ; retrieve al
0500+  104B 19 00         mov al, 0
0501+  104D 05 03         syscall sys_io        ; display AL
0502+  104F             
0503+  104F EA            pop bl
0504+  1050 E4            pop a
0505+  1051 09            ret
0506+  1052             
0507+  1052             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0508+  1052             ; print 8bit decimal unsigned number
0509+  1052             ; input number in AL
0510+  1052             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0511+  1052             print_u8d:
0512+  1052 D7            push a
0513+  1053 D8            push b
0514+  1054             
0515+  1054 22 00         mov ah, 0
0516+  1056 26 64 00      mov b, 100
0517+  1059 AE            div a, b
0518+  105A D8            push b      ; save remainder
0519+  105B B9 00         cmp al, 0
0520+  105D C6 67 10      je skip100
0521+  1060 6A 30         add al, $30
0522+  1062 23            mov ah, al
0523+  1063 19 00         mov al, 0
0524+  1065 05 03         syscall sys_io  ; print coeff
0525+  1067             skip100:
0526+  1067 E4            pop a
0527+  1068 22 00         mov ah, 0
0528+  106A 26 0A 00      mov b, 10
0529+  106D AE            div a, b
0530+  106E D8            push b      ; save remainder
0531+  106F B9 00         cmp al, 0
0532+  1071 C6 7B 10      je skip10
0533+  1074 6A 30         add al, $30
0534+  1076 23            mov ah, al
0535+  1077 19 00         mov al, 0
0536+  1079 05 03         syscall sys_io  ; print coeff
0537+  107B             skip10:
0538+  107B E4            pop a
0539+  107C 1B            mov al, bl
0540+  107D 6A 30         add al, $30
0541+  107F 23            mov ah, al
0542+  1080 19 00         mov al, 0
0543+  1082 05 03         syscall sys_io  ; print coeff
0544+  1084 E5            pop b
0545+  1085 E4            pop a
0546+  1086 09            ret
0547+  1087             
0548+  1087             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0549+  1087             ; INPUT 8BIT HEX INTEGER
0550+  1087             ; read 8bit integer into AL
0551+  1087             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0552+  1087             scan_u8x:
0553+  1087 F8 04 00      enter 4
0554+  108A D8            push b
0555+  108B DA            push d
0556+  108C             
0557+  108C FA FD FF      lea d, [bp + -3]
0558+  108F 07 61 0E      call _gets        ; get number
0559+  1092             
0560+  1092 32            mov bl, [d]
0561+  1093 37            mov bh, bl
0562+  1094 33 01 00      mov bl, [d + 1]
0563+  1097 07 17 0E      call _atoi        ; convert to int in AL
0564+  109A             
0565+  109A E7            pop d
0566+  109B E5            pop b
0567+  109C F9            leave
0568+  109D 09            ret
0569+  109E             
0570+  109E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  109E             ; input decimal number
0572+  109E             ; result in A
0573+  109E             ; 655'\0'
0574+  109E             ; low--------high
0575+  109E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0576+  109E             scan_u16d:
0577+  109E F8 08 00      enter 8
0578+  10A1 E2            push si
0579+  10A2 D8            push b
0580+  10A3 D9            push c
0581+  10A4 DA            push d
0582+  10A5 FA F9 FF      lea d, [bp +- 7]
0583+  10A8 07 61 0E      call _gets
0584+  10AB 07 B9 0D      call _strlen      ; get string length in C
0585+  10AE 7E            dec c
0586+  10AF FD 4E         mov si, d
0587+  10B1 12            mov a, c
0588+  10B2 FD 99         shl a
0589+  10B4 3B F0 10      mov d, table_power
0590+  10B7 59            add d, a
0591+  10B8 38 00 00      mov c, 0
0592+  10BB             mul_loop:
0593+  10BB F6            lodsb      ; load ASCII to al
0594+  10BC B9 00         cmp al, 0
0595+  10BE C6 D1 10      je mul_exit
0596+  10C1 6F 30         sub al, $30    ; make into integer
0597+  10C3 22 00         mov ah, 0
0598+  10C5 2A            mov b, [d]
0599+  10C6 AC            mul a, b      ; result in B since it fits in 16bits
0600+  10C7 11            mov a, b
0601+  10C8 28            mov b, c
0602+  10C9 54            add a, b
0603+  10CA 39            mov c, a
0604+  10CB 63 02 00      sub d, 2
0605+  10CE 0A BB 10      jmp mul_loop
0606+  10D1             mul_exit:
0607+  10D1 12            mov a, c
0608+  10D2 E7            pop d
0609+  10D3 E6            pop c
0610+  10D4 E5            pop b
0611+  10D5 EF            pop si
0612+  10D6 F9            leave
0613+  10D7 09            ret
0614+  10D8             
0615+  10D8             
0616+  10D8 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0616+  10DC 34 35 36 37 
0616+  10E0 38 39 41 42 
0616+  10E4 43 44 45 46 
0617+  10E8 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0617+  10EC 1B 5B 48 00 
0618+  10F0             
0619+  10F0             table_power:
0620+  10F0 01 00         .dw 1
0621+  10F2 0A 00         .dw 10
0622+  10F4 64 00         .dw 100
0623+  10F6 E8 03         .dw 1000
0624+  10F8 10 27         .dw 100001793   10FA             ; --- END INLINE ASM BLOCK
1794   10FA             
1795   10FA F9            leave
1796   10FB 09            ret
1797   10FC             ; --- END TEXT BLOCK
1798   10FC             
1799   10FC             ; --- BEGIN DATA BLOCK
1800   10FC 00 00 00 00 _a: .fill 4, 0
1801   1100 00 00 00 00 _b: .fill 4, 0
1802   1104 00 00 00 00 _c: .fill 4, 0
1803   1108 45 72 72 6F __s0: .db "Error: Unknown argument type.\n", 0
1803   110C 72 3A 20 55 
1803   1110 6E 6B 6E 6F 
1803   1114 77 6E 20 61 
1803   1118 72 67 75 6D 
1803   111C 65 6E 74 20 
1803   1120 74 79 70 65 
1803   1124 2E 0A 00 
1804   1127 1B 5B 32 4A __s1: .db "\033[2J\033[H", 0
1804   112B 1B 5B 48 00 
1805   112F 0A 00       __s2: .db "\n", 0
1806   1131             
1807   1131 33 11       _heap_top: .dw _heap
1808   1133 00          _heap: .db 0
1809   1134             ; --- END DATA BLOCK
1810   1134             
1811   1134             .end
tasm: Number of errors = 0
