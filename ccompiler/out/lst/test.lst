0001   0000             ; --- FILENAME: test
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ;; k->energy; 
0011   0408 3B 40 17      mov d, _k ; $k
0012   040B FD 2A         mov d, [d]
0013   040D 58 01 00      add d, 1
0014   0410 2A            mov b, [d]
0015   0411 05 0B         syscall sys_terminate_proc
0016   0413             
0017   0413             strcpy:
0018   0413 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0019   0416             ; $psrc 
0020   0416             ; $pdest 
0021   0416 52 04 00      sub sp, 4
0022   0419             ;; psrc = src; 
0023   0419 FA FF FF      lea d, [bp + -1] ; $psrc
0024   041C DA            push d
0025   041D FA 07 00      lea d, [bp + 7] ; $src
0026   0420 2A            mov b, [d]
0027   0421 E7            pop d
0028   0422 FD 43         mov [d], b
0029   0424             ;; pdest = dest; 
0030   0424 FA FD FF      lea d, [bp + -3] ; $pdest
0031   0427 DA            push d
0032   0428 FA 05 00      lea d, [bp + 5] ; $dest
0033   042B 2A            mov b, [d]
0034   042C E7            pop d
0035   042D FD 43         mov [d], b
0036   042F             ;; while(*psrc) *pdest++ = *psrc++; 
0037   042F             _while1_cond:
0038   042F FA FF FF      lea d, [bp + -1] ; $psrc
0039   0432 2A            mov b, [d]
0040   0433 74            mov d, b
0041   0434 32            mov bl, [d]
0042   0435 A7 00         mov bh, 0
0043   0437 C0 00 00      cmp b, 0
0044   043A C6 62 04      je _while1_exit
0045   043D             _while1_block:
0046   043D             ;; *pdest++ = *psrc++; 
0047   043D FA FD FF      lea d, [bp + -3] ; $pdest
0048   0440 2A            mov b, [d]
0049   0441 D8            push b
0050   0442 FD 77         inc b
0051   0444 FA FD FF      lea d, [bp + -3] ; $pdest
0052   0447 FD 43         mov [d], b
0053   0449 E5            pop b
0054   044A D8            push b
0055   044B FA FF FF      lea d, [bp + -1] ; $psrc
0056   044E 2A            mov b, [d]
0057   044F D8            push b
0058   0450 FD 77         inc b
0059   0452 FA FF FF      lea d, [bp + -1] ; $psrc
0060   0455 FD 43         mov [d], b
0061   0457 E5            pop b
0062   0458 74            mov d, b
0063   0459 32            mov bl, [d]
0064   045A A7 00         mov bh, 0
0065   045C E7            pop d
0066   045D FD 3E         mov [d], bl
0067   045F 0A 2F 04      jmp _while1_cond
0068   0462             _while1_exit:
0069   0462             ;; *pdest = '\0'; 
0070   0462 FA FD FF      lea d, [bp + -3] ; $pdest
0071   0465 2A            mov b, [d]
0072   0466 D8            push b
0073   0467 26 00 00      mov b, $0
0074   046A E7            pop d
0075   046B FD 3E         mov [d], bl
0076   046D F9            leave
0077   046E 09            ret
0078   046F             
0079   046F             strcmp:
0080   046F F8 00 00      enter 0 ; (push bp; mov bp, sp)
0081   0472             ;; while (*s1 && (*s1 == *s2)) { 
0082   0472             _while2_cond:
0083   0472 FA 05 00      lea d, [bp + 5] ; $s1
0084   0475 2A            mov b, [d]
0085   0476 74            mov d, b
0086   0477 32            mov bl, [d]
0087   0478 A7 00         mov bh, 0
0088   047A D7            push a
0089   047B 11            mov a, b
0090   047C FA 05 00      lea d, [bp + 5] ; $s1
0091   047F 2A            mov b, [d]
0092   0480 74            mov d, b
0093   0481 32            mov bl, [d]
0094   0482 A7 00         mov bh, 0
0095   0484             ; START RELATIONAL
0096   0484 D7            push a
0097   0485 11            mov a, b
0098   0486 FA 07 00      lea d, [bp + 7] ; $s2
0099   0489 2A            mov b, [d]
0100   048A 74            mov d, b
0101   048B 32            mov bl, [d]
0102   048C A7 00         mov bh, 0
0103   048E B0            cmp a, b
0104   048F FD 71         seq ; ==
0105   0491 E4            pop a
0106   0492             ; END RELATIONAL
0107   0492 FD A7         sand a, b
0108   0494 E4            pop a
0109   0495 C0 00 00      cmp b, 0
0110   0498 C6 B8 04      je _while2_exit
0111   049B             _while2_block:
0112   049B             ;; s1++; 
0113   049B FA 05 00      lea d, [bp + 5] ; $s1
0114   049E 2A            mov b, [d]
0115   049F D8            push b
0116   04A0 FD 77         inc b
0117   04A2 FA 05 00      lea d, [bp + 5] ; $s1
0118   04A5 FD 43         mov [d], b
0119   04A7 E5            pop b
0120   04A8             ;; s2++; 
0121   04A8 FA 07 00      lea d, [bp + 7] ; $s2
0122   04AB 2A            mov b, [d]
0123   04AC D8            push b
0124   04AD FD 77         inc b
0125   04AF FA 07 00      lea d, [bp + 7] ; $s2
0126   04B2 FD 43         mov [d], b
0127   04B4 E5            pop b
0128   04B5 0A 72 04      jmp _while2_cond
0129   04B8             _while2_exit:
0130   04B8             ;; return *s1 - *s2; 
0131   04B8 FA 05 00      lea d, [bp + 5] ; $s1
0132   04BB 2A            mov b, [d]
0133   04BC 74            mov d, b
0134   04BD 32            mov bl, [d]
0135   04BE A7 00         mov bh, 0
0136   04C0             ; START TERMS
0137   04C0 D7            push a
0138   04C1 11            mov a, b
0139   04C2 FA 07 00      lea d, [bp + 7] ; $s2
0140   04C5 2A            mov b, [d]
0141   04C6 74            mov d, b
0142   04C7 32            mov bl, [d]
0143   04C8 A7 00         mov bh, 0
0144   04CA 60            sub a, b
0145   04CB 27            mov b, a
0146   04CC E4            pop a
0147   04CD             ; END TERMS
0148   04CD F9            leave
0149   04CE 09            ret
0150   04CF             
0151   04CF             strncmp:
0152   04CF F8 00 00      enter 0 ; (push bp; mov bp, sp)
0153   04D2 F9            leave
0154   04D3 09            ret
0155   04D4             
0156   04D4             strcat:
0157   04D4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0158   04D7             ; $dest_len 
0159   04D7             ; $i 
0160   04D7 52 04 00      sub sp, 4
0161   04DA             ;; dest_len = strlen(dest); 
0162   04DA FA FF FF      lea d, [bp + -1] ; $dest_len
0163   04DD DA            push d
0164   04DE FA 05 00      lea d, [bp + 5] ; $dest
0165   04E1 2A            mov b, [d]
0166   04E2 FD AB         swp b
0167   04E4 D8            push b
0168   04E5 07 87 05      call strlen
0169   04E8 51 02 00      add sp, 2
0170   04EB E7            pop d
0171   04EC FD 43         mov [d], b
0172   04EE             ;; for (i = 0; src[i] != 0; i=i+1) { 
0173   04EE             _for3_init:
0174   04EE FA FD FF      lea d, [bp + -3] ; $i
0175   04F1 DA            push d
0176   04F2 26 00 00      mov b, $0
0177   04F5 E7            pop d
0178   04F6 FD 43         mov [d], b
0179   04F8             _for3_cond:
0180   04F8 FA 07 00      lea d, [bp + 7] ; $src
0181   04FB FD 2A         mov d, [d]
0182   04FD D7            push a
0183   04FE DA            push d
0184   04FF FA FD FF      lea d, [bp + -3] ; $i
0185   0502 2A            mov b, [d]
0186   0503 E7            pop d
0187   0504 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0188   0508 E4            pop a
0189   0509 32            mov bl, [d]
0190   050A A7 00         mov bh, 0
0191   050C             ; START RELATIONAL
0192   050C D7            push a
0193   050D 11            mov a, b
0194   050E 26 00 00      mov b, $0
0195   0511 B0            cmp a, b
0196   0512 FD 72         sneq ; !=
0197   0514 E4            pop a
0198   0515             ; END RELATIONAL
0199   0515 C0 00 00      cmp b, 0
0200   0518 C6 61 05      je _for3_exit
0201   051B             _for3_block:
0202   051B             ;; dest[dest_len + i] = src[i]; 
0203   051B FA 05 00      lea d, [bp + 5] ; $dest
0204   051E FD 2A         mov d, [d]
0205   0520 D7            push a
0206   0521 DA            push d
0207   0522 FA FF FF      lea d, [bp + -1] ; $dest_len
0208   0525 2A            mov b, [d]
0209   0526             ; START TERMS
0210   0526 D7            push a
0211   0527 11            mov a, b
0212   0528 FA FD FF      lea d, [bp + -3] ; $i
0213   052B 2A            mov b, [d]
0214   052C 56            add b, a
0215   052D E4            pop a
0216   052E             ; END TERMS
0217   052E E7            pop d
0218   052F FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0219   0533 E4            pop a
0220   0534 DA            push d
0221   0535 FA 07 00      lea d, [bp + 7] ; $src
0222   0538 FD 2A         mov d, [d]
0223   053A D7            push a
0224   053B DA            push d
0225   053C FA FD FF      lea d, [bp + -3] ; $i
0226   053F 2A            mov b, [d]
0227   0540 E7            pop d
0228   0541 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0229   0545 E4            pop a
0230   0546 32            mov bl, [d]
0231   0547 A7 00         mov bh, 0
0232   0549 E7            pop d
0233   054A FD 3E         mov [d], bl
0234   054C             _for3_update:
0235   054C FA FD FF      lea d, [bp + -3] ; $i
0236   054F DA            push d
0237   0550 FA FD FF      lea d, [bp + -3] ; $i
0238   0553 2A            mov b, [d]
0239   0554             ; START TERMS
0240   0554 D7            push a
0241   0555 11            mov a, b
0242   0556 26 01 00      mov b, $1
0243   0559 56            add b, a
0244   055A E4            pop a
0245   055B             ; END TERMS
0246   055B E7            pop d
0247   055C FD 43         mov [d], b
0248   055E 0A F8 04      jmp _for3_cond
0249   0561             _for3_exit:
0250   0561             ;; dest[dest_len + i] = 0; 
0251   0561 FA 05 00      lea d, [bp + 5] ; $dest
0252   0564 FD 2A         mov d, [d]
0253   0566 D7            push a
0254   0567 DA            push d
0255   0568 FA FF FF      lea d, [bp + -1] ; $dest_len
0256   056B 2A            mov b, [d]
0257   056C             ; START TERMS
0258   056C D7            push a
0259   056D 11            mov a, b
0260   056E FA FD FF      lea d, [bp + -3] ; $i
0261   0571 2A            mov b, [d]
0262   0572 56            add b, a
0263   0573 E4            pop a
0264   0574             ; END TERMS
0265   0574 E7            pop d
0266   0575 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0267   0579 E4            pop a
0268   057A DA            push d
0269   057B 26 00 00      mov b, $0
0270   057E E7            pop d
0271   057F FD 3E         mov [d], bl
0272   0581             ;; return dest; 
0273   0581 FA 05 00      lea d, [bp + 5] ; $dest
0274   0584 2A            mov b, [d]
0275   0585 F9            leave
0276   0586 09            ret
0277   0587             
0278   0587             strlen:
0279   0587 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0280   058A             ; $length 
0281   058A 52 02 00      sub sp, 2
0282   058D             ;; length = 0; 
0283   058D FA FF FF      lea d, [bp + -1] ; $length
0284   0590 DA            push d
0285   0591 26 00 00      mov b, $0
0286   0594 E7            pop d
0287   0595 FD 43         mov [d], b
0288   0597             ;; while (str[length] != 0) { 
0289   0597             _while4_cond:
0290   0597 FA 05 00      lea d, [bp + 5] ; $str
0291   059A FD 2A         mov d, [d]
0292   059C D7            push a
0293   059D DA            push d
0294   059E FA FF FF      lea d, [bp + -1] ; $length
0295   05A1 2A            mov b, [d]
0296   05A2 E7            pop d
0297   05A3 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0298   05A7 E4            pop a
0299   05A8 32            mov bl, [d]
0300   05A9 A7 00         mov bh, 0
0301   05AB             ; START RELATIONAL
0302   05AB D7            push a
0303   05AC 11            mov a, b
0304   05AD 26 00 00      mov b, $0
0305   05B0 B0            cmp a, b
0306   05B1 FD 72         sneq ; !=
0307   05B3 E4            pop a
0308   05B4             ; END RELATIONAL
0309   05B4 C0 00 00      cmp b, 0
0310   05B7 C6 CA 05      je _while4_exit
0311   05BA             _while4_block:
0312   05BA             ;; length++; 
0313   05BA FA FF FF      lea d, [bp + -1] ; $length
0314   05BD 2A            mov b, [d]
0315   05BE D8            push b
0316   05BF FD 77         inc b
0317   05C1 FA FF FF      lea d, [bp + -1] ; $length
0318   05C4 FD 43         mov [d], b
0319   05C6 E5            pop b
0320   05C7 0A 97 05      jmp _while4_cond
0321   05CA             _while4_exit:
0322   05CA             ;; return length; 
0323   05CA FA FF FF      lea d, [bp + -1] ; $length
0324   05CD 2A            mov b, [d]
0325   05CE F9            leave
0326   05CF 09            ret
0327   05D0             
0328   05D0             printf:
0329   05D0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0330   05D3             ; $p 
0331   05D3             ; $format_p 
0332   05D3 52 04 00      sub sp, 4
0333   05D6             ;; format_p = format; 
0334   05D6 FA FD FF      lea d, [bp + -3] ; $format_p
0335   05D9 DA            push d
0336   05DA FA 05 00      lea d, [bp + 5] ; $format
0337   05DD 2A            mov b, [d]
0338   05DE E7            pop d
0339   05DF FD 43         mov [d], b
0340   05E1             ;; p = &format + 2; 
0341   05E1 FA FF FF      lea d, [bp + -1] ; $p
0342   05E4 DA            push d
0343   05E5 FA 05 00      lea d, [bp + 5] ; $format
0344   05E8 2D            mov b, d
0345   05E9             ; START TERMS
0346   05E9 D7            push a
0347   05EA 11            mov a, b
0348   05EB 26 02 00      mov b, $2
0349   05EE 56            add b, a
0350   05EF E4            pop a
0351   05F0             ; END TERMS
0352   05F0 E7            pop d
0353   05F1 FD 43         mov [d], b
0354   05F3             ;; for(;;){ 
0355   05F3             _for5_init:
0356   05F3             _for5_cond:
0357   05F3             _for5_block:
0358   05F3             ;; if(!*format_p) break; 
0359   05F3             _if6_cond:
0360   05F3 FA FD FF      lea d, [bp + -3] ; $format_p
0361   05F6 2A            mov b, [d]
0362   05F7 74            mov d, b
0363   05F8 32            mov bl, [d]
0364   05F9 A7 00         mov bh, 0
0365   05FB C0 00 00      cmp b, 0
0366   05FE FD 71         seq ; !
0367   0600 C0 00 00      cmp b, 0
0368   0603 C6 0C 06      je _if6_else
0369   0606             _if6_true:
0370   0606             ;; break; 
0371   0606 0A 39 08      jmp _for5_exit ; for break
0372   0609 0A 36 08      jmp _if6_exit
0373   060C             _if6_else:
0374   060C             ;; if(*format_p == '%'){ 
0375   060C             _if7_cond:
0376   060C FA FD FF      lea d, [bp + -3] ; $format_p
0377   060F 2A            mov b, [d]
0378   0610 74            mov d, b
0379   0611 32            mov bl, [d]
0380   0612 A7 00         mov bh, 0
0381   0614             ; START RELATIONAL
0382   0614 D7            push a
0383   0615 11            mov a, b
0384   0616 26 25 00      mov b, $25
0385   0619 B0            cmp a, b
0386   061A FD 71         seq ; ==
0387   061C E4            pop a
0388   061D             ; END RELATIONAL
0389   061D C0 00 00      cmp b, 0
0390   0620 C6 1A 08      je _if7_else
0391   0623             _if7_true:
0392   0623             ;; format_p++; 
0393   0623 FA FD FF      lea d, [bp + -3] ; $format_p
0394   0626 2A            mov b, [d]
0395   0627 D8            push b
0396   0628 FD 77         inc b
0397   062A FA FD FF      lea d, [bp + -3] ; $format_p
0398   062D FD 43         mov [d], b
0399   062F E5            pop b
0400   0630             ;; switch(*format_p){ 
0401   0630             _switch8_expr:
0402   0630 FA FD FF      lea d, [bp + -3] ; $format_p
0403   0633 2A            mov b, [d]
0404   0634 74            mov d, b
0405   0635 32            mov bl, [d]
0406   0636 A7 00         mov bh, 0
0407   0638             _switch8_comparisons:
0408   0638 C1 6C         cmp bl, $6c
0409   063A C6 66 06      je _switch8_case0
0410   063D C1 4C         cmp bl, $4c
0411   063F C6 66 06      je _switch8_case1
0412   0642 C1 64         cmp bl, $64
0413   0644 C6 5A 07      je _switch8_case2
0414   0647 C1 69         cmp bl, $69
0415   0649 C6 5A 07      je _switch8_case3
0416   064C C1 75         cmp bl, $75
0417   064E C6 7E 07      je _switch8_case4
0418   0651 C1 78         cmp bl, $78
0419   0653 C6 A2 07      je _switch8_case5
0420   0656 C1 63         cmp bl, $63
0421   0658 C6 C0 07      je _switch8_case6
0422   065B C1 73         cmp bl, $73
0423   065D C6 DF 07      je _switch8_case7
0424   0660 0A FE 07      jmp _switch8_default
0425   0663 0A 0A 08      jmp _switch8_exit
0426   0666             _switch8_case0:
0427   0666             _switch8_case1:
0428   0666             ;; format_p++; 
0429   0666 FA FD FF      lea d, [bp + -3] ; $format_p
0430   0669 2A            mov b, [d]
0431   066A D8            push b
0432   066B FD 77         inc b
0433   066D FA FD FF      lea d, [bp + -3] ; $format_p
0434   0670 FD 43         mov [d], b
0435   0672 E5            pop b
0436   0673             ;; if(*format_p == 'd' || *format_p == 'i') 
0437   0673             _if9_cond:
0438   0673 FA FD FF      lea d, [bp + -3] ; $format_p
0439   0676 2A            mov b, [d]
0440   0677 74            mov d, b
0441   0678 32            mov bl, [d]
0442   0679 A7 00         mov bh, 0
0443   067B             ; START RELATIONAL
0444   067B D7            push a
0445   067C 11            mov a, b
0446   067D 26 64 00      mov b, $64
0447   0680 B0            cmp a, b
0448   0681 FD 71         seq ; ==
0449   0683 E4            pop a
0450   0684             ; END RELATIONAL
0451   0684 D7            push a
0452   0685 11            mov a, b
0453   0686 FA FD FF      lea d, [bp + -3] ; $format_p
0454   0689 2A            mov b, [d]
0455   068A 74            mov d, b
0456   068B 32            mov bl, [d]
0457   068C A7 00         mov bh, 0
0458   068E             ; START RELATIONAL
0459   068E D7            push a
0460   068F 11            mov a, b
0461   0690 26 69 00      mov b, $69
0462   0693 B0            cmp a, b
0463   0694 FD 71         seq ; ==
0464   0696 E4            pop a
0465   0697             ; END RELATIONAL
0466   0697 FD A8         sor a, b ; ||
0467   0699 E4            pop a
0468   069A C0 00 00      cmp b, 0
0469   069D C6 C4 06      je _if9_else
0470   06A0             _if9_true:
0471   06A0             ;; print_signed_long(*(long *)p); 
0472   06A0 FA FF FF      lea d, [bp + -1] ; $p
0473   06A3 2A            mov b, [d]
0474   06A4 AB            snex b
0475   06A5 FD 39         mov c, b
0476   06A7 74            mov d, b
0477   06A8 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0478   06AB FD 39         mov c, b ; And place it into C
0479   06AD 2A            mov b, [d] ; Lower Word in B
out/test.asm line 0480: Label not found: (b)
out/test.asm line 0480: Unused data in MS byte of argument. (2)
0480   06AE FD 22 00 00   mov g, b
0481   06B2 28            mov b, c
0482   06B3 FD AB         swp b
0483   06B5 D8            push b
0484   06B6 FD 27         mov b, g
0485   06B8 FD AB         swp b
0486   06BA D8            push b
0487   06BB 07 FF 0C      call print_signed_long
0488   06BE 51 04 00      add sp, 4
0489   06C1 0A 45 07      jmp _if9_exit
0490   06C4             _if9_else:
0491   06C4             ;; if(*format_p == 'u') 
0492   06C4             _if10_cond:
0493   06C4 FA FD FF      lea d, [bp + -3] ; $format_p
0494   06C7 2A            mov b, [d]
0495   06C8 74            mov d, b
0496   06C9 32            mov bl, [d]
0497   06CA A7 00         mov bh, 0
0498   06CC             ; START RELATIONAL
0499   06CC D7            push a
0500   06CD 11            mov a, b
0501   06CE 26 75 00      mov b, $75
0502   06D1 B0            cmp a, b
0503   06D2 FD 71         seq ; ==
0504   06D4 E4            pop a
0505   06D5             ; END RELATIONAL
0506   06D5 C0 00 00      cmp b, 0
0507   06D8 C6 01 07      je _if10_else
0508   06DB             _if10_true:
0509   06DB             ;; print_unsigned_long(*(unsigned long *)p); 
0510   06DB FA FF FF      lea d, [bp + -1] ; $p
0511   06DE 2A            mov b, [d]
0512   06DF A7 00         mov bh, 0
0513   06E1 38 00 00      mov c, 0
0514   06E4 74            mov d, b
0515   06E5 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0516   06E8 FD 39         mov c, b ; And place it into C
0517   06EA 2A            mov b, [d] ; Lower Word in B
out/test.asm line 0518: Label not found: (b)
out/test.asm line 0518: Unused data in MS byte of argument. (2)
0518   06EB FD 22 00 00   mov g, b
0519   06EF 28            mov b, c
0520   06F0 FD AB         swp b
0521   06F2 D8            push b
0522   06F3 FD 27         mov b, g
0523   06F5 FD AB         swp b
0524   06F7 D8            push b
0525   06F8 07 3E 10      call print_unsigned_long
0526   06FB 51 04 00      add sp, 4
0527   06FE 0A 45 07      jmp _if10_exit
0528   0701             _if10_else:
0529   0701             ;; if(*format_p == 'x') 
0530   0701             _if11_cond:
0531   0701 FA FD FF      lea d, [bp + -3] ; $format_p
0532   0704 2A            mov b, [d]
0533   0705 74            mov d, b
0534   0706 32            mov bl, [d]
0535   0707 A7 00         mov bh, 0
0536   0709             ; START RELATIONAL
0537   0709 D7            push a
0538   070A 11            mov a, b
0539   070B 26 78 00      mov b, $78
0540   070E B0            cmp a, b
0541   070F FD 71         seq ; ==
0542   0711 E4            pop a
0543   0712             ; END RELATIONAL
0544   0712 C0 00 00      cmp b, 0
0545   0715 C6 39 07      je _if11_else
0546   0718             _if11_true:
0547   0718             ;; printx32(*(long int *)p); 
0548   0718 FA FF FF      lea d, [bp + -1] ; $p
0549   071B 2A            mov b, [d]
0550   071C 74            mov d, b
0551   071D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0552   0720 FD 39         mov c, b ; And place it into C
0553   0722 2A            mov b, [d] ; Lower Word in B
out/test.asm line 0554: Label not found: (b)
out/test.asm line 0554: Unused data in MS byte of argument. (2)
0554   0723 FD 22 00 00   mov g, b
0555   0727 28            mov b, c
0556   0728 FD AB         swp b
0557   072A D8            push b
0558   072B FD 27         mov b, g
0559   072D FD AB         swp b
0560   072F D8            push b
0561   0730 07 88 0A      call printx32
0562   0733 51 04 00      add sp, 4
0563   0736 0A 45 07      jmp _if11_exit
0564   0739             _if11_else:
0565   0739             ;; err("Unexpected format in printf."); 
0566   0739 26 42 17      mov b, __s0 ; "Unexpected format in printf."
0567   073C FD AB         swp b
0568   073E D8            push b
0569   073F 07 76 0A      call err
0570   0742 51 02 00      add sp, 2
0571   0745             _if11_exit:
0572   0745             _if10_exit:
0573   0745             _if9_exit:
0574   0745             ;; p = p + 4; 
0575   0745 FA FF FF      lea d, [bp + -1] ; $p
0576   0748 DA            push d
0577   0749 FA FF FF      lea d, [bp + -1] ; $p
0578   074C 2A            mov b, [d]
0579   074D             ; START TERMS
0580   074D D7            push a
0581   074E 11            mov a, b
0582   074F 26 04 00      mov b, $4
0583   0752 56            add b, a
0584   0753 E4            pop a
0585   0754             ; END TERMS
0586   0754 E7            pop d
0587   0755 FD 43         mov [d], b
0588   0757             ;; break; 
0589   0757 0A 0A 08      jmp _switch8_exit ; case break
0590   075A             _switch8_case2:
0591   075A             _switch8_case3:
0592   075A             ;; print_signed(*(int*)p); 
0593   075A FA FF FF      lea d, [bp + -1] ; $p
0594   075D 2A            mov b, [d]
0595   075E 74            mov d, b
0596   075F 2A            mov b, [d]
0597   0760 FD AB         swp b
0598   0762 D8            push b
0599   0763 07 0F 0C      call print_signed
0600   0766 51 02 00      add sp, 2
0601   0769             ;; p = p + 2; 
0602   0769 FA FF FF      lea d, [bp + -1] ; $p
0603   076C DA            push d
0604   076D FA FF FF      lea d, [bp + -1] ; $p
0605   0770 2A            mov b, [d]
0606   0771             ; START TERMS
0607   0771 D7            push a
0608   0772 11            mov a, b
0609   0773 26 02 00      mov b, $2
0610   0776 56            add b, a
0611   0777 E4            pop a
0612   0778             ; END TERMS
0613   0778 E7            pop d
0614   0779 FD 43         mov [d], b
0615   077B             ;; break; 
0616   077B 0A 0A 08      jmp _switch8_exit ; case break
0617   077E             _switch8_case4:
0618   077E             ;; print_unsigned(*(unsigned int*)p); 
0619   077E FA FF FF      lea d, [bp + -1] ; $p
0620   0781 2A            mov b, [d]
0621   0782 74            mov d, b
0622   0783 2A            mov b, [d]
0623   0784 FD AB         swp b
0624   0786 D8            push b
0625   0787 07 3A 12      call print_unsigned
0626   078A 51 02 00      add sp, 2
0627   078D             ;; p = p + 2; 
0628   078D FA FF FF      lea d, [bp + -1] ; $p
0629   0790 DA            push d
0630   0791 FA FF FF      lea d, [bp + -1] ; $p
0631   0794 2A            mov b, [d]
0632   0795             ; START TERMS
0633   0795 D7            push a
0634   0796 11            mov a, b
0635   0797 26 02 00      mov b, $2
0636   079A 56            add b, a
0637   079B E4            pop a
0638   079C             ; END TERMS
0639   079C E7            pop d
0640   079D FD 43         mov [d], b
0641   079F             ;; break; 
0642   079F 0A 0A 08      jmp _switch8_exit ; case break
0643   07A2             _switch8_case5:
0644   07A2             
0645   07A2             ; --- BEGIN INLINE ASM BLOCK
0646   07A2 FA FF FF      lea d, [bp + -1] ; $p
0647   07A5 FD 2A         mov d, [d]
0648   07A7 2A            mov b, [d]
0649   07A8 07 3D 16      call print_u16x
0650   07AB             ; --- END INLINE ASM BLOCK
0651   07AB             
0652   07AB             ;; p = p + 2; 
0653   07AB FA FF FF      lea d, [bp + -1] ; $p
0654   07AE DA            push d
0655   07AF FA FF FF      lea d, [bp + -1] ; $p
0656   07B2 2A            mov b, [d]
0657   07B3             ; START TERMS
0658   07B3 D7            push a
0659   07B4 11            mov a, b
0660   07B5 26 02 00      mov b, $2
0661   07B8 56            add b, a
0662   07B9 E4            pop a
0663   07BA             ; END TERMS
0664   07BA E7            pop d
0665   07BB FD 43         mov [d], b
0666   07BD             ;; break; 
0667   07BD 0A 0A 08      jmp _switch8_exit ; case break
0668   07C0             _switch8_case6:
0669   07C0             
0670   07C0             ; --- BEGIN INLINE ASM BLOCK
0671   07C0 FA FF FF      lea d, [bp + -1] ; $p
0672   07C3 FD 2A         mov d, [d]
0673   07C5 1E            mov al, [d]
0674   07C6 23            mov ah, al
0675   07C7 07 9B 14      call _putchar
0676   07CA             ; --- END INLINE ASM BLOCK
0677   07CA             
0678   07CA             ;; p = p + 2; 
0679   07CA FA FF FF      lea d, [bp + -1] ; $p
0680   07CD DA            push d
0681   07CE FA FF FF      lea d, [bp + -1] ; $p
0682   07D1 2A            mov b, [d]
0683   07D2             ; START TERMS
0684   07D2 D7            push a
0685   07D3 11            mov a, b
0686   07D4 26 02 00      mov b, $2
0687   07D7 56            add b, a
0688   07D8 E4            pop a
0689   07D9             ; END TERMS
0690   07D9 E7            pop d
0691   07DA FD 43         mov [d], b
0692   07DC             ;; break; 
0693   07DC 0A 0A 08      jmp _switch8_exit ; case break
0694   07DF             _switch8_case7:
0695   07DF             
0696   07DF             ; --- BEGIN INLINE ASM BLOCK
0697   07DF FA FF FF      lea d, [bp + -1] ; $p
0698   07E2 FD 2A         mov d, [d]
0699   07E4 FD 2A         mov d, [d]
0700   07E6 07 E5 15      call _puts
0701   07E9             ; --- END INLINE ASM BLOCK
0702   07E9             
0703   07E9             ;; p = p + 2; 
0704   07E9 FA FF FF      lea d, [bp + -1] ; $p
0705   07EC DA            push d
0706   07ED FA FF FF      lea d, [bp + -1] ; $p
0707   07F0 2A            mov b, [d]
0708   07F1             ; START TERMS
0709   07F1 D7            push a
0710   07F2 11            mov a, b
0711   07F3 26 02 00      mov b, $2
0712   07F6 56            add b, a
0713   07F7 E4            pop a
0714   07F8             ; END TERMS
0715   07F8 E7            pop d
0716   07F9 FD 43         mov [d], b
0717   07FB             ;; break; 
0718   07FB 0A 0A 08      jmp _switch8_exit ; case break
0719   07FE             _switch8_default:
0720   07FE             ;; print("Error: Unknown argument type.\n"); 
0721   07FE 26 5F 17      mov b, __s1 ; "Error: Unknown argument type.\n"
0722   0801 FD AB         swp b
0723   0803 D8            push b
0724   0804 07 52 13      call print
0725   0807 51 02 00      add sp, 2
0726   080A             _switch8_exit:
0727   080A             ;; format_p++; 
0728   080A FA FD FF      lea d, [bp + -3] ; $format_p
0729   080D 2A            mov b, [d]
0730   080E D8            push b
0731   080F FD 77         inc b
0732   0811 FA FD FF      lea d, [bp + -3] ; $format_p
0733   0814 FD 43         mov [d], b
0734   0816 E5            pop b
0735   0817 0A 36 08      jmp _if7_exit
0736   081A             _if7_else:
0737   081A             ;; putchar(*format_p); 
0738   081A FA FD FF      lea d, [bp + -3] ; $format_p
0739   081D 2A            mov b, [d]
0740   081E 74            mov d, b
0741   081F 32            mov bl, [d]
0742   0820 A7 00         mov bh, 0
0743   0822 DD            push bl
0744   0823 07 0A 13      call putchar
0745   0826 51 01 00      add sp, 1
0746   0829             ;; format_p++; 
0747   0829 FA FD FF      lea d, [bp + -3] ; $format_p
0748   082C 2A            mov b, [d]
0749   082D D8            push b
0750   082E FD 77         inc b
0751   0830 FA FD FF      lea d, [bp + -3] ; $format_p
0752   0833 FD 43         mov [d], b
0753   0835 E5            pop b
0754   0836             _if7_exit:
0755   0836             _if6_exit:
0756   0836             _for5_update:
0757   0836 0A F3 05      jmp _for5_cond
0758   0839             _for5_exit:
0759   0839 F9            leave
0760   083A 09            ret
0761   083B             
0762   083B             scanf:
0763   083B F8 00 00      enter 0 ; (push bp; mov bp, sp)
0764   083E             ; $p 
0765   083E             ; $format_p 
0766   083E             ; $c 
0767   083E             ; $i 
0768   083E             ; $input_string 
0769   083E 52 07 02      sub sp, 519
0770   0841             ;; format_p = format; 
0771   0841 FA FD FF      lea d, [bp + -3] ; $format_p
0772   0844 DA            push d
0773   0845 FA 05 00      lea d, [bp + 5] ; $format
0774   0848 2A            mov b, [d]
0775   0849 E7            pop d
0776   084A FD 43         mov [d], b
0777   084C             ;; p = &format + 2; 
0778   084C FA FF FF      lea d, [bp + -1] ; $p
0779   084F DA            push d
0780   0850 FA 05 00      lea d, [bp + 5] ; $format
0781   0853 2D            mov b, d
0782   0854             ; START TERMS
0783   0854 D7            push a
0784   0855 11            mov a, b
0785   0856 26 02 00      mov b, $2
0786   0859 56            add b, a
0787   085A E4            pop a
0788   085B             ; END TERMS
0789   085B E7            pop d
0790   085C FD 43         mov [d], b
0791   085E             ;; for(;;){ 
0792   085E             _for12_init:
0793   085E             _for12_cond:
0794   085E             _for12_block:
0795   085E             ;; if(!*format_p) break; 
0796   085E             _if13_cond:
0797   085E FA FD FF      lea d, [bp + -3] ; $format_p
0798   0861 2A            mov b, [d]
0799   0862 74            mov d, b
0800   0863 32            mov bl, [d]
0801   0864 A7 00         mov bh, 0
0802   0866 C0 00 00      cmp b, 0
0803   0869 FD 71         seq ; !
0804   086B C0 00 00      cmp b, 0
0805   086E C6 77 08      je _if13_else
0806   0871             _if13_true:
0807   0871             ;; break; 
0808   0871 0A 74 0A      jmp _for12_exit ; for break
0809   0874 0A 71 0A      jmp _if13_exit
0810   0877             _if13_else:
0811   0877             ;; if(*format_p == '%'){ 
0812   0877             _if14_cond:
0813   0877 FA FD FF      lea d, [bp + -3] ; $format_p
0814   087A 2A            mov b, [d]
0815   087B 74            mov d, b
0816   087C 32            mov bl, [d]
0817   087D A7 00         mov bh, 0
0818   087F             ; START RELATIONAL
0819   087F D7            push a
0820   0880 11            mov a, b
0821   0881 26 25 00      mov b, $25
0822   0884 B0            cmp a, b
0823   0885 FD 71         seq ; ==
0824   0887 E4            pop a
0825   0888             ; END RELATIONAL
0826   0888 C0 00 00      cmp b, 0
0827   088B C6 55 0A      je _if14_else
0828   088E             _if14_true:
0829   088E             ;; format_p++; 
0830   088E FA FD FF      lea d, [bp + -3] ; $format_p
0831   0891 2A            mov b, [d]
0832   0892 D8            push b
0833   0893 FD 77         inc b
0834   0895 FA FD FF      lea d, [bp + -3] ; $format_p
0835   0898 FD 43         mov [d], b
0836   089A E5            pop b
0837   089B             ;; switch(*format_p){ 
0838   089B             _switch15_expr:
0839   089B FA FD FF      lea d, [bp + -3] ; $format_p
0840   089E 2A            mov b, [d]
0841   089F 74            mov d, b
0842   08A0 32            mov bl, [d]
0843   08A1 A7 00         mov bh, 0
0844   08A3             _switch15_comparisons:
0845   08A3 C1 6C         cmp bl, $6c
0846   08A5 C6 D1 08      je _switch15_case0
0847   08A8 C1 4C         cmp bl, $4c
0848   08AA C6 D1 08      je _switch15_case1
0849   08AD C1 64         cmp bl, $64
0850   08AF C6 63 09      je _switch15_case2
0851   08B2 C1 69         cmp bl, $69
0852   08B4 C6 63 09      je _switch15_case3
0853   08B7 C1 75         cmp bl, $75
0854   08B9 C6 90 09      je _switch15_case4
0855   08BC C1 78         cmp bl, $78
0856   08BE C6 BD 09      je _switch15_case5
0857   08C1 C1 63         cmp bl, $63
0858   08C3 C6 D2 09      je _switch15_case6
0859   08C6 C1 73         cmp bl, $73
0860   08C8 C6 01 0A      je _switch15_case7
0861   08CB 0A 39 0A      jmp _switch15_default
0862   08CE 0A 45 0A      jmp _switch15_exit
0863   08D1             _switch15_case0:
0864   08D1             _switch15_case1:
0865   08D1             ;; format_p++; 
0866   08D1 FA FD FF      lea d, [bp + -3] ; $format_p
0867   08D4 2A            mov b, [d]
0868   08D5 D8            push b
0869   08D6 FD 77         inc b
0870   08D8 FA FD FF      lea d, [bp + -3] ; $format_p
0871   08DB FD 43         mov [d], b
0872   08DD E5            pop b
0873   08DE             ;; if(*format_p == 'd' || *format_p == 'i'); 
0874   08DE             _if16_cond:
0875   08DE FA FD FF      lea d, [bp + -3] ; $format_p
0876   08E1 2A            mov b, [d]
0877   08E2 74            mov d, b
0878   08E3 32            mov bl, [d]
0879   08E4 A7 00         mov bh, 0
0880   08E6             ; START RELATIONAL
0881   08E6 D7            push a
0882   08E7 11            mov a, b
0883   08E8 26 64 00      mov b, $64
0884   08EB B0            cmp a, b
0885   08EC FD 71         seq ; ==
0886   08EE E4            pop a
0887   08EF             ; END RELATIONAL
0888   08EF D7            push a
0889   08F0 11            mov a, b
0890   08F1 FA FD FF      lea d, [bp + -3] ; $format_p
0891   08F4 2A            mov b, [d]
0892   08F5 74            mov d, b
0893   08F6 32            mov bl, [d]
0894   08F7 A7 00         mov bh, 0
0895   08F9             ; START RELATIONAL
0896   08F9 D7            push a
0897   08FA 11            mov a, b
0898   08FB 26 69 00      mov b, $69
0899   08FE B0            cmp a, b
0900   08FF FD 71         seq ; ==
0901   0901 E4            pop a
0902   0902             ; END RELATIONAL
0903   0902 FD A8         sor a, b ; ||
0904   0904 E4            pop a
0905   0905 C0 00 00      cmp b, 0
0906   0908 C6 0E 09      je _if16_else
0907   090B             _if16_true:
0908   090B             ;; ; 
0909   090B 0A 4E 09      jmp _if16_exit
0910   090E             _if16_else:
0911   090E             ;; if(*format_p == 'u'); 
0912   090E             _if17_cond:
0913   090E FA FD FF      lea d, [bp + -3] ; $format_p
0914   0911 2A            mov b, [d]
0915   0912 74            mov d, b
0916   0913 32            mov bl, [d]
0917   0914 A7 00         mov bh, 0
0918   0916             ; START RELATIONAL
0919   0916 D7            push a
0920   0917 11            mov a, b
0921   0918 26 75 00      mov b, $75
0922   091B B0            cmp a, b
0923   091C FD 71         seq ; ==
0924   091E E4            pop a
0925   091F             ; END RELATIONAL
0926   091F C0 00 00      cmp b, 0
0927   0922 C6 28 09      je _if17_else
0928   0925             _if17_true:
0929   0925             ;; ; 
0930   0925 0A 4E 09      jmp _if17_exit
0931   0928             _if17_else:
0932   0928             ;; if(*format_p == 'x'); 
0933   0928             _if18_cond:
0934   0928 FA FD FF      lea d, [bp + -3] ; $format_p
0935   092B 2A            mov b, [d]
0936   092C 74            mov d, b
0937   092D 32            mov bl, [d]
0938   092E A7 00         mov bh, 0
0939   0930             ; START RELATIONAL
0940   0930 D7            push a
0941   0931 11            mov a, b
0942   0932 26 78 00      mov b, $78
0943   0935 B0            cmp a, b
0944   0936 FD 71         seq ; ==
0945   0938 E4            pop a
0946   0939             ; END RELATIONAL
0947   0939 C0 00 00      cmp b, 0
0948   093C C6 42 09      je _if18_else
0949   093F             _if18_true:
0950   093F             ;; ; 
0951   093F 0A 4E 09      jmp _if18_exit
0952   0942             _if18_else:
0953   0942             ;; err("Unexpected format in printf."); 
0954   0942 26 42 17      mov b, __s0 ; "Unexpected format in printf."
0955   0945 FD AB         swp b
0956   0947 D8            push b
0957   0948 07 76 0A      call err
0958   094B 51 02 00      add sp, 2
0959   094E             _if18_exit:
0960   094E             _if17_exit:
0961   094E             _if16_exit:
0962   094E             ;; p = p + 4; 
0963   094E FA FF FF      lea d, [bp + -1] ; $p
0964   0951 DA            push d
0965   0952 FA FF FF      lea d, [bp + -1] ; $p
0966   0955 2A            mov b, [d]
0967   0956             ; START TERMS
0968   0956 D7            push a
0969   0957 11            mov a, b
0970   0958 26 04 00      mov b, $4
0971   095B 56            add b, a
0972   095C E4            pop a
0973   095D             ; END TERMS
0974   095D E7            pop d
0975   095E FD 43         mov [d], b
0976   0960             ;; break; 
0977   0960 0A 45 0A      jmp _switch15_exit ; case break
0978   0963             _switch15_case2:
0979   0963             _switch15_case3:
0980   0963             ;; i = scann(); 
0981   0963 FA FA FF      lea d, [bp + -6] ; $i
0982   0966 DA            push d
0983   0967 07 2D 13      call scann
0984   096A E7            pop d
0985   096B FD 43         mov [d], b
0986   096D             ;; **(int **)p = i; 
0987   096D FA FF FF      lea d, [bp + -1] ; $p
0988   0970 2A            mov b, [d]
0989   0971 74            mov d, b
0990   0972 2A            mov b, [d]
0991   0973 D8            push b
0992   0974 FA FA FF      lea d, [bp + -6] ; $i
0993   0977 2A            mov b, [d]
0994   0978 E7            pop d
0995   0979 FD 43         mov [d], b
0996   097B             ;; p = p + 2; 
0997   097B FA FF FF      lea d, [bp + -1] ; $p
0998   097E DA            push d
0999   097F FA FF FF      lea d, [bp + -1] ; $p
1000   0982 2A            mov b, [d]
1001   0983             ; START TERMS
1002   0983 D7            push a
1003   0984 11            mov a, b
1004   0985 26 02 00      mov b, $2
1005   0988 56            add b, a
1006   0989 E4            pop a
1007   098A             ; END TERMS
1008   098A E7            pop d
1009   098B FD 43         mov [d], b
1010   098D             ;; break; 
1011   098D 0A 45 0A      jmp _switch15_exit ; case break
1012   0990             _switch15_case4:
1013   0990             ;; i = scann(); 
1014   0990 FA FA FF      lea d, [bp + -6] ; $i
1015   0993 DA            push d
1016   0994 07 2D 13      call scann
1017   0997 E7            pop d
1018   0998 FD 43         mov [d], b
1019   099A             ;; **(int **)p = i; 
1020   099A FA FF FF      lea d, [bp + -1] ; $p
1021   099D 2A            mov b, [d]
1022   099E 74            mov d, b
1023   099F 2A            mov b, [d]
1024   09A0 D8            push b
1025   09A1 FA FA FF      lea d, [bp + -6] ; $i
1026   09A4 2A            mov b, [d]
1027   09A5 E7            pop d
1028   09A6 FD 43         mov [d], b
1029   09A8             ;; p = p + 2; 
1030   09A8 FA FF FF      lea d, [bp + -1] ; $p
1031   09AB DA            push d
1032   09AC FA FF FF      lea d, [bp + -1] ; $p
1033   09AF 2A            mov b, [d]
1034   09B0             ; START TERMS
1035   09B0 D7            push a
1036   09B1 11            mov a, b
1037   09B2 26 02 00      mov b, $2
1038   09B5 56            add b, a
1039   09B6 E4            pop a
1040   09B7             ; END TERMS
1041   09B7 E7            pop d
1042   09B8 FD 43         mov [d], b
1043   09BA             ;; break; 
1044   09BA 0A 45 0A      jmp _switch15_exit ; case break
1045   09BD             _switch15_case5:
1046   09BD             ;; p = p + 2; 
1047   09BD FA FF FF      lea d, [bp + -1] ; $p
1048   09C0 DA            push d
1049   09C1 FA FF FF      lea d, [bp + -1] ; $p
1050   09C4 2A            mov b, [d]
1051   09C5             ; START TERMS
1052   09C5 D7            push a
1053   09C6 11            mov a, b
1054   09C7 26 02 00      mov b, $2
1055   09CA 56            add b, a
1056   09CB E4            pop a
1057   09CC             ; END TERMS
1058   09CC E7            pop d
1059   09CD FD 43         mov [d], b
1060   09CF             ;; break; 
1061   09CF 0A 45 0A      jmp _switch15_exit ; case break
1062   09D2             _switch15_case6:
1063   09D2             ;; c = getchar(); 
1064   09D2 FA FC FF      lea d, [bp + -4] ; $c
1065   09D5 DA            push d
1066   09D6 07 17 13      call getchar
1067   09D9 E7            pop d
1068   09DA FD 3E         mov [d], bl
1069   09DC             ;; **(char **)p = c; 
1070   09DC FA FF FF      lea d, [bp + -1] ; $p
1071   09DF 2A            mov b, [d]
1072   09E0 74            mov d, b
1073   09E1 2A            mov b, [d]
1074   09E2 D8            push b
1075   09E3 FA FC FF      lea d, [bp + -4] ; $c
1076   09E6 32            mov bl, [d]
1077   09E7 A7 00         mov bh, 0
1078   09E9 E7            pop d
1079   09EA FD 43         mov [d], b
1080   09EC             ;; p = p + 2; 
1081   09EC FA FF FF      lea d, [bp + -1] ; $p
1082   09EF DA            push d
1083   09F0 FA FF FF      lea d, [bp + -1] ; $p
1084   09F3 2A            mov b, [d]
1085   09F4             ; START TERMS
1086   09F4 D7            push a
1087   09F5 11            mov a, b
1088   09F6 26 02 00      mov b, $2
1089   09F9 56            add b, a
1090   09FA E4            pop a
1091   09FB             ; END TERMS
1092   09FB E7            pop d
1093   09FC FD 43         mov [d], b
1094   09FE             ;; break; 
1095   09FE 0A 45 0A      jmp _switch15_exit ; case break
1096   0A01             _switch15_case7:
1097   0A01             ;; gets(input_string); 
1098   0A01 FA FA FD      lea d, [bp + -518] ; $input_string
1099   0A04 2D            mov b, d
1100   0A05 FD AB         swp b
1101   0A07 D8            push b
1102   0A08 07 F5 0B      call gets
1103   0A0B 51 02 00      add sp, 2
1104   0A0E             ;; strcpy(*(char **)p, input_string); 
1105   0A0E FA FA FD      lea d, [bp + -518] ; $input_string
1106   0A11 2D            mov b, d
1107   0A12 FD AB         swp b
1108   0A14 D8            push b
1109   0A15 FA FF FF      lea d, [bp + -1] ; $p
1110   0A18 2A            mov b, [d]
1111   0A19 74            mov d, b
1112   0A1A 2A            mov b, [d]
1113   0A1B FD AB         swp b
1114   0A1D D8            push b
1115   0A1E 07 13 04      call strcpy
1116   0A21 51 04 00      add sp, 4
1117   0A24             ;; p = p + 2; 
1118   0A24 FA FF FF      lea d, [bp + -1] ; $p
1119   0A27 DA            push d
1120   0A28 FA FF FF      lea d, [bp + -1] ; $p
1121   0A2B 2A            mov b, [d]
1122   0A2C             ; START TERMS
1123   0A2C D7            push a
1124   0A2D 11            mov a, b
1125   0A2E 26 02 00      mov b, $2
1126   0A31 56            add b, a
1127   0A32 E4            pop a
1128   0A33             ; END TERMS
1129   0A33 E7            pop d
1130   0A34 FD 43         mov [d], b
1131   0A36             ;; break; 
1132   0A36 0A 45 0A      jmp _switch15_exit ; case break
1133   0A39             _switch15_default:
1134   0A39             ;; print("Error: Unknown argument type.\n"); 
1135   0A39 26 5F 17      mov b, __s1 ; "Error: Unknown argument type.\n"
1136   0A3C FD AB         swp b
1137   0A3E D8            push b
1138   0A3F 07 52 13      call print
1139   0A42 51 02 00      add sp, 2
1140   0A45             _switch15_exit:
1141   0A45             ;; format_p++; 
1142   0A45 FA FD FF      lea d, [bp + -3] ; $format_p
1143   0A48 2A            mov b, [d]
1144   0A49 D8            push b
1145   0A4A FD 77         inc b
1146   0A4C FA FD FF      lea d, [bp + -3] ; $format_p
1147   0A4F FD 43         mov [d], b
1148   0A51 E5            pop b
1149   0A52 0A 71 0A      jmp _if14_exit
1150   0A55             _if14_else:
1151   0A55             ;; putchar(*format_p); 
1152   0A55 FA FD FF      lea d, [bp + -3] ; $format_p
1153   0A58 2A            mov b, [d]
1154   0A59 74            mov d, b
1155   0A5A 32            mov bl, [d]
1156   0A5B A7 00         mov bh, 0
1157   0A5D DD            push bl
1158   0A5E 07 0A 13      call putchar
1159   0A61 51 01 00      add sp, 1
1160   0A64             ;; format_p++; 
1161   0A64 FA FD FF      lea d, [bp + -3] ; $format_p
1162   0A67 2A            mov b, [d]
1163   0A68 D8            push b
1164   0A69 FD 77         inc b
1165   0A6B FA FD FF      lea d, [bp + -3] ; $format_p
1166   0A6E FD 43         mov [d], b
1167   0A70 E5            pop b
1168   0A71             _if14_exit:
1169   0A71             _if13_exit:
1170   0A71             _for12_update:
1171   0A71 0A 5E 08      jmp _for12_cond
1172   0A74             _for12_exit:
1173   0A74 F9            leave
1174   0A75 09            ret
1175   0A76             
1176   0A76             err:
1177   0A76 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1178   0A79             ;; print(e); 
1179   0A79 FA 05 00      lea d, [bp + 5] ; $e
1180   0A7C 2A            mov b, [d]
1181   0A7D FD AB         swp b
1182   0A7F D8            push b
1183   0A80 07 52 13      call print
1184   0A83 51 02 00      add sp, 2
1185   0A86 F9            leave
1186   0A87 09            ret
1187   0A88             
1188   0A88             printx32:
1189   0A88 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1190   0A8B             
1191   0A8B             ; --- BEGIN INLINE ASM BLOCK
1192   0A8B FA 05 00      lea d, [bp + 5] ; $hex
1193   0A8E 2B 02 00      mov b, [d+2]
1194   0A91 07 3D 16      call print_u16x
1195   0A94 2A            mov b, [d]
1196   0A95 07 3D 16      call print_u16x
1197   0A98             ; --- END INLINE ASM BLOCK
1198   0A98             
1199   0A98 F9            leave
1200   0A99 09            ret
1201   0A9A             
1202   0A9A             printx16:
1203   0A9A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1204   0A9D             
1205   0A9D             ; --- BEGIN INLINE ASM BLOCK
1206   0A9D FA 05 00      lea d, [bp + 5] ; $hex
1207   0AA0 2A            mov b, [d]
1208   0AA1 07 3D 16      call print_u16x
1209   0AA4             ; --- END INLINE ASM BLOCK
1210   0AA4             
1211   0AA4 F9            leave
1212   0AA5 09            ret
1213   0AA6             
1214   0AA6             printx8:
1215   0AA6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1216   0AA9             
1217   0AA9             ; --- BEGIN INLINE ASM BLOCK
1218   0AA9 FA 05 00      lea d, [bp + 5] ; $hex
1219   0AAC 32            mov bl, [d]
1220   0AAD 07 81 16      call print_u8x
1221   0AB0             ; --- END INLINE ASM BLOCK
1222   0AB0             
1223   0AB0 F9            leave
1224   0AB1 09            ret
1225   0AB2             
1226   0AB2             hex_str_to_int:
1227   0AB2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1228   0AB5             ; $value 
1229   0AB5 10 00 00      mov a, $0
1230   0AB8 45 FF FF      mov [bp + -1], a
1231   0ABB             ; $i 
1232   0ABB             ; $hex_char 
1233   0ABB             ; $len 
1234   0ABB 52 07 00      sub sp, 7
1235   0ABE             ;; len = strlen(hex_string); 
1236   0ABE FA FA FF      lea d, [bp + -6] ; $len
1237   0AC1 DA            push d
1238   0AC2 FA 05 00      lea d, [bp + 5] ; $hex_string
1239   0AC5 2A            mov b, [d]
1240   0AC6 FD AB         swp b
1241   0AC8 D8            push b
1242   0AC9 07 87 05      call strlen
1243   0ACC 51 02 00      add sp, 2
1244   0ACF E7            pop d
1245   0AD0 FD 43         mov [d], b
1246   0AD2             ;; for (i = 0; i < len; i++) { 
1247   0AD2             _for19_init:
1248   0AD2 FA FD FF      lea d, [bp + -3] ; $i
1249   0AD5 DA            push d
1250   0AD6 26 00 00      mov b, $0
1251   0AD9 E7            pop d
1252   0ADA FD 43         mov [d], b
1253   0ADC             _for19_cond:
1254   0ADC FA FD FF      lea d, [bp + -3] ; $i
1255   0ADF 2A            mov b, [d]
1256   0AE0             ; START RELATIONAL
1257   0AE0 D7            push a
1258   0AE1 11            mov a, b
1259   0AE2 FA FA FF      lea d, [bp + -6] ; $len
1260   0AE5 2A            mov b, [d]
1261   0AE6 B0            cmp a, b
1262   0AE7 FD 73         slt ; < (signed)
1263   0AE9 E4            pop a
1264   0AEA             ; END RELATIONAL
1265   0AEA C0 00 00      cmp b, 0
1266   0AED C6 EF 0B      je _for19_exit
1267   0AF0             _for19_block:
1268   0AF0             ;; hex_char = hex_string[i]; 
1269   0AF0 FA FC FF      lea d, [bp + -4] ; $hex_char
1270   0AF3 DA            push d
1271   0AF4 FA 05 00      lea d, [bp + 5] ; $hex_string
1272   0AF7 FD 2A         mov d, [d]
1273   0AF9 D7            push a
1274   0AFA DA            push d
1275   0AFB FA FD FF      lea d, [bp + -3] ; $i
1276   0AFE 2A            mov b, [d]
1277   0AFF E7            pop d
1278   0B00 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
1279   0B04 E4            pop a
1280   0B05 32            mov bl, [d]
1281   0B06 A7 00         mov bh, 0
1282   0B08 E7            pop d
1283   0B09 FD 3E         mov [d], bl
1284   0B0B             ;; if (hex_char >= 'a' && hex_char <= 'f')  
1285   0B0B             _if20_cond:
1286   0B0B FA FC FF      lea d, [bp + -4] ; $hex_char
1287   0B0E 32            mov bl, [d]
1288   0B0F A7 00         mov bh, 0
1289   0B11             ; START RELATIONAL
1290   0B11 D7            push a
1291   0B12 11            mov a, b
1292   0B13 26 61 00      mov b, $61
1293   0B16 B0            cmp a, b
1294   0B17 FD 80         sge ; >=
1295   0B19 E4            pop a
1296   0B1A             ; END RELATIONAL
1297   0B1A D7            push a
1298   0B1B 11            mov a, b
1299   0B1C FA FC FF      lea d, [bp + -4] ; $hex_char
1300   0B1F 32            mov bl, [d]
1301   0B20 A7 00         mov bh, 0
1302   0B22             ; START RELATIONAL
1303   0B22 D7            push a
1304   0B23 11            mov a, b
1305   0B24 26 66 00      mov b, $66
1306   0B27 B0            cmp a, b
1307   0B28 FD 73         slt ; <= (signed)
1308   0B2A E4            pop a
1309   0B2B             ; END RELATIONAL
1310   0B2B FD A7         sand a, b
1311   0B2D E4            pop a
1312   0B2E C0 00 00      cmp b, 0
1313   0B31 C6 62 0B      je _if20_else
1314   0B34             _if20_true:
1315   0B34             ;; value = (value * 16) + (hex_char - 'a' + 10); 
1316   0B34 FA FF FF      lea d, [bp + -1] ; $value
1317   0B37 DA            push d
1318   0B38 FA FF FF      lea d, [bp + -1] ; $value
1319   0B3B 2A            mov b, [d]
1320   0B3C             ; START FACTORS
1321   0B3C D7            push a
1322   0B3D 11            mov a, b
1323   0B3E 26 10 00      mov b, $10
1324   0B41 AC            mul a, b ; *
1325   0B42 11            mov a, b
1326   0B43 27            mov b, a
1327   0B44 E4            pop a
1328   0B45             ; END FACTORS
1329   0B45             ; START TERMS
1330   0B45 D7            push a
1331   0B46 11            mov a, b
1332   0B47 FA FC FF      lea d, [bp + -4] ; $hex_char
1333   0B4A 32            mov bl, [d]
1334   0B4B A7 00         mov bh, 0
1335   0B4D             ; START TERMS
1336   0B4D D7            push a
1337   0B4E 11            mov a, b
1338   0B4F 26 61 00      mov b, $61
1339   0B52 60            sub a, b
1340   0B53 27            mov b, a
1341   0B54 11            mov a, b
1342   0B55 26 0A 00      mov b, $a
1343   0B58 56            add b, a
1344   0B59 E4            pop a
1345   0B5A             ; END TERMS
1346   0B5A 56            add b, a
1347   0B5B E4            pop a
1348   0B5C             ; END TERMS
1349   0B5C E7            pop d
1350   0B5D FD 43         mov [d], b
1351   0B5F 0A DF 0B      jmp _if20_exit
1352   0B62             _if20_else:
1353   0B62             ;; if (hex_char >= 'A' && hex_char <= 'F')  
1354   0B62             _if21_cond:
1355   0B62 FA FC FF      lea d, [bp + -4] ; $hex_char
1356   0B65 32            mov bl, [d]
1357   0B66 A7 00         mov bh, 0
1358   0B68             ; START RELATIONAL
1359   0B68 D7            push a
1360   0B69 11            mov a, b
1361   0B6A 26 41 00      mov b, $41
1362   0B6D B0            cmp a, b
1363   0B6E FD 80         sge ; >=
1364   0B70 E4            pop a
1365   0B71             ; END RELATIONAL
1366   0B71 D7            push a
1367   0B72 11            mov a, b
1368   0B73 FA FC FF      lea d, [bp + -4] ; $hex_char
1369   0B76 32            mov bl, [d]
1370   0B77 A7 00         mov bh, 0
1371   0B79             ; START RELATIONAL
1372   0B79 D7            push a
1373   0B7A 11            mov a, b
1374   0B7B 26 46 00      mov b, $46
1375   0B7E B0            cmp a, b
1376   0B7F FD 73         slt ; <= (signed)
1377   0B81 E4            pop a
1378   0B82             ; END RELATIONAL
1379   0B82 FD A7         sand a, b
1380   0B84 E4            pop a
1381   0B85 C0 00 00      cmp b, 0
1382   0B88 C6 B9 0B      je _if21_else
1383   0B8B             _if21_true:
1384   0B8B             ;; value = (value * 16) + (hex_char - 'A' + 10); 
1385   0B8B FA FF FF      lea d, [bp + -1] ; $value
1386   0B8E DA            push d
1387   0B8F FA FF FF      lea d, [bp + -1] ; $value
1388   0B92 2A            mov b, [d]
1389   0B93             ; START FACTORS
1390   0B93 D7            push a
1391   0B94 11            mov a, b
1392   0B95 26 10 00      mov b, $10
1393   0B98 AC            mul a, b ; *
1394   0B99 11            mov a, b
1395   0B9A 27            mov b, a
1396   0B9B E4            pop a
1397   0B9C             ; END FACTORS
1398   0B9C             ; START TERMS
1399   0B9C D7            push a
1400   0B9D 11            mov a, b
1401   0B9E FA FC FF      lea d, [bp + -4] ; $hex_char
1402   0BA1 32            mov bl, [d]
1403   0BA2 A7 00         mov bh, 0
1404   0BA4             ; START TERMS
1405   0BA4 D7            push a
1406   0BA5 11            mov a, b
1407   0BA6 26 41 00      mov b, $41
1408   0BA9 60            sub a, b
1409   0BAA 27            mov b, a
1410   0BAB 11            mov a, b
1411   0BAC 26 0A 00      mov b, $a
1412   0BAF 56            add b, a
1413   0BB0 E4            pop a
1414   0BB1             ; END TERMS
1415   0BB1 56            add b, a
1416   0BB2 E4            pop a
1417   0BB3             ; END TERMS
1418   0BB3 E7            pop d
1419   0BB4 FD 43         mov [d], b
1420   0BB6 0A DF 0B      jmp _if21_exit
1421   0BB9             _if21_else:
1422   0BB9             ;; value = (value * 16) + (hex_char - '0'); 
1423   0BB9 FA FF FF      lea d, [bp + -1] ; $value
1424   0BBC DA            push d
1425   0BBD FA FF FF      lea d, [bp + -1] ; $value
1426   0BC0 2A            mov b, [d]
1427   0BC1             ; START FACTORS
1428   0BC1 D7            push a
1429   0BC2 11            mov a, b
1430   0BC3 26 10 00      mov b, $10
1431   0BC6 AC            mul a, b ; *
1432   0BC7 11            mov a, b
1433   0BC8 27            mov b, a
1434   0BC9 E4            pop a
1435   0BCA             ; END FACTORS
1436   0BCA             ; START TERMS
1437   0BCA D7            push a
1438   0BCB 11            mov a, b
1439   0BCC FA FC FF      lea d, [bp + -4] ; $hex_char
1440   0BCF 32            mov bl, [d]
1441   0BD0 A7 00         mov bh, 0
1442   0BD2             ; START TERMS
1443   0BD2 D7            push a
1444   0BD3 11            mov a, b
1445   0BD4 26 30 00      mov b, $30
1446   0BD7 60            sub a, b
1447   0BD8 27            mov b, a
1448   0BD9 E4            pop a
1449   0BDA             ; END TERMS
1450   0BDA 56            add b, a
1451   0BDB E4            pop a
1452   0BDC             ; END TERMS
1453   0BDC E7            pop d
1454   0BDD FD 43         mov [d], b
1455   0BDF             _if21_exit:
1456   0BDF             _if20_exit:
1457   0BDF             _for19_update:
1458   0BDF FA FD FF      lea d, [bp + -3] ; $i
1459   0BE2 2A            mov b, [d]
1460   0BE3 D8            push b
1461   0BE4 FD 77         inc b
1462   0BE6 FA FD FF      lea d, [bp + -3] ; $i
1463   0BE9 FD 43         mov [d], b
1464   0BEB E5            pop b
1465   0BEC 0A DC 0A      jmp _for19_cond
1466   0BEF             _for19_exit:
1467   0BEF             ;; return value; 
1468   0BEF FA FF FF      lea d, [bp + -1] ; $value
1469   0BF2 2A            mov b, [d]
1470   0BF3 F9            leave
1471   0BF4 09            ret
1472   0BF5             
1473   0BF5             gets:
1474   0BF5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1475   0BF8             
1476   0BF8             ; --- BEGIN INLINE ASM BLOCK
1477   0BF8 FA 05 00      lea d, [bp + 5] ; $s
1478   0BFB 15            mov a, [d]
1479   0BFC 3C            mov d, a
1480   0BFD 07 A2 14      call _gets
1481   0C00             ; --- END INLINE ASM BLOCK
1482   0C00             
1483   0C00             ;; return strlen(s); 
1484   0C00 FA 05 00      lea d, [bp + 5] ; $s
1485   0C03 2A            mov b, [d]
1486   0C04 FD AB         swp b
1487   0C06 D8            push b
1488   0C07 07 87 05      call strlen
1489   0C0A 51 02 00      add sp, 2
1490   0C0D F9            leave
1491   0C0E 09            ret
1492   0C0F             
1493   0C0F             print_signed:
1494   0C0F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1495   0C12             ; $digits 
1496   0C12             ; $i 
1497   0C12 10 00 00      mov a, $0
1498   0C15 45 FA FF      mov [bp + -6], a
1499   0C18 52 07 00      sub sp, 7
1500   0C1B             ;; if (num < 0) { 
1501   0C1B             _if22_cond:
1502   0C1B FA 05 00      lea d, [bp + 5] ; $num
1503   0C1E 2A            mov b, [d]
1504   0C1F             ; START RELATIONAL
1505   0C1F D7            push a
1506   0C20 11            mov a, b
1507   0C21 26 00 00      mov b, $0
1508   0C24 B0            cmp a, b
1509   0C25 FD 73         slt ; < (signed)
1510   0C27 E4            pop a
1511   0C28             ; END RELATIONAL
1512   0C28 C0 00 00      cmp b, 0
1513   0C2B C6 48 0C      je _if22_else
1514   0C2E             _if22_true:
1515   0C2E             ;; putchar('-'); 
1516   0C2E 26 2D 00      mov b, $2d
1517   0C31 DD            push bl
1518   0C32 07 0A 13      call putchar
1519   0C35 51 01 00      add sp, 1
1520   0C38             ;; num = -num; 
1521   0C38 FA 05 00      lea d, [bp + 5] ; $num
1522   0C3B DA            push d
1523   0C3C FA 05 00      lea d, [bp + 5] ; $num
1524   0C3F 2A            mov b, [d]
1525   0C40 FD 97         neg b
1526   0C42 E7            pop d
1527   0C43 FD 43         mov [d], b
1528   0C45 0A 6A 0C      jmp _if22_exit
1529   0C48             _if22_else:
1530   0C48             ;; if (num == 0) { 
1531   0C48             _if23_cond:
1532   0C48 FA 05 00      lea d, [bp + 5] ; $num
1533   0C4B 2A            mov b, [d]
1534   0C4C             ; START RELATIONAL
1535   0C4C D7            push a
1536   0C4D 11            mov a, b
1537   0C4E 26 00 00      mov b, $0
1538   0C51 B0            cmp a, b
1539   0C52 FD 71         seq ; ==
1540   0C54 E4            pop a
1541   0C55             ; END RELATIONAL
1542   0C55 C0 00 00      cmp b, 0
1543   0C58 C6 6A 0C      je _if23_exit
1544   0C5B             _if23_true:
1545   0C5B             ;; putchar('0'); 
1546   0C5B 26 30 00      mov b, $30
1547   0C5E DD            push bl
1548   0C5F 07 0A 13      call putchar
1549   0C62 51 01 00      add sp, 1
1550   0C65             ;; return; 
1551   0C65 F9            leave
1552   0C66 09            ret
1553   0C67 0A 6A 0C      jmp _if23_exit
1554   0C6A             _if23_exit:
1555   0C6A             _if22_exit:
1556   0C6A             ;; while (num > 0) { 
1557   0C6A             _while24_cond:
1558   0C6A FA 05 00      lea d, [bp + 5] ; $num
1559   0C6D 2A            mov b, [d]
1560   0C6E             ; START RELATIONAL
1561   0C6E D7            push a
1562   0C6F 11            mov a, b
1563   0C70 26 00 00      mov b, $0
1564   0C73 B0            cmp a, b
1565   0C74 FD 7F         sgt ; >
1566   0C76 E4            pop a
1567   0C77             ; END RELATIONAL
1568   0C77 C0 00 00      cmp b, 0
1569   0C7A C6 C4 0C      je _while24_exit
1570   0C7D             _while24_block:
1571   0C7D             ;; digits[i] = '0' + (num % 10); 
1572   0C7D FA FC FF      lea d, [bp + -4] ; $digits
1573   0C80 D7            push a
1574   0C81 DA            push d
1575   0C82 FA FA FF      lea d, [bp + -6] ; $i
1576   0C85 2A            mov b, [d]
1577   0C86 E7            pop d
1578   0C87 5A            add d, b
1579   0C88 E4            pop a
1580   0C89 DA            push d
1581   0C8A 26 30 00      mov b, $30
1582   0C8D             ; START TERMS
1583   0C8D D7            push a
1584   0C8E 11            mov a, b
1585   0C8F FA 05 00      lea d, [bp + 5] ; $num
1586   0C92 2A            mov b, [d]
1587   0C93             ; START FACTORS
1588   0C93 D7            push a
1589   0C94 11            mov a, b
1590   0C95 26 0A 00      mov b, $a
1591   0C98 AE            div a, b ; 
1592   0C99 11            mov a, b
1593   0C9A 27            mov b, a
1594   0C9B E4            pop a
1595   0C9C             ; END FACTORS
1596   0C9C 56            add b, a
1597   0C9D E4            pop a
1598   0C9E             ; END TERMS
1599   0C9E E7            pop d
1600   0C9F FD 3E         mov [d], bl
1601   0CA1             ;; num = num / 10; 
1602   0CA1 FA 05 00      lea d, [bp + 5] ; $num
1603   0CA4 DA            push d
1604   0CA5 FA 05 00      lea d, [bp + 5] ; $num
1605   0CA8 2A            mov b, [d]
1606   0CA9             ; START FACTORS
1607   0CA9 D7            push a
1608   0CAA 11            mov a, b
1609   0CAB 26 0A 00      mov b, $a
1610   0CAE AE            div a, b
1611   0CAF 27            mov b, a
1612   0CB0 E4            pop a
1613   0CB1             ; END FACTORS
1614   0CB1 E7            pop d
1615   0CB2 FD 43         mov [d], b
1616   0CB4             ;; i++; 
1617   0CB4 FA FA FF      lea d, [bp + -6] ; $i
1618   0CB7 2A            mov b, [d]
1619   0CB8 D8            push b
1620   0CB9 FD 77         inc b
1621   0CBB FA FA FF      lea d, [bp + -6] ; $i
1622   0CBE FD 43         mov [d], b
1623   0CC0 E5            pop b
1624   0CC1 0A 6A 0C      jmp _while24_cond
1625   0CC4             _while24_exit:
1626   0CC4             ;; while (i > 0) { 
1627   0CC4             _while25_cond:
1628   0CC4 FA FA FF      lea d, [bp + -6] ; $i
1629   0CC7 2A            mov b, [d]
1630   0CC8             ; START RELATIONAL
1631   0CC8 D7            push a
1632   0CC9 11            mov a, b
1633   0CCA 26 00 00      mov b, $0
1634   0CCD B0            cmp a, b
1635   0CCE FD 7F         sgt ; >
1636   0CD0 E4            pop a
1637   0CD1             ; END RELATIONAL
1638   0CD1 C0 00 00      cmp b, 0
1639   0CD4 C6 FD 0C      je _while25_exit
1640   0CD7             _while25_block:
1641   0CD7             ;; i--; 
1642   0CD7 FA FA FF      lea d, [bp + -6] ; $i
1643   0CDA 2A            mov b, [d]
1644   0CDB D8            push b
1645   0CDC FD 7D         dec b
1646   0CDE FA FA FF      lea d, [bp + -6] ; $i
1647   0CE1 FD 43         mov [d], b
1648   0CE3 E5            pop b
1649   0CE4             ;; putchar(digits[i]); 
1650   0CE4 FA FC FF      lea d, [bp + -4] ; $digits
1651   0CE7 D7            push a
1652   0CE8 DA            push d
1653   0CE9 FA FA FF      lea d, [bp + -6] ; $i
1654   0CEC 2A            mov b, [d]
1655   0CED E7            pop d
1656   0CEE 5A            add d, b
1657   0CEF E4            pop a
1658   0CF0 32            mov bl, [d]
1659   0CF1 A7 00         mov bh, 0
1660   0CF3 DD            push bl
1661   0CF4 07 0A 13      call putchar
1662   0CF7 51 01 00      add sp, 1
1663   0CFA 0A C4 0C      jmp _while25_cond
1664   0CFD             _while25_exit:
1665   0CFD F9            leave
1666   0CFE 09            ret
1667   0CFF             
1668   0CFF             print_signed_long:
1669   0CFF F8 00 00      enter 0 ; (push bp; mov bp, sp)
1670   0D02             ; $digits 
1671   0D02             ; $i 
1672   0D02 10 00 00      mov a, $0
1673   0D05 45 F5 FF      mov [bp + -11], a
1674   0D08 52 0C 00      sub sp, 12
1675   0D0B             ;; if (num < 0) { 
1676   0D0B             _if26_cond:
1677   0D0B FA 05 00      lea d, [bp + 5] ; $num
1678   0D0E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1679   0D11 FD 39         mov c, b ; And place it into C
1680   0D13 2A            mov b, [d] ; Lower Word in B
1681   0D14             ; START RELATIONAL
1682   0D14 D7            push a
1683   0D15 FD D8         push g
1684   0D17 11            mov a, b
out/test.asm line 1685: Label not found: (c)
out/test.asm line 1685: Unused data in MS byte of argument. (2)
1685   0D18 FD 22 00 00   mov g, c
1686   0D1C 26 00 00      mov b, $0
1687   0D1F 38 00 00      mov c, 0
1688   0D22 FD AF 00 00   cmp32 ga, cb
1688   0D26 00 00 00 00 
1688   0D2A 00 00 00 00 
1688   0D2E 00 00 00 00 
1688   0D32 00 00 00 00 
1688   0D36 00 00 00 00 
1688   0D3A 00 00 00 00 
1688   0D3E 00 00 00 00 
1688   0D42 00 00 00 00 
1688   0D46 00 00 00 00 
1688   0D4A 00 00 00 00 
1688   0D4E 00 00 00 00 
1688   0D52 00 00 00 00 
1688   0D56 00 00 00 00 
1688   0D5A 00 00 00 00 
1688   0D5E 00 00 00 00 
1688   0D62 00 00 00 00 
1688   0D66 00 00 00 00 
1688   0D6A 00 00 00 00 
1688   0D6E 00 00 00 00 
1688   0D72 00 00 00 00 
1688   0D76 00 00 00 00 
1688   0D7A 00 00 00 00 
1688   0D7E 00 00 00 00 
1688   0D82 00 00 00 00 
1688   0D86 00 00 00 00 
1688   0D8A 00 00 00 00 
1688   0D8E 00 00 00 00 
1688   0D92 00 00 00 00 
1688   0D96 00 00 00 00 
1688   0D9A 00 00 00 00 
1688   0D9E 00 00 00 00 
1688   0DA2 00 00 00 00 
1688   0DA6 00 00 00 00 
1688   0DAA 00 00 00 00 
1688   0DAE 00 00 00 00 
1688   0DB2 00 00 00 00 
1688   0DB6 00 00 00 00 
1688   0DBA 00 00 00 00 
1688   0DBE 00 00 00 00 
1688   0DC2 00 00 00 00 
1688   0DC6 00 00 00 00 
1688   0DCA 00 00 00 00 
1688   0DCE 00 00 00 00 
1688   0DD2 00 00 00 00 
1688   0DD6 00 00 00 00 
1688   0DDA 00 00 00 00 
1688   0DDE 00 00 00 00 
1688   0DE2 00 00 00 00 
1688   0DE6 00 00 00 00 
1688   0DEA 00 00 00 00 
1688   0DEE 00 00 00 00 
1688   0DF2 00 00 00 00 
1688   0DF6 00 00 00 00 
1688   0DFA 00 00 00 00 
1688   0DFE 00 00 00 00 
1688   0E02 00 00 00 00 
1688   0E06 00 00 00 00 
1688   0E0A 00 00 00 00 
1688   0E0E 00 00 00 00 
1688   0E12 00 00 00 00 
1688   0E16 00 00 00 00 
1688   0E1A 00 00 00 00 
1688   0E1E 00 00 00 00 
1688   0E22 00 
1689   0E23 FD 73         slt ; <
1690   0E25 FD F1         pop g
1691   0E27 E4            pop a
1692   0E28             ; END RELATIONAL
1693   0E28 C0 00 00      cmp b, 0
1694   0E2B C6 52 0E      je _if26_else
1695   0E2E             _if26_true:
1696   0E2E             ;; putchar('-'); 
1697   0E2E 26 2D 00      mov b, $2d
1698   0E31 DD            push bl
1699   0E32 07 0A 13      call putchar
1700   0E35 51 01 00      add sp, 1
1701   0E38             ;; num = -num; 
1702   0E38 FA 05 00      lea d, [bp + 5] ; $num
1703   0E3B DA            push d
1704   0E3C FA 05 00      lea d, [bp + 5] ; $num
1705   0E3F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1706   0E42 FD 39         mov c, b ; And place it into C
1707   0E44 2A            mov b, [d] ; Lower Word in B
1708   0E45 FD 97         neg b
1709   0E47 E7            pop d
1710   0E48 FD 43         mov [d], b
1711   0E4A 28            mov b, c
1712   0E4B FD 44 02 00   mov [d + 2], b
1713   0E4F 0A 84 0F      jmp _if26_exit
1714   0E52             _if26_else:
1715   0E52             ;; if (num == 0) { 
1716   0E52             _if27_cond:
1717   0E52 FA 05 00      lea d, [bp + 5] ; $num
1718   0E55 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1719   0E58 FD 39         mov c, b ; And place it into C
1720   0E5A 2A            mov b, [d] ; Lower Word in B
1721   0E5B             ; START RELATIONAL
1722   0E5B D7            push a
1723   0E5C FD D8         push g
1724   0E5E 11            mov a, b
out/test.asm line 1725: Label not found: (c)
out/test.asm line 1725: Unused data in MS byte of argument. (2)
1725   0E5F FD 22 00 00   mov g, c
1726   0E63 26 00 00      mov b, $0
1727   0E66 38 00 00      mov c, 0
1728   0E69 FD AF 00 00   cmp32 ga, cb
1728   0E6D 00 00 00 00 
1728   0E71 00 00 00 00 
1728   0E75 00 00 00 00 
1728   0E79 00 00 00 00 
1728   0E7D 00 00 00 00 
1728   0E81 00 00 00 00 
1728   0E85 00 00 00 00 
1728   0E89 00 00 00 00 
1728   0E8D 00 00 00 00 
1728   0E91 00 00 00 00 
1728   0E95 00 00 00 00 
1728   0E99 00 00 00 00 
1728   0E9D 00 00 00 00 
1728   0EA1 00 00 00 00 
1728   0EA5 00 00 00 00 
1728   0EA9 00 00 00 00 
1728   0EAD 00 00 00 00 
1728   0EB1 00 00 00 00 
1728   0EB5 00 00 00 00 
1728   0EB9 00 00 00 00 
1728   0EBD 00 00 00 00 
1728   0EC1 00 00 00 00 
1728   0EC5 00 00 00 00 
1728   0EC9 00 00 00 00 
1728   0ECD 00 00 00 00 
1728   0ED1 00 00 00 00 
1728   0ED5 00 00 00 00 
1728   0ED9 00 00 00 00 
1728   0EDD 00 00 00 00 
1728   0EE1 00 00 00 00 
1728   0EE5 00 00 00 00 
1728   0EE9 00 00 00 00 
1728   0EED 00 00 00 00 
1728   0EF1 00 00 00 00 
1728   0EF5 00 00 00 00 
1728   0EF9 00 00 00 00 
1728   0EFD 00 00 00 00 
1728   0F01 00 00 00 00 
1728   0F05 00 00 00 00 
1728   0F09 00 00 00 00 
1728   0F0D 00 00 00 00 
1728   0F11 00 00 00 00 
1728   0F15 00 00 00 00 
1728   0F19 00 00 00 00 
1728   0F1D 00 00 00 00 
1728   0F21 00 00 00 00 
1728   0F25 00 00 00 00 
1728   0F29 00 00 00 00 
1728   0F2D 00 00 00 00 
1728   0F31 00 00 00 00 
1728   0F35 00 00 00 00 
1728   0F39 00 00 00 00 
1728   0F3D 00 00 00 00 
1728   0F41 00 00 00 00 
1728   0F45 00 00 00 00 
1728   0F49 00 00 00 00 
1728   0F4D 00 00 00 00 
1728   0F51 00 00 00 00 
1728   0F55 00 00 00 00 
1728   0F59 00 00 00 00 
1728   0F5D 00 00 00 00 
1728   0F61 00 00 00 00 
1728   0F65 00 00 00 00 
1728   0F69 00 
1729   0F6A FD 71         seq ; ==
1730   0F6C FD F1         pop g
1731   0F6E E4            pop a
1732   0F6F             ; END RELATIONAL
1733   0F6F C0 00 00      cmp b, 0
1734   0F72 C6 84 0F      je _if27_exit
1735   0F75             _if27_true:
1736   0F75             ;; putchar('0'); 
1737   0F75 26 30 00      mov b, $30
1738   0F78 DD            push bl
1739   0F79 07 0A 13      call putchar
1740   0F7C 51 01 00      add sp, 1
1741   0F7F             ;; return; 
1742   0F7F F9            leave
1743   0F80 09            ret
1744   0F81 0A 84 0F      jmp _if27_exit
1745   0F84             _if27_exit:
1746   0F84             _if26_exit:
1747   0F84             ;; while (num > 0) { 
1748   0F84             _while28_cond:
1749   0F84 FA 05 00      lea d, [bp + 5] ; $num
1750   0F87 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1751   0F8A FD 39         mov c, b ; And place it into C
1752   0F8C 2A            mov b, [d] ; Lower Word in B
1753   0F8D             ; START RELATIONAL
1754   0F8D D7            push a
1755   0F8E FD D8         push g
1756   0F90 11            mov a, b
out/test.asm line 1757: Label not found: (c)
out/test.asm line 1757: Unused data in MS byte of argument. (2)
1757   0F91 FD 22 00 00   mov g, c
1758   0F95 26 00 00      mov b, $0
1759   0F98 38 00 00      mov c, 0
1760   0F9B FD 7F         sgt
1761   0F9D FD F1         pop g
1762   0F9F E4            pop a
1763   0FA0             ; END RELATIONAL
1764   0FA0 C0 00 00      cmp b, 0
1765   0FA3 C6 03 10      je _while28_exit
1766   0FA6             _while28_block:
1767   0FA6             ;; digits[i] = '0' + (num % 10); 
1768   0FA6 FA F7 FF      lea d, [bp + -9] ; $digits
1769   0FA9 D7            push a
1770   0FAA DA            push d
1771   0FAB FA F5 FF      lea d, [bp + -11] ; $i
1772   0FAE 2A            mov b, [d]
1773   0FAF E7            pop d
1774   0FB0 5A            add d, b
1775   0FB1 E4            pop a
1776   0FB2 DA            push d
1777   0FB3 26 30 00      mov b, $30
1778   0FB6             ; START TERMS
1779   0FB6 D7            push a
1780   0FB7 11            mov a, b
1781   0FB8 FA 05 00      lea d, [bp + 5] ; $num
1782   0FBB 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1783   0FBE FD 39         mov c, b ; And place it into C
1784   0FC0 2A            mov b, [d] ; Lower Word in B
1785   0FC1             ; START FACTORS
1786   0FC1 D7            push a
1787   0FC2 11            mov a, b
1788   0FC3 26 0A 00      mov b, $a
1789   0FC6 AE            div a, b ; 
1790   0FC7 11            mov a, b
1791   0FC8 27            mov b, a
1792   0FC9 E4            pop a
1793   0FCA             ; END FACTORS
1794   0FCA 54            add a, b
1795   0FCB D7            push a
1796   0FCC FD 12         mov a, g
1797   0FCE 28            mov b, c
1798   0FCF 5C            adc a, b
1799   0FD0 39            mov c, a
1800   0FD1 E5            pop b
1801   0FD2 E4            pop a
1802   0FD3             ; END TERMS
1803   0FD3 E7            pop d
1804   0FD4 FD 3E         mov [d], bl
1805   0FD6             ;; num = num / 10; 
1806   0FD6 FA 05 00      lea d, [bp + 5] ; $num
1807   0FD9 DA            push d
1808   0FDA FA 05 00      lea d, [bp + 5] ; $num
1809   0FDD 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1810   0FE0 FD 39         mov c, b ; And place it into C
1811   0FE2 2A            mov b, [d] ; Lower Word in B
1812   0FE3             ; START FACTORS
1813   0FE3 D7            push a
1814   0FE4 11            mov a, b
1815   0FE5 26 0A 00      mov b, $a
1816   0FE8 AE            div a, b
1817   0FE9 27            mov b, a
1818   0FEA E4            pop a
1819   0FEB             ; END FACTORS
1820   0FEB E7            pop d
1821   0FEC FD 43         mov [d], b
1822   0FEE 28            mov b, c
1823   0FEF FD 44 02 00   mov [d + 2], b
1824   0FF3             ;; i++; 
1825   0FF3 FA F5 FF      lea d, [bp + -11] ; $i
1826   0FF6 2A            mov b, [d]
1827   0FF7 D8            push b
1828   0FF8 FD 77         inc b
1829   0FFA FA F5 FF      lea d, [bp + -11] ; $i
1830   0FFD FD 43         mov [d], b
1831   0FFF E5            pop b
1832   1000 0A 84 0F      jmp _while28_cond
1833   1003             _while28_exit:
1834   1003             ;; while (i > 0) { 
1835   1003             _while29_cond:
1836   1003 FA F5 FF      lea d, [bp + -11] ; $i
1837   1006 2A            mov b, [d]
1838   1007             ; START RELATIONAL
1839   1007 D7            push a
1840   1008 11            mov a, b
1841   1009 26 00 00      mov b, $0
1842   100C B0            cmp a, b
1843   100D FD 7F         sgt ; >
1844   100F E4            pop a
1845   1010             ; END RELATIONAL
1846   1010 C0 00 00      cmp b, 0
1847   1013 C6 3C 10      je _while29_exit
1848   1016             _while29_block:
1849   1016             ;; i--; 
1850   1016 FA F5 FF      lea d, [bp + -11] ; $i
1851   1019 2A            mov b, [d]
1852   101A D8            push b
1853   101B FD 7D         dec b
1854   101D FA F5 FF      lea d, [bp + -11] ; $i
1855   1020 FD 43         mov [d], b
1856   1022 E5            pop b
1857   1023             ;; putchar(digits[i]); 
1858   1023 FA F7 FF      lea d, [bp + -9] ; $digits
1859   1026 D7            push a
1860   1027 DA            push d
1861   1028 FA F5 FF      lea d, [bp + -11] ; $i
1862   102B 2A            mov b, [d]
1863   102C E7            pop d
1864   102D 5A            add d, b
1865   102E E4            pop a
1866   102F 32            mov bl, [d]
1867   1030 A7 00         mov bh, 0
1868   1032 DD            push bl
1869   1033 07 0A 13      call putchar
1870   1036 51 01 00      add sp, 1
1871   1039 0A 03 10      jmp _while29_cond
1872   103C             _while29_exit:
1873   103C F9            leave
1874   103D 09            ret
1875   103E             
1876   103E             print_unsigned_long:
1877   103E F8 00 00      enter 0 ; (push bp; mov bp, sp)
1878   1041             ; $digits 
1879   1041             ; $i 
1880   1041 52 0C 00      sub sp, 12
1881   1044             ;; i = 0; 
1882   1044 FA F5 FF      lea d, [bp + -11] ; $i
1883   1047 DA            push d
1884   1048 26 00 00      mov b, $0
1885   104B E7            pop d
1886   104C FD 43         mov [d], b
1887   104E             ;; if(num == 0){ 
1888   104E             _if30_cond:
1889   104E FA 05 00      lea d, [bp + 5] ; $num
1890   1051 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1891   1054 FD 39         mov c, b ; And place it into C
1892   1056 2A            mov b, [d] ; Lower Word in B
1893   1057             ; START RELATIONAL
1894   1057 D7            push a
1895   1058 FD D8         push g
1896   105A 11            mov a, b
out/test.asm line 1897: Label not found: (c)
out/test.asm line 1897: Unused data in MS byte of argument. (2)
1897   105B FD 22 00 00   mov g, c
1898   105F 26 00 00      mov b, $0
1899   1062 38 00 00      mov c, 0
1900   1065 FD AF 00 00   cmp32 ga, cb
1900   1069 00 00 00 00 
1900   106D 00 00 00 00 
1900   1071 00 00 00 00 
1900   1075 00 00 00 00 
1900   1079 00 00 00 00 
1900   107D 00 00 00 00 
1900   1081 00 00 00 00 
1900   1085 00 00 00 00 
1900   1089 00 00 00 00 
1900   108D 00 00 00 00 
1900   1091 00 00 00 00 
1900   1095 00 00 00 00 
1900   1099 00 00 00 00 
1900   109D 00 00 00 00 
1900   10A1 00 00 00 00 
1900   10A5 00 00 00 00 
1900   10A9 00 00 00 00 
1900   10AD 00 00 00 00 
1900   10B1 00 00 00 00 
1900   10B5 00 00 00 00 
1900   10B9 00 00 00 00 
1900   10BD 00 00 00 00 
1900   10C1 00 00 00 00 
1900   10C5 00 00 00 00 
1900   10C9 00 00 00 00 
1900   10CD 00 00 00 00 
1900   10D1 00 00 00 00 
1900   10D5 00 00 00 00 
1900   10D9 00 00 00 00 
1900   10DD 00 00 00 00 
1900   10E1 00 00 00 00 
1900   10E5 00 00 00 00 
1900   10E9 00 00 00 00 
1900   10ED 00 00 00 00 
1900   10F1 00 00 00 00 
1900   10F5 00 00 00 00 
1900   10F9 00 00 00 00 
1900   10FD 00 00 00 00 
1900   1101 00 00 00 00 
1900   1105 00 00 00 00 
1900   1109 00 00 00 00 
1900   110D 00 00 00 00 
1900   1111 00 00 00 00 
1900   1115 00 00 00 00 
1900   1119 00 00 00 00 
1900   111D 00 00 00 00 
1900   1121 00 00 00 00 
1900   1125 00 00 00 00 
1900   1129 00 00 00 00 
1900   112D 00 00 00 00 
1900   1131 00 00 00 00 
1900   1135 00 00 00 00 
1900   1139 00 00 00 00 
1900   113D 00 00 00 00 
1900   1141 00 00 00 00 
1900   1145 00 00 00 00 
1900   1149 00 00 00 00 
1900   114D 00 00 00 00 
1900   1151 00 00 00 00 
1900   1155 00 00 00 00 
1900   1159 00 00 00 00 
1900   115D 00 00 00 00 
1900   1161 00 00 00 00 
1900   1165 00 
1901   1166 FD 71         seq ; ==
1902   1168 FD F1         pop g
1903   116A E4            pop a
1904   116B             ; END RELATIONAL
1905   116B C0 00 00      cmp b, 0
1906   116E C6 80 11      je _if30_exit
1907   1171             _if30_true:
1908   1171             ;; putchar('0'); 
1909   1171 26 30 00      mov b, $30
1910   1174 DD            push bl
1911   1175 07 0A 13      call putchar
1912   1178 51 01 00      add sp, 1
1913   117B             ;; return; 
1914   117B F9            leave
1915   117C 09            ret
1916   117D 0A 80 11      jmp _if30_exit
1917   1180             _if30_exit:
1918   1180             ;; while (num > 0) { 
1919   1180             _while31_cond:
1920   1180 FA 05 00      lea d, [bp + 5] ; $num
1921   1183 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1922   1186 FD 39         mov c, b ; And place it into C
1923   1188 2A            mov b, [d] ; Lower Word in B
1924   1189             ; START RELATIONAL
1925   1189 D7            push a
1926   118A FD D8         push g
1927   118C 11            mov a, b
out/test.asm line 1928: Label not found: (c)
out/test.asm line 1928: Unused data in MS byte of argument. (2)
1928   118D FD 22 00 00   mov g, c
1929   1191 26 00 00      mov b, $0
1930   1194 38 00 00      mov c, 0
1931   1197 FD 81         sgu
1932   1199 FD F1         pop g
1933   119B E4            pop a
1934   119C             ; END RELATIONAL
1935   119C C0 00 00      cmp b, 0
1936   119F C6 FF 11      je _while31_exit
1937   11A2             _while31_block:
1938   11A2             ;; digits[i] = '0' + (num % 10); 
1939   11A2 FA F7 FF      lea d, [bp + -9] ; $digits
1940   11A5 D7            push a
1941   11A6 DA            push d
1942   11A7 FA F5 FF      lea d, [bp + -11] ; $i
1943   11AA 2A            mov b, [d]
1944   11AB E7            pop d
1945   11AC 5A            add d, b
1946   11AD E4            pop a
1947   11AE DA            push d
1948   11AF 26 30 00      mov b, $30
1949   11B2             ; START TERMS
1950   11B2 D7            push a
1951   11B3 11            mov a, b
1952   11B4 FA 05 00      lea d, [bp + 5] ; $num
1953   11B7 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1954   11BA FD 39         mov c, b ; And place it into C
1955   11BC 2A            mov b, [d] ; Lower Word in B
1956   11BD             ; START FACTORS
1957   11BD D7            push a
1958   11BE 11            mov a, b
1959   11BF 26 0A 00      mov b, $a
1960   11C2 AE            div a, b ; 
1961   11C3 11            mov a, b
1962   11C4 27            mov b, a
1963   11C5 E4            pop a
1964   11C6             ; END FACTORS
1965   11C6 54            add a, b
1966   11C7 D7            push a
1967   11C8 FD 12         mov a, g
1968   11CA 28            mov b, c
1969   11CB 5C            adc a, b
1970   11CC 39            mov c, a
1971   11CD E5            pop b
1972   11CE E4            pop a
1973   11CF             ; END TERMS
1974   11CF E7            pop d
1975   11D0 FD 3E         mov [d], bl
1976   11D2             ;; num = num / 10; 
1977   11D2 FA 05 00      lea d, [bp + 5] ; $num
1978   11D5 DA            push d
1979   11D6 FA 05 00      lea d, [bp + 5] ; $num
1980   11D9 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1981   11DC FD 39         mov c, b ; And place it into C
1982   11DE 2A            mov b, [d] ; Lower Word in B
1983   11DF             ; START FACTORS
1984   11DF D7            push a
1985   11E0 11            mov a, b
1986   11E1 26 0A 00      mov b, $a
1987   11E4 AE            div a, b
1988   11E5 27            mov b, a
1989   11E6 E4            pop a
1990   11E7             ; END FACTORS
1991   11E7 E7            pop d
1992   11E8 FD 43         mov [d], b
1993   11EA 28            mov b, c
1994   11EB FD 44 02 00   mov [d + 2], b
1995   11EF             ;; i++; 
1996   11EF FA F5 FF      lea d, [bp + -11] ; $i
1997   11F2 2A            mov b, [d]
1998   11F3 D8            push b
1999   11F4 FD 77         inc b
2000   11F6 FA F5 FF      lea d, [bp + -11] ; $i
2001   11F9 FD 43         mov [d], b
2002   11FB E5            pop b
2003   11FC 0A 80 11      jmp _while31_cond
2004   11FF             _while31_exit:
2005   11FF             ;; while (i > 0) { 
2006   11FF             _while32_cond:
2007   11FF FA F5 FF      lea d, [bp + -11] ; $i
2008   1202 2A            mov b, [d]
2009   1203             ; START RELATIONAL
2010   1203 D7            push a
2011   1204 11            mov a, b
2012   1205 26 00 00      mov b, $0
2013   1208 B0            cmp a, b
2014   1209 FD 7F         sgt ; >
2015   120B E4            pop a
2016   120C             ; END RELATIONAL
2017   120C C0 00 00      cmp b, 0
2018   120F C6 38 12      je _while32_exit
2019   1212             _while32_block:
2020   1212             ;; i--; 
2021   1212 FA F5 FF      lea d, [bp + -11] ; $i
2022   1215 2A            mov b, [d]
2023   1216 D8            push b
2024   1217 FD 7D         dec b
2025   1219 FA F5 FF      lea d, [bp + -11] ; $i
2026   121C FD 43         mov [d], b
2027   121E E5            pop b
2028   121F             ;; putchar(digits[i]); 
2029   121F FA F7 FF      lea d, [bp + -9] ; $digits
2030   1222 D7            push a
2031   1223 DA            push d
2032   1224 FA F5 FF      lea d, [bp + -11] ; $i
2033   1227 2A            mov b, [d]
2034   1228 E7            pop d
2035   1229 5A            add d, b
2036   122A E4            pop a
2037   122B 32            mov bl, [d]
2038   122C A7 00         mov bh, 0
2039   122E DD            push bl
2040   122F 07 0A 13      call putchar
2041   1232 51 01 00      add sp, 1
2042   1235 0A FF 11      jmp _while32_cond
2043   1238             _while32_exit:
2044   1238 F9            leave
2045   1239 09            ret
2046   123A             
2047   123A             print_unsigned:
2048   123A F8 00 00      enter 0 ; (push bp; mov bp, sp)
2049   123D             ; $digits 
2050   123D             ; $i 
2051   123D 52 07 00      sub sp, 7
2052   1240             ;; i = 0; 
2053   1240 FA FA FF      lea d, [bp + -6] ; $i
2054   1243 DA            push d
2055   1244 26 00 00      mov b, $0
2056   1247 E7            pop d
2057   1248 FD 43         mov [d], b
2058   124A             ;; if(num == 0){ 
2059   124A             _if33_cond:
2060   124A FA 05 00      lea d, [bp + 5] ; $num
2061   124D 2A            mov b, [d]
2062   124E             ; START RELATIONAL
2063   124E D7            push a
2064   124F 11            mov a, b
2065   1250 26 00 00      mov b, $0
2066   1253 B0            cmp a, b
2067   1254 FD 71         seq ; ==
2068   1256 E4            pop a
2069   1257             ; END RELATIONAL
2070   1257 C0 00 00      cmp b, 0
2071   125A C6 6C 12      je _if33_exit
2072   125D             _if33_true:
2073   125D             ;; putchar('0'); 
2074   125D 26 30 00      mov b, $30
2075   1260 DD            push bl
2076   1261 07 0A 13      call putchar
2077   1264 51 01 00      add sp, 1
2078   1267             ;; return; 
2079   1267 F9            leave
2080   1268 09            ret
2081   1269 0A 6C 12      jmp _if33_exit
2082   126C             _if33_exit:
2083   126C             ;; while (num > 0) { 
2084   126C             _while34_cond:
2085   126C FA 05 00      lea d, [bp + 5] ; $num
2086   126F 2A            mov b, [d]
2087   1270             ; START RELATIONAL
2088   1270 D7            push a
2089   1271 11            mov a, b
2090   1272 26 00 00      mov b, $0
2091   1275 B0            cmp a, b
2092   1276 FD 81         sgu ; > (unsigned)
2093   1278 E4            pop a
2094   1279             ; END RELATIONAL
2095   1279 C0 00 00      cmp b, 0
2096   127C C6 C6 12      je _while34_exit
2097   127F             _while34_block:
2098   127F             ;; digits[i] = '0' + (num % 10); 
2099   127F FA FC FF      lea d, [bp + -4] ; $digits
2100   1282 D7            push a
2101   1283 DA            push d
2102   1284 FA FA FF      lea d, [bp + -6] ; $i
2103   1287 2A            mov b, [d]
2104   1288 E7            pop d
2105   1289 5A            add d, b
2106   128A E4            pop a
2107   128B DA            push d
2108   128C 26 30 00      mov b, $30
2109   128F             ; START TERMS
2110   128F D7            push a
2111   1290 11            mov a, b
2112   1291 FA 05 00      lea d, [bp + 5] ; $num
2113   1294 2A            mov b, [d]
2114   1295             ; START FACTORS
2115   1295 D7            push a
2116   1296 11            mov a, b
2117   1297 26 0A 00      mov b, $a
2118   129A AE            div a, b ; 
2119   129B 11            mov a, b
2120   129C 27            mov b, a
2121   129D E4            pop a
2122   129E             ; END FACTORS
2123   129E 56            add b, a
2124   129F E4            pop a
2125   12A0             ; END TERMS
2126   12A0 E7            pop d
2127   12A1 FD 3E         mov [d], bl
2128   12A3             ;; num = num / 10; 
2129   12A3 FA 05 00      lea d, [bp + 5] ; $num
2130   12A6 DA            push d
2131   12A7 FA 05 00      lea d, [bp + 5] ; $num
2132   12AA 2A            mov b, [d]
2133   12AB             ; START FACTORS
2134   12AB D7            push a
2135   12AC 11            mov a, b
2136   12AD 26 0A 00      mov b, $a
2137   12B0 AE            div a, b
2138   12B1 27            mov b, a
2139   12B2 E4            pop a
2140   12B3             ; END FACTORS
2141   12B3 E7            pop d
2142   12B4 FD 43         mov [d], b
2143   12B6             ;; i++; 
2144   12B6 FA FA FF      lea d, [bp + -6] ; $i
2145   12B9 2A            mov b, [d]
2146   12BA D8            push b
2147   12BB FD 77         inc b
2148   12BD FA FA FF      lea d, [bp + -6] ; $i
2149   12C0 FD 43         mov [d], b
2150   12C2 E5            pop b
2151   12C3 0A 6C 12      jmp _while34_cond
2152   12C6             _while34_exit:
2153   12C6             ;; while (i > 0) { 
2154   12C6             _while35_cond:
2155   12C6 FA FA FF      lea d, [bp + -6] ; $i
2156   12C9 2A            mov b, [d]
2157   12CA             ; START RELATIONAL
2158   12CA D7            push a
2159   12CB 11            mov a, b
2160   12CC 26 00 00      mov b, $0
2161   12CF B0            cmp a, b
2162   12D0 FD 7F         sgt ; >
2163   12D2 E4            pop a
2164   12D3             ; END RELATIONAL
2165   12D3 C0 00 00      cmp b, 0
2166   12D6 C6 FF 12      je _while35_exit
2167   12D9             _while35_block:
2168   12D9             ;; i--; 
2169   12D9 FA FA FF      lea d, [bp + -6] ; $i
2170   12DC 2A            mov b, [d]
2171   12DD D8            push b
2172   12DE FD 7D         dec b
2173   12E0 FA FA FF      lea d, [bp + -6] ; $i
2174   12E3 FD 43         mov [d], b
2175   12E5 E5            pop b
2176   12E6             ;; putchar(digits[i]); 
2177   12E6 FA FC FF      lea d, [bp + -4] ; $digits
2178   12E9 D7            push a
2179   12EA DA            push d
2180   12EB FA FA FF      lea d, [bp + -6] ; $i
2181   12EE 2A            mov b, [d]
2182   12EF E7            pop d
2183   12F0 5A            add d, b
2184   12F1 E4            pop a
2185   12F2 32            mov bl, [d]
2186   12F3 A7 00         mov bh, 0
2187   12F5 DD            push bl
2188   12F6 07 0A 13      call putchar
2189   12F9 51 01 00      add sp, 1
2190   12FC 0A C6 12      jmp _while35_cond
2191   12FF             _while35_exit:
2192   12FF F9            leave
2193   1300 09            ret
2194   1301             
2195   1301             date:
2196   1301 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2197   1304             
2198   1304             ; --- BEGIN INLINE ASM BLOCK
2199   1304 19 00         mov al, 0 
2200   1306 05 07         syscall sys_datetime
2201   1308             ; --- END INLINE ASM BLOCK
2202   1308             
2203   1308 F9            leave
2204   1309 09            ret
2205   130A             
2206   130A             putchar:
2207   130A F8 00 00      enter 0 ; (push bp; mov bp, sp)
2208   130D             
2209   130D             ; --- BEGIN INLINE ASM BLOCK
2210   130D FA 05 00      lea d, [bp + 5] ; $c
2211   1310 1E            mov al, [d]
2212   1311 23            mov ah, al
2213   1312 07 9B 14      call _putchar
2214   1315             ; --- END INLINE ASM BLOCK
2215   1315             
2216   1315 F9            leave
2217   1316 09            ret
2218   1317             
2219   1317             getchar:
2220   1317 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2221   131A             ; $c 
2222   131A 52 01 00      sub sp, 1
2223   131D             
2224   131D             ; --- BEGIN INLINE ASM BLOCK
2225   131D 07 94 14      call getch
2226   1320 1A            mov al, ah
2227   1321 FA 00 00      lea d, [bp + 0] ; $c
2228   1324 3E            mov [d], al
2229   1325             ; --- END INLINE ASM BLOCK
2230   1325             
2231   1325             ;; return c; 
2232   1325 FA 00 00      lea d, [bp + 0] ; $c
2233   1328 32            mov bl, [d]
2234   1329 A7 00         mov bh, 0
2235   132B F9            leave
2236   132C 09            ret
2237   132D             
2238   132D             scann:
2239   132D F8 00 00      enter 0 ; (push bp; mov bp, sp)
2240   1330             ; $m 
2241   1330 52 02 00      sub sp, 2
2242   1333             
2243   1333             ; --- BEGIN INLINE ASM BLOCK
2244   1333 07 DF 16      call scan_u16d
2245   1336 FA FF FF      lea d, [bp + -1] ; $m
2246   1339 43            mov [d], a
2247   133A             ; --- END INLINE ASM BLOCK
2248   133A             
2249   133A             ;; return m; 
2250   133A FA FF FF      lea d, [bp + -1] ; $m
2251   133D 2A            mov b, [d]
2252   133E F9            leave
2253   133F 09            ret
2254   1340             
2255   1340             puts:
2256   1340 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2257   1343             
2258   1343             ; --- BEGIN INLINE ASM BLOCK
2259   1343 FA 05 00      lea d, [bp + 5] ; $s
2260   1346 15            mov a, [d]
2261   1347 3C            mov d, a
2262   1348 07 E5 15      call _puts
2263   134B 10 00 0A      mov a, $0A00
2264   134E 05 03         syscall sys_io
2265   1350             ; --- END INLINE ASM BLOCK
2266   1350             
2267   1350 F9            leave
2268   1351 09            ret
2269   1352             
2270   1352             print:
2271   1352 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2272   1355             
2273   1355             ; --- BEGIN INLINE ASM BLOCK
2274   1355 FA 05 00      lea d, [bp + 5] ; $s
2275   1358 FD 2A         mov d, [d]
2276   135A 07 E5 15      call _puts
2277   135D             ; --- END INLINE ASM BLOCK
2278   135D             
2279   135D F9            leave
2280   135E 09            ret
2281   135F             
2282   135F             getparam:
2283   135F F8 00 00      enter 0 ; (push bp; mov bp, sp)
2284   1362             ; $data 
2285   1362 52 01 00      sub sp, 1
2286   1365             
2287   1365             ; --- BEGIN INLINE ASM BLOCK
2288   1365 19 04         mov al, 4
2289   1367 FA 05 00      lea d, [bp + 5] ; $address
2290   136A FD 2A         mov d, [d]
2291   136C 05 0C         syscall sys_system
2292   136E FA 00 00      lea d, [bp + 0] ; $data
2293   1371 FD 3E         mov [d], bl
2294   1373             ; --- END INLINE ASM BLOCK
2295   1373             
2296   1373             ;; return data; 
2297   1373 FA 00 00      lea d, [bp + 0] ; $data
2298   1376 32            mov bl, [d]
2299   1377 A7 00         mov bh, 0
2300   1379 F9            leave
2301   137A 09            ret
2302   137B             
2303   137B             clear:
2304   137B F8 00 00      enter 0 ; (push bp; mov bp, sp)
2305   137E             ;; print("\033[2J\033[H"); 
2306   137E 26 7E 17      mov b, __s2 ; "\033[2J\033[H"
2307   1381 FD AB         swp b
2308   1383 D8            push b
2309   1384 07 52 13      call print
2310   1387 51 02 00      add sp, 2
2311   138A F9            leave
2312   138B 09            ret
2313   138C             
2314   138C             abs:
2315   138C F8 00 00      enter 0 ; (push bp; mov bp, sp)
2316   138F             ;; return i < 0 ? -i : i; 
2317   138F             _ternary36_cond:
2318   138F FA 05 00      lea d, [bp + 5] ; $i
2319   1392 2A            mov b, [d]
2320   1393             ; START RELATIONAL
2321   1393 D7            push a
2322   1394 11            mov a, b
2323   1395 26 00 00      mov b, $0
2324   1398 B0            cmp a, b
2325   1399 FD 73         slt ; < (signed)
2326   139B E4            pop a
2327   139C             ; END RELATIONAL
2328   139C C0 00 00      cmp b, 0
2329   139F C6 AB 13      je _ternary36_false
2330   13A2             _ternary36_true:
2331   13A2 FA 05 00      lea d, [bp + 5] ; $i
2332   13A5 2A            mov b, [d]
2333   13A6 FD 97         neg b
2334   13A8 0A AF 13      jmp _ternary36_exit
2335   13AB             _ternary36_false:
2336   13AB FA 05 00      lea d, [bp + 5] ; $i
2337   13AE 2A            mov b, [d]
2338   13AF             _ternary36_exit:
2339   13AF F9            leave
2340   13B0 09            ret
2341   13B1             
2342   13B1             include_stdio_asm:
2343   13B1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2344   13B4             
2345   13B4             ; --- BEGIN INLINE ASM BLOCK
2346   13B4             .include "lib/asm/stdio.asm"
0001+  13B4             ;-----------------------------------------------------------------------------
0002+  13B4             ; stdio.s
0003+  13B4             ;-----------------------------------------------------------------------------
0004+  13B4             .include "lib/asm/string.asm"
0001++ 13B4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 13B4             ; string.s
0003++ 13B4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 13B4             
0005++ 13B4             
0006++ 13B4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 13B4             ; _strrev
0008++ 13B4             ; reverse a string
0009++ 13B4             ; D = string address
0010++ 13B4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 13B4             ; 01234
0012++ 13B4             _strrev:
0013++ 13B4 4B          	pusha
0014++ 13B5 07 FB 13    	call _strlen	; length in C
0015++ 13B8 12          	mov a, c
0016++ 13B9 AF 01 00    	cmp a, 1
0017++ 13BC D0 D6 13    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 13BF 7D          	dec a
0019++ 13C0 FD 4E       	mov si, d	; beginning of string
0020++ 13C2 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 13C4 59          	add d, a	; end of string
0022++ 13C5 12          	mov a, c
0023++ 13C6 FD 9B       	shr a		; divide by 2
0024++ 13C8 39          	mov c, a	; C now counts the steps
0025++ 13C9             _strrev_L0:
0026++ 13C9 32          	mov bl, [d]	; save load right-side char into BL
0027++ 13CA F6          	lodsb		; load left-side char into AL; increase SI
0028++ 13CB 3E          	mov [d], al	; store left char into right side
0029++ 13CC 1B          	mov al, bl
0030++ 13CD F7          	stosb		; store right-side char into left-side; increase DI
0031++ 13CE 7E          	dec c
0032++ 13CF 7F          	dec d
0033++ 13D0 C2 00 00    	cmp c, 0
0034++ 13D3 C7 C9 13    	jne _strrev_L0
0035++ 13D6             _strrev_end:
0036++ 13D6 4C          	popa
0037++ 13D7 09          	ret
0038++ 13D8             	
0039++ 13D8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 13D8             ; _strchr
0041++ 13D8             ; search string in D for char in AL
0042++ 13D8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 13D8             _strchr:
0044++ 13D8             _strchr_L0:
0045++ 13D8 32          	mov bl, [d]
0046++ 13D9 C1 00       	cmp bl, 0
0047++ 13DB C6 E6 13    	je _strchr_end
0048++ 13DE BA          	cmp al, bl
0049++ 13DF C6 E6 13    	je _strchr_end
0050++ 13E2 79          	inc d
0051++ 13E3 0A D8 13    	jmp _strchr_L0
0052++ 13E6             _strchr_end:
0053++ 13E6 1B          	mov al, bl
0054++ 13E7 09          	ret
0055++ 13E8             
0056++ 13E8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 13E8             ; _strstr
0058++ 13E8             ; find sub-string
0059++ 13E8             ; str1 in SI
0060++ 13E8             ; str2 in DI
0061++ 13E8             ; SI points to end of source string
0062++ 13E8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 13E8             _strstr:
0064++ 13E8 DB          	push al
0065++ 13E9 DA          	push d
0066++ 13EA E3          	push di
0067++ 13EB             _strstr_loop:
0068++ 13EB F3          	cmpsb					; compare a byte of the strings
0069++ 13EC C7 F7 13    	jne _strstr_ret
0070++ 13EF FC 00 00    	lea d, [di + 0]
0071++ 13F2 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 13F4 C7 EB 13    	jne _strstr_loop				; equal chars but not at end
0073++ 13F7             _strstr_ret:
0074++ 13F7 F0          	pop di
0075++ 13F8 E7          	pop d
0076++ 13F9 E8          	pop al
0077++ 13FA 09          	ret
0078++ 13FB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 13FB             ; length of null terminated string
0080++ 13FB             ; result in C
0081++ 13FB             ; pointer in D
0082++ 13FB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 13FB             _strlen:
0084++ 13FB DA          	push d
0085++ 13FC 38 00 00    	mov c, 0
0086++ 13FF             _strlen_L1:
0087++ 13FF BD 00       	cmp byte [d], 0
0088++ 1401 C6 09 14    	je _strlen_ret
0089++ 1404 79          	inc d
0090++ 1405 78          	inc c
0091++ 1406 0A FF 13    	jmp _strlen_L1
0092++ 1409             _strlen_ret:
0093++ 1409 E7          	pop d
0094++ 140A 09          	ret
0095++ 140B             
0096++ 140B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 140B             ; STRCMP
0098++ 140B             ; compare two strings
0099++ 140B             ; str1 in SI
0100++ 140B             ; str2 in DI
0101++ 140B             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 140B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 140B             _strcmp:
0104++ 140B DB          	push al
0105++ 140C DA          	push d
0106++ 140D E3          	push di
0107++ 140E E2          	push si
0108++ 140F             _strcmp_loop:
0109++ 140F F3          	cmpsb					; compare a byte of the strings
0110++ 1410 C7 1B 14    	jne _strcmp_ret
0111++ 1413 FB FF FF    	lea d, [si +- 1]
0112++ 1416 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1418 C7 0F 14    	jne _strcmp_loop				; equal chars but not at end
0114++ 141B             _strcmp_ret:
0115++ 141B EF          	pop si
0116++ 141C F0          	pop di
0117++ 141D E7          	pop d
0118++ 141E E8          	pop al
0119++ 141F 09          	ret
0120++ 1420             
0121++ 1420             
0122++ 1420             ; STRCPY
0123++ 1420             ; copy null terminated string from SI to DI
0124++ 1420             ; source in SI
0125++ 1420             ; destination in DI
0126++ 1420             _strcpy:
0127++ 1420 E2          	push si
0128++ 1421 E3          	push di
0129++ 1422 DB          	push al
0130++ 1423             _strcpy_L1:
0131++ 1423 F6          	lodsb
0132++ 1424 F7          	stosb
0133++ 1425 B9 00       	cmp al, 0
0134++ 1427 C7 23 14    	jne _strcpy_L1
0135++ 142A             _strcpy_end:
0136++ 142A E8          	pop al
0137++ 142B F0          	pop di
0138++ 142C EF          	pop si
0139++ 142D 09          	ret
0140++ 142E             
0141++ 142E             ; STRCAT
0142++ 142E             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 142E             ; source in SI
0144++ 142E             ; destination in DI
0145++ 142E             _strcat:
0146++ 142E E2          	push si
0147++ 142F E3          	push di
0148++ 1430 D7          	push a
0149++ 1431 DA          	push d
0150++ 1432 50          	mov a, di
0151++ 1433 3C          	mov d, a
0152++ 1434             _strcat_goto_end_L1:
0153++ 1434 BD 00       	cmp byte[d], 0
0154++ 1436 C6 3D 14    	je _strcat_start
0155++ 1439 79          	inc d
0156++ 143A 0A 34 14    	jmp _strcat_goto_end_L1
0157++ 143D             _strcat_start:
0158++ 143D FD 50       	mov di, d
0159++ 143F             _strcat_L1:
0160++ 143F F6          	lodsb
0161++ 1440 F7          	stosb
0162++ 1441 B9 00       	cmp al, 0
0163++ 1443 C7 3F 14    	jne _strcat_L1
0164++ 1446             _strcat_end:
0165++ 1446 E7          	pop d
0166++ 1447 E4          	pop a
0167++ 1448 F0          	pop di
0168++ 1449 EF          	pop si
0169++ 144A 09          	ret
0170++ 144B             
0171++ 144B             
0005+  144B             
0006+  144B             ;-----------------------------------------------------------------------------
0007+  144B             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0008+  144B             ; ASCII in BL
0009+  144B             ; result in AL
0010+  144B             ; ascii for F = 0100 0110
0011+  144B             ; ascii for 9 = 0011 1001
0012+  144B             ;-----------------------------------------------------------------------------
0013+  144B             hex_ascii_encode:
0014+  144B 1B            mov al, bl
0015+  144C 93 40         test al, $40        ; test if letter or number
0016+  144E C7 54 14      jnz hex_letter
0017+  1451 87 0F         and al, $0F        ; get number
0018+  1453 09            ret
0019+  1454             hex_letter:
0020+  1454 87 0F         and al, $0F        ; get letter
0021+  1456 6A 09         add al, 9
0022+  1458 09            ret
0023+  1459             
0024+  1459             ;-----------------------------------------------------------------------------
0025+  1459             ; ATOI
0026+  1459             ; 2 letter hex string in B
0027+  1459             ; 8bit integer returned in AL
0028+  1459             ;-----------------------------------------------------------------------------
0029+  1459             _atoi:
0030+  1459 D8            push b
0031+  145A 07 4B 14      call hex_ascii_encode      ; convert BL to 4bit code in AL
0032+  145D 30            mov bl, bh
0033+  145E DB            push al          ; save a
0034+  145F 07 4B 14      call hex_ascii_encode
0035+  1462 EA            pop bl  
0036+  1463 FD 9E 04      shl al, 4
0037+  1466 8C            or al, bl
0038+  1467 E5            pop b
0039+  1468 09            ret  
0040+  1469             
0041+  1469             
0042+  1469             ;-----------------------------------------------------------------------------
0043+  1469             ; ITOA
0044+  1469             ; 8bit value in BL
0045+  1469             ; 2 byte ASCII result in A
0046+  1469             ;-----------------------------------------------------------------------------
0047+  1469             _itoa:
0048+  1469 DA            push d
0049+  146A D8            push b
0050+  146B A7 00         mov bh, 0
0051+  146D FD A4 04      shr bl, 4  
0052+  1470 74            mov d, b
0053+  1471 1F 19 17      mov al, [d + s_hex_digits]
0054+  1474 23            mov ah, al
0055+  1475               
0056+  1475 E5            pop b
0057+  1476 D8            push b
0058+  1477 A7 00         mov bh, 0
0059+  1479 FD 87 0F      and bl, $0F
0060+  147C 74            mov d, b
0061+  147D 1F 19 17      mov al, [d + s_hex_digits]
0062+  1480 E5            pop b
0063+  1481 E7            pop d
0064+  1482 09            ret
0065+  1483             
0066+  1483             ;-----------------------------------------------------------------------------
0067+  1483             ; HEX STRING TO BINARY
0068+  1483             ; di = destination address
0069+  1483             ; si = source
0070+  1483             ;-----------------------------------------------------------------------------
0071+  1483             _hex_to_int:
0072+  1483             _hex_to_int_L1:
0073+  1483 F6            lodsb          ; load from [SI] to AL
0074+  1484 B9 00         cmp al, 0        ; check if ASCII 0
0075+  1486 C6 93 14      jz _hex_to_int_ret
0076+  1489 36            mov bh, al
0077+  148A F6            lodsb
0078+  148B 2F            mov bl, al
0079+  148C 07 59 14      call _atoi        ; convert ASCII byte in B to int (to AL)
0080+  148F F7            stosb          ; store AL to [DI]
0081+  1490 0A 83 14      jmp _hex_to_int_L1
0082+  1493             _hex_to_int_ret:
0083+  1493 09            ret    
0084+  1494             
0085+  1494             ;-----------------------------------------------------------------------------
0086+  1494             ; GETCHAR
0087+  1494             ; char in ah
0088+  1494             ;-----------------------------------------------------------------------------
0089+  1494             getch:
0090+  1494 DB            push al
0091+  1495             getch_retry:
0092+  1495 19 01         mov al, 1
0093+  1497 05 03         syscall sys_io      ; receive in AH
0094+  1499 E8            pop al
0095+  149A 09            ret
0096+  149B             
0097+  149B             ;-----------------------------------------------------------------------------
0098+  149B             ; PUTCHAR
0099+  149B             ; char in ah
0100+  149B             ;-----------------------------------------------------------------------------
0101+  149B             _putchar:
0102+  149B D7            push a
0103+  149C 19 00         mov al, 0
0104+  149E 05 03         syscall sys_io      ; char in AH
0105+  14A0 E4            pop a
0106+  14A1 09            ret
0107+  14A2             
0108+  14A2             ;-----------------------------------------------------------------------------
0109+  14A2             ;; INPUT A STRING
0110+  14A2             ;; terminates with null
0111+  14A2             ;; pointer in D
0112+  14A2             ;-----------------------------------------------------------------------------
0113+  14A2             _gets:
0114+  14A2 D7            push a
0115+  14A3 DA            push d
0116+  14A4             _gets_loop:
0117+  14A4 19 01         mov al, 1
0118+  14A6 05 03         syscall sys_io      ; receive in AH
0119+  14A8 B9 00         cmp al, 0        ; check error code (AL)
0120+  14AA C6 A4 14      je _gets_loop      ; if no char received, retry
0121+  14AD             
0122+  14AD 76 1B         cmp ah, 27
0123+  14AF C6 D0 14      je _gets_ansi_esc
0124+  14B2 76 0A         cmp ah, $0A        ; LF
0125+  14B4 C6 3B 15      je _gets_end
0126+  14B7 76 0D         cmp ah, $0D        ; CR
0127+  14B9 C6 3B 15      je _gets_end
0128+  14BC 76 5C         cmp ah, $5C        ; '\\'
0129+  14BE C6 FC 14      je _gets_escape
0130+  14C1               
0131+  14C1 76 08         cmp ah, $08      ; check for backspace
0132+  14C3 C6 CC 14      je _gets_backspace
0133+  14C6             
0134+  14C6 1A            mov al, ah
0135+  14C7 3E            mov [d], al
0136+  14C8 79            inc d
0137+  14C9 0A A4 14      jmp _gets_loop
0138+  14CC             _gets_backspace:
0139+  14CC 7F            dec d
0140+  14CD 0A A4 14      jmp _gets_loop
0141+  14D0             _gets_ansi_esc:
0142+  14D0 19 01         mov al, 1
0143+  14D2 05 03         syscall sys_io        ; receive in AH without echo
0144+  14D4 B9 00         cmp al, 0          ; check error code (AL)
0145+  14D6 C6 D0 14      je _gets_ansi_esc    ; if no char received, retry
0146+  14D9 76 5B         cmp ah, '['
0147+  14DB C7 A4 14      jne _gets_loop
0148+  14DE             _gets_ansi_esc_2:
0149+  14DE 19 01         mov al, 1
0150+  14E0 05 03         syscall sys_io          ; receive in AH without echo
0151+  14E2 B9 00         cmp al, 0            ; check error code (AL)
0152+  14E4 C6 DE 14      je _gets_ansi_esc_2  ; if no char received, retry
0153+  14E7 76 44         cmp ah, 'D'
0154+  14E9 C6 F4 14      je _gets_left_arrow
0155+  14EC 76 43         cmp ah, 'C'
0156+  14EE C6 F8 14      je _gets_right_arrow
0157+  14F1 0A A4 14      jmp _gets_loop
0158+  14F4             _gets_left_arrow:
0159+  14F4 7F            dec d
0160+  14F5 0A A4 14      jmp _gets_loop
0161+  14F8             _gets_right_arrow:
0162+  14F8 79            inc d
0163+  14F9 0A A4 14      jmp _gets_loop
0164+  14FC             _gets_escape:
0165+  14FC 19 01         mov al, 1
0166+  14FE 05 03         syscall sys_io      ; receive in AH
0167+  1500 B9 00         cmp al, 0        ; check error code (AL)
0168+  1502 C6 FC 14      je _gets_escape      ; if no char received, retry
0169+  1505 76 6E         cmp ah, 'n'
0170+  1507 C6 26 15      je _gets_LF
0171+  150A 76 72         cmp ah, 'r'
0172+  150C C6 2D 15      je _gets_CR
0173+  150F 76 30         cmp ah, '0'
0174+  1511 C6 34 15      je _gets_NULL
0175+  1514 76 5C         cmp ah, $5C  ; '\'
0176+  1516 C6 1F 15      je _gets_slash
0177+  1519 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0178+  151A 3E            mov [d], al
0179+  151B 79            inc d
0180+  151C 0A A4 14      jmp _gets_loop
0181+  151F             _gets_slash:
0182+  151F 19 5C         mov al, $5C
0183+  1521 3E            mov [d], al
0184+  1522 79            inc d
0185+  1523 0A A4 14      jmp _gets_loop
0186+  1526             _gets_LF:
0187+  1526 19 0A         mov al, $0A
0188+  1528 3E            mov [d], al
0189+  1529 79            inc d
0190+  152A 0A A4 14      jmp _gets_loop
0191+  152D             _gets_CR:
0192+  152D 19 0D         mov al, $0D
0193+  152F 3E            mov [d], al
0194+  1530 79            inc d
0195+  1531 0A A4 14      jmp _gets_loop
0196+  1534             _gets_NULL:
0197+  1534 19 00         mov al, $00
0198+  1536 3E            mov [d], al
0199+  1537 79            inc d
0200+  1538 0A A4 14      jmp _gets_loop
0201+  153B             _gets_end:
0202+  153B 19 00         mov al, 0
0203+  153D 3E            mov [d], al        ; terminate string
0204+  153E E7            pop d
0205+  153F E4            pop a
0206+  1540 09            ret
0207+  1541             
0208+  1541             ;-----------------------------------------------------------------------------
0209+  1541             ;; INPUT TEXT
0210+  1541             ;; terminated with CTRL+D
0211+  1541             ;; pointer in D
0212+  1541             ;-----------------------------------------------------------------------------
0213+  1541             _gettxt:
0214+  1541 D7            push a
0215+  1542 DA            push d
0216+  1543             _gettxt_loop:
0217+  1543 19 01         mov al, 1
0218+  1545 05 03         syscall sys_io      ; receive in AH
0219+  1547 B9 00         cmp al, 0        ; check error code (AL)
0220+  1549 C6 43 15      je _gettxt_loop    ; if no char received, retry
0221+  154C 76 04         cmp ah, 4      ; EOT
0222+  154E C6 8C 15      je _gettxt_end
0223+  1551 76 08         cmp ah, $08      ; check for backspace
0224+  1553 C6 88 15      je _gettxt_backspace
0225+  1556 76 5C         cmp ah, $5C        ; '\'
0226+  1558 C6 61 15      je _gettxt_escape
0227+  155B 1A            mov al, ah
0228+  155C 3E            mov [d], al
0229+  155D 79            inc d
0230+  155E 0A 43 15      jmp _gettxt_loop
0231+  1561             _gettxt_escape:
0232+  1561 19 01         mov al, 1
0233+  1563 05 03         syscall sys_io      ; receive in AH
0234+  1565 B9 00         cmp al, 0        ; check error code (AL)
0235+  1567 C6 61 15      je _gettxt_escape    ; if no char received, retry
0236+  156A 76 6E         cmp ah, 'n'
0237+  156C C6 7A 15      je _gettxt_LF
0238+  156F 76 72         cmp ah, 'r'
0239+  1571 C6 81 15      je _gettxt_CR
0240+  1574 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0241+  1575 3E            mov [d], al
0242+  1576 79            inc d
0243+  1577 0A 43 15      jmp _gettxt_loop
0244+  157A             _gettxt_LF:
0245+  157A 19 0A         mov al, $0A
0246+  157C 3E            mov [d], al
0247+  157D 79            inc d
0248+  157E 0A 43 15      jmp _gettxt_loop
0249+  1581             _gettxt_CR:
0250+  1581 19 0D         mov al, $0D
0251+  1583 3E            mov [d], al
0252+  1584 79            inc d
0253+  1585 0A 43 15      jmp _gettxt_loop
0254+  1588             _gettxt_backspace:
0255+  1588 7F            dec d
0256+  1589 0A 43 15      jmp _gettxt_loop
0257+  158C             _gettxt_end:
0258+  158C 19 00         mov al, 0
0259+  158E 3E            mov [d], al        ; terminate string
0260+  158F E7            pop d
0261+  1590 E4            pop a
0262+  1591 09            ret
0263+  1592             
0264+  1592             ;-----------------------------------------------------------------------------
0265+  1592             ; PRINT NEW LINE
0266+  1592             ;-----------------------------------------------------------------------------
0267+  1592             printnl:
0268+  1592 D7            push a
0269+  1593 10 00 0A      mov a, $0A00
0270+  1596 05 03         syscall sys_io
0271+  1598 10 00 0D      mov a, $0D00
0272+  159B 05 03         syscall sys_io
0273+  159D E4            pop a
0274+  159E 09            ret
0275+  159F             
0276+  159F             ;-----------------------------------------------------------------------------
0277+  159F             ; _strtoint
0278+  159F             ; 4 digit hex string number in d
0279+  159F             ; integer returned in A
0280+  159F             ;-----------------------------------------------------------------------------
0281+  159F             _strtointx:
0282+  159F D8            push b
0283+  15A0 32            mov bl, [d]
0284+  15A1 37            mov bh, bl
0285+  15A2 33 01 00      mov bl, [d + 1]
0286+  15A5 07 59 14      call _atoi        ; convert to int in AL
0287+  15A8 23            mov ah, al        ; move to AH
0288+  15A9 33 02 00      mov bl, [d + 2]
0289+  15AC 37            mov bh, bl
0290+  15AD 33 03 00      mov bl, [d + 3]
0291+  15B0 07 59 14      call _atoi        ; convert to int in AL
0292+  15B3 E5            pop b
0293+  15B4 09            ret
0294+  15B5             
0295+  15B5             ;-----------------------------------------------------------------------------
0296+  15B5             ; _strtoint
0297+  15B5             ; 5 digit base10 string number in d
0298+  15B5             ; integer returned in A
0299+  15B5             ;-----------------------------------------------------------------------------
0300+  15B5             _strtoint:
0301+  15B5 E2            push si
0302+  15B6 D8            push b
0303+  15B7 D9            push c
0304+  15B8 DA            push d
0305+  15B9 07 FB 13      call _strlen      ; get string length in C
0306+  15BC 7E            dec c
0307+  15BD FD 4E         mov si, d
0308+  15BF 12            mov a, c
0309+  15C0 FD 99         shl a
0310+  15C2 3B 31 17      mov d, table_power
0311+  15C5 59            add d, a
0312+  15C6 38 00 00      mov c, 0
0313+  15C9             _strtoint_L0:
0314+  15C9 F6            lodsb      ; load ASCII to al
0315+  15CA B9 00         cmp al, 0
0316+  15CC C6 DF 15      je _strtoint_end
0317+  15CF 6F 30         sub al, $30    ; make into integer
0318+  15D1 22 00         mov ah, 0
0319+  15D3 2A            mov b, [d]
0320+  15D4 AC            mul a, b      ; result in B since it fits in 16bits
0321+  15D5 11            mov a, b
0322+  15D6 28            mov b, c
0323+  15D7 54            add a, b
0324+  15D8 39            mov c, a
0325+  15D9 63 02 00      sub d, 2
0326+  15DC 0A C9 15      jmp _strtoint_L0
0327+  15DF             _strtoint_end:
0328+  15DF 12            mov a, c
0329+  15E0 E7            pop d
0330+  15E1 E6            pop c
0331+  15E2 E5            pop b
0332+  15E3 EF            pop si
0333+  15E4 09            ret
0334+  15E5             
0335+  15E5             ;-----------------------------------------------------------------------------
0336+  15E5             ; PRINT NULL TERMINATED STRING
0337+  15E5             ; pointer in D
0338+  15E5             ;-----------------------------------------------------------------------------
0339+  15E5             _puts:
0340+  15E5 D7            push a
0341+  15E6 DA            push d
0342+  15E7             _puts_L1:
0343+  15E7 1E            mov al, [d]
0344+  15E8 B9 00         cmp al, 0
0345+  15EA C6 F6 15      jz _puts_END
0346+  15ED 23            mov ah, al
0347+  15EE 19 00         mov al, 0
0348+  15F0 05 03         syscall sys_io
0349+  15F2 79            inc d
0350+  15F3 0A E7 15      jmp _puts_L1
0351+  15F6             _puts_END:
0352+  15F6 E7            pop d
0353+  15F7 E4            pop a
0354+  15F8 09            ret
0355+  15F9             
0356+  15F9             ;-----------------------------------------------------------------------------
0357+  15F9             ; PRINT N SIZE STRING
0358+  15F9             ; pointer in D
0359+  15F9             ; size in C
0360+  15F9             ;-----------------------------------------------------------------------------
0361+  15F9             _putsn:
0362+  15F9 DB            push al
0363+  15FA DA            push d
0364+  15FB D9            push c
0365+  15FC             _putsn_L0:
0366+  15FC 1E            mov al, [d]
0367+  15FD 23            mov ah, al
0368+  15FE 19 00         mov al, 0
0369+  1600 05 03         syscall sys_io
0370+  1602 79            inc d
0371+  1603 7E            dec c  
0372+  1604 C2 00 00      cmp c, 0
0373+  1607 C7 FC 15      jne _putsn_L0
0374+  160A             _putsn_end:
0375+  160A E6            pop c
0376+  160B E7            pop d
0377+  160C E8            pop al
0378+  160D 09            ret
0379+  160E             
0380+  160E             ;-----------------------------------------------------------------------------
0381+  160E             ; print 16bit decimal number
0382+  160E             ; input number in A
0383+  160E             ;-----------------------------------------------------------------------------
0384+  160E             print_u16d:
0385+  160E D7            push a
0386+  160F D8            push b
0387+  1610 26 10 27      mov b, 10000
0388+  1613 AE            div a, b      ; get 10000's coeff.
0389+  1614 07 36 16      call print_number
0390+  1617 11            mov a, b
0391+  1618 26 E8 03      mov b, 1000
0392+  161B AE            div a, b      ; get 1000's coeff.
0393+  161C 07 36 16      call print_number
0394+  161F 11            mov a, b
0395+  1620 26 64 00      mov b, 100
0396+  1623 AE            div a, b
0397+  1624 07 36 16      call print_number
0398+  1627 11            mov a, b
0399+  1628 26 0A 00      mov b, 10
0400+  162B AE            div a, b
0401+  162C 07 36 16      call print_number
0402+  162F 1B            mov al, bl      ; 1's coeff in bl
0403+  1630 07 36 16      call print_number
0404+  1633 E5            pop b
0405+  1634 E4            pop a
0406+  1635 09            ret
0407+  1636             
0408+  1636             ;-----------------------------------------------------------------------------
0409+  1636             ; print AL
0410+  1636             ;-----------------------------------------------------------------------------
0411+  1636             print_number:
0412+  1636 6A 30         add al, $30
0413+  1638 23            mov ah, al
0414+  1639 07 9B 14      call _putchar
0415+  163C 09            ret
0416+  163D             
0417+  163D             ;-----------------------------------------------------------------------------
0418+  163D             ; PRINT 16BIT HEX INTEGER
0419+  163D             ; integer value in reg B
0420+  163D             ;-----------------------------------------------------------------------------
0421+  163D             print_u16x:
0422+  163D D7            push a
0423+  163E D8            push b
0424+  163F DD            push bl
0425+  1640 30            mov bl, bh
0426+  1641 07 69 14      call _itoa        ; convert bh to char in A
0427+  1644 2F            mov bl, al        ; save al
0428+  1645 19 00         mov al, 0
0429+  1647 05 03         syscall sys_io        ; display AH
0430+  1649 24            mov ah, bl        ; retrieve al
0431+  164A 19 00         mov al, 0
0432+  164C 05 03         syscall sys_io        ; display AL
0433+  164E             
0434+  164E EA            pop bl
0435+  164F 07 69 14      call _itoa        ; convert bh to char in A
0436+  1652 2F            mov bl, al        ; save al
0437+  1653 19 00         mov al, 0
0438+  1655 05 03         syscall sys_io        ; display AH
0439+  1657 24            mov ah, bl        ; retrieve al
0440+  1658 19 00         mov al, 0
0441+  165A 05 03         syscall sys_io        ; display AL
0442+  165C             
0443+  165C E5            pop b
0444+  165D E4            pop a
0445+  165E 09            ret
0446+  165F             
0447+  165F             ;-----------------------------------------------------------------------------
0448+  165F             ; INPUT 16BIT HEX INTEGER
0449+  165F             ; read 16bit integer into A
0450+  165F             ;-----------------------------------------------------------------------------
0451+  165F             scan_u16x:
0452+  165F F8 10 00      enter 16
0453+  1662 D8            push b
0454+  1663 DA            push d
0455+  1664             
0456+  1664 FA F1 FF      lea d, [bp + -15]
0457+  1667 07 A2 14      call _gets        ; get number
0458+  166A             
0459+  166A 32            mov bl, [d]
0460+  166B 37            mov bh, bl
0461+  166C 33 01 00      mov bl, [d + 1]
0462+  166F 07 59 14      call _atoi        ; convert to int in AL
0463+  1672 23            mov ah, al        ; move to AH
0464+  1673             
0465+  1673 33 02 00      mov bl, [d + 2]
0466+  1676 37            mov bh, bl
0467+  1677 33 03 00      mov bl, [d + 3]
0468+  167A 07 59 14      call _atoi        ; convert to int in AL
0469+  167D             
0470+  167D E7            pop d
0471+  167E E5            pop b
0472+  167F F9            leave
0473+  1680 09            ret
0474+  1681             
0475+  1681             ;-----------------------------------------------------------------------------
0476+  1681             ; PRINT 8bit HEX INTEGER
0477+  1681             ; integer value in reg bl
0478+  1681             ;-----------------------------------------------------------------------------
0479+  1681             print_u8x:
0480+  1681 D7            push a
0481+  1682 DD            push bl
0482+  1683             
0483+  1683 07 69 14      call _itoa        ; convert bl to char in A
0484+  1686 2F            mov bl, al        ; save al
0485+  1687 19 00         mov al, 0
0486+  1689 05 03         syscall sys_io        ; display AH
0487+  168B 24            mov ah, bl        ; retrieve al
0488+  168C 19 00         mov al, 0
0489+  168E 05 03         syscall sys_io        ; display AL
0490+  1690             
0491+  1690 EA            pop bl
0492+  1691 E4            pop a
0493+  1692 09            ret
0494+  1693             
0495+  1693             ;-----------------------------------------------------------------------------
0496+  1693             ; print 8bit decimal unsigned number
0497+  1693             ; input number in AL
0498+  1693             ;-----------------------------------------------------------------------------
0499+  1693             print_u8d:
0500+  1693 D7            push a
0501+  1694 D8            push b
0502+  1695             
0503+  1695 22 00         mov ah, 0
0504+  1697 26 64 00      mov b, 100
0505+  169A AE            div a, b
0506+  169B D8            push b      ; save remainder
0507+  169C B9 00         cmp al, 0
0508+  169E C6 A8 16      je skip100
0509+  16A1 6A 30         add al, $30
0510+  16A3 23            mov ah, al
0511+  16A4 19 00         mov al, 0
0512+  16A6 05 03         syscall sys_io  ; print coeff
0513+  16A8             skip100:
0514+  16A8 E4            pop a
0515+  16A9 22 00         mov ah, 0
0516+  16AB 26 0A 00      mov b, 10
0517+  16AE AE            div a, b
0518+  16AF D8            push b      ; save remainder
0519+  16B0 B9 00         cmp al, 0
0520+  16B2 C6 BC 16      je skip10
0521+  16B5 6A 30         add al, $30
0522+  16B7 23            mov ah, al
0523+  16B8 19 00         mov al, 0
0524+  16BA 05 03         syscall sys_io  ; print coeff
0525+  16BC             skip10:
0526+  16BC E4            pop a
0527+  16BD 1B            mov al, bl
0528+  16BE 6A 30         add al, $30
0529+  16C0 23            mov ah, al
0530+  16C1 19 00         mov al, 0
0531+  16C3 05 03         syscall sys_io  ; print coeff
0532+  16C5 E5            pop b
0533+  16C6 E4            pop a
0534+  16C7 09            ret
0535+  16C8             
0536+  16C8             ;-----------------------------------------------------------------------------
0537+  16C8             ; INPUT 8BIT HEX INTEGER
0538+  16C8             ; read 8bit integer into AL
0539+  16C8             ;-----------------------------------------------------------------------------
0540+  16C8             scan_u8x:
0541+  16C8 F8 04 00      enter 4
0542+  16CB D8            push b
0543+  16CC DA            push d
0544+  16CD             
0545+  16CD FA FD FF      lea d, [bp + -3]
0546+  16D0 07 A2 14      call _gets        ; get number
0547+  16D3             
0548+  16D3 32            mov bl, [d]
0549+  16D4 37            mov bh, bl
0550+  16D5 33 01 00      mov bl, [d + 1]
0551+  16D8 07 59 14      call _atoi        ; convert to int in AL
0552+  16DB             
0553+  16DB E7            pop d
0554+  16DC E5            pop b
0555+  16DD F9            leave
0556+  16DE 09            ret
0557+  16DF             
0558+  16DF             ;-----------------------------------------------------------------------------
0559+  16DF             ; input decimal number
0560+  16DF             ; result in A
0561+  16DF             ; 655'\0'
0562+  16DF             ; low--------high
0563+  16DF             ;-----------------------------------------------------------------------------
0564+  16DF             scan_u16d:
0565+  16DF F8 08 00      enter 8
0566+  16E2 E2            push si
0567+  16E3 D8            push b
0568+  16E4 D9            push c
0569+  16E5 DA            push d
0570+  16E6 FA F9 FF      lea d, [bp +- 7]
0571+  16E9 07 A2 14      call _gets
0572+  16EC 07 FB 13      call _strlen      ; get string length in C
0573+  16EF 7E            dec c
0574+  16F0 FD 4E         mov si, d
0575+  16F2 12            mov a, c
0576+  16F3 FD 99         shl a
0577+  16F5 3B 31 17      mov d, table_power
0578+  16F8 59            add d, a
0579+  16F9 38 00 00      mov c, 0
0580+  16FC             mul_loop:
0581+  16FC F6            lodsb      ; load ASCII to al
0582+  16FD B9 00         cmp al, 0
0583+  16FF C6 12 17      je mul_exit
0584+  1702 6F 30         sub al, $30    ; make into integer
0585+  1704 22 00         mov ah, 0
0586+  1706 2A            mov b, [d]
0587+  1707 AC            mul a, b      ; result in B since it fits in 16bits
0588+  1708 11            mov a, b
0589+  1709 28            mov b, c
0590+  170A 54            add a, b
0591+  170B 39            mov c, a
0592+  170C 63 02 00      sub d, 2
0593+  170F 0A FC 16      jmp mul_loop
0594+  1712             mul_exit:
0595+  1712 12            mov a, c
0596+  1713 E7            pop d
0597+  1714 E6            pop c
0598+  1715 E5            pop b
0599+  1716 EF            pop si
0600+  1717 F9            leave
0601+  1718 09            ret
0602+  1719             
0603+  1719 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0603+  171D 34 35 36 37 
0603+  1721 38 39 41 42 
0603+  1725 43 44 45 46 
0604+  1729 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0604+  172D 1B 5B 48 00 
0605+  1731             
0606+  1731             table_power:
0607+  1731 01 00         .dw 1
0608+  1733 0A 00         .dw 10
0609+  1735 64 00         .dw 100
0610+  1737 E8 03         .dw 1000
0611+  1739 10 27         .dw 100002347   173B             ; --- END INLINE ASM BLOCK
2348   173B             
2349   173B F9            leave
2350   173C 09            ret
2351   173D             ; --- END TEXT BLOCK
2352   173D             
2353   173D             ; --- BEGIN DATA BLOCK
2354   173D 00 00 00    _klin_data: .fill 3, 0
2355   1740 00 00       _k: .fill 2, 0
2356   1742 55 6E 65 78 __s0: .db "Unexpected format in printf.", 0
2356   1746 70 65 63 74 
2356   174A 65 64 20 66 
2356   174E 6F 72 6D 61 
2356   1752 74 20 69 6E 
2356   1756 20 70 72 69 
2356   175A 6E 74 66 2E 
2356   175E 00 
2357   175F 45 72 72 6F __s1: .db "Error: Unknown argument type.\n", 0
2357   1763 72 3A 20 55 
2357   1767 6E 6B 6E 6F 
2357   176B 77 6E 20 61 
2357   176F 72 67 75 6D 
2357   1773 65 6E 74 20 
2357   1777 74 79 70 65 
2357   177B 2E 0A 00 
2358   177E 1B 5B 32 4A __s2: .db "\033[2J\033[H", 0
2358   1782 1B 5B 48 00 
2359   1786             
2360   1786 88 17       _heap_top: .dw _heap
2361   1788 00          _heap: .db 0
2362   1789             ; --- END DATA BLOCK
2363   1789             
2364   1789             .end
tasm: Number of errors = 16
