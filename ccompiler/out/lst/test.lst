0001   0000             ; --- FILENAME: test
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ;; printx32(0xAABBCCDDL); 
0011   0408 26 DD CC      mov b, $ccdd
0012   040B 38 BB AA      mov c, $aabb
0013   040E FD 79         mov g, b
0014   0410 28            mov b, c
0015   0411 FD AB         swp b
0016   0413 D8            push b
0017   0414 FD 27         mov b, g
0018   0416 D8            push b
0019   0417 07 3C 08      call printx32
0020   041A 51 04 00      add sp, 4
0021   041D 05 0B         syscall sys_terminate_proc
0022   041F             
0023   041F             strcpy:
0024   041F F8 00 00      enter 0 ; (push bp; mov bp, sp)
0025   0422             ; $psrc 
0026   0422             ; $pdest 
0027   0422 52 04 00      sub sp, 4
0028   0425             ;; psrc = src; 
0029   0425 FA FF FF      lea d, [bp + -1] ; $psrc
0030   0428 DA            push d
0031   0429 FA 07 00      lea d, [bp + 7] ; $src
0032   042C 2A            mov b, [d]
0033   042D E7            pop d
0034   042E FD 43         mov [d], b
0035   0430             ;; pdest = dest; 
0036   0430 FA FD FF      lea d, [bp + -3] ; $pdest
0037   0433 DA            push d
0038   0434 FA 05 00      lea d, [bp + 5] ; $dest
0039   0437 2A            mov b, [d]
0040   0438 E7            pop d
0041   0439 FD 43         mov [d], b
0042   043B             ;; while(*psrc) *pdest++ = *psrc++; 
0043   043B             _while1_cond:
0044   043B FA FF FF      lea d, [bp + -1] ; $psrc
0045   043E 2A            mov b, [d]
0046   043F 74            mov d, b
0047   0440 32            mov bl, [d]
0048   0441 A7 00         mov bh, 0
0049   0443 C0 00 00      cmp b, 0
0050   0446 C6 6E 04      je _while1_exit
0051   0449             _while1_block:
0052   0449             ;; *pdest++ = *psrc++; 
0053   0449 FA FD FF      lea d, [bp + -3] ; $pdest
0054   044C 2A            mov b, [d]
0055   044D D8            push b
0056   044E FD 77         inc b
0057   0450 FA FD FF      lea d, [bp + -3] ; $pdest
0058   0453 FD 43         mov [d], b
0059   0455 E5            pop b
0060   0456 D8            push b
0061   0457 FA FF FF      lea d, [bp + -1] ; $psrc
0062   045A 2A            mov b, [d]
0063   045B D8            push b
0064   045C FD 77         inc b
0065   045E FA FF FF      lea d, [bp + -1] ; $psrc
0066   0461 FD 43         mov [d], b
0067   0463 E5            pop b
0068   0464 74            mov d, b
0069   0465 32            mov bl, [d]
0070   0466 A7 00         mov bh, 0
0071   0468 E7            pop d
0072   0469 FD 3E         mov [d], bl
0073   046B 0A 3B 04      jmp _while1_cond
0074   046E             _while1_exit:
0075   046E             ;; *pdest = '\0'; 
0076   046E FA FD FF      lea d, [bp + -3] ; $pdest
0077   0471 2A            mov b, [d]
0078   0472 D8            push b
0079   0473 26 00 00      mov b, $0
0080   0476 E7            pop d
0081   0477 FD 3E         mov [d], bl
0082   0479 F9            leave
0083   047A 09            ret
0084   047B             
0085   047B             strcmp:
0086   047B F8 00 00      enter 0 ; (push bp; mov bp, sp)
0087   047E             ;; while (*s1 && (*s1 == *s2)) { 
0088   047E             _while2_cond:
0089   047E FA 05 00      lea d, [bp + 5] ; $s1
0090   0481 2A            mov b, [d]
0091   0482 74            mov d, b
0092   0483 32            mov bl, [d]
0093   0484 A7 00         mov bh, 0
0094   0486 D7            push a
0095   0487 11            mov a, b
0096   0488 FA 05 00      lea d, [bp + 5] ; $s1
0097   048B 2A            mov b, [d]
0098   048C 74            mov d, b
0099   048D 32            mov bl, [d]
0100   048E A7 00         mov bh, 0
0101   0490             ; START RELATIONAL
0102   0490 D7            push a
0103   0491 11            mov a, b
0104   0492 FA 07 00      lea d, [bp + 7] ; $s2
0105   0495 2A            mov b, [d]
0106   0496 74            mov d, b
0107   0497 32            mov bl, [d]
0108   0498 A7 00         mov bh, 0
0109   049A B0            cmp a, b
0110   049B FD 71         seq ; ==
0111   049D E4            pop a
0112   049E             ; END RELATIONAL
0113   049E FD A7         sand a, b ; &&
0114   04A0 E4            pop a
0115   04A1 C0 00 00      cmp b, 0
0116   04A4 C6 C4 04      je _while2_exit
0117   04A7             _while2_block:
0118   04A7             ;; s1++; 
0119   04A7 FA 05 00      lea d, [bp + 5] ; $s1
0120   04AA 2A            mov b, [d]
0121   04AB D8            push b
0122   04AC FD 77         inc b
0123   04AE FA 05 00      lea d, [bp + 5] ; $s1
0124   04B1 FD 43         mov [d], b
0125   04B3 E5            pop b
0126   04B4             ;; s2++; 
0127   04B4 FA 07 00      lea d, [bp + 7] ; $s2
0128   04B7 2A            mov b, [d]
0129   04B8 D8            push b
0130   04B9 FD 77         inc b
0131   04BB FA 07 00      lea d, [bp + 7] ; $s2
0132   04BE FD 43         mov [d], b
0133   04C0 E5            pop b
0134   04C1 0A 7E 04      jmp _while2_cond
0135   04C4             _while2_exit:
0136   04C4             ;; return *s1 - *s2; 
0137   04C4 FA 05 00      lea d, [bp + 5] ; $s1
0138   04C7 2A            mov b, [d]
0139   04C8 74            mov d, b
0140   04C9 32            mov bl, [d]
0141   04CA A7 00         mov bh, 0
0142   04CC             ; START TERMS
0143   04CC D7            push a
0144   04CD 11            mov a, b
0145   04CE FA 07 00      lea d, [bp + 7] ; $s2
0146   04D1 2A            mov b, [d]
0147   04D2 74            mov d, b
0148   04D3 32            mov bl, [d]
0149   04D4 A7 00         mov bh, 0
0150   04D6 60            sub a, b
0151   04D7 27            mov b, a
0152   04D8 E4            pop a
0153   04D9             ; END TERMS
0154   04D9 F9            leave
0155   04DA 09            ret
0156   04DB             
0157   04DB             strcat:
0158   04DB F8 00 00      enter 0 ; (push bp; mov bp, sp)
0159   04DE             ; $dest_len 
0160   04DE             ; $i 
0161   04DE 52 04 00      sub sp, 4
0162   04E1             ;; dest_len = strlen(dest); 
0163   04E1 FA FF FF      lea d, [bp + -1] ; $dest_len
0164   04E4 DA            push d
0165   04E5 FA 05 00      lea d, [bp + 5] ; $dest
0166   04E8 2A            mov b, [d]
0167   04E9 FD AB         swp b
0168   04EB D8            push b
0169   04EC 07 91 05      call strlen
0170   04EF 51 02 00      add sp, 2
0171   04F2 E7            pop d
0172   04F3 FD 43         mov [d], b
0173   04F5             ;; for (i = 0; src[i] != 0; i=i+1) { 
0174   04F5             _for3_init:
0175   04F5 FA FD FF      lea d, [bp + -3] ; $i
0176   04F8 DA            push d
0177   04F9 26 00 00      mov b, $0
0178   04FC E7            pop d
0179   04FD FD 43         mov [d], b
0180   04FF             _for3_cond:
0181   04FF FA 07 00      lea d, [bp + 7] ; $src
0182   0502 FD 2A         mov d, [d]
0183   0504 D7            push a
0184   0505 DA            push d
0185   0506 FA FD FF      lea d, [bp + -3] ; $i
0186   0509 2A            mov b, [d]
0187   050A E7            pop d
0188   050B FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0189   050F E4            pop a
0190   0510 32            mov bl, [d]
0191   0511 A7 00         mov bh, 0
0192   0513             ; START RELATIONAL
0193   0513 D7            push a
0194   0514 11            mov a, b
0195   0515 26 00 00      mov b, $0
0196   0518 B0            cmp a, b
0197   0519 FD 72         sneq ; !=
0198   051B E4            pop a
0199   051C             ; END RELATIONAL
0200   051C C0 00 00      cmp b, 0
0201   051F C6 6A 05      je _for3_exit
0202   0522             _for3_block:
0203   0522             ;; dest[dest_len + i] = src[i]; 
0204   0522 FA 05 00      lea d, [bp + 5] ; $dest
0205   0525 FD 2A         mov d, [d]
0206   0527 D7            push a
0207   0528 DA            push d
0208   0529 FA FF FF      lea d, [bp + -1] ; $dest_len
0209   052C 2A            mov b, [d]
0210   052D             ; START TERMS
0211   052D D7            push a
0212   052E 11            mov a, b
0213   052F FA FD FF      lea d, [bp + -3] ; $i
0214   0532 2A            mov b, [d]
0215   0533 54            add a, b
0216   0534 27            mov b, a
0217   0535 E4            pop a
0218   0536             ; END TERMS
0219   0536 E7            pop d
0220   0537 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0221   053B E4            pop a
0222   053C DA            push d
0223   053D FA 07 00      lea d, [bp + 7] ; $src
0224   0540 FD 2A         mov d, [d]
0225   0542 D7            push a
0226   0543 DA            push d
0227   0544 FA FD FF      lea d, [bp + -3] ; $i
0228   0547 2A            mov b, [d]
0229   0548 E7            pop d
0230   0549 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0231   054D E4            pop a
0232   054E 32            mov bl, [d]
0233   054F A7 00         mov bh, 0
0234   0551 E7            pop d
0235   0552 FD 3E         mov [d], bl
0236   0554             _for3_update:
0237   0554 FA FD FF      lea d, [bp + -3] ; $i
0238   0557 DA            push d
0239   0558 FA FD FF      lea d, [bp + -3] ; $i
0240   055B 2A            mov b, [d]
0241   055C             ; START TERMS
0242   055C D7            push a
0243   055D 11            mov a, b
0244   055E 26 01 00      mov b, $1
0245   0561 54            add a, b
0246   0562 27            mov b, a
0247   0563 E4            pop a
0248   0564             ; END TERMS
0249   0564 E7            pop d
0250   0565 FD 43         mov [d], b
0251   0567 0A FF 04      jmp _for3_cond
0252   056A             _for3_exit:
0253   056A             ;; dest[dest_len + i] = 0; 
0254   056A FA 05 00      lea d, [bp + 5] ; $dest
0255   056D FD 2A         mov d, [d]
0256   056F D7            push a
0257   0570 DA            push d
0258   0571 FA FF FF      lea d, [bp + -1] ; $dest_len
0259   0574 2A            mov b, [d]
0260   0575             ; START TERMS
0261   0575 D7            push a
0262   0576 11            mov a, b
0263   0577 FA FD FF      lea d, [bp + -3] ; $i
0264   057A 2A            mov b, [d]
0265   057B 54            add a, b
0266   057C 27            mov b, a
0267   057D E4            pop a
0268   057E             ; END TERMS
0269   057E E7            pop d
0270   057F FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0271   0583 E4            pop a
0272   0584 DA            push d
0273   0585 26 00 00      mov b, $0
0274   0588 E7            pop d
0275   0589 FD 3E         mov [d], bl
0276   058B             ;; return dest; 
0277   058B FA 05 00      lea d, [bp + 5] ; $dest
0278   058E 2A            mov b, [d]
0279   058F F9            leave
0280   0590 09            ret
0281   0591             
0282   0591             strlen:
0283   0591 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0284   0594             ; $length 
0285   0594 52 02 00      sub sp, 2
0286   0597             ;; length = 0; 
0287   0597 FA FF FF      lea d, [bp + -1] ; $length
0288   059A DA            push d
0289   059B 26 00 00      mov b, $0
0290   059E E7            pop d
0291   059F FD 43         mov [d], b
0292   05A1             ;; while (str[length] != 0) { 
0293   05A1             _while4_cond:
0294   05A1 FA 05 00      lea d, [bp + 5] ; $str
0295   05A4 FD 2A         mov d, [d]
0296   05A6 D7            push a
0297   05A7 DA            push d
0298   05A8 FA FF FF      lea d, [bp + -1] ; $length
0299   05AB 2A            mov b, [d]
0300   05AC E7            pop d
0301   05AD FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0302   05B1 E4            pop a
0303   05B2 32            mov bl, [d]
0304   05B3 A7 00         mov bh, 0
0305   05B5             ; START RELATIONAL
0306   05B5 D7            push a
0307   05B6 11            mov a, b
0308   05B7 26 00 00      mov b, $0
0309   05BA B0            cmp a, b
0310   05BB FD 72         sneq ; !=
0311   05BD E4            pop a
0312   05BE             ; END RELATIONAL
0313   05BE C0 00 00      cmp b, 0
0314   05C1 C6 D4 05      je _while4_exit
0315   05C4             _while4_block:
0316   05C4             ;; length++; 
0317   05C4 FA FF FF      lea d, [bp + -1] ; $length
0318   05C7 2A            mov b, [d]
0319   05C8 D8            push b
0320   05C9 FD 77         inc b
0321   05CB FA FF FF      lea d, [bp + -1] ; $length
0322   05CE FD 43         mov [d], b
0323   05D0 E5            pop b
0324   05D1 0A A1 05      jmp _while4_cond
0325   05D4             _while4_exit:
0326   05D4             ;; return length; 
0327   05D4 FA FF FF      lea d, [bp + -1] ; $length
0328   05D7 2A            mov b, [d]
0329   05D8 F9            leave
0330   05D9 09            ret
0331   05DA             
0332   05DA             printf:
0333   05DA F8 00 00      enter 0 ; (push bp; mov bp, sp)
0334   05DD             ; $p 
0335   05DD             ; $fp 
0336   05DD             ; $i 
0337   05DD 52 06 00      sub sp, 6
0338   05E0             ;; fp = format; 
0339   05E0 FA FD FF      lea d, [bp + -3] ; $fp
0340   05E3 DA            push d
0341   05E4 FA 05 00      lea d, [bp + 5] ; $format
0342   05E7 2A            mov b, [d]
0343   05E8 E7            pop d
0344   05E9 FD 43         mov [d], b
0345   05EB             ;; p = &format + 2; 
0346   05EB FA FF FF      lea d, [bp + -1] ; $p
0347   05EE DA            push d
0348   05EF FA 05 00      lea d, [bp + 5] ; $format
0349   05F2 2D            mov b, d
0350   05F3             ; START TERMS
0351   05F3 D7            push a
0352   05F4 11            mov a, b
0353   05F5 26 02 00      mov b, $2
0354   05F8 54            add a, b
0355   05F9 27            mov b, a
0356   05FA E4            pop a
0357   05FB             ; END TERMS
0358   05FB E7            pop d
0359   05FC FD 43         mov [d], b
0360   05FE             ;; for(;;){ 
0361   05FE             _for5_init:
0362   05FE             _for5_cond:
0363   05FE             _for5_block:
0364   05FE             ;; if(!*fp) break; 
0365   05FE             _if6_cond:
0366   05FE FA FD FF      lea d, [bp + -3] ; $fp
0367   0601 2A            mov b, [d]
0368   0602 74            mov d, b
0369   0603 32            mov bl, [d]
0370   0604 A7 00         mov bh, 0
0371   0606 C0 00 00      cmp b, 0
0372   0609 FD 71         seq ; !
0373   060B C0 00 00      cmp b, 0
0374   060E C6 17 06      je _if6_else
0375   0611             _if6_true:
0376   0611             ;; break; 
0377   0611 0A 25 08      jmp _for5_exit ; for break
0378   0614 0A 22 08      jmp _if6_exit
0379   0617             _if6_else:
0380   0617             ;; if(*fp == '%'){ 
0381   0617             _if7_cond:
0382   0617 FA FD FF      lea d, [bp + -3] ; $fp
0383   061A 2A            mov b, [d]
0384   061B 74            mov d, b
0385   061C 32            mov bl, [d]
0386   061D A7 00         mov bh, 0
0387   061F             ; START RELATIONAL
0388   061F D7            push a
0389   0620 11            mov a, b
0390   0621 26 25 00      mov b, $25
0391   0624 B0            cmp a, b
0392   0625 FD 71         seq ; ==
0393   0627 E4            pop a
0394   0628             ; END RELATIONAL
0395   0628 C0 00 00      cmp b, 0
0396   062B C6 06 08      je _if7_else
0397   062E             _if7_true:
0398   062E             ;; fp++; 
0399   062E FA FD FF      lea d, [bp + -3] ; $fp
0400   0631 2A            mov b, [d]
0401   0632 D8            push b
0402   0633 FD 77         inc b
0403   0635 FA FD FF      lea d, [bp + -3] ; $fp
0404   0638 FD 43         mov [d], b
0405   063A E5            pop b
0406   063B             ;; switch(*fp){ 
0407   063B             _switch8_expr:
0408   063B FA FD FF      lea d, [bp + -3] ; $fp
0409   063E 2A            mov b, [d]
0410   063F 74            mov d, b
0411   0640 32            mov bl, [d]
0412   0641 A7 00         mov bh, 0
0413   0643             _switch8_comparisons:
0414   0643 C1 6C         cmp bl, $6c
0415   0645 C6 71 06      je _switch8_case0
0416   0648 C1 4C         cmp bl, $4c
0417   064A C6 71 06      je _switch8_case1
0418   064D C1 64         cmp bl, $64
0419   064F C6 31 07      je _switch8_case2
0420   0652 C1 69         cmp bl, $69
0421   0654 C6 31 07      je _switch8_case3
0422   0657 C1 75         cmp bl, $75
0423   0659 C6 56 07      je _switch8_case4
0424   065C C1 78         cmp bl, $78
0425   065E C6 7B 07      je _switch8_case5
0426   0661 C1 63         cmp bl, $63
0427   0663 C6 A0 07      je _switch8_case6
0428   0666 C1 73         cmp bl, $73
0429   0668 C6 C5 07      je _switch8_case7
0430   066B 0A EA 07      jmp _switch8_default
0431   066E 0A F6 07      jmp _switch8_exit
0432   0671             _switch8_case0:
0433   0671             _switch8_case1:
0434   0671             ;; fp++; 
0435   0671 FA FD FF      lea d, [bp + -3] ; $fp
0436   0674 2A            mov b, [d]
0437   0675 D8            push b
0438   0676 FD 77         inc b
0439   0678 FA FD FF      lea d, [bp + -3] ; $fp
0440   067B FD 43         mov [d], b
0441   067D E5            pop b
0442   067E             ;; if(*fp == 'd' || *fp == 'i'){ 
0443   067E             _if9_cond:
0444   067E FA FD FF      lea d, [bp + -3] ; $fp
0445   0681 2A            mov b, [d]
0446   0682 74            mov d, b
0447   0683 32            mov bl, [d]
0448   0684 A7 00         mov bh, 0
0449   0686             ; START RELATIONAL
0450   0686 D7            push a
0451   0687 11            mov a, b
0452   0688 26 64 00      mov b, $64
0453   068B B0            cmp a, b
0454   068C FD 71         seq ; ==
0455   068E E4            pop a
0456   068F             ; END RELATIONAL
0457   068F D7            push a
0458   0690 11            mov a, b
0459   0691 FA FD FF      lea d, [bp + -3] ; $fp
0460   0694 2A            mov b, [d]
0461   0695 74            mov d, b
0462   0696 32            mov bl, [d]
0463   0697 A7 00         mov bh, 0
0464   0699             ; START RELATIONAL
0465   0699 D7            push a
0466   069A 11            mov a, b
0467   069B 26 69 00      mov b, $69
0468   069E B0            cmp a, b
0469   069F FD 71         seq ; ==
0470   06A1 E4            pop a
0471   06A2             ; END RELATIONAL
0472   06A2 FD A8         sor a, b ; ||
0473   06A4 E4            pop a
0474   06A5 C0 00 00      cmp b, 0
0475   06A8 C6 DB 06      je _if9_else
0476   06AB             _if9_true:
0477   06AB             ;; print_signed_long(*(long *)p); 
0478   06AB FA FF FF      lea d, [bp + -1] ; $p
0479   06AE 2A            mov b, [d]
0480   06AF 74            mov d, b
0481   06B0 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0482   06B3 FD 39         mov c, b ; And place it into C
0483   06B5 2A            mov b, [d] ; Lower Word in B
0484   06B6 FD 79         mov g, b
0485   06B8 28            mov b, c
0486   06B9 FD AB         swp b
0487   06BB D8            push b
0488   06BC FD 27         mov b, g
0489   06BE D8            push b
0490   06BF 07 C9 0B      call print_signed_long
0491   06C2 51 04 00      add sp, 4
0492   06C5             ;; p = p + 4; 
0493   06C5 FA FF FF      lea d, [bp + -1] ; $p
0494   06C8 DA            push d
0495   06C9 FA FF FF      lea d, [bp + -1] ; $p
0496   06CC 2A            mov b, [d]
0497   06CD             ; START TERMS
0498   06CD D7            push a
0499   06CE 11            mov a, b
0500   06CF 26 04 00      mov b, $4
0501   06D2 54            add a, b
0502   06D3 27            mov b, a
0503   06D4 E4            pop a
0504   06D5             ; END TERMS
0505   06D5 E7            pop d
0506   06D6 FD 43         mov [d], b
0507   06D8 0A 2E 07      jmp _if9_exit
0508   06DB             _if9_else:
0509   06DB             ;; if(*fp == 'u'){ 
0510   06DB             _if10_cond:
0511   06DB FA FD FF      lea d, [bp + -3] ; $fp
0512   06DE 2A            mov b, [d]
0513   06DF 74            mov d, b
0514   06E0 32            mov bl, [d]
0515   06E1 A7 00         mov bh, 0
0516   06E3             ; START RELATIONAL
0517   06E3 D7            push a
0518   06E4 11            mov a, b
0519   06E5 26 75 00      mov b, $75
0520   06E8 B0            cmp a, b
0521   06E9 FD 71         seq ; ==
0522   06EB E4            pop a
0523   06EC             ; END RELATIONAL
0524   06EC C0 00 00      cmp b, 0
0525   06EF C6 22 07      je _if10_else
0526   06F2             _if10_true:
0527   06F2             ;; print_unsigned_long(*(unsigned long *)p); 
0528   06F2 FA FF FF      lea d, [bp + -1] ; $p
0529   06F5 2A            mov b, [d]
0530   06F6 74            mov d, b
0531   06F7 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0532   06FA FD 39         mov c, b ; And place it into C
0533   06FC 2A            mov b, [d] ; Lower Word in B
0534   06FD FD 79         mov g, b
0535   06FF 28            mov b, c
0536   0700 FD AB         swp b
0537   0702 D8            push b
0538   0703 FD 27         mov b, g
0539   0705 D8            push b
0540   0706 07 BA 0C      call print_unsigned_long
0541   0709 51 04 00      add sp, 4
0542   070C             ;; p = p + 4; 
0543   070C FA FF FF      lea d, [bp + -1] ; $p
0544   070F DA            push d
0545   0710 FA FF FF      lea d, [bp + -1] ; $p
0546   0713 2A            mov b, [d]
0547   0714             ; START TERMS
0548   0714 D7            push a
0549   0715 11            mov a, b
0550   0716 26 04 00      mov b, $4
0551   0719 54            add a, b
0552   071A 27            mov b, a
0553   071B E4            pop a
0554   071C             ; END TERMS
0555   071C E7            pop d
0556   071D FD 43         mov [d], b
0557   071F 0A 2E 07      jmp _if10_exit
0558   0722             _if10_else:
0559   0722             ;; err("Unexpected format in printf."); 
0560   0722 26 F0 13      mov b, __s0 ; "Unexpected format in printf."
0561   0725 FD AB         swp b
0562   0727 D8            push b
0563   0728 07 27 08      call err
0564   072B 51 02 00      add sp, 2
0565   072E             _if10_exit:
0566   072E             _if9_exit:
0567   072E             ;; break; 
0568   072E 0A F6 07      jmp _switch8_exit ; case break
0569   0731             _switch8_case2:
0570   0731             _switch8_case3:
0571   0731             ;; print_signed(*(int*)p); 
0572   0731 FA FF FF      lea d, [bp + -1] ; $p
0573   0734 2A            mov b, [d]
0574   0735 74            mov d, b
0575   0736 2A            mov b, [d]
0576   0737 FD AB         swp b
0577   0739 D8            push b
0578   073A 07 D8 0A      call print_signed
0579   073D 51 02 00      add sp, 2
0580   0740             ;; p = p + 2; 
0581   0740 FA FF FF      lea d, [bp + -1] ; $p
0582   0743 DA            push d
0583   0744 FA FF FF      lea d, [bp + -1] ; $p
0584   0747 2A            mov b, [d]
0585   0748             ; START TERMS
0586   0748 D7            push a
0587   0749 11            mov a, b
0588   074A 26 02 00      mov b, $2
0589   074D 54            add a, b
0590   074E 27            mov b, a
0591   074F E4            pop a
0592   0750             ; END TERMS
0593   0750 E7            pop d
0594   0751 FD 43         mov [d], b
0595   0753             ;; break; 
0596   0753 0A F6 07      jmp _switch8_exit ; case break
0597   0756             _switch8_case4:
0598   0756             ;; print_unsigned(*(unsigned int*)p); 
0599   0756 FA FF FF      lea d, [bp + -1] ; $p
0600   0759 2A            mov b, [d]
0601   075A 74            mov d, b
0602   075B 2A            mov b, [d]
0603   075C FD AB         swp b
0604   075E D8            push b
0605   075F 07 82 0D      call print_unsigned
0606   0762 51 02 00      add sp, 2
0607   0765             ;; p = p + 2; 
0608   0765 FA FF FF      lea d, [bp + -1] ; $p
0609   0768 DA            push d
0610   0769 FA FF FF      lea d, [bp + -1] ; $p
0611   076C 2A            mov b, [d]
0612   076D             ; START TERMS
0613   076D D7            push a
0614   076E 11            mov a, b
0615   076F 26 02 00      mov b, $2
0616   0772 54            add a, b
0617   0773 27            mov b, a
0618   0774 E4            pop a
0619   0775             ; END TERMS
0620   0775 E7            pop d
0621   0776 FD 43         mov [d], b
0622   0778             ;; break; 
0623   0778 0A F6 07      jmp _switch8_exit ; case break
0624   077B             _switch8_case5:
0625   077B             ;; printx16(*(unsigned int*)p); 
0626   077B FA FF FF      lea d, [bp + -1] ; $p
0627   077E 2A            mov b, [d]
0628   077F 74            mov d, b
0629   0780 2A            mov b, [d]
0630   0781 FD AB         swp b
0631   0783 D8            push b
0632   0784 07 4E 08      call printx16
0633   0787 51 02 00      add sp, 2
0634   078A             ;; p = p + 2; 
0635   078A FA FF FF      lea d, [bp + -1] ; $p
0636   078D DA            push d
0637   078E FA FF FF      lea d, [bp + -1] ; $p
0638   0791 2A            mov b, [d]
0639   0792             ; START TERMS
0640   0792 D7            push a
0641   0793 11            mov a, b
0642   0794 26 02 00      mov b, $2
0643   0797 54            add a, b
0644   0798 27            mov b, a
0645   0799 E4            pop a
0646   079A             ; END TERMS
0647   079A E7            pop d
0648   079B FD 43         mov [d], b
0649   079D             ;; break; 
0650   079D 0A F6 07      jmp _switch8_exit ; case break
0651   07A0             _switch8_case6:
0652   07A0             ;; putchar(*(char*)p); 
0653   07A0 FA FF FF      lea d, [bp + -1] ; $p
0654   07A3 2A            mov b, [d]
0655   07A4 74            mov d, b
0656   07A5 32            mov bl, [d]
0657   07A6 A7 00         mov bh, 0
0658   07A8 DD            push bl
0659   07A9 07 6A 0E      call putchar
0660   07AC 51 01 00      add sp, 1
0661   07AF             ;; p = p + 2; 
0662   07AF FA FF FF      lea d, [bp + -1] ; $p
0663   07B2 DA            push d
0664   07B3 FA FF FF      lea d, [bp + -1] ; $p
0665   07B6 2A            mov b, [d]
0666   07B7             ; START TERMS
0667   07B7 D7            push a
0668   07B8 11            mov a, b
0669   07B9 26 02 00      mov b, $2
0670   07BC 54            add a, b
0671   07BD 27            mov b, a
0672   07BE E4            pop a
0673   07BF             ; END TERMS
0674   07BF E7            pop d
0675   07C0 FD 43         mov [d], b
0676   07C2             ;; break; 
0677   07C2 0A F6 07      jmp _switch8_exit ; case break
0678   07C5             _switch8_case7:
0679   07C5             ;; print(*(char**)p); 
0680   07C5 FA FF FF      lea d, [bp + -1] ; $p
0681   07C8 2A            mov b, [d]
0682   07C9 74            mov d, b
0683   07CA 2A            mov b, [d]
0684   07CB FD AB         swp b
0685   07CD D8            push b
0686   07CE 07 B2 0E      call print
0687   07D1 51 02 00      add sp, 2
0688   07D4             ;; p = p + 2; 
0689   07D4 FA FF FF      lea d, [bp + -1] ; $p
0690   07D7 DA            push d
0691   07D8 FA FF FF      lea d, [bp + -1] ; $p
0692   07DB 2A            mov b, [d]
0693   07DC             ; START TERMS
0694   07DC D7            push a
0695   07DD 11            mov a, b
0696   07DE 26 02 00      mov b, $2
0697   07E1 54            add a, b
0698   07E2 27            mov b, a
0699   07E3 E4            pop a
0700   07E4             ; END TERMS
0701   07E4 E7            pop d
0702   07E5 FD 43         mov [d], b
0703   07E7             ;; break; 
0704   07E7 0A F6 07      jmp _switch8_exit ; case break
0705   07EA             _switch8_default:
0706   07EA             ;; print("Error: Unknown argument type.\n"); 
0707   07EA 26 0D 14      mov b, __s1 ; "Error: Unknown argument type.\n"
0708   07ED FD AB         swp b
0709   07EF D8            push b
0710   07F0 07 B2 0E      call print
0711   07F3 51 02 00      add sp, 2
0712   07F6             _switch8_exit:
0713   07F6             ;; fp++; 
0714   07F6 FA FD FF      lea d, [bp + -3] ; $fp
0715   07F9 2A            mov b, [d]
0716   07FA D8            push b
0717   07FB FD 77         inc b
0718   07FD FA FD FF      lea d, [bp + -3] ; $fp
0719   0800 FD 43         mov [d], b
0720   0802 E5            pop b
0721   0803 0A 22 08      jmp _if7_exit
0722   0806             _if7_else:
0723   0806             ;; putchar(*fp); 
0724   0806 FA FD FF      lea d, [bp + -3] ; $fp
0725   0809 2A            mov b, [d]
0726   080A 74            mov d, b
0727   080B 32            mov bl, [d]
0728   080C A7 00         mov bh, 0
0729   080E DD            push bl
0730   080F 07 6A 0E      call putchar
0731   0812 51 01 00      add sp, 1
0732   0815             ;; fp++; 
0733   0815 FA FD FF      lea d, [bp + -3] ; $fp
0734   0818 2A            mov b, [d]
0735   0819 D8            push b
0736   081A FD 77         inc b
0737   081C FA FD FF      lea d, [bp + -3] ; $fp
0738   081F FD 43         mov [d], b
0739   0821 E5            pop b
0740   0822             _if7_exit:
0741   0822             _if6_exit:
0742   0822             _for5_update:
0743   0822 0A FE 05      jmp _for5_cond
0744   0825             _for5_exit:
0745   0825 F9            leave
0746   0826 09            ret
0747   0827             
0748   0827             err:
0749   0827 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0750   082A             ;; print(e); 
0751   082A FA 05 00      lea d, [bp + 5] ; $e
0752   082D 2A            mov b, [d]
0753   082E FD AB         swp b
0754   0830 D8            push b
0755   0831 07 B2 0E      call print
0756   0834 51 02 00      add sp, 2
0757   0837             ;; exit(); 
0758   0837 07 2C 0F      call exit
0759   083A F9            leave
0760   083B 09            ret
0761   083C             
0762   083C             printx32:
0763   083C F8 00 00      enter 0 ; (push bp; mov bp, sp)
0764   083F             
0765   083F             ; --- BEGIN INLINE ASM BLOCK
0766   083F FA 05 00      lea d, [bp + 5] ; $hex
0767   0842 2B 02 00      mov b, [d+2]
0768   0845 07 89 12      call print_u16x
0769   0848 2A            mov b, [d]
0770   0849 07 89 12      call print_u16x
0771   084C             ; --- END INLINE ASM BLOCK
0772   084C             
0773   084C F9            leave
0774   084D 09            ret
0775   084E             
0776   084E             printx16:
0777   084E F8 00 00      enter 0 ; (push bp; mov bp, sp)
0778   0851             
0779   0851             ; --- BEGIN INLINE ASM BLOCK
0780   0851 FA 05 00      lea d, [bp + 5] ; $hex
0781   0854 2A            mov b, [d]
0782   0855 07 89 12      call print_u16x
0783   0858             ; --- END INLINE ASM BLOCK
0784   0858             
0785   0858 F9            leave
0786   0859 09            ret
0787   085A             
0788   085A             printx8:
0789   085A F8 00 00      enter 0 ; (push bp; mov bp, sp)
0790   085D             
0791   085D             ; --- BEGIN INLINE ASM BLOCK
0792   085D FA 05 00      lea d, [bp + 5] ; $hex
0793   0860 32            mov bl, [d]
0794   0861 07 CD 12      call print_u8x
0795   0864             ; --- END INLINE ASM BLOCK
0796   0864             
0797   0864 F9            leave
0798   0865 09            ret
0799   0866             
0800   0866             hex_to_int:
0801   0866 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0802   0869             ; $value 
0803   0869 10 00 00      mov a, $0
0804   086C 45 FF FF      mov [bp + -1], a
0805   086F             ; $i 
0806   086F             ; $hex_char 
0807   086F             ; $len 
0808   086F 52 07 00      sub sp, 7
0809   0872             ;; len = strlen(hex_string); 
0810   0872 FA FA FF      lea d, [bp + -6] ; $len
0811   0875 DA            push d
0812   0876 FA 05 00      lea d, [bp + 5] ; $hex_string
0813   0879 2A            mov b, [d]
0814   087A FD AB         swp b
0815   087C D8            push b
0816   087D 07 91 05      call strlen
0817   0880 51 02 00      add sp, 2
0818   0883 E7            pop d
0819   0884 FD 43         mov [d], b
0820   0886             ;; for (i = 0; i < len; i++) { 
0821   0886             _for11_init:
0822   0886 FA FD FF      lea d, [bp + -3] ; $i
0823   0889 DA            push d
0824   088A 26 00 00      mov b, $0
0825   088D E7            pop d
0826   088E FD 43         mov [d], b
0827   0890             _for11_cond:
0828   0890 FA FD FF      lea d, [bp + -3] ; $i
0829   0893 2A            mov b, [d]
0830   0894             ; START RELATIONAL
0831   0894 D7            push a
0832   0895 11            mov a, b
0833   0896 FA FA FF      lea d, [bp + -6] ; $len
0834   0899 2A            mov b, [d]
0835   089A B0            cmp a, b
0836   089B FD 73         slt ; < 
0837   089D E4            pop a
0838   089E             ; END RELATIONAL
0839   089E C0 00 00      cmp b, 0
0840   08A1 C6 A6 09      je _for11_exit
0841   08A4             _for11_block:
0842   08A4             ;; hex_char = hex_string[i]; 
0843   08A4 FA FC FF      lea d, [bp + -4] ; $hex_char
0844   08A7 DA            push d
0845   08A8 FA 05 00      lea d, [bp + 5] ; $hex_string
0846   08AB FD 2A         mov d, [d]
0847   08AD D7            push a
0848   08AE DA            push d
0849   08AF FA FD FF      lea d, [bp + -3] ; $i
0850   08B2 2A            mov b, [d]
0851   08B3 E7            pop d
0852   08B4 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0853   08B8 E4            pop a
0854   08B9 32            mov bl, [d]
0855   08BA A7 00         mov bh, 0
0856   08BC E7            pop d
0857   08BD FD 3E         mov [d], bl
0858   08BF             ;; if (hex_char >= 'a' && hex_char <= 'f')  
0859   08BF             _if12_cond:
0860   08BF FA FC FF      lea d, [bp + -4] ; $hex_char
0861   08C2 32            mov bl, [d]
0862   08C3 A7 00         mov bh, 0
0863   08C5             ; START RELATIONAL
0864   08C5 D7            push a
0865   08C6 11            mov a, b
0866   08C7 26 61 00      mov b, $61
0867   08CA B0            cmp a, b
0868   08CB FD 80         sge ; >=
0869   08CD E4            pop a
0870   08CE             ; END RELATIONAL
0871   08CE D7            push a
0872   08CF 11            mov a, b
0873   08D0 FA FC FF      lea d, [bp + -4] ; $hex_char
0874   08D3 32            mov bl, [d]
0875   08D4 A7 00         mov bh, 0
0876   08D6             ; START RELATIONAL
0877   08D6 D7            push a
0878   08D7 11            mov a, b
0879   08D8 26 66 00      mov b, $66
0880   08DB B0            cmp a, b
0881   08DC FD 74         sle ; <=
0882   08DE E4            pop a
0883   08DF             ; END RELATIONAL
0884   08DF FD A7         sand a, b ; &&
0885   08E1 E4            pop a
0886   08E2 C0 00 00      cmp b, 0
0887   08E5 C6 17 09      je _if12_else
0888   08E8             _if12_true:
0889   08E8             ;; value = (value * 16) + (hex_char - 'a' + 10); 
0890   08E8 FA FF FF      lea d, [bp + -1] ; $value
0891   08EB DA            push d
0892   08EC FA FF FF      lea d, [bp + -1] ; $value
0893   08EF 2A            mov b, [d]
0894   08F0             ; START FACTORS
0895   08F0 D7            push a
0896   08F1 11            mov a, b
0897   08F2 26 10 00      mov b, $10
0898   08F5 AC            mul a, b ; *
0899   08F6 11            mov a, b
0900   08F7 27            mov b, a
0901   08F8 E4            pop a
0902   08F9             ; END FACTORS
0903   08F9             ; START TERMS
0904   08F9 D7            push a
0905   08FA 11            mov a, b
0906   08FB FA FC FF      lea d, [bp + -4] ; $hex_char
0907   08FE 32            mov bl, [d]
0908   08FF A7 00         mov bh, 0
0909   0901             ; START TERMS
0910   0901 D7            push a
0911   0902 11            mov a, b
0912   0903 26 61 00      mov b, $61
0913   0906 60            sub a, b
0914   0907 11            mov a, b
0915   0908 26 0A 00      mov b, $a
0916   090B 54            add a, b
0917   090C 27            mov b, a
0918   090D E4            pop a
0919   090E             ; END TERMS
0920   090E 54            add a, b
0921   090F 27            mov b, a
0922   0910 E4            pop a
0923   0911             ; END TERMS
0924   0911 E7            pop d
0925   0912 FD 43         mov [d], b
0926   0914 0A 96 09      jmp _if12_exit
0927   0917             _if12_else:
0928   0917             ;; if (hex_char >= 'A' && hex_char <= 'F')  
0929   0917             _if13_cond:
0930   0917 FA FC FF      lea d, [bp + -4] ; $hex_char
0931   091A 32            mov bl, [d]
0932   091B A7 00         mov bh, 0
0933   091D             ; START RELATIONAL
0934   091D D7            push a
0935   091E 11            mov a, b
0936   091F 26 41 00      mov b, $41
0937   0922 B0            cmp a, b
0938   0923 FD 80         sge ; >=
0939   0925 E4            pop a
0940   0926             ; END RELATIONAL
0941   0926 D7            push a
0942   0927 11            mov a, b
0943   0928 FA FC FF      lea d, [bp + -4] ; $hex_char
0944   092B 32            mov bl, [d]
0945   092C A7 00         mov bh, 0
0946   092E             ; START RELATIONAL
0947   092E D7            push a
0948   092F 11            mov a, b
0949   0930 26 46 00      mov b, $46
0950   0933 B0            cmp a, b
0951   0934 FD 74         sle ; <=
0952   0936 E4            pop a
0953   0937             ; END RELATIONAL
0954   0937 FD A7         sand a, b ; &&
0955   0939 E4            pop a
0956   093A C0 00 00      cmp b, 0
0957   093D C6 6F 09      je _if13_else
0958   0940             _if13_true:
0959   0940             ;; value = (value * 16) + (hex_char - 'A' + 10); 
0960   0940 FA FF FF      lea d, [bp + -1] ; $value
0961   0943 DA            push d
0962   0944 FA FF FF      lea d, [bp + -1] ; $value
0963   0947 2A            mov b, [d]
0964   0948             ; START FACTORS
0965   0948 D7            push a
0966   0949 11            mov a, b
0967   094A 26 10 00      mov b, $10
0968   094D AC            mul a, b ; *
0969   094E 11            mov a, b
0970   094F 27            mov b, a
0971   0950 E4            pop a
0972   0951             ; END FACTORS
0973   0951             ; START TERMS
0974   0951 D7            push a
0975   0952 11            mov a, b
0976   0953 FA FC FF      lea d, [bp + -4] ; $hex_char
0977   0956 32            mov bl, [d]
0978   0957 A7 00         mov bh, 0
0979   0959             ; START TERMS
0980   0959 D7            push a
0981   095A 11            mov a, b
0982   095B 26 41 00      mov b, $41
0983   095E 60            sub a, b
0984   095F 11            mov a, b
0985   0960 26 0A 00      mov b, $a
0986   0963 54            add a, b
0987   0964 27            mov b, a
0988   0965 E4            pop a
0989   0966             ; END TERMS
0990   0966 54            add a, b
0991   0967 27            mov b, a
0992   0968 E4            pop a
0993   0969             ; END TERMS
0994   0969 E7            pop d
0995   096A FD 43         mov [d], b
0996   096C 0A 96 09      jmp _if13_exit
0997   096F             _if13_else:
0998   096F             ;; value = (value * 16) + (hex_char - '0'); 
0999   096F FA FF FF      lea d, [bp + -1] ; $value
1000   0972 DA            push d
1001   0973 FA FF FF      lea d, [bp + -1] ; $value
1002   0976 2A            mov b, [d]
1003   0977             ; START FACTORS
1004   0977 D7            push a
1005   0978 11            mov a, b
1006   0979 26 10 00      mov b, $10
1007   097C AC            mul a, b ; *
1008   097D 11            mov a, b
1009   097E 27            mov b, a
1010   097F E4            pop a
1011   0980             ; END FACTORS
1012   0980             ; START TERMS
1013   0980 D7            push a
1014   0981 11            mov a, b
1015   0982 FA FC FF      lea d, [bp + -4] ; $hex_char
1016   0985 32            mov bl, [d]
1017   0986 A7 00         mov bh, 0
1018   0988             ; START TERMS
1019   0988 D7            push a
1020   0989 11            mov a, b
1021   098A 26 30 00      mov b, $30
1022   098D 60            sub a, b
1023   098E 27            mov b, a
1024   098F E4            pop a
1025   0990             ; END TERMS
1026   0990 54            add a, b
1027   0991 27            mov b, a
1028   0992 E4            pop a
1029   0993             ; END TERMS
1030   0993 E7            pop d
1031   0994 FD 43         mov [d], b
1032   0996             _if13_exit:
1033   0996             _if12_exit:
1034   0996             _for11_update:
1035   0996 FA FD FF      lea d, [bp + -3] ; $i
1036   0999 2A            mov b, [d]
1037   099A D8            push b
1038   099B FD 77         inc b
1039   099D FA FD FF      lea d, [bp + -3] ; $i
1040   09A0 FD 43         mov [d], b
1041   09A2 E5            pop b
1042   09A3 0A 90 08      jmp _for11_cond
1043   09A6             _for11_exit:
1044   09A6             ;; return value; 
1045   09A6 FA FF FF      lea d, [bp + -1] ; $value
1046   09A9 2A            mov b, [d]
1047   09AA F9            leave
1048   09AB 09            ret
1049   09AC             
1050   09AC             atoi:
1051   09AC F8 00 00      enter 0 ; (push bp; mov bp, sp)
1052   09AF             ; $result 
1053   09AF 10 00 00      mov a, $0
1054   09B2 45 FF FF      mov [bp + -1], a
1055   09B5             ; $sign 
1056   09B5 10 01 00      mov a, $1
1057   09B8 45 FD FF      mov [bp + -3], a
1058   09BB 52 04 00      sub sp, 4
1059   09BE             ;; while (*str == ' ') str++; 
1060   09BE             _while14_cond:
1061   09BE FA 05 00      lea d, [bp + 5] ; $str
1062   09C1 2A            mov b, [d]
1063   09C2 74            mov d, b
1064   09C3 32            mov bl, [d]
1065   09C4 A7 00         mov bh, 0
1066   09C6             ; START RELATIONAL
1067   09C6 D7            push a
1068   09C7 11            mov a, b
1069   09C8 26 20 00      mov b, $20
1070   09CB B0            cmp a, b
1071   09CC FD 71         seq ; ==
1072   09CE E4            pop a
1073   09CF             ; END RELATIONAL
1074   09CF C0 00 00      cmp b, 0
1075   09D2 C6 E5 09      je _while14_exit
1076   09D5             _while14_block:
1077   09D5             ;; str++; 
1078   09D5 FA 05 00      lea d, [bp + 5] ; $str
1079   09D8 2A            mov b, [d]
1080   09D9 D8            push b
1081   09DA FD 77         inc b
1082   09DC FA 05 00      lea d, [bp + 5] ; $str
1083   09DF FD 43         mov [d], b
1084   09E1 E5            pop b
1085   09E2 0A BE 09      jmp _while14_cond
1086   09E5             _while14_exit:
1087   09E5             ;; if (*str == '-' || *str == '+') { 
1088   09E5             _if15_cond:
1089   09E5 FA 05 00      lea d, [bp + 5] ; $str
1090   09E8 2A            mov b, [d]
1091   09E9 74            mov d, b
1092   09EA 32            mov bl, [d]
1093   09EB A7 00         mov bh, 0
1094   09ED             ; START RELATIONAL
1095   09ED D7            push a
1096   09EE 11            mov a, b
1097   09EF 26 2D 00      mov b, $2d
1098   09F2 B0            cmp a, b
1099   09F3 FD 71         seq ; ==
1100   09F5 E4            pop a
1101   09F6             ; END RELATIONAL
1102   09F6 D7            push a
1103   09F7 11            mov a, b
1104   09F8 FA 05 00      lea d, [bp + 5] ; $str
1105   09FB 2A            mov b, [d]
1106   09FC 74            mov d, b
1107   09FD 32            mov bl, [d]
1108   09FE A7 00         mov bh, 0
1109   0A00             ; START RELATIONAL
1110   0A00 D7            push a
1111   0A01 11            mov a, b
1112   0A02 26 2B 00      mov b, $2b
1113   0A05 B0            cmp a, b
1114   0A06 FD 71         seq ; ==
1115   0A08 E4            pop a
1116   0A09             ; END RELATIONAL
1117   0A09 FD A8         sor a, b ; ||
1118   0A0B E4            pop a
1119   0A0C C0 00 00      cmp b, 0
1120   0A0F C6 48 0A      je _if15_exit
1121   0A12             _if15_true:
1122   0A12             ;; if (*str == '-') sign = -1; 
1123   0A12             _if16_cond:
1124   0A12 FA 05 00      lea d, [bp + 5] ; $str
1125   0A15 2A            mov b, [d]
1126   0A16 74            mov d, b
1127   0A17 32            mov bl, [d]
1128   0A18 A7 00         mov bh, 0
1129   0A1A             ; START RELATIONAL
1130   0A1A D7            push a
1131   0A1B 11            mov a, b
1132   0A1C 26 2D 00      mov b, $2d
1133   0A1F B0            cmp a, b
1134   0A20 FD 71         seq ; ==
1135   0A22 E4            pop a
1136   0A23             ; END RELATIONAL
1137   0A23 C0 00 00      cmp b, 0
1138   0A26 C6 38 0A      je _if16_exit
1139   0A29             _if16_true:
1140   0A29             ;; sign = -1; 
1141   0A29 FA FD FF      lea d, [bp + -3] ; $sign
1142   0A2C DA            push d
1143   0A2D 26 01 00      mov b, $1
1144   0A30 FD 97         neg b
1145   0A32 E7            pop d
1146   0A33 FD 43         mov [d], b
1147   0A35 0A 38 0A      jmp _if16_exit
1148   0A38             _if16_exit:
1149   0A38             ;; str++; 
1150   0A38 FA 05 00      lea d, [bp + 5] ; $str
1151   0A3B 2A            mov b, [d]
1152   0A3C D8            push b
1153   0A3D FD 77         inc b
1154   0A3F FA 05 00      lea d, [bp + 5] ; $str
1155   0A42 FD 43         mov [d], b
1156   0A44 E5            pop b
1157   0A45 0A 48 0A      jmp _if15_exit
1158   0A48             _if15_exit:
1159   0A48             ;; while (*str >= '0' && *str <= '9') { 
1160   0A48             _while17_cond:
1161   0A48 FA 05 00      lea d, [bp + 5] ; $str
1162   0A4B 2A            mov b, [d]
1163   0A4C 74            mov d, b
1164   0A4D 32            mov bl, [d]
1165   0A4E A7 00         mov bh, 0
1166   0A50             ; START RELATIONAL
1167   0A50 D7            push a
1168   0A51 11            mov a, b
1169   0A52 26 30 00      mov b, $30
1170   0A55 B0            cmp a, b
1171   0A56 FD 82         sgeu ; >= (unsigned)
1172   0A58 E4            pop a
1173   0A59             ; END RELATIONAL
1174   0A59 D7            push a
1175   0A5A 11            mov a, b
1176   0A5B FA 05 00      lea d, [bp + 5] ; $str
1177   0A5E 2A            mov b, [d]
1178   0A5F 74            mov d, b
1179   0A60 32            mov bl, [d]
1180   0A61 A7 00         mov bh, 0
1181   0A63             ; START RELATIONAL
1182   0A63 D7            push a
1183   0A64 11            mov a, b
1184   0A65 26 39 00      mov b, $39
1185   0A68 B0            cmp a, b
1186   0A69 FD 76         sleu ; <= (unsigned)
1187   0A6B E4            pop a
1188   0A6C             ; END RELATIONAL
1189   0A6C FD A7         sand a, b ; &&
1190   0A6E E4            pop a
1191   0A6F C0 00 00      cmp b, 0
1192   0A72 C6 AE 0A      je _while17_exit
1193   0A75             _while17_block:
1194   0A75             ;; result = result * 10 + (*str - '0'); 
1195   0A75 FA FF FF      lea d, [bp + -1] ; $result
1196   0A78 DA            push d
1197   0A79 FA FF FF      lea d, [bp + -1] ; $result
1198   0A7C 2A            mov b, [d]
1199   0A7D             ; START FACTORS
1200   0A7D D7            push a
1201   0A7E 11            mov a, b
1202   0A7F 26 0A 00      mov b, $a
1203   0A82 AC            mul a, b ; *
1204   0A83 11            mov a, b
1205   0A84 27            mov b, a
1206   0A85 E4            pop a
1207   0A86             ; END FACTORS
1208   0A86             ; START TERMS
1209   0A86 D7            push a
1210   0A87 11            mov a, b
1211   0A88 FA 05 00      lea d, [bp + 5] ; $str
1212   0A8B 2A            mov b, [d]
1213   0A8C 74            mov d, b
1214   0A8D 32            mov bl, [d]
1215   0A8E A7 00         mov bh, 0
1216   0A90             ; START TERMS
1217   0A90 D7            push a
1218   0A91 11            mov a, b
1219   0A92 26 30 00      mov b, $30
1220   0A95 60            sub a, b
1221   0A96 27            mov b, a
1222   0A97 E4            pop a
1223   0A98             ; END TERMS
1224   0A98 54            add a, b
1225   0A99 27            mov b, a
1226   0A9A E4            pop a
1227   0A9B             ; END TERMS
1228   0A9B E7            pop d
1229   0A9C FD 43         mov [d], b
1230   0A9E             ;; str++; 
1231   0A9E FA 05 00      lea d, [bp + 5] ; $str
1232   0AA1 2A            mov b, [d]
1233   0AA2 D8            push b
1234   0AA3 FD 77         inc b
1235   0AA5 FA 05 00      lea d, [bp + 5] ; $str
1236   0AA8 FD 43         mov [d], b
1237   0AAA E5            pop b
1238   0AAB 0A 48 0A      jmp _while17_cond
1239   0AAE             _while17_exit:
1240   0AAE             ;; return sign * result; 
1241   0AAE FA FD FF      lea d, [bp + -3] ; $sign
1242   0AB1 2A            mov b, [d]
1243   0AB2             ; START FACTORS
1244   0AB2 D7            push a
1245   0AB3 11            mov a, b
1246   0AB4 FA FF FF      lea d, [bp + -1] ; $result
1247   0AB7 2A            mov b, [d]
1248   0AB8 AC            mul a, b ; *
1249   0AB9 11            mov a, b
1250   0ABA 27            mov b, a
1251   0ABB E4            pop a
1252   0ABC             ; END FACTORS
1253   0ABC F9            leave
1254   0ABD 09            ret
1255   0ABE             
1256   0ABE             gets:
1257   0ABE F8 00 00      enter 0 ; (push bp; mov bp, sp)
1258   0AC1             
1259   0AC1             ; --- BEGIN INLINE ASM BLOCK
1260   0AC1 FA 05 00      lea d, [bp + 5] ; $s
1261   0AC4 15            mov a, [d]
1262   0AC5 3C            mov d, a
1263   0AC6 07 EE 10      call _gets
1264   0AC9             ; --- END INLINE ASM BLOCK
1265   0AC9             
1266   0AC9             ;; return strlen(s); 
1267   0AC9 FA 05 00      lea d, [bp + 5] ; $s
1268   0ACC 2A            mov b, [d]
1269   0ACD FD AB         swp b
1270   0ACF D8            push b
1271   0AD0 07 91 05      call strlen
1272   0AD3 51 02 00      add sp, 2
1273   0AD6 F9            leave
1274   0AD7 09            ret
1275   0AD8             
1276   0AD8             print_signed:
1277   0AD8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1278   0ADB             ; $digits 
1279   0ADB             ; $i 
1280   0ADB 10 00 00      mov a, $0
1281   0ADE 45 FA FF      mov [bp + -6], a
1282   0AE1 52 07 00      sub sp, 7
1283   0AE4             ;; if (num < 0) { 
1284   0AE4             _if18_cond:
1285   0AE4 FA 05 00      lea d, [bp + 5] ; $num
1286   0AE7 2A            mov b, [d]
1287   0AE8             ; START RELATIONAL
1288   0AE8 D7            push a
1289   0AE9 11            mov a, b
1290   0AEA 26 00 00      mov b, $0
1291   0AED B0            cmp a, b
1292   0AEE FD 73         slt ; < 
1293   0AF0 E4            pop a
1294   0AF1             ; END RELATIONAL
1295   0AF1 C0 00 00      cmp b, 0
1296   0AF4 C6 11 0B      je _if18_else
1297   0AF7             _if18_true:
1298   0AF7             ;; putchar('-'); 
1299   0AF7 26 2D 00      mov b, $2d
1300   0AFA DD            push bl
1301   0AFB 07 6A 0E      call putchar
1302   0AFE 51 01 00      add sp, 1
1303   0B01             ;; num = -num; 
1304   0B01 FA 05 00      lea d, [bp + 5] ; $num
1305   0B04 DA            push d
1306   0B05 FA 05 00      lea d, [bp + 5] ; $num
1307   0B08 2A            mov b, [d]
1308   0B09 FD 97         neg b
1309   0B0B E7            pop d
1310   0B0C FD 43         mov [d], b
1311   0B0E 0A 33 0B      jmp _if18_exit
1312   0B11             _if18_else:
1313   0B11             ;; if (num == 0) { 
1314   0B11             _if19_cond:
1315   0B11 FA 05 00      lea d, [bp + 5] ; $num
1316   0B14 2A            mov b, [d]
1317   0B15             ; START RELATIONAL
1318   0B15 D7            push a
1319   0B16 11            mov a, b
1320   0B17 26 00 00      mov b, $0
1321   0B1A B0            cmp a, b
1322   0B1B FD 71         seq ; ==
1323   0B1D E4            pop a
1324   0B1E             ; END RELATIONAL
1325   0B1E C0 00 00      cmp b, 0
1326   0B21 C6 33 0B      je _if19_exit
1327   0B24             _if19_true:
1328   0B24             ;; putchar('0'); 
1329   0B24 26 30 00      mov b, $30
1330   0B27 DD            push bl
1331   0B28 07 6A 0E      call putchar
1332   0B2B 51 01 00      add sp, 1
1333   0B2E             ;; return; 
1334   0B2E F9            leave
1335   0B2F 09            ret
1336   0B30 0A 33 0B      jmp _if19_exit
1337   0B33             _if19_exit:
1338   0B33             _if18_exit:
1339   0B33             ;; while (num > 0) { 
1340   0B33             _while20_cond:
1341   0B33 FA 05 00      lea d, [bp + 5] ; $num
1342   0B36 2A            mov b, [d]
1343   0B37             ; START RELATIONAL
1344   0B37 D7            push a
1345   0B38 11            mov a, b
1346   0B39 26 00 00      mov b, $0
1347   0B3C B0            cmp a, b
1348   0B3D FD 7F         sgt ; >
1349   0B3F E4            pop a
1350   0B40             ; END RELATIONAL
1351   0B40 C0 00 00      cmp b, 0
1352   0B43 C6 8E 0B      je _while20_exit
1353   0B46             _while20_block:
1354   0B46             ;; digits[i] = '0' + (num % 10); 
1355   0B46 FA FC FF      lea d, [bp + -4] ; $digits
1356   0B49 D7            push a
1357   0B4A DA            push d
1358   0B4B FA FA FF      lea d, [bp + -6] ; $i
1359   0B4E 2A            mov b, [d]
1360   0B4F E7            pop d
1361   0B50 5A            add d, b
1362   0B51 E4            pop a
1363   0B52 DA            push d
1364   0B53 26 30 00      mov b, $30
1365   0B56             ; START TERMS
1366   0B56 D7            push a
1367   0B57 11            mov a, b
1368   0B58 FA 05 00      lea d, [bp + 5] ; $num
1369   0B5B 2A            mov b, [d]
1370   0B5C             ; START FACTORS
1371   0B5C D7            push a
1372   0B5D 11            mov a, b
1373   0B5E 26 0A 00      mov b, $a
1374   0B61 AE            div a, b ; 
1375   0B62 11            mov a, b
1376   0B63 27            mov b, a
1377   0B64 E4            pop a
1378   0B65             ; END FACTORS
1379   0B65 54            add a, b
1380   0B66 27            mov b, a
1381   0B67 E4            pop a
1382   0B68             ; END TERMS
1383   0B68 E7            pop d
1384   0B69 FD 3E         mov [d], bl
1385   0B6B             ;; num = num / 10; 
1386   0B6B FA 05 00      lea d, [bp + 5] ; $num
1387   0B6E DA            push d
1388   0B6F FA 05 00      lea d, [bp + 5] ; $num
1389   0B72 2A            mov b, [d]
1390   0B73             ; START FACTORS
1391   0B73 D7            push a
1392   0B74 11            mov a, b
1393   0B75 26 0A 00      mov b, $a
1394   0B78 AE            div a, b
1395   0B79 27            mov b, a
1396   0B7A E4            pop a
1397   0B7B             ; END FACTORS
1398   0B7B E7            pop d
1399   0B7C FD 43         mov [d], b
1400   0B7E             ;; i++; 
1401   0B7E FA FA FF      lea d, [bp + -6] ; $i
1402   0B81 2A            mov b, [d]
1403   0B82 D8            push b
1404   0B83 FD 77         inc b
1405   0B85 FA FA FF      lea d, [bp + -6] ; $i
1406   0B88 FD 43         mov [d], b
1407   0B8A E5            pop b
1408   0B8B 0A 33 0B      jmp _while20_cond
1409   0B8E             _while20_exit:
1410   0B8E             ;; while (i > 0) { 
1411   0B8E             _while21_cond:
1412   0B8E FA FA FF      lea d, [bp + -6] ; $i
1413   0B91 2A            mov b, [d]
1414   0B92             ; START RELATIONAL
1415   0B92 D7            push a
1416   0B93 11            mov a, b
1417   0B94 26 00 00      mov b, $0
1418   0B97 B0            cmp a, b
1419   0B98 FD 7F         sgt ; >
1420   0B9A E4            pop a
1421   0B9B             ; END RELATIONAL
1422   0B9B C0 00 00      cmp b, 0
1423   0B9E C6 C7 0B      je _while21_exit
1424   0BA1             _while21_block:
1425   0BA1             ;; i--; 
1426   0BA1 FA FA FF      lea d, [bp + -6] ; $i
1427   0BA4 2A            mov b, [d]
1428   0BA5 D8            push b
1429   0BA6 FD 7D         dec b
1430   0BA8 FA FA FF      lea d, [bp + -6] ; $i
1431   0BAB FD 43         mov [d], b
1432   0BAD E5            pop b
1433   0BAE             ;; putchar(digits[i]); 
1434   0BAE FA FC FF      lea d, [bp + -4] ; $digits
1435   0BB1 D7            push a
1436   0BB2 DA            push d
1437   0BB3 FA FA FF      lea d, [bp + -6] ; $i
1438   0BB6 2A            mov b, [d]
1439   0BB7 E7            pop d
1440   0BB8 5A            add d, b
1441   0BB9 E4            pop a
1442   0BBA 32            mov bl, [d]
1443   0BBB A7 00         mov bh, 0
1444   0BBD DD            push bl
1445   0BBE 07 6A 0E      call putchar
1446   0BC1 51 01 00      add sp, 1
1447   0BC4 0A 8E 0B      jmp _while21_cond
1448   0BC7             _while21_exit:
1449   0BC7 F9            leave
1450   0BC8 09            ret
1451   0BC9             
1452   0BC9             print_signed_long:
1453   0BC9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1454   0BCC             ; $digits 
1455   0BCC             ; $i 
1456   0BCC 10 00 00      mov a, $0
1457   0BCF 45 F5 FF      mov [bp + -11], a
1458   0BD2 52 0C 00      sub sp, 12
1459   0BD5             ;; if (num < 0) { 
1460   0BD5             _if22_cond:
1461   0BD5 FA 05 00      lea d, [bp + 5] ; $num
1462   0BD8 2A            mov b, [d]
1463   0BD9             ; START RELATIONAL
1464   0BD9 D7            push a
1465   0BDA 11            mov a, b
1466   0BDB 26 00 00      mov b, $0
1467   0BDE B0            cmp a, b
1468   0BDF FD 73         slt ; < 
1469   0BE1 E4            pop a
1470   0BE2             ; END RELATIONAL
1471   0BE2 C0 00 00      cmp b, 0
1472   0BE5 C6 02 0C      je _if22_else
1473   0BE8             _if22_true:
1474   0BE8             ;; putchar('-'); 
1475   0BE8 26 2D 00      mov b, $2d
1476   0BEB DD            push bl
1477   0BEC 07 6A 0E      call putchar
1478   0BEF 51 01 00      add sp, 1
1479   0BF2             ;; num = -num; 
1480   0BF2 FA 05 00      lea d, [bp + 5] ; $num
1481   0BF5 DA            push d
1482   0BF6 FA 05 00      lea d, [bp + 5] ; $num
1483   0BF9 2A            mov b, [d]
1484   0BFA FD 97         neg b
1485   0BFC E7            pop d
1486   0BFD FD 43         mov [d], b
1487   0BFF 0A 24 0C      jmp _if22_exit
1488   0C02             _if22_else:
1489   0C02             ;; if (num == 0) { 
1490   0C02             _if23_cond:
1491   0C02 FA 05 00      lea d, [bp + 5] ; $num
1492   0C05 2A            mov b, [d]
1493   0C06             ; START RELATIONAL
1494   0C06 D7            push a
1495   0C07 11            mov a, b
1496   0C08 26 00 00      mov b, $0
1497   0C0B B0            cmp a, b
1498   0C0C FD 71         seq ; ==
1499   0C0E E4            pop a
1500   0C0F             ; END RELATIONAL
1501   0C0F C0 00 00      cmp b, 0
1502   0C12 C6 24 0C      je _if23_exit
1503   0C15             _if23_true:
1504   0C15             ;; putchar('0'); 
1505   0C15 26 30 00      mov b, $30
1506   0C18 DD            push bl
1507   0C19 07 6A 0E      call putchar
1508   0C1C 51 01 00      add sp, 1
1509   0C1F             ;; return; 
1510   0C1F F9            leave
1511   0C20 09            ret
1512   0C21 0A 24 0C      jmp _if23_exit
1513   0C24             _if23_exit:
1514   0C24             _if22_exit:
1515   0C24             ;; while (num > 0) { 
1516   0C24             _while24_cond:
1517   0C24 FA 05 00      lea d, [bp + 5] ; $num
1518   0C27 2A            mov b, [d]
1519   0C28             ; START RELATIONAL
1520   0C28 D7            push a
1521   0C29 11            mov a, b
1522   0C2A 26 00 00      mov b, $0
1523   0C2D B0            cmp a, b
1524   0C2E FD 7F         sgt ; >
1525   0C30 E4            pop a
1526   0C31             ; END RELATIONAL
1527   0C31 C0 00 00      cmp b, 0
1528   0C34 C6 7F 0C      je _while24_exit
1529   0C37             _while24_block:
1530   0C37             ;; digits[i] = '0' + (num % 10); 
1531   0C37 FA F7 FF      lea d, [bp + -9] ; $digits
1532   0C3A D7            push a
1533   0C3B DA            push d
1534   0C3C FA F5 FF      lea d, [bp + -11] ; $i
1535   0C3F 2A            mov b, [d]
1536   0C40 E7            pop d
1537   0C41 5A            add d, b
1538   0C42 E4            pop a
1539   0C43 DA            push d
1540   0C44 26 30 00      mov b, $30
1541   0C47             ; START TERMS
1542   0C47 D7            push a
1543   0C48 11            mov a, b
1544   0C49 FA 05 00      lea d, [bp + 5] ; $num
1545   0C4C 2A            mov b, [d]
1546   0C4D             ; START FACTORS
1547   0C4D D7            push a
1548   0C4E 11            mov a, b
1549   0C4F 26 0A 00      mov b, $a
1550   0C52 AE            div a, b ; 
1551   0C53 11            mov a, b
1552   0C54 27            mov b, a
1553   0C55 E4            pop a
1554   0C56             ; END FACTORS
1555   0C56 54            add a, b
1556   0C57 27            mov b, a
1557   0C58 E4            pop a
1558   0C59             ; END TERMS
1559   0C59 E7            pop d
1560   0C5A FD 3E         mov [d], bl
1561   0C5C             ;; num = num / 10; 
1562   0C5C FA 05 00      lea d, [bp + 5] ; $num
1563   0C5F DA            push d
1564   0C60 FA 05 00      lea d, [bp + 5] ; $num
1565   0C63 2A            mov b, [d]
1566   0C64             ; START FACTORS
1567   0C64 D7            push a
1568   0C65 11            mov a, b
1569   0C66 26 0A 00      mov b, $a
1570   0C69 AE            div a, b
1571   0C6A 27            mov b, a
1572   0C6B E4            pop a
1573   0C6C             ; END FACTORS
1574   0C6C E7            pop d
1575   0C6D FD 43         mov [d], b
1576   0C6F             ;; i++; 
1577   0C6F FA F5 FF      lea d, [bp + -11] ; $i
1578   0C72 2A            mov b, [d]
1579   0C73 D8            push b
1580   0C74 FD 77         inc b
1581   0C76 FA F5 FF      lea d, [bp + -11] ; $i
1582   0C79 FD 43         mov [d], b
1583   0C7B E5            pop b
1584   0C7C 0A 24 0C      jmp _while24_cond
1585   0C7F             _while24_exit:
1586   0C7F             ;; while (i > 0) { 
1587   0C7F             _while25_cond:
1588   0C7F FA F5 FF      lea d, [bp + -11] ; $i
1589   0C82 2A            mov b, [d]
1590   0C83             ; START RELATIONAL
1591   0C83 D7            push a
1592   0C84 11            mov a, b
1593   0C85 26 00 00      mov b, $0
1594   0C88 B0            cmp a, b
1595   0C89 FD 7F         sgt ; >
1596   0C8B E4            pop a
1597   0C8C             ; END RELATIONAL
1598   0C8C C0 00 00      cmp b, 0
1599   0C8F C6 B8 0C      je _while25_exit
1600   0C92             _while25_block:
1601   0C92             ;; i--; 
1602   0C92 FA F5 FF      lea d, [bp + -11] ; $i
1603   0C95 2A            mov b, [d]
1604   0C96 D8            push b
1605   0C97 FD 7D         dec b
1606   0C99 FA F5 FF      lea d, [bp + -11] ; $i
1607   0C9C FD 43         mov [d], b
1608   0C9E E5            pop b
1609   0C9F             ;; putchar(digits[i]); 
1610   0C9F FA F7 FF      lea d, [bp + -9] ; $digits
1611   0CA2 D7            push a
1612   0CA3 DA            push d
1613   0CA4 FA F5 FF      lea d, [bp + -11] ; $i
1614   0CA7 2A            mov b, [d]
1615   0CA8 E7            pop d
1616   0CA9 5A            add d, b
1617   0CAA E4            pop a
1618   0CAB 32            mov bl, [d]
1619   0CAC A7 00         mov bh, 0
1620   0CAE DD            push bl
1621   0CAF 07 6A 0E      call putchar
1622   0CB2 51 01 00      add sp, 1
1623   0CB5 0A 7F 0C      jmp _while25_cond
1624   0CB8             _while25_exit:
1625   0CB8 F9            leave
1626   0CB9 09            ret
1627   0CBA             
1628   0CBA             print_unsigned_long:
1629   0CBA F8 00 00      enter 0 ; (push bp; mov bp, sp)
1630   0CBD             ; $digits 
1631   0CBD             ; $i 
1632   0CBD 52 0C 00      sub sp, 12
1633   0CC0             ;; i = 0; 
1634   0CC0 FA F5 FF      lea d, [bp + -11] ; $i
1635   0CC3 DA            push d
1636   0CC4 26 00 00      mov b, $0
1637   0CC7 E7            pop d
1638   0CC8 FD 43         mov [d], b
1639   0CCA             ;; if(num == 0){ 
1640   0CCA             _if26_cond:
1641   0CCA FA 05 00      lea d, [bp + 5] ; $num
1642   0CCD 2A            mov b, [d]
1643   0CCE             ; START RELATIONAL
1644   0CCE D7            push a
1645   0CCF 11            mov a, b
1646   0CD0 26 00 00      mov b, $0
1647   0CD3 B0            cmp a, b
1648   0CD4 FD 71         seq ; ==
1649   0CD6 E4            pop a
1650   0CD7             ; END RELATIONAL
1651   0CD7 C0 00 00      cmp b, 0
1652   0CDA C6 EC 0C      je _if26_exit
1653   0CDD             _if26_true:
1654   0CDD             ;; putchar('0'); 
1655   0CDD 26 30 00      mov b, $30
1656   0CE0 DD            push bl
1657   0CE1 07 6A 0E      call putchar
1658   0CE4 51 01 00      add sp, 1
1659   0CE7             ;; return; 
1660   0CE7 F9            leave
1661   0CE8 09            ret
1662   0CE9 0A EC 0C      jmp _if26_exit
1663   0CEC             _if26_exit:
1664   0CEC             ;; while (num > 0) { 
1665   0CEC             _while27_cond:
1666   0CEC FA 05 00      lea d, [bp + 5] ; $num
1667   0CEF 2A            mov b, [d]
1668   0CF0             ; START RELATIONAL
1669   0CF0 D7            push a
1670   0CF1 11            mov a, b
1671   0CF2 26 00 00      mov b, $0
1672   0CF5 B0            cmp a, b
1673   0CF6 FD 81         sgu ; > (unsigned)
1674   0CF8 E4            pop a
1675   0CF9             ; END RELATIONAL
1676   0CF9 C0 00 00      cmp b, 0
1677   0CFC C6 47 0D      je _while27_exit
1678   0CFF             _while27_block:
1679   0CFF             ;; digits[i] = '0' + (num % 10); 
1680   0CFF FA F7 FF      lea d, [bp + -9] ; $digits
1681   0D02 D7            push a
1682   0D03 DA            push d
1683   0D04 FA F5 FF      lea d, [bp + -11] ; $i
1684   0D07 2A            mov b, [d]
1685   0D08 E7            pop d
1686   0D09 5A            add d, b
1687   0D0A E4            pop a
1688   0D0B DA            push d
1689   0D0C 26 30 00      mov b, $30
1690   0D0F             ; START TERMS
1691   0D0F D7            push a
1692   0D10 11            mov a, b
1693   0D11 FA 05 00      lea d, [bp + 5] ; $num
1694   0D14 2A            mov b, [d]
1695   0D15             ; START FACTORS
1696   0D15 D7            push a
1697   0D16 11            mov a, b
1698   0D17 26 0A 00      mov b, $a
1699   0D1A AE            div a, b ; 
1700   0D1B 11            mov a, b
1701   0D1C 27            mov b, a
1702   0D1D E4            pop a
1703   0D1E             ; END FACTORS
1704   0D1E 54            add a, b
1705   0D1F 27            mov b, a
1706   0D20 E4            pop a
1707   0D21             ; END TERMS
1708   0D21 E7            pop d
1709   0D22 FD 3E         mov [d], bl
1710   0D24             ;; num = num / 10; 
1711   0D24 FA 05 00      lea d, [bp + 5] ; $num
1712   0D27 DA            push d
1713   0D28 FA 05 00      lea d, [bp + 5] ; $num
1714   0D2B 2A            mov b, [d]
1715   0D2C             ; START FACTORS
1716   0D2C D7            push a
1717   0D2D 11            mov a, b
1718   0D2E 26 0A 00      mov b, $a
1719   0D31 AE            div a, b
1720   0D32 27            mov b, a
1721   0D33 E4            pop a
1722   0D34             ; END FACTORS
1723   0D34 E7            pop d
1724   0D35 FD 43         mov [d], b
1725   0D37             ;; i++; 
1726   0D37 FA F5 FF      lea d, [bp + -11] ; $i
1727   0D3A 2A            mov b, [d]
1728   0D3B D8            push b
1729   0D3C FD 77         inc b
1730   0D3E FA F5 FF      lea d, [bp + -11] ; $i
1731   0D41 FD 43         mov [d], b
1732   0D43 E5            pop b
1733   0D44 0A EC 0C      jmp _while27_cond
1734   0D47             _while27_exit:
1735   0D47             ;; while (i > 0) { 
1736   0D47             _while28_cond:
1737   0D47 FA F5 FF      lea d, [bp + -11] ; $i
1738   0D4A 2A            mov b, [d]
1739   0D4B             ; START RELATIONAL
1740   0D4B D7            push a
1741   0D4C 11            mov a, b
1742   0D4D 26 00 00      mov b, $0
1743   0D50 B0            cmp a, b
1744   0D51 FD 7F         sgt ; >
1745   0D53 E4            pop a
1746   0D54             ; END RELATIONAL
1747   0D54 C0 00 00      cmp b, 0
1748   0D57 C6 80 0D      je _while28_exit
1749   0D5A             _while28_block:
1750   0D5A             ;; i--; 
1751   0D5A FA F5 FF      lea d, [bp + -11] ; $i
1752   0D5D 2A            mov b, [d]
1753   0D5E D8            push b
1754   0D5F FD 7D         dec b
1755   0D61 FA F5 FF      lea d, [bp + -11] ; $i
1756   0D64 FD 43         mov [d], b
1757   0D66 E5            pop b
1758   0D67             ;; putchar(digits[i]); 
1759   0D67 FA F7 FF      lea d, [bp + -9] ; $digits
1760   0D6A D7            push a
1761   0D6B DA            push d
1762   0D6C FA F5 FF      lea d, [bp + -11] ; $i
1763   0D6F 2A            mov b, [d]
1764   0D70 E7            pop d
1765   0D71 5A            add d, b
1766   0D72 E4            pop a
1767   0D73 32            mov bl, [d]
1768   0D74 A7 00         mov bh, 0
1769   0D76 DD            push bl
1770   0D77 07 6A 0E      call putchar
1771   0D7A 51 01 00      add sp, 1
1772   0D7D 0A 47 0D      jmp _while28_cond
1773   0D80             _while28_exit:
1774   0D80 F9            leave
1775   0D81 09            ret
1776   0D82             
1777   0D82             print_unsigned:
1778   0D82 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1779   0D85             ; $digits 
1780   0D85             ; $i 
1781   0D85 52 07 00      sub sp, 7
1782   0D88             ;; i = 0; 
1783   0D88 FA FA FF      lea d, [bp + -6] ; $i
1784   0D8B DA            push d
1785   0D8C 26 00 00      mov b, $0
1786   0D8F E7            pop d
1787   0D90 FD 43         mov [d], b
1788   0D92             ;; if(num == 0){ 
1789   0D92             _if29_cond:
1790   0D92 FA 05 00      lea d, [bp + 5] ; $num
1791   0D95 2A            mov b, [d]
1792   0D96             ; START RELATIONAL
1793   0D96 D7            push a
1794   0D97 11            mov a, b
1795   0D98 26 00 00      mov b, $0
1796   0D9B B0            cmp a, b
1797   0D9C FD 71         seq ; ==
1798   0D9E E4            pop a
1799   0D9F             ; END RELATIONAL
1800   0D9F C0 00 00      cmp b, 0
1801   0DA2 C6 B4 0D      je _if29_exit
1802   0DA5             _if29_true:
1803   0DA5             ;; putchar('0'); 
1804   0DA5 26 30 00      mov b, $30
1805   0DA8 DD            push bl
1806   0DA9 07 6A 0E      call putchar
1807   0DAC 51 01 00      add sp, 1
1808   0DAF             ;; return; 
1809   0DAF F9            leave
1810   0DB0 09            ret
1811   0DB1 0A B4 0D      jmp _if29_exit
1812   0DB4             _if29_exit:
1813   0DB4             ;; while (num > 0) { 
1814   0DB4             _while30_cond:
1815   0DB4 FA 05 00      lea d, [bp + 5] ; $num
1816   0DB7 2A            mov b, [d]
1817   0DB8             ; START RELATIONAL
1818   0DB8 D7            push a
1819   0DB9 11            mov a, b
1820   0DBA 26 00 00      mov b, $0
1821   0DBD B0            cmp a, b
1822   0DBE FD 81         sgu ; > (unsigned)
1823   0DC0 E4            pop a
1824   0DC1             ; END RELATIONAL
1825   0DC1 C0 00 00      cmp b, 0
1826   0DC4 C6 0F 0E      je _while30_exit
1827   0DC7             _while30_block:
1828   0DC7             ;; digits[i] = '0' + (num % 10); 
1829   0DC7 FA FC FF      lea d, [bp + -4] ; $digits
1830   0DCA D7            push a
1831   0DCB DA            push d
1832   0DCC FA FA FF      lea d, [bp + -6] ; $i
1833   0DCF 2A            mov b, [d]
1834   0DD0 E7            pop d
1835   0DD1 5A            add d, b
1836   0DD2 E4            pop a
1837   0DD3 DA            push d
1838   0DD4 26 30 00      mov b, $30
1839   0DD7             ; START TERMS
1840   0DD7 D7            push a
1841   0DD8 11            mov a, b
1842   0DD9 FA 05 00      lea d, [bp + 5] ; $num
1843   0DDC 2A            mov b, [d]
1844   0DDD             ; START FACTORS
1845   0DDD D7            push a
1846   0DDE 11            mov a, b
1847   0DDF 26 0A 00      mov b, $a
1848   0DE2 AE            div a, b ; 
1849   0DE3 11            mov a, b
1850   0DE4 27            mov b, a
1851   0DE5 E4            pop a
1852   0DE6             ; END FACTORS
1853   0DE6 54            add a, b
1854   0DE7 27            mov b, a
1855   0DE8 E4            pop a
1856   0DE9             ; END TERMS
1857   0DE9 E7            pop d
1858   0DEA FD 3E         mov [d], bl
1859   0DEC             ;; num = num / 10; 
1860   0DEC FA 05 00      lea d, [bp + 5] ; $num
1861   0DEF DA            push d
1862   0DF0 FA 05 00      lea d, [bp + 5] ; $num
1863   0DF3 2A            mov b, [d]
1864   0DF4             ; START FACTORS
1865   0DF4 D7            push a
1866   0DF5 11            mov a, b
1867   0DF6 26 0A 00      mov b, $a
1868   0DF9 AE            div a, b
1869   0DFA 27            mov b, a
1870   0DFB E4            pop a
1871   0DFC             ; END FACTORS
1872   0DFC E7            pop d
1873   0DFD FD 43         mov [d], b
1874   0DFF             ;; i++; 
1875   0DFF FA FA FF      lea d, [bp + -6] ; $i
1876   0E02 2A            mov b, [d]
1877   0E03 D8            push b
1878   0E04 FD 77         inc b
1879   0E06 FA FA FF      lea d, [bp + -6] ; $i
1880   0E09 FD 43         mov [d], b
1881   0E0B E5            pop b
1882   0E0C 0A B4 0D      jmp _while30_cond
1883   0E0F             _while30_exit:
1884   0E0F             ;; while (i > 0) { 
1885   0E0F             _while31_cond:
1886   0E0F FA FA FF      lea d, [bp + -6] ; $i
1887   0E12 2A            mov b, [d]
1888   0E13             ; START RELATIONAL
1889   0E13 D7            push a
1890   0E14 11            mov a, b
1891   0E15 26 00 00      mov b, $0
1892   0E18 B0            cmp a, b
1893   0E19 FD 7F         sgt ; >
1894   0E1B E4            pop a
1895   0E1C             ; END RELATIONAL
1896   0E1C C0 00 00      cmp b, 0
1897   0E1F C6 48 0E      je _while31_exit
1898   0E22             _while31_block:
1899   0E22             ;; i--; 
1900   0E22 FA FA FF      lea d, [bp + -6] ; $i
1901   0E25 2A            mov b, [d]
1902   0E26 D8            push b
1903   0E27 FD 7D         dec b
1904   0E29 FA FA FF      lea d, [bp + -6] ; $i
1905   0E2C FD 43         mov [d], b
1906   0E2E E5            pop b
1907   0E2F             ;; putchar(digits[i]); 
1908   0E2F FA FC FF      lea d, [bp + -4] ; $digits
1909   0E32 D7            push a
1910   0E33 DA            push d
1911   0E34 FA FA FF      lea d, [bp + -6] ; $i
1912   0E37 2A            mov b, [d]
1913   0E38 E7            pop d
1914   0E39 5A            add d, b
1915   0E3A E4            pop a
1916   0E3B 32            mov bl, [d]
1917   0E3C A7 00         mov bh, 0
1918   0E3E DD            push bl
1919   0E3F 07 6A 0E      call putchar
1920   0E42 51 01 00      add sp, 1
1921   0E45 0A 0F 0E      jmp _while31_cond
1922   0E48             _while31_exit:
1923   0E48 F9            leave
1924   0E49 09            ret
1925   0E4A             
1926   0E4A             rand:
1927   0E4A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1928   0E4D             ; $sec 
1929   0E4D 52 01 00      sub sp, 1
1930   0E50             
1931   0E50             ; --- BEGIN INLINE ASM BLOCK
1932   0E50 19 00         mov al, 0
1933   0E52 05 01         syscall sys_rtc					
1934   0E54 1A            mov al, ah
1935   0E55 FA 00 00      lea d, [bp + 0] ; $sec
1936   0E58 1E            mov al, [d]
1937   0E59             ; --- END INLINE ASM BLOCK
1938   0E59             
1939   0E59             ;; return sec; 
1940   0E59 FA 00 00      lea d, [bp + 0] ; $sec
1941   0E5C 32            mov bl, [d]
1942   0E5D A7 00         mov bh, 0
1943   0E5F F9            leave
1944   0E60 09            ret
1945   0E61             
1946   0E61             date:
1947   0E61 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1948   0E64             
1949   0E64             ; --- BEGIN INLINE ASM BLOCK
1950   0E64 19 00         mov al, 0 
1951   0E66 05 07         syscall sys_datetime
1952   0E68             ; --- END INLINE ASM BLOCK
1953   0E68             
1954   0E68 F9            leave
1955   0E69 09            ret
1956   0E6A             
1957   0E6A             putchar:
1958   0E6A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1959   0E6D             
1960   0E6D             ; --- BEGIN INLINE ASM BLOCK
1961   0E6D FA 05 00      lea d, [bp + 5] ; $c
1962   0E70 1E            mov al, [d]
1963   0E71 23            mov ah, al
1964   0E72 07 E7 10      call _putchar
1965   0E75             ; --- END INLINE ASM BLOCK
1966   0E75             
1967   0E75 F9            leave
1968   0E76 09            ret
1969   0E77             
1970   0E77             getchar:
1971   0E77 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1972   0E7A             ; $c 
1973   0E7A 52 01 00      sub sp, 1
1974   0E7D             
1975   0E7D             ; --- BEGIN INLINE ASM BLOCK
1976   0E7D 07 E0 10      call getch
1977   0E80 1A            mov al, ah
1978   0E81 FA 00 00      lea d, [bp + 0] ; $c
1979   0E84 3E            mov [d], al
1980   0E85             ; --- END INLINE ASM BLOCK
1981   0E85             
1982   0E85             ;; return c; 
1983   0E85 FA 00 00      lea d, [bp + 0] ; $c
1984   0E88 32            mov bl, [d]
1985   0E89 A7 00         mov bh, 0
1986   0E8B F9            leave
1987   0E8C 09            ret
1988   0E8D             
1989   0E8D             scann:
1990   0E8D F8 00 00      enter 0 ; (push bp; mov bp, sp)
1991   0E90             ; $m 
1992   0E90 52 02 00      sub sp, 2
1993   0E93             
1994   0E93             ; --- BEGIN INLINE ASM BLOCK
1995   0E93 07 2B 13      call scan_u16d
1996   0E96 FA FF FF      lea d, [bp + -1] ; $m
1997   0E99 43            mov [d], a
1998   0E9A             ; --- END INLINE ASM BLOCK
1999   0E9A             
2000   0E9A             ;; return m; 
2001   0E9A FA FF FF      lea d, [bp + -1] ; $m
2002   0E9D 2A            mov b, [d]
2003   0E9E F9            leave
2004   0E9F 09            ret
2005   0EA0             
2006   0EA0             puts:
2007   0EA0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2008   0EA3             
2009   0EA3             ; --- BEGIN INLINE ASM BLOCK
2010   0EA3 FA 05 00      lea d, [bp + 5] ; $s
2011   0EA6 15            mov a, [d]
2012   0EA7 3C            mov d, a
2013   0EA8 07 31 12      call _puts
2014   0EAB 10 00 0A      mov a, $0A00
2015   0EAE 05 03         syscall sys_io
2016   0EB0             ; --- END INLINE ASM BLOCK
2017   0EB0             
2018   0EB0 F9            leave
2019   0EB1 09            ret
2020   0EB2             
2021   0EB2             print:
2022   0EB2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2023   0EB5             
2024   0EB5             ; --- BEGIN INLINE ASM BLOCK
2025   0EB5 FA 05 00      lea d, [bp + 5] ; $s
2026   0EB8 FD 2A         mov d, [d]
2027   0EBA 07 31 12      call _puts
2028   0EBD             ; --- END INLINE ASM BLOCK
2029   0EBD             
2030   0EBD F9            leave
2031   0EBE 09            ret
2032   0EBF             
2033   0EBF             loadfile:
2034   0EBF F8 00 00      enter 0 ; (push bp; mov bp, sp)
2035   0EC2             
2036   0EC2             ; --- BEGIN INLINE ASM BLOCK
2037   0EC2 FA 07 00      lea d, [bp + 7] ; $destination
2038   0EC5 15            mov a, [d]
2039   0EC6 4F            mov di, a
2040   0EC7 FA 05 00      lea d, [bp + 5] ; $filename
2041   0ECA FD 2A         mov d, [d]
2042   0ECC 19 14         mov al, 20
2043   0ECE 05 04         syscall sys_filesystem
2044   0ED0             ; --- END INLINE ASM BLOCK
2045   0ED0             
2046   0ED0 F9            leave
2047   0ED1 09            ret
2048   0ED2             
2049   0ED2             create_file:
2050   0ED2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2051   0ED5 F9            leave
2052   0ED6 09            ret
2053   0ED7             
2054   0ED7             delete_file:
2055   0ED7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2056   0EDA             
2057   0EDA             ; --- BEGIN INLINE ASM BLOCK
2058   0EDA FA 05 00      lea d, [bp + 5] ; $filename
2059   0EDD 19 0A         mov al, 10
2060   0EDF 05 04         syscall sys_filesystem
2061   0EE1             ; --- END INLINE ASM BLOCK
2062   0EE1             
2063   0EE1 F9            leave
2064   0EE2 09            ret
2065   0EE3             
2066   0EE3             fopen:
2067   0EE3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2068   0EE6 F9            leave
2069   0EE7 09            ret
2070   0EE8             
2071   0EE8             fclose:
2072   0EE8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2073   0EEB F9            leave
2074   0EEC 09            ret
2075   0EED             
2076   0EED             alloc:
2077   0EED F8 00 00      enter 0 ; (push bp; mov bp, sp)
2078   0EF0             ;; heap_top = heap_top + bytes; 
2079   0EF0 3B 36 14      mov d, _heap_top ; $heap_top
2080   0EF3 DA            push d
2081   0EF4 3B 36 14      mov d, _heap_top ; $heap_top
2082   0EF7 2A            mov b, [d]
2083   0EF8             ; START TERMS
2084   0EF8 D7            push a
2085   0EF9 11            mov a, b
2086   0EFA FA 05 00      lea d, [bp + 5] ; $bytes
2087   0EFD 2A            mov b, [d]
2088   0EFE 54            add a, b
2089   0EFF 27            mov b, a
2090   0F00 E4            pop a
2091   0F01             ; END TERMS
2092   0F01 E7            pop d
2093   0F02 FD 43         mov [d], b
2094   0F04             ;; return heap_top - bytes; 
2095   0F04 3B 36 14      mov d, _heap_top ; $heap_top
2096   0F07 2A            mov b, [d]
2097   0F08             ; START TERMS
2098   0F08 D7            push a
2099   0F09 11            mov a, b
2100   0F0A FA 05 00      lea d, [bp + 5] ; $bytes
2101   0F0D 2A            mov b, [d]
2102   0F0E 60            sub a, b
2103   0F0F 27            mov b, a
2104   0F10 E4            pop a
2105   0F11             ; END TERMS
2106   0F11 F9            leave
2107   0F12 09            ret
2108   0F13             
2109   0F13             free:
2110   0F13 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2111   0F16             ;; return heap_top = heap_top - bytes; 
2112   0F16 3B 36 14      mov d, _heap_top ; $heap_top
2113   0F19 DA            push d
2114   0F1A 3B 36 14      mov d, _heap_top ; $heap_top
2115   0F1D 2A            mov b, [d]
2116   0F1E             ; START TERMS
2117   0F1E D7            push a
2118   0F1F 11            mov a, b
2119   0F20 FA 05 00      lea d, [bp + 5] ; $bytes
2120   0F23 2A            mov b, [d]
2121   0F24 60            sub a, b
2122   0F25 27            mov b, a
2123   0F26 E4            pop a
2124   0F27             ; END TERMS
2125   0F27 E7            pop d
2126   0F28 FD 43         mov [d], b
2127   0F2A F9            leave
2128   0F2B 09            ret
2129   0F2C             
2130   0F2C             exit:
2131   0F2C F8 00 00      enter 0 ; (push bp; mov bp, sp)
2132   0F2F             
2133   0F2F             ; --- BEGIN INLINE ASM BLOCK
2134   0F2F 05 0B         syscall sys_terminate_proc
2135   0F31             ; --- END INLINE ASM BLOCK
2136   0F31             
2137   0F31 F9            leave
2138   0F32 09            ret
2139   0F33             
2140   0F33             load_hex:
2141   0F33 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2142   0F36             ; $temp 
2143   0F36 52 02 00      sub sp, 2
2144   0F39             ;; temp = alloc(32768); 
2145   0F39 FA FF FF      lea d, [bp + -1] ; $temp
2146   0F3C DA            push d
2147   0F3D 26 00 80      mov b, $8000
2148   0F40 FD AB         swp b
2149   0F42 D8            push b
2150   0F43 07 ED 0E      call alloc
2151   0F46 51 02 00      add sp, 2
2152   0F49 E7            pop d
2153   0F4A FD 43         mov [d], b
2154   0F4C             
2155   0F4C             ; --- BEGIN INLINE ASM BLOCK
2156   0F4C               
2157   0F4C               
2158   0F4C               
2159   0F4C               
2160   0F4C               
2161   0F4C             _load_hex:
2162   0F4C D7            push a
2163   0F4D D8            push b
2164   0F4E DA            push d
2165   0F4F E2            push si
2166   0F50 E3            push di
2167   0F51 52 00 80      sub sp, $8000      
2168   0F54 38 00 00      mov c, 0
2169   0F57 48            mov a, sp
2170   0F58 77            inc a
2171   0F59 3C            mov d, a          
2172   0F5A 07 EE 10      call _gets        
2173   0F5D 4D            mov si, a
2174   0F5E             __load_hex_loop:
2175   0F5E F6            lodsb             
2176   0F5F B9 00         cmp al, 0         
2177   0F61 C6 6F 0F      jz __load_hex_ret
2178   0F64 36            mov bh, al
2179   0F65 F6            lodsb
2180   0F66 2F            mov bl, al
2181   0F67 07 A4 10      call _atoi        
2182   0F6A F7            stosb             
2183   0F6B 78            inc c
2184   0F6C 0A 5E 0F      jmp __load_hex_loop
2185   0F6F             __load_hex_ret:
2186   0F6F 51 00 80      add sp, $8000
2187   0F72 F0            pop di
2188   0F73 EF            pop si
2189   0F74 E7            pop d
2190   0F75 E5            pop b
2191   0F76 E4            pop a
2192   0F77             ; --- END INLINE ASM BLOCK
2193   0F77             
2194   0F77 F9            leave
2195   0F78 09            ret
2196   0F79             
2197   0F79             getparam:
2198   0F79 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2199   0F7C             ; $data 
2200   0F7C 52 01 00      sub sp, 1
2201   0F7F             
2202   0F7F             ; --- BEGIN INLINE ASM BLOCK
2203   0F7F 19 04         mov al, 4
2204   0F81 FA 05 00      lea d, [bp + 5] ; $address
2205   0F84 FD 2A         mov d, [d]
2206   0F86 05 0C         syscall sys_system
2207   0F88 FA 00 00      lea d, [bp + 0] ; $data
2208   0F8B FD 3E         mov [d], bl
2209   0F8D             ; --- END INLINE ASM BLOCK
2210   0F8D             
2211   0F8D             ;; return data; 
2212   0F8D FA 00 00      lea d, [bp + 0] ; $data
2213   0F90 32            mov bl, [d]
2214   0F91 A7 00         mov bh, 0
2215   0F93 F9            leave
2216   0F94 09            ret
2217   0F95             
2218   0F95             clear:
2219   0F95 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2220   0F98             ;; print("\033[2J\033[H"); 
2221   0F98 26 2C 14      mov b, __s2 ; "\033[2J\033[H"
2222   0F9B FD AB         swp b
2223   0F9D D8            push b
2224   0F9E 07 B2 0E      call print
2225   0FA1 51 02 00      add sp, 2
2226   0FA4 F9            leave
2227   0FA5 09            ret
2228   0FA6             
2229   0FA6             printun:
2230   0FA6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2231   0FA9             ;; print(prompt); 
2232   0FA9 FA 05 00      lea d, [bp + 5] ; $prompt
2233   0FAC 2A            mov b, [d]
2234   0FAD FD AB         swp b
2235   0FAF D8            push b
2236   0FB0 07 B2 0E      call print
2237   0FB3 51 02 00      add sp, 2
2238   0FB6             ;; print_unsigned(n); 
2239   0FB6 FA 07 00      lea d, [bp + 7] ; $n
2240   0FB9 2A            mov b, [d]
2241   0FBA FD AB         swp b
2242   0FBC D8            push b
2243   0FBD 07 82 0D      call print_unsigned
2244   0FC0 51 02 00      add sp, 2
2245   0FC3             ;; print("\n"); 
2246   0FC3 26 34 14      mov b, __s3 ; "\n"
2247   0FC6 FD AB         swp b
2248   0FC8 D8            push b
2249   0FC9 07 B2 0E      call print
2250   0FCC 51 02 00      add sp, 2
2251   0FCF F9            leave
2252   0FD0 09            ret
2253   0FD1             
2254   0FD1             printsn:
2255   0FD1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2256   0FD4             ;; print(prompt); 
2257   0FD4 FA 05 00      lea d, [bp + 5] ; $prompt
2258   0FD7 2A            mov b, [d]
2259   0FD8 FD AB         swp b
2260   0FDA D8            push b
2261   0FDB 07 B2 0E      call print
2262   0FDE 51 02 00      add sp, 2
2263   0FE1             ;; print_signed(n); 
2264   0FE1 FA 07 00      lea d, [bp + 7] ; $n
2265   0FE4 2A            mov b, [d]
2266   0FE5 FD AB         swp b
2267   0FE7 D8            push b
2268   0FE8 07 D8 0A      call print_signed
2269   0FEB 51 02 00      add sp, 2
2270   0FEE             ;; print("\n"); 
2271   0FEE 26 34 14      mov b, __s3 ; "\n"
2272   0FF1 FD AB         swp b
2273   0FF3 D8            push b
2274   0FF4 07 B2 0E      call print
2275   0FF7 51 02 00      add sp, 2
2276   0FFA F9            leave
2277   0FFB 09            ret
2278   0FFC             
2279   0FFC             include_stdio_asm:
2280   0FFC F8 00 00      enter 0 ; (push bp; mov bp, sp)
2281   0FFF             
2282   0FFF             ; --- BEGIN INLINE ASM BLOCK
2283   0FFF             .include "lib/asm/stdio.asm"
0001+  0FFF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0FFF             ; stdio.s
0003+  0FFF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0FFF             .include "lib/asm/string.asm"
0001++ 0FFF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0FFF             ; string.s
0003++ 0FFF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0FFF             
0005++ 0FFF             
0006++ 0FFF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0FFF             ; _strrev
0008++ 0FFF             ; reverse a string
0009++ 0FFF             ; D = string address
0010++ 0FFF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0FFF             ; 01234
0012++ 0FFF             _strrev:
0013++ 0FFF 4B          	pusha
0014++ 1000 07 46 10    	call _strlen	; length in C
0015++ 1003 12          	mov a, c
0016++ 1004 AF 01 00    	cmp a, 1
0017++ 1007 D0 21 10    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 100A 7D          	dec a
0019++ 100B FD 4E       	mov si, d	; beginning of string
0020++ 100D FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 100F 59          	add d, a	; end of string
0022++ 1010 12          	mov a, c
0023++ 1011 FD 9B       	shr a		; divide by 2
0024++ 1013 39          	mov c, a	; C now counts the steps
0025++ 1014             _strrev_L0:
0026++ 1014 32          	mov bl, [d]	; save load right-side char into BL
0027++ 1015 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 1016 3E          	mov [d], al	; store left char into right side
0029++ 1017 1B          	mov al, bl
0030++ 1018 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 1019 7E          	dec c
0032++ 101A 7F          	dec d
0033++ 101B C2 00 00    	cmp c, 0
0034++ 101E C7 14 10    	jne _strrev_L0
0035++ 1021             _strrev_end:
0036++ 1021 4C          	popa
0037++ 1022 09          	ret
0038++ 1023             	
0039++ 1023             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 1023             ; _strchr
0041++ 1023             ; search string in D for char in AL
0042++ 1023             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 1023             _strchr:
0044++ 1023             _strchr_L0:
0045++ 1023 32          	mov bl, [d]
0046++ 1024 C1 00       	cmp bl, 0
0047++ 1026 C6 31 10    	je _strchr_end
0048++ 1029 BA          	cmp al, bl
0049++ 102A C6 31 10    	je _strchr_end
0050++ 102D 79          	inc d
0051++ 102E 0A 23 10    	jmp _strchr_L0
0052++ 1031             _strchr_end:
0053++ 1031 1B          	mov al, bl
0054++ 1032 09          	ret
0055++ 1033             
0056++ 1033             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 1033             ; _strstr
0058++ 1033             ; find sub-string
0059++ 1033             ; str1 in SI
0060++ 1033             ; str2 in DI
0061++ 1033             ; SI points to end of source string
0062++ 1033             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 1033             _strstr:
0064++ 1033 DB          	push al
0065++ 1034 DA          	push d
0066++ 1035 E3          	push di
0067++ 1036             _strstr_loop:
0068++ 1036 F3          	cmpsb					; compare a byte of the strings
0069++ 1037 C7 42 10    	jne _strstr_ret
0070++ 103A FC 00 00    	lea d, [di + 0]
0071++ 103D BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 103F C7 36 10    	jne _strstr_loop				; equal chars but not at end
0073++ 1042             _strstr_ret:
0074++ 1042 F0          	pop di
0075++ 1043 E7          	pop d
0076++ 1044 E8          	pop al
0077++ 1045 09          	ret
0078++ 1046             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1046             ; length of null terminated string
0080++ 1046             ; result in C
0081++ 1046             ; pointer in D
0082++ 1046             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1046             _strlen:
0084++ 1046 DA          	push d
0085++ 1047 38 00 00    	mov c, 0
0086++ 104A             _strlen_L1:
0087++ 104A BD 00       	cmp byte [d], 0
0088++ 104C C6 54 10    	je _strlen_ret
0089++ 104F 79          	inc d
0090++ 1050 78          	inc c
0091++ 1051 0A 4A 10    	jmp _strlen_L1
0092++ 1054             _strlen_ret:
0093++ 1054 E7          	pop d
0094++ 1055 09          	ret
0095++ 1056             
0096++ 1056             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1056             ; STRCMP
0098++ 1056             ; compare two strings
0099++ 1056             ; str1 in SI
0100++ 1056             ; str2 in DI
0101++ 1056             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 1056             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1056             _strcmp:
0104++ 1056 DB          	push al
0105++ 1057 DA          	push d
0106++ 1058 E3          	push di
0107++ 1059 E2          	push si
0108++ 105A             _strcmp_loop:
0109++ 105A F3          	cmpsb					; compare a byte of the strings
0110++ 105B C7 66 10    	jne _strcmp_ret
0111++ 105E FB FF FF    	lea d, [si +- 1]
0112++ 1061 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1063 C7 5A 10    	jne _strcmp_loop				; equal chars but not at end
0114++ 1066             _strcmp_ret:
0115++ 1066 EF          	pop si
0116++ 1067 F0          	pop di
0117++ 1068 E7          	pop d
0118++ 1069 E8          	pop al
0119++ 106A 09          	ret
0120++ 106B             
0121++ 106B             
0122++ 106B             ; STRCPY
0123++ 106B             ; copy null terminated string from SI to DI
0124++ 106B             ; source in SI
0125++ 106B             ; destination in DI
0126++ 106B             _strcpy:
0127++ 106B E2          	push si
0128++ 106C E3          	push di
0129++ 106D DB          	push al
0130++ 106E             _strcpy_L1:
0131++ 106E F6          	lodsb
0132++ 106F F7          	stosb
0133++ 1070 B9 00       	cmp al, 0
0134++ 1072 C7 6E 10    	jne _strcpy_L1
0135++ 1075             _strcpy_end:
0136++ 1075 E8          	pop al
0137++ 1076 F0          	pop di
0138++ 1077 EF          	pop si
0139++ 1078 09          	ret
0140++ 1079             
0141++ 1079             ; STRCAT
0142++ 1079             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 1079             ; source in SI
0144++ 1079             ; destination in DI
0145++ 1079             _strcat:
0146++ 1079 E2          	push si
0147++ 107A E3          	push di
0148++ 107B D7          	push a
0149++ 107C DA          	push d
0150++ 107D 50          	mov a, di
0151++ 107E 3C          	mov d, a
0152++ 107F             _strcat_goto_end_L1:
0153++ 107F BD 00       	cmp byte[d], 0
0154++ 1081 C6 88 10    	je _strcat_start
0155++ 1084 79          	inc d
0156++ 1085 0A 7F 10    	jmp _strcat_goto_end_L1
0157++ 1088             _strcat_start:
0158++ 1088 FD 50       	mov di, d
0159++ 108A             _strcat_L1:
0160++ 108A F6          	lodsb
0161++ 108B F7          	stosb
0162++ 108C B9 00       	cmp al, 0
0163++ 108E C7 8A 10    	jne _strcat_L1
0164++ 1091             _strcat_end:
0165++ 1091 E7          	pop d
0166++ 1092 E4          	pop a
0167++ 1093 F0          	pop di
0168++ 1094 EF          	pop si
0169++ 1095 09          	ret
0170++ 1096             
0171++ 1096             
0005+  1096             
0006+  1096             
0007+  1096             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  1096             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  1096             ; ASCII in BL
0010+  1096             ; result in AL
0011+  1096             ; ascii for F = 0100 0110
0012+  1096             ; ascii for 9 = 0011 1001
0013+  1096             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  1096             hex_ascii_encode:
0015+  1096 1B            mov al, bl
0016+  1097 93 40         test al, $40        ; test if letter or number
0017+  1099 C7 9F 10      jnz hex_letter
0018+  109C 87 0F         and al, $0F        ; get number
0019+  109E 09            ret
0020+  109F             hex_letter:
0021+  109F 87 0F         and al, $0F        ; get letter
0022+  10A1 6A 09         add al, 9
0023+  10A3 09            ret
0024+  10A4             
0025+  10A4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  10A4             ; ATOI
0027+  10A4             ; 2 letter hex string in B
0028+  10A4             ; 8bit integer returned in AL
0029+  10A4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  10A4             _atoi:
0031+  10A4 D8            push b
0032+  10A5 07 96 10      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  10A8 30            mov bl, bh
0034+  10A9 DB            push al          ; save a
0035+  10AA 07 96 10      call hex_ascii_encode
0036+  10AD EA            pop bl  
0037+  10AE FD 9E 04      shl al, 4
0038+  10B1 8C            or al, bl
0039+  10B2 E5            pop b
0040+  10B3 09            ret  
0041+  10B4             
0042+  10B4             
0043+  10B4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  10B4             ; scanf
0045+  10B4             ; no need for explanations!
0046+  10B4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  10B4             scanf:
0048+  10B4 09            ret
0049+  10B5             
0050+  10B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  10B5             ; ITOA
0052+  10B5             ; 8bit value in BL
0053+  10B5             ; 2 byte ASCII result in A
0054+  10B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  10B5             _itoa:
0056+  10B5 DA            push d
0057+  10B6 D8            push b
0058+  10B7 A7 00         mov bh, 0
0059+  10B9 FD A4 04      shr bl, 4  
0060+  10BC 74            mov d, b
0061+  10BD 1F 65 13      mov al, [d + s_hex_digits]
0062+  10C0 23            mov ah, al
0063+  10C1               
0064+  10C1 E5            pop b
0065+  10C2 D8            push b
0066+  10C3 A7 00         mov bh, 0
0067+  10C5 FD 87 0F      and bl, $0F
0068+  10C8 74            mov d, b
0069+  10C9 1F 65 13      mov al, [d + s_hex_digits]
0070+  10CC E5            pop b
0071+  10CD E7            pop d
0072+  10CE 09            ret
0073+  10CF             
0074+  10CF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  10CF             ; HEX STRING TO BINARY
0076+  10CF             ; di = destination address
0077+  10CF             ; si = source
0078+  10CF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  10CF             _hex_to_int:
0080+  10CF             _hex_to_int_L1:
0081+  10CF F6            lodsb          ; load from [SI] to AL
0082+  10D0 B9 00         cmp al, 0        ; check if ASCII 0
0083+  10D2 C6 DF 10      jz _hex_to_int_ret
0084+  10D5 36            mov bh, al
0085+  10D6 F6            lodsb
0086+  10D7 2F            mov bl, al
0087+  10D8 07 A4 10      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  10DB F7            stosb          ; store AL to [DI]
0089+  10DC 0A CF 10      jmp _hex_to_int_L1
0090+  10DF             _hex_to_int_ret:
0091+  10DF 09            ret    
0092+  10E0             
0093+  10E0             
0094+  10E0             
0095+  10E0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  10E0             ; GETCHAR
0097+  10E0             ; char in ah
0098+  10E0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  10E0             getch:
0100+  10E0 DB            push al
0101+  10E1             getch_retry:
0102+  10E1 19 01         mov al, 1
0103+  10E3 05 03         syscall sys_io      ; receive in AH
0104+  10E5 E8            pop al
0105+  10E6 09            ret
0106+  10E7             
0107+  10E7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  10E7             ; PUTCHAR
0109+  10E7             ; char in ah
0110+  10E7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  10E7             _putchar:
0112+  10E7 D7            push a
0113+  10E8 19 00         mov al, 0
0114+  10EA 05 03         syscall sys_io      ; char in AH
0115+  10EC E4            pop a
0116+  10ED 09            ret
0117+  10EE             
0118+  10EE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  10EE             ;; INPUT A STRING
0120+  10EE             ;; terminates with null
0121+  10EE             ;; pointer in D
0122+  10EE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  10EE             _gets:
0124+  10EE D7            push a
0125+  10EF DA            push d
0126+  10F0             _gets_loop:
0127+  10F0 19 01         mov al, 1
0128+  10F2 05 03         syscall sys_io      ; receive in AH
0129+  10F4 B9 00         cmp al, 0        ; check error code (AL)
0130+  10F6 C6 F0 10      je _gets_loop      ; if no char received, retry
0131+  10F9             
0132+  10F9 76 1B         cmp ah, 27
0133+  10FB C6 1C 11      je _gets_ansi_esc
0134+  10FE 76 0A         cmp ah, $0A        ; LF
0135+  1100 C6 87 11      je _gets_end
0136+  1103 76 0D         cmp ah, $0D        ; CR
0137+  1105 C6 87 11      je _gets_end
0138+  1108 76 5C         cmp ah, $5C        ; '\\'
0139+  110A C6 48 11      je _gets_escape
0140+  110D               
0141+  110D 76 08         cmp ah, $08      ; check for backspace
0142+  110F C6 18 11      je _gets_backspace
0143+  1112             
0144+  1112 1A            mov al, ah
0145+  1113 3E            mov [d], al
0146+  1114 79            inc d
0147+  1115 0A F0 10      jmp _gets_loop
0148+  1118             _gets_backspace:
0149+  1118 7F            dec d
0150+  1119 0A F0 10      jmp _gets_loop
0151+  111C             _gets_ansi_esc:
0152+  111C 19 01         mov al, 1
0153+  111E 05 03         syscall sys_io        ; receive in AH without echo
0154+  1120 B9 00         cmp al, 0          ; check error code (AL)
0155+  1122 C6 1C 11      je _gets_ansi_esc    ; if no char received, retry
0156+  1125 76 5B         cmp ah, '['
0157+  1127 C7 F0 10      jne _gets_loop
0158+  112A             _gets_ansi_esc_2:
0159+  112A 19 01         mov al, 1
0160+  112C 05 03         syscall sys_io          ; receive in AH without echo
0161+  112E B9 00         cmp al, 0            ; check error code (AL)
0162+  1130 C6 2A 11      je _gets_ansi_esc_2  ; if no char received, retry
0163+  1133 76 44         cmp ah, 'D'
0164+  1135 C6 40 11      je _gets_left_arrow
0165+  1138 76 43         cmp ah, 'C'
0166+  113A C6 44 11      je _gets_right_arrow
0167+  113D 0A F0 10      jmp _gets_loop
0168+  1140             _gets_left_arrow:
0169+  1140 7F            dec d
0170+  1141 0A F0 10      jmp _gets_loop
0171+  1144             _gets_right_arrow:
0172+  1144 79            inc d
0173+  1145 0A F0 10      jmp _gets_loop
0174+  1148             _gets_escape:
0175+  1148 19 01         mov al, 1
0176+  114A 05 03         syscall sys_io      ; receive in AH
0177+  114C B9 00         cmp al, 0        ; check error code (AL)
0178+  114E C6 48 11      je _gets_escape      ; if no char received, retry
0179+  1151 76 6E         cmp ah, 'n'
0180+  1153 C6 72 11      je _gets_LF
0181+  1156 76 72         cmp ah, 'r'
0182+  1158 C6 79 11      je _gets_CR
0183+  115B 76 30         cmp ah, '0'
0184+  115D C6 80 11      je _gets_NULL
0185+  1160 76 5C         cmp ah, $5C  ; '\'
0186+  1162 C6 6B 11      je _gets_slash
0187+  1165 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0188+  1166 3E            mov [d], al
0189+  1167 79            inc d
0190+  1168 0A F0 10      jmp _gets_loop
0191+  116B             _gets_slash:
0192+  116B 19 5C         mov al, $5C
0193+  116D 3E            mov [d], al
0194+  116E 79            inc d
0195+  116F 0A F0 10      jmp _gets_loop
0196+  1172             _gets_LF:
0197+  1172 19 0A         mov al, $0A
0198+  1174 3E            mov [d], al
0199+  1175 79            inc d
0200+  1176 0A F0 10      jmp _gets_loop
0201+  1179             _gets_CR:
0202+  1179 19 0D         mov al, $0D
0203+  117B 3E            mov [d], al
0204+  117C 79            inc d
0205+  117D 0A F0 10      jmp _gets_loop
0206+  1180             _gets_NULL:
0207+  1180 19 00         mov al, $00
0208+  1182 3E            mov [d], al
0209+  1183 79            inc d
0210+  1184 0A F0 10      jmp _gets_loop
0211+  1187             _gets_end:
0212+  1187 19 00         mov al, 0
0213+  1189 3E            mov [d], al        ; terminate string
0214+  118A E7            pop d
0215+  118B E4            pop a
0216+  118C 09            ret
0217+  118D             
0218+  118D             
0219+  118D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0220+  118D             ;; INPUT TEXT
0221+  118D             ;; terminated with CTRL+D
0222+  118D             ;; pointer in D
0223+  118D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0224+  118D             _gettxt:
0225+  118D D7            push a
0226+  118E DA            push d
0227+  118F             _gettxt_loop:
0228+  118F 19 01         mov al, 1
0229+  1191 05 03         syscall sys_io      ; receive in AH
0230+  1193 B9 00         cmp al, 0        ; check error code (AL)
0231+  1195 C6 8F 11      je _gettxt_loop    ; if no char received, retry
0232+  1198 76 04         cmp ah, 4      ; EOT
0233+  119A C6 D8 11      je _gettxt_end
0234+  119D 76 08         cmp ah, $08      ; check for backspace
0235+  119F C6 D4 11      je _gettxt_backspace
0236+  11A2 76 5C         cmp ah, $5C        ; '\'
0237+  11A4 C6 AD 11      je _gettxt_escape
0238+  11A7 1A            mov al, ah
0239+  11A8 3E            mov [d], al
0240+  11A9 79            inc d
0241+  11AA 0A 8F 11      jmp _gettxt_loop
0242+  11AD             _gettxt_escape:
0243+  11AD 19 01         mov al, 1
0244+  11AF 05 03         syscall sys_io      ; receive in AH
0245+  11B1 B9 00         cmp al, 0        ; check error code (AL)
0246+  11B3 C6 AD 11      je _gettxt_escape    ; if no char received, retry
0247+  11B6 76 6E         cmp ah, 'n'
0248+  11B8 C6 C6 11      je _gettxt_LF
0249+  11BB 76 72         cmp ah, 'r'
0250+  11BD C6 CD 11      je _gettxt_CR
0251+  11C0 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0252+  11C1 3E            mov [d], al
0253+  11C2 79            inc d
0254+  11C3 0A 8F 11      jmp _gettxt_loop
0255+  11C6             _gettxt_LF:
0256+  11C6 19 0A         mov al, $0A
0257+  11C8 3E            mov [d], al
0258+  11C9 79            inc d
0259+  11CA 0A 8F 11      jmp _gettxt_loop
0260+  11CD             _gettxt_CR:
0261+  11CD 19 0D         mov al, $0D
0262+  11CF 3E            mov [d], al
0263+  11D0 79            inc d
0264+  11D1 0A 8F 11      jmp _gettxt_loop
0265+  11D4             _gettxt_backspace:
0266+  11D4 7F            dec d
0267+  11D5 0A 8F 11      jmp _gettxt_loop
0268+  11D8             _gettxt_end:
0269+  11D8 19 00         mov al, 0
0270+  11DA 3E            mov [d], al        ; terminate string
0271+  11DB E7            pop d
0272+  11DC E4            pop a
0273+  11DD 09            ret
0274+  11DE             
0275+  11DE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  11DE             ; PRINT NEW LINE
0277+  11DE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0278+  11DE             printnl:
0279+  11DE D7            push a
0280+  11DF 10 00 0A      mov a, $0A00
0281+  11E2 05 03         syscall sys_io
0282+  11E4 10 00 0D      mov a, $0D00
0283+  11E7 05 03         syscall sys_io
0284+  11E9 E4            pop a
0285+  11EA 09            ret
0286+  11EB             
0287+  11EB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  11EB             ; _strtoint
0289+  11EB             ; 4 digit hex string number in d
0290+  11EB             ; integer returned in A
0291+  11EB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0292+  11EB             _strtointx:
0293+  11EB D8            push b
0294+  11EC 32            mov bl, [d]
0295+  11ED 37            mov bh, bl
0296+  11EE 33 01 00      mov bl, [d + 1]
0297+  11F1 07 A4 10      call _atoi        ; convert to int in AL
0298+  11F4 23            mov ah, al        ; move to AH
0299+  11F5 33 02 00      mov bl, [d + 2]
0300+  11F8 37            mov bh, bl
0301+  11F9 33 03 00      mov bl, [d + 3]
0302+  11FC 07 A4 10      call _atoi        ; convert to int in AL
0303+  11FF E5            pop b
0304+  1200 09            ret
0305+  1201             
0306+  1201             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0307+  1201             ; _strtoint
0308+  1201             ; 5 digit base10 string number in d
0309+  1201             ; integer returned in A
0310+  1201             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0311+  1201             _strtoint:
0312+  1201 E2            push si
0313+  1202 D8            push b
0314+  1203 D9            push c
0315+  1204 DA            push d
0316+  1205 07 46 10      call _strlen      ; get string length in C
0317+  1208 7E            dec c
0318+  1209 FD 4E         mov si, d
0319+  120B 12            mov a, c
0320+  120C FD 99         shl a
0321+  120E 3B 7D 13      mov d, table_power
0322+  1211 59            add d, a
0323+  1212 38 00 00      mov c, 0
0324+  1215             _strtoint_L0:
0325+  1215 F6            lodsb      ; load ASCII to al
0326+  1216 B9 00         cmp al, 0
0327+  1218 C6 2B 12      je _strtoint_end
0328+  121B 6F 30         sub al, $30    ; make into integer
0329+  121D 22 00         mov ah, 0
0330+  121F 2A            mov b, [d]
0331+  1220 AC            mul a, b      ; result in B since it fits in 16bits
0332+  1221 11            mov a, b
0333+  1222 28            mov b, c
0334+  1223 54            add a, b
0335+  1224 39            mov c, a
0336+  1225 63 02 00      sub d, 2
0337+  1228 0A 15 12      jmp _strtoint_L0
0338+  122B             _strtoint_end:
0339+  122B 12            mov a, c
0340+  122C E7            pop d
0341+  122D E6            pop c
0342+  122E E5            pop b
0343+  122F EF            pop si
0344+  1230 09            ret
0345+  1231             
0346+  1231             
0347+  1231             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0348+  1231             ; PRINT NULL TERMINATED STRING
0349+  1231             ; pointer in D
0350+  1231             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0351+  1231             _puts:
0352+  1231 D7            push a
0353+  1232 DA            push d
0354+  1233             _puts_L1:
0355+  1233 1E            mov al, [d]
0356+  1234 B9 00         cmp al, 0
0357+  1236 C6 42 12      jz _puts_END
0358+  1239 23            mov ah, al
0359+  123A 19 00         mov al, 0
0360+  123C 05 03         syscall sys_io
0361+  123E 79            inc d
0362+  123F 0A 33 12      jmp _puts_L1
0363+  1242             _puts_END:
0364+  1242 E7            pop d
0365+  1243 E4            pop a
0366+  1244 09            ret
0367+  1245             
0368+  1245             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0369+  1245             ; PRINT N SIZE STRING
0370+  1245             ; pointer in D
0371+  1245             ; size in C
0372+  1245             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0373+  1245             _putsn:
0374+  1245 DB            push al
0375+  1246 DA            push d
0376+  1247 D9            push c
0377+  1248             _putsn_L0:
0378+  1248 1E            mov al, [d]
0379+  1249 23            mov ah, al
0380+  124A 19 00         mov al, 0
0381+  124C 05 03         syscall sys_io
0382+  124E 79            inc d
0383+  124F 7E            dec c  
0384+  1250 C2 00 00      cmp c, 0
0385+  1253 C7 48 12      jne _putsn_L0
0386+  1256             _putsn_end:
0387+  1256 E6            pop c
0388+  1257 E7            pop d
0389+  1258 E8            pop al
0390+  1259 09            ret
0391+  125A             
0392+  125A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0393+  125A             ; print 16bit decimal number
0394+  125A             ; input number in A
0395+  125A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0396+  125A             print_u16d:
0397+  125A D7            push a
0398+  125B D8            push b
0399+  125C 26 10 27      mov b, 10000
0400+  125F AE            div a, b      ; get 10000's coeff.
0401+  1260 07 82 12      call print_number
0402+  1263 11            mov a, b
0403+  1264 26 E8 03      mov b, 1000
0404+  1267 AE            div a, b      ; get 1000's coeff.
0405+  1268 07 82 12      call print_number
0406+  126B 11            mov a, b
0407+  126C 26 64 00      mov b, 100
0408+  126F AE            div a, b
0409+  1270 07 82 12      call print_number
0410+  1273 11            mov a, b
0411+  1274 26 0A 00      mov b, 10
0412+  1277 AE            div a, b
0413+  1278 07 82 12      call print_number
0414+  127B 1B            mov al, bl      ; 1's coeff in bl
0415+  127C 07 82 12      call print_number
0416+  127F E5            pop b
0417+  1280 E4            pop a
0418+  1281 09            ret
0419+  1282             
0420+  1282             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0421+  1282             ; print AL
0422+  1282             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0423+  1282             print_number:
0424+  1282 6A 30         add al, $30
0425+  1284 23            mov ah, al
0426+  1285 07 E7 10      call _putchar
0427+  1288 09            ret
0428+  1289             
0429+  1289             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0430+  1289             ; PRINT 16BIT HEX INTEGER
0431+  1289             ; integer value in reg B
0432+  1289             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  1289             print_u16x:
0434+  1289 D7            push a
0435+  128A D8            push b
0436+  128B DD            push bl
0437+  128C 30            mov bl, bh
0438+  128D 07 B5 10      call _itoa        ; convert bh to char in A
0439+  1290 2F            mov bl, al        ; save al
0440+  1291 19 00         mov al, 0
0441+  1293 05 03         syscall sys_io        ; display AH
0442+  1295 24            mov ah, bl        ; retrieve al
0443+  1296 19 00         mov al, 0
0444+  1298 05 03         syscall sys_io        ; display AL
0445+  129A             
0446+  129A EA            pop bl
0447+  129B 07 B5 10      call _itoa        ; convert bh to char in A
0448+  129E 2F            mov bl, al        ; save al
0449+  129F 19 00         mov al, 0
0450+  12A1 05 03         syscall sys_io        ; display AH
0451+  12A3 24            mov ah, bl        ; retrieve al
0452+  12A4 19 00         mov al, 0
0453+  12A6 05 03         syscall sys_io        ; display AL
0454+  12A8             
0455+  12A8 E5            pop b
0456+  12A9 E4            pop a
0457+  12AA 09            ret
0458+  12AB             
0459+  12AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0460+  12AB             ; INPUT 16BIT HEX INTEGER
0461+  12AB             ; read 16bit integer into A
0462+  12AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0463+  12AB             scan_u16x:
0464+  12AB F8 10 00      enter 16
0465+  12AE D8            push b
0466+  12AF DA            push d
0467+  12B0             
0468+  12B0 FA F1 FF      lea d, [bp + -15]
0469+  12B3 07 EE 10      call _gets        ; get number
0470+  12B6             
0471+  12B6 32            mov bl, [d]
0472+  12B7 37            mov bh, bl
0473+  12B8 33 01 00      mov bl, [d + 1]
0474+  12BB 07 A4 10      call _atoi        ; convert to int in AL
0475+  12BE 23            mov ah, al        ; move to AH
0476+  12BF             
0477+  12BF 33 02 00      mov bl, [d + 2]
0478+  12C2 37            mov bh, bl
0479+  12C3 33 03 00      mov bl, [d + 3]
0480+  12C6 07 A4 10      call _atoi        ; convert to int in AL
0481+  12C9             
0482+  12C9 E7            pop d
0483+  12CA E5            pop b
0484+  12CB F9            leave
0485+  12CC 09            ret
0486+  12CD             
0487+  12CD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0488+  12CD             ; PRINT 8bit HEX INTEGER
0489+  12CD             ; integer value in reg bl
0490+  12CD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0491+  12CD             print_u8x:
0492+  12CD D7            push a
0493+  12CE DD            push bl
0494+  12CF             
0495+  12CF 07 B5 10      call _itoa        ; convert bl to char in A
0496+  12D2 2F            mov bl, al        ; save al
0497+  12D3 19 00         mov al, 0
0498+  12D5 05 03         syscall sys_io        ; display AH
0499+  12D7 24            mov ah, bl        ; retrieve al
0500+  12D8 19 00         mov al, 0
0501+  12DA 05 03         syscall sys_io        ; display AL
0502+  12DC             
0503+  12DC EA            pop bl
0504+  12DD E4            pop a
0505+  12DE 09            ret
0506+  12DF             
0507+  12DF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0508+  12DF             ; print 8bit decimal unsigned number
0509+  12DF             ; input number in AL
0510+  12DF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0511+  12DF             print_u8d:
0512+  12DF D7            push a
0513+  12E0 D8            push b
0514+  12E1             
0515+  12E1 22 00         mov ah, 0
0516+  12E3 26 64 00      mov b, 100
0517+  12E6 AE            div a, b
0518+  12E7 D8            push b      ; save remainder
0519+  12E8 B9 00         cmp al, 0
0520+  12EA C6 F4 12      je skip100
0521+  12ED 6A 30         add al, $30
0522+  12EF 23            mov ah, al
0523+  12F0 19 00         mov al, 0
0524+  12F2 05 03         syscall sys_io  ; print coeff
0525+  12F4             skip100:
0526+  12F4 E4            pop a
0527+  12F5 22 00         mov ah, 0
0528+  12F7 26 0A 00      mov b, 10
0529+  12FA AE            div a, b
0530+  12FB D8            push b      ; save remainder
0531+  12FC B9 00         cmp al, 0
0532+  12FE C6 08 13      je skip10
0533+  1301 6A 30         add al, $30
0534+  1303 23            mov ah, al
0535+  1304 19 00         mov al, 0
0536+  1306 05 03         syscall sys_io  ; print coeff
0537+  1308             skip10:
0538+  1308 E4            pop a
0539+  1309 1B            mov al, bl
0540+  130A 6A 30         add al, $30
0541+  130C 23            mov ah, al
0542+  130D 19 00         mov al, 0
0543+  130F 05 03         syscall sys_io  ; print coeff
0544+  1311 E5            pop b
0545+  1312 E4            pop a
0546+  1313 09            ret
0547+  1314             
0548+  1314             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0549+  1314             ; INPUT 8BIT HEX INTEGER
0550+  1314             ; read 8bit integer into AL
0551+  1314             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0552+  1314             scan_u8x:
0553+  1314 F8 04 00      enter 4
0554+  1317 D8            push b
0555+  1318 DA            push d
0556+  1319             
0557+  1319 FA FD FF      lea d, [bp + -3]
0558+  131C 07 EE 10      call _gets        ; get number
0559+  131F             
0560+  131F 32            mov bl, [d]
0561+  1320 37            mov bh, bl
0562+  1321 33 01 00      mov bl, [d + 1]
0563+  1324 07 A4 10      call _atoi        ; convert to int in AL
0564+  1327             
0565+  1327 E7            pop d
0566+  1328 E5            pop b
0567+  1329 F9            leave
0568+  132A 09            ret
0569+  132B             
0570+  132B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  132B             ; input decimal number
0572+  132B             ; result in A
0573+  132B             ; 655'\0'
0574+  132B             ; low--------high
0575+  132B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0576+  132B             scan_u16d:
0577+  132B F8 08 00      enter 8
0578+  132E E2            push si
0579+  132F D8            push b
0580+  1330 D9            push c
0581+  1331 DA            push d
0582+  1332 FA F9 FF      lea d, [bp +- 7]
0583+  1335 07 EE 10      call _gets
0584+  1338 07 46 10      call _strlen      ; get string length in C
0585+  133B 7E            dec c
0586+  133C FD 4E         mov si, d
0587+  133E 12            mov a, c
0588+  133F FD 99         shl a
0589+  1341 3B 7D 13      mov d, table_power
0590+  1344 59            add d, a
0591+  1345 38 00 00      mov c, 0
0592+  1348             mul_loop:
0593+  1348 F6            lodsb      ; load ASCII to al
0594+  1349 B9 00         cmp al, 0
0595+  134B C6 5E 13      je mul_exit
0596+  134E 6F 30         sub al, $30    ; make into integer
0597+  1350 22 00         mov ah, 0
0598+  1352 2A            mov b, [d]
0599+  1353 AC            mul a, b      ; result in B since it fits in 16bits
0600+  1354 11            mov a, b
0601+  1355 28            mov b, c
0602+  1356 54            add a, b
0603+  1357 39            mov c, a
0604+  1358 63 02 00      sub d, 2
0605+  135B 0A 48 13      jmp mul_loop
0606+  135E             mul_exit:
0607+  135E 12            mov a, c
0608+  135F E7            pop d
0609+  1360 E6            pop c
0610+  1361 E5            pop b
0611+  1362 EF            pop si
0612+  1363 F9            leave
0613+  1364 09            ret
0614+  1365             
0615+  1365             
0616+  1365 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0616+  1369 34 35 36 37 
0616+  136D 38 39 41 42 
0616+  1371 43 44 45 46 
0617+  1375 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0617+  1379 1B 5B 48 00 
0618+  137D             
0619+  137D             table_power:
0620+  137D 01 00         .dw 1
0621+  137F 0A 00         .dw 10
0622+  1381 64 00         .dw 100
0623+  1383 E8 03         .dw 1000
0624+  1385 10 27         .dw 100002284   1387             ; --- END INLINE ASM BLOCK
2285   1387             
2286   1387 F9            leave
2287   1388 09            ret
2288   1389             
2289   1389             print_unsigned_long2:
2290   1389 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2291   138C             ; $p 
2292   138C 52 02 00      sub sp, 2
2293   138F             ;; p = &num; 
2294   138F FA FF FF      lea d, [bp + -1] ; $p
2295   1392 DA            push d
2296   1393 FA 05 00      lea d, [bp + 5] ; $num
2297   1396 2D            mov b, d
2298   1397 E7            pop d
2299   1398 FD 43         mov [d], b
2300   139A             ;; printx8(*p); 
2301   139A FA FF FF      lea d, [bp + -1] ; $p
2302   139D 2A            mov b, [d]
2303   139E 74            mov d, b
2304   139F 32            mov bl, [d]
2305   13A0 A7 00         mov bh, 0
2306   13A2 DD            push bl
2307   13A3 07 5A 08      call printx8
2308   13A6 51 01 00      add sp, 1
2309   13A9             ;; printx8(*(p+1)); 
2310   13A9 FA FF FF      lea d, [bp + -1] ; $p
2311   13AC 2A            mov b, [d]
2312   13AD             ; START TERMS
2313   13AD D7            push a
2314   13AE 11            mov a, b
2315   13AF 26 01 00      mov b, $1
2316   13B2 54            add a, b
2317   13B3 27            mov b, a
2318   13B4 E4            pop a
2319   13B5             ; END TERMS
2320   13B5 74            mov d, b
2321   13B6 32            mov bl, [d]
2322   13B7 A7 00         mov bh, 0
2323   13B9 DD            push bl
2324   13BA 07 5A 08      call printx8
2325   13BD 51 01 00      add sp, 1
2326   13C0             ;; printx8(*(p-2)); 
2327   13C0 FA FF FF      lea d, [bp + -1] ; $p
2328   13C3 2A            mov b, [d]
2329   13C4             ; START TERMS
2330   13C4 D7            push a
2331   13C5 11            mov a, b
2332   13C6 26 02 00      mov b, $2
2333   13C9 60            sub a, b
2334   13CA 27            mov b, a
2335   13CB E4            pop a
2336   13CC             ; END TERMS
2337   13CC 74            mov d, b
2338   13CD 32            mov bl, [d]
2339   13CE A7 00         mov bh, 0
2340   13D0 DD            push bl
2341   13D1 07 5A 08      call printx8
2342   13D4 51 01 00      add sp, 1
2343   13D7             ;; printx8(*(p-3)); 
2344   13D7 FA FF FF      lea d, [bp + -1] ; $p
2345   13DA 2A            mov b, [d]
2346   13DB             ; START TERMS
2347   13DB D7            push a
2348   13DC 11            mov a, b
2349   13DD 26 03 00      mov b, $3
2350   13E0 60            sub a, b
2351   13E1 27            mov b, a
2352   13E2 E4            pop a
2353   13E3             ; END TERMS
2354   13E3 74            mov d, b
2355   13E4 32            mov bl, [d]
2356   13E5 A7 00         mov bh, 0
2357   13E7 DD            push bl
2358   13E8 07 5A 08      call printx8
2359   13EB 51 01 00      add sp, 1
2360   13EE F9            leave
2361   13EF 09            ret
2362   13F0             ; --- END TEXT BLOCK
2363   13F0             
2364   13F0             ; --- BEGIN DATA BLOCK
2365   13F0 55 6E 65 78 __s0: .db "Unexpected format in printf.", 0
2365   13F4 70 65 63 74 
2365   13F8 65 64 20 66 
2365   13FC 6F 72 6D 61 
2365   1400 74 20 69 6E 
2365   1404 20 70 72 69 
2365   1408 6E 74 66 2E 
2365   140C 00 
2366   140D 45 72 72 6F __s1: .db "Error: Unknown argument type.\n", 0
2366   1411 72 3A 20 55 
2366   1415 6E 6B 6E 6F 
2366   1419 77 6E 20 61 
2366   141D 72 67 75 6D 
2366   1421 65 6E 74 20 
2366   1425 74 79 70 65 
2366   1429 2E 0A 00 
2367   142C 1B 5B 32 4A __s2: .db "\033[2J\033[H", 0
2367   1430 1B 5B 48 00 
2368   1434 0A 00       __s3: .db "\n", 0
2369   1436             
2370   1436 38 14       _heap_top: .dw _heap
2371   1438 00          _heap: .db 0
2372   1439             ; --- END DATA BLOCK
2373   1439             
2374   1439             .end
tasm: Number of errors = 0
