0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT SEGMENT
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; ++p; 
0011   0408 3B 51 21      mov d, _p ; $p
0012   040B 2B 02 00      mov b, [d+2]
0013   040E FD 39         mov c, b
0014   0410 2A            mov b, [d]
0015   0411 FD 77         inc b
0016   0413 FD 43         mov [d], b
0017   0415 28            mov b, c
0018   0416 FD 44 02 00   mov [d+2], b
0019   041A 05 0B         syscall sys_terminate_proc
0020   041C             
0021   041C             strcpy:
0022   041C F8 00 00      enter 0 ; (push bp; mov bp, sp)
0023   041F             ; char *psrc; 
0024   041F 52 02 00      sub sp, 2
0025   0422             ; char *pdest; 
0026   0422 52 02 00      sub sp, 2
0027   0425             ; psrc = src; 
0028   0425 FA FF FF      lea d, [bp + -1] ; $psrc
0029   0428 DA            push d
0030   0429 FA 07 00      lea d, [bp + 7] ; $src
0031   042C 2A            mov b, [d]
0032   042D 38 00 00      mov c, 0
0033   0430 E7            pop d
0034   0431 FD 43         mov [d], b
0035   0433             ; pdest = dest; 
0036   0433 FA FD FF      lea d, [bp + -3] ; $pdest
0037   0436 DA            push d
0038   0437 FA 05 00      lea d, [bp + 5] ; $dest
0039   043A 2A            mov b, [d]
0040   043B 38 00 00      mov c, 0
0041   043E E7            pop d
0042   043F FD 43         mov [d], b
0043   0441             ; while(*psrc) *pdest++ = *psrc++; 
0044   0441             _while1_cond:
0045   0441 FA FF FF      lea d, [bp + -1] ; $psrc
0046   0444 2A            mov b, [d]
0047   0445 38 00 00      mov c, 0
0048   0448 74            mov d, b
0049   0449 32            mov bl, [d]
0050   044A A7 00         mov bh, 0
0051   044C 38 00 00      mov c, 0
0052   044F C0 00 00      cmp b, 0
0053   0452 C6 83 04      je _while1_exit
0054   0455             _while1_block:
0055   0455             ; *pdest++ = *psrc++; 
0056   0455 FA FD FF      lea d, [bp + -3] ; $pdest
0057   0458 2A            mov b, [d]
0058   0459 38 00 00      mov c, 0
0059   045C FD 77         inc b
0060   045E FA FD FF      lea d, [bp + -3] ; $pdest
0061   0461 FD 43         mov [d], b
0062   0463 FD 7D         dec b
0063   0465 D8            push b
0064   0466 FA FF FF      lea d, [bp + -1] ; $psrc
0065   0469 2A            mov b, [d]
0066   046A 38 00 00      mov c, 0
0067   046D FD 77         inc b
0068   046F FA FF FF      lea d, [bp + -1] ; $psrc
0069   0472 FD 43         mov [d], b
0070   0474 FD 7D         dec b
0071   0476 74            mov d, b
0072   0477 32            mov bl, [d]
0073   0478 A7 00         mov bh, 0
0074   047A 38 00 00      mov c, 0
0075   047D E7            pop d
0076   047E FD 3E         mov [d], bl
0077   0480 0A 41 04      jmp _while1_cond
0078   0483             _while1_exit:
0079   0483             ; *pdest = '\0'; 
0080   0483 FA FD FF      lea d, [bp + -3] ; $pdest
0081   0486 2A            mov b, [d]
0082   0487 38 00 00      mov c, 0
0083   048A D8            push b
0084   048B FD 2E 00 00   mov32 cb, $00000000
0084   048F 00 00 
0085   0491 E7            pop d
0086   0492 FD 3E         mov [d], bl
0087   0494 F9            leave
0088   0495 09            ret
0089   0496             
0090   0496             strcmp:
0091   0496 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0092   0499             ; while (*s1 && (*s1 == *s2)) { 
0093   0499             _while2_cond:
0094   0499 FA 05 00      lea d, [bp + 5] ; $s1
0095   049C 2A            mov b, [d]
0096   049D 38 00 00      mov c, 0
0097   04A0 74            mov d, b
0098   04A1 32            mov bl, [d]
0099   04A2 A7 00         mov bh, 0
0100   04A4 38 00 00      mov c, 0
0101   04A7             ; --- START LOGICAL AND
0102   04A7 D7            push a
0103   04A8 11            mov a, b
0104   04A9 FA 05 00      lea d, [bp + 5] ; $s1
0105   04AC 2A            mov b, [d]
0106   04AD 38 00 00      mov c, 0
0107   04B0 74            mov d, b
0108   04B1 32            mov bl, [d]
0109   04B2 A7 00         mov bh, 0
0110   04B4 38 00 00      mov c, 0
0111   04B7             ; --- START RELATIONAL
0112   04B7 D7            push a
0113   04B8 11            mov a, b
0114   04B9 FA 07 00      lea d, [bp + 7] ; $s2
0115   04BC 2A            mov b, [d]
0116   04BD 38 00 00      mov c, 0
0117   04C0 74            mov d, b
0118   04C1 32            mov bl, [d]
0119   04C2 A7 00         mov bh, 0
0120   04C4 38 00 00      mov c, 0
0121   04C7 B0            cmp a, b
0122   04C8 FD 71         seq ; ==
0123   04CA E4            pop a
0124   04CB             ; --- END RELATIONAL
0125   04CB FD A7         sand a, b
0126   04CD E4            pop a
0127   04CE             ; --- END LOGICAL AND
0128   04CE C0 00 00      cmp b, 0
0129   04D1 C6 F7 04      je _while2_exit
0130   04D4             _while2_block:
0131   04D4             ; s1++; 
0132   04D4 FA 05 00      lea d, [bp + 5] ; $s1
0133   04D7 2A            mov b, [d]
0134   04D8 38 00 00      mov c, 0
0135   04DB FD 77         inc b
0136   04DD FA 05 00      lea d, [bp + 5] ; $s1
0137   04E0 FD 43         mov [d], b
0138   04E2 FD 7D         dec b
0139   04E4             ; s2++; 
0140   04E4 FA 07 00      lea d, [bp + 7] ; $s2
0141   04E7 2A            mov b, [d]
0142   04E8 38 00 00      mov c, 0
0143   04EB FD 77         inc b
0144   04ED FA 07 00      lea d, [bp + 7] ; $s2
0145   04F0 FD 43         mov [d], b
0146   04F2 FD 7D         dec b
0147   04F4 0A 99 04      jmp _while2_cond
0148   04F7             _while2_exit:
0149   04F7             ; return *s1 - *s2; 
0150   04F7 FA 05 00      lea d, [bp + 5] ; $s1
0151   04FA 2A            mov b, [d]
0152   04FB 38 00 00      mov c, 0
0153   04FE 74            mov d, b
0154   04FF 32            mov bl, [d]
0155   0500 A7 00         mov bh, 0
0156   0502 38 00 00      mov c, 0
0157   0505             ; --- START TERMS
0158   0505 D7            push a
0159   0506 11            mov a, b
0160   0507 FA 07 00      lea d, [bp + 7] ; $s2
0161   050A 2A            mov b, [d]
0162   050B 38 00 00      mov c, 0
0163   050E 74            mov d, b
0164   050F 32            mov bl, [d]
0165   0510 A7 00         mov bh, 0
0166   0512 38 00 00      mov c, 0
0167   0515 60            sub a, b
0168   0516 27            mov b, a
0169   0517 E4            pop a
0170   0518             ; --- END TERMS
0171   0518 F9            leave
0172   0519 09            ret
0173   051A             
0174   051A             strncmp:
0175   051A F8 00 00      enter 0 ; (push bp; mov bp, sp)
0176   051D F9            leave
0177   051E 09            ret
0178   051F             
0179   051F             strcat:
0180   051F F8 00 00      enter 0 ; (push bp; mov bp, sp)
0181   0522             ; int dest_len; 
0182   0522 52 02 00      sub sp, 2
0183   0525             ; int i; 
0184   0525 52 02 00      sub sp, 2
0185   0528             ; dest_len = strlen(dest); 
0186   0528 FA FF FF      lea d, [bp + -1] ; $dest_len
0187   052B DA            push d
0188   052C             ; --- START FUNCTION CALL
0189   052C FA 05 00      lea d, [bp + 5] ; $dest
0190   052F 2A            mov b, [d]
0191   0530 38 00 00      mov c, 0
0192   0533 FD AB         swp b
0193   0535 D8            push b
0194   0536 07 02 06      call strlen
0195   0539 51 02 00      add sp, 2
0196   053C             ; --- END FUNCTION CALL
0197   053C E7            pop d
0198   053D FD 43         mov [d], b
0199   053F             ; for (i = 0; src[i] != 0; i=i+1) { 
0200   053F             _for3_init:
0201   053F FA FD FF      lea d, [bp + -3] ; $i
0202   0542 DA            push d
0203   0543 FD 2E 00 00   mov32 cb, $00000000
0203   0547 00 00 
0204   0549 E7            pop d
0205   054A FD 43         mov [d], b
0206   054C             _for3_cond:
0207   054C FA 07 00      lea d, [bp + 7] ; $src
0208   054F FD 2A         mov d, [d]
0209   0551 D7            push a
0210   0552 DA            push d
0211   0553 FA FD FF      lea d, [bp + -3] ; $i
0212   0556 2A            mov b, [d]
0213   0557 38 00 00      mov c, 0
0214   055A E7            pop d
0215   055B FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0216   055F E4            pop a
0217   0560 32            mov bl, [d]
0218   0561 A7 00         mov bh, 0
0219   0563 38 00 00      mov c, 0
0220   0566             ; --- START RELATIONAL
0221   0566 D7            push a
0222   0567 11            mov a, b
0223   0568 FD 2E 00 00   mov32 cb, $00000000
0223   056C 00 00 
0224   056E B0            cmp a, b
0225   056F FD 72         sneq ; !=
0226   0571 E4            pop a
0227   0572             ; --- END RELATIONAL
0228   0572 C0 00 00      cmp b, 0
0229   0575 C6 D0 05      je _for3_exit
0230   0578             _for3_block:
0231   0578             ; dest[dest_len + i] = src[i]; 
0232   0578 FA 05 00      lea d, [bp + 5] ; $dest
0233   057B FD 2A         mov d, [d]
0234   057D D7            push a
0235   057E DA            push d
0236   057F FA FF FF      lea d, [bp + -1] ; $dest_len
0237   0582 2A            mov b, [d]
0238   0583 38 00 00      mov c, 0
0239   0586             ; --- START TERMS
0240   0586 D7            push a
0241   0587 11            mov a, b
0242   0588 FA FD FF      lea d, [bp + -3] ; $i
0243   058B 2A            mov b, [d]
0244   058C 38 00 00      mov c, 0
0245   058F 56            add b, a
0246   0590 E4            pop a
0247   0591             ; --- END TERMS
0248   0591 E7            pop d
0249   0592 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0250   0596 E4            pop a
0251   0597 DA            push d
0252   0598 FA 07 00      lea d, [bp + 7] ; $src
0253   059B FD 2A         mov d, [d]
0254   059D D7            push a
0255   059E DA            push d
0256   059F FA FD FF      lea d, [bp + -3] ; $i
0257   05A2 2A            mov b, [d]
0258   05A3 38 00 00      mov c, 0
0259   05A6 E7            pop d
0260   05A7 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0261   05AB E4            pop a
0262   05AC 32            mov bl, [d]
0263   05AD A7 00         mov bh, 0
0264   05AF 38 00 00      mov c, 0
0265   05B2 E7            pop d
0266   05B3 FD 3E         mov [d], bl
0267   05B5             _for3_update:
0268   05B5 FA FD FF      lea d, [bp + -3] ; $i
0269   05B8 DA            push d
0270   05B9 FA FD FF      lea d, [bp + -3] ; $i
0271   05BC 2A            mov b, [d]
0272   05BD 38 00 00      mov c, 0
0273   05C0             ; --- START TERMS
0274   05C0 D7            push a
0275   05C1 11            mov a, b
0276   05C2 FD 2E 01 00   mov32 cb, $00000001
0276   05C6 00 00 
0277   05C8 56            add b, a
0278   05C9 E4            pop a
0279   05CA             ; --- END TERMS
0280   05CA E7            pop d
0281   05CB FD 43         mov [d], b
0282   05CD 0A 4C 05      jmp _for3_cond
0283   05D0             _for3_exit:
0284   05D0             ; dest[dest_len + i] = 0; 
0285   05D0 FA 05 00      lea d, [bp + 5] ; $dest
0286   05D3 FD 2A         mov d, [d]
0287   05D5 D7            push a
0288   05D6 DA            push d
0289   05D7 FA FF FF      lea d, [bp + -1] ; $dest_len
0290   05DA 2A            mov b, [d]
0291   05DB 38 00 00      mov c, 0
0292   05DE             ; --- START TERMS
0293   05DE D7            push a
0294   05DF 11            mov a, b
0295   05E0 FA FD FF      lea d, [bp + -3] ; $i
0296   05E3 2A            mov b, [d]
0297   05E4 38 00 00      mov c, 0
0298   05E7 56            add b, a
0299   05E8 E4            pop a
0300   05E9             ; --- END TERMS
0301   05E9 E7            pop d
0302   05EA FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0303   05EE E4            pop a
0304   05EF DA            push d
0305   05F0 FD 2E 00 00   mov32 cb, $00000000
0305   05F4 00 00 
0306   05F6 E7            pop d
0307   05F7 FD 3E         mov [d], bl
0308   05F9             ; return dest; 
0309   05F9 FA 05 00      lea d, [bp + 5] ; $dest
0310   05FC 2A            mov b, [d]
0311   05FD 38 00 00      mov c, 0
0312   0600 F9            leave
0313   0601 09            ret
0314   0602             
0315   0602             strlen:
0316   0602 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0317   0605             ; int length; 
0318   0605 52 02 00      sub sp, 2
0319   0608             ; length = 0; 
0320   0608 FA FF FF      lea d, [bp + -1] ; $length
0321   060B DA            push d
0322   060C FD 2E 00 00   mov32 cb, $00000000
0322   0610 00 00 
0323   0612 E7            pop d
0324   0613 FD 43         mov [d], b
0325   0615             ; while (str[length] != 0) { 
0326   0615             _while4_cond:
0327   0615 FA 05 00      lea d, [bp + 5] ; $str
0328   0618 FD 2A         mov d, [d]
0329   061A D7            push a
0330   061B DA            push d
0331   061C FA FF FF      lea d, [bp + -1] ; $length
0332   061F 2A            mov b, [d]
0333   0620 38 00 00      mov c, 0
0334   0623 E7            pop d
0335   0624 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0336   0628 E4            pop a
0337   0629 32            mov bl, [d]
0338   062A A7 00         mov bh, 0
0339   062C 38 00 00      mov c, 0
0340   062F             ; --- START RELATIONAL
0341   062F D7            push a
0342   0630 11            mov a, b
0343   0631 FD 2E 00 00   mov32 cb, $00000000
0343   0635 00 00 
0344   0637 B0            cmp a, b
0345   0638 FD 72         sneq ; !=
0346   063A E4            pop a
0347   063B             ; --- END RELATIONAL
0348   063B C0 00 00      cmp b, 0
0349   063E C6 54 06      je _while4_exit
0350   0641             _while4_block:
0351   0641             ; length++; 
0352   0641 FA FF FF      lea d, [bp + -1] ; $length
0353   0644 2A            mov b, [d]
0354   0645 38 00 00      mov c, 0
0355   0648 FD 77         inc b
0356   064A FA FF FF      lea d, [bp + -1] ; $length
0357   064D FD 43         mov [d], b
0358   064F FD 7D         dec b
0359   0651 0A 15 06      jmp _while4_cond
0360   0654             _while4_exit:
0361   0654             ; return length; 
0362   0654 FA FF FF      lea d, [bp + -1] ; $length
0363   0657 2A            mov b, [d]
0364   0658 38 00 00      mov c, 0
0365   065B F9            leave
0366   065C 09            ret
0367   065D             
0368   065D             exit:
0369   065D F8 00 00      enter 0 ; (push bp; mov bp, sp)
0370   0660             
0371   0660             ; --- BEGIN INLINE ASM SEGMENT
0372   0660 05 0B         syscall sys_terminate_proc
0373   0662             ; --- END INLINE ASM SEGMENT
0374   0662             
0375   0662 F9            leave
0376   0663 09            ret
0377   0664             
0378   0664             memset:
0379   0664 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0380   0667             ; int i; 
0381   0667 52 02 00      sub sp, 2
0382   066A             ; for(i = 0; i < size; i++){ 
0383   066A             _for5_init:
0384   066A FA FF FF      lea d, [bp + -1] ; $i
0385   066D DA            push d
0386   066E FD 2E 00 00   mov32 cb, $00000000
0386   0672 00 00 
0387   0674 E7            pop d
0388   0675 FD 43         mov [d], b
0389   0677             _for5_cond:
0390   0677 FA FF FF      lea d, [bp + -1] ; $i
0391   067A 2A            mov b, [d]
0392   067B 38 00 00      mov c, 0
0393   067E             ; --- START RELATIONAL
0394   067E D7            push a
0395   067F 11            mov a, b
0396   0680 FA 08 00      lea d, [bp + 8] ; $size
0397   0683 2A            mov b, [d]
0398   0684 38 00 00      mov c, 0
0399   0687 B0            cmp a, b
0400   0688 FD 73         slt ; < (signed)
0401   068A E4            pop a
0402   068B             ; --- END RELATIONAL
0403   068B C0 00 00      cmp b, 0
0404   068E C6 C3 06      je _for5_exit
0405   0691             _for5_block:
0406   0691             ; *(s+i) = c; 
0407   0691 FA 05 00      lea d, [bp + 5] ; $s
0408   0694 2A            mov b, [d]
0409   0695 38 00 00      mov c, 0
0410   0698             ; --- START TERMS
0411   0698 D7            push a
0412   0699 11            mov a, b
0413   069A FA FF FF      lea d, [bp + -1] ; $i
0414   069D 2A            mov b, [d]
0415   069E 38 00 00      mov c, 0
0416   06A1 56            add b, a
0417   06A2 E4            pop a
0418   06A3             ; --- END TERMS
0419   06A3 D8            push b
0420   06A4 FA 07 00      lea d, [bp + 7] ; $c
0421   06A7 32            mov bl, [d]
0422   06A8 A7 00         mov bh, 0
0423   06AA 38 00 00      mov c, 0
0424   06AD E7            pop d
0425   06AE FD 3E         mov [d], bl
0426   06B0             _for5_update:
0427   06B0 FA FF FF      lea d, [bp + -1] ; $i
0428   06B3 2A            mov b, [d]
0429   06B4 38 00 00      mov c, 0
0430   06B7 FD 77         inc b
0431   06B9 FA FF FF      lea d, [bp + -1] ; $i
0432   06BC FD 43         mov [d], b
0433   06BE FD 7D         dec b
0434   06C0 0A 77 06      jmp _for5_cond
0435   06C3             _for5_exit:
0436   06C3             ; return s; 
0437   06C3 FA 05 00      lea d, [bp + 5] ; $s
0438   06C6 2A            mov b, [d]
0439   06C7 38 00 00      mov c, 0
0440   06CA F9            leave
0441   06CB 09            ret
0442   06CC             
0443   06CC             atoi:
0444   06CC F8 00 00      enter 0 ; (push bp; mov bp, sp)
0445   06CF             ; int result = 0;  // Initialize result 
0446   06CF 52 02 00      sub sp, 2
0447   06D2             ; --- START LOCAL VAR INITIALIZATION
0448   06D2 FA FF FF      lea d, [bp + -1] ; $result
0449   06D5 DA            push d
0450   06D6 FD 2E 00 00   mov32 cb, $00000000
0450   06DA 00 00 
0451   06DC E7            pop d
0452   06DD FD 43         mov [d], b
0453   06DF             ; --- END LOCAL VAR INITIALIZATION
0454   06DF             ; int sign = 1;    // Initialize sign as positive 
0455   06DF 52 02 00      sub sp, 2
0456   06E2             ; --- START LOCAL VAR INITIALIZATION
0457   06E2 FA FD FF      lea d, [bp + -3] ; $sign
0458   06E5 DA            push d
0459   06E6 FD 2E 01 00   mov32 cb, $00000001
0459   06EA 00 00 
0460   06EC E7            pop d
0461   06ED FD 43         mov [d], b
0462   06EF             ; --- END LOCAL VAR INITIALIZATION
0463   06EF             ; while (*str == ' ') str++; 
0464   06EF             _while6_cond:
0465   06EF FA 05 00      lea d, [bp + 5] ; $str
0466   06F2 2A            mov b, [d]
0467   06F3 38 00 00      mov c, 0
0468   06F6 74            mov d, b
0469   06F7 32            mov bl, [d]
0470   06F8 A7 00         mov bh, 0
0471   06FA 38 00 00      mov c, 0
0472   06FD             ; --- START RELATIONAL
0473   06FD D7            push a
0474   06FE 11            mov a, b
0475   06FF FD 2E 20 00   mov32 cb, $00000020
0475   0703 00 00 
0476   0705 B0            cmp a, b
0477   0706 FD 71         seq ; ==
0478   0708 E4            pop a
0479   0709             ; --- END RELATIONAL
0480   0709 C0 00 00      cmp b, 0
0481   070C C6 22 07      je _while6_exit
0482   070F             _while6_block:
0483   070F             ; str++; 
0484   070F FA 05 00      lea d, [bp + 5] ; $str
0485   0712 2A            mov b, [d]
0486   0713 38 00 00      mov c, 0
0487   0716 FD 77         inc b
0488   0718 FA 05 00      lea d, [bp + 5] ; $str
0489   071B FD 43         mov [d], b
0490   071D FD 7D         dec b
0491   071F 0A EF 06      jmp _while6_cond
0492   0722             _while6_exit:
0493   0722             ; if (*str == '-' || *str == '+') { 
0494   0722             _if7_cond:
0495   0722 FA 05 00      lea d, [bp + 5] ; $str
0496   0725 2A            mov b, [d]
0497   0726 38 00 00      mov c, 0
0498   0729 74            mov d, b
0499   072A 32            mov bl, [d]
0500   072B A7 00         mov bh, 0
0501   072D 38 00 00      mov c, 0
0502   0730             ; --- START RELATIONAL
0503   0730 D7            push a
0504   0731 11            mov a, b
0505   0732 FD 2E 2D 00   mov32 cb, $0000002d
0505   0736 00 00 
0506   0738 B0            cmp a, b
0507   0739 FD 71         seq ; ==
0508   073B E4            pop a
0509   073C             ; --- END RELATIONAL
0510   073C             ; --- START LOGICAL OR
0511   073C D7            push a
0512   073D 11            mov a, b
0513   073E FA 05 00      lea d, [bp + 5] ; $str
0514   0741 2A            mov b, [d]
0515   0742 38 00 00      mov c, 0
0516   0745 74            mov d, b
0517   0746 32            mov bl, [d]
0518   0747 A7 00         mov bh, 0
0519   0749 38 00 00      mov c, 0
0520   074C             ; --- START RELATIONAL
0521   074C D7            push a
0522   074D 11            mov a, b
0523   074E FD 2E 2B 00   mov32 cb, $0000002b
0523   0752 00 00 
0524   0754 B0            cmp a, b
0525   0755 FD 71         seq ; ==
0526   0757 E4            pop a
0527   0758             ; --- END RELATIONAL
0528   0758 FD A8         sor a, b ; ||
0529   075A E4            pop a
0530   075B             ; --- END LOGICAL OR
0531   075B C0 00 00      cmp b, 0
0532   075E C6 A6 07      je _if7_exit
0533   0761             _if7_true:
0534   0761             ; if (*str == '-') sign = -1; 
0535   0761             _if8_cond:
0536   0761 FA 05 00      lea d, [bp + 5] ; $str
0537   0764 2A            mov b, [d]
0538   0765 38 00 00      mov c, 0
0539   0768 74            mov d, b
0540   0769 32            mov bl, [d]
0541   076A A7 00         mov bh, 0
0542   076C 38 00 00      mov c, 0
0543   076F             ; --- START RELATIONAL
0544   076F D7            push a
0545   0770 11            mov a, b
0546   0771 FD 2E 2D 00   mov32 cb, $0000002d
0546   0775 00 00 
0547   0777 B0            cmp a, b
0548   0778 FD 71         seq ; ==
0549   077A E4            pop a
0550   077B             ; --- END RELATIONAL
0551   077B C0 00 00      cmp b, 0
0552   077E C6 93 07      je _if8_exit
0553   0781             _if8_true:
0554   0781             ; sign = -1; 
0555   0781 FA FD FF      lea d, [bp + -3] ; $sign
0556   0784 DA            push d
0557   0785 FD 2E 01 00   mov32 cb, $00000001
0557   0789 00 00 
0558   078B FD 97         neg b
0559   078D E7            pop d
0560   078E FD 43         mov [d], b
0561   0790 0A 93 07      jmp _if8_exit
0562   0793             _if8_exit:
0563   0793             ; str++; 
0564   0793 FA 05 00      lea d, [bp + 5] ; $str
0565   0796 2A            mov b, [d]
0566   0797 38 00 00      mov c, 0
0567   079A FD 77         inc b
0568   079C FA 05 00      lea d, [bp + 5] ; $str
0569   079F FD 43         mov [d], b
0570   07A1 FD 7D         dec b
0571   07A3 0A A6 07      jmp _if7_exit
0572   07A6             _if7_exit:
0573   07A6             ; while (*str >= '0' && *str <= '9') { 
0574   07A6             _while9_cond:
0575   07A6 FA 05 00      lea d, [bp + 5] ; $str
0576   07A9 2A            mov b, [d]
0577   07AA 38 00 00      mov c, 0
0578   07AD 74            mov d, b
0579   07AE 32            mov bl, [d]
0580   07AF A7 00         mov bh, 0
0581   07B1 38 00 00      mov c, 0
0582   07B4             ; --- START RELATIONAL
0583   07B4 D7            push a
0584   07B5 11            mov a, b
0585   07B6 FD 2E 30 00   mov32 cb, $00000030
0585   07BA 00 00 
0586   07BC B0            cmp a, b
0587   07BD FD 82         sgeu ; >= (unsigned)
0588   07BF E4            pop a
0589   07C0             ; --- END RELATIONAL
0590   07C0             ; --- START LOGICAL AND
0591   07C0 D7            push a
0592   07C1 11            mov a, b
0593   07C2 FA 05 00      lea d, [bp + 5] ; $str
0594   07C5 2A            mov b, [d]
0595   07C6 38 00 00      mov c, 0
0596   07C9 74            mov d, b
0597   07CA 32            mov bl, [d]
0598   07CB A7 00         mov bh, 0
0599   07CD 38 00 00      mov c, 0
0600   07D0             ; --- START RELATIONAL
0601   07D0 D7            push a
0602   07D1 11            mov a, b
0603   07D2 FD 2E 39 00   mov32 cb, $00000039
0603   07D6 00 00 
0604   07D8 B0            cmp a, b
0605   07D9 FD 76         sleu ; <= (unsigned)
0606   07DB E4            pop a
0607   07DC             ; --- END RELATIONAL
0608   07DC FD A7         sand a, b
0609   07DE E4            pop a
0610   07DF             ; --- END LOGICAL AND
0611   07DF C0 00 00      cmp b, 0
0612   07E2 C6 2F 08      je _while9_exit
0613   07E5             _while9_block:
0614   07E5             ; result = result * 10 + (*str - '0'); 
0615   07E5 FA FF FF      lea d, [bp + -1] ; $result
0616   07E8 DA            push d
0617   07E9 FA FF FF      lea d, [bp + -1] ; $result
0618   07EC 2A            mov b, [d]
0619   07ED 38 00 00      mov c, 0
0620   07F0             ; --- START FACTORS
0621   07F0 D7            push a
0622   07F1 11            mov a, b
0623   07F2 FD 2E 0A 00   mov32 cb, $0000000a
0623   07F6 00 00 
0624   07F8 AC            mul a, b ; *
0625   07F9 11            mov a, b
0626   07FA 27            mov b, a
0627   07FB E4            pop a
0628   07FC             ; --- END FACTORS
0629   07FC             ; --- START TERMS
0630   07FC D7            push a
0631   07FD 11            mov a, b
0632   07FE FA 05 00      lea d, [bp + 5] ; $str
0633   0801 2A            mov b, [d]
0634   0802 38 00 00      mov c, 0
0635   0805 74            mov d, b
0636   0806 32            mov bl, [d]
0637   0807 A7 00         mov bh, 0
0638   0809 38 00 00      mov c, 0
0639   080C             ; --- START TERMS
0640   080C D7            push a
0641   080D 11            mov a, b
0642   080E FD 2E 30 00   mov32 cb, $00000030
0642   0812 00 00 
0643   0814 60            sub a, b
0644   0815 27            mov b, a
0645   0816 E4            pop a
0646   0817             ; --- END TERMS
0647   0817 56            add b, a
0648   0818 E4            pop a
0649   0819             ; --- END TERMS
0650   0819 E7            pop d
0651   081A FD 43         mov [d], b
0652   081C             ; str++; 
0653   081C FA 05 00      lea d, [bp + 5] ; $str
0654   081F 2A            mov b, [d]
0655   0820 38 00 00      mov c, 0
0656   0823 FD 77         inc b
0657   0825 FA 05 00      lea d, [bp + 5] ; $str
0658   0828 FD 43         mov [d], b
0659   082A FD 7D         dec b
0660   082C 0A A6 07      jmp _while9_cond
0661   082F             _while9_exit:
0662   082F             ; return sign * result; 
0663   082F FA FD FF      lea d, [bp + -3] ; $sign
0664   0832 2A            mov b, [d]
0665   0833 38 00 00      mov c, 0
0666   0836             ; --- START FACTORS
0667   0836 D7            push a
0668   0837 11            mov a, b
0669   0838 FA FF FF      lea d, [bp + -1] ; $result
0670   083B 2A            mov b, [d]
0671   083C 38 00 00      mov c, 0
0672   083F AC            mul a, b ; *
0673   0840 11            mov a, b
0674   0841 27            mov b, a
0675   0842 E4            pop a
0676   0843             ; --- END FACTORS
0677   0843 F9            leave
0678   0844 09            ret
0679   0845             
0680   0845             rand:
0681   0845 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0682   0848             ; int  sec; 
0683   0848 52 02 00      sub sp, 2
0684   084B             
0685   084B             ; --- BEGIN INLINE ASM SEGMENT
0686   084B 19 00         mov al, 0
0687   084D 05 01         syscall sys_rtc					
0688   084F 1A            mov al, ah
0689   0850 FA FF FF      lea d, [bp + -1] ; $sec
0690   0853 1E            mov al, [d]
0691   0854 22 00         mov ah, 0
0692   0856             ; --- END INLINE ASM SEGMENT
0693   0856             
0694   0856             ; return sec; 
0695   0856 FA FF FF      lea d, [bp + -1] ; $sec
0696   0859 2A            mov b, [d]
0697   085A 38 00 00      mov c, 0
0698   085D F9            leave
0699   085E 09            ret
0700   085F             
0701   085F             alloc:
0702   085F F8 00 00      enter 0 ; (push bp; mov bp, sp)
0703   0862             ; heap_top = heap_top + bytes; 
0704   0862 3B 9B 21      mov d, _heap_top ; $heap_top
0705   0865 DA            push d
0706   0866 3B 9B 21      mov d, _heap_top ; $heap_top
0707   0869 2A            mov b, [d]
0708   086A 38 00 00      mov c, 0
0709   086D             ; --- START TERMS
0710   086D D7            push a
0711   086E 11            mov a, b
0712   086F FA 05 00      lea d, [bp + 5] ; $bytes
0713   0872 2A            mov b, [d]
0714   0873 38 00 00      mov c, 0
0715   0876 56            add b, a
0716   0877 E4            pop a
0717   0878             ; --- END TERMS
0718   0878 E7            pop d
0719   0879 FD 43         mov [d], b
0720   087B             ; return heap_top - bytes; 
0721   087B 3B 9B 21      mov d, _heap_top ; $heap_top
0722   087E 2A            mov b, [d]
0723   087F 38 00 00      mov c, 0
0724   0882             ; --- START TERMS
0725   0882 D7            push a
0726   0883 11            mov a, b
0727   0884 FA 05 00      lea d, [bp + 5] ; $bytes
0728   0887 2A            mov b, [d]
0729   0888 38 00 00      mov c, 0
0730   088B 60            sub a, b
0731   088C 27            mov b, a
0732   088D E4            pop a
0733   088E             ; --- END TERMS
0734   088E F9            leave
0735   088F 09            ret
0736   0890             
0737   0890             free:
0738   0890 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0739   0893             ; return heap_top = heap_top - bytes; 
0740   0893 3B 9B 21      mov d, _heap_top ; $heap_top
0741   0896 DA            push d
0742   0897 3B 9B 21      mov d, _heap_top ; $heap_top
0743   089A 2A            mov b, [d]
0744   089B 38 00 00      mov c, 0
0745   089E             ; --- START TERMS
0746   089E D7            push a
0747   089F 11            mov a, b
0748   08A0 FA 05 00      lea d, [bp + 5] ; $bytes
0749   08A3 2A            mov b, [d]
0750   08A4 38 00 00      mov c, 0
0751   08A7 60            sub a, b
0752   08A8 27            mov b, a
0753   08A9 E4            pop a
0754   08AA             ; --- END TERMS
0755   08AA E7            pop d
0756   08AB FD 43         mov [d], b
0757   08AD F9            leave
0758   08AE 09            ret
0759   08AF             
0760   08AF             fopen:
0761   08AF F8 00 00      enter 0 ; (push bp; mov bp, sp)
0762   08B2             ; FILE *fp; 
0763   08B2 52 02 00      sub sp, 2
0764   08B5             ; static int max_handle = 0; 
0765   08B5 52 02 00      sub sp, 2
0766   08B8             ; fp = alloc(sizeof(FILE)); 
0767   08B8 FA FF FF      lea d, [bp + -1] ; $fp
0768   08BB DA            push d
0769   08BC             ; --- START FUNCTION CALL
0770   08BC 26 04 01      mov b, 260
0771   08BF FD AB         swp b
0772   08C1 D8            push b
0773   08C2 07 5F 08      call alloc
0774   08C5 51 02 00      add sp, 2
0775   08C8             ; --- END FUNCTION CALL
0776   08C8 E7            pop d
0777   08C9 FD 43         mov [d], b
0778   08CB             ; strcpy(fp->filename, filename); 
0779   08CB             ; --- START FUNCTION CALL
0780   08CB FA 05 00      lea d, [bp + 5] ; $filename
0781   08CE 2A            mov b, [d]
0782   08CF 38 00 00      mov c, 0
0783   08D2 FD AB         swp b
0784   08D4 D8            push b
0785   08D5 FA FF FF      lea d, [bp + -1] ; $fp
0786   08D8 FD 2A         mov d, [d]
0787   08DA 58 02 00      add d, 2
0788   08DD 2D            mov b, d
0789   08DE 38 00 00      mov c, 0
0790   08E1 FD AB         swp b
0791   08E3 D8            push b
0792   08E4 07 1C 04      call strcpy
0793   08E7 51 04 00      add sp, 4
0794   08EA             ; --- END FUNCTION CALL
0795   08EA             ; fp->handle = max_handle; 
0796   08EA FA FF FF      lea d, [bp + -1] ; $fp
0797   08ED FD 2A         mov d, [d]
0798   08EF 58 00 00      add d, 0
0799   08F2 DA            push d
0800   08F3 3B 55 21      mov d, st_fopen_max_handle ; static max_handle
0801   08F6 2A            mov b, [d]
0802   08F7 38 00 00      mov c, 0
0803   08FA E7            pop d
0804   08FB FD 43         mov [d], b
0805   08FD             ; fp->mode = mode; 
0806   08FD FA FF FF      lea d, [bp + -1] ; $fp
0807   0900 FD 2A         mov d, [d]
0808   0902 58 02 01      add d, 258
0809   0905 DA            push d
0810   0906 FA 07 00      lea d, [bp + 7] ; $mode
0811   0909 32            mov bl, [d]
0812   090A A7 00         mov bh, 0
0813   090C 38 00 00      mov c, 0
0814   090F E7            pop d
0815   0910 FD 3E         mov [d], bl
0816   0912             ; fp->loc = 0; 
0817   0912 FA FF FF      lea d, [bp + -1] ; $fp
0818   0915 FD 2A         mov d, [d]
0819   0917 58 03 01      add d, 259
0820   091A DA            push d
0821   091B FD 2E 00 00   mov32 cb, $00000000
0821   091F 00 00 
0822   0921 E7            pop d
0823   0922 FD 3E         mov [d], bl
0824   0924             ; max_handle++; 
0825   0924 3B 55 21      mov d, st_fopen_max_handle ; static max_handle
0826   0927 2A            mov b, [d]
0827   0928 38 00 00      mov c, 0
0828   092B FD 77         inc b
0829   092D 3B 55 21      mov d, st_fopen_max_handle ; static max_handle
0830   0930 FD 43         mov [d], b
0831   0932 FD 7D         dec b
0832   0934 F9            leave
0833   0935 09            ret
0834   0936             
0835   0936             fclose:
0836   0936 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0837   0939             ; free(sizeof(FILE)); 
0838   0939             ; --- START FUNCTION CALL
0839   0939 26 04 01      mov b, 260
0840   093C FD AB         swp b
0841   093E D8            push b
0842   093F 07 90 08      call free
0843   0942 51 02 00      add sp, 2
0844   0945             ; --- END FUNCTION CALL
0845   0945 F9            leave
0846   0946 09            ret
0847   0947             
0848   0947             printf:
0849   0947 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0850   094A             ; char *p, *format_p; 
0851   094A 52 02 00      sub sp, 2
0852   094D 52 02 00      sub sp, 2
0853   0950             ; format_p = format; 
0854   0950 FA FD FF      lea d, [bp + -3] ; $format_p
0855   0953 DA            push d
0856   0954 FA 05 00      lea d, [bp + 5] ; $format
0857   0957 2A            mov b, [d]
0858   0958 38 00 00      mov c, 0
0859   095B E7            pop d
0860   095C FD 43         mov [d], b
0861   095E             ; p = &format + 2; 
0862   095E FA FF FF      lea d, [bp + -1] ; $p
0863   0961 DA            push d
0864   0962 FA 05 00      lea d, [bp + 5] ; $format
0865   0965 2D            mov b, d
0866   0966             ; --- START TERMS
0867   0966 D7            push a
0868   0967 11            mov a, b
0869   0968 FD 2E 02 00   mov32 cb, $00000002
0869   096C 00 00 
0870   096E 56            add b, a
0871   096F E4            pop a
0872   0970             ; --- END TERMS
0873   0970 E7            pop d
0874   0971 FD 43         mov [d], b
0875   0973             ; for(;;){ 
0876   0973             _for10_init:
0877   0973             _for10_cond:
0878   0973             _for10_block:
0879   0973             ; if(!*format_p) break; 
0880   0973             _if11_cond:
0881   0973 FA FD FF      lea d, [bp + -3] ; $format_p
0882   0976 2A            mov b, [d]
0883   0977 38 00 00      mov c, 0
0884   097A 74            mov d, b
0885   097B 32            mov bl, [d]
0886   097C A7 00         mov bh, 0
0887   097E 38 00 00      mov c, 0
0888   0981 C0 00 00      cmp b, 0
0889   0984 FD 71         seq ; !
0890   0986 C0 00 00      cmp b, 0
0891   0989 C6 92 09      je _if11_else
0892   098C             _if11_true:
0893   098C             ; break; 
0894   098C 0A 23 0C      jmp _for10_exit ; for break
0895   098F 0A 20 0C      jmp _if11_exit
0896   0992             _if11_else:
0897   0992             ; if(*format_p == '%'){ 
0898   0992             _if12_cond:
0899   0992 FA FD FF      lea d, [bp + -3] ; $format_p
0900   0995 2A            mov b, [d]
0901   0996 38 00 00      mov c, 0
0902   0999 74            mov d, b
0903   099A 32            mov bl, [d]
0904   099B A7 00         mov bh, 0
0905   099D 38 00 00      mov c, 0
0906   09A0             ; --- START RELATIONAL
0907   09A0 D7            push a
0908   09A1 11            mov a, b
0909   09A2 FD 2E 25 00   mov32 cb, $00000025
0909   09A6 00 00 
0910   09A8 B0            cmp a, b
0911   09A9 FD 71         seq ; ==
0912   09AB E4            pop a
0913   09AC             ; --- END RELATIONAL
0914   09AC C0 00 00      cmp b, 0
0915   09AF C6 FB 0B      je _if12_else
0916   09B2             _if12_true:
0917   09B2             ; format_p++; 
0918   09B2 FA FD FF      lea d, [bp + -3] ; $format_p
0919   09B5 2A            mov b, [d]
0920   09B6 38 00 00      mov c, 0
0921   09B9 FD 77         inc b
0922   09BB FA FD FF      lea d, [bp + -3] ; $format_p
0923   09BE FD 43         mov [d], b
0924   09C0 FD 7D         dec b
0925   09C2             ; switch(*format_p){ 
0926   09C2             _switch13_expr:
0927   09C2 FA FD FF      lea d, [bp + -3] ; $format_p
0928   09C5 2A            mov b, [d]
0929   09C6 38 00 00      mov c, 0
0930   09C9 74            mov d, b
0931   09CA 32            mov bl, [d]
0932   09CB A7 00         mov bh, 0
0933   09CD 38 00 00      mov c, 0
0934   09D0             _switch13_comparisons:
0935   09D0 C1 6C         cmp bl, $6c
0936   09D2 C6 FE 09      je _switch13_case0
0937   09D5 C1 4C         cmp bl, $4c
0938   09D7 C6 FE 09      je _switch13_case1
0939   09DA C1 64         cmp bl, $64
0940   09DC C6 0E 0B      je _switch13_case2
0941   09DF C1 69         cmp bl, $69
0942   09E1 C6 0E 0B      je _switch13_case3
0943   09E4 C1 75         cmp bl, $75
0944   09E6 C6 3E 0B      je _switch13_case4
0945   09E9 C1 78         cmp bl, $78
0946   09EB C6 6E 0B      je _switch13_case5
0947   09EE C1 63         cmp bl, $63
0948   09F0 C6 92 0B      je _switch13_case6
0949   09F3 C1 73         cmp bl, $73
0950   09F5 C6 B7 0B      je _switch13_case7
0951   09F8 0A DC 0B      jmp _switch13_default
0952   09FB 0A E8 0B      jmp _switch13_exit
0953   09FE             _switch13_case0:
0954   09FE             _switch13_case1:
0955   09FE             ; format_p++; 
0956   09FE FA FD FF      lea d, [bp + -3] ; $format_p
0957   0A01 2A            mov b, [d]
0958   0A02 38 00 00      mov c, 0
0959   0A05 FD 77         inc b
0960   0A07 FA FD FF      lea d, [bp + -3] ; $format_p
0961   0A0A FD 43         mov [d], b
0962   0A0C FD 7D         dec b
0963   0A0E             ; if(*format_p == 'd' || *format_p == 'i') 
0964   0A0E             _if14_cond:
0965   0A0E FA FD FF      lea d, [bp + -3] ; $format_p
0966   0A11 2A            mov b, [d]
0967   0A12 38 00 00      mov c, 0
0968   0A15 74            mov d, b
0969   0A16 32            mov bl, [d]
0970   0A17 A7 00         mov bh, 0
0971   0A19 38 00 00      mov c, 0
0972   0A1C             ; --- START RELATIONAL
0973   0A1C D7            push a
0974   0A1D 11            mov a, b
0975   0A1E FD 2E 64 00   mov32 cb, $00000064
0975   0A22 00 00 
0976   0A24 B0            cmp a, b
0977   0A25 FD 71         seq ; ==
0978   0A27 E4            pop a
0979   0A28             ; --- END RELATIONAL
0980   0A28             ; --- START LOGICAL OR
0981   0A28 D7            push a
0982   0A29 11            mov a, b
0983   0A2A FA FD FF      lea d, [bp + -3] ; $format_p
0984   0A2D 2A            mov b, [d]
0985   0A2E 38 00 00      mov c, 0
0986   0A31 74            mov d, b
0987   0A32 32            mov bl, [d]
0988   0A33 A7 00         mov bh, 0
0989   0A35 38 00 00      mov c, 0
0990   0A38             ; --- START RELATIONAL
0991   0A38 D7            push a
0992   0A39 11            mov a, b
0993   0A3A FD 2E 69 00   mov32 cb, $00000069
0993   0A3E 00 00 
0994   0A40 B0            cmp a, b
0995   0A41 FD 71         seq ; ==
0996   0A43 E4            pop a
0997   0A44             ; --- END RELATIONAL
0998   0A44 FD A8         sor a, b ; ||
0999   0A46 E4            pop a
1000   0A47             ; --- END LOGICAL OR
1001   0A47 C0 00 00      cmp b, 0
1002   0A4A C6 6B 0A      je _if14_else
1003   0A4D             _if14_true:
1004   0A4D             ; print_signed_long(*(long *)p); 
1005   0A4D             ; --- START FUNCTION CALL
1006   0A4D FA FF FF      lea d, [bp + -1] ; $p
1007   0A50 2A            mov b, [d]
1008   0A51 38 00 00      mov c, 0
1009   0A54 74            mov d, b
1010   0A55 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1011   0A58 FD 39         mov c, b ; And place it into C
1012   0A5A 2A            mov b, [d] ; Lower Word in B
1013   0A5B 12            mov a, c
1014   0A5C FD AA         swp a
1015   0A5E D7            push a
1016   0A5F FD AB         swp b
1017   0A61 D8            push b
1018   0A62 07 F5 15      call print_signed_long
1019   0A65 51 04 00      add sp, 4
1020   0A68             ; --- END FUNCTION CALL
1021   0A68 0A F3 0A      jmp _if14_exit
1022   0A6B             _if14_else:
1023   0A6B             ; if(*format_p == 'u') 
1024   0A6B             _if15_cond:
1025   0A6B FA FD FF      lea d, [bp + -3] ; $format_p
1026   0A6E 2A            mov b, [d]
1027   0A6F 38 00 00      mov c, 0
1028   0A72 74            mov d, b
1029   0A73 32            mov bl, [d]
1030   0A74 A7 00         mov bh, 0
1031   0A76 38 00 00      mov c, 0
1032   0A79             ; --- START RELATIONAL
1033   0A79 D7            push a
1034   0A7A 11            mov a, b
1035   0A7B FD 2E 75 00   mov32 cb, $00000075
1035   0A7F 00 00 
1036   0A81 B0            cmp a, b
1037   0A82 FD 71         seq ; ==
1038   0A84 E4            pop a
1039   0A85             ; --- END RELATIONAL
1040   0A85 C0 00 00      cmp b, 0
1041   0A88 C6 A9 0A      je _if15_else
1042   0A8B             _if15_true:
1043   0A8B             ; print_unsigned_long(*(unsigned long *)p); 
1044   0A8B             ; --- START FUNCTION CALL
1045   0A8B FA FF FF      lea d, [bp + -1] ; $p
1046   0A8E 2A            mov b, [d]
1047   0A8F 38 00 00      mov c, 0
1048   0A92 74            mov d, b
1049   0A93 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1050   0A96 FD 39         mov c, b ; And place it into C
1051   0A98 2A            mov b, [d] ; Lower Word in B
1052   0A99 12            mov a, c
1053   0A9A FD AA         swp a
1054   0A9C D7            push a
1055   0A9D FD AB         swp b
1056   0A9F D8            push b
1057   0AA0 07 64 17      call print_unsigned_long
1058   0AA3 51 04 00      add sp, 4
1059   0AA6             ; --- END FUNCTION CALL
1060   0AA6 0A F3 0A      jmp _if15_exit
1061   0AA9             _if15_else:
1062   0AA9             ; if(*format_p == 'x') 
1063   0AA9             _if16_cond:
1064   0AA9 FA FD FF      lea d, [bp + -3] ; $format_p
1065   0AAC 2A            mov b, [d]
1066   0AAD 38 00 00      mov c, 0
1067   0AB0 74            mov d, b
1068   0AB1 32            mov bl, [d]
1069   0AB2 A7 00         mov bh, 0
1070   0AB4 38 00 00      mov c, 0
1071   0AB7             ; --- START RELATIONAL
1072   0AB7 D7            push a
1073   0AB8 11            mov a, b
1074   0AB9 FD 2E 78 00   mov32 cb, $00000078
1074   0ABD 00 00 
1075   0ABF B0            cmp a, b
1076   0AC0 FD 71         seq ; ==
1077   0AC2 E4            pop a
1078   0AC3             ; --- END RELATIONAL
1079   0AC3 C0 00 00      cmp b, 0
1080   0AC6 C6 E7 0A      je _if16_else
1081   0AC9             _if16_true:
1082   0AC9             ; printx32(*(long int *)p); 
1083   0AC9             ; --- START FUNCTION CALL
1084   0AC9 FA FF FF      lea d, [bp + -1] ; $p
1085   0ACC 2A            mov b, [d]
1086   0ACD 38 00 00      mov c, 0
1087   0AD0 74            mov d, b
1088   0AD1 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1089   0AD4 FD 39         mov c, b ; And place it into C
1090   0AD6 2A            mov b, [d] ; Lower Word in B
1091   0AD7 12            mov a, c
1092   0AD8 FD AA         swp a
1093   0ADA D7            push a
1094   0ADB FD AB         swp b
1095   0ADD D8            push b
1096   0ADE 07 C8 12      call printx32
1097   0AE1 51 04 00      add sp, 4
1098   0AE4             ; --- END FUNCTION CALL
1099   0AE4 0A F3 0A      jmp _if16_exit
1100   0AE7             _if16_else:
1101   0AE7             ; err("Unexpected format in printf."); 
1102   0AE7             ; --- START FUNCTION CALL
1103   0AE7 26 57 21      mov b, _s0 ; "Unexpected format in printf."
1104   0AEA FD AB         swp b
1105   0AEC D8            push b
1106   0AED 07 B3 12      call err
1107   0AF0 51 02 00      add sp, 2
1108   0AF3             ; --- END FUNCTION CALL
1109   0AF3             _if16_exit:
1110   0AF3             _if15_exit:
1111   0AF3             _if14_exit:
1112   0AF3             ; p = p + 4; 
1113   0AF3 FA FF FF      lea d, [bp + -1] ; $p
1114   0AF6 DA            push d
1115   0AF7 FA FF FF      lea d, [bp + -1] ; $p
1116   0AFA 2A            mov b, [d]
1117   0AFB 38 00 00      mov c, 0
1118   0AFE             ; --- START TERMS
1119   0AFE D7            push a
1120   0AFF 11            mov a, b
1121   0B00 FD 2E 04 00   mov32 cb, $00000004
1121   0B04 00 00 
1122   0B06 56            add b, a
1123   0B07 E4            pop a
1124   0B08             ; --- END TERMS
1125   0B08 E7            pop d
1126   0B09 FD 43         mov [d], b
1127   0B0B             ; break; 
1128   0B0B 0A E8 0B      jmp _switch13_exit ; case break
1129   0B0E             _switch13_case2:
1130   0B0E             _switch13_case3:
1131   0B0E             ; print_signed(*(int*)p); 
1132   0B0E             ; --- START FUNCTION CALL
1133   0B0E FA FF FF      lea d, [bp + -1] ; $p
1134   0B11 2A            mov b, [d]
1135   0B12 38 00 00      mov c, 0
1136   0B15 74            mov d, b
1137   0B16 2A            mov b, [d]
1138   0B17 38 00 00      mov c, 0
1139   0B1A FD AB         swp b
1140   0B1C D8            push b
1141   0B1D 07 BC 14      call print_signed
1142   0B20 51 02 00      add sp, 2
1143   0B23             ; --- END FUNCTION CALL
1144   0B23             ; p = p + 2; 
1145   0B23 FA FF FF      lea d, [bp + -1] ; $p
1146   0B26 DA            push d
1147   0B27 FA FF FF      lea d, [bp + -1] ; $p
1148   0B2A 2A            mov b, [d]
1149   0B2B 38 00 00      mov c, 0
1150   0B2E             ; --- START TERMS
1151   0B2E D7            push a
1152   0B2F 11            mov a, b
1153   0B30 FD 2E 02 00   mov32 cb, $00000002
1153   0B34 00 00 
1154   0B36 56            add b, a
1155   0B37 E4            pop a
1156   0B38             ; --- END TERMS
1157   0B38 E7            pop d
1158   0B39 FD 43         mov [d], b
1159   0B3B             ; break; 
1160   0B3B 0A E8 0B      jmp _switch13_exit ; case break
1161   0B3E             _switch13_case4:
1162   0B3E             ; print_unsigned(*(unsigned int*)p); 
1163   0B3E             ; --- START FUNCTION CALL
1164   0B3E FA FF FF      lea d, [bp + -1] ; $p
1165   0B41 2A            mov b, [d]
1166   0B42 38 00 00      mov c, 0
1167   0B45 74            mov d, b
1168   0B46 2A            mov b, [d]
1169   0B47 38 00 00      mov c, 0
1170   0B4A FD AB         swp b
1171   0B4C D8            push b
1172   0B4D 07 D8 19      call print_unsigned
1173   0B50 51 02 00      add sp, 2
1174   0B53             ; --- END FUNCTION CALL
1175   0B53             ; p = p + 2; 
1176   0B53 FA FF FF      lea d, [bp + -1] ; $p
1177   0B56 DA            push d
1178   0B57 FA FF FF      lea d, [bp + -1] ; $p
1179   0B5A 2A            mov b, [d]
1180   0B5B 38 00 00      mov c, 0
1181   0B5E             ; --- START TERMS
1182   0B5E D7            push a
1183   0B5F 11            mov a, b
1184   0B60 FD 2E 02 00   mov32 cb, $00000002
1184   0B64 00 00 
1185   0B66 56            add b, a
1186   0B67 E4            pop a
1187   0B68             ; --- END TERMS
1188   0B68 E7            pop d
1189   0B69 FD 43         mov [d], b
1190   0B6B             ; break; 
1191   0B6B 0A E8 0B      jmp _switch13_exit ; case break
1192   0B6E             _switch13_case5:
1193   0B6E             
1194   0B6E             ; --- BEGIN INLINE ASM SEGMENT
1195   0B6E FA FF FF      lea d, [bp + -1] ; $p
1196   0B71 FD 2A         mov d, [d]
1197   0B73 2A            mov b, [d]
1198   0B74 07 51 20      call print_u16x
1199   0B77             ; --- END INLINE ASM SEGMENT
1200   0B77             
1201   0B77             ; p = p + 2; 
1202   0B77 FA FF FF      lea d, [bp + -1] ; $p
1203   0B7A DA            push d
1204   0B7B FA FF FF      lea d, [bp + -1] ; $p
1205   0B7E 2A            mov b, [d]
1206   0B7F 38 00 00      mov c, 0
1207   0B82             ; --- START TERMS
1208   0B82 D7            push a
1209   0B83 11            mov a, b
1210   0B84 FD 2E 02 00   mov32 cb, $00000002
1210   0B88 00 00 
1211   0B8A 56            add b, a
1212   0B8B E4            pop a
1213   0B8C             ; --- END TERMS
1214   0B8C E7            pop d
1215   0B8D FD 43         mov [d], b
1216   0B8F             ; break; 
1217   0B8F 0A E8 0B      jmp _switch13_exit ; case break
1218   0B92             _switch13_case6:
1219   0B92             
1220   0B92             ; --- BEGIN INLINE ASM SEGMENT
1221   0B92 FA FF FF      lea d, [bp + -1] ; $p
1222   0B95 FD 2A         mov d, [d]
1223   0B97 1E            mov al, [d]
1224   0B98 23            mov ah, al
1225   0B99 07 AF 1E      call _putchar
1226   0B9C             ; --- END INLINE ASM SEGMENT
1227   0B9C             
1228   0B9C             ; p = p + 1; 
1229   0B9C FA FF FF      lea d, [bp + -1] ; $p
1230   0B9F DA            push d
1231   0BA0 FA FF FF      lea d, [bp + -1] ; $p
1232   0BA3 2A            mov b, [d]
1233   0BA4 38 00 00      mov c, 0
1234   0BA7             ; --- START TERMS
1235   0BA7 D7            push a
1236   0BA8 11            mov a, b
1237   0BA9 FD 2E 01 00   mov32 cb, $00000001
1237   0BAD 00 00 
1238   0BAF 56            add b, a
1239   0BB0 E4            pop a
1240   0BB1             ; --- END TERMS
1241   0BB1 E7            pop d
1242   0BB2 FD 43         mov [d], b
1243   0BB4             ; break; 
1244   0BB4 0A E8 0B      jmp _switch13_exit ; case break
1245   0BB7             _switch13_case7:
1246   0BB7             
1247   0BB7             ; --- BEGIN INLINE ASM SEGMENT
1248   0BB7 FA FF FF      lea d, [bp + -1] ; $p
1249   0BBA FD 2A         mov d, [d]
1250   0BBC FD 2A         mov d, [d]
1251   0BBE 07 F9 1F      call _puts
1252   0BC1             ; --- END INLINE ASM SEGMENT
1253   0BC1             
1254   0BC1             ; p = p + 2; 
1255   0BC1 FA FF FF      lea d, [bp + -1] ; $p
1256   0BC4 DA            push d
1257   0BC5 FA FF FF      lea d, [bp + -1] ; $p
1258   0BC8 2A            mov b, [d]
1259   0BC9 38 00 00      mov c, 0
1260   0BCC             ; --- START TERMS
1261   0BCC D7            push a
1262   0BCD 11            mov a, b
1263   0BCE FD 2E 02 00   mov32 cb, $00000002
1263   0BD2 00 00 
1264   0BD4 56            add b, a
1265   0BD5 E4            pop a
1266   0BD6             ; --- END TERMS
1267   0BD6 E7            pop d
1268   0BD7 FD 43         mov [d], b
1269   0BD9             ; break; 
1270   0BD9 0A E8 0B      jmp _switch13_exit ; case break
1271   0BDC             _switch13_default:
1272   0BDC             ; print("Error: Unknown argument type.\n"); 
1273   0BDC             ; --- START FUNCTION CALL
1274   0BDC 26 74 21      mov b, _s1 ; "Error: Unknown argument type.\n"
1275   0BDF FD AB         swp b
1276   0BE1 D8            push b
1277   0BE2 07 EE 1C      call print
1278   0BE5 51 02 00      add sp, 2
1279   0BE8             ; --- END FUNCTION CALL
1280   0BE8             _switch13_exit:
1281   0BE8             ; format_p++; 
1282   0BE8 FA FD FF      lea d, [bp + -3] ; $format_p
1283   0BEB 2A            mov b, [d]
1284   0BEC 38 00 00      mov c, 0
1285   0BEF FD 77         inc b
1286   0BF1 FA FD FF      lea d, [bp + -3] ; $format_p
1287   0BF4 FD 43         mov [d], b
1288   0BF6 FD 7D         dec b
1289   0BF8 0A 20 0C      jmp _if12_exit
1290   0BFB             _if12_else:
1291   0BFB             ; putchar(*format_p); 
1292   0BFB             ; --- START FUNCTION CALL
1293   0BFB FA FD FF      lea d, [bp + -3] ; $format_p
1294   0BFE 2A            mov b, [d]
1295   0BFF 38 00 00      mov c, 0
1296   0C02 74            mov d, b
1297   0C03 32            mov bl, [d]
1298   0C04 A7 00         mov bh, 0
1299   0C06 38 00 00      mov c, 0
1300   0C09 DD            push bl
1301   0C0A 07 A0 1C      call putchar
1302   0C0D 51 01 00      add sp, 1
1303   0C10             ; --- END FUNCTION CALL
1304   0C10             ; format_p++; 
1305   0C10 FA FD FF      lea d, [bp + -3] ; $format_p
1306   0C13 2A            mov b, [d]
1307   0C14 38 00 00      mov c, 0
1308   0C17 FD 77         inc b
1309   0C19 FA FD FF      lea d, [bp + -3] ; $format_p
1310   0C1C FD 43         mov [d], b
1311   0C1E FD 7D         dec b
1312   0C20             _if12_exit:
1313   0C20             _if11_exit:
1314   0C20             _for10_update:
1315   0C20 0A 73 09      jmp _for10_cond
1316   0C23             _for10_exit:
1317   0C23 F9            leave
1318   0C24 09            ret
1319   0C25             
1320   0C25             scanf:
1321   0C25 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1322   0C28             ; char *p, *format_p; 
1323   0C28 52 02 00      sub sp, 2
1324   0C2B 52 02 00      sub sp, 2
1325   0C2E             ; char c; 
1326   0C2E 52 01 00      sub sp, 1
1327   0C31             ; int i; 
1328   0C31 52 02 00      sub sp, 2
1329   0C34             ; char input_string[  512                    ]; 
1330   0C34 52 00 02      sub sp, 512
1331   0C37             ; format_p = format; 
1332   0C37 FA FD FF      lea d, [bp + -3] ; $format_p
1333   0C3A DA            push d
1334   0C3B FA 05 00      lea d, [bp + 5] ; $format
1335   0C3E 2A            mov b, [d]
1336   0C3F 38 00 00      mov c, 0
1337   0C42 E7            pop d
1338   0C43 FD 43         mov [d], b
1339   0C45             ; p = &format + 2; 
1340   0C45 FA FF FF      lea d, [bp + -1] ; $p
1341   0C48 DA            push d
1342   0C49 FA 05 00      lea d, [bp + 5] ; $format
1343   0C4C 2D            mov b, d
1344   0C4D             ; --- START TERMS
1345   0C4D D7            push a
1346   0C4E 11            mov a, b
1347   0C4F FD 2E 02 00   mov32 cb, $00000002
1347   0C53 00 00 
1348   0C55 56            add b, a
1349   0C56 E4            pop a
1350   0C57             ; --- END TERMS
1351   0C57 E7            pop d
1352   0C58 FD 43         mov [d], b
1353   0C5A             ; for(;;){ 
1354   0C5A             _for17_init:
1355   0C5A             _for17_cond:
1356   0C5A             _for17_block:
1357   0C5A             ; if(!*format_p) break; 
1358   0C5A             _if18_cond:
1359   0C5A FA FD FF      lea d, [bp + -3] ; $format_p
1360   0C5D 2A            mov b, [d]
1361   0C5E 38 00 00      mov c, 0
1362   0C61 74            mov d, b
1363   0C62 32            mov bl, [d]
1364   0C63 A7 00         mov bh, 0
1365   0C65 38 00 00      mov c, 0
1366   0C68 C0 00 00      cmp b, 0
1367   0C6B FD 71         seq ; !
1368   0C6D C0 00 00      cmp b, 0
1369   0C70 C6 79 0C      je _if18_else
1370   0C73             _if18_true:
1371   0C73             ; break; 
1372   0C73 0A 01 0F      jmp _for17_exit ; for break
1373   0C76 0A FE 0E      jmp _if18_exit
1374   0C79             _if18_else:
1375   0C79             ; if(*format_p == '%'){ 
1376   0C79             _if19_cond:
1377   0C79 FA FD FF      lea d, [bp + -3] ; $format_p
1378   0C7C 2A            mov b, [d]
1379   0C7D 38 00 00      mov c, 0
1380   0C80 74            mov d, b
1381   0C81 32            mov bl, [d]
1382   0C82 A7 00         mov bh, 0
1383   0C84 38 00 00      mov c, 0
1384   0C87             ; --- START RELATIONAL
1385   0C87 D7            push a
1386   0C88 11            mov a, b
1387   0C89 FD 2E 25 00   mov32 cb, $00000025
1387   0C8D 00 00 
1388   0C8F B0            cmp a, b
1389   0C90 FD 71         seq ; ==
1390   0C92 E4            pop a
1391   0C93             ; --- END RELATIONAL
1392   0C93 C0 00 00      cmp b, 0
1393   0C96 C6 D9 0E      je _if19_else
1394   0C99             _if19_true:
1395   0C99             ; format_p++; 
1396   0C99 FA FD FF      lea d, [bp + -3] ; $format_p
1397   0C9C 2A            mov b, [d]
1398   0C9D 38 00 00      mov c, 0
1399   0CA0 FD 77         inc b
1400   0CA2 FA FD FF      lea d, [bp + -3] ; $format_p
1401   0CA5 FD 43         mov [d], b
1402   0CA7 FD 7D         dec b
1403   0CA9             ; switch(*format_p){ 
1404   0CA9             _switch20_expr:
1405   0CA9 FA FD FF      lea d, [bp + -3] ; $format_p
1406   0CAC 2A            mov b, [d]
1407   0CAD 38 00 00      mov c, 0
1408   0CB0 74            mov d, b
1409   0CB1 32            mov bl, [d]
1410   0CB2 A7 00         mov bh, 0
1411   0CB4 38 00 00      mov c, 0
1412   0CB7             _switch20_comparisons:
1413   0CB7 C1 6C         cmp bl, $6c
1414   0CB9 C6 E5 0C      je _switch20_case0
1415   0CBC C1 4C         cmp bl, $4c
1416   0CBE C6 E5 0C      je _switch20_case1
1417   0CC1 C1 64         cmp bl, $64
1418   0CC3 C6 A4 0D      je _switch20_case2
1419   0CC6 C1 69         cmp bl, $69
1420   0CC8 C6 A4 0D      je _switch20_case3
1421   0CCB C1 75         cmp bl, $75
1422   0CCD C6 DD 0D      je _switch20_case4
1423   0CD0 C1 78         cmp bl, $78
1424   0CD2 C6 16 0E      je _switch20_case5
1425   0CD5 C1 63         cmp bl, $63
1426   0CD7 C6 31 0E      je _switch20_case6
1427   0CDA C1 73         cmp bl, $73
1428   0CDC C6 73 0E      je _switch20_case7
1429   0CDF 0A BA 0E      jmp _switch20_default
1430   0CE2 0A C6 0E      jmp _switch20_exit
1431   0CE5             _switch20_case0:
1432   0CE5             _switch20_case1:
1433   0CE5             ; format_p++; 
1434   0CE5 FA FD FF      lea d, [bp + -3] ; $format_p
1435   0CE8 2A            mov b, [d]
1436   0CE9 38 00 00      mov c, 0
1437   0CEC FD 77         inc b
1438   0CEE FA FD FF      lea d, [bp + -3] ; $format_p
1439   0CF1 FD 43         mov [d], b
1440   0CF3 FD 7D         dec b
1441   0CF5             ; if(*format_p == 'd' || *format_p == 'i'); 
1442   0CF5             _if21_cond:
1443   0CF5 FA FD FF      lea d, [bp + -3] ; $format_p
1444   0CF8 2A            mov b, [d]
1445   0CF9 38 00 00      mov c, 0
1446   0CFC 74            mov d, b
1447   0CFD 32            mov bl, [d]
1448   0CFE A7 00         mov bh, 0
1449   0D00 38 00 00      mov c, 0
1450   0D03             ; --- START RELATIONAL
1451   0D03 D7            push a
1452   0D04 11            mov a, b
1453   0D05 FD 2E 64 00   mov32 cb, $00000064
1453   0D09 00 00 
1454   0D0B B0            cmp a, b
1455   0D0C FD 71         seq ; ==
1456   0D0E E4            pop a
1457   0D0F             ; --- END RELATIONAL
1458   0D0F             ; --- START LOGICAL OR
1459   0D0F D7            push a
1460   0D10 11            mov a, b
1461   0D11 FA FD FF      lea d, [bp + -3] ; $format_p
1462   0D14 2A            mov b, [d]
1463   0D15 38 00 00      mov c, 0
1464   0D18 74            mov d, b
1465   0D19 32            mov bl, [d]
1466   0D1A A7 00         mov bh, 0
1467   0D1C 38 00 00      mov c, 0
1468   0D1F             ; --- START RELATIONAL
1469   0D1F D7            push a
1470   0D20 11            mov a, b
1471   0D21 FD 2E 69 00   mov32 cb, $00000069
1471   0D25 00 00 
1472   0D27 B0            cmp a, b
1473   0D28 FD 71         seq ; ==
1474   0D2A E4            pop a
1475   0D2B             ; --- END RELATIONAL
1476   0D2B FD A8         sor a, b ; ||
1477   0D2D E4            pop a
1478   0D2E             ; --- END LOGICAL OR
1479   0D2E C0 00 00      cmp b, 0
1480   0D31 C6 37 0D      je _if21_else
1481   0D34             _if21_true:
1482   0D34             ; ; 
1483   0D34 0A 89 0D      jmp _if21_exit
1484   0D37             _if21_else:
1485   0D37             ; if(*format_p == 'u'); 
1486   0D37             _if22_cond:
1487   0D37 FA FD FF      lea d, [bp + -3] ; $format_p
1488   0D3A 2A            mov b, [d]
1489   0D3B 38 00 00      mov c, 0
1490   0D3E 74            mov d, b
1491   0D3F 32            mov bl, [d]
1492   0D40 A7 00         mov bh, 0
1493   0D42 38 00 00      mov c, 0
1494   0D45             ; --- START RELATIONAL
1495   0D45 D7            push a
1496   0D46 11            mov a, b
1497   0D47 FD 2E 75 00   mov32 cb, $00000075
1497   0D4B 00 00 
1498   0D4D B0            cmp a, b
1499   0D4E FD 71         seq ; ==
1500   0D50 E4            pop a
1501   0D51             ; --- END RELATIONAL
1502   0D51 C0 00 00      cmp b, 0
1503   0D54 C6 5A 0D      je _if22_else
1504   0D57             _if22_true:
1505   0D57             ; ; 
1506   0D57 0A 89 0D      jmp _if22_exit
1507   0D5A             _if22_else:
1508   0D5A             ; if(*format_p == 'x'); 
1509   0D5A             _if23_cond:
1510   0D5A FA FD FF      lea d, [bp + -3] ; $format_p
1511   0D5D 2A            mov b, [d]
1512   0D5E 38 00 00      mov c, 0
1513   0D61 74            mov d, b
1514   0D62 32            mov bl, [d]
1515   0D63 A7 00         mov bh, 0
1516   0D65 38 00 00      mov c, 0
1517   0D68             ; --- START RELATIONAL
1518   0D68 D7            push a
1519   0D69 11            mov a, b
1520   0D6A FD 2E 78 00   mov32 cb, $00000078
1520   0D6E 00 00 
1521   0D70 B0            cmp a, b
1522   0D71 FD 71         seq ; ==
1523   0D73 E4            pop a
1524   0D74             ; --- END RELATIONAL
1525   0D74 C0 00 00      cmp b, 0
1526   0D77 C6 7D 0D      je _if23_else
1527   0D7A             _if23_true:
1528   0D7A             ; ; 
1529   0D7A 0A 89 0D      jmp _if23_exit
1530   0D7D             _if23_else:
1531   0D7D             ; err("Unexpected format in printf."); 
1532   0D7D             ; --- START FUNCTION CALL
1533   0D7D 26 57 21      mov b, _s0 ; "Unexpected format in printf."
1534   0D80 FD AB         swp b
1535   0D82 D8            push b
1536   0D83 07 B3 12      call err
1537   0D86 51 02 00      add sp, 2
1538   0D89             ; --- END FUNCTION CALL
1539   0D89             _if23_exit:
1540   0D89             _if22_exit:
1541   0D89             _if21_exit:
1542   0D89             ; p = p + 4; 
1543   0D89 FA FF FF      lea d, [bp + -1] ; $p
1544   0D8C DA            push d
1545   0D8D FA FF FF      lea d, [bp + -1] ; $p
1546   0D90 2A            mov b, [d]
1547   0D91 38 00 00      mov c, 0
1548   0D94             ; --- START TERMS
1549   0D94 D7            push a
1550   0D95 11            mov a, b
1551   0D96 FD 2E 04 00   mov32 cb, $00000004
1551   0D9A 00 00 
1552   0D9C 56            add b, a
1553   0D9D E4            pop a
1554   0D9E             ; --- END TERMS
1555   0D9E E7            pop d
1556   0D9F FD 43         mov [d], b
1557   0DA1             ; break; 
1558   0DA1 0A C6 0E      jmp _switch20_exit ; case break
1559   0DA4             _switch20_case2:
1560   0DA4             _switch20_case3:
1561   0DA4             ; i = scann(); 
1562   0DA4 FA FA FF      lea d, [bp + -6] ; $i
1563   0DA7 DA            push d
1564   0DA8             ; --- START FUNCTION CALL
1565   0DA8 07 C6 1C      call scann
1566   0DAB E7            pop d
1567   0DAC FD 43         mov [d], b
1568   0DAE             ; **(int **)p = i; 
1569   0DAE FA FF FF      lea d, [bp + -1] ; $p
1570   0DB1 2A            mov b, [d]
1571   0DB2 38 00 00      mov c, 0
1572   0DB5 74            mov d, b
1573   0DB6 2A            mov b, [d]
1574   0DB7 D8            push b
1575   0DB8 FA FA FF      lea d, [bp + -6] ; $i
1576   0DBB 2A            mov b, [d]
1577   0DBC 38 00 00      mov c, 0
1578   0DBF E7            pop d
1579   0DC0 FD 43         mov [d], b
1580   0DC2             ; p = p + 2; 
1581   0DC2 FA FF FF      lea d, [bp + -1] ; $p
1582   0DC5 DA            push d
1583   0DC6 FA FF FF      lea d, [bp + -1] ; $p
1584   0DC9 2A            mov b, [d]
1585   0DCA 38 00 00      mov c, 0
1586   0DCD             ; --- START TERMS
1587   0DCD D7            push a
1588   0DCE 11            mov a, b
1589   0DCF FD 2E 02 00   mov32 cb, $00000002
1589   0DD3 00 00 
1590   0DD5 56            add b, a
1591   0DD6 E4            pop a
1592   0DD7             ; --- END TERMS
1593   0DD7 E7            pop d
1594   0DD8 FD 43         mov [d], b
1595   0DDA             ; break; 
1596   0DDA 0A C6 0E      jmp _switch20_exit ; case break
1597   0DDD             _switch20_case4:
1598   0DDD             ; i = scann(); 
1599   0DDD FA FA FF      lea d, [bp + -6] ; $i
1600   0DE0 DA            push d
1601   0DE1             ; --- START FUNCTION CALL
1602   0DE1 07 C6 1C      call scann
1603   0DE4 E7            pop d
1604   0DE5 FD 43         mov [d], b
1605   0DE7             ; **(int **)p = i; 
1606   0DE7 FA FF FF      lea d, [bp + -1] ; $p
1607   0DEA 2A            mov b, [d]
1608   0DEB 38 00 00      mov c, 0
1609   0DEE 74            mov d, b
1610   0DEF 2A            mov b, [d]
1611   0DF0 D8            push b
1612   0DF1 FA FA FF      lea d, [bp + -6] ; $i
1613   0DF4 2A            mov b, [d]
1614   0DF5 38 00 00      mov c, 0
1615   0DF8 E7            pop d
1616   0DF9 FD 43         mov [d], b
1617   0DFB             ; p = p + 2; 
1618   0DFB FA FF FF      lea d, [bp + -1] ; $p
1619   0DFE DA            push d
1620   0DFF FA FF FF      lea d, [bp + -1] ; $p
1621   0E02 2A            mov b, [d]
1622   0E03 38 00 00      mov c, 0
1623   0E06             ; --- START TERMS
1624   0E06 D7            push a
1625   0E07 11            mov a, b
1626   0E08 FD 2E 02 00   mov32 cb, $00000002
1626   0E0C 00 00 
1627   0E0E 56            add b, a
1628   0E0F E4            pop a
1629   0E10             ; --- END TERMS
1630   0E10 E7            pop d
1631   0E11 FD 43         mov [d], b
1632   0E13             ; break; 
1633   0E13 0A C6 0E      jmp _switch20_exit ; case break
1634   0E16             _switch20_case5:
1635   0E16             ; p = p + 2; 
1636   0E16 FA FF FF      lea d, [bp + -1] ; $p
1637   0E19 DA            push d
1638   0E1A FA FF FF      lea d, [bp + -1] ; $p
1639   0E1D 2A            mov b, [d]
1640   0E1E 38 00 00      mov c, 0
1641   0E21             ; --- START TERMS
1642   0E21 D7            push a
1643   0E22 11            mov a, b
1644   0E23 FD 2E 02 00   mov32 cb, $00000002
1644   0E27 00 00 
1645   0E29 56            add b, a
1646   0E2A E4            pop a
1647   0E2B             ; --- END TERMS
1648   0E2B E7            pop d
1649   0E2C FD 43         mov [d], b
1650   0E2E             ; break; 
1651   0E2E 0A C6 0E      jmp _switch20_exit ; case break
1652   0E31             _switch20_case6:
1653   0E31             ; c = getchar(); 
1654   0E31 FA FC FF      lea d, [bp + -4] ; $c
1655   0E34 DA            push d
1656   0E35             ; --- START FUNCTION CALL
1657   0E35 07 AD 1C      call getchar
1658   0E38 E7            pop d
1659   0E39 FD 3E         mov [d], bl
1660   0E3B             ; **(char **)p = *(char *)c; 
1661   0E3B FA FF FF      lea d, [bp + -1] ; $p
1662   0E3E 2A            mov b, [d]
1663   0E3F 38 00 00      mov c, 0
1664   0E42 74            mov d, b
1665   0E43 2A            mov b, [d]
1666   0E44 D8            push b
1667   0E45 FA FC FF      lea d, [bp + -4] ; $c
1668   0E48 32            mov bl, [d]
1669   0E49 A7 00         mov bh, 0
1670   0E4B 38 00 00      mov c, 0
1671   0E4E 74            mov d, b
1672   0E4F 32            mov bl, [d]
1673   0E50 A7 00         mov bh, 0
1674   0E52 38 00 00      mov c, 0
1675   0E55 E7            pop d
1676   0E56 FD 43         mov [d], b
1677   0E58             ; p = p + 1; 
1678   0E58 FA FF FF      lea d, [bp + -1] ; $p
1679   0E5B DA            push d
1680   0E5C FA FF FF      lea d, [bp + -1] ; $p
1681   0E5F 2A            mov b, [d]
1682   0E60 38 00 00      mov c, 0
1683   0E63             ; --- START TERMS
1684   0E63 D7            push a
1685   0E64 11            mov a, b
1686   0E65 FD 2E 01 00   mov32 cb, $00000001
1686   0E69 00 00 
1687   0E6B 56            add b, a
1688   0E6C E4            pop a
1689   0E6D             ; --- END TERMS
1690   0E6D E7            pop d
1691   0E6E FD 43         mov [d], b
1692   0E70             ; break; 
1693   0E70 0A C6 0E      jmp _switch20_exit ; case break
1694   0E73             _switch20_case7:
1695   0E73             ; gets(input_string); 
1696   0E73             ; --- START FUNCTION CALL
1697   0E73 FA FA FD      lea d, [bp + -518] ; $input_string
1698   0E76 2D            mov b, d
1699   0E77 38 00 00      mov c, 0
1700   0E7A FD AB         swp b
1701   0E7C D8            push b
1702   0E7D 07 9F 14      call gets
1703   0E80 51 02 00      add sp, 2
1704   0E83             ; --- END FUNCTION CALL
1705   0E83             ; strcpy(*(char **)p, input_string); 
1706   0E83             ; --- START FUNCTION CALL
1707   0E83 FA FA FD      lea d, [bp + -518] ; $input_string
1708   0E86 2D            mov b, d
1709   0E87 38 00 00      mov c, 0
1710   0E8A FD AB         swp b
1711   0E8C D8            push b
1712   0E8D FA FF FF      lea d, [bp + -1] ; $p
1713   0E90 2A            mov b, [d]
1714   0E91 38 00 00      mov c, 0
1715   0E94 74            mov d, b
1716   0E95 2A            mov b, [d]
1717   0E96 FD AB         swp b
1718   0E98 D8            push b
1719   0E99 07 1C 04      call strcpy
1720   0E9C 51 04 00      add sp, 4
1721   0E9F             ; --- END FUNCTION CALL
1722   0E9F             ; p = p + 2; 
1723   0E9F FA FF FF      lea d, [bp + -1] ; $p
1724   0EA2 DA            push d
1725   0EA3 FA FF FF      lea d, [bp + -1] ; $p
1726   0EA6 2A            mov b, [d]
1727   0EA7 38 00 00      mov c, 0
1728   0EAA             ; --- START TERMS
1729   0EAA D7            push a
1730   0EAB 11            mov a, b
1731   0EAC FD 2E 02 00   mov32 cb, $00000002
1731   0EB0 00 00 
1732   0EB2 56            add b, a
1733   0EB3 E4            pop a
1734   0EB4             ; --- END TERMS
1735   0EB4 E7            pop d
1736   0EB5 FD 43         mov [d], b
1737   0EB7             ; break; 
1738   0EB7 0A C6 0E      jmp _switch20_exit ; case break
1739   0EBA             _switch20_default:
1740   0EBA             ; print("Error: Unknown argument type.\n"); 
1741   0EBA             ; --- START FUNCTION CALL
1742   0EBA 26 74 21      mov b, _s1 ; "Error: Unknown argument type.\n"
1743   0EBD FD AB         swp b
1744   0EBF D8            push b
1745   0EC0 07 EE 1C      call print
1746   0EC3 51 02 00      add sp, 2
1747   0EC6             ; --- END FUNCTION CALL
1748   0EC6             _switch20_exit:
1749   0EC6             ; format_p++; 
1750   0EC6 FA FD FF      lea d, [bp + -3] ; $format_p
1751   0EC9 2A            mov b, [d]
1752   0ECA 38 00 00      mov c, 0
1753   0ECD FD 77         inc b
1754   0ECF FA FD FF      lea d, [bp + -3] ; $format_p
1755   0ED2 FD 43         mov [d], b
1756   0ED4 FD 7D         dec b
1757   0ED6 0A FE 0E      jmp _if19_exit
1758   0ED9             _if19_else:
1759   0ED9             ; putchar(*format_p); 
1760   0ED9             ; --- START FUNCTION CALL
1761   0ED9 FA FD FF      lea d, [bp + -3] ; $format_p
1762   0EDC 2A            mov b, [d]
1763   0EDD 38 00 00      mov c, 0
1764   0EE0 74            mov d, b
1765   0EE1 32            mov bl, [d]
1766   0EE2 A7 00         mov bh, 0
1767   0EE4 38 00 00      mov c, 0
1768   0EE7 DD            push bl
1769   0EE8 07 A0 1C      call putchar
1770   0EEB 51 01 00      add sp, 1
1771   0EEE             ; --- END FUNCTION CALL
1772   0EEE             ; format_p++; 
1773   0EEE FA FD FF      lea d, [bp + -3] ; $format_p
1774   0EF1 2A            mov b, [d]
1775   0EF2 38 00 00      mov c, 0
1776   0EF5 FD 77         inc b
1777   0EF7 FA FD FF      lea d, [bp + -3] ; $format_p
1778   0EFA FD 43         mov [d], b
1779   0EFC FD 7D         dec b
1780   0EFE             _if19_exit:
1781   0EFE             _if18_exit:
1782   0EFE             _for17_update:
1783   0EFE 0A 5A 0C      jmp _for17_cond
1784   0F01             _for17_exit:
1785   0F01 F9            leave
1786   0F02 09            ret
1787   0F03             
1788   0F03             sprintf:
1789   0F03 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1790   0F06             ; char *p, *format_p; 
1791   0F06 52 02 00      sub sp, 2
1792   0F09 52 02 00      sub sp, 2
1793   0F0C             ; char *sp; 
1794   0F0C 52 02 00      sub sp, 2
1795   0F0F             ; sp = dest; 
1796   0F0F FA FB FF      lea d, [bp + -5] ; $sp
1797   0F12 DA            push d
1798   0F13 FA 05 00      lea d, [bp + 5] ; $dest
1799   0F16 2A            mov b, [d]
1800   0F17 38 00 00      mov c, 0
1801   0F1A E7            pop d
1802   0F1B FD 43         mov [d], b
1803   0F1D             ; format_p = format; 
1804   0F1D FA FD FF      lea d, [bp + -3] ; $format_p
1805   0F20 DA            push d
1806   0F21 FA 07 00      lea d, [bp + 7] ; $format
1807   0F24 2A            mov b, [d]
1808   0F25 38 00 00      mov c, 0
1809   0F28 E7            pop d
1810   0F29 FD 43         mov [d], b
1811   0F2B             ; p = &format + 2; 
1812   0F2B FA FF FF      lea d, [bp + -1] ; $p
1813   0F2E DA            push d
1814   0F2F FA 07 00      lea d, [bp + 7] ; $format
1815   0F32 2D            mov b, d
1816   0F33             ; --- START TERMS
1817   0F33 D7            push a
1818   0F34 11            mov a, b
1819   0F35 FD 2E 02 00   mov32 cb, $00000002
1819   0F39 00 00 
1820   0F3B 56            add b, a
1821   0F3C E4            pop a
1822   0F3D             ; --- END TERMS
1823   0F3D E7            pop d
1824   0F3E FD 43         mov [d], b
1825   0F40             ; for(;;){ 
1826   0F40             _for24_init:
1827   0F40             _for24_cond:
1828   0F40             _for24_block:
1829   0F40             ; if(!*format_p) break; 
1830   0F40             _if25_cond:
1831   0F40 FA FD FF      lea d, [bp + -3] ; $format_p
1832   0F43 2A            mov b, [d]
1833   0F44 38 00 00      mov c, 0
1834   0F47 74            mov d, b
1835   0F48 32            mov bl, [d]
1836   0F49 A7 00         mov bh, 0
1837   0F4B 38 00 00      mov c, 0
1838   0F4E C0 00 00      cmp b, 0
1839   0F51 FD 71         seq ; !
1840   0F53 C0 00 00      cmp b, 0
1841   0F56 C6 5F 0F      je _if25_else
1842   0F59             _if25_true:
1843   0F59             ; break; 
1844   0F59 0A 8D 12      jmp _for24_exit ; for break
1845   0F5C 0A 8A 12      jmp _if25_exit
1846   0F5F             _if25_else:
1847   0F5F             ; if(*format_p == '%'){ 
1848   0F5F             _if26_cond:
1849   0F5F FA FD FF      lea d, [bp + -3] ; $format_p
1850   0F62 2A            mov b, [d]
1851   0F63 38 00 00      mov c, 0
1852   0F66 74            mov d, b
1853   0F67 32            mov bl, [d]
1854   0F68 A7 00         mov bh, 0
1855   0F6A 38 00 00      mov c, 0
1856   0F6D             ; --- START RELATIONAL
1857   0F6D D7            push a
1858   0F6E 11            mov a, b
1859   0F6F FD 2E 25 00   mov32 cb, $00000025
1859   0F73 00 00 
1860   0F75 B0            cmp a, b
1861   0F76 FD 71         seq ; ==
1862   0F78 E4            pop a
1863   0F79             ; --- END RELATIONAL
1864   0F79 C0 00 00      cmp b, 0
1865   0F7C C6 5F 12      je _if26_else
1866   0F7F             _if26_true:
1867   0F7F             ; format_p++; 
1868   0F7F FA FD FF      lea d, [bp + -3] ; $format_p
1869   0F82 2A            mov b, [d]
1870   0F83 38 00 00      mov c, 0
1871   0F86 FD 77         inc b
1872   0F88 FA FD FF      lea d, [bp + -3] ; $format_p
1873   0F8B FD 43         mov [d], b
1874   0F8D FD 7D         dec b
1875   0F8F             ; switch(*format_p){ 
1876   0F8F             _switch27_expr:
1877   0F8F FA FD FF      lea d, [bp + -3] ; $format_p
1878   0F92 2A            mov b, [d]
1879   0F93 38 00 00      mov c, 0
1880   0F96 74            mov d, b
1881   0F97 32            mov bl, [d]
1882   0F98 A7 00         mov bh, 0
1883   0F9A 38 00 00      mov c, 0
1884   0F9D             _switch27_comparisons:
1885   0F9D C1 6C         cmp bl, $6c
1886   0F9F C6 CB 0F      je _switch27_case0
1887   0FA2 C1 4C         cmp bl, $4c
1888   0FA4 C6 CB 0F      je _switch27_case1
1889   0FA7 C1 64         cmp bl, $64
1890   0FA9 C6 DB 10      je _switch27_case2
1891   0FAC C1 69         cmp bl, $69
1892   0FAE C6 DB 10      je _switch27_case3
1893   0FB1 C1 75         cmp bl, $75
1894   0FB3 C6 27 11      je _switch27_case4
1895   0FB6 C1 78         cmp bl, $78
1896   0FB8 C6 73 11      je _switch27_case5
1897   0FBB C1 63         cmp bl, $63
1898   0FBD C6 97 11      je _switch27_case6
1899   0FC0 C1 73         cmp bl, $73
1900   0FC2 C6 D4 11      je _switch27_case7
1901   0FC5 0A 40 12      jmp _switch27_default
1902   0FC8 0A 4C 12      jmp _switch27_exit
1903   0FCB             _switch27_case0:
1904   0FCB             _switch27_case1:
1905   0FCB             ; format_p++; 
1906   0FCB FA FD FF      lea d, [bp + -3] ; $format_p
1907   0FCE 2A            mov b, [d]
1908   0FCF 38 00 00      mov c, 0
1909   0FD2 FD 77         inc b
1910   0FD4 FA FD FF      lea d, [bp + -3] ; $format_p
1911   0FD7 FD 43         mov [d], b
1912   0FD9 FD 7D         dec b
1913   0FDB             ; if(*format_p == 'd' || *format_p == 'i') 
1914   0FDB             _if28_cond:
1915   0FDB FA FD FF      lea d, [bp + -3] ; $format_p
1916   0FDE 2A            mov b, [d]
1917   0FDF 38 00 00      mov c, 0
1918   0FE2 74            mov d, b
1919   0FE3 32            mov bl, [d]
1920   0FE4 A7 00         mov bh, 0
1921   0FE6 38 00 00      mov c, 0
1922   0FE9             ; --- START RELATIONAL
1923   0FE9 D7            push a
1924   0FEA 11            mov a, b
1925   0FEB FD 2E 64 00   mov32 cb, $00000064
1925   0FEF 00 00 
1926   0FF1 B0            cmp a, b
1927   0FF2 FD 71         seq ; ==
1928   0FF4 E4            pop a
1929   0FF5             ; --- END RELATIONAL
1930   0FF5             ; --- START LOGICAL OR
1931   0FF5 D7            push a
1932   0FF6 11            mov a, b
1933   0FF7 FA FD FF      lea d, [bp + -3] ; $format_p
1934   0FFA 2A            mov b, [d]
1935   0FFB 38 00 00      mov c, 0
1936   0FFE 74            mov d, b
1937   0FFF 32            mov bl, [d]
1938   1000 A7 00         mov bh, 0
1939   1002 38 00 00      mov c, 0
1940   1005             ; --- START RELATIONAL
1941   1005 D7            push a
1942   1006 11            mov a, b
1943   1007 FD 2E 69 00   mov32 cb, $00000069
1943   100B 00 00 
1944   100D B0            cmp a, b
1945   100E FD 71         seq ; ==
1946   1010 E4            pop a
1947   1011             ; --- END RELATIONAL
1948   1011 FD A8         sor a, b ; ||
1949   1013 E4            pop a
1950   1014             ; --- END LOGICAL OR
1951   1014 C0 00 00      cmp b, 0
1952   1017 C6 38 10      je _if28_else
1953   101A             _if28_true:
1954   101A             ; print_signed_long(*(long *)p); 
1955   101A             ; --- START FUNCTION CALL
1956   101A FA FF FF      lea d, [bp + -1] ; $p
1957   101D 2A            mov b, [d]
1958   101E 38 00 00      mov c, 0
1959   1021 74            mov d, b
1960   1022 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1961   1025 FD 39         mov c, b ; And place it into C
1962   1027 2A            mov b, [d] ; Lower Word in B
1963   1028 12            mov a, c
1964   1029 FD AA         swp a
1965   102B D7            push a
1966   102C FD AB         swp b
1967   102E D8            push b
1968   102F 07 F5 15      call print_signed_long
1969   1032 51 04 00      add sp, 4
1970   1035             ; --- END FUNCTION CALL
1971   1035 0A C0 10      jmp _if28_exit
1972   1038             _if28_else:
1973   1038             ; if(*format_p == 'u') 
1974   1038             _if29_cond:
1975   1038 FA FD FF      lea d, [bp + -3] ; $format_p
1976   103B 2A            mov b, [d]
1977   103C 38 00 00      mov c, 0
1978   103F 74            mov d, b
1979   1040 32            mov bl, [d]
1980   1041 A7 00         mov bh, 0
1981   1043 38 00 00      mov c, 0
1982   1046             ; --- START RELATIONAL
1983   1046 D7            push a
1984   1047 11            mov a, b
1985   1048 FD 2E 75 00   mov32 cb, $00000075
1985   104C 00 00 
1986   104E B0            cmp a, b
1987   104F FD 71         seq ; ==
1988   1051 E4            pop a
1989   1052             ; --- END RELATIONAL
1990   1052 C0 00 00      cmp b, 0
1991   1055 C6 76 10      je _if29_else
1992   1058             _if29_true:
1993   1058             ; print_unsigned_long(*(unsigned long *)p); 
1994   1058             ; --- START FUNCTION CALL
1995   1058 FA FF FF      lea d, [bp + -1] ; $p
1996   105B 2A            mov b, [d]
1997   105C 38 00 00      mov c, 0
1998   105F 74            mov d, b
1999   1060 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2000   1063 FD 39         mov c, b ; And place it into C
2001   1065 2A            mov b, [d] ; Lower Word in B
2002   1066 12            mov a, c
2003   1067 FD AA         swp a
2004   1069 D7            push a
2005   106A FD AB         swp b
2006   106C D8            push b
2007   106D 07 64 17      call print_unsigned_long
2008   1070 51 04 00      add sp, 4
2009   1073             ; --- END FUNCTION CALL
2010   1073 0A C0 10      jmp _if29_exit
2011   1076             _if29_else:
2012   1076             ; if(*format_p == 'x') 
2013   1076             _if30_cond:
2014   1076 FA FD FF      lea d, [bp + -3] ; $format_p
2015   1079 2A            mov b, [d]
2016   107A 38 00 00      mov c, 0
2017   107D 74            mov d, b
2018   107E 32            mov bl, [d]
2019   107F A7 00         mov bh, 0
2020   1081 38 00 00      mov c, 0
2021   1084             ; --- START RELATIONAL
2022   1084 D7            push a
2023   1085 11            mov a, b
2024   1086 FD 2E 78 00   mov32 cb, $00000078
2024   108A 00 00 
2025   108C B0            cmp a, b
2026   108D FD 71         seq ; ==
2027   108F E4            pop a
2028   1090             ; --- END RELATIONAL
2029   1090 C0 00 00      cmp b, 0
2030   1093 C6 B4 10      je _if30_else
2031   1096             _if30_true:
2032   1096             ; printx32(*(long int *)p); 
2033   1096             ; --- START FUNCTION CALL
2034   1096 FA FF FF      lea d, [bp + -1] ; $p
2035   1099 2A            mov b, [d]
2036   109A 38 00 00      mov c, 0
2037   109D 74            mov d, b
2038   109E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2039   10A1 FD 39         mov c, b ; And place it into C
2040   10A3 2A            mov b, [d] ; Lower Word in B
2041   10A4 12            mov a, c
2042   10A5 FD AA         swp a
2043   10A7 D7            push a
2044   10A8 FD AB         swp b
2045   10AA D8            push b
2046   10AB 07 C8 12      call printx32
2047   10AE 51 04 00      add sp, 4
2048   10B1             ; --- END FUNCTION CALL
2049   10B1 0A C0 10      jmp _if30_exit
2050   10B4             _if30_else:
2051   10B4             ; err("Unexpected format in printf."); 
2052   10B4             ; --- START FUNCTION CALL
2053   10B4 26 57 21      mov b, _s0 ; "Unexpected format in printf."
2054   10B7 FD AB         swp b
2055   10B9 D8            push b
2056   10BA 07 B3 12      call err
2057   10BD 51 02 00      add sp, 2
2058   10C0             ; --- END FUNCTION CALL
2059   10C0             _if30_exit:
2060   10C0             _if29_exit:
2061   10C0             _if28_exit:
2062   10C0             ; p = p + 4; 
2063   10C0 FA FF FF      lea d, [bp + -1] ; $p
2064   10C3 DA            push d
2065   10C4 FA FF FF      lea d, [bp + -1] ; $p
2066   10C7 2A            mov b, [d]
2067   10C8 38 00 00      mov c, 0
2068   10CB             ; --- START TERMS
2069   10CB D7            push a
2070   10CC 11            mov a, b
2071   10CD FD 2E 04 00   mov32 cb, $00000004
2071   10D1 00 00 
2072   10D3 56            add b, a
2073   10D4 E4            pop a
2074   10D5             ; --- END TERMS
2075   10D5 E7            pop d
2076   10D6 FD 43         mov [d], b
2077   10D8             ; break; 
2078   10D8 0A 4C 12      jmp _switch27_exit ; case break
2079   10DB             _switch27_case2:
2080   10DB             _switch27_case3:
2081   10DB             ; sp = sp + sprint_signed(sp, *(int*)p); 
2082   10DB FA FB FF      lea d, [bp + -5] ; $sp
2083   10DE DA            push d
2084   10DF FA FB FF      lea d, [bp + -5] ; $sp
2085   10E2 2A            mov b, [d]
2086   10E3 38 00 00      mov c, 0
2087   10E6             ; --- START TERMS
2088   10E6 D7            push a
2089   10E7 11            mov a, b
2090   10E8             ; --- START FUNCTION CALL
2091   10E8 FA FF FF      lea d, [bp + -1] ; $p
2092   10EB 2A            mov b, [d]
2093   10EC 38 00 00      mov c, 0
2094   10EF 74            mov d, b
2095   10F0 2A            mov b, [d]
2096   10F1 38 00 00      mov c, 0
2097   10F4 FD AB         swp b
2098   10F6 D8            push b
2099   10F7 FA FB FF      lea d, [bp + -5] ; $sp
2100   10FA 2A            mov b, [d]
2101   10FB 38 00 00      mov c, 0
2102   10FE FD AB         swp b
2103   1100 D8            push b
2104   1101 07 D8 1A      call sprint_signed
2105   1104 51 04 00      add sp, 4
2106   1107             ; --- END FUNCTION CALL
2107   1107 56            add b, a
2108   1108 E4            pop a
2109   1109             ; --- END TERMS
2110   1109 E7            pop d
2111   110A FD 43         mov [d], b
2112   110C             ; p = p + 2; 
2113   110C FA FF FF      lea d, [bp + -1] ; $p
2114   110F DA            push d
2115   1110 FA FF FF      lea d, [bp + -1] ; $p
2116   1113 2A            mov b, [d]
2117   1114 38 00 00      mov c, 0
2118   1117             ; --- START TERMS
2119   1117 D7            push a
2120   1118 11            mov a, b
2121   1119 FD 2E 02 00   mov32 cb, $00000002
2121   111D 00 00 
2122   111F 56            add b, a
2123   1120 E4            pop a
2124   1121             ; --- END TERMS
2125   1121 E7            pop d
2126   1122 FD 43         mov [d], b
2127   1124             ; break; 
2128   1124 0A 4C 12      jmp _switch27_exit ; case break
2129   1127             _switch27_case4:
2130   1127             ; sp = sp + sprint_unsigned(sp, *(unsigned int*)p); 
2131   1127 FA FB FF      lea d, [bp + -5] ; $sp
2132   112A DA            push d
2133   112B FA FB FF      lea d, [bp + -5] ; $sp
2134   112E 2A            mov b, [d]
2135   112F 38 00 00      mov c, 0
2136   1132             ; --- START TERMS
2137   1132 D7            push a
2138   1133 11            mov a, b
2139   1134             ; --- START FUNCTION CALL
2140   1134 FA FF FF      lea d, [bp + -1] ; $p
2141   1137 2A            mov b, [d]
2142   1138 38 00 00      mov c, 0
2143   113B 74            mov d, b
2144   113C 2A            mov b, [d]
2145   113D 38 00 00      mov c, 0
2146   1140 FD AB         swp b
2147   1142 D8            push b
2148   1143 FA FB FF      lea d, [bp + -5] ; $sp
2149   1146 2A            mov b, [d]
2150   1147 38 00 00      mov c, 0
2151   114A FD AB         swp b
2152   114C D8            push b
2153   114D 07 80 18      call sprint_unsigned
2154   1150 51 04 00      add sp, 4
2155   1153             ; --- END FUNCTION CALL
2156   1153 56            add b, a
2157   1154 E4            pop a
2158   1155             ; --- END TERMS
2159   1155 E7            pop d
2160   1156 FD 43         mov [d], b
2161   1158             ; p = p + 2; 
2162   1158 FA FF FF      lea d, [bp + -1] ; $p
2163   115B DA            push d
2164   115C FA FF FF      lea d, [bp + -1] ; $p
2165   115F 2A            mov b, [d]
2166   1160 38 00 00      mov c, 0
2167   1163             ; --- START TERMS
2168   1163 D7            push a
2169   1164 11            mov a, b
2170   1165 FD 2E 02 00   mov32 cb, $00000002
2170   1169 00 00 
2171   116B 56            add b, a
2172   116C E4            pop a
2173   116D             ; --- END TERMS
2174   116D E7            pop d
2175   116E FD 43         mov [d], b
2176   1170             ; break; 
2177   1170 0A 4C 12      jmp _switch27_exit ; case break
2178   1173             _switch27_case5:
2179   1173             
2180   1173             ; --- BEGIN INLINE ASM SEGMENT
2181   1173 FA FF FF      lea d, [bp + -1] ; $p
2182   1176 FD 2A         mov d, [d]
2183   1178 2A            mov b, [d]
2184   1179 07 51 20      call print_u16x
2185   117C             ; --- END INLINE ASM SEGMENT
2186   117C             
2187   117C             ; p = p + 2; 
2188   117C FA FF FF      lea d, [bp + -1] ; $p
2189   117F DA            push d
2190   1180 FA FF FF      lea d, [bp + -1] ; $p
2191   1183 2A            mov b, [d]
2192   1184 38 00 00      mov c, 0
2193   1187             ; --- START TERMS
2194   1187 D7            push a
2195   1188 11            mov a, b
2196   1189 FD 2E 02 00   mov32 cb, $00000002
2196   118D 00 00 
2197   118F 56            add b, a
2198   1190 E4            pop a
2199   1191             ; --- END TERMS
2200   1191 E7            pop d
2201   1192 FD 43         mov [d], b
2202   1194             ; break; 
2203   1194 0A 4C 12      jmp _switch27_exit ; case break
2204   1197             _switch27_case6:
2205   1197             ; *sp++ = *(char *)p; 
2206   1197 FA FB FF      lea d, [bp + -5] ; $sp
2207   119A 2A            mov b, [d]
2208   119B 38 00 00      mov c, 0
2209   119E FD 77         inc b
2210   11A0 FA FB FF      lea d, [bp + -5] ; $sp
2211   11A3 FD 43         mov [d], b
2212   11A5 FD 7D         dec b
2213   11A7 D8            push b
2214   11A8 FA FF FF      lea d, [bp + -1] ; $p
2215   11AB 2A            mov b, [d]
2216   11AC 38 00 00      mov c, 0
2217   11AF 74            mov d, b
2218   11B0 32            mov bl, [d]
2219   11B1 A7 00         mov bh, 0
2220   11B3 38 00 00      mov c, 0
2221   11B6 E7            pop d
2222   11B7 FD 3E         mov [d], bl
2223   11B9             ; p = p + 1; 
2224   11B9 FA FF FF      lea d, [bp + -1] ; $p
2225   11BC DA            push d
2226   11BD FA FF FF      lea d, [bp + -1] ; $p
2227   11C0 2A            mov b, [d]
2228   11C1 38 00 00      mov c, 0
2229   11C4             ; --- START TERMS
2230   11C4 D7            push a
2231   11C5 11            mov a, b
2232   11C6 FD 2E 01 00   mov32 cb, $00000001
2232   11CA 00 00 
2233   11CC 56            add b, a
2234   11CD E4            pop a
2235   11CE             ; --- END TERMS
2236   11CE E7            pop d
2237   11CF FD 43         mov [d], b
2238   11D1             ; break; 
2239   11D1 0A 4C 12      jmp _switch27_exit ; case break
2240   11D4             _switch27_case7:
2241   11D4             ; int len = strlen(*(char **)p); 
2242   11D4 52 02 00      sub sp, 2
2243   11D7             ; --- START LOCAL VAR INITIALIZATION
2244   11D7 FA F9 FF      lea d, [bp + -7] ; $len
2245   11DA DA            push d
2246   11DB             ; --- START FUNCTION CALL
2247   11DB FA FF FF      lea d, [bp + -1] ; $p
2248   11DE 2A            mov b, [d]
2249   11DF 38 00 00      mov c, 0
2250   11E2 74            mov d, b
2251   11E3 2A            mov b, [d]
2252   11E4 FD AB         swp b
2253   11E6 D8            push b
2254   11E7 07 02 06      call strlen
2255   11EA 51 02 00      add sp, 2
2256   11ED             ; --- END FUNCTION CALL
2257   11ED E7            pop d
2258   11EE FD 43         mov [d], b
2259   11F0             ; --- END LOCAL VAR INITIALIZATION
2260   11F0             ; strcpy(sp, *(char **)p); 
2261   11F0             ; --- START FUNCTION CALL
2262   11F0 FA FF FF      lea d, [bp + -1] ; $p
2263   11F3 2A            mov b, [d]
2264   11F4 38 00 00      mov c, 0
2265   11F7 74            mov d, b
2266   11F8 2A            mov b, [d]
2267   11F9 FD AB         swp b
2268   11FB D8            push b
2269   11FC FA FB FF      lea d, [bp + -5] ; $sp
2270   11FF 2A            mov b, [d]
2271   1200 38 00 00      mov c, 0
2272   1203 FD AB         swp b
2273   1205 D8            push b
2274   1206 07 1C 04      call strcpy
2275   1209 51 04 00      add sp, 4
2276   120C             ; --- END FUNCTION CALL
2277   120C             ; sp = sp + len; 
2278   120C FA FB FF      lea d, [bp + -5] ; $sp
2279   120F DA            push d
2280   1210 FA FB FF      lea d, [bp + -5] ; $sp
2281   1213 2A            mov b, [d]
2282   1214 38 00 00      mov c, 0
2283   1217             ; --- START TERMS
2284   1217 D7            push a
2285   1218 11            mov a, b
2286   1219 FA F9 FF      lea d, [bp + -7] ; $len
2287   121C 2A            mov b, [d]
2288   121D 38 00 00      mov c, 0
2289   1220 56            add b, a
2290   1221 E4            pop a
2291   1222             ; --- END TERMS
2292   1222 E7            pop d
2293   1223 FD 43         mov [d], b
2294   1225             ; p = p + 2; 
2295   1225 FA FF FF      lea d, [bp + -1] ; $p
2296   1228 DA            push d
2297   1229 FA FF FF      lea d, [bp + -1] ; $p
2298   122C 2A            mov b, [d]
2299   122D 38 00 00      mov c, 0
2300   1230             ; --- START TERMS
2301   1230 D7            push a
2302   1231 11            mov a, b
2303   1232 FD 2E 02 00   mov32 cb, $00000002
2303   1236 00 00 
2304   1238 56            add b, a
2305   1239 E4            pop a
2306   123A             ; --- END TERMS
2307   123A E7            pop d
2308   123B FD 43         mov [d], b
2309   123D             ; break; 
2310   123D 0A 4C 12      jmp _switch27_exit ; case break
2311   1240             _switch27_default:
2312   1240             ; print("Error: Unknown argument type.\n"); 
2313   1240             ; --- START FUNCTION CALL
2314   1240 26 74 21      mov b, _s1 ; "Error: Unknown argument type.\n"
2315   1243 FD AB         swp b
2316   1245 D8            push b
2317   1246 07 EE 1C      call print
2318   1249 51 02 00      add sp, 2
2319   124C             ; --- END FUNCTION CALL
2320   124C             _switch27_exit:
2321   124C             ; format_p++; 
2322   124C FA FD FF      lea d, [bp + -3] ; $format_p
2323   124F 2A            mov b, [d]
2324   1250 38 00 00      mov c, 0
2325   1253 FD 77         inc b
2326   1255 FA FD FF      lea d, [bp + -3] ; $format_p
2327   1258 FD 43         mov [d], b
2328   125A FD 7D         dec b
2329   125C 0A 8A 12      jmp _if26_exit
2330   125F             _if26_else:
2331   125F             ; *sp++ = *format_p++; 
2332   125F FA FB FF      lea d, [bp + -5] ; $sp
2333   1262 2A            mov b, [d]
2334   1263 38 00 00      mov c, 0
2335   1266 FD 77         inc b
2336   1268 FA FB FF      lea d, [bp + -5] ; $sp
2337   126B FD 43         mov [d], b
2338   126D FD 7D         dec b
2339   126F D8            push b
2340   1270 FA FD FF      lea d, [bp + -3] ; $format_p
2341   1273 2A            mov b, [d]
2342   1274 38 00 00      mov c, 0
2343   1277 FD 77         inc b
2344   1279 FA FD FF      lea d, [bp + -3] ; $format_p
2345   127C FD 43         mov [d], b
2346   127E FD 7D         dec b
2347   1280 74            mov d, b
2348   1281 32            mov bl, [d]
2349   1282 A7 00         mov bh, 0
2350   1284 38 00 00      mov c, 0
2351   1287 E7            pop d
2352   1288 FD 3E         mov [d], bl
2353   128A             _if26_exit:
2354   128A             _if25_exit:
2355   128A             _for24_update:
2356   128A 0A 40 0F      jmp _for24_cond
2357   128D             _for24_exit:
2358   128D             ; *sp = '\0'; 
2359   128D FA FB FF      lea d, [bp + -5] ; $sp
2360   1290 2A            mov b, [d]
2361   1291 38 00 00      mov c, 0
2362   1294 D8            push b
2363   1295 FD 2E 00 00   mov32 cb, $00000000
2363   1299 00 00 
2364   129B E7            pop d
2365   129C FD 3E         mov [d], bl
2366   129E             ; return sp - dest; // return total number of chars written 
2367   129E FA FB FF      lea d, [bp + -5] ; $sp
2368   12A1 2A            mov b, [d]
2369   12A2 38 00 00      mov c, 0
2370   12A5             ; --- START TERMS
2371   12A5 D7            push a
2372   12A6 11            mov a, b
2373   12A7 FA 05 00      lea d, [bp + 5] ; $dest
2374   12AA 2A            mov b, [d]
2375   12AB 38 00 00      mov c, 0
2376   12AE 60            sub a, b
2377   12AF 27            mov b, a
2378   12B0 E4            pop a
2379   12B1             ; --- END TERMS
2380   12B1 F9            leave
2381   12B2 09            ret
2382   12B3             
2383   12B3             err:
2384   12B3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2385   12B6             ; print(e); 
2386   12B6             ; --- START FUNCTION CALL
2387   12B6 FA 05 00      lea d, [bp + 5] ; $e
2388   12B9 2A            mov b, [d]
2389   12BA 38 00 00      mov c, 0
2390   12BD FD AB         swp b
2391   12BF D8            push b
2392   12C0 07 EE 1C      call print
2393   12C3 51 02 00      add sp, 2
2394   12C6             ; --- END FUNCTION CALL
2395   12C6 F9            leave
2396   12C7 09            ret
2397   12C8             
2398   12C8             printx32:
2399   12C8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2400   12CB             
2401   12CB             ; --- BEGIN INLINE ASM SEGMENT
2402   12CB FA 05 00      lea d, [bp + 5] ; $hex
2403   12CE 2B 02 00      mov b, [d+2]
2404   12D1 07 51 20      call print_u16x
2405   12D4 2A            mov b, [d]
2406   12D5 07 51 20      call print_u16x
2407   12D8             ; --- END INLINE ASM SEGMENT
2408   12D8             
2409   12D8 F9            leave
2410   12D9 09            ret
2411   12DA             
2412   12DA             printx16:
2413   12DA F8 00 00      enter 0 ; (push bp; mov bp, sp)
2414   12DD             
2415   12DD             ; --- BEGIN INLINE ASM SEGMENT
2416   12DD FA 05 00      lea d, [bp + 5] ; $hex
2417   12E0 2A            mov b, [d]
2418   12E1 07 51 20      call print_u16x
2419   12E4             ; --- END INLINE ASM SEGMENT
2420   12E4             
2421   12E4 F9            leave
2422   12E5 09            ret
2423   12E6             
2424   12E6             printx8:
2425   12E6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2426   12E9             
2427   12E9             ; --- BEGIN INLINE ASM SEGMENT
2428   12E9 FA 05 00      lea d, [bp + 5] ; $hex
2429   12EC 32            mov bl, [d]
2430   12ED 07 95 20      call print_u8x
2431   12F0             ; --- END INLINE ASM SEGMENT
2432   12F0             
2433   12F0 F9            leave
2434   12F1 09            ret
2435   12F2             
2436   12F2             hex_str_to_int:
2437   12F2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2438   12F5             ; int value = 0; 
2439   12F5 52 02 00      sub sp, 2
2440   12F8             ; --- START LOCAL VAR INITIALIZATION
2441   12F8 FA FF FF      lea d, [bp + -1] ; $value
2442   12FB DA            push d
2443   12FC FD 2E 00 00   mov32 cb, $00000000
2443   1300 00 00 
2444   1302 E7            pop d
2445   1303 FD 43         mov [d], b
2446   1305             ; --- END LOCAL VAR INITIALIZATION
2447   1305             ; int i; 
2448   1305 52 02 00      sub sp, 2
2449   1308             ; char hex_char; 
2450   1308 52 01 00      sub sp, 1
2451   130B             ; int len; 
2452   130B 52 02 00      sub sp, 2
2453   130E             ; len = strlen(hex_string); 
2454   130E FA FA FF      lea d, [bp + -6] ; $len
2455   1311 DA            push d
2456   1312             ; --- START FUNCTION CALL
2457   1312 FA 05 00      lea d, [bp + 5] ; $hex_string
2458   1315 2A            mov b, [d]
2459   1316 38 00 00      mov c, 0
2460   1319 FD AB         swp b
2461   131B D8            push b
2462   131C 07 02 06      call strlen
2463   131F 51 02 00      add sp, 2
2464   1322             ; --- END FUNCTION CALL
2465   1322 E7            pop d
2466   1323 FD 43         mov [d], b
2467   1325             ; for (i = 0; i < len; i++) { 
2468   1325             _for31_init:
2469   1325 FA FD FF      lea d, [bp + -3] ; $i
2470   1328 DA            push d
2471   1329 FD 2E 00 00   mov32 cb, $00000000
2471   132D 00 00 
2472   132F E7            pop d
2473   1330 FD 43         mov [d], b
2474   1332             _for31_cond:
2475   1332 FA FD FF      lea d, [bp + -3] ; $i
2476   1335 2A            mov b, [d]
2477   1336 38 00 00      mov c, 0
2478   1339             ; --- START RELATIONAL
2479   1339 D7            push a
2480   133A 11            mov a, b
2481   133B FA FA FF      lea d, [bp + -6] ; $len
2482   133E 2A            mov b, [d]
2483   133F 38 00 00      mov c, 0
2484   1342 B0            cmp a, b
2485   1343 FD 73         slt ; < (signed)
2486   1345 E4            pop a
2487   1346             ; --- END RELATIONAL
2488   1346 C0 00 00      cmp b, 0
2489   1349 C6 96 14      je _for31_exit
2490   134C             _for31_block:
2491   134C             ; hex_char = hex_string[i]; 
2492   134C FA FC FF      lea d, [bp + -4] ; $hex_char
2493   134F DA            push d
2494   1350 FA 05 00      lea d, [bp + 5] ; $hex_string
2495   1353 FD 2A         mov d, [d]
2496   1355 D7            push a
2497   1356 DA            push d
2498   1357 FA FD FF      lea d, [bp + -3] ; $i
2499   135A 2A            mov b, [d]
2500   135B 38 00 00      mov c, 0
2501   135E E7            pop d
2502   135F FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
2503   1363 E4            pop a
2504   1364 32            mov bl, [d]
2505   1365 A7 00         mov bh, 0
2506   1367 38 00 00      mov c, 0
2507   136A E7            pop d
2508   136B FD 3E         mov [d], bl
2509   136D             ; if (hex_char >= 'a' && hex_char <= 'f')  
2510   136D             _if32_cond:
2511   136D FA FC FF      lea d, [bp + -4] ; $hex_char
2512   1370 32            mov bl, [d]
2513   1371 A7 00         mov bh, 0
2514   1373 38 00 00      mov c, 0
2515   1376             ; --- START RELATIONAL
2516   1376 D7            push a
2517   1377 11            mov a, b
2518   1378 FD 2E 61 00   mov32 cb, $00000061
2518   137C 00 00 
2519   137E B0            cmp a, b
2520   137F FD 80         sge ; >=
2521   1381 E4            pop a
2522   1382             ; --- END RELATIONAL
2523   1382             ; --- START LOGICAL AND
2524   1382 D7            push a
2525   1383 11            mov a, b
2526   1384 FA FC FF      lea d, [bp + -4] ; $hex_char
2527   1387 32            mov bl, [d]
2528   1388 A7 00         mov bh, 0
2529   138A 38 00 00      mov c, 0
2530   138D             ; --- START RELATIONAL
2531   138D D7            push a
2532   138E 11            mov a, b
2533   138F FD 2E 66 00   mov32 cb, $00000066
2533   1393 00 00 
2534   1395 B0            cmp a, b
2535   1396 FD 74         sle ; <= (signed)
2536   1398 E4            pop a
2537   1399             ; --- END RELATIONAL
2538   1399 FD A7         sand a, b
2539   139B E4            pop a
2540   139C             ; --- END LOGICAL AND
2541   139C C0 00 00      cmp b, 0
2542   139F C6 DF 13      je _if32_else
2543   13A2             _if32_true:
2544   13A2             ; value = (value * 16) + (hex_char - 'a' + 10); 
2545   13A2 FA FF FF      lea d, [bp + -1] ; $value
2546   13A5 DA            push d
2547   13A6 FA FF FF      lea d, [bp + -1] ; $value
2548   13A9 2A            mov b, [d]
2549   13AA 38 00 00      mov c, 0
2550   13AD             ; --- START FACTORS
2551   13AD D7            push a
2552   13AE 11            mov a, b
2553   13AF FD 2E 10 00   mov32 cb, $00000010
2553   13B3 00 00 
2554   13B5 AC            mul a, b ; *
2555   13B6 11            mov a, b
2556   13B7 27            mov b, a
2557   13B8 E4            pop a
2558   13B9             ; --- END FACTORS
2559   13B9             ; --- START TERMS
2560   13B9 D7            push a
2561   13BA 11            mov a, b
2562   13BB FA FC FF      lea d, [bp + -4] ; $hex_char
2563   13BE 32            mov bl, [d]
2564   13BF A7 00         mov bh, 0
2565   13C1 38 00 00      mov c, 0
2566   13C4             ; --- START TERMS
2567   13C4 D7            push a
2568   13C5 11            mov a, b
2569   13C6 FD 2E 61 00   mov32 cb, $00000061
2569   13CA 00 00 
2570   13CC 60            sub a, b
2571   13CD 27            mov b, a
2572   13CE 11            mov a, b
2573   13CF FD 2E 0A 00   mov32 cb, $0000000a
2573   13D3 00 00 
2574   13D5 56            add b, a
2575   13D6 E4            pop a
2576   13D7             ; --- END TERMS
2577   13D7 56            add b, a
2578   13D8 E4            pop a
2579   13D9             ; --- END TERMS
2580   13D9 E7            pop d
2581   13DA FD 43         mov [d], b
2582   13DC 0A 83 14      jmp _if32_exit
2583   13DF             _if32_else:
2584   13DF             ; if (hex_char >= 'A' && hex_char <= 'F')  
2585   13DF             _if33_cond:
2586   13DF FA FC FF      lea d, [bp + -4] ; $hex_char
2587   13E2 32            mov bl, [d]
2588   13E3 A7 00         mov bh, 0
2589   13E5 38 00 00      mov c, 0
2590   13E8             ; --- START RELATIONAL
2591   13E8 D7            push a
2592   13E9 11            mov a, b
2593   13EA FD 2E 41 00   mov32 cb, $00000041
2593   13EE 00 00 
2594   13F0 B0            cmp a, b
2595   13F1 FD 80         sge ; >=
2596   13F3 E4            pop a
2597   13F4             ; --- END RELATIONAL
2598   13F4             ; --- START LOGICAL AND
2599   13F4 D7            push a
2600   13F5 11            mov a, b
2601   13F6 FA FC FF      lea d, [bp + -4] ; $hex_char
2602   13F9 32            mov bl, [d]
2603   13FA A7 00         mov bh, 0
2604   13FC 38 00 00      mov c, 0
2605   13FF             ; --- START RELATIONAL
2606   13FF D7            push a
2607   1400 11            mov a, b
2608   1401 FD 2E 46 00   mov32 cb, $00000046
2608   1405 00 00 
2609   1407 B0            cmp a, b
2610   1408 FD 74         sle ; <= (signed)
2611   140A E4            pop a
2612   140B             ; --- END RELATIONAL
2613   140B FD A7         sand a, b
2614   140D E4            pop a
2615   140E             ; --- END LOGICAL AND
2616   140E C0 00 00      cmp b, 0
2617   1411 C6 51 14      je _if33_else
2618   1414             _if33_true:
2619   1414             ; value = (value * 16) + (hex_char - 'A' + 10); 
2620   1414 FA FF FF      lea d, [bp + -1] ; $value
2621   1417 DA            push d
2622   1418 FA FF FF      lea d, [bp + -1] ; $value
2623   141B 2A            mov b, [d]
2624   141C 38 00 00      mov c, 0
2625   141F             ; --- START FACTORS
2626   141F D7            push a
2627   1420 11            mov a, b
2628   1421 FD 2E 10 00   mov32 cb, $00000010
2628   1425 00 00 
2629   1427 AC            mul a, b ; *
2630   1428 11            mov a, b
2631   1429 27            mov b, a
2632   142A E4            pop a
2633   142B             ; --- END FACTORS
2634   142B             ; --- START TERMS
2635   142B D7            push a
2636   142C 11            mov a, b
2637   142D FA FC FF      lea d, [bp + -4] ; $hex_char
2638   1430 32            mov bl, [d]
2639   1431 A7 00         mov bh, 0
2640   1433 38 00 00      mov c, 0
2641   1436             ; --- START TERMS
2642   1436 D7            push a
2643   1437 11            mov a, b
2644   1438 FD 2E 41 00   mov32 cb, $00000041
2644   143C 00 00 
2645   143E 60            sub a, b
2646   143F 27            mov b, a
2647   1440 11            mov a, b
2648   1441 FD 2E 0A 00   mov32 cb, $0000000a
2648   1445 00 00 
2649   1447 56            add b, a
2650   1448 E4            pop a
2651   1449             ; --- END TERMS
2652   1449 56            add b, a
2653   144A E4            pop a
2654   144B             ; --- END TERMS
2655   144B E7            pop d
2656   144C FD 43         mov [d], b
2657   144E 0A 83 14      jmp _if33_exit
2658   1451             _if33_else:
2659   1451             ; value = (value * 16) + (hex_char - '0'); 
2660   1451 FA FF FF      lea d, [bp + -1] ; $value
2661   1454 DA            push d
2662   1455 FA FF FF      lea d, [bp + -1] ; $value
2663   1458 2A            mov b, [d]
2664   1459 38 00 00      mov c, 0
2665   145C             ; --- START FACTORS
2666   145C D7            push a
2667   145D 11            mov a, b
2668   145E FD 2E 10 00   mov32 cb, $00000010
2668   1462 00 00 
2669   1464 AC            mul a, b ; *
2670   1465 11            mov a, b
2671   1466 27            mov b, a
2672   1467 E4            pop a
2673   1468             ; --- END FACTORS
2674   1468             ; --- START TERMS
2675   1468 D7            push a
2676   1469 11            mov a, b
2677   146A FA FC FF      lea d, [bp + -4] ; $hex_char
2678   146D 32            mov bl, [d]
2679   146E A7 00         mov bh, 0
2680   1470 38 00 00      mov c, 0
2681   1473             ; --- START TERMS
2682   1473 D7            push a
2683   1474 11            mov a, b
2684   1475 FD 2E 30 00   mov32 cb, $00000030
2684   1479 00 00 
2685   147B 60            sub a, b
2686   147C 27            mov b, a
2687   147D E4            pop a
2688   147E             ; --- END TERMS
2689   147E 56            add b, a
2690   147F E4            pop a
2691   1480             ; --- END TERMS
2692   1480 E7            pop d
2693   1481 FD 43         mov [d], b
2694   1483             _if33_exit:
2695   1483             _if32_exit:
2696   1483             _for31_update:
2697   1483 FA FD FF      lea d, [bp + -3] ; $i
2698   1486 2A            mov b, [d]
2699   1487 38 00 00      mov c, 0
2700   148A FD 77         inc b
2701   148C FA FD FF      lea d, [bp + -3] ; $i
2702   148F FD 43         mov [d], b
2703   1491 FD 7D         dec b
2704   1493 0A 32 13      jmp _for31_cond
2705   1496             _for31_exit:
2706   1496             ; return value; 
2707   1496 FA FF FF      lea d, [bp + -1] ; $value
2708   1499 2A            mov b, [d]
2709   149A 38 00 00      mov c, 0
2710   149D F9            leave
2711   149E 09            ret
2712   149F             
2713   149F             gets:
2714   149F F8 00 00      enter 0 ; (push bp; mov bp, sp)
2715   14A2             
2716   14A2             ; --- BEGIN INLINE ASM SEGMENT
2717   14A2 FA 05 00      lea d, [bp + 5] ; $s
2718   14A5 15            mov a, [d]
2719   14A6 3C            mov d, a
2720   14A7 07 B6 1E      call _gets
2721   14AA             ; --- END INLINE ASM SEGMENT
2722   14AA             
2723   14AA             ; return strlen(s); 
2724   14AA             ; --- START FUNCTION CALL
2725   14AA FA 05 00      lea d, [bp + 5] ; $s
2726   14AD 2A            mov b, [d]
2727   14AE 38 00 00      mov c, 0
2728   14B1 FD AB         swp b
2729   14B3 D8            push b
2730   14B4 07 02 06      call strlen
2731   14B7 51 02 00      add sp, 2
2732   14BA             ; --- END FUNCTION CALL
2733   14BA F9            leave
2734   14BB 09            ret
2735   14BC             
2736   14BC             print_signed:
2737   14BC F8 00 00      enter 0 ; (push bp; mov bp, sp)
2738   14BF             ; char digits[5]; 
2739   14BF 52 05 00      sub sp, 5
2740   14C2             ; int i = 0; 
2741   14C2 52 02 00      sub sp, 2
2742   14C5             ; --- START LOCAL VAR INITIALIZATION
2743   14C5 FA FA FF      lea d, [bp + -6] ; $i
2744   14C8 DA            push d
2745   14C9 FD 2E 00 00   mov32 cb, $00000000
2745   14CD 00 00 
2746   14CF E7            pop d
2747   14D0 FD 43         mov [d], b
2748   14D2             ; --- END LOCAL VAR INITIALIZATION
2749   14D2             ; if (num < 0) { 
2750   14D2             _if34_cond:
2751   14D2 FA 05 00      lea d, [bp + 5] ; $num
2752   14D5 2A            mov b, [d]
2753   14D6 38 00 00      mov c, 0
2754   14D9             ; --- START RELATIONAL
2755   14D9 D7            push a
2756   14DA 11            mov a, b
2757   14DB FD 2E 00 00   mov32 cb, $00000000
2757   14DF 00 00 
2758   14E1 B0            cmp a, b
2759   14E2 FD 73         slt ; < (signed)
2760   14E4 E4            pop a
2761   14E5             ; --- END RELATIONAL
2762   14E5 C0 00 00      cmp b, 0
2763   14E8 C6 0B 15      je _if34_else
2764   14EB             _if34_true:
2765   14EB             ; putchar('-'); 
2766   14EB             ; --- START FUNCTION CALL
2767   14EB FD 2E 2D 00   mov32 cb, $0000002d
2767   14EF 00 00 
2768   14F1 DD            push bl
2769   14F2 07 A0 1C      call putchar
2770   14F5 51 01 00      add sp, 1
2771   14F8             ; --- END FUNCTION CALL
2772   14F8             ; num = -num; 
2773   14F8 FA 05 00      lea d, [bp + 5] ; $num
2774   14FB DA            push d
2775   14FC FA 05 00      lea d, [bp + 5] ; $num
2776   14FF 2A            mov b, [d]
2777   1500 38 00 00      mov c, 0
2778   1503 FD 97         neg b
2779   1505 E7            pop d
2780   1506 FD 43         mov [d], b
2781   1508 0A 36 15      jmp _if34_exit
2782   150B             _if34_else:
2783   150B             ; if (num == 0) { 
2784   150B             _if35_cond:
2785   150B FA 05 00      lea d, [bp + 5] ; $num
2786   150E 2A            mov b, [d]
2787   150F 38 00 00      mov c, 0
2788   1512             ; --- START RELATIONAL
2789   1512 D7            push a
2790   1513 11            mov a, b
2791   1514 FD 2E 00 00   mov32 cb, $00000000
2791   1518 00 00 
2792   151A B0            cmp a, b
2793   151B FD 71         seq ; ==
2794   151D E4            pop a
2795   151E             ; --- END RELATIONAL
2796   151E C0 00 00      cmp b, 0
2797   1521 C6 36 15      je _if35_exit
2798   1524             _if35_true:
2799   1524             ; putchar('0'); 
2800   1524             ; --- START FUNCTION CALL
2801   1524 FD 2E 30 00   mov32 cb, $00000030
2801   1528 00 00 
2802   152A DD            push bl
2803   152B 07 A0 1C      call putchar
2804   152E 51 01 00      add sp, 1
2805   1531             ; --- END FUNCTION CALL
2806   1531             ; return; 
2807   1531 F9            leave
2808   1532 09            ret
2809   1533 0A 36 15      jmp _if35_exit
2810   1536             _if35_exit:
2811   1536             _if34_exit:
2812   1536             ; while (num > 0) { 
2813   1536             _while36_cond:
2814   1536 FA 05 00      lea d, [bp + 5] ; $num
2815   1539 2A            mov b, [d]
2816   153A 38 00 00      mov c, 0
2817   153D             ; --- START RELATIONAL
2818   153D D7            push a
2819   153E 11            mov a, b
2820   153F FD 2E 00 00   mov32 cb, $00000000
2820   1543 00 00 
2821   1545 B0            cmp a, b
2822   1546 FD 7F         sgt ; >
2823   1548 E4            pop a
2824   1549             ; --- END RELATIONAL
2825   1549 C0 00 00      cmp b, 0
2826   154C C6 AB 15      je _while36_exit
2827   154F             _while36_block:
2828   154F             ; digits[i] = '0' + (num % 10); 
2829   154F FA FC FF      lea d, [bp + -4] ; $digits
2830   1552 D7            push a
2831   1553 DA            push d
2832   1554 FA FA FF      lea d, [bp + -6] ; $i
2833   1557 2A            mov b, [d]
2834   1558 38 00 00      mov c, 0
2835   155B E7            pop d
2836   155C 5A            add d, b
2837   155D E4            pop a
2838   155E DA            push d
2839   155F FD 2E 30 00   mov32 cb, $00000030
2839   1563 00 00 
2840   1565             ; --- START TERMS
2841   1565 D7            push a
2842   1566 11            mov a, b
2843   1567 FA 05 00      lea d, [bp + 5] ; $num
2844   156A 2A            mov b, [d]
2845   156B 38 00 00      mov c, 0
2846   156E             ; --- START FACTORS
2847   156E D7            push a
2848   156F 11            mov a, b
2849   1570 FD 2E 0A 00   mov32 cb, $0000000a
2849   1574 00 00 
2850   1576 AE            div a, b ; 
2851   1577 11            mov a, b
2852   1578 27            mov b, a
2853   1579 E4            pop a
2854   157A             ; --- END FACTORS
2855   157A 56            add b, a
2856   157B E4            pop a
2857   157C             ; --- END TERMS
2858   157C E7            pop d
2859   157D FD 3E         mov [d], bl
2860   157F             ; num = num / 10; 
2861   157F FA 05 00      lea d, [bp + 5] ; $num
2862   1582 DA            push d
2863   1583 FA 05 00      lea d, [bp + 5] ; $num
2864   1586 2A            mov b, [d]
2865   1587 38 00 00      mov c, 0
2866   158A             ; --- START FACTORS
2867   158A D7            push a
2868   158B 11            mov a, b
2869   158C FD 2E 0A 00   mov32 cb, $0000000a
2869   1590 00 00 
2870   1592 AE            div a, b
2871   1593 27            mov b, a
2872   1594 E4            pop a
2873   1595             ; --- END FACTORS
2874   1595 E7            pop d
2875   1596 FD 43         mov [d], b
2876   1598             ; i++; 
2877   1598 FA FA FF      lea d, [bp + -6] ; $i
2878   159B 2A            mov b, [d]
2879   159C 38 00 00      mov c, 0
2880   159F FD 77         inc b
2881   15A1 FA FA FF      lea d, [bp + -6] ; $i
2882   15A4 FD 43         mov [d], b
2883   15A6 FD 7D         dec b
2884   15A8 0A 36 15      jmp _while36_cond
2885   15AB             _while36_exit:
2886   15AB             ; while (i > 0) { 
2887   15AB             _while37_cond:
2888   15AB FA FA FF      lea d, [bp + -6] ; $i
2889   15AE 2A            mov b, [d]
2890   15AF 38 00 00      mov c, 0
2891   15B2             ; --- START RELATIONAL
2892   15B2 D7            push a
2893   15B3 11            mov a, b
2894   15B4 FD 2E 00 00   mov32 cb, $00000000
2894   15B8 00 00 
2895   15BA B0            cmp a, b
2896   15BB FD 7F         sgt ; >
2897   15BD E4            pop a
2898   15BE             ; --- END RELATIONAL
2899   15BE C0 00 00      cmp b, 0
2900   15C1 C6 F3 15      je _while37_exit
2901   15C4             _while37_block:
2902   15C4             ; i--; 
2903   15C4 FA FA FF      lea d, [bp + -6] ; $i
2904   15C7 2A            mov b, [d]
2905   15C8 38 00 00      mov c, 0
2906   15CB FD 7D         dec b
2907   15CD FA FA FF      lea d, [bp + -6] ; $i
2908   15D0 FD 43         mov [d], b
2909   15D2 FD 77         inc b
2910   15D4             ; putchar(digits[i]); 
2911   15D4             ; --- START FUNCTION CALL
2912   15D4 FA FC FF      lea d, [bp + -4] ; $digits
2913   15D7 D7            push a
2914   15D8 DA            push d
2915   15D9 FA FA FF      lea d, [bp + -6] ; $i
2916   15DC 2A            mov b, [d]
2917   15DD 38 00 00      mov c, 0
2918   15E0 E7            pop d
2919   15E1 5A            add d, b
2920   15E2 E4            pop a
2921   15E3 32            mov bl, [d]
2922   15E4 A7 00         mov bh, 0
2923   15E6 38 00 00      mov c, 0
2924   15E9 DD            push bl
2925   15EA 07 A0 1C      call putchar
2926   15ED 51 01 00      add sp, 1
2927   15F0             ; --- END FUNCTION CALL
2928   15F0 0A AB 15      jmp _while37_cond
2929   15F3             _while37_exit:
2930   15F3 F9            leave
2931   15F4 09            ret
2932   15F5             
2933   15F5             print_signed_long:
2934   15F5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2935   15F8             ; char digits[10]; 
2936   15F8 52 0A 00      sub sp, 10
2937   15FB             ; int i = 0; 
2938   15FB 52 02 00      sub sp, 2
2939   15FE             ; --- START LOCAL VAR INITIALIZATION
2940   15FE FA F5 FF      lea d, [bp + -11] ; $i
2941   1601 DA            push d
2942   1602 FD 2E 00 00   mov32 cb, $00000000
2942   1606 00 00 
2943   1608 E7            pop d
2944   1609 FD 43         mov [d], b
2945   160B             ; --- END LOCAL VAR INITIALIZATION
2946   160B             ; if (num < 0) { 
2947   160B             _if38_cond:
2948   160B FA 05 00      lea d, [bp + 5] ; $num
2949   160E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2950   1611 FD 39         mov c, b ; And place it into C
2951   1613 2A            mov b, [d] ; Lower Word in B
2952   1614             ; --- START RELATIONAL
2953   1614 D7            push a
2954   1615 FD D8         push g
2955   1617 11            mov a, b
2956   1618 FD 7A         mov g, c
2957   161A FD 2E 00 00   mov32 cb, $00000000
2957   161E 00 00 
2958   1620 FD AF         cmp32 ga, cb
2959   1622 FD 73         slt ; <
2960   1624 FD F1         pop g
2961   1626 E4            pop a
2962   1627             ; --- END RELATIONAL
2963   1627 C0 00 00      cmp b, 0
2964   162A C6 5E 16      je _if38_else
2965   162D             _if38_true:
2966   162D             ; putchar('-'); 
2967   162D             ; --- START FUNCTION CALL
2968   162D FD 2E 2D 00   mov32 cb, $0000002d
2968   1631 00 00 
2969   1633 DD            push bl
2970   1634 07 A0 1C      call putchar
2971   1637 51 01 00      add sp, 1
2972   163A             ; --- END FUNCTION CALL
2973   163A             ; num = -num; 
2974   163A FA 05 00      lea d, [bp + 5] ; $num
2975   163D DA            push d
2976   163E FA 05 00      lea d, [bp + 5] ; $num
2977   1641 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2978   1644 FD 39         mov c, b ; And place it into C
2979   1646 2A            mov b, [d] ; Lower Word in B
2980   1647 12            mov a, c
2981   1648 95            not a
2982   1649 97            not b
2983   164A 55 01 00      add b, 1
2984   164D 5B 00 00      adc a, 0
2985   1650 39            mov c, a
2986   1651 E7            pop d
2987   1652 FD 43         mov [d], b
2988   1654 26 00 00      mov b, 0
2989   1657 FD 44 02 00   mov [d + 2], b
2990   165B 0A 92 16      jmp _if38_exit
2991   165E             _if38_else:
2992   165E             ; if (num == 0) { 
2993   165E             _if39_cond:
2994   165E FA 05 00      lea d, [bp + 5] ; $num
2995   1661 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2996   1664 FD 39         mov c, b ; And place it into C
2997   1666 2A            mov b, [d] ; Lower Word in B
2998   1667             ; --- START RELATIONAL
2999   1667 D7            push a
3000   1668 FD D8         push g
3001   166A 11            mov a, b
3002   166B FD 7A         mov g, c
3003   166D FD 2E 00 00   mov32 cb, $00000000
3003   1671 00 00 
3004   1673 FD AF         cmp32 ga, cb
3005   1675 FD 71         seq ; ==
3006   1677 FD F1         pop g
3007   1679 E4            pop a
3008   167A             ; --- END RELATIONAL
3009   167A C0 00 00      cmp b, 0
3010   167D C6 92 16      je _if39_exit
3011   1680             _if39_true:
3012   1680             ; putchar('0'); 
3013   1680             ; --- START FUNCTION CALL
3014   1680 FD 2E 30 00   mov32 cb, $00000030
3014   1684 00 00 
3015   1686 DD            push bl
3016   1687 07 A0 1C      call putchar
3017   168A 51 01 00      add sp, 1
3018   168D             ; --- END FUNCTION CALL
3019   168D             ; return; 
3020   168D F9            leave
3021   168E 09            ret
3022   168F 0A 92 16      jmp _if39_exit
3023   1692             _if39_exit:
3024   1692             _if38_exit:
3025   1692             ; while (num > 0) { 
3026   1692             _while40_cond:
3027   1692 FA 05 00      lea d, [bp + 5] ; $num
3028   1695 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3029   1698 FD 39         mov c, b ; And place it into C
3030   169A 2A            mov b, [d] ; Lower Word in B
3031   169B             ; --- START RELATIONAL
3032   169B D7            push a
3033   169C FD D8         push g
3034   169E 11            mov a, b
3035   169F FD 7A         mov g, c
3036   16A1 FD 2E 00 00   mov32 cb, $00000000
3036   16A5 00 00 
3037   16A7 FD AF         cmp32 ga, cb
3038   16A9 FD 7F         sgt
3039   16AB FD F1         pop g
3040   16AD E4            pop a
3041   16AE             ; --- END RELATIONAL
3042   16AE C0 00 00      cmp b, 0
3043   16B1 C6 1A 17      je _while40_exit
3044   16B4             _while40_block:
3045   16B4             ; digits[i] = '0' + (num % 10); 
3046   16B4 FA F7 FF      lea d, [bp + -9] ; $digits
3047   16B7 D7            push a
3048   16B8 DA            push d
3049   16B9 FA F5 FF      lea d, [bp + -11] ; $i
3050   16BC 2A            mov b, [d]
3051   16BD 38 00 00      mov c, 0
3052   16C0 E7            pop d
3053   16C1 5A            add d, b
3054   16C2 E4            pop a
3055   16C3 DA            push d
3056   16C4 FD 2E 30 00   mov32 cb, $00000030
3056   16C8 00 00 
3057   16CA             ; --- START TERMS
3058   16CA D7            push a
3059   16CB 11            mov a, b
3060   16CC FA 05 00      lea d, [bp + 5] ; $num
3061   16CF 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3062   16D2 FD 39         mov c, b ; And place it into C
3063   16D4 2A            mov b, [d] ; Lower Word in B
3064   16D5             ; --- START FACTORS
3065   16D5 D7            push a
3066   16D6 11            mov a, b
3067   16D7 FD 2E 0A 00   mov32 cb, $0000000a
3067   16DB 00 00 
3068   16DD AE            div a, b ; 
3069   16DE 11            mov a, b
3070   16DF 27            mov b, a
3071   16E0 E4            pop a
3072   16E1             ; --- END FACTORS
3073   16E1 FD 15         add32 cb, ga
3074   16E3 E4            pop a
3075   16E4             ; --- END TERMS
3076   16E4 E7            pop d
3077   16E5 FD 3E         mov [d], bl
3078   16E7             ; num = num / 10; 
3079   16E7 FA 05 00      lea d, [bp + 5] ; $num
3080   16EA DA            push d
3081   16EB FA 05 00      lea d, [bp + 5] ; $num
3082   16EE 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3083   16F1 FD 39         mov c, b ; And place it into C
3084   16F3 2A            mov b, [d] ; Lower Word in B
3085   16F4             ; --- START FACTORS
3086   16F4 D7            push a
3087   16F5 11            mov a, b
3088   16F6 FD 2E 0A 00   mov32 cb, $0000000a
3088   16FA 00 00 
3089   16FC AE            div a, b
3090   16FD 27            mov b, a
3091   16FE E4            pop a
3092   16FF             ; --- END FACTORS
3093   16FF E7            pop d
3094   1700 FD 43         mov [d], b
3095   1702 28            mov b, c
3096   1703 FD 44 02 00   mov [d + 2], b
3097   1707             ; i++; 
3098   1707 FA F5 FF      lea d, [bp + -11] ; $i
3099   170A 2A            mov b, [d]
3100   170B 38 00 00      mov c, 0
3101   170E FD 77         inc b
3102   1710 FA F5 FF      lea d, [bp + -11] ; $i
3103   1713 FD 43         mov [d], b
3104   1715 FD 7D         dec b
3105   1717 0A 92 16      jmp _while40_cond
3106   171A             _while40_exit:
3107   171A             ; while (i > 0) { 
3108   171A             _while41_cond:
3109   171A FA F5 FF      lea d, [bp + -11] ; $i
3110   171D 2A            mov b, [d]
3111   171E 38 00 00      mov c, 0
3112   1721             ; --- START RELATIONAL
3113   1721 D7            push a
3114   1722 11            mov a, b
3115   1723 FD 2E 00 00   mov32 cb, $00000000
3115   1727 00 00 
3116   1729 B0            cmp a, b
3117   172A FD 7F         sgt ; >
3118   172C E4            pop a
3119   172D             ; --- END RELATIONAL
3120   172D C0 00 00      cmp b, 0
3121   1730 C6 62 17      je _while41_exit
3122   1733             _while41_block:
3123   1733             ; i--; 
3124   1733 FA F5 FF      lea d, [bp + -11] ; $i
3125   1736 2A            mov b, [d]
3126   1737 38 00 00      mov c, 0
3127   173A FD 7D         dec b
3128   173C FA F5 FF      lea d, [bp + -11] ; $i
3129   173F FD 43         mov [d], b
3130   1741 FD 77         inc b
3131   1743             ; putchar(digits[i]); 
3132   1743             ; --- START FUNCTION CALL
3133   1743 FA F7 FF      lea d, [bp + -9] ; $digits
3134   1746 D7            push a
3135   1747 DA            push d
3136   1748 FA F5 FF      lea d, [bp + -11] ; $i
3137   174B 2A            mov b, [d]
3138   174C 38 00 00      mov c, 0
3139   174F E7            pop d
3140   1750 5A            add d, b
3141   1751 E4            pop a
3142   1752 32            mov bl, [d]
3143   1753 A7 00         mov bh, 0
3144   1755 38 00 00      mov c, 0
3145   1758 DD            push bl
3146   1759 07 A0 1C      call putchar
3147   175C 51 01 00      add sp, 1
3148   175F             ; --- END FUNCTION CALL
3149   175F 0A 1A 17      jmp _while41_cond
3150   1762             _while41_exit:
3151   1762 F9            leave
3152   1763 09            ret
3153   1764             
3154   1764             print_unsigned_long:
3155   1764 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3156   1767             ; char digits[10]; 
3157   1767 52 0A 00      sub sp, 10
3158   176A             ; int i; 
3159   176A 52 02 00      sub sp, 2
3160   176D             ; i = 0; 
3161   176D FA F5 FF      lea d, [bp + -11] ; $i
3162   1770 DA            push d
3163   1771 FD 2E 00 00   mov32 cb, $00000000
3163   1775 00 00 
3164   1777 E7            pop d
3165   1778 FD 43         mov [d], b
3166   177A             ; if(num == 0){ 
3167   177A             _if42_cond:
3168   177A FA 05 00      lea d, [bp + 5] ; $num
3169   177D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3170   1780 FD 39         mov c, b ; And place it into C
3171   1782 2A            mov b, [d] ; Lower Word in B
3172   1783             ; --- START RELATIONAL
3173   1783 D7            push a
3174   1784 FD D8         push g
3175   1786 11            mov a, b
3176   1787 FD 7A         mov g, c
3177   1789 FD 2E 00 00   mov32 cb, $00000000
3177   178D 00 00 
3178   178F FD AF         cmp32 ga, cb
3179   1791 FD 71         seq ; ==
3180   1793 FD F1         pop g
3181   1795 E4            pop a
3182   1796             ; --- END RELATIONAL
3183   1796 C0 00 00      cmp b, 0
3184   1799 C6 AE 17      je _if42_exit
3185   179C             _if42_true:
3186   179C             ; putchar('0'); 
3187   179C             ; --- START FUNCTION CALL
3188   179C FD 2E 30 00   mov32 cb, $00000030
3188   17A0 00 00 
3189   17A2 DD            push bl
3190   17A3 07 A0 1C      call putchar
3191   17A6 51 01 00      add sp, 1
3192   17A9             ; --- END FUNCTION CALL
3193   17A9             ; return; 
3194   17A9 F9            leave
3195   17AA 09            ret
3196   17AB 0A AE 17      jmp _if42_exit
3197   17AE             _if42_exit:
3198   17AE             ; while (num > 0) { 
3199   17AE             _while43_cond:
3200   17AE FA 05 00      lea d, [bp + 5] ; $num
3201   17B1 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3202   17B4 FD 39         mov c, b ; And place it into C
3203   17B6 2A            mov b, [d] ; Lower Word in B
3204   17B7             ; --- START RELATIONAL
3205   17B7 D7            push a
3206   17B8 FD D8         push g
3207   17BA 11            mov a, b
3208   17BB FD 7A         mov g, c
3209   17BD FD 2E 00 00   mov32 cb, $00000000
3209   17C1 00 00 
3210   17C3 FD AF         cmp32 ga, cb
3211   17C5 FD 81         sgu
3212   17C7 FD F1         pop g
3213   17C9 E4            pop a
3214   17CA             ; --- END RELATIONAL
3215   17CA C0 00 00      cmp b, 0
3216   17CD C6 36 18      je _while43_exit
3217   17D0             _while43_block:
3218   17D0             ; digits[i] = '0' + (num % 10); 
3219   17D0 FA F7 FF      lea d, [bp + -9] ; $digits
3220   17D3 D7            push a
3221   17D4 DA            push d
3222   17D5 FA F5 FF      lea d, [bp + -11] ; $i
3223   17D8 2A            mov b, [d]
3224   17D9 38 00 00      mov c, 0
3225   17DC E7            pop d
3226   17DD 5A            add d, b
3227   17DE E4            pop a
3228   17DF DA            push d
3229   17E0 FD 2E 30 00   mov32 cb, $00000030
3229   17E4 00 00 
3230   17E6             ; --- START TERMS
3231   17E6 D7            push a
3232   17E7 11            mov a, b
3233   17E8 FA 05 00      lea d, [bp + 5] ; $num
3234   17EB 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3235   17EE FD 39         mov c, b ; And place it into C
3236   17F0 2A            mov b, [d] ; Lower Word in B
3237   17F1             ; --- START FACTORS
3238   17F1 D7            push a
3239   17F2 11            mov a, b
3240   17F3 FD 2E 0A 00   mov32 cb, $0000000a
3240   17F7 00 00 
3241   17F9 AE            div a, b ; 
3242   17FA 11            mov a, b
3243   17FB 27            mov b, a
3244   17FC E4            pop a
3245   17FD             ; --- END FACTORS
3246   17FD FD 15         add32 cb, ga
3247   17FF E4            pop a
3248   1800             ; --- END TERMS
3249   1800 E7            pop d
3250   1801 FD 3E         mov [d], bl
3251   1803             ; num = num / 10; 
3252   1803 FA 05 00      lea d, [bp + 5] ; $num
3253   1806 DA            push d
3254   1807 FA 05 00      lea d, [bp + 5] ; $num
3255   180A 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
3256   180D FD 39         mov c, b ; And place it into C
3257   180F 2A            mov b, [d] ; Lower Word in B
3258   1810             ; --- START FACTORS
3259   1810 D7            push a
3260   1811 11            mov a, b
3261   1812 FD 2E 0A 00   mov32 cb, $0000000a
3261   1816 00 00 
3262   1818 AE            div a, b
3263   1819 27            mov b, a
3264   181A E4            pop a
3265   181B             ; --- END FACTORS
3266   181B E7            pop d
3267   181C FD 43         mov [d], b
3268   181E 28            mov b, c
3269   181F FD 44 02 00   mov [d + 2], b
3270   1823             ; i++; 
3271   1823 FA F5 FF      lea d, [bp + -11] ; $i
3272   1826 2A            mov b, [d]
3273   1827 38 00 00      mov c, 0
3274   182A FD 77         inc b
3275   182C FA F5 FF      lea d, [bp + -11] ; $i
3276   182F FD 43         mov [d], b
3277   1831 FD 7D         dec b
3278   1833 0A AE 17      jmp _while43_cond
3279   1836             _while43_exit:
3280   1836             ; while (i > 0) { 
3281   1836             _while44_cond:
3282   1836 FA F5 FF      lea d, [bp + -11] ; $i
3283   1839 2A            mov b, [d]
3284   183A 38 00 00      mov c, 0
3285   183D             ; --- START RELATIONAL
3286   183D D7            push a
3287   183E 11            mov a, b
3288   183F FD 2E 00 00   mov32 cb, $00000000
3288   1843 00 00 
3289   1845 B0            cmp a, b
3290   1846 FD 7F         sgt ; >
3291   1848 E4            pop a
3292   1849             ; --- END RELATIONAL
3293   1849 C0 00 00      cmp b, 0
3294   184C C6 7E 18      je _while44_exit
3295   184F             _while44_block:
3296   184F             ; i--; 
3297   184F FA F5 FF      lea d, [bp + -11] ; $i
3298   1852 2A            mov b, [d]
3299   1853 38 00 00      mov c, 0
3300   1856 FD 7D         dec b
3301   1858 FA F5 FF      lea d, [bp + -11] ; $i
3302   185B FD 43         mov [d], b
3303   185D FD 77         inc b
3304   185F             ; putchar(digits[i]); 
3305   185F             ; --- START FUNCTION CALL
3306   185F FA F7 FF      lea d, [bp + -9] ; $digits
3307   1862 D7            push a
3308   1863 DA            push d
3309   1864 FA F5 FF      lea d, [bp + -11] ; $i
3310   1867 2A            mov b, [d]
3311   1868 38 00 00      mov c, 0
3312   186B E7            pop d
3313   186C 5A            add d, b
3314   186D E4            pop a
3315   186E 32            mov bl, [d]
3316   186F A7 00         mov bh, 0
3317   1871 38 00 00      mov c, 0
3318   1874 DD            push bl
3319   1875 07 A0 1C      call putchar
3320   1878 51 01 00      add sp, 1
3321   187B             ; --- END FUNCTION CALL
3322   187B 0A 36 18      jmp _while44_cond
3323   187E             _while44_exit:
3324   187E F9            leave
3325   187F 09            ret
3326   1880             
3327   1880             sprint_unsigned:
3328   1880 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3329   1883             ; char digits[5]; 
3330   1883 52 05 00      sub sp, 5
3331   1886             ; int i; 
3332   1886 52 02 00      sub sp, 2
3333   1889             ; int len = 0; 
3334   1889 52 02 00      sub sp, 2
3335   188C             ; --- START LOCAL VAR INITIALIZATION
3336   188C FA F8 FF      lea d, [bp + -8] ; $len
3337   188F DA            push d
3338   1890 FD 2E 00 00   mov32 cb, $00000000
3338   1894 00 00 
3339   1896 E7            pop d
3340   1897 FD 43         mov [d], b
3341   1899             ; --- END LOCAL VAR INITIALIZATION
3342   1899             ; i = 0; 
3343   1899 FA FA FF      lea d, [bp + -6] ; $i
3344   189C DA            push d
3345   189D FD 2E 00 00   mov32 cb, $00000000
3345   18A1 00 00 
3346   18A3 E7            pop d
3347   18A4 FD 43         mov [d], b
3348   18A6             ; if(num == 0){ 
3349   18A6             _if45_cond:
3350   18A6 FA 07 00      lea d, [bp + 7] ; $num
3351   18A9 2A            mov b, [d]
3352   18AA 38 00 00      mov c, 0
3353   18AD             ; --- START RELATIONAL
3354   18AD D7            push a
3355   18AE 11            mov a, b
3356   18AF FD 2E 00 00   mov32 cb, $00000000
3356   18B3 00 00 
3357   18B5 B0            cmp a, b
3358   18B6 FD 71         seq ; ==
3359   18B8 E4            pop a
3360   18B9             ; --- END RELATIONAL
3361   18B9 C0 00 00      cmp b, 0
3362   18BC C6 E4 18      je _if45_exit
3363   18BF             _if45_true:
3364   18BF             ; *dest++ = '0'; 
3365   18BF FA 05 00      lea d, [bp + 5] ; $dest
3366   18C2 2A            mov b, [d]
3367   18C3 38 00 00      mov c, 0
3368   18C6 FD 77         inc b
3369   18C8 FA 05 00      lea d, [bp + 5] ; $dest
3370   18CB FD 43         mov [d], b
3371   18CD FD 7D         dec b
3372   18CF D8            push b
3373   18D0 FD 2E 30 00   mov32 cb, $00000030
3373   18D4 00 00 
3374   18D6 E7            pop d
3375   18D7 FD 3E         mov [d], bl
3376   18D9             ; return 1; 
3377   18D9 FD 2E 01 00   mov32 cb, $00000001
3377   18DD 00 00 
3378   18DF F9            leave
3379   18E0 09            ret
3380   18E1 0A E4 18      jmp _if45_exit
3381   18E4             _if45_exit:
3382   18E4             ; while (num > 0) { 
3383   18E4             _while46_cond:
3384   18E4 FA 07 00      lea d, [bp + 7] ; $num
3385   18E7 2A            mov b, [d]
3386   18E8 38 00 00      mov c, 0
3387   18EB             ; --- START RELATIONAL
3388   18EB D7            push a
3389   18EC 11            mov a, b
3390   18ED FD 2E 00 00   mov32 cb, $00000000
3390   18F1 00 00 
3391   18F3 B0            cmp a, b
3392   18F4 FD 81         sgu ; > (unsigned)
3393   18F6 E4            pop a
3394   18F7             ; --- END RELATIONAL
3395   18F7 C0 00 00      cmp b, 0
3396   18FA C6 59 19      je _while46_exit
3397   18FD             _while46_block:
3398   18FD             ; digits[i] = '0' + (num % 10); 
3399   18FD FA FC FF      lea d, [bp + -4] ; $digits
3400   1900 D7            push a
3401   1901 DA            push d
3402   1902 FA FA FF      lea d, [bp + -6] ; $i
3403   1905 2A            mov b, [d]
3404   1906 38 00 00      mov c, 0
3405   1909 E7            pop d
3406   190A 5A            add d, b
3407   190B E4            pop a
3408   190C DA            push d
3409   190D FD 2E 30 00   mov32 cb, $00000030
3409   1911 00 00 
3410   1913             ; --- START TERMS
3411   1913 D7            push a
3412   1914 11            mov a, b
3413   1915 FA 07 00      lea d, [bp + 7] ; $num
3414   1918 2A            mov b, [d]
3415   1919 38 00 00      mov c, 0
3416   191C             ; --- START FACTORS
3417   191C D7            push a
3418   191D 11            mov a, b
3419   191E FD 2E 0A 00   mov32 cb, $0000000a
3419   1922 00 00 
3420   1924 AE            div a, b ; 
3421   1925 11            mov a, b
3422   1926 27            mov b, a
3423   1927 E4            pop a
3424   1928             ; --- END FACTORS
3425   1928 56            add b, a
3426   1929 E4            pop a
3427   192A             ; --- END TERMS
3428   192A E7            pop d
3429   192B FD 3E         mov [d], bl
3430   192D             ; num = num / 10; 
3431   192D FA 07 00      lea d, [bp + 7] ; $num
3432   1930 DA            push d
3433   1931 FA 07 00      lea d, [bp + 7] ; $num
3434   1934 2A            mov b, [d]
3435   1935 38 00 00      mov c, 0
3436   1938             ; --- START FACTORS
3437   1938 D7            push a
3438   1939 11            mov a, b
3439   193A FD 2E 0A 00   mov32 cb, $0000000a
3439   193E 00 00 
3440   1940 AE            div a, b
3441   1941 27            mov b, a
3442   1942 E4            pop a
3443   1943             ; --- END FACTORS
3444   1943 E7            pop d
3445   1944 FD 43         mov [d], b
3446   1946             ; i++; 
3447   1946 FA FA FF      lea d, [bp + -6] ; $i
3448   1949 2A            mov b, [d]
3449   194A 38 00 00      mov c, 0
3450   194D FD 77         inc b
3451   194F FA FA FF      lea d, [bp + -6] ; $i
3452   1952 FD 43         mov [d], b
3453   1954 FD 7D         dec b
3454   1956 0A E4 18      jmp _while46_cond
3455   1959             _while46_exit:
3456   1959             ; while (i > 0) { 
3457   1959             _while47_cond:
3458   1959 FA FA FF      lea d, [bp + -6] ; $i
3459   195C 2A            mov b, [d]
3460   195D 38 00 00      mov c, 0
3461   1960             ; --- START RELATIONAL
3462   1960 D7            push a
3463   1961 11            mov a, b
3464   1962 FD 2E 00 00   mov32 cb, $00000000
3464   1966 00 00 
3465   1968 B0            cmp a, b
3466   1969 FD 7F         sgt ; >
3467   196B E4            pop a
3468   196C             ; --- END RELATIONAL
3469   196C C0 00 00      cmp b, 0
3470   196F C6 BE 19      je _while47_exit
3471   1972             _while47_block:
3472   1972             ; i--; 
3473   1972 FA FA FF      lea d, [bp + -6] ; $i
3474   1975 2A            mov b, [d]
3475   1976 38 00 00      mov c, 0
3476   1979 FD 7D         dec b
3477   197B FA FA FF      lea d, [bp + -6] ; $i
3478   197E FD 43         mov [d], b
3479   1980 FD 77         inc b
3480   1982             ; *dest++ = digits[i]; 
3481   1982 FA 05 00      lea d, [bp + 5] ; $dest
3482   1985 2A            mov b, [d]
3483   1986 38 00 00      mov c, 0
3484   1989 FD 77         inc b
3485   198B FA 05 00      lea d, [bp + 5] ; $dest
3486   198E FD 43         mov [d], b
3487   1990 FD 7D         dec b
3488   1992 D8            push b
3489   1993 FA FC FF      lea d, [bp + -4] ; $digits
3490   1996 D7            push a
3491   1997 DA            push d
3492   1998 FA FA FF      lea d, [bp + -6] ; $i
3493   199B 2A            mov b, [d]
3494   199C 38 00 00      mov c, 0
3495   199F E7            pop d
3496   19A0 5A            add d, b
3497   19A1 E4            pop a
3498   19A2 32            mov bl, [d]
3499   19A3 A7 00         mov bh, 0
3500   19A5 38 00 00      mov c, 0
3501   19A8 E7            pop d
3502   19A9 FD 3E         mov [d], bl
3503   19AB             ; len++; 
3504   19AB FA F8 FF      lea d, [bp + -8] ; $len
3505   19AE 2A            mov b, [d]
3506   19AF 38 00 00      mov c, 0
3507   19B2 FD 77         inc b
3508   19B4 FA F8 FF      lea d, [bp + -8] ; $len
3509   19B7 FD 43         mov [d], b
3510   19B9 FD 7D         dec b
3511   19BB 0A 59 19      jmp _while47_cond
3512   19BE             _while47_exit:
3513   19BE             ; *dest = '\0'; 
3514   19BE FA 05 00      lea d, [bp + 5] ; $dest
3515   19C1 2A            mov b, [d]
3516   19C2 38 00 00      mov c, 0
3517   19C5 D8            push b
3518   19C6 FD 2E 00 00   mov32 cb, $00000000
3518   19CA 00 00 
3519   19CC E7            pop d
3520   19CD FD 3E         mov [d], bl
3521   19CF             ; return len; 
3522   19CF FA F8 FF      lea d, [bp + -8] ; $len
3523   19D2 2A            mov b, [d]
3524   19D3 38 00 00      mov c, 0
3525   19D6 F9            leave
3526   19D7 09            ret
3527   19D8             
3528   19D8             print_unsigned:
3529   19D8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3530   19DB             ; char digits[5]; 
3531   19DB 52 05 00      sub sp, 5
3532   19DE             ; int i; 
3533   19DE 52 02 00      sub sp, 2
3534   19E1             ; i = 0; 
3535   19E1 FA FA FF      lea d, [bp + -6] ; $i
3536   19E4 DA            push d
3537   19E5 FD 2E 00 00   mov32 cb, $00000000
3537   19E9 00 00 
3538   19EB E7            pop d
3539   19EC FD 43         mov [d], b
3540   19EE             ; if(num == 0){ 
3541   19EE             _if48_cond:
3542   19EE FA 05 00      lea d, [bp + 5] ; $num
3543   19F1 2A            mov b, [d]
3544   19F2 38 00 00      mov c, 0
3545   19F5             ; --- START RELATIONAL
3546   19F5 D7            push a
3547   19F6 11            mov a, b
3548   19F7 FD 2E 00 00   mov32 cb, $00000000
3548   19FB 00 00 
3549   19FD B0            cmp a, b
3550   19FE FD 71         seq ; ==
3551   1A00 E4            pop a
3552   1A01             ; --- END RELATIONAL
3553   1A01 C0 00 00      cmp b, 0
3554   1A04 C6 19 1A      je _if48_exit
3555   1A07             _if48_true:
3556   1A07             ; putchar('0'); 
3557   1A07             ; --- START FUNCTION CALL
3558   1A07 FD 2E 30 00   mov32 cb, $00000030
3558   1A0B 00 00 
3559   1A0D DD            push bl
3560   1A0E 07 A0 1C      call putchar
3561   1A11 51 01 00      add sp, 1
3562   1A14             ; --- END FUNCTION CALL
3563   1A14             ; return; 
3564   1A14 F9            leave
3565   1A15 09            ret
3566   1A16 0A 19 1A      jmp _if48_exit
3567   1A19             _if48_exit:
3568   1A19             ; while (num > 0) { 
3569   1A19             _while49_cond:
3570   1A19 FA 05 00      lea d, [bp + 5] ; $num
3571   1A1C 2A            mov b, [d]
3572   1A1D 38 00 00      mov c, 0
3573   1A20             ; --- START RELATIONAL
3574   1A20 D7            push a
3575   1A21 11            mov a, b
3576   1A22 FD 2E 00 00   mov32 cb, $00000000
3576   1A26 00 00 
3577   1A28 B0            cmp a, b
3578   1A29 FD 81         sgu ; > (unsigned)
3579   1A2B E4            pop a
3580   1A2C             ; --- END RELATIONAL
3581   1A2C C0 00 00      cmp b, 0
3582   1A2F C6 8E 1A      je _while49_exit
3583   1A32             _while49_block:
3584   1A32             ; digits[i] = '0' + (num % 10); 
3585   1A32 FA FC FF      lea d, [bp + -4] ; $digits
3586   1A35 D7            push a
3587   1A36 DA            push d
3588   1A37 FA FA FF      lea d, [bp + -6] ; $i
3589   1A3A 2A            mov b, [d]
3590   1A3B 38 00 00      mov c, 0
3591   1A3E E7            pop d
3592   1A3F 5A            add d, b
3593   1A40 E4            pop a
3594   1A41 DA            push d
3595   1A42 FD 2E 30 00   mov32 cb, $00000030
3595   1A46 00 00 
3596   1A48             ; --- START TERMS
3597   1A48 D7            push a
3598   1A49 11            mov a, b
3599   1A4A FA 05 00      lea d, [bp + 5] ; $num
3600   1A4D 2A            mov b, [d]
3601   1A4E 38 00 00      mov c, 0
3602   1A51             ; --- START FACTORS
3603   1A51 D7            push a
3604   1A52 11            mov a, b
3605   1A53 FD 2E 0A 00   mov32 cb, $0000000a
3605   1A57 00 00 
3606   1A59 AE            div a, b ; 
3607   1A5A 11            mov a, b
3608   1A5B 27            mov b, a
3609   1A5C E4            pop a
3610   1A5D             ; --- END FACTORS
3611   1A5D 56            add b, a
3612   1A5E E4            pop a
3613   1A5F             ; --- END TERMS
3614   1A5F E7            pop d
3615   1A60 FD 3E         mov [d], bl
3616   1A62             ; num = num / 10; 
3617   1A62 FA 05 00      lea d, [bp + 5] ; $num
3618   1A65 DA            push d
3619   1A66 FA 05 00      lea d, [bp + 5] ; $num
3620   1A69 2A            mov b, [d]
3621   1A6A 38 00 00      mov c, 0
3622   1A6D             ; --- START FACTORS
3623   1A6D D7            push a
3624   1A6E 11            mov a, b
3625   1A6F FD 2E 0A 00   mov32 cb, $0000000a
3625   1A73 00 00 
3626   1A75 AE            div a, b
3627   1A76 27            mov b, a
3628   1A77 E4            pop a
3629   1A78             ; --- END FACTORS
3630   1A78 E7            pop d
3631   1A79 FD 43         mov [d], b
3632   1A7B             ; i++; 
3633   1A7B FA FA FF      lea d, [bp + -6] ; $i
3634   1A7E 2A            mov b, [d]
3635   1A7F 38 00 00      mov c, 0
3636   1A82 FD 77         inc b
3637   1A84 FA FA FF      lea d, [bp + -6] ; $i
3638   1A87 FD 43         mov [d], b
3639   1A89 FD 7D         dec b
3640   1A8B 0A 19 1A      jmp _while49_cond
3641   1A8E             _while49_exit:
3642   1A8E             ; while (i > 0) { 
3643   1A8E             _while50_cond:
3644   1A8E FA FA FF      lea d, [bp + -6] ; $i
3645   1A91 2A            mov b, [d]
3646   1A92 38 00 00      mov c, 0
3647   1A95             ; --- START RELATIONAL
3648   1A95 D7            push a
3649   1A96 11            mov a, b
3650   1A97 FD 2E 00 00   mov32 cb, $00000000
3650   1A9B 00 00 
3651   1A9D B0            cmp a, b
3652   1A9E FD 7F         sgt ; >
3653   1AA0 E4            pop a
3654   1AA1             ; --- END RELATIONAL
3655   1AA1 C0 00 00      cmp b, 0
3656   1AA4 C6 D6 1A      je _while50_exit
3657   1AA7             _while50_block:
3658   1AA7             ; i--; 
3659   1AA7 FA FA FF      lea d, [bp + -6] ; $i
3660   1AAA 2A            mov b, [d]
3661   1AAB 38 00 00      mov c, 0
3662   1AAE FD 7D         dec b
3663   1AB0 FA FA FF      lea d, [bp + -6] ; $i
3664   1AB3 FD 43         mov [d], b
3665   1AB5 FD 77         inc b
3666   1AB7             ; putchar(digits[i]); 
3667   1AB7             ; --- START FUNCTION CALL
3668   1AB7 FA FC FF      lea d, [bp + -4] ; $digits
3669   1ABA D7            push a
3670   1ABB DA            push d
3671   1ABC FA FA FF      lea d, [bp + -6] ; $i
3672   1ABF 2A            mov b, [d]
3673   1AC0 38 00 00      mov c, 0
3674   1AC3 E7            pop d
3675   1AC4 5A            add d, b
3676   1AC5 E4            pop a
3677   1AC6 32            mov bl, [d]
3678   1AC7 A7 00         mov bh, 0
3679   1AC9 38 00 00      mov c, 0
3680   1ACC DD            push bl
3681   1ACD 07 A0 1C      call putchar
3682   1AD0 51 01 00      add sp, 1
3683   1AD3             ; --- END FUNCTION CALL
3684   1AD3 0A 8E 1A      jmp _while50_cond
3685   1AD6             _while50_exit:
3686   1AD6 F9            leave
3687   1AD7 09            ret
3688   1AD8             
3689   1AD8             sprint_signed:
3690   1AD8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3691   1ADB             ; char digits[5]; 
3692   1ADB 52 05 00      sub sp, 5
3693   1ADE             ; int i = 0; 
3694   1ADE 52 02 00      sub sp, 2
3695   1AE1             ; --- START LOCAL VAR INITIALIZATION
3696   1AE1 FA FA FF      lea d, [bp + -6] ; $i
3697   1AE4 DA            push d
3698   1AE5 FD 2E 00 00   mov32 cb, $00000000
3698   1AE9 00 00 
3699   1AEB E7            pop d
3700   1AEC FD 43         mov [d], b
3701   1AEE             ; --- END LOCAL VAR INITIALIZATION
3702   1AEE             ; int len = 0; 
3703   1AEE 52 02 00      sub sp, 2
3704   1AF1             ; --- START LOCAL VAR INITIALIZATION
3705   1AF1 FA F8 FF      lea d, [bp + -8] ; $len
3706   1AF4 DA            push d
3707   1AF5 FD 2E 00 00   mov32 cb, $00000000
3707   1AF9 00 00 
3708   1AFB E7            pop d
3709   1AFC FD 43         mov [d], b
3710   1AFE             ; --- END LOCAL VAR INITIALIZATION
3711   1AFE             ; if (num < 0) { 
3712   1AFE             _if51_cond:
3713   1AFE FA 07 00      lea d, [bp + 7] ; $num
3714   1B01 2A            mov b, [d]
3715   1B02 38 00 00      mov c, 0
3716   1B05             ; --- START RELATIONAL
3717   1B05 D7            push a
3718   1B06 11            mov a, b
3719   1B07 FD 2E 00 00   mov32 cb, $00000000
3719   1B0B 00 00 
3720   1B0D B0            cmp a, b
3721   1B0E FD 73         slt ; < (signed)
3722   1B10 E4            pop a
3723   1B11             ; --- END RELATIONAL
3724   1B11 C0 00 00      cmp b, 0
3725   1B14 C6 54 1B      je _if51_else
3726   1B17             _if51_true:
3727   1B17             ; *dest++ = '-'; 
3728   1B17 FA 05 00      lea d, [bp + 5] ; $dest
3729   1B1A 2A            mov b, [d]
3730   1B1B 38 00 00      mov c, 0
3731   1B1E FD 77         inc b
3732   1B20 FA 05 00      lea d, [bp + 5] ; $dest
3733   1B23 FD 43         mov [d], b
3734   1B25 FD 7D         dec b
3735   1B27 D8            push b
3736   1B28 FD 2E 2D 00   mov32 cb, $0000002d
3736   1B2C 00 00 
3737   1B2E E7            pop d
3738   1B2F FD 3E         mov [d], bl
3739   1B31             ; num = -num; 
3740   1B31 FA 07 00      lea d, [bp + 7] ; $num
3741   1B34 DA            push d
3742   1B35 FA 07 00      lea d, [bp + 7] ; $num
3743   1B38 2A            mov b, [d]
3744   1B39 38 00 00      mov c, 0
3745   1B3C FD 97         neg b
3746   1B3E E7            pop d
3747   1B3F FD 43         mov [d], b
3748   1B41             ; len++; 
3749   1B41 FA F8 FF      lea d, [bp + -8] ; $len
3750   1B44 2A            mov b, [d]
3751   1B45 38 00 00      mov c, 0
3752   1B48 FD 77         inc b
3753   1B4A FA F8 FF      lea d, [bp + -8] ; $len
3754   1B4D FD 43         mov [d], b
3755   1B4F FD 7D         dec b
3756   1B51 0A A3 1B      jmp _if51_exit
3757   1B54             _if51_else:
3758   1B54             ; if (num == 0) { 
3759   1B54             _if52_cond:
3760   1B54 FA 07 00      lea d, [bp + 7] ; $num
3761   1B57 2A            mov b, [d]
3762   1B58 38 00 00      mov c, 0
3763   1B5B             ; --- START RELATIONAL
3764   1B5B D7            push a
3765   1B5C 11            mov a, b
3766   1B5D FD 2E 00 00   mov32 cb, $00000000
3766   1B61 00 00 
3767   1B63 B0            cmp a, b
3768   1B64 FD 71         seq ; ==
3769   1B66 E4            pop a
3770   1B67             ; --- END RELATIONAL
3771   1B67 C0 00 00      cmp b, 0
3772   1B6A C6 A3 1B      je _if52_exit
3773   1B6D             _if52_true:
3774   1B6D             ; *dest++ = '0'; 
3775   1B6D FA 05 00      lea d, [bp + 5] ; $dest
3776   1B70 2A            mov b, [d]
3777   1B71 38 00 00      mov c, 0
3778   1B74 FD 77         inc b
3779   1B76 FA 05 00      lea d, [bp + 5] ; $dest
3780   1B79 FD 43         mov [d], b
3781   1B7B FD 7D         dec b
3782   1B7D D8            push b
3783   1B7E FD 2E 30 00   mov32 cb, $00000030
3783   1B82 00 00 
3784   1B84 E7            pop d
3785   1B85 FD 3E         mov [d], bl
3786   1B87             ; *dest = '\0'; 
3787   1B87 FA 05 00      lea d, [bp + 5] ; $dest
3788   1B8A 2A            mov b, [d]
3789   1B8B 38 00 00      mov c, 0
3790   1B8E D8            push b
3791   1B8F FD 2E 00 00   mov32 cb, $00000000
3791   1B93 00 00 
3792   1B95 E7            pop d
3793   1B96 FD 3E         mov [d], bl
3794   1B98             ; return 1; 
3795   1B98 FD 2E 01 00   mov32 cb, $00000001
3795   1B9C 00 00 
3796   1B9E F9            leave
3797   1B9F 09            ret
3798   1BA0 0A A3 1B      jmp _if52_exit
3799   1BA3             _if52_exit:
3800   1BA3             _if51_exit:
3801   1BA3             ; while (num > 0) { 
3802   1BA3             _while53_cond:
3803   1BA3 FA 07 00      lea d, [bp + 7] ; $num
3804   1BA6 2A            mov b, [d]
3805   1BA7 38 00 00      mov c, 0
3806   1BAA             ; --- START RELATIONAL
3807   1BAA D7            push a
3808   1BAB 11            mov a, b
3809   1BAC FD 2E 00 00   mov32 cb, $00000000
3809   1BB0 00 00 
3810   1BB2 B0            cmp a, b
3811   1BB3 FD 7F         sgt ; >
3812   1BB5 E4            pop a
3813   1BB6             ; --- END RELATIONAL
3814   1BB6 C0 00 00      cmp b, 0
3815   1BB9 C6 18 1C      je _while53_exit
3816   1BBC             _while53_block:
3817   1BBC             ; digits[i] = '0' + (num % 10); 
3818   1BBC FA FC FF      lea d, [bp + -4] ; $digits
3819   1BBF D7            push a
3820   1BC0 DA            push d
3821   1BC1 FA FA FF      lea d, [bp + -6] ; $i
3822   1BC4 2A            mov b, [d]
3823   1BC5 38 00 00      mov c, 0
3824   1BC8 E7            pop d
3825   1BC9 5A            add d, b
3826   1BCA E4            pop a
3827   1BCB DA            push d
3828   1BCC FD 2E 30 00   mov32 cb, $00000030
3828   1BD0 00 00 
3829   1BD2             ; --- START TERMS
3830   1BD2 D7            push a
3831   1BD3 11            mov a, b
3832   1BD4 FA 07 00      lea d, [bp + 7] ; $num
3833   1BD7 2A            mov b, [d]
3834   1BD8 38 00 00      mov c, 0
3835   1BDB             ; --- START FACTORS
3836   1BDB D7            push a
3837   1BDC 11            mov a, b
3838   1BDD FD 2E 0A 00   mov32 cb, $0000000a
3838   1BE1 00 00 
3839   1BE3 AE            div a, b ; 
3840   1BE4 11            mov a, b
3841   1BE5 27            mov b, a
3842   1BE6 E4            pop a
3843   1BE7             ; --- END FACTORS
3844   1BE7 56            add b, a
3845   1BE8 E4            pop a
3846   1BE9             ; --- END TERMS
3847   1BE9 E7            pop d
3848   1BEA FD 3E         mov [d], bl
3849   1BEC             ; num = num / 10; 
3850   1BEC FA 07 00      lea d, [bp + 7] ; $num
3851   1BEF DA            push d
3852   1BF0 FA 07 00      lea d, [bp + 7] ; $num
3853   1BF3 2A            mov b, [d]
3854   1BF4 38 00 00      mov c, 0
3855   1BF7             ; --- START FACTORS
3856   1BF7 D7            push a
3857   1BF8 11            mov a, b
3858   1BF9 FD 2E 0A 00   mov32 cb, $0000000a
3858   1BFD 00 00 
3859   1BFF AE            div a, b
3860   1C00 27            mov b, a
3861   1C01 E4            pop a
3862   1C02             ; --- END FACTORS
3863   1C02 E7            pop d
3864   1C03 FD 43         mov [d], b
3865   1C05             ; i++; 
3866   1C05 FA FA FF      lea d, [bp + -6] ; $i
3867   1C08 2A            mov b, [d]
3868   1C09 38 00 00      mov c, 0
3869   1C0C FD 77         inc b
3870   1C0E FA FA FF      lea d, [bp + -6] ; $i
3871   1C11 FD 43         mov [d], b
3872   1C13 FD 7D         dec b
3873   1C15 0A A3 1B      jmp _while53_cond
3874   1C18             _while53_exit:
3875   1C18             ; while (i > 0) { 
3876   1C18             _while54_cond:
3877   1C18 FA FA FF      lea d, [bp + -6] ; $i
3878   1C1B 2A            mov b, [d]
3879   1C1C 38 00 00      mov c, 0
3880   1C1F             ; --- START RELATIONAL
3881   1C1F D7            push a
3882   1C20 11            mov a, b
3883   1C21 FD 2E 00 00   mov32 cb, $00000000
3883   1C25 00 00 
3884   1C27 B0            cmp a, b
3885   1C28 FD 7F         sgt ; >
3886   1C2A E4            pop a
3887   1C2B             ; --- END RELATIONAL
3888   1C2B C0 00 00      cmp b, 0
3889   1C2E C6 7D 1C      je _while54_exit
3890   1C31             _while54_block:
3891   1C31             ; i--; 
3892   1C31 FA FA FF      lea d, [bp + -6] ; $i
3893   1C34 2A            mov b, [d]
3894   1C35 38 00 00      mov c, 0
3895   1C38 FD 7D         dec b
3896   1C3A FA FA FF      lea d, [bp + -6] ; $i
3897   1C3D FD 43         mov [d], b
3898   1C3F FD 77         inc b
3899   1C41             ; *dest++ = digits[i]; 
3900   1C41 FA 05 00      lea d, [bp + 5] ; $dest
3901   1C44 2A            mov b, [d]
3902   1C45 38 00 00      mov c, 0
3903   1C48 FD 77         inc b
3904   1C4A FA 05 00      lea d, [bp + 5] ; $dest
3905   1C4D FD 43         mov [d], b
3906   1C4F FD 7D         dec b
3907   1C51 D8            push b
3908   1C52 FA FC FF      lea d, [bp + -4] ; $digits
3909   1C55 D7            push a
3910   1C56 DA            push d
3911   1C57 FA FA FF      lea d, [bp + -6] ; $i
3912   1C5A 2A            mov b, [d]
3913   1C5B 38 00 00      mov c, 0
3914   1C5E E7            pop d
3915   1C5F 5A            add d, b
3916   1C60 E4            pop a
3917   1C61 32            mov bl, [d]
3918   1C62 A7 00         mov bh, 0
3919   1C64 38 00 00      mov c, 0
3920   1C67 E7            pop d
3921   1C68 FD 3E         mov [d], bl
3922   1C6A             ; len++; 
3923   1C6A FA F8 FF      lea d, [bp + -8] ; $len
3924   1C6D 2A            mov b, [d]
3925   1C6E 38 00 00      mov c, 0
3926   1C71 FD 77         inc b
3927   1C73 FA F8 FF      lea d, [bp + -8] ; $len
3928   1C76 FD 43         mov [d], b
3929   1C78 FD 7D         dec b
3930   1C7A 0A 18 1C      jmp _while54_cond
3931   1C7D             _while54_exit:
3932   1C7D             ; *dest = '\0'; 
3933   1C7D FA 05 00      lea d, [bp + 5] ; $dest
3934   1C80 2A            mov b, [d]
3935   1C81 38 00 00      mov c, 0
3936   1C84 D8            push b
3937   1C85 FD 2E 00 00   mov32 cb, $00000000
3937   1C89 00 00 
3938   1C8B E7            pop d
3939   1C8C FD 3E         mov [d], bl
3940   1C8E             ; return len; 
3941   1C8E FA F8 FF      lea d, [bp + -8] ; $len
3942   1C91 2A            mov b, [d]
3943   1C92 38 00 00      mov c, 0
3944   1C95 F9            leave
3945   1C96 09            ret
3946   1C97             
3947   1C97             date:
3948   1C97 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3949   1C9A             
3950   1C9A             ; --- BEGIN INLINE ASM SEGMENT
3951   1C9A 19 00         mov al, 0 
3952   1C9C 05 07         syscall sys_datetime
3953   1C9E             ; --- END INLINE ASM SEGMENT
3954   1C9E             
3955   1C9E F9            leave
3956   1C9F 09            ret
3957   1CA0             
3958   1CA0             putchar:
3959   1CA0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3960   1CA3             
3961   1CA3             ; --- BEGIN INLINE ASM SEGMENT
3962   1CA3 FA 05 00      lea d, [bp + 5] ; $c
3963   1CA6 1E            mov al, [d]
3964   1CA7 23            mov ah, al
3965   1CA8 07 AF 1E      call _putchar
3966   1CAB             ; --- END INLINE ASM SEGMENT
3967   1CAB             
3968   1CAB F9            leave
3969   1CAC 09            ret
3970   1CAD             
3971   1CAD             getchar:
3972   1CAD F8 00 00      enter 0 ; (push bp; mov bp, sp)
3973   1CB0             ; char c; 
3974   1CB0 52 01 00      sub sp, 1
3975   1CB3             
3976   1CB3             ; --- BEGIN INLINE ASM SEGMENT
3977   1CB3 07 A8 1E      call getch
3978   1CB6 1A            mov al, ah
3979   1CB7 FA 00 00      lea d, [bp + 0] ; $c
3980   1CBA 3E            mov [d], al
3981   1CBB             ; --- END INLINE ASM SEGMENT
3982   1CBB             
3983   1CBB             ; return c; 
3984   1CBB FA 00 00      lea d, [bp + 0] ; $c
3985   1CBE 32            mov bl, [d]
3986   1CBF A7 00         mov bh, 0
3987   1CC1 38 00 00      mov c, 0
3988   1CC4 F9            leave
3989   1CC5 09            ret
3990   1CC6             
3991   1CC6             scann:
3992   1CC6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
3993   1CC9             ; int m; 
3994   1CC9 52 02 00      sub sp, 2
3995   1CCC             
3996   1CCC             ; --- BEGIN INLINE ASM SEGMENT
3997   1CCC 07 F3 20      call scan_u16d
3998   1CCF FA FF FF      lea d, [bp + -1] ; $m
3999   1CD2 43            mov [d], a
4000   1CD3             ; --- END INLINE ASM SEGMENT
4001   1CD3             
4002   1CD3             ; return m; 
4003   1CD3 FA FF FF      lea d, [bp + -1] ; $m
4004   1CD6 2A            mov b, [d]
4005   1CD7 38 00 00      mov c, 0
4006   1CDA F9            leave
4007   1CDB 09            ret
4008   1CDC             
4009   1CDC             puts:
4010   1CDC F8 00 00      enter 0 ; (push bp; mov bp, sp)
4011   1CDF             
4012   1CDF             ; --- BEGIN INLINE ASM SEGMENT
4013   1CDF FA 05 00      lea d, [bp + 5] ; $s
4014   1CE2 15            mov a, [d]
4015   1CE3 3C            mov d, a
4016   1CE4 07 F9 1F      call _puts
4017   1CE7 10 00 0A      mov a, $0A00
4018   1CEA 05 03         syscall sys_io
4019   1CEC             ; --- END INLINE ASM SEGMENT
4020   1CEC             
4021   1CEC F9            leave
4022   1CED 09            ret
4023   1CEE             
4024   1CEE             print:
4025   1CEE F8 00 00      enter 0 ; (push bp; mov bp, sp)
4026   1CF1             
4027   1CF1             ; --- BEGIN INLINE ASM SEGMENT
4028   1CF1 FA 05 00      lea d, [bp + 5] ; $s
4029   1CF4 FD 2A         mov d, [d]
4030   1CF6 07 F9 1F      call _puts
4031   1CF9             ; --- END INLINE ASM SEGMENT
4032   1CF9             
4033   1CF9 F9            leave
4034   1CFA 09            ret
4035   1CFB             
4036   1CFB             getparam:
4037   1CFB F8 00 00      enter 0 ; (push bp; mov bp, sp)
4038   1CFE             ; char data; 
4039   1CFE 52 01 00      sub sp, 1
4040   1D01             
4041   1D01             ; --- BEGIN INLINE ASM SEGMENT
4042   1D01 19 04         mov al, 4
4043   1D03 FA 05 00      lea d, [bp + 5] ; $address
4044   1D06 FD 2A         mov d, [d]
4045   1D08 05 0C         syscall sys_system
4046   1D0A FA 00 00      lea d, [bp + 0] ; $data
4047   1D0D FD 3E         mov [d], bl
4048   1D0F             ; --- END INLINE ASM SEGMENT
4049   1D0F             
4050   1D0F             ; return data; 
4051   1D0F FA 00 00      lea d, [bp + 0] ; $data
4052   1D12 32            mov bl, [d]
4053   1D13 A7 00         mov bh, 0
4054   1D15 38 00 00      mov c, 0
4055   1D18 F9            leave
4056   1D19 09            ret
4057   1D1A             
4058   1D1A             clear:
4059   1D1A F8 00 00      enter 0 ; (push bp; mov bp, sp)
4060   1D1D             ; print("\033[2J\033[H"); 
4061   1D1D             ; --- START FUNCTION CALL
4062   1D1D 26 93 21      mov b, _s2 ; "\033[2J\033[H"
4063   1D20 FD AB         swp b
4064   1D22 D8            push b
4065   1D23 07 EE 1C      call print
4066   1D26 51 02 00      add sp, 2
4067   1D29             ; --- END FUNCTION CALL
4068   1D29 F9            leave
4069   1D2A 09            ret
4070   1D2B             
4071   1D2B             abs:
4072   1D2B F8 00 00      enter 0 ; (push bp; mov bp, sp)
4073   1D2E             ; return i < 0 ? -i : i; 
4074   1D2E             _ternary55_cond:
4075   1D2E FA 05 00      lea d, [bp + 5] ; $i
4076   1D31 2A            mov b, [d]
4077   1D32 38 00 00      mov c, 0
4078   1D35             ; --- START RELATIONAL
4079   1D35 D7            push a
4080   1D36 11            mov a, b
4081   1D37 FD 2E 00 00   mov32 cb, $00000000
4081   1D3B 00 00 
4082   1D3D B0            cmp a, b
4083   1D3E FD 73         slt ; < (signed)
4084   1D40 E4            pop a
4085   1D41             ; --- END RELATIONAL
4086   1D41 C0 00 00      cmp b, 0
4087   1D44 C6 53 1D      je _ternary55_false
4088   1D47             _ternary55_true:
4089   1D47 FA 05 00      lea d, [bp + 5] ; $i
4090   1D4A 2A            mov b, [d]
4091   1D4B 38 00 00      mov c, 0
4092   1D4E FD 97         neg b
4093   1D50 0A 5A 1D      jmp _ternary55_exit
4094   1D53             _ternary55_false:
4095   1D53 FA 05 00      lea d, [bp + 5] ; $i
4096   1D56 2A            mov b, [d]
4097   1D57 38 00 00      mov c, 0
4098   1D5A             _ternary55_exit:
4099   1D5A F9            leave
4100   1D5B 09            ret
4101   1D5C             
4102   1D5C             loadfile:
4103   1D5C F8 00 00      enter 0 ; (push bp; mov bp, sp)
4104   1D5F             
4105   1D5F             ; --- BEGIN INLINE ASM SEGMENT
4106   1D5F FA 07 00      lea d, [bp + 7] ; $destination
4107   1D62 15            mov a, [d]
4108   1D63 4F            mov di, a
4109   1D64 FA 05 00      lea d, [bp + 5] ; $filename
4110   1D67 FD 2A         mov d, [d]
4111   1D69 19 14         mov al, 20
4112   1D6B 05 04         syscall sys_filesystem
4113   1D6D             ; --- END INLINE ASM SEGMENT
4114   1D6D             
4115   1D6D F9            leave
4116   1D6E 09            ret
4117   1D6F             
4118   1D6F             create_file:
4119   1D6F F8 00 00      enter 0 ; (push bp; mov bp, sp)
4120   1D72 F9            leave
4121   1D73 09            ret
4122   1D74             
4123   1D74             delete_file:
4124   1D74 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4125   1D77             
4126   1D77             ; --- BEGIN INLINE ASM SEGMENT
4127   1D77 FA 05 00      lea d, [bp + 5] ; $filename
4128   1D7A 19 0A         mov al, 10
4129   1D7C 05 04         syscall sys_filesystem
4130   1D7E             ; --- END INLINE ASM SEGMENT
4131   1D7E             
4132   1D7E F9            leave
4133   1D7F 09            ret
4134   1D80             
4135   1D80             load_hex:
4136   1D80 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4137   1D83             ; char *temp; 
4138   1D83 52 02 00      sub sp, 2
4139   1D86             ; temp = alloc(32768); 
4140   1D86 FA FF FF      lea d, [bp + -1] ; $temp
4141   1D89 DA            push d
4142   1D8A             ; --- START FUNCTION CALL
4143   1D8A FD 2E 00 80   mov32 cb, $00008000
4143   1D8E 00 00 
4144   1D90 FD AB         swp b
4145   1D92 D8            push b
4146   1D93 07 5F 08      call alloc
4147   1D96 51 02 00      add sp, 2
4148   1D99             ; --- END FUNCTION CALL
4149   1D99 E7            pop d
4150   1D9A FD 43         mov [d], b
4151   1D9C             
4152   1D9C             ; --- BEGIN INLINE ASM SEGMENT
4153   1D9C               
4154   1D9C               
4155   1D9C               
4156   1D9C             _load_hex:
4157   1D9C FA 05 00      lea d, [bp + 5] ; $destination
4158   1D9F FD 2A         mov d, [d]
4159   1DA1 FD 50         mov di, d
4160   1DA3 FA FF FF      lea d, [bp + -1] ; $temp
4161   1DA6 FD 2A         mov d, [d]
4162   1DA8 38 00 00      mov c, 0
4163   1DAB 48            mov a, sp
4164   1DAC 77            inc a
4165   1DAD 3C            mov d, a          
4166   1DAE 07 B6 1E      call _gets        
4167   1DB1 4D            mov si, a
4168   1DB2             __load_hex_loop:
4169   1DB2 F6            lodsb             
4170   1DB3 B9 00         cmp al, 0         
4171   1DB5 C6 C3 1D      jz __load_hex_ret
4172   1DB8 36            mov bh, al
4173   1DB9 F6            lodsb
4174   1DBA 2F            mov bl, al
4175   1DBB 07 6D 1E      call _atoi        
4176   1DBE F7            stosb             
4177   1DBF 78            inc c
4178   1DC0 0A B2 1D      jmp __load_hex_loop
4179   1DC3             __load_hex_ret:
4180   1DC3             ; --- END INLINE ASM SEGMENT
4181   1DC3             
4182   1DC3 F9            leave
4183   1DC4 09            ret
4184   1DC5             
4185   1DC5             include_stdio_asm:
4186   1DC5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
4187   1DC8             
4188   1DC8             ; --- BEGIN INLINE ASM SEGMENT
4189   1DC8             .include "lib/asm/stdio.asm"
0001+  1DC8             ;-----------------------------------------------------------------------------
0002+  1DC8             ; stdio.s
0003+  1DC8             ;-----------------------------------------------------------------------------
0004+  1DC8             .include "lib/asm/string.asm"
0001++ 1DC8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 1DC8             ; string.s
0003++ 1DC8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 1DC8             
0005++ 1DC8             
0006++ 1DC8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 1DC8             ; _strrev
0008++ 1DC8             ; reverse a string
0009++ 1DC8             ; D = string address
0010++ 1DC8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 1DC8             ; 01234
0012++ 1DC8             _strrev:
0013++ 1DC8 4B          	pusha
0014++ 1DC9 07 0F 1E    	call _strlen	; length in C
0015++ 1DCC 12          	mov a, c
0016++ 1DCD AF 01 00    	cmp a, 1
0017++ 1DD0 D0 EA 1D    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 1DD3 7D          	dec a
0019++ 1DD4 FD 4E       	mov si, d	; beginning of string
0020++ 1DD6 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 1DD8 59          	add d, a	; end of string
0022++ 1DD9 12          	mov a, c
0023++ 1DDA FD 9B       	shr a		; divide by 2
0024++ 1DDC 39          	mov c, a	; C now counts the steps
0025++ 1DDD             _strrev_L0:
0026++ 1DDD 32          	mov bl, [d]	; save load right-side char into BL
0027++ 1DDE F6          	lodsb		; load left-side char into AL; increase SI
0028++ 1DDF 3E          	mov [d], al	; store left char into right side
0029++ 1DE0 1B          	mov al, bl
0030++ 1DE1 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 1DE2 7E          	dec c
0032++ 1DE3 7F          	dec d
0033++ 1DE4 C2 00 00    	cmp c, 0
0034++ 1DE7 C7 DD 1D    	jne _strrev_L0
0035++ 1DEA             _strrev_end:
0036++ 1DEA 4C          	popa
0037++ 1DEB 09          	ret
0038++ 1DEC             	
0039++ 1DEC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 1DEC             ; _strchr
0041++ 1DEC             ; search string in D for char in AL
0042++ 1DEC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 1DEC             _strchr:
0044++ 1DEC             _strchr_L0:
0045++ 1DEC 32          	mov bl, [d]
0046++ 1DED C1 00       	cmp bl, 0
0047++ 1DEF C6 FA 1D    	je _strchr_end
0048++ 1DF2 BA          	cmp al, bl
0049++ 1DF3 C6 FA 1D    	je _strchr_end
0050++ 1DF6 79          	inc d
0051++ 1DF7 0A EC 1D    	jmp _strchr_L0
0052++ 1DFA             _strchr_end:
0053++ 1DFA 1B          	mov al, bl
0054++ 1DFB 09          	ret
0055++ 1DFC             
0056++ 1DFC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 1DFC             ; _strstr
0058++ 1DFC             ; find sub-string
0059++ 1DFC             ; str1 in SI
0060++ 1DFC             ; str2 in DI
0061++ 1DFC             ; SI points to end of source string
0062++ 1DFC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 1DFC             _strstr:
0064++ 1DFC DB          	push al
0065++ 1DFD DA          	push d
0066++ 1DFE E3          	push di
0067++ 1DFF             _strstr_loop:
0068++ 1DFF F3          	cmpsb					; compare a byte of the strings
0069++ 1E00 C7 0B 1E    	jne _strstr_ret
0070++ 1E03 FC 00 00    	lea d, [di + 0]
0071++ 1E06 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1E08 C7 FF 1D    	jne _strstr_loop				; equal chars but not at end
0073++ 1E0B             _strstr_ret:
0074++ 1E0B F0          	pop di
0075++ 1E0C E7          	pop d
0076++ 1E0D E8          	pop al
0077++ 1E0E 09          	ret
0078++ 1E0F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1E0F             ; length of null terminated string
0080++ 1E0F             ; result in C
0081++ 1E0F             ; pointer in D
0082++ 1E0F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1E0F             _strlen:
0084++ 1E0F DA          	push d
0085++ 1E10 38 00 00    	mov c, 0
0086++ 1E13             _strlen_L1:
0087++ 1E13 BD 00       	cmp byte [d], 0
0088++ 1E15 C6 1D 1E    	je _strlen_ret
0089++ 1E18 79          	inc d
0090++ 1E19 78          	inc c
0091++ 1E1A 0A 13 1E    	jmp _strlen_L1
0092++ 1E1D             _strlen_ret:
0093++ 1E1D E7          	pop d
0094++ 1E1E 09          	ret
0095++ 1E1F             
0096++ 1E1F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1E1F             ; STRCMP
0098++ 1E1F             ; compare two strings
0099++ 1E1F             ; str1 in SI
0100++ 1E1F             ; str2 in DI
0101++ 1E1F             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 1E1F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1E1F             _strcmp:
0104++ 1E1F DB          	push al
0105++ 1E20 DA          	push d
0106++ 1E21 E3          	push di
0107++ 1E22 E2          	push si
0108++ 1E23             _strcmp_loop:
0109++ 1E23 F3          	cmpsb					; compare a byte of the strings
0110++ 1E24 C7 2F 1E    	jne _strcmp_ret
0111++ 1E27 FB FF FF    	lea d, [si +- 1]
0112++ 1E2A BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1E2C C7 23 1E    	jne _strcmp_loop				; equal chars but not at end
0114++ 1E2F             _strcmp_ret:
0115++ 1E2F EF          	pop si
0116++ 1E30 F0          	pop di
0117++ 1E31 E7          	pop d
0118++ 1E32 E8          	pop al
0119++ 1E33 09          	ret
0120++ 1E34             
0121++ 1E34             
0122++ 1E34             ; STRCPY
0123++ 1E34             ; copy null terminated string from SI to DI
0124++ 1E34             ; source in SI
0125++ 1E34             ; destination in DI
0126++ 1E34             _strcpy:
0127++ 1E34 E2          	push si
0128++ 1E35 E3          	push di
0129++ 1E36 DB          	push al
0130++ 1E37             _strcpy_L1:
0131++ 1E37 F6          	lodsb
0132++ 1E38 F7          	stosb
0133++ 1E39 B9 00       	cmp al, 0
0134++ 1E3B C7 37 1E    	jne _strcpy_L1
0135++ 1E3E             _strcpy_end:
0136++ 1E3E E8          	pop al
0137++ 1E3F F0          	pop di
0138++ 1E40 EF          	pop si
0139++ 1E41 09          	ret
0140++ 1E42             
0141++ 1E42             ; STRCAT
0142++ 1E42             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 1E42             ; source in SI
0144++ 1E42             ; destination in DI
0145++ 1E42             _strcat:
0146++ 1E42 E2          	push si
0147++ 1E43 E3          	push di
0148++ 1E44 D7          	push a
0149++ 1E45 DA          	push d
0150++ 1E46 50          	mov a, di
0151++ 1E47 3C          	mov d, a
0152++ 1E48             _strcat_goto_end_L1:
0153++ 1E48 BD 00       	cmp byte[d], 0
0154++ 1E4A C6 51 1E    	je _strcat_start
0155++ 1E4D 79          	inc d
0156++ 1E4E 0A 48 1E    	jmp _strcat_goto_end_L1
0157++ 1E51             _strcat_start:
0158++ 1E51 FD 50       	mov di, d
0159++ 1E53             _strcat_L1:
0160++ 1E53 F6          	lodsb
0161++ 1E54 F7          	stosb
0162++ 1E55 B9 00       	cmp al, 0
0163++ 1E57 C7 53 1E    	jne _strcat_L1
0164++ 1E5A             _strcat_end:
0165++ 1E5A E7          	pop d
0166++ 1E5B E4          	pop a
0167++ 1E5C F0          	pop di
0168++ 1E5D EF          	pop si
0169++ 1E5E 09          	ret
0170++ 1E5F             
0171++ 1E5F             
0005+  1E5F             
0006+  1E5F             ;-----------------------------------------------------------------------------
0007+  1E5F             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0008+  1E5F             ; ASCII in BL
0009+  1E5F             ; result in AL
0010+  1E5F             ; ascii for F = 0100 0110
0011+  1E5F             ; ascii for 9 = 0011 1001
0012+  1E5F             ;-----------------------------------------------------------------------------
0013+  1E5F             hex_ascii_encode:
0014+  1E5F 1B            mov al, bl
0015+  1E60 93 40         test al, $40        ; test if letter or number
0016+  1E62 C7 68 1E      jnz hex_letter
0017+  1E65 87 0F         and al, $0F        ; get number
0018+  1E67 09            ret
0019+  1E68             hex_letter:
0020+  1E68 87 0F         and al, $0F        ; get letter
0021+  1E6A 6A 09         add al, 9
0022+  1E6C 09            ret
0023+  1E6D             
0024+  1E6D             ;-----------------------------------------------------------------------------
0025+  1E6D             ; ATOI
0026+  1E6D             ; 2 letter hex string in B
0027+  1E6D             ; 8bit integer returned in AL
0028+  1E6D             ;-----------------------------------------------------------------------------
0029+  1E6D             _atoi:
0030+  1E6D D8            push b
0031+  1E6E 07 5F 1E      call hex_ascii_encode      ; convert BL to 4bit code in AL
0032+  1E71 30            mov bl, bh
0033+  1E72 DB            push al          ; save a
0034+  1E73 07 5F 1E      call hex_ascii_encode
0035+  1E76 EA            pop bl  
0036+  1E77 FD 9E 04      shl al, 4
0037+  1E7A 8C            or al, bl
0038+  1E7B E5            pop b
0039+  1E7C 09            ret  
0040+  1E7D             
0041+  1E7D             
0042+  1E7D             ;-----------------------------------------------------------------------------
0043+  1E7D             ; ITOA
0044+  1E7D             ; 8bit value in BL
0045+  1E7D             ; 2 byte ASCII result in A
0046+  1E7D             ;-----------------------------------------------------------------------------
0047+  1E7D             _itoa:
0048+  1E7D DA            push d
0049+  1E7E D8            push b
0050+  1E7F A7 00         mov bh, 0
0051+  1E81 FD A4 04      shr bl, 4  
0052+  1E84 74            mov d, b
0053+  1E85 1F 2D 21      mov al, [d + s_hex_digits]
0054+  1E88 23            mov ah, al
0055+  1E89               
0056+  1E89 E5            pop b
0057+  1E8A D8            push b
0058+  1E8B A7 00         mov bh, 0
0059+  1E8D FD 87 0F      and bl, $0F
0060+  1E90 74            mov d, b
0061+  1E91 1F 2D 21      mov al, [d + s_hex_digits]
0062+  1E94 E5            pop b
0063+  1E95 E7            pop d
0064+  1E96 09            ret
0065+  1E97             
0066+  1E97             ;-----------------------------------------------------------------------------
0067+  1E97             ; HEX STRING TO BINARY
0068+  1E97             ; di = destination address
0069+  1E97             ; si = source
0070+  1E97             ;-----------------------------------------------------------------------------
0071+  1E97             _hex_to_int:
0072+  1E97             _hex_to_int_L1:
0073+  1E97 F6            lodsb          ; load from [SI] to AL
0074+  1E98 B9 00         cmp al, 0        ; check if ASCII 0
0075+  1E9A C6 A7 1E      jz _hex_to_int_ret
0076+  1E9D 36            mov bh, al
0077+  1E9E F6            lodsb
0078+  1E9F 2F            mov bl, al
0079+  1EA0 07 6D 1E      call _atoi        ; convert ASCII byte in B to int (to AL)
0080+  1EA3 F7            stosb          ; store AL to [DI]
0081+  1EA4 0A 97 1E      jmp _hex_to_int_L1
0082+  1EA7             _hex_to_int_ret:
0083+  1EA7 09            ret    
0084+  1EA8             
0085+  1EA8             ;-----------------------------------------------------------------------------
0086+  1EA8             ; GETCHAR
0087+  1EA8             ; char in ah
0088+  1EA8             ;-----------------------------------------------------------------------------
0089+  1EA8             getch:
0090+  1EA8 DB            push al
0091+  1EA9             getch_retry:
0092+  1EA9 19 01         mov al, 1
0093+  1EAB 05 03         syscall sys_io      ; receive in AH
0094+  1EAD E8            pop al
0095+  1EAE 09            ret
0096+  1EAF             
0097+  1EAF             ;-----------------------------------------------------------------------------
0098+  1EAF             ; PUTCHAR
0099+  1EAF             ; char in ah
0100+  1EAF             ;-----------------------------------------------------------------------------
0101+  1EAF             _putchar:
0102+  1EAF D7            push a
0103+  1EB0 19 00         mov al, 0
0104+  1EB2 05 03         syscall sys_io      ; char in AH
0105+  1EB4 E4            pop a
0106+  1EB5 09            ret
0107+  1EB6             
0108+  1EB6             ;-----------------------------------------------------------------------------
0109+  1EB6             ;; INPUT A STRING
0110+  1EB6             ;; terminates with null
0111+  1EB6             ;; pointer in D
0112+  1EB6             ;-----------------------------------------------------------------------------
0113+  1EB6             _gets:
0114+  1EB6 D7            push a
0115+  1EB7 DA            push d
0116+  1EB8             _gets_loop:
0117+  1EB8 19 01         mov al, 1
0118+  1EBA 05 03         syscall sys_io      ; receive in AH
0119+  1EBC B9 00         cmp al, 0        ; check error code (AL)
0120+  1EBE C6 B8 1E      je _gets_loop      ; if no char received, retry
0121+  1EC1             
0122+  1EC1 76 1B         cmp ah, 27
0123+  1EC3 C6 E4 1E      je _gets_ansi_esc
0124+  1EC6 76 0A         cmp ah, $0A        ; LF
0125+  1EC8 C6 4F 1F      je _gets_end
0126+  1ECB 76 0D         cmp ah, $0D        ; CR
0127+  1ECD C6 4F 1F      je _gets_end
0128+  1ED0 76 5C         cmp ah, $5C        ; '\\'
0129+  1ED2 C6 10 1F      je _gets_escape
0130+  1ED5               
0131+  1ED5 76 08         cmp ah, $08      ; check for backspace
0132+  1ED7 C6 E0 1E      je _gets_backspace
0133+  1EDA             
0134+  1EDA 1A            mov al, ah
0135+  1EDB 3E            mov [d], al
0136+  1EDC 79            inc d
0137+  1EDD 0A B8 1E      jmp _gets_loop
0138+  1EE0             _gets_backspace:
0139+  1EE0 7F            dec d
0140+  1EE1 0A B8 1E      jmp _gets_loop
0141+  1EE4             _gets_ansi_esc:
0142+  1EE4 19 01         mov al, 1
0143+  1EE6 05 03         syscall sys_io        ; receive in AH without echo
0144+  1EE8 B9 00         cmp al, 0          ; check error code (AL)
0145+  1EEA C6 E4 1E      je _gets_ansi_esc    ; if no char received, retry
0146+  1EED 76 5B         cmp ah, '['
0147+  1EEF C7 B8 1E      jne _gets_loop
0148+  1EF2             _gets_ansi_esc_2:
0149+  1EF2 19 01         mov al, 1
0150+  1EF4 05 03         syscall sys_io          ; receive in AH without echo
0151+  1EF6 B9 00         cmp al, 0            ; check error code (AL)
0152+  1EF8 C6 F2 1E      je _gets_ansi_esc_2  ; if no char received, retry
0153+  1EFB 76 44         cmp ah, 'D'
0154+  1EFD C6 08 1F      je _gets_left_arrow
0155+  1F00 76 43         cmp ah, 'C'
0156+  1F02 C6 0C 1F      je _gets_right_arrow
0157+  1F05 0A B8 1E      jmp _gets_loop
0158+  1F08             _gets_left_arrow:
0159+  1F08 7F            dec d
0160+  1F09 0A B8 1E      jmp _gets_loop
0161+  1F0C             _gets_right_arrow:
0162+  1F0C 79            inc d
0163+  1F0D 0A B8 1E      jmp _gets_loop
0164+  1F10             _gets_escape:
0165+  1F10 19 01         mov al, 1
0166+  1F12 05 03         syscall sys_io      ; receive in AH
0167+  1F14 B9 00         cmp al, 0        ; check error code (AL)
0168+  1F16 C6 10 1F      je _gets_escape      ; if no char received, retry
0169+  1F19 76 6E         cmp ah, 'n'
0170+  1F1B C6 3A 1F      je _gets_LF
0171+  1F1E 76 72         cmp ah, 'r'
0172+  1F20 C6 41 1F      je _gets_CR
0173+  1F23 76 30         cmp ah, '0'
0174+  1F25 C6 48 1F      je _gets_NULL
0175+  1F28 76 5C         cmp ah, $5C  ; '\'
0176+  1F2A C6 33 1F      je _gets_slash
0177+  1F2D 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0178+  1F2E 3E            mov [d], al
0179+  1F2F 79            inc d
0180+  1F30 0A B8 1E      jmp _gets_loop
0181+  1F33             _gets_slash:
0182+  1F33 19 5C         mov al, $5C
0183+  1F35 3E            mov [d], al
0184+  1F36 79            inc d
0185+  1F37 0A B8 1E      jmp _gets_loop
0186+  1F3A             _gets_LF:
0187+  1F3A 19 0A         mov al, $0A
0188+  1F3C 3E            mov [d], al
0189+  1F3D 79            inc d
0190+  1F3E 0A B8 1E      jmp _gets_loop
0191+  1F41             _gets_CR:
0192+  1F41 19 0D         mov al, $0D
0193+  1F43 3E            mov [d], al
0194+  1F44 79            inc d
0195+  1F45 0A B8 1E      jmp _gets_loop
0196+  1F48             _gets_NULL:
0197+  1F48 19 00         mov al, $00
0198+  1F4A 3E            mov [d], al
0199+  1F4B 79            inc d
0200+  1F4C 0A B8 1E      jmp _gets_loop
0201+  1F4F             _gets_end:
0202+  1F4F 19 00         mov al, 0
0203+  1F51 3E            mov [d], al        ; terminate string
0204+  1F52 E7            pop d
0205+  1F53 E4            pop a
0206+  1F54 09            ret
0207+  1F55             
0208+  1F55             ;-----------------------------------------------------------------------------
0209+  1F55             ;; INPUT TEXT
0210+  1F55             ;; terminated with CTRL+D
0211+  1F55             ;; pointer in D
0212+  1F55             ;-----------------------------------------------------------------------------
0213+  1F55             _gettxt:
0214+  1F55 D7            push a
0215+  1F56 DA            push d
0216+  1F57             _gettxt_loop:
0217+  1F57 19 01         mov al, 1
0218+  1F59 05 03         syscall sys_io      ; receive in AH
0219+  1F5B B9 00         cmp al, 0        ; check error code (AL)
0220+  1F5D C6 57 1F      je _gettxt_loop    ; if no char received, retry
0221+  1F60 76 04         cmp ah, 4      ; EOT
0222+  1F62 C6 A0 1F      je _gettxt_end
0223+  1F65 76 08         cmp ah, $08      ; check for backspace
0224+  1F67 C6 9C 1F      je _gettxt_backspace
0225+  1F6A 76 5C         cmp ah, $5C        ; '\'
0226+  1F6C C6 75 1F      je _gettxt_escape
0227+  1F6F 1A            mov al, ah
0228+  1F70 3E            mov [d], al
0229+  1F71 79            inc d
0230+  1F72 0A 57 1F      jmp _gettxt_loop
0231+  1F75             _gettxt_escape:
0232+  1F75 19 01         mov al, 1
0233+  1F77 05 03         syscall sys_io      ; receive in AH
0234+  1F79 B9 00         cmp al, 0        ; check error code (AL)
0235+  1F7B C6 75 1F      je _gettxt_escape    ; if no char received, retry
0236+  1F7E 76 6E         cmp ah, 'n'
0237+  1F80 C6 8E 1F      je _gettxt_LF
0238+  1F83 76 72         cmp ah, 'r'
0239+  1F85 C6 95 1F      je _gettxt_CR
0240+  1F88 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0241+  1F89 3E            mov [d], al
0242+  1F8A 79            inc d
0243+  1F8B 0A 57 1F      jmp _gettxt_loop
0244+  1F8E             _gettxt_LF:
0245+  1F8E 19 0A         mov al, $0A
0246+  1F90 3E            mov [d], al
0247+  1F91 79            inc d
0248+  1F92 0A 57 1F      jmp _gettxt_loop
0249+  1F95             _gettxt_CR:
0250+  1F95 19 0D         mov al, $0D
0251+  1F97 3E            mov [d], al
0252+  1F98 79            inc d
0253+  1F99 0A 57 1F      jmp _gettxt_loop
0254+  1F9C             _gettxt_backspace:
0255+  1F9C 7F            dec d
0256+  1F9D 0A 57 1F      jmp _gettxt_loop
0257+  1FA0             _gettxt_end:
0258+  1FA0 19 00         mov al, 0
0259+  1FA2 3E            mov [d], al        ; terminate string
0260+  1FA3 E7            pop d
0261+  1FA4 E4            pop a
0262+  1FA5 09            ret
0263+  1FA6             
0264+  1FA6             ;-----------------------------------------------------------------------------
0265+  1FA6             ; PRINT NEW LINE
0266+  1FA6             ;-----------------------------------------------------------------------------
0267+  1FA6             printnl:
0268+  1FA6 D7            push a
0269+  1FA7 10 00 0A      mov a, $0A00
0270+  1FAA 05 03         syscall sys_io
0271+  1FAC 10 00 0D      mov a, $0D00
0272+  1FAF 05 03         syscall sys_io
0273+  1FB1 E4            pop a
0274+  1FB2 09            ret
0275+  1FB3             
0276+  1FB3             ;-----------------------------------------------------------------------------
0277+  1FB3             ; _strtoint
0278+  1FB3             ; 4 digit hex string number in d
0279+  1FB3             ; integer returned in A
0280+  1FB3             ;-----------------------------------------------------------------------------
0281+  1FB3             _strtointx:
0282+  1FB3 D8            push b
0283+  1FB4 32            mov bl, [d]
0284+  1FB5 37            mov bh, bl
0285+  1FB6 33 01 00      mov bl, [d + 1]
0286+  1FB9 07 6D 1E      call _atoi        ; convert to int in AL
0287+  1FBC 23            mov ah, al        ; move to AH
0288+  1FBD 33 02 00      mov bl, [d + 2]
0289+  1FC0 37            mov bh, bl
0290+  1FC1 33 03 00      mov bl, [d + 3]
0291+  1FC4 07 6D 1E      call _atoi        ; convert to int in AL
0292+  1FC7 E5            pop b
0293+  1FC8 09            ret
0294+  1FC9             
0295+  1FC9             ;-----------------------------------------------------------------------------
0296+  1FC9             ; _strtoint
0297+  1FC9             ; 5 digit base10 string number in d
0298+  1FC9             ; integer returned in A
0299+  1FC9             ;-----------------------------------------------------------------------------
0300+  1FC9             _strtoint:
0301+  1FC9 E2            push si
0302+  1FCA D8            push b
0303+  1FCB D9            push c
0304+  1FCC DA            push d
0305+  1FCD 07 0F 1E      call _strlen      ; get string length in C
0306+  1FD0 7E            dec c
0307+  1FD1 FD 4E         mov si, d
0308+  1FD3 12            mov a, c
0309+  1FD4 FD 99         shl a
0310+  1FD6 3B 45 21      mov d, table_power
0311+  1FD9 59            add d, a
0312+  1FDA 38 00 00      mov c, 0
0313+  1FDD             _strtoint_L0:
0314+  1FDD F6            lodsb      ; load ASCII to al
0315+  1FDE B9 00         cmp al, 0
0316+  1FE0 C6 F3 1F      je _strtoint_end
0317+  1FE3 6F 30         sub al, $30    ; make into integer
0318+  1FE5 22 00         mov ah, 0
0319+  1FE7 2A            mov b, [d]
0320+  1FE8 AC            mul a, b      ; result in B since it fits in 16bits
0321+  1FE9 11            mov a, b
0322+  1FEA 28            mov b, c
0323+  1FEB 54            add a, b
0324+  1FEC 39            mov c, a
0325+  1FED 63 02 00      sub d, 2
0326+  1FF0 0A DD 1F      jmp _strtoint_L0
0327+  1FF3             _strtoint_end:
0328+  1FF3 12            mov a, c
0329+  1FF4 E7            pop d
0330+  1FF5 E6            pop c
0331+  1FF6 E5            pop b
0332+  1FF7 EF            pop si
0333+  1FF8 09            ret
0334+  1FF9             
0335+  1FF9             ;-----------------------------------------------------------------------------
0336+  1FF9             ; PRINT NULL TERMINATED STRING
0337+  1FF9             ; pointer in D
0338+  1FF9             ;-----------------------------------------------------------------------------
0339+  1FF9             _puts:
0340+  1FF9 D7            push a
0341+  1FFA DA            push d
0342+  1FFB             _puts_L1:
0343+  1FFB 1E            mov al, [d]
0344+  1FFC B9 00         cmp al, 0
0345+  1FFE C6 0A 20      jz _puts_END
0346+  2001 23            mov ah, al
0347+  2002 19 00         mov al, 0
0348+  2004 05 03         syscall sys_io
0349+  2006 79            inc d
0350+  2007 0A FB 1F      jmp _puts_L1
0351+  200A             _puts_END:
0352+  200A E7            pop d
0353+  200B E4            pop a
0354+  200C 09            ret
0355+  200D             
0356+  200D             ;-----------------------------------------------------------------------------
0357+  200D             ; PRINT N SIZE STRING
0358+  200D             ; pointer in D
0359+  200D             ; size in C
0360+  200D             ;-----------------------------------------------------------------------------
0361+  200D             _putsn:
0362+  200D DB            push al
0363+  200E DA            push d
0364+  200F D9            push c
0365+  2010             _putsn_L0:
0366+  2010 1E            mov al, [d]
0367+  2011 23            mov ah, al
0368+  2012 19 00         mov al, 0
0369+  2014 05 03         syscall sys_io
0370+  2016 79            inc d
0371+  2017 7E            dec c  
0372+  2018 C2 00 00      cmp c, 0
0373+  201B C7 10 20      jne _putsn_L0
0374+  201E             _putsn_end:
0375+  201E E6            pop c
0376+  201F E7            pop d
0377+  2020 E8            pop al
0378+  2021 09            ret
0379+  2022             
0380+  2022             ;-----------------------------------------------------------------------------
0381+  2022             ; print 16bit decimal number
0382+  2022             ; input number in A
0383+  2022             ;-----------------------------------------------------------------------------
0384+  2022             print_u16d:
0385+  2022 D7            push a
0386+  2023 D8            push b
0387+  2024 26 10 27      mov b, 10000
0388+  2027 AE            div a, b      ; get 10000's coeff.
0389+  2028 07 4A 20      call print_number
0390+  202B 11            mov a, b
0391+  202C 26 E8 03      mov b, 1000
0392+  202F AE            div a, b      ; get 1000's coeff.
0393+  2030 07 4A 20      call print_number
0394+  2033 11            mov a, b
0395+  2034 26 64 00      mov b, 100
0396+  2037 AE            div a, b
0397+  2038 07 4A 20      call print_number
0398+  203B 11            mov a, b
0399+  203C 26 0A 00      mov b, 10
0400+  203F AE            div a, b
0401+  2040 07 4A 20      call print_number
0402+  2043 1B            mov al, bl      ; 1's coeff in bl
0403+  2044 07 4A 20      call print_number
0404+  2047 E5            pop b
0405+  2048 E4            pop a
0406+  2049 09            ret
0407+  204A             
0408+  204A             ;-----------------------------------------------------------------------------
0409+  204A             ; print AL
0410+  204A             ;-----------------------------------------------------------------------------
0411+  204A             print_number:
0412+  204A 6A 30         add al, $30
0413+  204C 23            mov ah, al
0414+  204D 07 AF 1E      call _putchar
0415+  2050 09            ret
0416+  2051             
0417+  2051             ;-----------------------------------------------------------------------------
0418+  2051             ; PRINT 16BIT HEX INTEGER
0419+  2051             ; integer value in reg B
0420+  2051             ;-----------------------------------------------------------------------------
0421+  2051             print_u16x:
0422+  2051 D7            push a
0423+  2052 D8            push b
0424+  2053 DD            push bl
0425+  2054 30            mov bl, bh
0426+  2055 07 7D 1E      call _itoa        ; convert bh to char in A
0427+  2058 2F            mov bl, al        ; save al
0428+  2059 19 00         mov al, 0
0429+  205B 05 03         syscall sys_io        ; display AH
0430+  205D 24            mov ah, bl        ; retrieve al
0431+  205E 19 00         mov al, 0
0432+  2060 05 03         syscall sys_io        ; display AL
0433+  2062             
0434+  2062 EA            pop bl
0435+  2063 07 7D 1E      call _itoa        ; convert bh to char in A
0436+  2066 2F            mov bl, al        ; save al
0437+  2067 19 00         mov al, 0
0438+  2069 05 03         syscall sys_io        ; display AH
0439+  206B 24            mov ah, bl        ; retrieve al
0440+  206C 19 00         mov al, 0
0441+  206E 05 03         syscall sys_io        ; display AL
0442+  2070             
0443+  2070 E5            pop b
0444+  2071 E4            pop a
0445+  2072 09            ret
0446+  2073             
0447+  2073             ;-----------------------------------------------------------------------------
0448+  2073             ; INPUT 16BIT HEX INTEGER
0449+  2073             ; read 16bit integer into A
0450+  2073             ;-----------------------------------------------------------------------------
0451+  2073             scan_u16x:
0452+  2073 F8 10 00      enter 16
0453+  2076 D8            push b
0454+  2077 DA            push d
0455+  2078             
0456+  2078 FA F1 FF      lea d, [bp + -15]
0457+  207B 07 B6 1E      call _gets        ; get number
0458+  207E             
0459+  207E 32            mov bl, [d]
0460+  207F 37            mov bh, bl
0461+  2080 33 01 00      mov bl, [d + 1]
0462+  2083 07 6D 1E      call _atoi        ; convert to int in AL
0463+  2086 23            mov ah, al        ; move to AH
0464+  2087             
0465+  2087 33 02 00      mov bl, [d + 2]
0466+  208A 37            mov bh, bl
0467+  208B 33 03 00      mov bl, [d + 3]
0468+  208E 07 6D 1E      call _atoi        ; convert to int in AL
0469+  2091             
0470+  2091 E7            pop d
0471+  2092 E5            pop b
0472+  2093 F9            leave
0473+  2094 09            ret
0474+  2095             
0475+  2095             ;-----------------------------------------------------------------------------
0476+  2095             ; PRINT 8bit HEX INTEGER
0477+  2095             ; integer value in reg bl
0478+  2095             ;-----------------------------------------------------------------------------
0479+  2095             print_u8x:
0480+  2095 D7            push a
0481+  2096 DD            push bl
0482+  2097             
0483+  2097 07 7D 1E      call _itoa        ; convert bl to char in A
0484+  209A 2F            mov bl, al        ; save al
0485+  209B 19 00         mov al, 0
0486+  209D 05 03         syscall sys_io        ; display AH
0487+  209F 24            mov ah, bl        ; retrieve al
0488+  20A0 19 00         mov al, 0
0489+  20A2 05 03         syscall sys_io        ; display AL
0490+  20A4             
0491+  20A4 EA            pop bl
0492+  20A5 E4            pop a
0493+  20A6 09            ret
0494+  20A7             
0495+  20A7             ;-----------------------------------------------------------------------------
0496+  20A7             ; print 8bit decimal unsigned number
0497+  20A7             ; input number in AL
0498+  20A7             ;-----------------------------------------------------------------------------
0499+  20A7             print_u8d:
0500+  20A7 D7            push a
0501+  20A8 D8            push b
0502+  20A9             
0503+  20A9 22 00         mov ah, 0
0504+  20AB 26 64 00      mov b, 100
0505+  20AE AE            div a, b
0506+  20AF D8            push b      ; save remainder
0507+  20B0 B9 00         cmp al, 0
0508+  20B2 C6 BC 20      je skip100
0509+  20B5 6A 30         add al, $30
0510+  20B7 23            mov ah, al
0511+  20B8 19 00         mov al, 0
0512+  20BA 05 03         syscall sys_io  ; print coeff
0513+  20BC             skip100:
0514+  20BC E4            pop a
0515+  20BD 22 00         mov ah, 0
0516+  20BF 26 0A 00      mov b, 10
0517+  20C2 AE            div a, b
0518+  20C3 D8            push b      ; save remainder
0519+  20C4 B9 00         cmp al, 0
0520+  20C6 C6 D0 20      je skip10
0521+  20C9 6A 30         add al, $30
0522+  20CB 23            mov ah, al
0523+  20CC 19 00         mov al, 0
0524+  20CE 05 03         syscall sys_io  ; print coeff
0525+  20D0             skip10:
0526+  20D0 E4            pop a
0527+  20D1 1B            mov al, bl
0528+  20D2 6A 30         add al, $30
0529+  20D4 23            mov ah, al
0530+  20D5 19 00         mov al, 0
0531+  20D7 05 03         syscall sys_io  ; print coeff
0532+  20D9 E5            pop b
0533+  20DA E4            pop a
0534+  20DB 09            ret
0535+  20DC             
0536+  20DC             ;-----------------------------------------------------------------------------
0537+  20DC             ; INPUT 8BIT HEX INTEGER
0538+  20DC             ; read 8bit integer into AL
0539+  20DC             ;-----------------------------------------------------------------------------
0540+  20DC             scan_u8x:
0541+  20DC F8 04 00      enter 4
0542+  20DF D8            push b
0543+  20E0 DA            push d
0544+  20E1             
0545+  20E1 FA FD FF      lea d, [bp + -3]
0546+  20E4 07 B6 1E      call _gets        ; get number
0547+  20E7             
0548+  20E7 32            mov bl, [d]
0549+  20E8 37            mov bh, bl
0550+  20E9 33 01 00      mov bl, [d + 1]
0551+  20EC 07 6D 1E      call _atoi        ; convert to int in AL
0552+  20EF             
0553+  20EF E7            pop d
0554+  20F0 E5            pop b
0555+  20F1 F9            leave
0556+  20F2 09            ret
0557+  20F3             
0558+  20F3             ;-----------------------------------------------------------------------------
0559+  20F3             ; input decimal number
0560+  20F3             ; result in A
0561+  20F3             ; 655'\0'
0562+  20F3             ; low--------high
0563+  20F3             ;-----------------------------------------------------------------------------
0564+  20F3             scan_u16d:
0565+  20F3 F8 08 00      enter 8
0566+  20F6 E2            push si
0567+  20F7 D8            push b
0568+  20F8 D9            push c
0569+  20F9 DA            push d
0570+  20FA FA F9 FF      lea d, [bp +- 7]
0571+  20FD 07 B6 1E      call _gets
0572+  2100 07 0F 1E      call _strlen      ; get string length in C
0573+  2103 7E            dec c
0574+  2104 FD 4E         mov si, d
0575+  2106 12            mov a, c
0576+  2107 FD 99         shl a
0577+  2109 3B 45 21      mov d, table_power
0578+  210C 59            add d, a
0579+  210D 38 00 00      mov c, 0
0580+  2110             mul_loop:
0581+  2110 F6            lodsb      ; load ASCII to al
0582+  2111 B9 00         cmp al, 0
0583+  2113 C6 26 21      je mul_exit
0584+  2116 6F 30         sub al, $30    ; make into integer
0585+  2118 22 00         mov ah, 0
0586+  211A 2A            mov b, [d]
0587+  211B AC            mul a, b      ; result in B since it fits in 16bits
0588+  211C 11            mov a, b
0589+  211D 28            mov b, c
0590+  211E 54            add a, b
0591+  211F 39            mov c, a
0592+  2120 63 02 00      sub d, 2
0593+  2123 0A 10 21      jmp mul_loop
0594+  2126             mul_exit:
0595+  2126 12            mov a, c
0596+  2127 E7            pop d
0597+  2128 E6            pop c
0598+  2129 E5            pop b
0599+  212A EF            pop si
0600+  212B F9            leave
0601+  212C 09            ret
0602+  212D             
0603+  212D 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0603+  2131 34 35 36 37 
0603+  2135 38 39 41 42 
0603+  2139 43 44 45 46 
0604+  213D 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0604+  2141 1B 5B 48 00 
0605+  2145             
0606+  2145             table_power:
0607+  2145 01 00         .dw 1
0608+  2147 0A 00         .dw 10
0609+  2149 64 00         .dw 100
0610+  214B E8 03         .dw 1000
0611+  214D 10 27         .dw 100004190   214F             ; --- END INLINE ASM SEGMENT
4191   214F             
4192   214F F9            leave
4193   2150 09            ret
4194   2151             ; --- END TEXT SEGMENT
4195   2151             
4196   2151             ; --- BEGIN DATA SEGMENT
4197   2151 00 00 00 00 _p: .fill 4, 0
4198   2155 00 00       st_fopen_max_handle: .dw 0
4199   2157 55 6E 65 78 _s0: .db "Unexpected format in printf.", 0
4199   215B 70 65 63 74 
4199   215F 65 64 20 66 
4199   2163 6F 72 6D 61 
4199   2167 74 20 69 6E 
4199   216B 20 70 72 69 
4199   216F 6E 74 66 2E 
4199   2173 00 
4200   2174 45 72 72 6F _s1: .db "Error: Unknown argument type.\n", 0
4200   2178 72 3A 20 55 
4200   217C 6E 6B 6E 6F 
4200   2180 77 6E 20 61 
4200   2184 72 67 75 6D 
4200   2188 65 6E 74 20 
4200   218C 74 79 70 65 
4200   2190 2E 0A 00 
4201   2193 1B 5B 32 4A _s2: .db "\033[2J\033[H", 0
4201   2197 1B 5B 48 00 
4202   219B             
4203   219B 9D 21       _heap_top: .dw _heap
4204   219D 00          _heap: .db 0
4205   219E             ; --- END DATA SEGMENT
4206   219E             
4207   219E             .end
tasm: Number of errors = 0
