out/test.asm line 0069: Duplicate label: (text_org)
out/test.asm line 0158: Duplicate label: (sys_rtc)
out/test.asm line 0159: Duplicate label: (sys_ide)
out/test.asm line 0160: Duplicate label: (sys_io)
out/test.asm line 0161: Duplicate label: (sys_filesystem)
out/test.asm line 0164: Duplicate label: (sys_datetime)
out/test.asm line 0165: Duplicate label: (sys_reboot)
out/test.asm line 0166: Duplicate label: (sys_pause_proc)
out/test.asm line 0167: Duplicate label: (sys_resume_proc)
out/test.asm line 0168: Duplicate label: (sys_terminate_proc)
out/test.asm line 0169: Duplicate label: (sys_system)
0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0000             ; --- BEGIN SYSTEM SEGMENT
0005   0000               ; ------------------------------------------------------------------------------------------------------------------;
0006   0000               ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0007   0000               ; ------------------------------------------------------------------------------------------------------------------;
0008   0000               ; Memory Map
0009   0000               ; ------------------------------------------------------------------------------------------------------------------;
0010   0000               ; 0000    ROM BEGIN
0011   0000               ; ....
0012   0000               ; 7FFF    ROM END
0013   0000               ;
0014   0000               ; 8000    RAM begin
0015   0000               ; ....
0016   0000               ; F7FF    Stack root
0017   0000               ; ------------------------------------------------------------------------------------------------------------------;
0018   0000               ; I/O MAP
0019   0000               ; ------------------------------------------------------------------------------------------------------------------;
0020   0000               ; FF80    UART 0    (16550)
0021   0000               ; FF90    UART 1    (16550)
0022   0000               ; FFA0    RTC       (M48T02)
0023   0000               ; FFB0    PIO 0     (8255)
0024   0000               ; FFC0    PIO 1     (8255)
0025   0000               ; FFD0    IDE       (Compact Flash / PATA)
0026   0000               ; FFE0    Timer     (8253)
0027   0000               ; FFF0    BIOS CONFIGURATION NV-RAM STORE AREA
0028   0000               ; ------------------------------------------------------------------------------------------------------------------;
0029   0000               ; ------------------------------------------------------------------------------------------------------------------;
0030   0000               ; System Constants
0031   0000               ; ------------------------------------------------------------------------------------------------------------------;
0032   0000             _UART0_DATA       .equ $FF80            ; data
0033   0000             _UART0_DLAB_0     .equ $FF80            ; divisor latch low byte
0034   0000             _UART0_DLAB_1     .equ $FF81            ; divisor latch high byte
0035   0000             _UART0_IER        .equ $FF81            ; Interrupt enable register
0036   0000             _UART0_FCR        .equ $FF82            ; FIFO control register
0037   0000             _UART0_LCR        .equ $FF83            ; line control register
0038   0000             _UART0_LSR        .equ $FF85            ; line status register
0039   0000             _UART1_DATA       .equ $FF90            ; data
0040   0000             _UART1_DLAB_0     .equ $FF90            ; divisor latch low byte
0041   0000             _UART1_DLAB_1     .equ $FF91            ; divisor latch high byte
0042   0000             _UART1_IER        .equ $FF91            ; Interrupt enable register
0043   0000             _UART1_FCR        .equ $FF92            ; FIFO control register
0044   0000             _UART1_LCR        .equ $FF93            ; line control register
0045   0000             _UART1_LSR        .equ $FF95            ; line status register
0046   0000             XON               .equ $11
0047   0000             XOFF              .equ $13
0048   0000             _ide_BASE         .equ $FFD0            ; IDE BASE
0049   0000             _ide_R0           .equ _ide_BASE + 0    ; DATA PORT
0050   0000             _ide_R1           .equ _ide_BASE + 1    ; READ: ERROR CODE, WRITE: FEATURE
0051   0000             _ide_R2           .equ _ide_BASE + 2    ; NUMBER OF SECTORS TO TRANSFER
0052   0000             _ide_R3           .equ _ide_BASE + 3    ; SECTOR ADDRESS LBA 0 [0:7]
0053   0000             _ide_R4           .equ _ide_BASE + 4    ; SECTOR ADDRESS LBA 1 [8:15]
0054   0000             _ide_R5           .equ _ide_BASE + 5    ; SECTOR ADDRESS LBA 2 [16:23]
0055   0000             _ide_R6           .equ _ide_BASE + 6    ; SECTOR ADDRESS LBA 3 [24:27 (LSB)]
0056   0000             _ide_R7           .equ _ide_BASE + 7    ; READ: STATUS, WRITE: COMMAND
0057   0000             _7SEG_DISPLAY     .equ $FFB0            ; BIOS POST CODE HEX DISPLAY (2 DIGITS) (CONNECTED TO PIO A)
0058   0000             _BIOS_POST_CTRL   .equ $FFB3            ; BIOS POST DISPLAY CONTROL REGISTER, 80h = As Output
0059   0000             _PIO_A            .equ $FFB0    
0060   0000             _PIO_B            .equ $FFB1
0061   0000             _PIO_C            .equ $FFB2
0062   0000             _PIO_CONTROL      .equ $FFB3            ; PIO CONTROL PORT
0063   0000             _TIMER_C_0        .equ $FFE0            ; TIMER COUNTER 0
0064   0000             _TIMER_C_1        .equ $FFE1            ; TIMER COUNTER 1
0065   0000             _TIMER_C_2        .equ $FFE2            ; TIMER COUNTER 2
0066   0000             _TIMER_CTRL       .equ $FFE3            ; TIMER CONTROL REGISTER
0067   0000             STACK_BEGIN       .equ $F7FF            ; beginning of stack
0068   0000             FIFO_SIZE         .equ 1024
0069   0000             text_org          .equ $400
0070   0000               ; ------------------------------------------------------------------------------------------------------------------;
0071   0000             ; For the next iteration:
0072   0000               ; boot-sector(1) | kernel-sectors(32) | inode-bitmap | rawdata-bitmap | inode-table | raw-disk-data
0073   0000             ; inode-table format:
0074   0000               ;  file-type(f, d)
0075   0000               ;  permissons
0076   0000               ;  link-count
0077   0000               ;  filesize
0078   0000               ;  time-stamps
0079   0000               ;  15 data block pointers
0080   0000               ;  single-indirect pointer
0081   0000               ; FILE ENTRY ATTRIBUTES
0082   0000               ; filename (24)
0083   0000             ; attributes (1)       :|0|0|file_type(3bits)|x|w|r|
0084   0000             ; LBA (2)              : location of raw data for file entry, or dirID for directory entry
0085   0000             ; size (2)             : filesize
0086   0000               ; day (1)           
0087   0000               ; month (1)
0088   0000               ; year (1)
0089   0000             ; packet size = 32 bytes  : total packet size in bytes
0090   0000             FST_ENTRY_SIZE          .equ 32  ; bytes
0091   0000             FST_FILES_PER_SECT      .equ (512 / FST_ENTRY_SIZE)
0092   0000             FST_FILES_PER_DIR       .equ (512 / FST_ENTRY_SIZE)
0093   0000             FST_NBR_DIRECTORIES     .equ 64
0094   0000               ; 1 sector for header, the rest is for the list of files/dirs
0095   0000             FST_SECTORS_PER_DIR     .equ (1 + (FST_ENTRY_SIZE * FST_FILES_PER_DIR / 512))    
0096   0000             FST_TOTAL_SECTORS       .equ (FST_SECTORS_PER_DIR * FST_NBR_DIRECTORIES)
0097   0000             FST_LBA_START           .equ 32
0098   0000             FST_LBA_END             .equ (FST_LBA_START + FST_TOTAL_SECTORS - 1)
0099   0000             FS_NBR_FILES            .equ (FST_NBR_DIRECTORIES * FST_FILES_PER_DIR)
0100   0000             FS_SECTORS_PER_FILE     .equ 32         ; the first sector is always a header with a  0     parameter (first byte)
0101   0000               ; so that we know which blocks are free or taken
0102   0000             FS_FILE_SIZE            .equ (FS_SECTORS_PER_FILE * 512)                  
0103   0000             FS_TOTAL_SECTORS        .equ (FS_NBR_FILES * FS_SECTORS_PER_FILE)
0104   0000             FS_LBA_START            .equ (FST_LBA_END + 1)
0105   0000             FS_LBA_END              .equ (FS_LBA_START + FS_NBR_FILES - 1)
0106   0000             root_id:                .equ FST_LBA_START
0107   0000               ; ------------------------------------------------------------------------------------------------------------------;
0108   0000               ; GLOBAL SYSTEM VARIABLES
0109   0000               ; ------------------------------------------------------------------------------------------------------------------;
0110   0000               ; ------------------------------------------------------------------------------------------------------------------;
0111   0000               ; IRQ Table
0112   0000               ; Highest priority at lowest address
0113   0000               ; ------------------------------------------------------------------------------------------------------------------;
out/test.asm line 0114: Label not found: (int_0)
out/test.asm line 0114: Label not found: (int_0)
0114   0000 00 00       .dw int_0
out/test.asm line 0115: Label not found: (int_1)
out/test.asm line 0115: Label not found: (int_1)
0115   0002 00 00       .dw int_1
out/test.asm line 0116: Label not found: (int_2)
out/test.asm line 0116: Label not found: (int_2)
0116   0004 00 00       .dw int_2
out/test.asm line 0117: Label not found: (int_3)
out/test.asm line 0117: Label not found: (int_3)
0117   0006 00 00       .dw int_3
out/test.asm line 0118: Label not found: (int_4)
out/test.asm line 0118: Label not found: (int_4)
0118   0008 00 00       .dw int_4
out/test.asm line 0119: Label not found: (int_5)
out/test.asm line 0119: Label not found: (int_5)
0119   000A 00 00       .dw int_5
out/test.asm line 0120: Label not found: (int_6)
out/test.asm line 0120: Label not found: (int_6)
0120   000C 00 00       .dw int_6
out/test.asm line 0121: Label not found: (int_7)
out/test.asm line 0121: Label not found: (int_7)
0121   000E 00 00       .dw int_7
0122   0010               ; ------------------------------------------------------------------------------------------------------------------;
0123   0010               ; Reset Vector
0124   0010               ; ------------------------------------------------------------------------------------------------------------------;
out/test.asm line 0125: Label not found: (kernel_reset_vector)
out/test.asm line 0125: Label not found: (kernel_reset_vector)
0125   0010 00 00       .dw kernel_reset_vector
0126   0012               ; ------------------------------------------------------------------------------------------------------------------;
0127   0012               ; Exception Vector Table
0128   0012               ; Total of 7 entries, starting at address $0012
0129   0012               ; ------------------------------------------------------------------------------------------------------------------;
out/test.asm line 0130: Label not found: (trap_privilege)
out/test.asm line 0130: Label not found: (trap_privilege)
0130   0012 00 00       .dw trap_privilege
out/test.asm line 0131: Label not found: (trap_div_zero)
out/test.asm line 0131: Label not found: (trap_div_zero)
0131   0014 00 00       .dw trap_div_zero
out/test.asm line 0132: Label not found: (trap_undef_opcode)
out/test.asm line 0132: Label not found: (trap_undef_opcode)
0132   0016 00 00       .dw trap_undef_opcode
0133   0018 00 00       .dw 0
0134   001A 00 00       .dw 0
0135   001C 00 00       .dw 0
0136   001E 00 00       .dw 0
0137   0020               ; ------------------------------------------------------------------------------------------------------------------;
0138   0020               ; System Call Vector Table
0139   0020               ; Starts at address $0020
0140   0020               ; ------------------------------------------------------------------------------------------------------------------;
0141   0020 16 04       .dw syscall_break
0142   0022 1B 04       .dw syscall_rtc
0143   0024 20 04       .dw syscall_ide
0144   0026 25 04       .dw syscall_io
0145   0028 2A 04       .dw syscall_file_system
0146   002A 2F 04       .dw syscall_create_proc
0147   002C 34 04       .dw syscall_list_procs
0148   002E 39 04       .dw syscall_datetime
0149   0030 3E 04       .dw syscall_reboot
0150   0032 43 04       .dw syscall_pause_proc
0151   0034 48 04       .dw syscall_resume_proc
0152   0036 4D 04       .dw syscall_terminate_proc
0153   0038 52 04       .dw syscall_system            
0154   003A               ; ------------------------------------------------------------------------------------------------------------------;
0155   003A               ; System Call Aliases
0156   003A               ; ------------------------------------------------------------------------------------------------------------------;
0157   003A             sys_break            .equ 0
0158   003A             sys_rtc              .equ 1
0159   003A             sys_ide              .equ 2
0160   003A             sys_io               .equ 3
0161   003A             sys_filesystem       .equ 4
0162   003A             sys_create_proc      .equ 5
0163   003A             sys_list_proc        .equ 6
0164   003A             sys_datetime         .equ 7
0165   003A             sys_reboot           .equ 8
0166   003A             sys_pause_proc       .equ 9
0167   003A             sys_resume_proc      .equ 10
0168   003A             sys_terminate_proc   .equ 11
0169   003A             sys_system           .equ 12
0170   003A               ; ------------------------------------------------------------------------------------------------------------------;
0171   003A               ; Alias Exports
0172   003A               ; ------------------------------------------------------------------------------------------------------------------;
0173   003A               .export text_org
0174   003A               .export sys_break
0175   003A               .export sys_rtc
0176   003A               .export sys_ide
0177   003A               .export sys_io
0178   003A               .export sys_filesystem
0179   003A               .export sys_create_proc
0180   003A               .export sys_list_proc
0181   003A               .export sys_datetime
0182   003A               .export sys_reboot
0183   003A               .export sys_pause_proc
0184   003A               .export sys_resume_proc
0185   003A               .export sys_terminate_proc
0186   003A               .export sys_system
0187   003A             ; --- END SYSTEM SEGMENT
0188   003A             
0189   003A             ; --- BEGIN TEXT SEGMENT
0190   0400             .org text_org
0191   0400             main:
0192   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0193   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0194   0408             ; printf("Hello World" 
0195   0408             ; --- START FUNCTION CALL
0196   0408 26 66 0D      mov b, _s0 ; "Hello WorldMy name is Sol-1And this is a multi-line string"
0197   040B FD AB         swp b
0198   040D D8            push b
0199   040E 07 57 04      call printf
0200   0411 51 02 00      add sp, 2
0201   0414             ; --- END FUNCTION CALL
0202   0414 05 0B         syscall sys_terminate_proc
0203   0416             
0204   0416             syscall_break:
0205   0416 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0206   0419 F9            leave
0207   041A 09            ret
0208   041B             
0209   041B             syscall_rtc:
0210   041B F8 00 00      enter 0 ; (push bp; mov bp, sp)
0211   041E F9            leave
0212   041F 09            ret
0213   0420             
0214   0420             syscall_ide:
0215   0420 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0216   0423 F9            leave
0217   0424 09            ret
0218   0425             
0219   0425             syscall_io:
0220   0425 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0221   0428 F9            leave
0222   0429 09            ret
0223   042A             
0224   042A             syscall_file_system:
0225   042A F8 00 00      enter 0 ; (push bp; mov bp, sp)
0226   042D F9            leave
0227   042E 09            ret
0228   042F             
0229   042F             syscall_create_proc:
0230   042F F8 00 00      enter 0 ; (push bp; mov bp, sp)
0231   0432 F9            leave
0232   0433 09            ret
0233   0434             
0234   0434             syscall_list_procs:
0235   0434 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0236   0437 F9            leave
0237   0438 09            ret
0238   0439             
0239   0439             syscall_datetime:
0240   0439 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0241   043C F9            leave
0242   043D 09            ret
0243   043E             
0244   043E             syscall_reboot:
0245   043E F8 00 00      enter 0 ; (push bp; mov bp, sp)
0246   0441 F9            leave
0247   0442 09            ret
0248   0443             
0249   0443             syscall_pause_proc:
0250   0443 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0251   0446 F9            leave
0252   0447 09            ret
0253   0448             
0254   0448             syscall_resume_proc:
0255   0448 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0256   044B F9            leave
0257   044C 09            ret
0258   044D             
0259   044D             syscall_terminate_proc:
0260   044D F8 00 00      enter 0 ; (push bp; mov bp, sp)
0261   0450 F9            leave
0262   0451 09            ret
0263   0452             
0264   0452             syscall_system:
0265   0452 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0266   0455 F9            leave
0267   0456 09            ret
0268   0457             
0269   0457             printf:
0270   0457 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0271   045A             ; char *p, *format_p; 
0272   045A 52 02 00      sub sp, 2
0273   045D 52 02 00      sub sp, 2
0274   0460             ; format_p = format; 
0275   0460 FA FD FF      lea d, [bp + -3] ; $format_p
0276   0463 DA            push d
0277   0464 FA 05 00      lea d, [bp + 5] ; $format
0278   0467 2A            mov b, [d]
0279   0468 38 00 00      mov c, 0
0280   046B E7            pop d
0281   046C FD 43         mov [d], b
0282   046E             ; p = &format + 2; 
0283   046E FA FF FF      lea d, [bp + -1] ; $p
0284   0471 DA            push d
0285   0472 FA 05 00      lea d, [bp + 5] ; $format
0286   0475 2D            mov b, d
0287   0476             ; --- START TERMS
0288   0476 D7            push a
0289   0477 11            mov a, b
0290   0478 FD 2E 02 00   mov32 cb, $00000002
0290   047C 00 00 
0291   047E 56            add b, a
0292   047F E4            pop a
0293   0480             ; --- END TERMS
0294   0480 E7            pop d
0295   0481 FD 43         mov [d], b
0296   0483             ; for(;;){ 
0297   0483             _for1_init:
0298   0483             _for1_cond:
0299   0483             _for1_block:
0300   0483             ; if(!*format_p) break; 
0301   0483             _if2_cond:
0302   0483 FA FD FF      lea d, [bp + -3] ; $format_p
0303   0486 2A            mov b, [d]
0304   0487 38 00 00      mov c, 0
0305   048A 74            mov d, b
0306   048B 32            mov bl, [d]
0307   048C A7 00         mov bh, 0
0308   048E 38 00 00      mov c, 0
0309   0491 C0 00 00      cmp b, 0
0310   0494 FD 71         seq ; !
0311   0496 C0 00 00      cmp b, 0
0312   0499 C6 A2 04      je _if2_else
0313   049C             _if2_TRUE:
0314   049C             ; break; 
0315   049C 0A 52 07      jmp _for1_exit ; for break
0316   049F 0A 4F 07      jmp _if2_exit
0317   04A2             _if2_else:
0318   04A2             ; if(*format_p == '%'){ 
0319   04A2             _if3_cond:
0320   04A2 FA FD FF      lea d, [bp + -3] ; $format_p
0321   04A5 2A            mov b, [d]
0322   04A6 38 00 00      mov c, 0
0323   04A9 74            mov d, b
0324   04AA 32            mov bl, [d]
0325   04AB A7 00         mov bh, 0
0326   04AD 38 00 00      mov c, 0
0327   04B0             ; --- START RELATIONAL
0328   04B0 D7            push a
0329   04B1 11            mov a, b
0330   04B2 FD 2E 25 00   mov32 cb, $00000025
0330   04B6 00 00 
0331   04B8 B0            cmp a, b
0332   04B9 FD 71         seq ; ==
0333   04BB E4            pop a
0334   04BC             ; --- END RELATIONAL
0335   04BC C0 00 00      cmp b, 0
0336   04BF C6 2A 07      je _if3_else
0337   04C2             _if3_TRUE:
0338   04C2             ; format_p++; 
0339   04C2 FA FD FF      lea d, [bp + -3] ; $format_p
0340   04C5 2A            mov b, [d]
0341   04C6 38 00 00      mov c, 0
0342   04C9 FD 77         inc b
0343   04CB FA FD FF      lea d, [bp + -3] ; $format_p
0344   04CE FD 43         mov [d], b
0345   04D0 FD 7D         dec b
0346   04D2             ; switch(*format_p){ 
0347   04D2             _switch4_expr:
0348   04D2 FA FD FF      lea d, [bp + -3] ; $format_p
0349   04D5 2A            mov b, [d]
0350   04D6 38 00 00      mov c, 0
0351   04D9 74            mov d, b
0352   04DA 32            mov bl, [d]
0353   04DB A7 00         mov bh, 0
0354   04DD 38 00 00      mov c, 0
0355   04E0             _switch4_comparisons:
0356   04E0 C1 6C         cmp bl, $6c
0357   04E2 C6 0E 05      je _switch4_case0
0358   04E5 C1 4C         cmp bl, $4c
0359   04E7 C6 0E 05      je _switch4_case1
0360   04EA C1 64         cmp bl, $64
0361   04EC C6 1E 06      je _switch4_case2
0362   04EF C1 69         cmp bl, $69
0363   04F1 C6 1E 06      je _switch4_case3
0364   04F4 C1 75         cmp bl, $75
0365   04F6 C6 4E 06      je _switch4_case4
0366   04F9 C1 78         cmp bl, $78
0367   04FB C6 7E 06      je _switch4_case5
0368   04FE C1 63         cmp bl, $63
0369   0500 C6 AE 06      je _switch4_case6
0370   0503 C1 73         cmp bl, $73
0371   0505 C6 DE 06      je _switch4_case7
0372   0508 0A 0B 07      jmp _switch4_default
0373   050B 0A 17 07      jmp _switch4_exit
0374   050E             _switch4_case0:
0375   050E             _switch4_case1:
0376   050E             ; format_p++; 
0377   050E FA FD FF      lea d, [bp + -3] ; $format_p
0378   0511 2A            mov b, [d]
0379   0512 38 00 00      mov c, 0
0380   0515 FD 77         inc b
0381   0517 FA FD FF      lea d, [bp + -3] ; $format_p
0382   051A FD 43         mov [d], b
0383   051C FD 7D         dec b
0384   051E             ; if(*format_p == 'd' || *format_p == 'i') 
0385   051E             _if5_cond:
0386   051E FA FD FF      lea d, [bp + -3] ; $format_p
0387   0521 2A            mov b, [d]
0388   0522 38 00 00      mov c, 0
0389   0525 74            mov d, b
0390   0526 32            mov bl, [d]
0391   0527 A7 00         mov bh, 0
0392   0529 38 00 00      mov c, 0
0393   052C             ; --- START RELATIONAL
0394   052C D7            push a
0395   052D 11            mov a, b
0396   052E FD 2E 64 00   mov32 cb, $00000064
0396   0532 00 00 
0397   0534 B0            cmp a, b
0398   0535 FD 71         seq ; ==
0399   0537 E4            pop a
0400   0538             ; --- END RELATIONAL
0401   0538             ; --- START LOGICAL OR
0402   0538 D7            push a
0403   0539 11            mov a, b
0404   053A FA FD FF      lea d, [bp + -3] ; $format_p
0405   053D 2A            mov b, [d]
0406   053E 38 00 00      mov c, 0
0407   0541 74            mov d, b
0408   0542 32            mov bl, [d]
0409   0543 A7 00         mov bh, 0
0410   0545 38 00 00      mov c, 0
0411   0548             ; --- START RELATIONAL
0412   0548 D7            push a
0413   0549 11            mov a, b
0414   054A FD 2E 69 00   mov32 cb, $00000069
0414   054E 00 00 
0415   0550 B0            cmp a, b
0416   0551 FD 71         seq ; ==
0417   0553 E4            pop a
0418   0554             ; --- END RELATIONAL
0419   0554 FD A8         sor a, b ; ||
0420   0556 E4            pop a
0421   0557             ; --- END LOGICAL OR
0422   0557 C0 00 00      cmp b, 0
0423   055A C6 7B 05      je _if5_else
0424   055D             _if5_TRUE:
0425   055D             ; print_signed_long(*(long *)p); 
0426   055D             ; --- START FUNCTION CALL
0427   055D FA FF FF      lea d, [bp + -1] ; $p
0428   0560 2A            mov b, [d]
0429   0561 38 00 00      mov c, 0
0430   0564 74            mov d, b
0431   0565 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0432   0568 FD 39         mov c, b ; And place it into C
0433   056A 2A            mov b, [d] ; Lower Word in B
0434   056B 12            mov a, c
0435   056C FD AA         swp a
0436   056E D7            push a
0437   056F FD AB         swp b
0438   0571 D8            push b
0439   0572 07 54 07      call print_signed_long
0440   0575 51 04 00      add sp, 4
0441   0578             ; --- END FUNCTION CALL
0442   0578 0A 03 06      jmp _if5_exit
0443   057B             _if5_else:
0444   057B             ; if(*format_p == 'u') 
0445   057B             _if6_cond:
0446   057B FA FD FF      lea d, [bp + -3] ; $format_p
0447   057E 2A            mov b, [d]
0448   057F 38 00 00      mov c, 0
0449   0582 74            mov d, b
0450   0583 32            mov bl, [d]
0451   0584 A7 00         mov bh, 0
0452   0586 38 00 00      mov c, 0
0453   0589             ; --- START RELATIONAL
0454   0589 D7            push a
0455   058A 11            mov a, b
0456   058B FD 2E 75 00   mov32 cb, $00000075
0456   058F 00 00 
0457   0591 B0            cmp a, b
0458   0592 FD 71         seq ; ==
0459   0594 E4            pop a
0460   0595             ; --- END RELATIONAL
0461   0595 C0 00 00      cmp b, 0
0462   0598 C6 B9 05      je _if6_else
0463   059B             _if6_TRUE:
0464   059B             ; print_unsigned_long(*(unsigned long *)p); 
0465   059B             ; --- START FUNCTION CALL
0466   059B FA FF FF      lea d, [bp + -1] ; $p
0467   059E 2A            mov b, [d]
0468   059F 38 00 00      mov c, 0
0469   05A2 74            mov d, b
0470   05A3 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0471   05A6 FD 39         mov c, b ; And place it into C
0472   05A8 2A            mov b, [d] ; Lower Word in B
0473   05A9 12            mov a, c
0474   05AA FD AA         swp a
0475   05AC D7            push a
0476   05AD FD AB         swp b
0477   05AF D8            push b
0478   05B0 07 E7 08      call print_unsigned_long
0479   05B3 51 04 00      add sp, 4
0480   05B6             ; --- END FUNCTION CALL
0481   05B6 0A 03 06      jmp _if6_exit
0482   05B9             _if6_else:
0483   05B9             ; if(*format_p == 'x') 
0484   05B9             _if7_cond:
0485   05B9 FA FD FF      lea d, [bp + -3] ; $format_p
0486   05BC 2A            mov b, [d]
0487   05BD 38 00 00      mov c, 0
0488   05C0 74            mov d, b
0489   05C1 32            mov bl, [d]
0490   05C2 A7 00         mov bh, 0
0491   05C4 38 00 00      mov c, 0
0492   05C7             ; --- START RELATIONAL
0493   05C7 D7            push a
0494   05C8 11            mov a, b
0495   05C9 FD 2E 78 00   mov32 cb, $00000078
0495   05CD 00 00 
0496   05CF B0            cmp a, b
0497   05D0 FD 71         seq ; ==
0498   05D2 E4            pop a
0499   05D3             ; --- END RELATIONAL
0500   05D3 C0 00 00      cmp b, 0
0501   05D6 C6 F7 05      je _if7_else
0502   05D9             _if7_TRUE:
0503   05D9             ; printx32(*(long int *)p); 
0504   05D9             ; --- START FUNCTION CALL
0505   05D9 FA FF FF      lea d, [bp + -1] ; $p
0506   05DC 2A            mov b, [d]
0507   05DD 38 00 00      mov c, 0
0508   05E0 74            mov d, b
0509   05E1 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0510   05E4 FD 39         mov c, b ; And place it into C
0511   05E6 2A            mov b, [d] ; Lower Word in B
0512   05E7 12            mov a, c
0513   05E8 FD AA         swp a
0514   05EA D7            push a
0515   05EB FD AB         swp b
0516   05ED D8            push b
0517   05EE 07 1B 0A      call printx32
0518   05F1 51 04 00      add sp, 4
0519   05F4             ; --- END FUNCTION CALL
0520   05F4 0A 03 06      jmp _if7_exit
0521   05F7             _if7_else:
0522   05F7             ; err("Unexpected format in printf."); 
0523   05F7             ; --- START FUNCTION CALL
0524   05F7 26 A1 0D      mov b, _s1 ; "Unexpected format in printf."
0525   05FA FD AB         swp b
0526   05FC D8            push b
0527   05FD 07 7B 0A      call err
0528   0600 51 02 00      add sp, 2
0529   0603             ; --- END FUNCTION CALL
0530   0603             _if7_exit:
0531   0603             _if6_exit:
0532   0603             _if5_exit:
0533   0603             ; p = p + 4; 
0534   0603 FA FF FF      lea d, [bp + -1] ; $p
0535   0606 DA            push d
0536   0607 FA FF FF      lea d, [bp + -1] ; $p
0537   060A 2A            mov b, [d]
0538   060B 38 00 00      mov c, 0
0539   060E             ; --- START TERMS
0540   060E D7            push a
0541   060F 11            mov a, b
0542   0610 FD 2E 04 00   mov32 cb, $00000004
0542   0614 00 00 
0543   0616 56            add b, a
0544   0617 E4            pop a
0545   0618             ; --- END TERMS
0546   0618 E7            pop d
0547   0619 FD 43         mov [d], b
0548   061B             ; break; 
0549   061B 0A 17 07      jmp _switch4_exit ; case break
0550   061E             _switch4_case2:
0551   061E             _switch4_case3:
0552   061E             ; print_signed(*(int*)p); 
0553   061E             ; --- START FUNCTION CALL
0554   061E FA FF FF      lea d, [bp + -1] ; $p
0555   0621 2A            mov b, [d]
0556   0622 38 00 00      mov c, 0
0557   0625 74            mov d, b
0558   0626 2A            mov b, [d]
0559   0627 38 00 00      mov c, 0
0560   062A FD AB         swp b
0561   062C D8            push b
0562   062D 07 A9 0A      call print_signed
0563   0630 51 02 00      add sp, 2
0564   0633             ; --- END FUNCTION CALL
0565   0633             ; p = p + 2; 
0566   0633 FA FF FF      lea d, [bp + -1] ; $p
0567   0636 DA            push d
0568   0637 FA FF FF      lea d, [bp + -1] ; $p
0569   063A 2A            mov b, [d]
0570   063B 38 00 00      mov c, 0
0571   063E             ; --- START TERMS
0572   063E D7            push a
0573   063F 11            mov a, b
0574   0640 FD 2E 02 00   mov32 cb, $00000002
0574   0644 00 00 
0575   0646 56            add b, a
0576   0647 E4            pop a
0577   0648             ; --- END TERMS
0578   0648 E7            pop d
0579   0649 FD 43         mov [d], b
0580   064B             ; break; 
0581   064B 0A 17 07      jmp _switch4_exit ; case break
0582   064E             _switch4_case4:
0583   064E             ; print_unsigned(*(unsigned int*)p); 
0584   064E             ; --- START FUNCTION CALL
0585   064E FA FF FF      lea d, [bp + -1] ; $p
0586   0651 2A            mov b, [d]
0587   0652 38 00 00      mov c, 0
0588   0655 74            mov d, b
0589   0656 2A            mov b, [d]
0590   0657 38 00 00      mov c, 0
0591   065A FD AB         swp b
0592   065C D8            push b
0593   065D 07 FA 0B      call print_unsigned
0594   0660 51 02 00      add sp, 2
0595   0663             ; --- END FUNCTION CALL
0596   0663             ; p = p + 2; 
0597   0663 FA FF FF      lea d, [bp + -1] ; $p
0598   0666 DA            push d
0599   0667 FA FF FF      lea d, [bp + -1] ; $p
0600   066A 2A            mov b, [d]
0601   066B 38 00 00      mov c, 0
0602   066E             ; --- START TERMS
0603   066E D7            push a
0604   066F 11            mov a, b
0605   0670 FD 2E 02 00   mov32 cb, $00000002
0605   0674 00 00 
0606   0676 56            add b, a
0607   0677 E4            pop a
0608   0678             ; --- END TERMS
0609   0678 E7            pop d
0610   0679 FD 43         mov [d], b
0611   067B             ; break; 
0612   067B 0A 17 07      jmp _switch4_exit ; case break
0613   067E             _switch4_case5:
0614   067E             ; printx16(*(int*)p); 
0615   067E             ; --- START FUNCTION CALL
0616   067E FA FF FF      lea d, [bp + -1] ; $p
0617   0681 2A            mov b, [d]
0618   0682 38 00 00      mov c, 0
0619   0685 74            mov d, b
0620   0686 2A            mov b, [d]
0621   0687 38 00 00      mov c, 0
0622   068A FD AB         swp b
0623   068C D8            push b
0624   068D 07 12 0D      call printx16
0625   0690 51 02 00      add sp, 2
0626   0693             ; --- END FUNCTION CALL
0627   0693             ; p = p + 2; 
0628   0693 FA FF FF      lea d, [bp + -1] ; $p
0629   0696 DA            push d
0630   0697 FA FF FF      lea d, [bp + -1] ; $p
0631   069A 2A            mov b, [d]
0632   069B 38 00 00      mov c, 0
0633   069E             ; --- START TERMS
0634   069E D7            push a
0635   069F 11            mov a, b
0636   06A0 FD 2E 02 00   mov32 cb, $00000002
0636   06A4 00 00 
0637   06A6 56            add b, a
0638   06A7 E4            pop a
0639   06A8             ; --- END TERMS
0640   06A8 E7            pop d
0641   06A9 FD 43         mov [d], b
0642   06AB             ; break; 
0643   06AB 0A 17 07      jmp _switch4_exit ; case break
0644   06AE             _switch4_case6:
0645   06AE             ; putchar(*(char*)p); 
0646   06AE             ; --- START FUNCTION CALL
0647   06AE FA FF FF      lea d, [bp + -1] ; $p
0648   06B1 2A            mov b, [d]
0649   06B2 38 00 00      mov c, 0
0650   06B5 74            mov d, b
0651   06B6 32            mov bl, [d]
0652   06B7 A7 00         mov bh, 0
0653   06B9 38 00 00      mov c, 0
0654   06BC DD            push bl
0655   06BD 07 D9 08      call putchar
0656   06C0 51 01 00      add sp, 1
0657   06C3             ; --- END FUNCTION CALL
0658   06C3             ; p = p + 2; 
0659   06C3 FA FF FF      lea d, [bp + -1] ; $p
0660   06C6 DA            push d
0661   06C7 FA FF FF      lea d, [bp + -1] ; $p
0662   06CA 2A            mov b, [d]
0663   06CB 38 00 00      mov c, 0
0664   06CE             ; --- START TERMS
0665   06CE D7            push a
0666   06CF 11            mov a, b
0667   06D0 FD 2E 02 00   mov32 cb, $00000002
0667   06D4 00 00 
0668   06D6 56            add b, a
0669   06D7 E4            pop a
0670   06D8             ; --- END TERMS
0671   06D8 E7            pop d
0672   06D9 FD 43         mov [d], b
0673   06DB             ; break; 
0674   06DB 0A 17 07      jmp _switch4_exit ; case break
0675   06DE             _switch4_case7:
0676   06DE             ; print(*(char**)p); 
0677   06DE             ; --- START FUNCTION CALL
0678   06DE FA FF FF      lea d, [bp + -1] ; $p
0679   06E1 2A            mov b, [d]
0680   06E2 38 00 00      mov c, 0
0681   06E5 74            mov d, b
0682   06E6 2A            mov b, [d]
0683   06E7 FD AB         swp b
0684   06E9 D8            push b
0685   06EA 07 90 0A      call print
0686   06ED 51 02 00      add sp, 2
0687   06F0             ; --- END FUNCTION CALL
0688   06F0             ; p = p + 2; 
0689   06F0 FA FF FF      lea d, [bp + -1] ; $p
0690   06F3 DA            push d
0691   06F4 FA FF FF      lea d, [bp + -1] ; $p
0692   06F7 2A            mov b, [d]
0693   06F8 38 00 00      mov c, 0
0694   06FB             ; --- START TERMS
0695   06FB D7            push a
0696   06FC 11            mov a, b
0697   06FD FD 2E 02 00   mov32 cb, $00000002
0697   0701 00 00 
0698   0703 56            add b, a
0699   0704 E4            pop a
0700   0705             ; --- END TERMS
0701   0705 E7            pop d
0702   0706 FD 43         mov [d], b
0703   0708             ; break; 
0704   0708 0A 17 07      jmp _switch4_exit ; case break
0705   070B             _switch4_default:
0706   070B             ; print("Error: Unknown argument type.\n"); 
0707   070B             ; --- START FUNCTION CALL
0708   070B 26 BE 0D      mov b, _s2 ; "Error: Unknown argument type.\n"
0709   070E FD AB         swp b
0710   0710 D8            push b
0711   0711 07 90 0A      call print
0712   0714 51 02 00      add sp, 2
0713   0717             ; --- END FUNCTION CALL
0714   0717             _switch4_exit:
0715   0717             ; format_p++; 
0716   0717 FA FD FF      lea d, [bp + -3] ; $format_p
0717   071A 2A            mov b, [d]
0718   071B 38 00 00      mov c, 0
0719   071E FD 77         inc b
0720   0720 FA FD FF      lea d, [bp + -3] ; $format_p
0721   0723 FD 43         mov [d], b
0722   0725 FD 7D         dec b
0723   0727 0A 4F 07      jmp _if3_exit
0724   072A             _if3_else:
0725   072A             ; putchar(*format_p); 
0726   072A             ; --- START FUNCTION CALL
0727   072A FA FD FF      lea d, [bp + -3] ; $format_p
0728   072D 2A            mov b, [d]
0729   072E 38 00 00      mov c, 0
0730   0731 74            mov d, b
0731   0732 32            mov bl, [d]
0732   0733 A7 00         mov bh, 0
0733   0735 38 00 00      mov c, 0
0734   0738 DD            push bl
0735   0739 07 D9 08      call putchar
0736   073C 51 01 00      add sp, 1
0737   073F             ; --- END FUNCTION CALL
0738   073F             ; format_p++; 
0739   073F FA FD FF      lea d, [bp + -3] ; $format_p
0740   0742 2A            mov b, [d]
0741   0743 38 00 00      mov c, 0
0742   0746 FD 77         inc b
0743   0748 FA FD FF      lea d, [bp + -3] ; $format_p
0744   074B FD 43         mov [d], b
0745   074D FD 7D         dec b
0746   074F             _if3_exit:
0747   074F             _if2_exit:
0748   074F             _for1_update:
0749   074F 0A 83 04      jmp _for1_cond
0750   0752             _for1_exit:
0751   0752 F9            leave
0752   0753 09            ret
0753   0754             
0754   0754             print_signed_long:
0755   0754 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0756   0757             ; char digits[10]; 
0757   0757 52 0A 00      sub sp, 10
0758   075A             ; int i = 0; 
0759   075A 52 02 00      sub sp, 2
0760   075D             ; --- START LOCAL VAR INITIALIZATION
0761   075D FA F5 FF      lea d, [bp + -11] ; $i
0762   0760 DA            push d
0763   0761 FD 2E 00 00   mov32 cb, $00000000
0763   0765 00 00 
0764   0767 E7            pop d
0765   0768 FD 43         mov [d], b
0766   076A             ; --- END LOCAL VAR INITIALIZATION
0767   076A             ; if (num < 0) { 
0768   076A             _if8_cond:
0769   076A FA 05 00      lea d, [bp + 5] ; $num
0770   076D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0771   0770 FD 39         mov c, b ; And place it into C
0772   0772 2A            mov b, [d] ; Lower Word in B
0773   0773             ; --- START RELATIONAL
0774   0773 D7            push a
0775   0774 FD D8         push g
0776   0776 11            mov a, b
0777   0777 FD 7A         mov g, c
0778   0779 FD 2E 00 00   mov32 cb, $00000000
0778   077D 00 00 
0779   077F FD AF         cmp32 ga, cb
0780   0781 FD 73         slt ; <
0781   0783 FD F1         pop g
0782   0785 E4            pop a
0783   0786             ; --- END RELATIONAL
0784   0786 C0 00 00      cmp b, 0
0785   0789 C6 BB 07      je _if8_else
0786   078C             _if8_TRUE:
0787   078C             ; putchar('-'); 
0788   078C             ; --- START FUNCTION CALL
0789   078C FD 2E 2D 00   mov32 cb, $0000002d
0789   0790 00 00 
0790   0792 DD            push bl
0791   0793 07 D9 08      call putchar
0792   0796 51 01 00      add sp, 1
0793   0799             ; --- END FUNCTION CALL
0794   0799             ; num = -num; 
0795   0799 FA 05 00      lea d, [bp + 5] ; $num
0796   079C DA            push d
0797   079D FA 05 00      lea d, [bp + 5] ; $num
0798   07A0 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0799   07A3 FD 39         mov c, b ; And place it into C
0800   07A5 2A            mov b, [d] ; Lower Word in B
0801   07A6 12            mov a, c
0802   07A7 95            not a
0803   07A8 97            not b
0804   07A9 55 01 00      add b, 1
0805   07AC 5B 00 00      adc a, 0
0806   07AF 39            mov c, a
0807   07B0 E7            pop d
0808   07B1 FD 43         mov [d], b
0809   07B3 28            mov b, c
0810   07B4 FD 44 02 00   mov [d + 2], b
0811   07B8 0A EF 07      jmp _if8_exit
0812   07BB             _if8_else:
0813   07BB             ; if (num == 0) { 
0814   07BB             _if9_cond:
0815   07BB FA 05 00      lea d, [bp + 5] ; $num
0816   07BE 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0817   07C1 FD 39         mov c, b ; And place it into C
0818   07C3 2A            mov b, [d] ; Lower Word in B
0819   07C4             ; --- START RELATIONAL
0820   07C4 D7            push a
0821   07C5 FD D8         push g
0822   07C7 11            mov a, b
0823   07C8 FD 7A         mov g, c
0824   07CA FD 2E 00 00   mov32 cb, $00000000
0824   07CE 00 00 
0825   07D0 FD AF         cmp32 ga, cb
0826   07D2 FD 71         seq ; ==
0827   07D4 FD F1         pop g
0828   07D6 E4            pop a
0829   07D7             ; --- END RELATIONAL
0830   07D7 C0 00 00      cmp b, 0
0831   07DA C6 EF 07      je _if9_exit
0832   07DD             _if9_TRUE:
0833   07DD             ; putchar('0'); 
0834   07DD             ; --- START FUNCTION CALL
0835   07DD FD 2E 30 00   mov32 cb, $00000030
0835   07E1 00 00 
0836   07E3 DD            push bl
0837   07E4 07 D9 08      call putchar
0838   07E7 51 01 00      add sp, 1
0839   07EA             ; --- END FUNCTION CALL
0840   07EA             ; return; 
0841   07EA F9            leave
0842   07EB 09            ret
0843   07EC 0A EF 07      jmp _if9_exit
0844   07EF             _if9_exit:
0845   07EF             _if8_exit:
0846   07EF             ; while (num > 0) { 
0847   07EF             _while10_cond:
0848   07EF FA 05 00      lea d, [bp + 5] ; $num
0849   07F2 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0850   07F5 FD 39         mov c, b ; And place it into C
0851   07F7 2A            mov b, [d] ; Lower Word in B
0852   07F8             ; --- START RELATIONAL
0853   07F8 D7            push a
0854   07F9 FD D8         push g
0855   07FB 11            mov a, b
0856   07FC FD 7A         mov g, c
0857   07FE FD 2E 00 00   mov32 cb, $00000000
0857   0802 00 00 
0858   0804 FD AF         cmp32 ga, cb
0859   0806 FD 7F         sgt
0860   0808 FD F1         pop g
0861   080A E4            pop a
0862   080B             ; --- END RELATIONAL
0863   080B C0 00 00      cmp b, 0
0864   080E C6 8F 08      je _while10_exit
0865   0811             _while10_block:
0866   0811             ; digits[i] = '0' + (num % 10); 
0867   0811 FA F7 FF      lea d, [bp + -9] ; $digits
0868   0814 D7            push a
0869   0815 DA            push d
0870   0816 FA F5 FF      lea d, [bp + -11] ; $i
0871   0819 2A            mov b, [d]
0872   081A 38 00 00      mov c, 0
0873   081D E7            pop d
0874   081E 5A            add d, b
0875   081F E4            pop a
0876   0820 DA            push d
0877   0821 FD 2E 30 00   mov32 cb, $00000030
0877   0825 00 00 
0878   0827             ; --- START TERMS
0879   0827 D7            push a
0880   0828 11            mov a, b
0881   0829 FA 05 00      lea d, [bp + 5] ; $num
0882   082C 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0883   082F FD 39         mov c, b ; And place it into C
0884   0831 2A            mov b, [d] ; Lower Word in B
0885   0832             ; --- START FACTORS
0886   0832 D7            push a
0887   0833 FD D8         push g
0888   0835 11            mov a, b
0889   0836 FD 7A         mov g, c
0890   0838 FD 2E 0A 00   mov32 cb, $0000000a
0890   083C 00 00 
0891   083E FD D8         push g ; save 'g' as the div instruction uses it
0892   0840 AE            div a, b ; %, a: quotient, b: remainder
0893   0841 11            mov a, b
0894   0842 FD F1         pop g
0895   0844 FD 38         mov c, g
0896   0846 27            mov b, a
0897   0847 FD F1         pop g
0898   0849 E4            pop a
0899   084A             ; --- END FACTORS
0900   084A FD 15         add32 cb, ga
0901   084C E4            pop a
0902   084D             ; --- END TERMS
0903   084D E7            pop d
0904   084E FD 3E         mov [d], bl
0905   0850             ; num = num / 10; 
0906   0850 FA 05 00      lea d, [bp + 5] ; $num
0907   0853 DA            push d
0908   0854 FA 05 00      lea d, [bp + 5] ; $num
0909   0857 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0910   085A FD 39         mov c, b ; And place it into C
0911   085C 2A            mov b, [d] ; Lower Word in B
0912   085D             ; --- START FACTORS
0913   085D D7            push a
0914   085E FD D8         push g
0915   0860 11            mov a, b
0916   0861 FD 7A         mov g, c
0917   0863 FD 2E 0A 00   mov32 cb, $0000000a
0917   0867 00 00 
0918   0869 FD D8         push g ; save 'g' as the div instruction uses it
0919   086B AE            div a, b ; /, a: quotient, b: remainder
0920   086C FD F1         pop g
0921   086E FD 38         mov c, g
0922   0870 27            mov b, a
0923   0871 FD F1         pop g
0924   0873 E4            pop a
0925   0874             ; --- END FACTORS
0926   0874 E7            pop d
0927   0875 FD 43         mov [d], b
0928   0877 28            mov b, c
0929   0878 FD 44 02 00   mov [d + 2], b
0930   087C             ; i++; 
0931   087C FA F5 FF      lea d, [bp + -11] ; $i
0932   087F 2A            mov b, [d]
0933   0880 38 00 00      mov c, 0
0934   0883 11            mov a, b
0935   0884 FD 77         inc b
0936   0886 FA F5 FF      lea d, [bp + -11] ; $i
0937   0889 FD 43         mov [d], b
0938   088B 27            mov b, a
0939   088C 0A EF 07      jmp _while10_cond
0940   088F             _while10_exit:
0941   088F             ; while (i > 0) { 
0942   088F             _while17_cond:
0943   088F FA F5 FF      lea d, [bp + -11] ; $i
0944   0892 2A            mov b, [d]
0945   0893 38 00 00      mov c, 0
0946   0896             ; --- START RELATIONAL
0947   0896 D7            push a
0948   0897 11            mov a, b
0949   0898 FD 2E 00 00   mov32 cb, $00000000
0949   089C 00 00 
0950   089E B0            cmp a, b
0951   089F FD 7F         sgt ; >
0952   08A1 E4            pop a
0953   08A2             ; --- END RELATIONAL
0954   08A2 C0 00 00      cmp b, 0
0955   08A5 C6 D7 08      je _while17_exit
0956   08A8             _while17_block:
0957   08A8             ; i--; 
0958   08A8 FA F5 FF      lea d, [bp + -11] ; $i
0959   08AB 2A            mov b, [d]
0960   08AC 38 00 00      mov c, 0
0961   08AF 11            mov a, b
0962   08B0 FD 7D         dec b
0963   08B2 FA F5 FF      lea d, [bp + -11] ; $i
0964   08B5 FD 43         mov [d], b
0965   08B7 27            mov b, a
0966   08B8             ; putchar(digits[i]); 
0967   08B8             ; --- START FUNCTION CALL
0968   08B8 FA F7 FF      lea d, [bp + -9] ; $digits
0969   08BB D7            push a
0970   08BC DA            push d
0971   08BD FA F5 FF      lea d, [bp + -11] ; $i
0972   08C0 2A            mov b, [d]
0973   08C1 38 00 00      mov c, 0
0974   08C4 E7            pop d
0975   08C5 5A            add d, b
0976   08C6 E4            pop a
0977   08C7 32            mov bl, [d]
0978   08C8 A7 00         mov bh, 0
0979   08CA 38 00 00      mov c, 0
0980   08CD DD            push bl
0981   08CE 07 D9 08      call putchar
0982   08D1 51 01 00      add sp, 1
0983   08D4             ; --- END FUNCTION CALL
0984   08D4 0A 8F 08      jmp _while17_cond
0985   08D7             _while17_exit:
0986   08D7 F9            leave
0987   08D8 09            ret
0988   08D9             
0989   08D9             putchar:
0990   08D9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0991   08DC             ; --- BEGIN INLINE ASM SEGMENT
0992   08DC FA 05 00      lea d, [bp + 5] ; $c
0993   08DF 1E            mov al, [d]
0994   08E0 23            mov ah, al
0995   08E1 19 00         mov al, 0
0996   08E3 05 03         syscall sys_io      ; char in AH
0997   08E5             ; --- END INLINE ASM SEGMENT
0998   08E5 F9            leave
0999   08E6 09            ret
1000   08E7             
1001   08E7             print_unsigned_long:
1002   08E7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1003   08EA             ; char digits[10]; 
1004   08EA 52 0A 00      sub sp, 10
1005   08ED             ; int i; 
1006   08ED 52 02 00      sub sp, 2
1007   08F0             ; i = 0; 
1008   08F0 FA F5 FF      lea d, [bp + -11] ; $i
1009   08F3 DA            push d
1010   08F4 FD 2E 00 00   mov32 cb, $00000000
1010   08F8 00 00 
1011   08FA E7            pop d
1012   08FB FD 43         mov [d], b
1013   08FD             ; if(num == 0){ 
1014   08FD             _if18_cond:
1015   08FD FA 05 00      lea d, [bp + 5] ; $num
1016   0900 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1017   0903 FD 39         mov c, b ; And place it into C
1018   0905 2A            mov b, [d] ; Lower Word in B
1019   0906             ; --- START RELATIONAL
1020   0906 D7            push a
1021   0907 FD D8         push g
1022   0909 11            mov a, b
1023   090A FD 7A         mov g, c
1024   090C FD 2E 00 00   mov32 cb, $00000000
1024   0910 00 00 
1025   0912 FD AF         cmp32 ga, cb
1026   0914 FD 71         seq ; ==
1027   0916 FD F1         pop g
1028   0918 E4            pop a
1029   0919             ; --- END RELATIONAL
1030   0919 C0 00 00      cmp b, 0
1031   091C C6 31 09      je _if18_exit
1032   091F             _if18_TRUE:
1033   091F             ; putchar('0'); 
1034   091F             ; --- START FUNCTION CALL
1035   091F FD 2E 30 00   mov32 cb, $00000030
1035   0923 00 00 
1036   0925 DD            push bl
1037   0926 07 D9 08      call putchar
1038   0929 51 01 00      add sp, 1
1039   092C             ; --- END FUNCTION CALL
1040   092C             ; return; 
1041   092C F9            leave
1042   092D 09            ret
1043   092E 0A 31 09      jmp _if18_exit
1044   0931             _if18_exit:
1045   0931             ; while (num > 0) { 
1046   0931             _while19_cond:
1047   0931 FA 05 00      lea d, [bp + 5] ; $num
1048   0934 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1049   0937 FD 39         mov c, b ; And place it into C
1050   0939 2A            mov b, [d] ; Lower Word in B
1051   093A             ; --- START RELATIONAL
1052   093A D7            push a
1053   093B FD D8         push g
1054   093D 11            mov a, b
1055   093E FD 7A         mov g, c
1056   0940 FD 2E 00 00   mov32 cb, $00000000
1056   0944 00 00 
1057   0946 FD AF         cmp32 ga, cb
1058   0948 FD 81         sgu
1059   094A FD F1         pop g
1060   094C E4            pop a
1061   094D             ; --- END RELATIONAL
1062   094D C0 00 00      cmp b, 0
1063   0950 C6 D1 09      je _while19_exit
1064   0953             _while19_block:
1065   0953             ; digits[i] = '0' + (num % 10); 
1066   0953 FA F7 FF      lea d, [bp + -9] ; $digits
1067   0956 D7            push a
1068   0957 DA            push d
1069   0958 FA F5 FF      lea d, [bp + -11] ; $i
1070   095B 2A            mov b, [d]
1071   095C 38 00 00      mov c, 0
1072   095F E7            pop d
1073   0960 5A            add d, b
1074   0961 E4            pop a
1075   0962 DA            push d
1076   0963 FD 2E 30 00   mov32 cb, $00000030
1076   0967 00 00 
1077   0969             ; --- START TERMS
1078   0969 D7            push a
1079   096A 11            mov a, b
1080   096B FA 05 00      lea d, [bp + 5] ; $num
1081   096E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1082   0971 FD 39         mov c, b ; And place it into C
1083   0973 2A            mov b, [d] ; Lower Word in B
1084   0974             ; --- START FACTORS
1085   0974 D7            push a
1086   0975 FD D8         push g
1087   0977 11            mov a, b
1088   0978 FD 7A         mov g, c
1089   097A FD 2E 0A 00   mov32 cb, $0000000a
1089   097E 00 00 
1090   0980 FD D8         push g ; save 'g' as the div instruction uses it
1091   0982 AE            div a, b ; %, a: quotient, b: remainder
1092   0983 11            mov a, b
1093   0984 FD F1         pop g
1094   0986 FD 38         mov c, g
1095   0988 27            mov b, a
1096   0989 FD F1         pop g
1097   098B E4            pop a
1098   098C             ; --- END FACTORS
1099   098C FD 15         add32 cb, ga
1100   098E E4            pop a
1101   098F             ; --- END TERMS
1102   098F E7            pop d
1103   0990 FD 3E         mov [d], bl
1104   0992             ; num = num / 10; 
1105   0992 FA 05 00      lea d, [bp + 5] ; $num
1106   0995 DA            push d
1107   0996 FA 05 00      lea d, [bp + 5] ; $num
1108   0999 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1109   099C FD 39         mov c, b ; And place it into C
1110   099E 2A            mov b, [d] ; Lower Word in B
1111   099F             ; --- START FACTORS
1112   099F D7            push a
1113   09A0 FD D8         push g
1114   09A2 11            mov a, b
1115   09A3 FD 7A         mov g, c
1116   09A5 FD 2E 0A 00   mov32 cb, $0000000a
1116   09A9 00 00 
1117   09AB FD D8         push g ; save 'g' as the div instruction uses it
1118   09AD AE            div a, b ; /, a: quotient, b: remainder
1119   09AE FD F1         pop g
1120   09B0 FD 38         mov c, g
1121   09B2 27            mov b, a
1122   09B3 FD F1         pop g
1123   09B5 E4            pop a
1124   09B6             ; --- END FACTORS
1125   09B6 E7            pop d
1126   09B7 FD 43         mov [d], b
1127   09B9 28            mov b, c
1128   09BA FD 44 02 00   mov [d + 2], b
1129   09BE             ; i++; 
1130   09BE FA F5 FF      lea d, [bp + -11] ; $i
1131   09C1 2A            mov b, [d]
1132   09C2 38 00 00      mov c, 0
1133   09C5 11            mov a, b
1134   09C6 FD 77         inc b
1135   09C8 FA F5 FF      lea d, [bp + -11] ; $i
1136   09CB FD 43         mov [d], b
1137   09CD 27            mov b, a
1138   09CE 0A 31 09      jmp _while19_cond
1139   09D1             _while19_exit:
1140   09D1             ; while (i > 0) { 
1141   09D1             _while26_cond:
1142   09D1 FA F5 FF      lea d, [bp + -11] ; $i
1143   09D4 2A            mov b, [d]
1144   09D5 38 00 00      mov c, 0
1145   09D8             ; --- START RELATIONAL
1146   09D8 D7            push a
1147   09D9 11            mov a, b
1148   09DA FD 2E 00 00   mov32 cb, $00000000
1148   09DE 00 00 
1149   09E0 B0            cmp a, b
1150   09E1 FD 7F         sgt ; >
1151   09E3 E4            pop a
1152   09E4             ; --- END RELATIONAL
1153   09E4 C0 00 00      cmp b, 0
1154   09E7 C6 19 0A      je _while26_exit
1155   09EA             _while26_block:
1156   09EA             ; i--; 
1157   09EA FA F5 FF      lea d, [bp + -11] ; $i
1158   09ED 2A            mov b, [d]
1159   09EE 38 00 00      mov c, 0
1160   09F1 11            mov a, b
1161   09F2 FD 7D         dec b
1162   09F4 FA F5 FF      lea d, [bp + -11] ; $i
1163   09F7 FD 43         mov [d], b
1164   09F9 27            mov b, a
1165   09FA             ; putchar(digits[i]); 
1166   09FA             ; --- START FUNCTION CALL
1167   09FA FA F7 FF      lea d, [bp + -9] ; $digits
1168   09FD D7            push a
1169   09FE DA            push d
1170   09FF FA F5 FF      lea d, [bp + -11] ; $i
1171   0A02 2A            mov b, [d]
1172   0A03 38 00 00      mov c, 0
1173   0A06 E7            pop d
1174   0A07 5A            add d, b
1175   0A08 E4            pop a
1176   0A09 32            mov bl, [d]
1177   0A0A A7 00         mov bh, 0
1178   0A0C 38 00 00      mov c, 0
1179   0A0F DD            push bl
1180   0A10 07 D9 08      call putchar
1181   0A13 51 01 00      add sp, 1
1182   0A16             ; --- END FUNCTION CALL
1183   0A16 0A D1 09      jmp _while26_cond
1184   0A19             _while26_exit:
1185   0A19 F9            leave
1186   0A1A 09            ret
1187   0A1B             
1188   0A1B             printx32:
1189   0A1B F8 00 00      enter 0 ; (push bp; mov bp, sp)
1190   0A1E             ; --- BEGIN INLINE ASM SEGMENT
1191   0A1E FA 05 00      lea d, [bp + 5] ; $hex
1192   0A21 2B 02 00      mov b, [d+2]
1193   0A24 07 2D 0A      call print_u16x_printx32
1194   0A27 2A            mov b, [d]
1195   0A28 07 2D 0A      call print_u16x_printx32
1196   0A2B             ; --- END INLINE ASM SEGMENT
1197   0A2B             ; return; 
1198   0A2B F9            leave
1199   0A2C 09            ret
1200   0A2D             ; --- BEGIN INLINE ASM SEGMENT
1201   0A2D             print_u16x_printx32:
1202   0A2D D7            push a
1203   0A2E D8            push b
1204   0A2F DD            push bl
1205   0A30 30            mov bl, bh
1206   0A31 07 4F 0A      call _itoa_printx32        ; convert bh to char in A
1207   0A34 2F            mov bl, al        ; save al
1208   0A35 19 00         mov al, 0
1209   0A37 05 03         syscall sys_io        ; display AH
1210   0A39 24            mov ah, bl        ; retrieve al
1211   0A3A 19 00         mov al, 0
1212   0A3C 05 03         syscall sys_io        ; display AL
1213   0A3E EA            pop bl
1214   0A3F 07 4F 0A      call _itoa_printx32        ; convert bh to char in A
1215   0A42 2F            mov bl, al        ; save al
1216   0A43 19 00         mov al, 0
1217   0A45 05 03         syscall sys_io        ; display AH
1218   0A47 24            mov ah, bl        ; retrieve al
1219   0A48 19 00         mov al, 0
1220   0A4A 05 03         syscall sys_io        ; display AL
1221   0A4C E5            pop b
1222   0A4D E4            pop a
1223   0A4E 09            ret
1224   0A4F             _itoa_printx32:
1225   0A4F DA            push d
1226   0A50 D8            push b
1227   0A51 A7 00         mov bh, 0
1228   0A53 FD A4 04      shr bl, 4  
1229   0A56 74            mov d, b
1230   0A57 1F 69 0A      mov al, [d + s_hex_digits_printx32]
1231   0A5A 23            mov ah, al
1232   0A5B E5            pop b
1233   0A5C D8            push b
1234   0A5D A7 00         mov bh, 0
1235   0A5F FD 87 0F      and bl, $0F
1236   0A62 74            mov d, b
1237   0A63 1F 69 0A      mov al, [d + s_hex_digits_printx32]
1238   0A66 E5            pop b
1239   0A67 E7            pop d
1240   0A68 09            ret
1241   0A69 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
1241   0A6D 34 35 36 37 
1241   0A71 38 39 41 42 
1241   0A75 43 44 45 46 
1242   0A79             ; --- END INLINE ASM SEGMENT
1243   0A79 F9            leave
1244   0A7A 09            ret
1245   0A7B             
1246   0A7B             err:
1247   0A7B F8 00 00      enter 0 ; (push bp; mov bp, sp)
1248   0A7E             ; print(e); 
1249   0A7E             ; --- START FUNCTION CALL
1250   0A7E FA 05 00      lea d, [bp + 5] ; $e
1251   0A81 2A            mov b, [d]
1252   0A82 38 00 00      mov c, 0
1253   0A85 FD AB         swp b
1254   0A87 D8            push b
1255   0A88 07 90 0A      call print
1256   0A8B 51 02 00      add sp, 2
1257   0A8E             ; --- END FUNCTION CALL
1258   0A8E F9            leave
1259   0A8F 09            ret
1260   0A90             
1261   0A90             print:
1262   0A90 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1263   0A93             ; --- BEGIN INLINE ASM SEGMENT
1264   0A93 FA 05 00      lea d, [bp + 5] ; $s
1265   0A96 FD 2A         mov d, [d]
1266   0A98             _puts_L1_print:
1267   0A98 1E            mov al, [d]
1268   0A99 B9 00         cmp al, 0
1269   0A9B C6 A7 0A      jz _puts_END_print
1270   0A9E 23            mov ah, al
1271   0A9F 19 00         mov al, 0
1272   0AA1 05 03         syscall sys_io
1273   0AA3 79            inc d
1274   0AA4 0A 98 0A      jmp _puts_L1_print
1275   0AA7             _puts_END_print:
1276   0AA7             ; --- END INLINE ASM SEGMENT
1277   0AA7 F9            leave
1278   0AA8 09            ret
1279   0AA9             
1280   0AA9             print_signed:
1281   0AA9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1282   0AAC             ; char digits[5]; 
1283   0AAC 52 05 00      sub sp, 5
1284   0AAF             ; int i = 0; 
1285   0AAF 52 02 00      sub sp, 2
1286   0AB2             ; --- START LOCAL VAR INITIALIZATION
1287   0AB2 FA FA FF      lea d, [bp + -6] ; $i
1288   0AB5 DA            push d
1289   0AB6 FD 2E 00 00   mov32 cb, $00000000
1289   0ABA 00 00 
1290   0ABC E7            pop d
1291   0ABD FD 43         mov [d], b
1292   0ABF             ; --- END LOCAL VAR INITIALIZATION
1293   0ABF             ; if (num < 0) { 
1294   0ABF             _if27_cond:
1295   0ABF FA 05 00      lea d, [bp + 5] ; $num
1296   0AC2 2A            mov b, [d]
1297   0AC3 38 00 00      mov c, 0
1298   0AC6             ; --- START RELATIONAL
1299   0AC6 D7            push a
1300   0AC7 11            mov a, b
1301   0AC8 FD 2E 00 00   mov32 cb, $00000000
1301   0ACC 00 00 
1302   0ACE B0            cmp a, b
1303   0ACF FD 73         slt ; < (signed)
1304   0AD1 E4            pop a
1305   0AD2             ; --- END RELATIONAL
1306   0AD2 C0 00 00      cmp b, 0
1307   0AD5 C6 F8 0A      je _if27_else
1308   0AD8             _if27_TRUE:
1309   0AD8             ; putchar('-'); 
1310   0AD8             ; --- START FUNCTION CALL
1311   0AD8 FD 2E 2D 00   mov32 cb, $0000002d
1311   0ADC 00 00 
1312   0ADE DD            push bl
1313   0ADF 07 D9 08      call putchar
1314   0AE2 51 01 00      add sp, 1
1315   0AE5             ; --- END FUNCTION CALL
1316   0AE5             ; num = -num; 
1317   0AE5 FA 05 00      lea d, [bp + 5] ; $num
1318   0AE8 DA            push d
1319   0AE9 FA 05 00      lea d, [bp + 5] ; $num
1320   0AEC 2A            mov b, [d]
1321   0AED 38 00 00      mov c, 0
1322   0AF0 FD 97         neg b
1323   0AF2 E7            pop d
1324   0AF3 FD 43         mov [d], b
1325   0AF5 0A 23 0B      jmp _if27_exit
1326   0AF8             _if27_else:
1327   0AF8             ; if (num == 0) { 
1328   0AF8             _if28_cond:
1329   0AF8 FA 05 00      lea d, [bp + 5] ; $num
1330   0AFB 2A            mov b, [d]
1331   0AFC 38 00 00      mov c, 0
1332   0AFF             ; --- START RELATIONAL
1333   0AFF D7            push a
1334   0B00 11            mov a, b
1335   0B01 FD 2E 00 00   mov32 cb, $00000000
1335   0B05 00 00 
1336   0B07 B0            cmp a, b
1337   0B08 FD 71         seq ; ==
1338   0B0A E4            pop a
1339   0B0B             ; --- END RELATIONAL
1340   0B0B C0 00 00      cmp b, 0
1341   0B0E C6 23 0B      je _if28_exit
1342   0B11             _if28_TRUE:
1343   0B11             ; putchar('0'); 
1344   0B11             ; --- START FUNCTION CALL
1345   0B11 FD 2E 30 00   mov32 cb, $00000030
1345   0B15 00 00 
1346   0B17 DD            push bl
1347   0B18 07 D9 08      call putchar
1348   0B1B 51 01 00      add sp, 1
1349   0B1E             ; --- END FUNCTION CALL
1350   0B1E             ; return; 
1351   0B1E F9            leave
1352   0B1F 09            ret
1353   0B20 0A 23 0B      jmp _if28_exit
1354   0B23             _if28_exit:
1355   0B23             _if27_exit:
1356   0B23             ; while (num > 0) { 
1357   0B23             _while29_cond:
1358   0B23 FA 05 00      lea d, [bp + 5] ; $num
1359   0B26 2A            mov b, [d]
1360   0B27 38 00 00      mov c, 0
1361   0B2A             ; --- START RELATIONAL
1362   0B2A D7            push a
1363   0B2B 11            mov a, b
1364   0B2C FD 2E 00 00   mov32 cb, $00000000
1364   0B30 00 00 
1365   0B32 B0            cmp a, b
1366   0B33 FD 7F         sgt ; >
1367   0B35 E4            pop a
1368   0B36             ; --- END RELATIONAL
1369   0B36 C0 00 00      cmp b, 0
1370   0B39 C6 B0 0B      je _while29_exit
1371   0B3C             _while29_block:
1372   0B3C             ; digits[i] = '0' + (num % 10); 
1373   0B3C FA FC FF      lea d, [bp + -4] ; $digits
1374   0B3F D7            push a
1375   0B40 DA            push d
1376   0B41 FA FA FF      lea d, [bp + -6] ; $i
1377   0B44 2A            mov b, [d]
1378   0B45 38 00 00      mov c, 0
1379   0B48 E7            pop d
1380   0B49 5A            add d, b
1381   0B4A E4            pop a
1382   0B4B DA            push d
1383   0B4C FD 2E 30 00   mov32 cb, $00000030
1383   0B50 00 00 
1384   0B52             ; --- START TERMS
1385   0B52 D7            push a
1386   0B53 11            mov a, b
1387   0B54 FA 05 00      lea d, [bp + 5] ; $num
1388   0B57 2A            mov b, [d]
1389   0B58 38 00 00      mov c, 0
1390   0B5B             ; --- START FACTORS
1391   0B5B D7            push a
1392   0B5C FD D8         push g
1393   0B5E 11            mov a, b
1394   0B5F FD 7A         mov g, c
1395   0B61 FD 2E 0A 00   mov32 cb, $0000000a
1395   0B65 00 00 
1396   0B67 FD D8         push g ; save 'g' as the div instruction uses it
1397   0B69 AE            div a, b ; %, a: quotient, b: remainder
1398   0B6A 11            mov a, b
1399   0B6B FD F1         pop g
1400   0B6D FD 38         mov c, g
1401   0B6F 27            mov b, a
1402   0B70 FD F1         pop g
1403   0B72 E4            pop a
1404   0B73             ; --- END FACTORS
1405   0B73 56            add b, a
1406   0B74 E4            pop a
1407   0B75             ; --- END TERMS
1408   0B75 E7            pop d
1409   0B76 FD 3E         mov [d], bl
1410   0B78             ; num = num / 10; 
1411   0B78 FA 05 00      lea d, [bp + 5] ; $num
1412   0B7B DA            push d
1413   0B7C FA 05 00      lea d, [bp + 5] ; $num
1414   0B7F 2A            mov b, [d]
1415   0B80 38 00 00      mov c, 0
1416   0B83             ; --- START FACTORS
1417   0B83 D7            push a
1418   0B84 FD D8         push g
1419   0B86 11            mov a, b
1420   0B87 FD 7A         mov g, c
1421   0B89 FD 2E 0A 00   mov32 cb, $0000000a
1421   0B8D 00 00 
1422   0B8F FD D8         push g ; save 'g' as the div instruction uses it
1423   0B91 AE            div a, b ; /, a: quotient, b: remainder
1424   0B92 FD F1         pop g
1425   0B94 FD 38         mov c, g
1426   0B96 27            mov b, a
1427   0B97 FD F1         pop g
1428   0B99 E4            pop a
1429   0B9A             ; --- END FACTORS
1430   0B9A E7            pop d
1431   0B9B FD 43         mov [d], b
1432   0B9D             ; i++; 
1433   0B9D FA FA FF      lea d, [bp + -6] ; $i
1434   0BA0 2A            mov b, [d]
1435   0BA1 38 00 00      mov c, 0
1436   0BA4 11            mov a, b
1437   0BA5 FD 77         inc b
1438   0BA7 FA FA FF      lea d, [bp + -6] ; $i
1439   0BAA FD 43         mov [d], b
1440   0BAC 27            mov b, a
1441   0BAD 0A 23 0B      jmp _while29_cond
1442   0BB0             _while29_exit:
1443   0BB0             ; while (i > 0) { 
1444   0BB0             _while36_cond:
1445   0BB0 FA FA FF      lea d, [bp + -6] ; $i
1446   0BB3 2A            mov b, [d]
1447   0BB4 38 00 00      mov c, 0
1448   0BB7             ; --- START RELATIONAL
1449   0BB7 D7            push a
1450   0BB8 11            mov a, b
1451   0BB9 FD 2E 00 00   mov32 cb, $00000000
1451   0BBD 00 00 
1452   0BBF B0            cmp a, b
1453   0BC0 FD 7F         sgt ; >
1454   0BC2 E4            pop a
1455   0BC3             ; --- END RELATIONAL
1456   0BC3 C0 00 00      cmp b, 0
1457   0BC6 C6 F8 0B      je _while36_exit
1458   0BC9             _while36_block:
1459   0BC9             ; i--; 
1460   0BC9 FA FA FF      lea d, [bp + -6] ; $i
1461   0BCC 2A            mov b, [d]
1462   0BCD 38 00 00      mov c, 0
1463   0BD0 11            mov a, b
1464   0BD1 FD 7D         dec b
1465   0BD3 FA FA FF      lea d, [bp + -6] ; $i
1466   0BD6 FD 43         mov [d], b
1467   0BD8 27            mov b, a
1468   0BD9             ; putchar(digits[i]); 
1469   0BD9             ; --- START FUNCTION CALL
1470   0BD9 FA FC FF      lea d, [bp + -4] ; $digits
1471   0BDC D7            push a
1472   0BDD DA            push d
1473   0BDE FA FA FF      lea d, [bp + -6] ; $i
1474   0BE1 2A            mov b, [d]
1475   0BE2 38 00 00      mov c, 0
1476   0BE5 E7            pop d
1477   0BE6 5A            add d, b
1478   0BE7 E4            pop a
1479   0BE8 32            mov bl, [d]
1480   0BE9 A7 00         mov bh, 0
1481   0BEB 38 00 00      mov c, 0
1482   0BEE DD            push bl
1483   0BEF 07 D9 08      call putchar
1484   0BF2 51 01 00      add sp, 1
1485   0BF5             ; --- END FUNCTION CALL
1486   0BF5 0A B0 0B      jmp _while36_cond
1487   0BF8             _while36_exit:
1488   0BF8 F9            leave
1489   0BF9 09            ret
1490   0BFA             
1491   0BFA             print_unsigned:
1492   0BFA F8 00 00      enter 0 ; (push bp; mov bp, sp)
1493   0BFD             ; char digits[5]; 
1494   0BFD 52 05 00      sub sp, 5
1495   0C00             ; int i; 
1496   0C00 52 02 00      sub sp, 2
1497   0C03             ; i = 0; 
1498   0C03 FA FA FF      lea d, [bp + -6] ; $i
1499   0C06 DA            push d
1500   0C07 FD 2E 00 00   mov32 cb, $00000000
1500   0C0B 00 00 
1501   0C0D E7            pop d
1502   0C0E FD 43         mov [d], b
1503   0C10             ; if(num == 0){ 
1504   0C10             _if37_cond:
1505   0C10 FA 05 00      lea d, [bp + 5] ; $num
1506   0C13 2A            mov b, [d]
1507   0C14 38 00 00      mov c, 0
1508   0C17             ; --- START RELATIONAL
1509   0C17 D7            push a
1510   0C18 11            mov a, b
1511   0C19 FD 2E 00 00   mov32 cb, $00000000
1511   0C1D 00 00 
1512   0C1F B0            cmp a, b
1513   0C20 FD 71         seq ; ==
1514   0C22 E4            pop a
1515   0C23             ; --- END RELATIONAL
1516   0C23 C0 00 00      cmp b, 0
1517   0C26 C6 3B 0C      je _if37_exit
1518   0C29             _if37_TRUE:
1519   0C29             ; putchar('0'); 
1520   0C29             ; --- START FUNCTION CALL
1521   0C29 FD 2E 30 00   mov32 cb, $00000030
1521   0C2D 00 00 
1522   0C2F DD            push bl
1523   0C30 07 D9 08      call putchar
1524   0C33 51 01 00      add sp, 1
1525   0C36             ; --- END FUNCTION CALL
1526   0C36             ; return; 
1527   0C36 F9            leave
1528   0C37 09            ret
1529   0C38 0A 3B 0C      jmp _if37_exit
1530   0C3B             _if37_exit:
1531   0C3B             ; while (num > 0) { 
1532   0C3B             _while38_cond:
1533   0C3B FA 05 00      lea d, [bp + 5] ; $num
1534   0C3E 2A            mov b, [d]
1535   0C3F 38 00 00      mov c, 0
1536   0C42             ; --- START RELATIONAL
1537   0C42 D7            push a
1538   0C43 11            mov a, b
1539   0C44 FD 2E 00 00   mov32 cb, $00000000
1539   0C48 00 00 
1540   0C4A B0            cmp a, b
1541   0C4B FD 81         sgu ; > (unsigned)
1542   0C4D E4            pop a
1543   0C4E             ; --- END RELATIONAL
1544   0C4E C0 00 00      cmp b, 0
1545   0C51 C6 C8 0C      je _while38_exit
1546   0C54             _while38_block:
1547   0C54             ; digits[i] = '0' + (num % 10); 
1548   0C54 FA FC FF      lea d, [bp + -4] ; $digits
1549   0C57 D7            push a
1550   0C58 DA            push d
1551   0C59 FA FA FF      lea d, [bp + -6] ; $i
1552   0C5C 2A            mov b, [d]
1553   0C5D 38 00 00      mov c, 0
1554   0C60 E7            pop d
1555   0C61 5A            add d, b
1556   0C62 E4            pop a
1557   0C63 DA            push d
1558   0C64 FD 2E 30 00   mov32 cb, $00000030
1558   0C68 00 00 
1559   0C6A             ; --- START TERMS
1560   0C6A D7            push a
1561   0C6B 11            mov a, b
1562   0C6C FA 05 00      lea d, [bp + 5] ; $num
1563   0C6F 2A            mov b, [d]
1564   0C70 38 00 00      mov c, 0
1565   0C73             ; --- START FACTORS
1566   0C73 D7            push a
1567   0C74 FD D8         push g
1568   0C76 11            mov a, b
1569   0C77 FD 7A         mov g, c
1570   0C79 FD 2E 0A 00   mov32 cb, $0000000a
1570   0C7D 00 00 
1571   0C7F FD D8         push g ; save 'g' as the div instruction uses it
1572   0C81 AE            div a, b ; %, a: quotient, b: remainder
1573   0C82 11            mov a, b
1574   0C83 FD F1         pop g
1575   0C85 FD 38         mov c, g
1576   0C87 27            mov b, a
1577   0C88 FD F1         pop g
1578   0C8A E4            pop a
1579   0C8B             ; --- END FACTORS
1580   0C8B 56            add b, a
1581   0C8C E4            pop a
1582   0C8D             ; --- END TERMS
1583   0C8D E7            pop d
1584   0C8E FD 3E         mov [d], bl
1585   0C90             ; num = num / 10; 
1586   0C90 FA 05 00      lea d, [bp + 5] ; $num
1587   0C93 DA            push d
1588   0C94 FA 05 00      lea d, [bp + 5] ; $num
1589   0C97 2A            mov b, [d]
1590   0C98 38 00 00      mov c, 0
1591   0C9B             ; --- START FACTORS
1592   0C9B D7            push a
1593   0C9C FD D8         push g
1594   0C9E 11            mov a, b
1595   0C9F FD 7A         mov g, c
1596   0CA1 FD 2E 0A 00   mov32 cb, $0000000a
1596   0CA5 00 00 
1597   0CA7 FD D8         push g ; save 'g' as the div instruction uses it
1598   0CA9 AE            div a, b ; /, a: quotient, b: remainder
1599   0CAA FD F1         pop g
1600   0CAC FD 38         mov c, g
1601   0CAE 27            mov b, a
1602   0CAF FD F1         pop g
1603   0CB1 E4            pop a
1604   0CB2             ; --- END FACTORS
1605   0CB2 E7            pop d
1606   0CB3 FD 43         mov [d], b
1607   0CB5             ; i++; 
1608   0CB5 FA FA FF      lea d, [bp + -6] ; $i
1609   0CB8 2A            mov b, [d]
1610   0CB9 38 00 00      mov c, 0
1611   0CBC 11            mov a, b
1612   0CBD FD 77         inc b
1613   0CBF FA FA FF      lea d, [bp + -6] ; $i
1614   0CC2 FD 43         mov [d], b
1615   0CC4 27            mov b, a
1616   0CC5 0A 3B 0C      jmp _while38_cond
1617   0CC8             _while38_exit:
1618   0CC8             ; while (i > 0) { 
1619   0CC8             _while45_cond:
1620   0CC8 FA FA FF      lea d, [bp + -6] ; $i
1621   0CCB 2A            mov b, [d]
1622   0CCC 38 00 00      mov c, 0
1623   0CCF             ; --- START RELATIONAL
1624   0CCF D7            push a
1625   0CD0 11            mov a, b
1626   0CD1 FD 2E 00 00   mov32 cb, $00000000
1626   0CD5 00 00 
1627   0CD7 B0            cmp a, b
1628   0CD8 FD 7F         sgt ; >
1629   0CDA E4            pop a
1630   0CDB             ; --- END RELATIONAL
1631   0CDB C0 00 00      cmp b, 0
1632   0CDE C6 10 0D      je _while45_exit
1633   0CE1             _while45_block:
1634   0CE1             ; i--; 
1635   0CE1 FA FA FF      lea d, [bp + -6] ; $i
1636   0CE4 2A            mov b, [d]
1637   0CE5 38 00 00      mov c, 0
1638   0CE8 11            mov a, b
1639   0CE9 FD 7D         dec b
1640   0CEB FA FA FF      lea d, [bp + -6] ; $i
1641   0CEE FD 43         mov [d], b
1642   0CF0 27            mov b, a
1643   0CF1             ; putchar(digits[i]); 
1644   0CF1             ; --- START FUNCTION CALL
1645   0CF1 FA FC FF      lea d, [bp + -4] ; $digits
1646   0CF4 D7            push a
1647   0CF5 DA            push d
1648   0CF6 FA FA FF      lea d, [bp + -6] ; $i
1649   0CF9 2A            mov b, [d]
1650   0CFA 38 00 00      mov c, 0
1651   0CFD E7            pop d
1652   0CFE 5A            add d, b
1653   0CFF E4            pop a
1654   0D00 32            mov bl, [d]
1655   0D01 A7 00         mov bh, 0
1656   0D03 38 00 00      mov c, 0
1657   0D06 DD            push bl
1658   0D07 07 D9 08      call putchar
1659   0D0A 51 01 00      add sp, 1
1660   0D0D             ; --- END FUNCTION CALL
1661   0D0D 0A C8 0C      jmp _while45_cond
1662   0D10             _while45_exit:
1663   0D10 F9            leave
1664   0D11 09            ret
1665   0D12             
1666   0D12             printx16:
1667   0D12 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1668   0D15             ; --- BEGIN INLINE ASM SEGMENT
1669   0D15 FA 05 00      lea d, [bp + 5] ; $hex
1670   0D18 2A            mov b, [d]
1671   0D19             print_u16x_printx16:
1672   0D19 DD            push bl
1673   0D1A 30            mov bl, bh
1674   0D1B 07 38 0D      call _itoa_printx16        ; convert bh to char in A
1675   0D1E 2F            mov bl, al        ; save al
1676   0D1F 19 00         mov al, 0
1677   0D21 05 03         syscall sys_io        ; display AH
1678   0D23 24            mov ah, bl        ; retrieve al
1679   0D24 19 00         mov al, 0
1680   0D26 05 03         syscall sys_io        ; display AL
1681   0D28 EA            pop bl
1682   0D29 07 38 0D      call _itoa_printx16        ; convert bh to char in A
1683   0D2C 2F            mov bl, al        ; save al
1684   0D2D 19 00         mov al, 0
1685   0D2F 05 03         syscall sys_io        ; display AH
1686   0D31 24            mov ah, bl        ; retrieve al
1687   0D32 19 00         mov al, 0
1688   0D34 05 03         syscall sys_io        ; display AL
1689   0D36             ; --- END INLINE ASM SEGMENT
1690   0D36             ; return; 
1691   0D36 F9            leave
1692   0D37 09            ret
1693   0D38             ; --- BEGIN INLINE ASM SEGMENT
1694   0D38             _itoa_printx16:
1695   0D38 DA            push d
1696   0D39 D8            push b
1697   0D3A A7 00         mov bh, 0
1698   0D3C FD A4 04      shr bl, 4  
1699   0D3F 74            mov d, b
1700   0D40 1F 52 0D      mov al, [d + s_hex_digits_printx16]
1701   0D43 23            mov ah, al
1702   0D44 E5            pop b
1703   0D45 D8            push b
1704   0D46 A7 00         mov bh, 0
1705   0D48 FD 87 0F      and bl, $0F
1706   0D4B 74            mov d, b
1707   0D4C 1F 52 0D      mov al, [d + s_hex_digits_printx16]
1708   0D4F E5            pop b
1709   0D50 E7            pop d
1710   0D51 09            ret
1711   0D52 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
1711   0D56 34 35 36 37 
1711   0D5A 38 39 41 42 
1711   0D5E 43 44 45 46 
1712   0D62             ; --- END INLINE ASM SEGMENT
1713   0D62 F9            leave
1714   0D63 09            ret
1715   0D64             ; --- END TEXT SEGMENT
1716   0D64             
1717   0D64             ; --- BEGIN DATA SEGMENT
1718   0D64 02 00       _a: .dw $0002
1719   0D66 48 65 6C 6C _s0: .db "Hello WorldMy name is Sol-1And this is a multi-line string", 0
1719   0D6A 6F 20 57 6F 
1719   0D6E 72 6C 64 4D 
1719   0D72 79 20 6E 61 
1719   0D76 6D 65 20 69 
1719   0D7A 73 20 53 6F 
1719   0D7E 6C 2D 31 41 
1719   0D82 6E 64 20 74 
1719   0D86 68 69 73 20 
1719   0D8A 69 73 20 61 
1719   0D8E 20 6D 75 6C 
1719   0D92 74 69 2D 6C 
1719   0D96 69 6E 65 20 
1719   0D9A 73 74 72 69 
1719   0D9E 6E 67 00 
1720   0DA1 55 6E 65 78 _s1: .db "Unexpected format in printf.", 0
1720   0DA5 70 65 63 74 
1720   0DA9 65 64 20 66 
1720   0DAD 6F 72 6D 61 
1720   0DB1 74 20 69 6E 
1720   0DB5 20 70 72 69 
1720   0DB9 6E 74 66 2E 
1720   0DBD 00 
1721   0DBE 45 72 72 6F _s2: .db "Error: Unknown argument type.\n", 0
1721   0DC2 72 3A 20 55 
1721   0DC6 6E 6B 6E 6F 
1721   0DCA 77 6E 20 61 
1721   0DCE 72 67 75 6D 
1721   0DD2 65 6E 74 20 
1721   0DD6 74 79 70 65 
1721   0DDA 2E 0A 00 
1722   0DDD             
1723   0DDD DF 0D       _heap_top: .dw _heap
1724   0DDF 00          _heap: .db 0
1725   0DE0             ; --- END DATA SEGMENT
1726   0DE0             
1727   0DE0             .end
tasm: Number of errors = 35
