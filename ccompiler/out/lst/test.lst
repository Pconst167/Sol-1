0001   0000             ; --- FILENAME: test
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; $i 
0011   0408             ; $c 
0012   0408             ; $j 
0013   0408             ; $ms 
0014   0408 52 0F 00      sub sp, 15
0015   040B             ;; i = 0xAABBCCDDL; 
0016   040B FA FD FF      lea d, [bp + -3] ; $i
0017   040E DA            push d
0018   040F 26 DD CC      mov b, $ccdd
0019   0412 38 BB AA      mov c, $aabb
0020   0415 E7            pop d
0021   0416 FD 43         mov [d], b
0022   0418 28            mov b, c
0023   0419 FD 44 02 00   mov [d + 2], b
0024   041D             ;; c = 0xAE; 
0025   041D FA FC FF      lea d, [bp + -4] ; $c
0026   0420 DA            push d
0027   0421 26 AE 00      mov b, $ae
0028   0424 E7            pop d
0029   0425 FD 3E         mov [d], bl
0030   0427             ;; j = 0x1234; 
0031   0427 FA FA FF      lea d, [bp + -6] ; $j
0032   042A DA            push d
0033   042B 26 34 12      mov b, $1234
0034   042E E7            pop d
0035   042F FD 43         mov [d], b
0036   0431             ;; ms.c = 'A'; 
0037   0431 FA F2 FF      lea d, [bp + -14] ; $ms
0038   0434 58 00 00      add d, 0
0039   0437 FD 14         clb
0040   0439 DA            push d
0041   043A 26 41 00      mov b, $41
0042   043D E7            pop d
0043   043E FD 3E         mov [d], bl
0044   0440             ;; ms.a = 65535; 
0045   0440 FA F2 FF      lea d, [bp + -14] ; $ms
0046   0443 58 01 00      add d, 1
0047   0446 FD 14         clb
0048   0448 DA            push d
0049   0449 26 FF FF      mov b, $ffff
0050   044C E7            pop d
0051   044D FD 43         mov [d], b
0052   044F             ;; ms.sp = &ms; 
0053   044F FA F2 FF      lea d, [bp + -14] ; $ms
0054   0452 58 03 00      add d, 3
0055   0455 FD 14         clb
0056   0457 DA            push d
0057   0458 FA F2 FF      lea d, [bp + -14] ; $ms
0058   045B 2D            mov b, d
0059   045C E7            pop d
0060   045D FD 43         mov [d], b
0061   045F             ;; ms.s2.cc = 'Z'; 
0062   045F FA F2 FF      lea d, [bp + -14] ; $ms
0063   0462 58 05 00      add d, 5
0064   0465 FD 14         clb
0065   0467 58 00 00      add d, 0
0066   046A FD 14         clb
0067   046C DA            push d
0068   046D 26 5A 00      mov b, $5a
0069   0470 E7            pop d
0070   0471 FD 3E         mov [d], bl
0071   0473             ;; ms.s2.aa = 32765; 
0072   0473 FA F2 FF      lea d, [bp + -14] ; $ms
0073   0476 58 05 00      add d, 5
0074   0479 FD 14         clb
0075   047B 58 01 00      add d, 1
0076   047E FD 14         clb
0077   0480 DA            push d
0078   0481 26 FD 7F      mov b, $7ffd
0079   0484 E7            pop d
0080   0485 FD 43         mov [d], b
0081   0487             ;; printf("Value: %c\n", ms.c); 
0082   0487 FA F2 FF      lea d, [bp + -14] ; $ms
0083   048A 58 00 00      add d, 0
0084   048D FD 14         clb
0085   048F 32            mov bl, [d]
0086   0490 A7 00         mov bh, 0
0087   0492 FD AB         swp b
0088   0494 D8            push b
0089   0495 26 FD 14      mov b, __s0 ; "Value: %c\n"
0090   0498 FD AB         swp b
0091   049A D8            push b
0092   049B 07 CA 06      call printf
0093   049E 51 04 00      add sp, 4
0094   04A1             ;; printf("Value: %d\n", ms.a); 
0095   04A1 FA F2 FF      lea d, [bp + -14] ; $ms
0096   04A4 58 01 00      add d, 1
0097   04A7 FD 14         clb
0098   04A9 2A            mov b, [d]
0099   04AA FD AB         swp b
0100   04AC D8            push b
0101   04AD 26 08 15      mov b, __s1 ; "Value: %d\n"
0102   04B0 FD AB         swp b
0103   04B2 D8            push b
0104   04B3 07 CA 06      call printf
0105   04B6 51 04 00      add sp, 4
0106   04B9             ;; printf("Value: %x\n", ms.sp); 
0107   04B9 FA F2 FF      lea d, [bp + -14] ; $ms
0108   04BC 58 03 00      add d, 3
0109   04BF FD 14         clb
0110   04C1 2A            mov b, [d]
0111   04C2 FD AB         swp b
0112   04C4 D8            push b
0113   04C5 26 13 15      mov b, __s2 ; "Value: %x\n"
0114   04C8 FD AB         swp b
0115   04CA D8            push b
0116   04CB 07 CA 06      call printf
0117   04CE 51 04 00      add sp, 4
0118   04D1             ;; printf("Value: %c\n", ms.s2.cc); 
0119   04D1 FA F2 FF      lea d, [bp + -14] ; $ms
0120   04D4 58 05 00      add d, 5
0121   04D7 FD 14         clb
0122   04D9 58 00 00      add d, 0
0123   04DC FD 14         clb
0124   04DE 32            mov bl, [d]
0125   04DF A7 00         mov bh, 0
0126   04E1 FD AB         swp b
0127   04E3 D8            push b
0128   04E4 26 FD 14      mov b, __s0 ; "Value: %c\n"
0129   04E7 FD AB         swp b
0130   04E9 D8            push b
0131   04EA 07 CA 06      call printf
0132   04ED 51 04 00      add sp, 4
0133   04F0             ;; printf("Value: %d\n", ms.s2.aa); 
0134   04F0 FA F2 FF      lea d, [bp + -14] ; $ms
0135   04F3 58 05 00      add d, 5
0136   04F6 FD 14         clb
0137   04F8 58 01 00      add d, 1
0138   04FB FD 14         clb
0139   04FD 2A            mov b, [d]
0140   04FE FD AB         swp b
0141   0500 D8            push b
0142   0501 26 08 15      mov b, __s1 ; "Value: %d\n"
0143   0504 FD AB         swp b
0144   0506 D8            push b
0145   0507 07 CA 06      call printf
0146   050A 51 04 00      add sp, 4
0147   050D 05 0B         syscall sys_terminate_proc
0148   050F             
0149   050F             strcpy:
0150   050F F8 00 00      enter 0 ; (push bp; mov bp, sp)
0151   0512             ; $psrc 
0152   0512             ; $pdest 
0153   0512 52 04 00      sub sp, 4
0154   0515             ;; psrc = src; 
0155   0515 FA FF FF      lea d, [bp + -1] ; $psrc
0156   0518 DA            push d
0157   0519 FA 07 00      lea d, [bp + 7] ; $src
0158   051C 2A            mov b, [d]
0159   051D E7            pop d
0160   051E FD 43         mov [d], b
0161   0520             ;; pdest = dest; 
0162   0520 FA FD FF      lea d, [bp + -3] ; $pdest
0163   0523 DA            push d
0164   0524 FA 05 00      lea d, [bp + 5] ; $dest
0165   0527 2A            mov b, [d]
0166   0528 E7            pop d
0167   0529 FD 43         mov [d], b
0168   052B             ;; while(*psrc) *pdest++ = *psrc++; 
0169   052B             _while1_cond:
0170   052B FA FF FF      lea d, [bp + -1] ; $psrc
0171   052E 2A            mov b, [d]
0172   052F 74            mov d, b
0173   0530 32            mov bl, [d]
0174   0531 A7 00         mov bh, 0
0175   0533 C0 00 00      cmp b, 0
0176   0536 C6 5E 05      je _while1_exit
0177   0539             _while1_block:
0178   0539             ;; *pdest++ = *psrc++; 
0179   0539 FA FD FF      lea d, [bp + -3] ; $pdest
0180   053C 2A            mov b, [d]
0181   053D D8            push b
0182   053E FD 77         inc b
0183   0540 FA FD FF      lea d, [bp + -3] ; $pdest
0184   0543 FD 43         mov [d], b
0185   0545 E5            pop b
0186   0546 D8            push b
0187   0547 FA FF FF      lea d, [bp + -1] ; $psrc
0188   054A 2A            mov b, [d]
0189   054B D8            push b
0190   054C FD 77         inc b
0191   054E FA FF FF      lea d, [bp + -1] ; $psrc
0192   0551 FD 43         mov [d], b
0193   0553 E5            pop b
0194   0554 74            mov d, b
0195   0555 32            mov bl, [d]
0196   0556 A7 00         mov bh, 0
0197   0558 E7            pop d
0198   0559 FD 3E         mov [d], bl
0199   055B 0A 2B 05      jmp _while1_cond
0200   055E             _while1_exit:
0201   055E             ;; *pdest = '\0'; 
0202   055E FA FD FF      lea d, [bp + -3] ; $pdest
0203   0561 2A            mov b, [d]
0204   0562 D8            push b
0205   0563 26 00 00      mov b, $0
0206   0566 E7            pop d
0207   0567 FD 3E         mov [d], bl
0208   0569 F9            leave
0209   056A 09            ret
0210   056B             
0211   056B             strcmp:
0212   056B F8 00 00      enter 0 ; (push bp; mov bp, sp)
0213   056E             ;; while (*s1 && (*s1 == *s2)) { 
0214   056E             _while2_cond:
0215   056E FA 05 00      lea d, [bp + 5] ; $s1
0216   0571 2A            mov b, [d]
0217   0572 74            mov d, b
0218   0573 32            mov bl, [d]
0219   0574 A7 00         mov bh, 0
0220   0576 D7            push a
0221   0577 11            mov a, b
0222   0578 FA 05 00      lea d, [bp + 5] ; $s1
0223   057B 2A            mov b, [d]
0224   057C 74            mov d, b
0225   057D 32            mov bl, [d]
0226   057E A7 00         mov bh, 0
0227   0580             ; START RELATIONAL
0228   0580 D7            push a
0229   0581 11            mov a, b
0230   0582 FA 07 00      lea d, [bp + 7] ; $s2
0231   0585 2A            mov b, [d]
0232   0586 74            mov d, b
0233   0587 32            mov bl, [d]
0234   0588 A7 00         mov bh, 0
0235   058A B0            cmp a, b
0236   058B FD 71         seq ; ==
0237   058D E4            pop a
0238   058E             ; END RELATIONAL
0239   058E FD A7         sand a, b ; &&
0240   0590 E4            pop a
0241   0591 C0 00 00      cmp b, 0
0242   0594 C6 B4 05      je _while2_exit
0243   0597             _while2_block:
0244   0597             ;; s1++; 
0245   0597 FA 05 00      lea d, [bp + 5] ; $s1
0246   059A 2A            mov b, [d]
0247   059B D8            push b
0248   059C FD 77         inc b
0249   059E FA 05 00      lea d, [bp + 5] ; $s1
0250   05A1 FD 43         mov [d], b
0251   05A3 E5            pop b
0252   05A4             ;; s2++; 
0253   05A4 FA 07 00      lea d, [bp + 7] ; $s2
0254   05A7 2A            mov b, [d]
0255   05A8 D8            push b
0256   05A9 FD 77         inc b
0257   05AB FA 07 00      lea d, [bp + 7] ; $s2
0258   05AE FD 43         mov [d], b
0259   05B0 E5            pop b
0260   05B1 0A 6E 05      jmp _while2_cond
0261   05B4             _while2_exit:
0262   05B4             ;; return *s1 - *s2; 
0263   05B4 FA 05 00      lea d, [bp + 5] ; $s1
0264   05B7 2A            mov b, [d]
0265   05B8 74            mov d, b
0266   05B9 32            mov bl, [d]
0267   05BA A7 00         mov bh, 0
0268   05BC             ; START TERMS
0269   05BC D7            push a
0270   05BD 11            mov a, b
0271   05BE FA 07 00      lea d, [bp + 7] ; $s2
0272   05C1 2A            mov b, [d]
0273   05C2 74            mov d, b
0274   05C3 32            mov bl, [d]
0275   05C4 A7 00         mov bh, 0
0276   05C6 60            sub a, b
0277   05C7 27            mov b, a
0278   05C8 E4            pop a
0279   05C9             ; END TERMS
0280   05C9 F9            leave
0281   05CA 09            ret
0282   05CB             
0283   05CB             strcat:
0284   05CB F8 00 00      enter 0 ; (push bp; mov bp, sp)
0285   05CE             ; $dest_len 
0286   05CE             ; $i 
0287   05CE 52 04 00      sub sp, 4
0288   05D1             ;; dest_len = strlen(dest); 
0289   05D1 FA FF FF      lea d, [bp + -1] ; $dest_len
0290   05D4 DA            push d
0291   05D5 FA 05 00      lea d, [bp + 5] ; $dest
0292   05D8 2A            mov b, [d]
0293   05D9 FD AB         swp b
0294   05DB D8            push b
0295   05DC 07 81 06      call strlen
0296   05DF 51 02 00      add sp, 2
0297   05E2 E7            pop d
0298   05E3 FD 43         mov [d], b
0299   05E5             ;; for (i = 0; src[i] != 0; i=i+1) { 
0300   05E5             _for3_init:
0301   05E5 FA FD FF      lea d, [bp + -3] ; $i
0302   05E8 DA            push d
0303   05E9 26 00 00      mov b, $0
0304   05EC E7            pop d
0305   05ED FD 43         mov [d], b
0306   05EF             _for3_cond:
0307   05EF FA 07 00      lea d, [bp + 7] ; $src
0308   05F2 FD 2A         mov d, [d]
0309   05F4 D7            push a
0310   05F5 DA            push d
0311   05F6 FA FD FF      lea d, [bp + -3] ; $i
0312   05F9 2A            mov b, [d]
0313   05FA E7            pop d
0314   05FB FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0315   05FF E4            pop a
0316   0600 32            mov bl, [d]
0317   0601 A7 00         mov bh, 0
0318   0603             ; START RELATIONAL
0319   0603 D7            push a
0320   0604 11            mov a, b
0321   0605 26 00 00      mov b, $0
0322   0608 B0            cmp a, b
0323   0609 FD 72         sneq ; !=
0324   060B E4            pop a
0325   060C             ; END RELATIONAL
0326   060C C0 00 00      cmp b, 0
0327   060F C6 5A 06      je _for3_exit
0328   0612             _for3_block:
0329   0612             ;; dest[dest_len + i] = src[i]; 
0330   0612 FA 05 00      lea d, [bp + 5] ; $dest
0331   0615 FD 2A         mov d, [d]
0332   0617 D7            push a
0333   0618 DA            push d
0334   0619 FA FF FF      lea d, [bp + -1] ; $dest_len
0335   061C 2A            mov b, [d]
0336   061D             ; START TERMS
0337   061D D7            push a
0338   061E 11            mov a, b
0339   061F FA FD FF      lea d, [bp + -3] ; $i
0340   0622 2A            mov b, [d]
0341   0623 54            add a, b
0342   0624 27            mov b, a
0343   0625 E4            pop a
0344   0626             ; END TERMS
0345   0626 E7            pop d
0346   0627 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0347   062B E4            pop a
0348   062C DA            push d
0349   062D FA 07 00      lea d, [bp + 7] ; $src
0350   0630 FD 2A         mov d, [d]
0351   0632 D7            push a
0352   0633 DA            push d
0353   0634 FA FD FF      lea d, [bp + -3] ; $i
0354   0637 2A            mov b, [d]
0355   0638 E7            pop d
0356   0639 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0357   063D E4            pop a
0358   063E 32            mov bl, [d]
0359   063F A7 00         mov bh, 0
0360   0641 E7            pop d
0361   0642 FD 3E         mov [d], bl
0362   0644             _for3_update:
0363   0644 FA FD FF      lea d, [bp + -3] ; $i
0364   0647 DA            push d
0365   0648 FA FD FF      lea d, [bp + -3] ; $i
0366   064B 2A            mov b, [d]
0367   064C             ; START TERMS
0368   064C D7            push a
0369   064D 11            mov a, b
0370   064E 26 01 00      mov b, $1
0371   0651 54            add a, b
0372   0652 27            mov b, a
0373   0653 E4            pop a
0374   0654             ; END TERMS
0375   0654 E7            pop d
0376   0655 FD 43         mov [d], b
0377   0657 0A EF 05      jmp _for3_cond
0378   065A             _for3_exit:
0379   065A             ;; dest[dest_len + i] = 0; 
0380   065A FA 05 00      lea d, [bp + 5] ; $dest
0381   065D FD 2A         mov d, [d]
0382   065F D7            push a
0383   0660 DA            push d
0384   0661 FA FF FF      lea d, [bp + -1] ; $dest_len
0385   0664 2A            mov b, [d]
0386   0665             ; START TERMS
0387   0665 D7            push a
0388   0666 11            mov a, b
0389   0667 FA FD FF      lea d, [bp + -3] ; $i
0390   066A 2A            mov b, [d]
0391   066B 54            add a, b
0392   066C 27            mov b, a
0393   066D E4            pop a
0394   066E             ; END TERMS
0395   066E E7            pop d
0396   066F FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0397   0673 E4            pop a
0398   0674 DA            push d
0399   0675 26 00 00      mov b, $0
0400   0678 E7            pop d
0401   0679 FD 3E         mov [d], bl
0402   067B             ;; return dest; 
0403   067B FA 05 00      lea d, [bp + 5] ; $dest
0404   067E 2A            mov b, [d]
0405   067F F9            leave
0406   0680 09            ret
0407   0681             
0408   0681             strlen:
0409   0681 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0410   0684             ; $length 
0411   0684 52 02 00      sub sp, 2
0412   0687             ;; length = 0; 
0413   0687 FA FF FF      lea d, [bp + -1] ; $length
0414   068A DA            push d
0415   068B 26 00 00      mov b, $0
0416   068E E7            pop d
0417   068F FD 43         mov [d], b
0418   0691             ;; while (str[length] != 0) { 
0419   0691             _while4_cond:
0420   0691 FA 05 00      lea d, [bp + 5] ; $str
0421   0694 FD 2A         mov d, [d]
0422   0696 D7            push a
0423   0697 DA            push d
0424   0698 FA FF FF      lea d, [bp + -1] ; $length
0425   069B 2A            mov b, [d]
0426   069C E7            pop d
0427   069D FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0428   06A1 E4            pop a
0429   06A2 32            mov bl, [d]
0430   06A3 A7 00         mov bh, 0
0431   06A5             ; START RELATIONAL
0432   06A5 D7            push a
0433   06A6 11            mov a, b
0434   06A7 26 00 00      mov b, $0
0435   06AA B0            cmp a, b
0436   06AB FD 72         sneq ; !=
0437   06AD E4            pop a
0438   06AE             ; END RELATIONAL
0439   06AE C0 00 00      cmp b, 0
0440   06B1 C6 C4 06      je _while4_exit
0441   06B4             _while4_block:
0442   06B4             ;; length++; 
0443   06B4 FA FF FF      lea d, [bp + -1] ; $length
0444   06B7 2A            mov b, [d]
0445   06B8 D8            push b
0446   06B9 FD 77         inc b
0447   06BB FA FF FF      lea d, [bp + -1] ; $length
0448   06BE FD 43         mov [d], b
0449   06C0 E5            pop b
0450   06C1 0A 91 06      jmp _while4_cond
0451   06C4             _while4_exit:
0452   06C4             ;; return length; 
0453   06C4 FA FF FF      lea d, [bp + -1] ; $length
0454   06C7 2A            mov b, [d]
0455   06C8 F9            leave
0456   06C9 09            ret
0457   06CA             
0458   06CA             printf:
0459   06CA F8 00 00      enter 0 ; (push bp; mov bp, sp)
0460   06CD             ; $p 
0461   06CD             ; $fp 
0462   06CD             ; $i 
0463   06CD 52 06 00      sub sp, 6
0464   06D0             ;; fp = format; 
0465   06D0 FA FD FF      lea d, [bp + -3] ; $fp
0466   06D3 DA            push d
0467   06D4 FA 05 00      lea d, [bp + 5] ; $format
0468   06D7 2A            mov b, [d]
0469   06D8 E7            pop d
0470   06D9 FD 43         mov [d], b
0471   06DB             ;; p = &format + 2; 
0472   06DB FA FF FF      lea d, [bp + -1] ; $p
0473   06DE DA            push d
0474   06DF FA 05 00      lea d, [bp + 5] ; $format
0475   06E2 2D            mov b, d
0476   06E3             ; START TERMS
0477   06E3 D7            push a
0478   06E4 11            mov a, b
0479   06E5 26 02 00      mov b, $2
0480   06E8 54            add a, b
0481   06E9 27            mov b, a
0482   06EA E4            pop a
0483   06EB             ; END TERMS
0484   06EB E7            pop d
0485   06EC FD 43         mov [d], b
0486   06EE             ;; for(;;){ 
0487   06EE             _for5_init:
0488   06EE             _for5_cond:
0489   06EE             _for5_block:
0490   06EE             ;; if(!*fp) break; 
0491   06EE             _if6_cond:
0492   06EE FA FD FF      lea d, [bp + -3] ; $fp
0493   06F1 2A            mov b, [d]
0494   06F2 74            mov d, b
0495   06F3 32            mov bl, [d]
0496   06F4 A7 00         mov bh, 0
0497   06F6 C0 00 00      cmp b, 0
0498   06F9 FD 71         seq ; !
0499   06FB C0 00 00      cmp b, 0
0500   06FE C6 07 07      je _if6_else
0501   0701             _if6_true:
0502   0701             ;; break; 
0503   0701 0A 26 09      jmp _for5_exit ; for break
0504   0704 0A 23 09      jmp _if6_exit
0505   0707             _if6_else:
0506   0707             ;; if(*fp == '%'){ 
0507   0707             _if7_cond:
0508   0707 FA FD FF      lea d, [bp + -3] ; $fp
0509   070A 2A            mov b, [d]
0510   070B 74            mov d, b
0511   070C 32            mov bl, [d]
0512   070D A7 00         mov bh, 0
0513   070F             ; START RELATIONAL
0514   070F D7            push a
0515   0710 11            mov a, b
0516   0711 26 25 00      mov b, $25
0517   0714 B0            cmp a, b
0518   0715 FD 71         seq ; ==
0519   0717 E4            pop a
0520   0718             ; END RELATIONAL
0521   0718 C0 00 00      cmp b, 0
0522   071B C6 07 09      je _if7_else
0523   071E             _if7_true:
0524   071E             ;; fp++; 
0525   071E FA FD FF      lea d, [bp + -3] ; $fp
0526   0721 2A            mov b, [d]
0527   0722 D8            push b
0528   0723 FD 77         inc b
0529   0725 FA FD FF      lea d, [bp + -3] ; $fp
0530   0728 FD 43         mov [d], b
0531   072A E5            pop b
0532   072B             ;; switch(*fp){ 
0533   072B             _switch8_expr:
0534   072B FA FD FF      lea d, [bp + -3] ; $fp
0535   072E 2A            mov b, [d]
0536   072F 74            mov d, b
0537   0730 32            mov bl, [d]
0538   0731 A7 00         mov bh, 0
0539   0733             _switch8_comparisons:
0540   0733 C1 6C         cmp bl, $6c
0541   0735 C6 61 07      je _switch8_case0
0542   0738 C1 4C         cmp bl, $4c
0543   073A C6 61 07      je _switch8_case1
0544   073D C1 64         cmp bl, $64
0545   073F C6 34 08      je _switch8_case2
0546   0742 C1 69         cmp bl, $69
0547   0744 C6 34 08      je _switch8_case3
0548   0747 C1 75         cmp bl, $75
0549   0749 C6 59 08      je _switch8_case4
0550   074C C1 78         cmp bl, $78
0551   074E C6 7E 08      je _switch8_case5
0552   0751 C1 63         cmp bl, $63
0553   0753 C6 A3 08      je _switch8_case6
0554   0756 C1 73         cmp bl, $73
0555   0758 C6 C8 08      je _switch8_case7
0556   075B 0A EB 08      jmp _switch8_default
0557   075E 0A F7 08      jmp _switch8_exit
0558   0761             _switch8_case0:
0559   0761             _switch8_case1:
0560   0761             ;; fp++; 
0561   0761 FA FD FF      lea d, [bp + -3] ; $fp
0562   0764 2A            mov b, [d]
0563   0765 D8            push b
0564   0766 FD 77         inc b
0565   0768 FA FD FF      lea d, [bp + -3] ; $fp
0566   076B FD 43         mov [d], b
0567   076D E5            pop b
0568   076E             ;; if(*fp == 'd' || *fp == 'i') 
0569   076E             _if9_cond:
0570   076E FA FD FF      lea d, [bp + -3] ; $fp
0571   0771 2A            mov b, [d]
0572   0772 74            mov d, b
0573   0773 32            mov bl, [d]
0574   0774 A7 00         mov bh, 0
0575   0776             ; START RELATIONAL
0576   0776 D7            push a
0577   0777 11            mov a, b
0578   0778 26 64 00      mov b, $64
0579   077B B0            cmp a, b
0580   077C FD 71         seq ; ==
0581   077E E4            pop a
0582   077F             ; END RELATIONAL
0583   077F D7            push a
0584   0780 11            mov a, b
0585   0781 FA FD FF      lea d, [bp + -3] ; $fp
0586   0784 2A            mov b, [d]
0587   0785 74            mov d, b
0588   0786 32            mov bl, [d]
0589   0787 A7 00         mov bh, 0
0590   0789             ; START RELATIONAL
0591   0789 D7            push a
0592   078A 11            mov a, b
0593   078B 26 69 00      mov b, $69
0594   078E B0            cmp a, b
0595   078F FD 71         seq ; ==
0596   0791 E4            pop a
0597   0792             ; END RELATIONAL
0598   0792 FD A8         sor a, b ; ||
0599   0794 E4            pop a
0600   0795 C0 00 00      cmp b, 0
0601   0798 C6 B0 07      je _if9_else
0602   079B             _if9_true:
0603   079B             ;; print_signed_long(*(long *)p); 
0604   079B 74            mov d, b
0605   079C FD 79         mov g, b
0606   079E 28            mov b, c
0607   079F FD AB         swp b
0608   07A1 D8            push b
0609   07A2 FD 27         mov b, g
0610   07A4 FD AB         swp b
0611   07A6 D8            push b
0612   07A7 07 CA 0C      call print_signed_long
0613   07AA 51 04 00      add sp, 4
0614   07AD 0A 1E 08      jmp _if9_exit
0615   07B0             _if9_else:
0616   07B0             ;; if(*fp == 'u') 
0617   07B0             _if10_cond:
0618   07B0 FA FD FF      lea d, [bp + -3] ; $fp
0619   07B3 2A            mov b, [d]
0620   07B4 74            mov d, b
0621   07B5 32            mov bl, [d]
0622   07B6 A7 00         mov bh, 0
0623   07B8             ; START RELATIONAL
0624   07B8 D7            push a
0625   07B9 11            mov a, b
0626   07BA 26 75 00      mov b, $75
0627   07BD B0            cmp a, b
0628   07BE FD 71         seq ; ==
0629   07C0 E4            pop a
0630   07C1             ; END RELATIONAL
0631   07C1 C0 00 00      cmp b, 0
0632   07C4 C6 DC 07      je _if10_else
0633   07C7             _if10_true:
0634   07C7             ;; print_unsigned_long(*(unsigned long *)p); 
0635   07C7 74            mov d, b
0636   07C8 FD 79         mov g, b
0637   07CA 28            mov b, c
0638   07CB FD AB         swp b
0639   07CD D8            push b
0640   07CE FD 27         mov b, g
0641   07D0 FD AB         swp b
0642   07D2 D8            push b
0643   07D3 07 FF 0D      call print_unsigned_long
0644   07D6 51 04 00      add sp, 4
0645   07D9 0A 1E 08      jmp _if10_exit
0646   07DC             _if10_else:
0647   07DC             ;; if(*fp == 'x') 
0648   07DC             _if11_cond:
0649   07DC FA FD FF      lea d, [bp + -3] ; $fp
0650   07DF 2A            mov b, [d]
0651   07E0 74            mov d, b
0652   07E1 32            mov bl, [d]
0653   07E2 A7 00         mov bh, 0
0654   07E4             ; START RELATIONAL
0655   07E4 D7            push a
0656   07E5 11            mov a, b
0657   07E6 26 78 00      mov b, $78
0658   07E9 B0            cmp a, b
0659   07EA FD 71         seq ; ==
0660   07EC E4            pop a
0661   07ED             ; END RELATIONAL
0662   07ED C0 00 00      cmp b, 0
0663   07F0 C6 12 08      je _if11_else
0664   07F3             _if11_true:
0665   07F3             ;; printx32(*(long int *)p); 
0666   07F3 FA FF FF      lea d, [bp + -1] ; $p
0667   07F6 2A            mov b, [d]
0668   07F7 74            mov d, b
0669   07F8 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0670   07FB FD 39         mov c, b ; And place it into C
0671   07FD 2A            mov b, [d] ; Lower Word in B
0672   07FE FD 79         mov g, b
0673   0800 28            mov b, c
0674   0801 FD AB         swp b
0675   0803 D8            push b
0676   0804 FD 27         mov b, g
0677   0806 FD AB         swp b
0678   0808 D8            push b
0679   0809 07 3D 09      call printx32
0680   080C 51 04 00      add sp, 4
0681   080F 0A 1E 08      jmp _if11_exit
0682   0812             _if11_else:
0683   0812             ;; err("Unexpected format in printf."); 
0684   0812 26 1E 15      mov b, __s3 ; "Unexpected format in printf."
0685   0815 FD AB         swp b
0686   0817 D8            push b
0687   0818 07 28 09      call err
0688   081B 51 02 00      add sp, 2
0689   081E             _if11_exit:
0690   081E             _if10_exit:
0691   081E             _if9_exit:
0692   081E             ;; p = p + 4; 
0693   081E FA FF FF      lea d, [bp + -1] ; $p
0694   0821 DA            push d
0695   0822 FA FF FF      lea d, [bp + -1] ; $p
0696   0825 2A            mov b, [d]
0697   0826             ; START TERMS
0698   0826 D7            push a
0699   0827 11            mov a, b
0700   0828 26 04 00      mov b, $4
0701   082B 54            add a, b
0702   082C 27            mov b, a
0703   082D E4            pop a
0704   082E             ; END TERMS
0705   082E E7            pop d
0706   082F FD 43         mov [d], b
0707   0831             ;; break; 
0708   0831 0A F7 08      jmp _switch8_exit ; case break
0709   0834             _switch8_case2:
0710   0834             _switch8_case3:
0711   0834             ;; print_signed(*(int*)p); 
0712   0834 FA FF FF      lea d, [bp + -1] ; $p
0713   0837 2A            mov b, [d]
0714   0838 74            mov d, b
0715   0839 2A            mov b, [d]
0716   083A FD AB         swp b
0717   083C D8            push b
0718   083D 07 D9 0B      call print_signed
0719   0840 51 02 00      add sp, 2
0720   0843             ;; p = p + 2; 
0721   0843 FA FF FF      lea d, [bp + -1] ; $p
0722   0846 DA            push d
0723   0847 FA FF FF      lea d, [bp + -1] ; $p
0724   084A 2A            mov b, [d]
0725   084B             ; START TERMS
0726   084B D7            push a
0727   084C 11            mov a, b
0728   084D 26 02 00      mov b, $2
0729   0850 54            add a, b
0730   0851 27            mov b, a
0731   0852 E4            pop a
0732   0853             ; END TERMS
0733   0853 E7            pop d
0734   0854 FD 43         mov [d], b
0735   0856             ;; break; 
0736   0856 0A F7 08      jmp _switch8_exit ; case break
0737   0859             _switch8_case4:
0738   0859             ;; print_unsigned(*(unsigned int*)p); 
0739   0859 FA FF FF      lea d, [bp + -1] ; $p
0740   085C 2A            mov b, [d]
0741   085D 74            mov d, b
0742   085E 2A            mov b, [d]
0743   085F FD AB         swp b
0744   0861 D8            push b
0745   0862 07 F6 0E      call print_unsigned
0746   0865 51 02 00      add sp, 2
0747   0868             ;; p = p + 2; 
0748   0868 FA FF FF      lea d, [bp + -1] ; $p
0749   086B DA            push d
0750   086C FA FF FF      lea d, [bp + -1] ; $p
0751   086F 2A            mov b, [d]
0752   0870             ; START TERMS
0753   0870 D7            push a
0754   0871 11            mov a, b
0755   0872 26 02 00      mov b, $2
0756   0875 54            add a, b
0757   0876 27            mov b, a
0758   0877 E4            pop a
0759   0878             ; END TERMS
0760   0878 E7            pop d
0761   0879 FD 43         mov [d], b
0762   087B             ;; break; 
0763   087B 0A F7 08      jmp _switch8_exit ; case break
0764   087E             _switch8_case5:
0765   087E             ;; printx16(*(unsigned int*)p); 
0766   087E FA FF FF      lea d, [bp + -1] ; $p
0767   0881 2A            mov b, [d]
0768   0882 74            mov d, b
0769   0883 2A            mov b, [d]
0770   0884 FD AB         swp b
0771   0886 D8            push b
0772   0887 07 4F 09      call printx16
0773   088A 51 02 00      add sp, 2
0774   088D             ;; p = p + 2; 
0775   088D FA FF FF      lea d, [bp + -1] ; $p
0776   0890 DA            push d
0777   0891 FA FF FF      lea d, [bp + -1] ; $p
0778   0894 2A            mov b, [d]
0779   0895             ; START TERMS
0780   0895 D7            push a
0781   0896 11            mov a, b
0782   0897 26 02 00      mov b, $2
0783   089A 54            add a, b
0784   089B 27            mov b, a
0785   089C E4            pop a
0786   089D             ; END TERMS
0787   089D E7            pop d
0788   089E FD 43         mov [d], b
0789   08A0             ;; break; 
0790   08A0 0A F7 08      jmp _switch8_exit ; case break
0791   08A3             _switch8_case6:
0792   08A3             ;; putchar(*(char*)p); 
0793   08A3 FA FF FF      lea d, [bp + -1] ; $p
0794   08A6 2A            mov b, [d]
0795   08A7 74            mov d, b
0796   08A8 32            mov bl, [d]
0797   08A9 A7 00         mov bh, 0
0798   08AB DD            push bl
0799   08AC 07 DE 0F      call putchar
0800   08AF 51 01 00      add sp, 1
0801   08B2             ;; p = p + 2; 
0802   08B2 FA FF FF      lea d, [bp + -1] ; $p
0803   08B5 DA            push d
0804   08B6 FA FF FF      lea d, [bp + -1] ; $p
0805   08B9 2A            mov b, [d]
0806   08BA             ; START TERMS
0807   08BA D7            push a
0808   08BB 11            mov a, b
0809   08BC 26 02 00      mov b, $2
0810   08BF 54            add a, b
0811   08C0 27            mov b, a
0812   08C1 E4            pop a
0813   08C2             ; END TERMS
0814   08C2 E7            pop d
0815   08C3 FD 43         mov [d], b
0816   08C5             ;; break; 
0817   08C5 0A F7 08      jmp _switch8_exit ; case break
0818   08C8             _switch8_case7:
0819   08C8             ;; print((char*)p); 
0820   08C8 FA FF FF      lea d, [bp + -1] ; $p
0821   08CB 2A            mov b, [d]
0822   08CC FD AB         swp b
0823   08CE D8            push b
0824   08CF 07 26 10      call print
0825   08D2 51 02 00      add sp, 2
0826   08D5             ;; p = p + 2; 
0827   08D5 FA FF FF      lea d, [bp + -1] ; $p
0828   08D8 DA            push d
0829   08D9 FA FF FF      lea d, [bp + -1] ; $p
0830   08DC 2A            mov b, [d]
0831   08DD             ; START TERMS
0832   08DD D7            push a
0833   08DE 11            mov a, b
0834   08DF 26 02 00      mov b, $2
0835   08E2 54            add a, b
0836   08E3 27            mov b, a
0837   08E4 E4            pop a
0838   08E5             ; END TERMS
0839   08E5 E7            pop d
0840   08E6 FD 43         mov [d], b
0841   08E8             ;; break; 
0842   08E8 0A F7 08      jmp _switch8_exit ; case break
0843   08EB             _switch8_default:
0844   08EB             ;; print("Error: Unknown argument type.\n"); 
0845   08EB 26 3B 15      mov b, __s4 ; "Error: Unknown argument type.\n"
0846   08EE FD AB         swp b
0847   08F0 D8            push b
0848   08F1 07 26 10      call print
0849   08F4 51 02 00      add sp, 2
0850   08F7             _switch8_exit:
0851   08F7             ;; fp++; 
0852   08F7 FA FD FF      lea d, [bp + -3] ; $fp
0853   08FA 2A            mov b, [d]
0854   08FB D8            push b
0855   08FC FD 77         inc b
0856   08FE FA FD FF      lea d, [bp + -3] ; $fp
0857   0901 FD 43         mov [d], b
0858   0903 E5            pop b
0859   0904 0A 23 09      jmp _if7_exit
0860   0907             _if7_else:
0861   0907             ;; putchar(*fp); 
0862   0907 FA FD FF      lea d, [bp + -3] ; $fp
0863   090A 2A            mov b, [d]
0864   090B 74            mov d, b
0865   090C 32            mov bl, [d]
0866   090D A7 00         mov bh, 0
0867   090F DD            push bl
0868   0910 07 DE 0F      call putchar
0869   0913 51 01 00      add sp, 1
0870   0916             ;; fp++; 
0871   0916 FA FD FF      lea d, [bp + -3] ; $fp
0872   0919 2A            mov b, [d]
0873   091A D8            push b
0874   091B FD 77         inc b
0875   091D FA FD FF      lea d, [bp + -3] ; $fp
0876   0920 FD 43         mov [d], b
0877   0922 E5            pop b
0878   0923             _if7_exit:
0879   0923             _if6_exit:
0880   0923             _for5_update:
0881   0923 0A EE 06      jmp _for5_cond
0882   0926             _for5_exit:
0883   0926 F9            leave
0884   0927 09            ret
0885   0928             
0886   0928             err:
0887   0928 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0888   092B             ;; print(e); 
0889   092B FA 05 00      lea d, [bp + 5] ; $e
0890   092E 2A            mov b, [d]
0891   092F FD AB         swp b
0892   0931 D8            push b
0893   0932 07 26 10      call print
0894   0935 51 02 00      add sp, 2
0895   0938             ;; exit(); 
0896   0938 07 A0 10      call exit
0897   093B F9            leave
0898   093C 09            ret
0899   093D             
0900   093D             printx32:
0901   093D F8 00 00      enter 0 ; (push bp; mov bp, sp)
0902   0940             
0903   0940             ; --- BEGIN INLINE ASM BLOCK
0904   0940 FA 05 00      lea d, [bp + 5] ; $hex
0905   0943 2B 02 00      mov b, [d+2]
0906   0946 07 FD 13      call print_u16x
0907   0949 2A            mov b, [d]
0908   094A 07 FD 13      call print_u16x
0909   094D             ; --- END INLINE ASM BLOCK
0910   094D             
0911   094D F9            leave
0912   094E 09            ret
0913   094F             
0914   094F             printx16:
0915   094F F8 00 00      enter 0 ; (push bp; mov bp, sp)
0916   0952             
0917   0952             ; --- BEGIN INLINE ASM BLOCK
0918   0952 FA 05 00      lea d, [bp + 5] ; $hex
0919   0955 2A            mov b, [d]
0920   0956 07 FD 13      call print_u16x
0921   0959             ; --- END INLINE ASM BLOCK
0922   0959             
0923   0959 F9            leave
0924   095A 09            ret
0925   095B             
0926   095B             printx8:
0927   095B F8 00 00      enter 0 ; (push bp; mov bp, sp)
0928   095E             
0929   095E             ; --- BEGIN INLINE ASM BLOCK
0930   095E FA 05 00      lea d, [bp + 5] ; $hex
0931   0961 32            mov bl, [d]
0932   0962 07 41 14      call print_u8x
0933   0965             ; --- END INLINE ASM BLOCK
0934   0965             
0935   0965 F9            leave
0936   0966 09            ret
0937   0967             
0938   0967             hex_to_int:
0939   0967 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0940   096A             ; $value 
0941   096A 10 00 00      mov a, $0
0942   096D 45 FF FF      mov [bp + -1], a
0943   0970             ; $i 
0944   0970             ; $hex_char 
0945   0970             ; $len 
0946   0970 52 07 00      sub sp, 7
0947   0973             ;; len = strlen(hex_string); 
0948   0973 FA FA FF      lea d, [bp + -6] ; $len
0949   0976 DA            push d
0950   0977 FA 05 00      lea d, [bp + 5] ; $hex_string
0951   097A 2A            mov b, [d]
0952   097B FD AB         swp b
0953   097D D8            push b
0954   097E 07 81 06      call strlen
0955   0981 51 02 00      add sp, 2
0956   0984 E7            pop d
0957   0985 FD 43         mov [d], b
0958   0987             ;; for (i = 0; i < len; i++) { 
0959   0987             _for12_init:
0960   0987 FA FD FF      lea d, [bp + -3] ; $i
0961   098A DA            push d
0962   098B 26 00 00      mov b, $0
0963   098E E7            pop d
0964   098F FD 43         mov [d], b
0965   0991             _for12_cond:
0966   0991 FA FD FF      lea d, [bp + -3] ; $i
0967   0994 2A            mov b, [d]
0968   0995             ; START RELATIONAL
0969   0995 D7            push a
0970   0996 11            mov a, b
0971   0997 FA FA FF      lea d, [bp + -6] ; $len
0972   099A 2A            mov b, [d]
0973   099B B0            cmp a, b
0974   099C FD 73         slt ; < 
0975   099E E4            pop a
0976   099F             ; END RELATIONAL
0977   099F C0 00 00      cmp b, 0
0978   09A2 C6 A7 0A      je _for12_exit
0979   09A5             _for12_block:
0980   09A5             ;; hex_char = hex_string[i]; 
0981   09A5 FA FC FF      lea d, [bp + -4] ; $hex_char
0982   09A8 DA            push d
0983   09A9 FA 05 00      lea d, [bp + 5] ; $hex_string
0984   09AC FD 2A         mov d, [d]
0985   09AE D7            push a
0986   09AF DA            push d
0987   09B0 FA FD FF      lea d, [bp + -3] ; $i
0988   09B3 2A            mov b, [d]
0989   09B4 E7            pop d
0990   09B5 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0991   09B9 E4            pop a
0992   09BA 32            mov bl, [d]
0993   09BB A7 00         mov bh, 0
0994   09BD E7            pop d
0995   09BE FD 3E         mov [d], bl
0996   09C0             ;; if (hex_char >= 'a' && hex_char <= 'f')  
0997   09C0             _if13_cond:
0998   09C0 FA FC FF      lea d, [bp + -4] ; $hex_char
0999   09C3 32            mov bl, [d]
1000   09C4 A7 00         mov bh, 0
1001   09C6             ; START RELATIONAL
1002   09C6 D7            push a
1003   09C7 11            mov a, b
1004   09C8 26 61 00      mov b, $61
1005   09CB B0            cmp a, b
1006   09CC FD 80         sge ; >=
1007   09CE E4            pop a
1008   09CF             ; END RELATIONAL
1009   09CF D7            push a
1010   09D0 11            mov a, b
1011   09D1 FA FC FF      lea d, [bp + -4] ; $hex_char
1012   09D4 32            mov bl, [d]
1013   09D5 A7 00         mov bh, 0
1014   09D7             ; START RELATIONAL
1015   09D7 D7            push a
1016   09D8 11            mov a, b
1017   09D9 26 66 00      mov b, $66
1018   09DC B0            cmp a, b
1019   09DD FD 74         sle ; <=
1020   09DF E4            pop a
1021   09E0             ; END RELATIONAL
1022   09E0 FD A7         sand a, b ; &&
1023   09E2 E4            pop a
1024   09E3 C0 00 00      cmp b, 0
1025   09E6 C6 18 0A      je _if13_else
1026   09E9             _if13_true:
1027   09E9             ;; value = (value * 16) + (hex_char - 'a' + 10); 
1028   09E9 FA FF FF      lea d, [bp + -1] ; $value
1029   09EC DA            push d
1030   09ED FA FF FF      lea d, [bp + -1] ; $value
1031   09F0 2A            mov b, [d]
1032   09F1             ; START FACTORS
1033   09F1 D7            push a
1034   09F2 11            mov a, b
1035   09F3 26 10 00      mov b, $10
1036   09F6 AC            mul a, b ; *
1037   09F7 11            mov a, b
1038   09F8 27            mov b, a
1039   09F9 E4            pop a
1040   09FA             ; END FACTORS
1041   09FA             ; START TERMS
1042   09FA D7            push a
1043   09FB 11            mov a, b
1044   09FC FA FC FF      lea d, [bp + -4] ; $hex_char
1045   09FF 32            mov bl, [d]
1046   0A00 A7 00         mov bh, 0
1047   0A02             ; START TERMS
1048   0A02 D7            push a
1049   0A03 11            mov a, b
1050   0A04 26 61 00      mov b, $61
1051   0A07 60            sub a, b
1052   0A08 11            mov a, b
1053   0A09 26 0A 00      mov b, $a
1054   0A0C 54            add a, b
1055   0A0D 27            mov b, a
1056   0A0E E4            pop a
1057   0A0F             ; END TERMS
1058   0A0F 54            add a, b
1059   0A10 27            mov b, a
1060   0A11 E4            pop a
1061   0A12             ; END TERMS
1062   0A12 E7            pop d
1063   0A13 FD 43         mov [d], b
1064   0A15 0A 97 0A      jmp _if13_exit
1065   0A18             _if13_else:
1066   0A18             ;; if (hex_char >= 'A' && hex_char <= 'F')  
1067   0A18             _if14_cond:
1068   0A18 FA FC FF      lea d, [bp + -4] ; $hex_char
1069   0A1B 32            mov bl, [d]
1070   0A1C A7 00         mov bh, 0
1071   0A1E             ; START RELATIONAL
1072   0A1E D7            push a
1073   0A1F 11            mov a, b
1074   0A20 26 41 00      mov b, $41
1075   0A23 B0            cmp a, b
1076   0A24 FD 80         sge ; >=
1077   0A26 E4            pop a
1078   0A27             ; END RELATIONAL
1079   0A27 D7            push a
1080   0A28 11            mov a, b
1081   0A29 FA FC FF      lea d, [bp + -4] ; $hex_char
1082   0A2C 32            mov bl, [d]
1083   0A2D A7 00         mov bh, 0
1084   0A2F             ; START RELATIONAL
1085   0A2F D7            push a
1086   0A30 11            mov a, b
1087   0A31 26 46 00      mov b, $46
1088   0A34 B0            cmp a, b
1089   0A35 FD 74         sle ; <=
1090   0A37 E4            pop a
1091   0A38             ; END RELATIONAL
1092   0A38 FD A7         sand a, b ; &&
1093   0A3A E4            pop a
1094   0A3B C0 00 00      cmp b, 0
1095   0A3E C6 70 0A      je _if14_else
1096   0A41             _if14_true:
1097   0A41             ;; value = (value * 16) + (hex_char - 'A' + 10); 
1098   0A41 FA FF FF      lea d, [bp + -1] ; $value
1099   0A44 DA            push d
1100   0A45 FA FF FF      lea d, [bp + -1] ; $value
1101   0A48 2A            mov b, [d]
1102   0A49             ; START FACTORS
1103   0A49 D7            push a
1104   0A4A 11            mov a, b
1105   0A4B 26 10 00      mov b, $10
1106   0A4E AC            mul a, b ; *
1107   0A4F 11            mov a, b
1108   0A50 27            mov b, a
1109   0A51 E4            pop a
1110   0A52             ; END FACTORS
1111   0A52             ; START TERMS
1112   0A52 D7            push a
1113   0A53 11            mov a, b
1114   0A54 FA FC FF      lea d, [bp + -4] ; $hex_char
1115   0A57 32            mov bl, [d]
1116   0A58 A7 00         mov bh, 0
1117   0A5A             ; START TERMS
1118   0A5A D7            push a
1119   0A5B 11            mov a, b
1120   0A5C 26 41 00      mov b, $41
1121   0A5F 60            sub a, b
1122   0A60 11            mov a, b
1123   0A61 26 0A 00      mov b, $a
1124   0A64 54            add a, b
1125   0A65 27            mov b, a
1126   0A66 E4            pop a
1127   0A67             ; END TERMS
1128   0A67 54            add a, b
1129   0A68 27            mov b, a
1130   0A69 E4            pop a
1131   0A6A             ; END TERMS
1132   0A6A E7            pop d
1133   0A6B FD 43         mov [d], b
1134   0A6D 0A 97 0A      jmp _if14_exit
1135   0A70             _if14_else:
1136   0A70             ;; value = (value * 16) + (hex_char - '0'); 
1137   0A70 FA FF FF      lea d, [bp + -1] ; $value
1138   0A73 DA            push d
1139   0A74 FA FF FF      lea d, [bp + -1] ; $value
1140   0A77 2A            mov b, [d]
1141   0A78             ; START FACTORS
1142   0A78 D7            push a
1143   0A79 11            mov a, b
1144   0A7A 26 10 00      mov b, $10
1145   0A7D AC            mul a, b ; *
1146   0A7E 11            mov a, b
1147   0A7F 27            mov b, a
1148   0A80 E4            pop a
1149   0A81             ; END FACTORS
1150   0A81             ; START TERMS
1151   0A81 D7            push a
1152   0A82 11            mov a, b
1153   0A83 FA FC FF      lea d, [bp + -4] ; $hex_char
1154   0A86 32            mov bl, [d]
1155   0A87 A7 00         mov bh, 0
1156   0A89             ; START TERMS
1157   0A89 D7            push a
1158   0A8A 11            mov a, b
1159   0A8B 26 30 00      mov b, $30
1160   0A8E 60            sub a, b
1161   0A8F 27            mov b, a
1162   0A90 E4            pop a
1163   0A91             ; END TERMS
1164   0A91 54            add a, b
1165   0A92 27            mov b, a
1166   0A93 E4            pop a
1167   0A94             ; END TERMS
1168   0A94 E7            pop d
1169   0A95 FD 43         mov [d], b
1170   0A97             _if14_exit:
1171   0A97             _if13_exit:
1172   0A97             _for12_update:
1173   0A97 FA FD FF      lea d, [bp + -3] ; $i
1174   0A9A 2A            mov b, [d]
1175   0A9B D8            push b
1176   0A9C FD 77         inc b
1177   0A9E FA FD FF      lea d, [bp + -3] ; $i
1178   0AA1 FD 43         mov [d], b
1179   0AA3 E5            pop b
1180   0AA4 0A 91 09      jmp _for12_cond
1181   0AA7             _for12_exit:
1182   0AA7             ;; return value; 
1183   0AA7 FA FF FF      lea d, [bp + -1] ; $value
1184   0AAA 2A            mov b, [d]
1185   0AAB F9            leave
1186   0AAC 09            ret
1187   0AAD             
1188   0AAD             atoi:
1189   0AAD F8 00 00      enter 0 ; (push bp; mov bp, sp)
1190   0AB0             ; $result 
1191   0AB0 10 00 00      mov a, $0
1192   0AB3 45 FF FF      mov [bp + -1], a
1193   0AB6             ; $sign 
1194   0AB6 10 01 00      mov a, $1
1195   0AB9 45 FD FF      mov [bp + -3], a
1196   0ABC 52 04 00      sub sp, 4
1197   0ABF             ;; while (*str == ' ') str++; 
1198   0ABF             _while15_cond:
1199   0ABF FA 05 00      lea d, [bp + 5] ; $str
1200   0AC2 2A            mov b, [d]
1201   0AC3 74            mov d, b
1202   0AC4 32            mov bl, [d]
1203   0AC5 A7 00         mov bh, 0
1204   0AC7             ; START RELATIONAL
1205   0AC7 D7            push a
1206   0AC8 11            mov a, b
1207   0AC9 26 20 00      mov b, $20
1208   0ACC B0            cmp a, b
1209   0ACD FD 71         seq ; ==
1210   0ACF E4            pop a
1211   0AD0             ; END RELATIONAL
1212   0AD0 C0 00 00      cmp b, 0
1213   0AD3 C6 E6 0A      je _while15_exit
1214   0AD6             _while15_block:
1215   0AD6             ;; str++; 
1216   0AD6 FA 05 00      lea d, [bp + 5] ; $str
1217   0AD9 2A            mov b, [d]
1218   0ADA D8            push b
1219   0ADB FD 77         inc b
1220   0ADD FA 05 00      lea d, [bp + 5] ; $str
1221   0AE0 FD 43         mov [d], b
1222   0AE2 E5            pop b
1223   0AE3 0A BF 0A      jmp _while15_cond
1224   0AE6             _while15_exit:
1225   0AE6             ;; if (*str == '-' || *str == '+') { 
1226   0AE6             _if16_cond:
1227   0AE6 FA 05 00      lea d, [bp + 5] ; $str
1228   0AE9 2A            mov b, [d]
1229   0AEA 74            mov d, b
1230   0AEB 32            mov bl, [d]
1231   0AEC A7 00         mov bh, 0
1232   0AEE             ; START RELATIONAL
1233   0AEE D7            push a
1234   0AEF 11            mov a, b
1235   0AF0 26 2D 00      mov b, $2d
1236   0AF3 B0            cmp a, b
1237   0AF4 FD 71         seq ; ==
1238   0AF6 E4            pop a
1239   0AF7             ; END RELATIONAL
1240   0AF7 D7            push a
1241   0AF8 11            mov a, b
1242   0AF9 FA 05 00      lea d, [bp + 5] ; $str
1243   0AFC 2A            mov b, [d]
1244   0AFD 74            mov d, b
1245   0AFE 32            mov bl, [d]
1246   0AFF A7 00         mov bh, 0
1247   0B01             ; START RELATIONAL
1248   0B01 D7            push a
1249   0B02 11            mov a, b
1250   0B03 26 2B 00      mov b, $2b
1251   0B06 B0            cmp a, b
1252   0B07 FD 71         seq ; ==
1253   0B09 E4            pop a
1254   0B0A             ; END RELATIONAL
1255   0B0A FD A8         sor a, b ; ||
1256   0B0C E4            pop a
1257   0B0D C0 00 00      cmp b, 0
1258   0B10 C6 49 0B      je _if16_exit
1259   0B13             _if16_true:
1260   0B13             ;; if (*str == '-') sign = -1; 
1261   0B13             _if17_cond:
1262   0B13 FA 05 00      lea d, [bp + 5] ; $str
1263   0B16 2A            mov b, [d]
1264   0B17 74            mov d, b
1265   0B18 32            mov bl, [d]
1266   0B19 A7 00         mov bh, 0
1267   0B1B             ; START RELATIONAL
1268   0B1B D7            push a
1269   0B1C 11            mov a, b
1270   0B1D 26 2D 00      mov b, $2d
1271   0B20 B0            cmp a, b
1272   0B21 FD 71         seq ; ==
1273   0B23 E4            pop a
1274   0B24             ; END RELATIONAL
1275   0B24 C0 00 00      cmp b, 0
1276   0B27 C6 39 0B      je _if17_exit
1277   0B2A             _if17_true:
1278   0B2A             ;; sign = -1; 
1279   0B2A FA FD FF      lea d, [bp + -3] ; $sign
1280   0B2D DA            push d
1281   0B2E 26 01 00      mov b, $1
1282   0B31 FD 97         neg b
1283   0B33 E7            pop d
1284   0B34 FD 43         mov [d], b
1285   0B36 0A 39 0B      jmp _if17_exit
1286   0B39             _if17_exit:
1287   0B39             ;; str++; 
1288   0B39 FA 05 00      lea d, [bp + 5] ; $str
1289   0B3C 2A            mov b, [d]
1290   0B3D D8            push b
1291   0B3E FD 77         inc b
1292   0B40 FA 05 00      lea d, [bp + 5] ; $str
1293   0B43 FD 43         mov [d], b
1294   0B45 E5            pop b
1295   0B46 0A 49 0B      jmp _if16_exit
1296   0B49             _if16_exit:
1297   0B49             ;; while (*str >= '0' && *str <= '9') { 
1298   0B49             _while18_cond:
1299   0B49 FA 05 00      lea d, [bp + 5] ; $str
1300   0B4C 2A            mov b, [d]
1301   0B4D 74            mov d, b
1302   0B4E 32            mov bl, [d]
1303   0B4F A7 00         mov bh, 0
1304   0B51             ; START RELATIONAL
1305   0B51 D7            push a
1306   0B52 11            mov a, b
1307   0B53 26 30 00      mov b, $30
1308   0B56 B0            cmp a, b
1309   0B57 FD 82         sgeu ; >= (unsigned)
1310   0B59 E4            pop a
1311   0B5A             ; END RELATIONAL
1312   0B5A D7            push a
1313   0B5B 11            mov a, b
1314   0B5C FA 05 00      lea d, [bp + 5] ; $str
1315   0B5F 2A            mov b, [d]
1316   0B60 74            mov d, b
1317   0B61 32            mov bl, [d]
1318   0B62 A7 00         mov bh, 0
1319   0B64             ; START RELATIONAL
1320   0B64 D7            push a
1321   0B65 11            mov a, b
1322   0B66 26 39 00      mov b, $39
1323   0B69 B0            cmp a, b
1324   0B6A FD 76         sleu ; <= (unsigned)
1325   0B6C E4            pop a
1326   0B6D             ; END RELATIONAL
1327   0B6D FD A7         sand a, b ; &&
1328   0B6F E4            pop a
1329   0B70 C0 00 00      cmp b, 0
1330   0B73 C6 AF 0B      je _while18_exit
1331   0B76             _while18_block:
1332   0B76             ;; result = result * 10 + (*str - '0'); 
1333   0B76 FA FF FF      lea d, [bp + -1] ; $result
1334   0B79 DA            push d
1335   0B7A FA FF FF      lea d, [bp + -1] ; $result
1336   0B7D 2A            mov b, [d]
1337   0B7E             ; START FACTORS
1338   0B7E D7            push a
1339   0B7F 11            mov a, b
1340   0B80 26 0A 00      mov b, $a
1341   0B83 AC            mul a, b ; *
1342   0B84 11            mov a, b
1343   0B85 27            mov b, a
1344   0B86 E4            pop a
1345   0B87             ; END FACTORS
1346   0B87             ; START TERMS
1347   0B87 D7            push a
1348   0B88 11            mov a, b
1349   0B89 FA 05 00      lea d, [bp + 5] ; $str
1350   0B8C 2A            mov b, [d]
1351   0B8D 74            mov d, b
1352   0B8E 32            mov bl, [d]
1353   0B8F A7 00         mov bh, 0
1354   0B91             ; START TERMS
1355   0B91 D7            push a
1356   0B92 11            mov a, b
1357   0B93 26 30 00      mov b, $30
1358   0B96 60            sub a, b
1359   0B97 27            mov b, a
1360   0B98 E4            pop a
1361   0B99             ; END TERMS
1362   0B99 54            add a, b
1363   0B9A 27            mov b, a
1364   0B9B E4            pop a
1365   0B9C             ; END TERMS
1366   0B9C E7            pop d
1367   0B9D FD 43         mov [d], b
1368   0B9F             ;; str++; 
1369   0B9F FA 05 00      lea d, [bp + 5] ; $str
1370   0BA2 2A            mov b, [d]
1371   0BA3 D8            push b
1372   0BA4 FD 77         inc b
1373   0BA6 FA 05 00      lea d, [bp + 5] ; $str
1374   0BA9 FD 43         mov [d], b
1375   0BAB E5            pop b
1376   0BAC 0A 49 0B      jmp _while18_cond
1377   0BAF             _while18_exit:
1378   0BAF             ;; return sign * result; 
1379   0BAF FA FD FF      lea d, [bp + -3] ; $sign
1380   0BB2 2A            mov b, [d]
1381   0BB3             ; START FACTORS
1382   0BB3 D7            push a
1383   0BB4 11            mov a, b
1384   0BB5 FA FF FF      lea d, [bp + -1] ; $result
1385   0BB8 2A            mov b, [d]
1386   0BB9 AC            mul a, b ; *
1387   0BBA 11            mov a, b
1388   0BBB 27            mov b, a
1389   0BBC E4            pop a
1390   0BBD             ; END FACTORS
1391   0BBD F9            leave
1392   0BBE 09            ret
1393   0BBF             
1394   0BBF             gets:
1395   0BBF F8 00 00      enter 0 ; (push bp; mov bp, sp)
1396   0BC2             
1397   0BC2             ; --- BEGIN INLINE ASM BLOCK
1398   0BC2 FA 05 00      lea d, [bp + 5] ; $s
1399   0BC5 15            mov a, [d]
1400   0BC6 3C            mov d, a
1401   0BC7 07 62 12      call _gets
1402   0BCA             ; --- END INLINE ASM BLOCK
1403   0BCA             
1404   0BCA             ;; return strlen(s); 
1405   0BCA FA 05 00      lea d, [bp + 5] ; $s
1406   0BCD 2A            mov b, [d]
1407   0BCE FD AB         swp b
1408   0BD0 D8            push b
1409   0BD1 07 81 06      call strlen
1410   0BD4 51 02 00      add sp, 2
1411   0BD7 F9            leave
1412   0BD8 09            ret
1413   0BD9             
1414   0BD9             print_signed:
1415   0BD9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1416   0BDC             ; $digits 
1417   0BDC             ; $i 
1418   0BDC 10 00 00      mov a, $0
1419   0BDF 45 FA FF      mov [bp + -6], a
1420   0BE2 52 07 00      sub sp, 7
1421   0BE5             ;; if (num < 0) { 
1422   0BE5             _if19_cond:
1423   0BE5 FA 05 00      lea d, [bp + 5] ; $num
1424   0BE8 2A            mov b, [d]
1425   0BE9             ; START RELATIONAL
1426   0BE9 D7            push a
1427   0BEA 11            mov a, b
1428   0BEB 26 00 00      mov b, $0
1429   0BEE B0            cmp a, b
1430   0BEF FD 73         slt ; < 
1431   0BF1 E4            pop a
1432   0BF2             ; END RELATIONAL
1433   0BF2 C0 00 00      cmp b, 0
1434   0BF5 C6 12 0C      je _if19_else
1435   0BF8             _if19_true:
1436   0BF8             ;; putchar('-'); 
1437   0BF8 26 2D 00      mov b, $2d
1438   0BFB DD            push bl
1439   0BFC 07 DE 0F      call putchar
1440   0BFF 51 01 00      add sp, 1
1441   0C02             ;; num = -num; 
1442   0C02 FA 05 00      lea d, [bp + 5] ; $num
1443   0C05 DA            push d
1444   0C06 FA 05 00      lea d, [bp + 5] ; $num
1445   0C09 2A            mov b, [d]
1446   0C0A FD 97         neg b
1447   0C0C E7            pop d
1448   0C0D FD 43         mov [d], b
1449   0C0F 0A 34 0C      jmp _if19_exit
1450   0C12             _if19_else:
1451   0C12             ;; if (num == 0) { 
1452   0C12             _if20_cond:
1453   0C12 FA 05 00      lea d, [bp + 5] ; $num
1454   0C15 2A            mov b, [d]
1455   0C16             ; START RELATIONAL
1456   0C16 D7            push a
1457   0C17 11            mov a, b
1458   0C18 26 00 00      mov b, $0
1459   0C1B B0            cmp a, b
1460   0C1C FD 71         seq ; ==
1461   0C1E E4            pop a
1462   0C1F             ; END RELATIONAL
1463   0C1F C0 00 00      cmp b, 0
1464   0C22 C6 34 0C      je _if20_exit
1465   0C25             _if20_true:
1466   0C25             ;; putchar('0'); 
1467   0C25 26 30 00      mov b, $30
1468   0C28 DD            push bl
1469   0C29 07 DE 0F      call putchar
1470   0C2C 51 01 00      add sp, 1
1471   0C2F             ;; return; 
1472   0C2F F9            leave
1473   0C30 09            ret
1474   0C31 0A 34 0C      jmp _if20_exit
1475   0C34             _if20_exit:
1476   0C34             _if19_exit:
1477   0C34             ;; while (num > 0) { 
1478   0C34             _while21_cond:
1479   0C34 FA 05 00      lea d, [bp + 5] ; $num
1480   0C37 2A            mov b, [d]
1481   0C38             ; START RELATIONAL
1482   0C38 D7            push a
1483   0C39 11            mov a, b
1484   0C3A 26 00 00      mov b, $0
1485   0C3D B0            cmp a, b
1486   0C3E FD 7F         sgt ; >
1487   0C40 E4            pop a
1488   0C41             ; END RELATIONAL
1489   0C41 C0 00 00      cmp b, 0
1490   0C44 C6 8F 0C      je _while21_exit
1491   0C47             _while21_block:
1492   0C47             ;; digits[i] = '0' + (num % 10); 
1493   0C47 FA FC FF      lea d, [bp + -4] ; $digits
1494   0C4A D7            push a
1495   0C4B DA            push d
1496   0C4C FA FA FF      lea d, [bp + -6] ; $i
1497   0C4F 2A            mov b, [d]
1498   0C50 E7            pop d
1499   0C51 5A            add d, b
1500   0C52 E4            pop a
1501   0C53 DA            push d
1502   0C54 26 30 00      mov b, $30
1503   0C57             ; START TERMS
1504   0C57 D7            push a
1505   0C58 11            mov a, b
1506   0C59 FA 05 00      lea d, [bp + 5] ; $num
1507   0C5C 2A            mov b, [d]
1508   0C5D             ; START FACTORS
1509   0C5D D7            push a
1510   0C5E 11            mov a, b
1511   0C5F 26 0A 00      mov b, $a
1512   0C62 AE            div a, b ; 
1513   0C63 11            mov a, b
1514   0C64 27            mov b, a
1515   0C65 E4            pop a
1516   0C66             ; END FACTORS
1517   0C66 54            add a, b
1518   0C67 27            mov b, a
1519   0C68 E4            pop a
1520   0C69             ; END TERMS
1521   0C69 E7            pop d
1522   0C6A FD 3E         mov [d], bl
1523   0C6C             ;; num = num / 10; 
1524   0C6C FA 05 00      lea d, [bp + 5] ; $num
1525   0C6F DA            push d
1526   0C70 FA 05 00      lea d, [bp + 5] ; $num
1527   0C73 2A            mov b, [d]
1528   0C74             ; START FACTORS
1529   0C74 D7            push a
1530   0C75 11            mov a, b
1531   0C76 26 0A 00      mov b, $a
1532   0C79 AE            div a, b
1533   0C7A 27            mov b, a
1534   0C7B E4            pop a
1535   0C7C             ; END FACTORS
1536   0C7C E7            pop d
1537   0C7D FD 43         mov [d], b
1538   0C7F             ;; i++; 
1539   0C7F FA FA FF      lea d, [bp + -6] ; $i
1540   0C82 2A            mov b, [d]
1541   0C83 D8            push b
1542   0C84 FD 77         inc b
1543   0C86 FA FA FF      lea d, [bp + -6] ; $i
1544   0C89 FD 43         mov [d], b
1545   0C8B E5            pop b
1546   0C8C 0A 34 0C      jmp _while21_cond
1547   0C8F             _while21_exit:
1548   0C8F             ;; while (i > 0) { 
1549   0C8F             _while22_cond:
1550   0C8F FA FA FF      lea d, [bp + -6] ; $i
1551   0C92 2A            mov b, [d]
1552   0C93             ; START RELATIONAL
1553   0C93 D7            push a
1554   0C94 11            mov a, b
1555   0C95 26 00 00      mov b, $0
1556   0C98 B0            cmp a, b
1557   0C99 FD 7F         sgt ; >
1558   0C9B E4            pop a
1559   0C9C             ; END RELATIONAL
1560   0C9C C0 00 00      cmp b, 0
1561   0C9F C6 C8 0C      je _while22_exit
1562   0CA2             _while22_block:
1563   0CA2             ;; i--; 
1564   0CA2 FA FA FF      lea d, [bp + -6] ; $i
1565   0CA5 2A            mov b, [d]
1566   0CA6 D8            push b
1567   0CA7 FD 7D         dec b
1568   0CA9 FA FA FF      lea d, [bp + -6] ; $i
1569   0CAC FD 43         mov [d], b
1570   0CAE E5            pop b
1571   0CAF             ;; putchar(digits[i]); 
1572   0CAF FA FC FF      lea d, [bp + -4] ; $digits
1573   0CB2 D7            push a
1574   0CB3 DA            push d
1575   0CB4 FA FA FF      lea d, [bp + -6] ; $i
1576   0CB7 2A            mov b, [d]
1577   0CB8 E7            pop d
1578   0CB9 5A            add d, b
1579   0CBA E4            pop a
1580   0CBB 32            mov bl, [d]
1581   0CBC A7 00         mov bh, 0
1582   0CBE DD            push bl
1583   0CBF 07 DE 0F      call putchar
1584   0CC2 51 01 00      add sp, 1
1585   0CC5 0A 8F 0C      jmp _while22_cond
1586   0CC8             _while22_exit:
1587   0CC8 F9            leave
1588   0CC9 09            ret
1589   0CCA             
1590   0CCA             print_signed_long:
1591   0CCA F8 00 00      enter 0 ; (push bp; mov bp, sp)
1592   0CCD             ; $digits 
1593   0CCD             ; $i 
1594   0CCD 10 00 00      mov a, $0
1595   0CD0 45 F5 FF      mov [bp + -11], a
1596   0CD3 52 0C 00      sub sp, 12
1597   0CD6             ;; if (num < 0) { 
1598   0CD6             _if23_cond:
1599   0CD6 FA 05 00      lea d, [bp + 5] ; $num
1600   0CD9 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1601   0CDC FD 39         mov c, b ; And place it into C
1602   0CDE 2A            mov b, [d] ; Lower Word in B
1603   0CDF             ; START RELATIONAL
1604   0CDF D7            push a
1605   0CE0 FD D8         push g
1606   0CE2 11            mov a, b
1607   0CE3 FD 7A         mov g, c
1608   0CE5 26 00 00      mov b, $0
1609   0CE8 B0            cmp a, b
1610   0CE9 FD 73         slt ; < 
1611   0CEB FD F1         pop g
1612   0CED E4            pop a
1613   0CEE             ; END RELATIONAL
1614   0CEE C0 00 00      cmp b, 0
1615   0CF1 C6 18 0D      je _if23_else
1616   0CF4             _if23_true:
1617   0CF4             ;; putchar('-'); 
1618   0CF4 26 2D 00      mov b, $2d
1619   0CF7 DD            push bl
1620   0CF8 07 DE 0F      call putchar
1621   0CFB 51 01 00      add sp, 1
1622   0CFE             ;; num = -num; 
1623   0CFE FA 05 00      lea d, [bp + 5] ; $num
1624   0D01 DA            push d
1625   0D02 FA 05 00      lea d, [bp + 5] ; $num
1626   0D05 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1627   0D08 FD 39         mov c, b ; And place it into C
1628   0D0A 2A            mov b, [d] ; Lower Word in B
1629   0D0B FD 97         neg b
1630   0D0D E7            pop d
1631   0D0E FD 43         mov [d], b
1632   0D10 28            mov b, c
1633   0D11 FD 44 02 00   mov [d + 2], b
1634   0D15 0A 4F 0D      jmp _if23_exit
1635   0D18             _if23_else:
1636   0D18             ;; if (num == 0) { 
1637   0D18             _if24_cond:
1638   0D18 FA 05 00      lea d, [bp + 5] ; $num
1639   0D1B 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1640   0D1E FD 39         mov c, b ; And place it into C
1641   0D20 2A            mov b, [d] ; Lower Word in B
1642   0D21             ; START RELATIONAL
1643   0D21 D7            push a
1644   0D22 FD D8         push g
1645   0D24 11            mov a, b
1646   0D25 FD 7A         mov g, c
1647   0D27 26 00 00      mov b, $0
1648   0D2A B0            cmp a, b
1649   0D2B FD 71         seq ; ==
1650   0D2D D8            push b
1651   0D2E 12            mov a, c
1652   0D2F FD 27         mov b, g
1653   0D31 B0            cmp a, b
1654   0D32 FD 71         seq ; ==
1655   0D34 E4            pop a
1656   0D35 FD A7         sand a, b
1657   0D37 FD F1         pop g
1658   0D39 E4            pop a
1659   0D3A             ; END RELATIONAL
1660   0D3A C0 00 00      cmp b, 0
1661   0D3D C6 4F 0D      je _if24_exit
1662   0D40             _if24_true:
1663   0D40             ;; putchar('0'); 
1664   0D40 26 30 00      mov b, $30
1665   0D43 DD            push bl
1666   0D44 07 DE 0F      call putchar
1667   0D47 51 01 00      add sp, 1
1668   0D4A             ;; return; 
1669   0D4A F9            leave
1670   0D4B 09            ret
1671   0D4C 0A 4F 0D      jmp _if24_exit
1672   0D4F             _if24_exit:
1673   0D4F             _if23_exit:
1674   0D4F             ;; while (num > 0) { 
1675   0D4F             _while25_cond:
1676   0D4F FA 05 00      lea d, [bp + 5] ; $num
1677   0D52 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1678   0D55 FD 39         mov c, b ; And place it into C
1679   0D57 2A            mov b, [d] ; Lower Word in B
1680   0D58             ; START RELATIONAL
1681   0D58 D7            push a
1682   0D59 FD D8         push g
1683   0D5B 11            mov a, b
1684   0D5C FD 7A         mov g, c
1685   0D5E 26 00 00      mov b, $0
1686   0D61 B0            cmp a, b
1687   0D62 FD 7F         sgt ; >
1688   0D64 FD F1         pop g
1689   0D66 E4            pop a
1690   0D67             ; END RELATIONAL
1691   0D67 C0 00 00      cmp b, 0
1692   0D6A C6 C4 0D      je _while25_exit
1693   0D6D             _while25_block:
1694   0D6D             ;; digits[i] = '0' + (num % 10); 
1695   0D6D FA F7 FF      lea d, [bp + -9] ; $digits
1696   0D70 D7            push a
1697   0D71 DA            push d
1698   0D72 FA F5 FF      lea d, [bp + -11] ; $i
1699   0D75 2A            mov b, [d]
1700   0D76 E7            pop d
1701   0D77 5A            add d, b
1702   0D78 E4            pop a
1703   0D79 DA            push d
1704   0D7A 26 30 00      mov b, $30
1705   0D7D             ; START TERMS
1706   0D7D D7            push a
1707   0D7E 11            mov a, b
1708   0D7F FA 05 00      lea d, [bp + 5] ; $num
1709   0D82 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1710   0D85 FD 39         mov c, b ; And place it into C
1711   0D87 2A            mov b, [d] ; Lower Word in B
1712   0D88             ; START FACTORS
1713   0D88 D7            push a
1714   0D89 11            mov a, b
1715   0D8A 26 0A 00      mov b, $a
1716   0D8D AE            div a, b ; 
1717   0D8E 11            mov a, b
1718   0D8F 27            mov b, a
1719   0D90 E4            pop a
1720   0D91             ; END FACTORS
1721   0D91 54            add a, b
1722   0D92 27            mov b, a
1723   0D93 E4            pop a
1724   0D94             ; END TERMS
1725   0D94 E7            pop d
1726   0D95 FD 3E         mov [d], bl
1727   0D97             ;; num = num / 10; 
1728   0D97 FA 05 00      lea d, [bp + 5] ; $num
1729   0D9A DA            push d
1730   0D9B FA 05 00      lea d, [bp + 5] ; $num
1731   0D9E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1732   0DA1 FD 39         mov c, b ; And place it into C
1733   0DA3 2A            mov b, [d] ; Lower Word in B
1734   0DA4             ; START FACTORS
1735   0DA4 D7            push a
1736   0DA5 11            mov a, b
1737   0DA6 26 0A 00      mov b, $a
1738   0DA9 AE            div a, b
1739   0DAA 27            mov b, a
1740   0DAB E4            pop a
1741   0DAC             ; END FACTORS
1742   0DAC E7            pop d
1743   0DAD FD 43         mov [d], b
1744   0DAF 28            mov b, c
1745   0DB0 FD 44 02 00   mov [d + 2], b
1746   0DB4             ;; i++; 
1747   0DB4 FA F5 FF      lea d, [bp + -11] ; $i
1748   0DB7 2A            mov b, [d]
1749   0DB8 D8            push b
1750   0DB9 FD 77         inc b
1751   0DBB FA F5 FF      lea d, [bp + -11] ; $i
1752   0DBE FD 43         mov [d], b
1753   0DC0 E5            pop b
1754   0DC1 0A 4F 0D      jmp _while25_cond
1755   0DC4             _while25_exit:
1756   0DC4             ;; while (i > 0) { 
1757   0DC4             _while26_cond:
1758   0DC4 FA F5 FF      lea d, [bp + -11] ; $i
1759   0DC7 2A            mov b, [d]
1760   0DC8             ; START RELATIONAL
1761   0DC8 D7            push a
1762   0DC9 11            mov a, b
1763   0DCA 26 00 00      mov b, $0
1764   0DCD B0            cmp a, b
1765   0DCE FD 7F         sgt ; >
1766   0DD0 E4            pop a
1767   0DD1             ; END RELATIONAL
1768   0DD1 C0 00 00      cmp b, 0
1769   0DD4 C6 FD 0D      je _while26_exit
1770   0DD7             _while26_block:
1771   0DD7             ;; i--; 
1772   0DD7 FA F5 FF      lea d, [bp + -11] ; $i
1773   0DDA 2A            mov b, [d]
1774   0DDB D8            push b
1775   0DDC FD 7D         dec b
1776   0DDE FA F5 FF      lea d, [bp + -11] ; $i
1777   0DE1 FD 43         mov [d], b
1778   0DE3 E5            pop b
1779   0DE4             ;; putchar(digits[i]); 
1780   0DE4 FA F7 FF      lea d, [bp + -9] ; $digits
1781   0DE7 D7            push a
1782   0DE8 DA            push d
1783   0DE9 FA F5 FF      lea d, [bp + -11] ; $i
1784   0DEC 2A            mov b, [d]
1785   0DED E7            pop d
1786   0DEE 5A            add d, b
1787   0DEF E4            pop a
1788   0DF0 32            mov bl, [d]
1789   0DF1 A7 00         mov bh, 0
1790   0DF3 DD            push bl
1791   0DF4 07 DE 0F      call putchar
1792   0DF7 51 01 00      add sp, 1
1793   0DFA 0A C4 0D      jmp _while26_cond
1794   0DFD             _while26_exit:
1795   0DFD F9            leave
1796   0DFE 09            ret
1797   0DFF             
1798   0DFF             print_unsigned_long:
1799   0DFF F8 00 00      enter 0 ; (push bp; mov bp, sp)
1800   0E02             ; $digits 
1801   0E02             ; $i 
1802   0E02 52 0C 00      sub sp, 12
1803   0E05             ;; i = 0; 
1804   0E05 FA F5 FF      lea d, [bp + -11] ; $i
1805   0E08 DA            push d
1806   0E09 26 00 00      mov b, $0
1807   0E0C E7            pop d
1808   0E0D FD 43         mov [d], b
1809   0E0F             ;; if(num == 0){ 
1810   0E0F             _if27_cond:
1811   0E0F FA 05 00      lea d, [bp + 5] ; $num
1812   0E12 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1813   0E15 FD 39         mov c, b ; And place it into C
1814   0E17 2A            mov b, [d] ; Lower Word in B
1815   0E18             ; START RELATIONAL
1816   0E18 D7            push a
1817   0E19 FD D8         push g
1818   0E1B 11            mov a, b
1819   0E1C FD 7A         mov g, c
1820   0E1E 26 00 00      mov b, $0
1821   0E21 B0            cmp a, b
1822   0E22 FD 71         seq ; ==
1823   0E24 D8            push b
1824   0E25 12            mov a, c
1825   0E26 FD 27         mov b, g
1826   0E28 B0            cmp a, b
1827   0E29 FD 71         seq ; ==
1828   0E2B E4            pop a
1829   0E2C FD A7         sand a, b
1830   0E2E FD F1         pop g
1831   0E30 E4            pop a
1832   0E31             ; END RELATIONAL
1833   0E31 C0 00 00      cmp b, 0
1834   0E34 C6 46 0E      je _if27_exit
1835   0E37             _if27_true:
1836   0E37             ;; putchar('0'); 
1837   0E37 26 30 00      mov b, $30
1838   0E3A DD            push bl
1839   0E3B 07 DE 0F      call putchar
1840   0E3E 51 01 00      add sp, 1
1841   0E41             ;; return; 
1842   0E41 F9            leave
1843   0E42 09            ret
1844   0E43 0A 46 0E      jmp _if27_exit
1845   0E46             _if27_exit:
1846   0E46             ;; while (num > 0) { 
1847   0E46             _while28_cond:
1848   0E46 FA 05 00      lea d, [bp + 5] ; $num
1849   0E49 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1850   0E4C FD 39         mov c, b ; And place it into C
1851   0E4E 2A            mov b, [d] ; Lower Word in B
1852   0E4F             ; START RELATIONAL
1853   0E4F D7            push a
1854   0E50 FD D8         push g
1855   0E52 11            mov a, b
1856   0E53 FD 7A         mov g, c
1857   0E55 26 00 00      mov b, $0
1858   0E58 B0            cmp a, b
1859   0E59 FD 81         sgu ; > (unsigned)
1860   0E5B FD F1         pop g
1861   0E5D E4            pop a
1862   0E5E             ; END RELATIONAL
1863   0E5E C0 00 00      cmp b, 0
1864   0E61 C6 BB 0E      je _while28_exit
1865   0E64             _while28_block:
1866   0E64             ;; digits[i] = '0' + (num % 10); 
1867   0E64 FA F7 FF      lea d, [bp + -9] ; $digits
1868   0E67 D7            push a
1869   0E68 DA            push d
1870   0E69 FA F5 FF      lea d, [bp + -11] ; $i
1871   0E6C 2A            mov b, [d]
1872   0E6D E7            pop d
1873   0E6E 5A            add d, b
1874   0E6F E4            pop a
1875   0E70 DA            push d
1876   0E71 26 30 00      mov b, $30
1877   0E74             ; START TERMS
1878   0E74 D7            push a
1879   0E75 11            mov a, b
1880   0E76 FA 05 00      lea d, [bp + 5] ; $num
1881   0E79 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1882   0E7C FD 39         mov c, b ; And place it into C
1883   0E7E 2A            mov b, [d] ; Lower Word in B
1884   0E7F             ; START FACTORS
1885   0E7F D7            push a
1886   0E80 11            mov a, b
1887   0E81 26 0A 00      mov b, $a
1888   0E84 AE            div a, b ; 
1889   0E85 11            mov a, b
1890   0E86 27            mov b, a
1891   0E87 E4            pop a
1892   0E88             ; END FACTORS
1893   0E88 54            add a, b
1894   0E89 27            mov b, a
1895   0E8A E4            pop a
1896   0E8B             ; END TERMS
1897   0E8B E7            pop d
1898   0E8C FD 3E         mov [d], bl
1899   0E8E             ;; num = num / 10; 
1900   0E8E FA 05 00      lea d, [bp + 5] ; $num
1901   0E91 DA            push d
1902   0E92 FA 05 00      lea d, [bp + 5] ; $num
1903   0E95 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1904   0E98 FD 39         mov c, b ; And place it into C
1905   0E9A 2A            mov b, [d] ; Lower Word in B
1906   0E9B             ; START FACTORS
1907   0E9B D7            push a
1908   0E9C 11            mov a, b
1909   0E9D 26 0A 00      mov b, $a
1910   0EA0 AE            div a, b
1911   0EA1 27            mov b, a
1912   0EA2 E4            pop a
1913   0EA3             ; END FACTORS
1914   0EA3 E7            pop d
1915   0EA4 FD 43         mov [d], b
1916   0EA6 28            mov b, c
1917   0EA7 FD 44 02 00   mov [d + 2], b
1918   0EAB             ;; i++; 
1919   0EAB FA F5 FF      lea d, [bp + -11] ; $i
1920   0EAE 2A            mov b, [d]
1921   0EAF D8            push b
1922   0EB0 FD 77         inc b
1923   0EB2 FA F5 FF      lea d, [bp + -11] ; $i
1924   0EB5 FD 43         mov [d], b
1925   0EB7 E5            pop b
1926   0EB8 0A 46 0E      jmp _while28_cond
1927   0EBB             _while28_exit:
1928   0EBB             ;; while (i > 0) { 
1929   0EBB             _while29_cond:
1930   0EBB FA F5 FF      lea d, [bp + -11] ; $i
1931   0EBE 2A            mov b, [d]
1932   0EBF             ; START RELATIONAL
1933   0EBF D7            push a
1934   0EC0 11            mov a, b
1935   0EC1 26 00 00      mov b, $0
1936   0EC4 B0            cmp a, b
1937   0EC5 FD 7F         sgt ; >
1938   0EC7 E4            pop a
1939   0EC8             ; END RELATIONAL
1940   0EC8 C0 00 00      cmp b, 0
1941   0ECB C6 F4 0E      je _while29_exit
1942   0ECE             _while29_block:
1943   0ECE             ;; i--; 
1944   0ECE FA F5 FF      lea d, [bp + -11] ; $i
1945   0ED1 2A            mov b, [d]
1946   0ED2 D8            push b
1947   0ED3 FD 7D         dec b
1948   0ED5 FA F5 FF      lea d, [bp + -11] ; $i
1949   0ED8 FD 43         mov [d], b
1950   0EDA E5            pop b
1951   0EDB             ;; putchar(digits[i]); 
1952   0EDB FA F7 FF      lea d, [bp + -9] ; $digits
1953   0EDE D7            push a
1954   0EDF DA            push d
1955   0EE0 FA F5 FF      lea d, [bp + -11] ; $i
1956   0EE3 2A            mov b, [d]
1957   0EE4 E7            pop d
1958   0EE5 5A            add d, b
1959   0EE6 E4            pop a
1960   0EE7 32            mov bl, [d]
1961   0EE8 A7 00         mov bh, 0
1962   0EEA DD            push bl
1963   0EEB 07 DE 0F      call putchar
1964   0EEE 51 01 00      add sp, 1
1965   0EF1 0A BB 0E      jmp _while29_cond
1966   0EF4             _while29_exit:
1967   0EF4 F9            leave
1968   0EF5 09            ret
1969   0EF6             
1970   0EF6             print_unsigned:
1971   0EF6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1972   0EF9             ; $digits 
1973   0EF9             ; $i 
1974   0EF9 52 07 00      sub sp, 7
1975   0EFC             ;; i = 0; 
1976   0EFC FA FA FF      lea d, [bp + -6] ; $i
1977   0EFF DA            push d
1978   0F00 26 00 00      mov b, $0
1979   0F03 E7            pop d
1980   0F04 FD 43         mov [d], b
1981   0F06             ;; if(num == 0){ 
1982   0F06             _if30_cond:
1983   0F06 FA 05 00      lea d, [bp + 5] ; $num
1984   0F09 2A            mov b, [d]
1985   0F0A             ; START RELATIONAL
1986   0F0A D7            push a
1987   0F0B 11            mov a, b
1988   0F0C 26 00 00      mov b, $0
1989   0F0F B0            cmp a, b
1990   0F10 FD 71         seq ; ==
1991   0F12 E4            pop a
1992   0F13             ; END RELATIONAL
1993   0F13 C0 00 00      cmp b, 0
1994   0F16 C6 28 0F      je _if30_exit
1995   0F19             _if30_true:
1996   0F19             ;; putchar('0'); 
1997   0F19 26 30 00      mov b, $30
1998   0F1C DD            push bl
1999   0F1D 07 DE 0F      call putchar
2000   0F20 51 01 00      add sp, 1
2001   0F23             ;; return; 
2002   0F23 F9            leave
2003   0F24 09            ret
2004   0F25 0A 28 0F      jmp _if30_exit
2005   0F28             _if30_exit:
2006   0F28             ;; while (num > 0) { 
2007   0F28             _while31_cond:
2008   0F28 FA 05 00      lea d, [bp + 5] ; $num
2009   0F2B 2A            mov b, [d]
2010   0F2C             ; START RELATIONAL
2011   0F2C D7            push a
2012   0F2D 11            mov a, b
2013   0F2E 26 00 00      mov b, $0
2014   0F31 B0            cmp a, b
2015   0F32 FD 81         sgu ; > (unsigned)
2016   0F34 E4            pop a
2017   0F35             ; END RELATIONAL
2018   0F35 C0 00 00      cmp b, 0
2019   0F38 C6 83 0F      je _while31_exit
2020   0F3B             _while31_block:
2021   0F3B             ;; digits[i] = '0' + (num % 10); 
2022   0F3B FA FC FF      lea d, [bp + -4] ; $digits
2023   0F3E D7            push a
2024   0F3F DA            push d
2025   0F40 FA FA FF      lea d, [bp + -6] ; $i
2026   0F43 2A            mov b, [d]
2027   0F44 E7            pop d
2028   0F45 5A            add d, b
2029   0F46 E4            pop a
2030   0F47 DA            push d
2031   0F48 26 30 00      mov b, $30
2032   0F4B             ; START TERMS
2033   0F4B D7            push a
2034   0F4C 11            mov a, b
2035   0F4D FA 05 00      lea d, [bp + 5] ; $num
2036   0F50 2A            mov b, [d]
2037   0F51             ; START FACTORS
2038   0F51 D7            push a
2039   0F52 11            mov a, b
2040   0F53 26 0A 00      mov b, $a
2041   0F56 AE            div a, b ; 
2042   0F57 11            mov a, b
2043   0F58 27            mov b, a
2044   0F59 E4            pop a
2045   0F5A             ; END FACTORS
2046   0F5A 54            add a, b
2047   0F5B 27            mov b, a
2048   0F5C E4            pop a
2049   0F5D             ; END TERMS
2050   0F5D E7            pop d
2051   0F5E FD 3E         mov [d], bl
2052   0F60             ;; num = num / 10; 
2053   0F60 FA 05 00      lea d, [bp + 5] ; $num
2054   0F63 DA            push d
2055   0F64 FA 05 00      lea d, [bp + 5] ; $num
2056   0F67 2A            mov b, [d]
2057   0F68             ; START FACTORS
2058   0F68 D7            push a
2059   0F69 11            mov a, b
2060   0F6A 26 0A 00      mov b, $a
2061   0F6D AE            div a, b
2062   0F6E 27            mov b, a
2063   0F6F E4            pop a
2064   0F70             ; END FACTORS
2065   0F70 E7            pop d
2066   0F71 FD 43         mov [d], b
2067   0F73             ;; i++; 
2068   0F73 FA FA FF      lea d, [bp + -6] ; $i
2069   0F76 2A            mov b, [d]
2070   0F77 D8            push b
2071   0F78 FD 77         inc b
2072   0F7A FA FA FF      lea d, [bp + -6] ; $i
2073   0F7D FD 43         mov [d], b
2074   0F7F E5            pop b
2075   0F80 0A 28 0F      jmp _while31_cond
2076   0F83             _while31_exit:
2077   0F83             ;; while (i > 0) { 
2078   0F83             _while32_cond:
2079   0F83 FA FA FF      lea d, [bp + -6] ; $i
2080   0F86 2A            mov b, [d]
2081   0F87             ; START RELATIONAL
2082   0F87 D7            push a
2083   0F88 11            mov a, b
2084   0F89 26 00 00      mov b, $0
2085   0F8C B0            cmp a, b
2086   0F8D FD 7F         sgt ; >
2087   0F8F E4            pop a
2088   0F90             ; END RELATIONAL
2089   0F90 C0 00 00      cmp b, 0
2090   0F93 C6 BC 0F      je _while32_exit
2091   0F96             _while32_block:
2092   0F96             ;; i--; 
2093   0F96 FA FA FF      lea d, [bp + -6] ; $i
2094   0F99 2A            mov b, [d]
2095   0F9A D8            push b
2096   0F9B FD 7D         dec b
2097   0F9D FA FA FF      lea d, [bp + -6] ; $i
2098   0FA0 FD 43         mov [d], b
2099   0FA2 E5            pop b
2100   0FA3             ;; putchar(digits[i]); 
2101   0FA3 FA FC FF      lea d, [bp + -4] ; $digits
2102   0FA6 D7            push a
2103   0FA7 DA            push d
2104   0FA8 FA FA FF      lea d, [bp + -6] ; $i
2105   0FAB 2A            mov b, [d]
2106   0FAC E7            pop d
2107   0FAD 5A            add d, b
2108   0FAE E4            pop a
2109   0FAF 32            mov bl, [d]
2110   0FB0 A7 00         mov bh, 0
2111   0FB2 DD            push bl
2112   0FB3 07 DE 0F      call putchar
2113   0FB6 51 01 00      add sp, 1
2114   0FB9 0A 83 0F      jmp _while32_cond
2115   0FBC             _while32_exit:
2116   0FBC F9            leave
2117   0FBD 09            ret
2118   0FBE             
2119   0FBE             rand:
2120   0FBE F8 00 00      enter 0 ; (push bp; mov bp, sp)
2121   0FC1             ; $sec 
2122   0FC1 52 01 00      sub sp, 1
2123   0FC4             
2124   0FC4             ; --- BEGIN INLINE ASM BLOCK
2125   0FC4 19 00         mov al, 0
2126   0FC6 05 01         syscall sys_rtc					
2127   0FC8 1A            mov al, ah
2128   0FC9 FA 00 00      lea d, [bp + 0] ; $sec
2129   0FCC 1E            mov al, [d]
2130   0FCD             ; --- END INLINE ASM BLOCK
2131   0FCD             
2132   0FCD             ;; return sec; 
2133   0FCD FA 00 00      lea d, [bp + 0] ; $sec
2134   0FD0 32            mov bl, [d]
2135   0FD1 A7 00         mov bh, 0
2136   0FD3 F9            leave
2137   0FD4 09            ret
2138   0FD5             
2139   0FD5             date:
2140   0FD5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2141   0FD8             
2142   0FD8             ; --- BEGIN INLINE ASM BLOCK
2143   0FD8 19 00         mov al, 0 
2144   0FDA 05 07         syscall sys_datetime
2145   0FDC             ; --- END INLINE ASM BLOCK
2146   0FDC             
2147   0FDC F9            leave
2148   0FDD 09            ret
2149   0FDE             
2150   0FDE             putchar:
2151   0FDE F8 00 00      enter 0 ; (push bp; mov bp, sp)
2152   0FE1             
2153   0FE1             ; --- BEGIN INLINE ASM BLOCK
2154   0FE1 FA 05 00      lea d, [bp + 5] ; $c
2155   0FE4 1E            mov al, [d]
2156   0FE5 23            mov ah, al
2157   0FE6 07 5B 12      call _putchar
2158   0FE9             ; --- END INLINE ASM BLOCK
2159   0FE9             
2160   0FE9 F9            leave
2161   0FEA 09            ret
2162   0FEB             
2163   0FEB             getchar:
2164   0FEB F8 00 00      enter 0 ; (push bp; mov bp, sp)
2165   0FEE             ; $c 
2166   0FEE 52 01 00      sub sp, 1
2167   0FF1             
2168   0FF1             ; --- BEGIN INLINE ASM BLOCK
2169   0FF1 07 54 12      call getch
2170   0FF4 1A            mov al, ah
2171   0FF5 FA 00 00      lea d, [bp + 0] ; $c
2172   0FF8 3E            mov [d], al
2173   0FF9             ; --- END INLINE ASM BLOCK
2174   0FF9             
2175   0FF9             ;; return c; 
2176   0FF9 FA 00 00      lea d, [bp + 0] ; $c
2177   0FFC 32            mov bl, [d]
2178   0FFD A7 00         mov bh, 0
2179   0FFF F9            leave
2180   1000 09            ret
2181   1001             
2182   1001             scann:
2183   1001 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2184   1004             ; $m 
2185   1004 52 02 00      sub sp, 2
2186   1007             
2187   1007             ; --- BEGIN INLINE ASM BLOCK
2188   1007 07 9F 14      call scan_u16d
2189   100A FA FF FF      lea d, [bp + -1] ; $m
2190   100D 43            mov [d], a
2191   100E             ; --- END INLINE ASM BLOCK
2192   100E             
2193   100E             ;; return m; 
2194   100E FA FF FF      lea d, [bp + -1] ; $m
2195   1011 2A            mov b, [d]
2196   1012 F9            leave
2197   1013 09            ret
2198   1014             
2199   1014             puts:
2200   1014 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2201   1017             
2202   1017             ; --- BEGIN INLINE ASM BLOCK
2203   1017 FA 05 00      lea d, [bp + 5] ; $s
2204   101A 15            mov a, [d]
2205   101B 3C            mov d, a
2206   101C 07 A5 13      call _puts
2207   101F 10 00 0A      mov a, $0A00
2208   1022 05 03         syscall sys_io
2209   1024             ; --- END INLINE ASM BLOCK
2210   1024             
2211   1024 F9            leave
2212   1025 09            ret
2213   1026             
2214   1026             print:
2215   1026 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2216   1029             
2217   1029             ; --- BEGIN INLINE ASM BLOCK
2218   1029 FA 05 00      lea d, [bp + 5] ; $s
2219   102C FD 2A         mov d, [d]
2220   102E 07 A5 13      call _puts
2221   1031             ; --- END INLINE ASM BLOCK
2222   1031             
2223   1031 F9            leave
2224   1032 09            ret
2225   1033             
2226   1033             loadfile:
2227   1033 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2228   1036             
2229   1036             ; --- BEGIN INLINE ASM BLOCK
2230   1036 FA 07 00      lea d, [bp + 7] ; $destination
2231   1039 15            mov a, [d]
2232   103A 4F            mov di, a
2233   103B FA 05 00      lea d, [bp + 5] ; $filename
2234   103E FD 2A         mov d, [d]
2235   1040 19 14         mov al, 20
2236   1042 05 04         syscall sys_filesystem
2237   1044             ; --- END INLINE ASM BLOCK
2238   1044             
2239   1044 F9            leave
2240   1045 09            ret
2241   1046             
2242   1046             create_file:
2243   1046 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2244   1049 F9            leave
2245   104A 09            ret
2246   104B             
2247   104B             delete_file:
2248   104B F8 00 00      enter 0 ; (push bp; mov bp, sp)
2249   104E             
2250   104E             ; --- BEGIN INLINE ASM BLOCK
2251   104E FA 05 00      lea d, [bp + 5] ; $filename
2252   1051 19 0A         mov al, 10
2253   1053 05 04         syscall sys_filesystem
2254   1055             ; --- END INLINE ASM BLOCK
2255   1055             
2256   1055 F9            leave
2257   1056 09            ret
2258   1057             
2259   1057             fopen:
2260   1057 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2261   105A F9            leave
2262   105B 09            ret
2263   105C             
2264   105C             fclose:
2265   105C F8 00 00      enter 0 ; (push bp; mov bp, sp)
2266   105F F9            leave
2267   1060 09            ret
2268   1061             
2269   1061             alloc:
2270   1061 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2271   1064             ;; heap_top = heap_top + bytes; 
2272   1064 3B 64 15      mov d, _heap_top ; $heap_top
2273   1067 DA            push d
2274   1068 3B 64 15      mov d, _heap_top ; $heap_top
2275   106B 2A            mov b, [d]
2276   106C             ; START TERMS
2277   106C D7            push a
2278   106D 11            mov a, b
2279   106E FA 05 00      lea d, [bp + 5] ; $bytes
2280   1071 2A            mov b, [d]
2281   1072 54            add a, b
2282   1073 27            mov b, a
2283   1074 E4            pop a
2284   1075             ; END TERMS
2285   1075 E7            pop d
2286   1076 FD 43         mov [d], b
2287   1078             ;; return heap_top - bytes; 
2288   1078 3B 64 15      mov d, _heap_top ; $heap_top
2289   107B 2A            mov b, [d]
2290   107C             ; START TERMS
2291   107C D7            push a
2292   107D 11            mov a, b
2293   107E FA 05 00      lea d, [bp + 5] ; $bytes
2294   1081 2A            mov b, [d]
2295   1082 60            sub a, b
2296   1083 27            mov b, a
2297   1084 E4            pop a
2298   1085             ; END TERMS
2299   1085 F9            leave
2300   1086 09            ret
2301   1087             
2302   1087             free:
2303   1087 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2304   108A             ;; return heap_top = heap_top - bytes; 
2305   108A 3B 64 15      mov d, _heap_top ; $heap_top
2306   108D DA            push d
2307   108E 3B 64 15      mov d, _heap_top ; $heap_top
2308   1091 2A            mov b, [d]
2309   1092             ; START TERMS
2310   1092 D7            push a
2311   1093 11            mov a, b
2312   1094 FA 05 00      lea d, [bp + 5] ; $bytes
2313   1097 2A            mov b, [d]
2314   1098 60            sub a, b
2315   1099 27            mov b, a
2316   109A E4            pop a
2317   109B             ; END TERMS
2318   109B E7            pop d
2319   109C FD 43         mov [d], b
2320   109E F9            leave
2321   109F 09            ret
2322   10A0             
2323   10A0             exit:
2324   10A0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2325   10A3             
2326   10A3             ; --- BEGIN INLINE ASM BLOCK
2327   10A3 05 0B         syscall sys_terminate_proc
2328   10A5             ; --- END INLINE ASM BLOCK
2329   10A5             
2330   10A5 F9            leave
2331   10A6 09            ret
2332   10A7             
2333   10A7             load_hex:
2334   10A7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2335   10AA             ; $temp 
2336   10AA 52 02 00      sub sp, 2
2337   10AD             ;; temp = alloc(32768); 
2338   10AD FA FF FF      lea d, [bp + -1] ; $temp
2339   10B0 DA            push d
2340   10B1 26 00 80      mov b, $8000
2341   10B4 FD AB         swp b
2342   10B6 D8            push b
2343   10B7 07 61 10      call alloc
2344   10BA 51 02 00      add sp, 2
2345   10BD E7            pop d
2346   10BE FD 43         mov [d], b
2347   10C0             
2348   10C0             ; --- BEGIN INLINE ASM BLOCK
2349   10C0               
2350   10C0               
2351   10C0               
2352   10C0               
2353   10C0               
2354   10C0             _load_hex:
2355   10C0 D7            push a
2356   10C1 D8            push b
2357   10C2 DA            push d
2358   10C3 E2            push si
2359   10C4 E3            push di
2360   10C5 52 00 80      sub sp, $8000      
2361   10C8 38 00 00      mov c, 0
2362   10CB 48            mov a, sp
2363   10CC 77            inc a
2364   10CD 3C            mov d, a          
2365   10CE 07 62 12      call _gets        
2366   10D1 4D            mov si, a
2367   10D2             __load_hex_loop:
2368   10D2 F6            lodsb             
2369   10D3 B9 00         cmp al, 0         
2370   10D5 C6 E3 10      jz __load_hex_ret
2371   10D8 36            mov bh, al
2372   10D9 F6            lodsb
2373   10DA 2F            mov bl, al
2374   10DB 07 18 12      call _atoi        
2375   10DE F7            stosb             
2376   10DF 78            inc c
2377   10E0 0A D2 10      jmp __load_hex_loop
2378   10E3             __load_hex_ret:
2379   10E3 51 00 80      add sp, $8000
2380   10E6 F0            pop di
2381   10E7 EF            pop si
2382   10E8 E7            pop d
2383   10E9 E5            pop b
2384   10EA E4            pop a
2385   10EB             ; --- END INLINE ASM BLOCK
2386   10EB             
2387   10EB F9            leave
2388   10EC 09            ret
2389   10ED             
2390   10ED             getparam:
2391   10ED F8 00 00      enter 0 ; (push bp; mov bp, sp)
2392   10F0             ; $data 
2393   10F0 52 01 00      sub sp, 1
2394   10F3             
2395   10F3             ; --- BEGIN INLINE ASM BLOCK
2396   10F3 19 04         mov al, 4
2397   10F5 FA 05 00      lea d, [bp + 5] ; $address
2398   10F8 FD 2A         mov d, [d]
2399   10FA 05 0C         syscall sys_system
2400   10FC FA 00 00      lea d, [bp + 0] ; $data
2401   10FF FD 3E         mov [d], bl
2402   1101             ; --- END INLINE ASM BLOCK
2403   1101             
2404   1101             ;; return data; 
2405   1101 FA 00 00      lea d, [bp + 0] ; $data
2406   1104 32            mov bl, [d]
2407   1105 A7 00         mov bh, 0
2408   1107 F9            leave
2409   1108 09            ret
2410   1109             
2411   1109             clear:
2412   1109 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2413   110C             ;; print("\033[2J\033[H"); 
2414   110C 26 5A 15      mov b, __s5 ; "\033[2J\033[H"
2415   110F FD AB         swp b
2416   1111 D8            push b
2417   1112 07 26 10      call print
2418   1115 51 02 00      add sp, 2
2419   1118 F9            leave
2420   1119 09            ret
2421   111A             
2422   111A             printun:
2423   111A F8 00 00      enter 0 ; (push bp; mov bp, sp)
2424   111D             ;; print(prompt); 
2425   111D FA 05 00      lea d, [bp + 5] ; $prompt
2426   1120 2A            mov b, [d]
2427   1121 FD AB         swp b
2428   1123 D8            push b
2429   1124 07 26 10      call print
2430   1127 51 02 00      add sp, 2
2431   112A             ;; print_unsigned(n); 
2432   112A FA 07 00      lea d, [bp + 7] ; $n
2433   112D 2A            mov b, [d]
2434   112E FD AB         swp b
2435   1130 D8            push b
2436   1131 07 F6 0E      call print_unsigned
2437   1134 51 02 00      add sp, 2
2438   1137             ;; print("\n"); 
2439   1137 26 62 15      mov b, __s6 ; "\n"
2440   113A FD AB         swp b
2441   113C D8            push b
2442   113D 07 26 10      call print
2443   1140 51 02 00      add sp, 2
2444   1143 F9            leave
2445   1144 09            ret
2446   1145             
2447   1145             printsn:
2448   1145 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2449   1148             ;; print(prompt); 
2450   1148 FA 05 00      lea d, [bp + 5] ; $prompt
2451   114B 2A            mov b, [d]
2452   114C FD AB         swp b
2453   114E D8            push b
2454   114F 07 26 10      call print
2455   1152 51 02 00      add sp, 2
2456   1155             ;; print_signed(n); 
2457   1155 FA 07 00      lea d, [bp + 7] ; $n
2458   1158 2A            mov b, [d]
2459   1159 FD AB         swp b
2460   115B D8            push b
2461   115C 07 D9 0B      call print_signed
2462   115F 51 02 00      add sp, 2
2463   1162             ;; print("\n"); 
2464   1162 26 62 15      mov b, __s6 ; "\n"
2465   1165 FD AB         swp b
2466   1167 D8            push b
2467   1168 07 26 10      call print
2468   116B 51 02 00      add sp, 2
2469   116E F9            leave
2470   116F 09            ret
2471   1170             
2472   1170             include_stdio_asm:
2473   1170 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2474   1173             
2475   1173             ; --- BEGIN INLINE ASM BLOCK
2476   1173             .include "lib/asm/stdio.asm"
0001+  1173             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  1173             ; stdio.s
0003+  1173             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  1173             .include "lib/asm/string.asm"
0001++ 1173             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 1173             ; string.s
0003++ 1173             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 1173             
0005++ 1173             
0006++ 1173             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 1173             ; _strrev
0008++ 1173             ; reverse a string
0009++ 1173             ; D = string address
0010++ 1173             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 1173             ; 01234
0012++ 1173             _strrev:
0013++ 1173 4B          	pusha
0014++ 1174 07 BA 11    	call _strlen	; length in C
0015++ 1177 12          	mov a, c
0016++ 1178 AF 01 00    	cmp a, 1
0017++ 117B D0 95 11    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 117E 7D          	dec a
0019++ 117F FD 4E       	mov si, d	; beginning of string
0020++ 1181 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 1183 59          	add d, a	; end of string
0022++ 1184 12          	mov a, c
0023++ 1185 FD 9B       	shr a		; divide by 2
0024++ 1187 39          	mov c, a	; C now counts the steps
0025++ 1188             _strrev_L0:
0026++ 1188 32          	mov bl, [d]	; save load right-side char into BL
0027++ 1189 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 118A 3E          	mov [d], al	; store left char into right side
0029++ 118B 1B          	mov al, bl
0030++ 118C F7          	stosb		; store right-side char into left-side; increase DI
0031++ 118D 7E          	dec c
0032++ 118E 7F          	dec d
0033++ 118F C2 00 00    	cmp c, 0
0034++ 1192 C7 88 11    	jne _strrev_L0
0035++ 1195             _strrev_end:
0036++ 1195 4C          	popa
0037++ 1196 09          	ret
0038++ 1197             	
0039++ 1197             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 1197             ; _strchr
0041++ 1197             ; search string in D for char in AL
0042++ 1197             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 1197             _strchr:
0044++ 1197             _strchr_L0:
0045++ 1197 32          	mov bl, [d]
0046++ 1198 C1 00       	cmp bl, 0
0047++ 119A C6 A5 11    	je _strchr_end
0048++ 119D BA          	cmp al, bl
0049++ 119E C6 A5 11    	je _strchr_end
0050++ 11A1 79          	inc d
0051++ 11A2 0A 97 11    	jmp _strchr_L0
0052++ 11A5             _strchr_end:
0053++ 11A5 1B          	mov al, bl
0054++ 11A6 09          	ret
0055++ 11A7             
0056++ 11A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 11A7             ; _strstr
0058++ 11A7             ; find sub-string
0059++ 11A7             ; str1 in SI
0060++ 11A7             ; str2 in DI
0061++ 11A7             ; SI points to end of source string
0062++ 11A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 11A7             _strstr:
0064++ 11A7 DB          	push al
0065++ 11A8 DA          	push d
0066++ 11A9 E3          	push di
0067++ 11AA             _strstr_loop:
0068++ 11AA F3          	cmpsb					; compare a byte of the strings
0069++ 11AB C7 B6 11    	jne _strstr_ret
0070++ 11AE FC 00 00    	lea d, [di + 0]
0071++ 11B1 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 11B3 C7 AA 11    	jne _strstr_loop				; equal chars but not at end
0073++ 11B6             _strstr_ret:
0074++ 11B6 F0          	pop di
0075++ 11B7 E7          	pop d
0076++ 11B8 E8          	pop al
0077++ 11B9 09          	ret
0078++ 11BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 11BA             ; length of null terminated string
0080++ 11BA             ; result in C
0081++ 11BA             ; pointer in D
0082++ 11BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 11BA             _strlen:
0084++ 11BA DA          	push d
0085++ 11BB 38 00 00    	mov c, 0
0086++ 11BE             _strlen_L1:
0087++ 11BE BD 00       	cmp byte [d], 0
0088++ 11C0 C6 C8 11    	je _strlen_ret
0089++ 11C3 79          	inc d
0090++ 11C4 78          	inc c
0091++ 11C5 0A BE 11    	jmp _strlen_L1
0092++ 11C8             _strlen_ret:
0093++ 11C8 E7          	pop d
0094++ 11C9 09          	ret
0095++ 11CA             
0096++ 11CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 11CA             ; STRCMP
0098++ 11CA             ; compare two strings
0099++ 11CA             ; str1 in SI
0100++ 11CA             ; str2 in DI
0101++ 11CA             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 11CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 11CA             _strcmp:
0104++ 11CA DB          	push al
0105++ 11CB DA          	push d
0106++ 11CC E3          	push di
0107++ 11CD E2          	push si
0108++ 11CE             _strcmp_loop:
0109++ 11CE F3          	cmpsb					; compare a byte of the strings
0110++ 11CF C7 DA 11    	jne _strcmp_ret
0111++ 11D2 FB FF FF    	lea d, [si +- 1]
0112++ 11D5 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 11D7 C7 CE 11    	jne _strcmp_loop				; equal chars but not at end
0114++ 11DA             _strcmp_ret:
0115++ 11DA EF          	pop si
0116++ 11DB F0          	pop di
0117++ 11DC E7          	pop d
0118++ 11DD E8          	pop al
0119++ 11DE 09          	ret
0120++ 11DF             
0121++ 11DF             
0122++ 11DF             ; STRCPY
0123++ 11DF             ; copy null terminated string from SI to DI
0124++ 11DF             ; source in SI
0125++ 11DF             ; destination in DI
0126++ 11DF             _strcpy:
0127++ 11DF E2          	push si
0128++ 11E0 E3          	push di
0129++ 11E1 DB          	push al
0130++ 11E2             _strcpy_L1:
0131++ 11E2 F6          	lodsb
0132++ 11E3 F7          	stosb
0133++ 11E4 B9 00       	cmp al, 0
0134++ 11E6 C7 E2 11    	jne _strcpy_L1
0135++ 11E9             _strcpy_end:
0136++ 11E9 E8          	pop al
0137++ 11EA F0          	pop di
0138++ 11EB EF          	pop si
0139++ 11EC 09          	ret
0140++ 11ED             
0141++ 11ED             ; STRCAT
0142++ 11ED             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 11ED             ; source in SI
0144++ 11ED             ; destination in DI
0145++ 11ED             _strcat:
0146++ 11ED E2          	push si
0147++ 11EE E3          	push di
0148++ 11EF D7          	push a
0149++ 11F0 DA          	push d
0150++ 11F1 50          	mov a, di
0151++ 11F2 3C          	mov d, a
0152++ 11F3             _strcat_goto_end_L1:
0153++ 11F3 BD 00       	cmp byte[d], 0
0154++ 11F5 C6 FC 11    	je _strcat_start
0155++ 11F8 79          	inc d
0156++ 11F9 0A F3 11    	jmp _strcat_goto_end_L1
0157++ 11FC             _strcat_start:
0158++ 11FC FD 50       	mov di, d
0159++ 11FE             _strcat_L1:
0160++ 11FE F6          	lodsb
0161++ 11FF F7          	stosb
0162++ 1200 B9 00       	cmp al, 0
0163++ 1202 C7 FE 11    	jne _strcat_L1
0164++ 1205             _strcat_end:
0165++ 1205 E7          	pop d
0166++ 1206 E4          	pop a
0167++ 1207 F0          	pop di
0168++ 1208 EF          	pop si
0169++ 1209 09          	ret
0170++ 120A             
0171++ 120A             
0005+  120A             
0006+  120A             
0007+  120A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  120A             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  120A             ; ASCII in BL
0010+  120A             ; result in AL
0011+  120A             ; ascii for F = 0100 0110
0012+  120A             ; ascii for 9 = 0011 1001
0013+  120A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  120A             hex_ascii_encode:
0015+  120A 1B            mov al, bl
0016+  120B 93 40         test al, $40        ; test if letter or number
0017+  120D C7 13 12      jnz hex_letter
0018+  1210 87 0F         and al, $0F        ; get number
0019+  1212 09            ret
0020+  1213             hex_letter:
0021+  1213 87 0F         and al, $0F        ; get letter
0022+  1215 6A 09         add al, 9
0023+  1217 09            ret
0024+  1218             
0025+  1218             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  1218             ; ATOI
0027+  1218             ; 2 letter hex string in B
0028+  1218             ; 8bit integer returned in AL
0029+  1218             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  1218             _atoi:
0031+  1218 D8            push b
0032+  1219 07 0A 12      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  121C 30            mov bl, bh
0034+  121D DB            push al          ; save a
0035+  121E 07 0A 12      call hex_ascii_encode
0036+  1221 EA            pop bl  
0037+  1222 FD 9E 04      shl al, 4
0038+  1225 8C            or al, bl
0039+  1226 E5            pop b
0040+  1227 09            ret  
0041+  1228             
0042+  1228             
0043+  1228             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  1228             ; scanf
0045+  1228             ; no need for explanations!
0046+  1228             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  1228             scanf:
0048+  1228 09            ret
0049+  1229             
0050+  1229             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  1229             ; ITOA
0052+  1229             ; 8bit value in BL
0053+  1229             ; 2 byte ASCII result in A
0054+  1229             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  1229             _itoa:
0056+  1229 DA            push d
0057+  122A D8            push b
0058+  122B A7 00         mov bh, 0
0059+  122D FD A4 04      shr bl, 4  
0060+  1230 74            mov d, b
0061+  1231 1F D9 14      mov al, [d + s_hex_digits]
0062+  1234 23            mov ah, al
0063+  1235               
0064+  1235 E5            pop b
0065+  1236 D8            push b
0066+  1237 A7 00         mov bh, 0
0067+  1239 FD 87 0F      and bl, $0F
0068+  123C 74            mov d, b
0069+  123D 1F D9 14      mov al, [d + s_hex_digits]
0070+  1240 E5            pop b
0071+  1241 E7            pop d
0072+  1242 09            ret
0073+  1243             
0074+  1243             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  1243             ; HEX STRING TO BINARY
0076+  1243             ; di = destination address
0077+  1243             ; si = source
0078+  1243             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  1243             _hex_to_int:
0080+  1243             _hex_to_int_L1:
0081+  1243 F6            lodsb          ; load from [SI] to AL
0082+  1244 B9 00         cmp al, 0        ; check if ASCII 0
0083+  1246 C6 53 12      jz _hex_to_int_ret
0084+  1249 36            mov bh, al
0085+  124A F6            lodsb
0086+  124B 2F            mov bl, al
0087+  124C 07 18 12      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  124F F7            stosb          ; store AL to [DI]
0089+  1250 0A 43 12      jmp _hex_to_int_L1
0090+  1253             _hex_to_int_ret:
0091+  1253 09            ret    
0092+  1254             
0093+  1254             
0094+  1254             
0095+  1254             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  1254             ; GETCHAR
0097+  1254             ; char in ah
0098+  1254             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  1254             getch:
0100+  1254 DB            push al
0101+  1255             getch_retry:
0102+  1255 19 01         mov al, 1
0103+  1257 05 03         syscall sys_io      ; receive in AH
0104+  1259 E8            pop al
0105+  125A 09            ret
0106+  125B             
0107+  125B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  125B             ; PUTCHAR
0109+  125B             ; char in ah
0110+  125B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  125B             _putchar:
0112+  125B D7            push a
0113+  125C 19 00         mov al, 0
0114+  125E 05 03         syscall sys_io      ; char in AH
0115+  1260 E4            pop a
0116+  1261 09            ret
0117+  1262             
0118+  1262             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  1262             ;; INPUT A STRING
0120+  1262             ;; terminates with null
0121+  1262             ;; pointer in D
0122+  1262             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  1262             _gets:
0124+  1262 D7            push a
0125+  1263 DA            push d
0126+  1264             _gets_loop:
0127+  1264 19 01         mov al, 1
0128+  1266 05 03         syscall sys_io      ; receive in AH
0129+  1268 B9 00         cmp al, 0        ; check error code (AL)
0130+  126A C6 64 12      je _gets_loop      ; if no char received, retry
0131+  126D             
0132+  126D 76 1B         cmp ah, 27
0133+  126F C6 90 12      je _gets_ansi_esc
0134+  1272 76 0A         cmp ah, $0A        ; LF
0135+  1274 C6 FB 12      je _gets_end
0136+  1277 76 0D         cmp ah, $0D        ; CR
0137+  1279 C6 FB 12      je _gets_end
0138+  127C 76 5C         cmp ah, $5C        ; '\\'
0139+  127E C6 BC 12      je _gets_escape
0140+  1281               
0141+  1281 76 08         cmp ah, $08      ; check for backspace
0142+  1283 C6 8C 12      je _gets_backspace
0143+  1286             
0144+  1286 1A            mov al, ah
0145+  1287 3E            mov [d], al
0146+  1288 79            inc d
0147+  1289 0A 64 12      jmp _gets_loop
0148+  128C             _gets_backspace:
0149+  128C 7F            dec d
0150+  128D 0A 64 12      jmp _gets_loop
0151+  1290             _gets_ansi_esc:
0152+  1290 19 01         mov al, 1
0153+  1292 05 03         syscall sys_io        ; receive in AH without echo
0154+  1294 B9 00         cmp al, 0          ; check error code (AL)
0155+  1296 C6 90 12      je _gets_ansi_esc    ; if no char received, retry
0156+  1299 76 5B         cmp ah, '['
0157+  129B C7 64 12      jne _gets_loop
0158+  129E             _gets_ansi_esc_2:
0159+  129E 19 01         mov al, 1
0160+  12A0 05 03         syscall sys_io          ; receive in AH without echo
0161+  12A2 B9 00         cmp al, 0            ; check error code (AL)
0162+  12A4 C6 9E 12      je _gets_ansi_esc_2  ; if no char received, retry
0163+  12A7 76 44         cmp ah, 'D'
0164+  12A9 C6 B4 12      je _gets_left_arrow
0165+  12AC 76 43         cmp ah, 'C'
0166+  12AE C6 B8 12      je _gets_right_arrow
0167+  12B1 0A 64 12      jmp _gets_loop
0168+  12B4             _gets_left_arrow:
0169+  12B4 7F            dec d
0170+  12B5 0A 64 12      jmp _gets_loop
0171+  12B8             _gets_right_arrow:
0172+  12B8 79            inc d
0173+  12B9 0A 64 12      jmp _gets_loop
0174+  12BC             _gets_escape:
0175+  12BC 19 01         mov al, 1
0176+  12BE 05 03         syscall sys_io      ; receive in AH
0177+  12C0 B9 00         cmp al, 0        ; check error code (AL)
0178+  12C2 C6 BC 12      je _gets_escape      ; if no char received, retry
0179+  12C5 76 6E         cmp ah, 'n'
0180+  12C7 C6 E6 12      je _gets_LF
0181+  12CA 76 72         cmp ah, 'r'
0182+  12CC C6 ED 12      je _gets_CR
0183+  12CF 76 30         cmp ah, '0'
0184+  12D1 C6 F4 12      je _gets_NULL
0185+  12D4 76 5C         cmp ah, $5C  ; '\'
0186+  12D6 C6 DF 12      je _gets_slash
0187+  12D9 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0188+  12DA 3E            mov [d], al
0189+  12DB 79            inc d
0190+  12DC 0A 64 12      jmp _gets_loop
0191+  12DF             _gets_slash:
0192+  12DF 19 5C         mov al, $5C
0193+  12E1 3E            mov [d], al
0194+  12E2 79            inc d
0195+  12E3 0A 64 12      jmp _gets_loop
0196+  12E6             _gets_LF:
0197+  12E6 19 0A         mov al, $0A
0198+  12E8 3E            mov [d], al
0199+  12E9 79            inc d
0200+  12EA 0A 64 12      jmp _gets_loop
0201+  12ED             _gets_CR:
0202+  12ED 19 0D         mov al, $0D
0203+  12EF 3E            mov [d], al
0204+  12F0 79            inc d
0205+  12F1 0A 64 12      jmp _gets_loop
0206+  12F4             _gets_NULL:
0207+  12F4 19 00         mov al, $00
0208+  12F6 3E            mov [d], al
0209+  12F7 79            inc d
0210+  12F8 0A 64 12      jmp _gets_loop
0211+  12FB             _gets_end:
0212+  12FB 19 00         mov al, 0
0213+  12FD 3E            mov [d], al        ; terminate string
0214+  12FE E7            pop d
0215+  12FF E4            pop a
0216+  1300 09            ret
0217+  1301             
0218+  1301             
0219+  1301             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0220+  1301             ;; INPUT TEXT
0221+  1301             ;; terminated with CTRL+D
0222+  1301             ;; pointer in D
0223+  1301             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0224+  1301             _gettxt:
0225+  1301 D7            push a
0226+  1302 DA            push d
0227+  1303             _gettxt_loop:
0228+  1303 19 01         mov al, 1
0229+  1305 05 03         syscall sys_io      ; receive in AH
0230+  1307 B9 00         cmp al, 0        ; check error code (AL)
0231+  1309 C6 03 13      je _gettxt_loop    ; if no char received, retry
0232+  130C 76 04         cmp ah, 4      ; EOT
0233+  130E C6 4C 13      je _gettxt_end
0234+  1311 76 08         cmp ah, $08      ; check for backspace
0235+  1313 C6 48 13      je _gettxt_backspace
0236+  1316 76 5C         cmp ah, $5C        ; '\'
0237+  1318 C6 21 13      je _gettxt_escape
0238+  131B 1A            mov al, ah
0239+  131C 3E            mov [d], al
0240+  131D 79            inc d
0241+  131E 0A 03 13      jmp _gettxt_loop
0242+  1321             _gettxt_escape:
0243+  1321 19 01         mov al, 1
0244+  1323 05 03         syscall sys_io      ; receive in AH
0245+  1325 B9 00         cmp al, 0        ; check error code (AL)
0246+  1327 C6 21 13      je _gettxt_escape    ; if no char received, retry
0247+  132A 76 6E         cmp ah, 'n'
0248+  132C C6 3A 13      je _gettxt_LF
0249+  132F 76 72         cmp ah, 'r'
0250+  1331 C6 41 13      je _gettxt_CR
0251+  1334 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0252+  1335 3E            mov [d], al
0253+  1336 79            inc d
0254+  1337 0A 03 13      jmp _gettxt_loop
0255+  133A             _gettxt_LF:
0256+  133A 19 0A         mov al, $0A
0257+  133C 3E            mov [d], al
0258+  133D 79            inc d
0259+  133E 0A 03 13      jmp _gettxt_loop
0260+  1341             _gettxt_CR:
0261+  1341 19 0D         mov al, $0D
0262+  1343 3E            mov [d], al
0263+  1344 79            inc d
0264+  1345 0A 03 13      jmp _gettxt_loop
0265+  1348             _gettxt_backspace:
0266+  1348 7F            dec d
0267+  1349 0A 03 13      jmp _gettxt_loop
0268+  134C             _gettxt_end:
0269+  134C 19 00         mov al, 0
0270+  134E 3E            mov [d], al        ; terminate string
0271+  134F E7            pop d
0272+  1350 E4            pop a
0273+  1351 09            ret
0274+  1352             
0275+  1352             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  1352             ; PRINT NEW LINE
0277+  1352             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0278+  1352             printnl:
0279+  1352 D7            push a
0280+  1353 10 00 0A      mov a, $0A00
0281+  1356 05 03         syscall sys_io
0282+  1358 10 00 0D      mov a, $0D00
0283+  135B 05 03         syscall sys_io
0284+  135D E4            pop a
0285+  135E 09            ret
0286+  135F             
0287+  135F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  135F             ; _strtoint
0289+  135F             ; 4 digit hex string number in d
0290+  135F             ; integer returned in A
0291+  135F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0292+  135F             _strtointx:
0293+  135F D8            push b
0294+  1360 32            mov bl, [d]
0295+  1361 37            mov bh, bl
0296+  1362 33 01 00      mov bl, [d + 1]
0297+  1365 07 18 12      call _atoi        ; convert to int in AL
0298+  1368 23            mov ah, al        ; move to AH
0299+  1369 33 02 00      mov bl, [d + 2]
0300+  136C 37            mov bh, bl
0301+  136D 33 03 00      mov bl, [d + 3]
0302+  1370 07 18 12      call _atoi        ; convert to int in AL
0303+  1373 E5            pop b
0304+  1374 09            ret
0305+  1375             
0306+  1375             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0307+  1375             ; _strtoint
0308+  1375             ; 5 digit base10 string number in d
0309+  1375             ; integer returned in A
0310+  1375             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0311+  1375             _strtoint:
0312+  1375 E2            push si
0313+  1376 D8            push b
0314+  1377 D9            push c
0315+  1378 DA            push d
0316+  1379 07 BA 11      call _strlen      ; get string length in C
0317+  137C 7E            dec c
0318+  137D FD 4E         mov si, d
0319+  137F 12            mov a, c
0320+  1380 FD 99         shl a
0321+  1382 3B F1 14      mov d, table_power
0322+  1385 59            add d, a
0323+  1386 38 00 00      mov c, 0
0324+  1389             _strtoint_L0:
0325+  1389 F6            lodsb      ; load ASCII to al
0326+  138A B9 00         cmp al, 0
0327+  138C C6 9F 13      je _strtoint_end
0328+  138F 6F 30         sub al, $30    ; make into integer
0329+  1391 22 00         mov ah, 0
0330+  1393 2A            mov b, [d]
0331+  1394 AC            mul a, b      ; result in B since it fits in 16bits
0332+  1395 11            mov a, b
0333+  1396 28            mov b, c
0334+  1397 54            add a, b
0335+  1398 39            mov c, a
0336+  1399 63 02 00      sub d, 2
0337+  139C 0A 89 13      jmp _strtoint_L0
0338+  139F             _strtoint_end:
0339+  139F 12            mov a, c
0340+  13A0 E7            pop d
0341+  13A1 E6            pop c
0342+  13A2 E5            pop b
0343+  13A3 EF            pop si
0344+  13A4 09            ret
0345+  13A5             
0346+  13A5             
0347+  13A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0348+  13A5             ; PRINT NULL TERMINATED STRING
0349+  13A5             ; pointer in D
0350+  13A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0351+  13A5             _puts:
0352+  13A5 D7            push a
0353+  13A6 DA            push d
0354+  13A7             _puts_L1:
0355+  13A7 1E            mov al, [d]
0356+  13A8 B9 00         cmp al, 0
0357+  13AA C6 B6 13      jz _puts_END
0358+  13AD 23            mov ah, al
0359+  13AE 19 00         mov al, 0
0360+  13B0 05 03         syscall sys_io
0361+  13B2 79            inc d
0362+  13B3 0A A7 13      jmp _puts_L1
0363+  13B6             _puts_END:
0364+  13B6 E7            pop d
0365+  13B7 E4            pop a
0366+  13B8 09            ret
0367+  13B9             
0368+  13B9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0369+  13B9             ; PRINT N SIZE STRING
0370+  13B9             ; pointer in D
0371+  13B9             ; size in C
0372+  13B9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0373+  13B9             _putsn:
0374+  13B9 DB            push al
0375+  13BA DA            push d
0376+  13BB D9            push c
0377+  13BC             _putsn_L0:
0378+  13BC 1E            mov al, [d]
0379+  13BD 23            mov ah, al
0380+  13BE 19 00         mov al, 0
0381+  13C0 05 03         syscall sys_io
0382+  13C2 79            inc d
0383+  13C3 7E            dec c  
0384+  13C4 C2 00 00      cmp c, 0
0385+  13C7 C7 BC 13      jne _putsn_L0
0386+  13CA             _putsn_end:
0387+  13CA E6            pop c
0388+  13CB E7            pop d
0389+  13CC E8            pop al
0390+  13CD 09            ret
0391+  13CE             
0392+  13CE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0393+  13CE             ; print 16bit decimal number
0394+  13CE             ; input number in A
0395+  13CE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0396+  13CE             print_u16d:
0397+  13CE D7            push a
0398+  13CF D8            push b
0399+  13D0 26 10 27      mov b, 10000
0400+  13D3 AE            div a, b      ; get 10000's coeff.
0401+  13D4 07 F6 13      call print_number
0402+  13D7 11            mov a, b
0403+  13D8 26 E8 03      mov b, 1000
0404+  13DB AE            div a, b      ; get 1000's coeff.
0405+  13DC 07 F6 13      call print_number
0406+  13DF 11            mov a, b
0407+  13E0 26 64 00      mov b, 100
0408+  13E3 AE            div a, b
0409+  13E4 07 F6 13      call print_number
0410+  13E7 11            mov a, b
0411+  13E8 26 0A 00      mov b, 10
0412+  13EB AE            div a, b
0413+  13EC 07 F6 13      call print_number
0414+  13EF 1B            mov al, bl      ; 1's coeff in bl
0415+  13F0 07 F6 13      call print_number
0416+  13F3 E5            pop b
0417+  13F4 E4            pop a
0418+  13F5 09            ret
0419+  13F6             
0420+  13F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0421+  13F6             ; print AL
0422+  13F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0423+  13F6             print_number:
0424+  13F6 6A 30         add al, $30
0425+  13F8 23            mov ah, al
0426+  13F9 07 5B 12      call _putchar
0427+  13FC 09            ret
0428+  13FD             
0429+  13FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0430+  13FD             ; PRINT 16BIT HEX INTEGER
0431+  13FD             ; integer value in reg B
0432+  13FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  13FD             print_u16x:
0434+  13FD D7            push a
0435+  13FE D8            push b
0436+  13FF DD            push bl
0437+  1400 30            mov bl, bh
0438+  1401 07 29 12      call _itoa        ; convert bh to char in A
0439+  1404 2F            mov bl, al        ; save al
0440+  1405 19 00         mov al, 0
0441+  1407 05 03         syscall sys_io        ; display AH
0442+  1409 24            mov ah, bl        ; retrieve al
0443+  140A 19 00         mov al, 0
0444+  140C 05 03         syscall sys_io        ; display AL
0445+  140E             
0446+  140E EA            pop bl
0447+  140F 07 29 12      call _itoa        ; convert bh to char in A
0448+  1412 2F            mov bl, al        ; save al
0449+  1413 19 00         mov al, 0
0450+  1415 05 03         syscall sys_io        ; display AH
0451+  1417 24            mov ah, bl        ; retrieve al
0452+  1418 19 00         mov al, 0
0453+  141A 05 03         syscall sys_io        ; display AL
0454+  141C             
0455+  141C E5            pop b
0456+  141D E4            pop a
0457+  141E 09            ret
0458+  141F             
0459+  141F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0460+  141F             ; INPUT 16BIT HEX INTEGER
0461+  141F             ; read 16bit integer into A
0462+  141F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0463+  141F             scan_u16x:
0464+  141F F8 10 00      enter 16
0465+  1422 D8            push b
0466+  1423 DA            push d
0467+  1424             
0468+  1424 FA F1 FF      lea d, [bp + -15]
0469+  1427 07 62 12      call _gets        ; get number
0470+  142A             
0471+  142A 32            mov bl, [d]
0472+  142B 37            mov bh, bl
0473+  142C 33 01 00      mov bl, [d + 1]
0474+  142F 07 18 12      call _atoi        ; convert to int in AL
0475+  1432 23            mov ah, al        ; move to AH
0476+  1433             
0477+  1433 33 02 00      mov bl, [d + 2]
0478+  1436 37            mov bh, bl
0479+  1437 33 03 00      mov bl, [d + 3]
0480+  143A 07 18 12      call _atoi        ; convert to int in AL
0481+  143D             
0482+  143D E7            pop d
0483+  143E E5            pop b
0484+  143F F9            leave
0485+  1440 09            ret
0486+  1441             
0487+  1441             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0488+  1441             ; PRINT 8bit HEX INTEGER
0489+  1441             ; integer value in reg bl
0490+  1441             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0491+  1441             print_u8x:
0492+  1441 D7            push a
0493+  1442 DD            push bl
0494+  1443             
0495+  1443 07 29 12      call _itoa        ; convert bl to char in A
0496+  1446 2F            mov bl, al        ; save al
0497+  1447 19 00         mov al, 0
0498+  1449 05 03         syscall sys_io        ; display AH
0499+  144B 24            mov ah, bl        ; retrieve al
0500+  144C 19 00         mov al, 0
0501+  144E 05 03         syscall sys_io        ; display AL
0502+  1450             
0503+  1450 EA            pop bl
0504+  1451 E4            pop a
0505+  1452 09            ret
0506+  1453             
0507+  1453             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0508+  1453             ; print 8bit decimal unsigned number
0509+  1453             ; input number in AL
0510+  1453             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0511+  1453             print_u8d:
0512+  1453 D7            push a
0513+  1454 D8            push b
0514+  1455             
0515+  1455 22 00         mov ah, 0
0516+  1457 26 64 00      mov b, 100
0517+  145A AE            div a, b
0518+  145B D8            push b      ; save remainder
0519+  145C B9 00         cmp al, 0
0520+  145E C6 68 14      je skip100
0521+  1461 6A 30         add al, $30
0522+  1463 23            mov ah, al
0523+  1464 19 00         mov al, 0
0524+  1466 05 03         syscall sys_io  ; print coeff
0525+  1468             skip100:
0526+  1468 E4            pop a
0527+  1469 22 00         mov ah, 0
0528+  146B 26 0A 00      mov b, 10
0529+  146E AE            div a, b
0530+  146F D8            push b      ; save remainder
0531+  1470 B9 00         cmp al, 0
0532+  1472 C6 7C 14      je skip10
0533+  1475 6A 30         add al, $30
0534+  1477 23            mov ah, al
0535+  1478 19 00         mov al, 0
0536+  147A 05 03         syscall sys_io  ; print coeff
0537+  147C             skip10:
0538+  147C E4            pop a
0539+  147D 1B            mov al, bl
0540+  147E 6A 30         add al, $30
0541+  1480 23            mov ah, al
0542+  1481 19 00         mov al, 0
0543+  1483 05 03         syscall sys_io  ; print coeff
0544+  1485 E5            pop b
0545+  1486 E4            pop a
0546+  1487 09            ret
0547+  1488             
0548+  1488             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0549+  1488             ; INPUT 8BIT HEX INTEGER
0550+  1488             ; read 8bit integer into AL
0551+  1488             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0552+  1488             scan_u8x:
0553+  1488 F8 04 00      enter 4
0554+  148B D8            push b
0555+  148C DA            push d
0556+  148D             
0557+  148D FA FD FF      lea d, [bp + -3]
0558+  1490 07 62 12      call _gets        ; get number
0559+  1493             
0560+  1493 32            mov bl, [d]
0561+  1494 37            mov bh, bl
0562+  1495 33 01 00      mov bl, [d + 1]
0563+  1498 07 18 12      call _atoi        ; convert to int in AL
0564+  149B             
0565+  149B E7            pop d
0566+  149C E5            pop b
0567+  149D F9            leave
0568+  149E 09            ret
0569+  149F             
0570+  149F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  149F             ; input decimal number
0572+  149F             ; result in A
0573+  149F             ; 655'\0'
0574+  149F             ; low--------high
0575+  149F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0576+  149F             scan_u16d:
0577+  149F F8 08 00      enter 8
0578+  14A2 E2            push si
0579+  14A3 D8            push b
0580+  14A4 D9            push c
0581+  14A5 DA            push d
0582+  14A6 FA F9 FF      lea d, [bp +- 7]
0583+  14A9 07 62 12      call _gets
0584+  14AC 07 BA 11      call _strlen      ; get string length in C
0585+  14AF 7E            dec c
0586+  14B0 FD 4E         mov si, d
0587+  14B2 12            mov a, c
0588+  14B3 FD 99         shl a
0589+  14B5 3B F1 14      mov d, table_power
0590+  14B8 59            add d, a
0591+  14B9 38 00 00      mov c, 0
0592+  14BC             mul_loop:
0593+  14BC F6            lodsb      ; load ASCII to al
0594+  14BD B9 00         cmp al, 0
0595+  14BF C6 D2 14      je mul_exit
0596+  14C2 6F 30         sub al, $30    ; make into integer
0597+  14C4 22 00         mov ah, 0
0598+  14C6 2A            mov b, [d]
0599+  14C7 AC            mul a, b      ; result in B since it fits in 16bits
0600+  14C8 11            mov a, b
0601+  14C9 28            mov b, c
0602+  14CA 54            add a, b
0603+  14CB 39            mov c, a
0604+  14CC 63 02 00      sub d, 2
0605+  14CF 0A BC 14      jmp mul_loop
0606+  14D2             mul_exit:
0607+  14D2 12            mov a, c
0608+  14D3 E7            pop d
0609+  14D4 E6            pop c
0610+  14D5 E5            pop b
0611+  14D6 EF            pop si
0612+  14D7 F9            leave
0613+  14D8 09            ret
0614+  14D9             
0615+  14D9             
0616+  14D9 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0616+  14DD 34 35 36 37 
0616+  14E1 38 39 41 42 
0616+  14E5 43 44 45 46 
0617+  14E9 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0617+  14ED 1B 5B 48 00 
0618+  14F1             
0619+  14F1             table_power:
0620+  14F1 01 00         .dw 1
0621+  14F3 0A 00         .dw 10
0622+  14F5 64 00         .dw 100
0623+  14F7 E8 03         .dw 1000
0624+  14F9 10 27         .dw 100002477   14FB             ; --- END INLINE ASM BLOCK
2478   14FB             
2479   14FB F9            leave
2480   14FC 09            ret
2481   14FD             ; --- END TEXT BLOCK
2482   14FD             
2483   14FD             ; --- BEGIN DATA BLOCK
2484   14FD 56 61 6C 75 __s0: .db "Value: %c\n", 0
2484   1501 65 3A 20 25 
2484   1505 63 0A 00 
2485   1508 56 61 6C 75 __s1: .db "Value: %d\n", 0
2485   150C 65 3A 20 25 
2485   1510 64 0A 00 
2486   1513 56 61 6C 75 __s2: .db "Value: %x\n", 0
2486   1517 65 3A 20 25 
2486   151B 78 0A 00 
2487   151E 55 6E 65 78 __s3: .db "Unexpected format in printf.", 0
2487   1522 70 65 63 74 
2487   1526 65 64 20 66 
2487   152A 6F 72 6D 61 
2487   152E 74 20 69 6E 
2487   1532 20 70 72 69 
2487   1536 6E 74 66 2E 
2487   153A 00 
2488   153B 45 72 72 6F __s4: .db "Error: Unknown argument type.\n", 0
2488   153F 72 3A 20 55 
2488   1543 6E 6B 6E 6F 
2488   1547 77 6E 20 61 
2488   154B 72 67 75 6D 
2488   154F 65 6E 74 20 
2488   1553 74 79 70 65 
2488   1557 2E 0A 00 
2489   155A 1B 5B 32 4A __s5: .db "\033[2J\033[H", 0
2489   155E 1B 5B 48 00 
2490   1562 0A 00       __s6: .db "\n", 0
2491   1564             
2492   1564 66 15       _heap_top: .dw _heap
2493   1566 00          _heap: .db 0
2494   1567             ; --- END DATA BLOCK
2495   1567             
2496   1567             .end
tasm: Number of errors = 0
