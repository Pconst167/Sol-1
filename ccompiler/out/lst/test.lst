0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             sys_break        .EQU  $0000
0002+  0000             sys_rtc          .EQU  $0001
0003+  0000             sys_ide          .EQU  $0002
0004+  0000             sys_io           .EQU  $0003
0005+  0000             sys_filesystem   .EQU  $0004
0006+  0000             sys_create_proc  .EQU  $0005
0007+  0000             sys_list_proc    .EQU  $0006
0008+  0000             sys_datetime     .EQU  $0007
0009+  0000             sys_reboot       .EQU  $0008
0010+  0000             sys_pause_proc   .EQU  $0009
0011+  0000             sys_resume_proc  .EQU  $000a
0012+  0000             sys_terminate_proc .EQU  $000b
0013+  0000             sys_system       .EQU  $000c
0014+  0000             sys_fdc          .EQU  $000d
0015+  0000             text_org         .EQU  $0400
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0000             
0005   0000             ; --- BEGIN TEXT SEGMENT
0006   0400             .org text_org
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; long int a = 65536; 
0011   0408 52 04 00      sub sp, 4
0012   040B             ; --- START LOCAL VAR INITIALIZATION
0013   040B FA FD FF      lea d, [bp + -3] ; $a
0014   040E DA            push d
0015   040F FD 2E 00 00   mov32 cb, $00010000
0015   0413 01 00 
0016   0415 E7            pop d
0017   0416 FD 43         mov [d], b
0018   0418 28            mov b, c
0019   0419 FD 44 02 00   mov [d + 2], b
0020   041D             ; --- END LOCAL VAR INITIALIZATION
0021   041D             ; print_unsigned_long(a); 
0022   041D             ; --- START FUNCTION CALL
0023   041D FA FD FF      lea d, [bp + -3] ; $a
0024   0420 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0025   0423 FD 39         mov c, b ; And place it into C
0026   0425 2A            mov b, [d] ; Lower Word in B
0027   0426 12            mov a, c
0028   0427 FD AA         swp a
0029   0429 D7            push a
0030   042A FD AB         swp b
0031   042C D8            push b
0032   042D 07 35 04      call print_unsigned_long
0033   0430 51 04 00      add sp, 4
0034   0433             ; --- END FUNCTION CALL
0035   0433 05 0B         syscall sys_terminate_proc
0036   0435             
0037   0435             print_unsigned_long:
0038   0435 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0039   0438             ; char digits[10]; 
0040   0438 52 0A 00      sub sp, 10
0041   043B             ; int i; 
0042   043B 52 02 00      sub sp, 2
0043   043E             ; i = 0; 
0044   043E FA F5 FF      lea d, [bp + -11] ; $i
0045   0441 DA            push d
0046   0442 FD 2E 00 00   mov32 cb, $00000000
0046   0446 00 00 
0047   0448 E7            pop d
0048   0449 FD 43         mov [d], b
0049   044B             ; if(num == 0){ 
0050   044B             _if1_cond:
0051   044B FA 05 00      lea d, [bp + 5] ; $num
0052   044E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0053   0451 FD 39         mov c, b ; And place it into C
0054   0453 2A            mov b, [d] ; Lower Word in B
0055   0454             ; --- START RELATIONAL
0056   0454 D7            push a
0057   0455 FD D8         push g
0058   0457 11            mov a, b
0059   0458 FD 7A         mov g, c
0060   045A FD 2E 00 00   mov32 cb, $00000000
0060   045E 00 00 
0061   0460 FD AF         cmp32 ga, cb
0062   0462 FD 71         seq ; ==
0063   0464 FD F1         pop g
0064   0466 E4            pop a
0065   0467             ; --- END RELATIONAL
0066   0467 C0 00 00      cmp b, 0
0067   046A C6 7F 04      je _if1_exit
0068   046D             _if1_TRUE:
0069   046D             ; putchar('0'); 
0070   046D             ; --- START FUNCTION CALL
0071   046D FD 2E 30 00   mov32 cb, $00000030
0071   0471 00 00 
0072   0473 DD            push bl
0073   0474 07 69 05      call putchar
0074   0477 51 01 00      add sp, 1
0075   047A             ; --- END FUNCTION CALL
0076   047A             ; return; 
0077   047A F9            leave
0078   047B 09            ret
0079   047C 0A 7F 04      jmp _if1_exit
0080   047F             _if1_exit:
0081   047F             ; while (num > 0) { 
0082   047F             _while2_cond:
0083   047F FA 05 00      lea d, [bp + 5] ; $num
0084   0482 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0085   0485 FD 39         mov c, b ; And place it into C
0086   0487 2A            mov b, [d] ; Lower Word in B
0087   0488             ; --- START RELATIONAL
0088   0488 D7            push a
0089   0489 FD D8         push g
0090   048B 11            mov a, b
0091   048C FD 7A         mov g, c
0092   048E FD 2E 00 00   mov32 cb, $00000000
0092   0492 00 00 
0093   0494 FD AF         cmp32 ga, cb
0094   0496 FD 81         sgu
0095   0498 FD F1         pop g
0096   049A E4            pop a
0097   049B             ; --- END RELATIONAL
0098   049B C0 00 00      cmp b, 0
0099   049E C6 1F 05      je _while2_exit
0100   04A1             _while2_block:
0101   04A1             ; digits[i] = '0' + (num % 10); 
0102   04A1 FA F7 FF      lea d, [bp + -9] ; $digits
0103   04A4 D7            push a
0104   04A5 DA            push d
0105   04A6 FA F5 FF      lea d, [bp + -11] ; $i
0106   04A9 2A            mov b, [d]
0107   04AA 38 00 00      mov c, 0
0108   04AD E7            pop d
0109   04AE 5A            add d, b
0110   04AF E4            pop a
0111   04B0 DA            push d
0112   04B1 FD 2E 30 00   mov32 cb, $00000030
0112   04B5 00 00 
0113   04B7             ; --- START TERMS
0114   04B7 D7            push a
0115   04B8 11            mov a, b
0116   04B9 FA 05 00      lea d, [bp + 5] ; $num
0117   04BC 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0118   04BF FD 39         mov c, b ; And place it into C
0119   04C1 2A            mov b, [d] ; Lower Word in B
0120   04C2             ; --- START FACTORS
0121   04C2 D7            push a
0122   04C3 FD D8         push g
0123   04C5 11            mov a, b
0124   04C6 FD 7A         mov g, c
0125   04C8 FD 2E 0A 00   mov32 cb, $0000000a
0125   04CC 00 00 
0126   04CE FD D8         push g ; save 'g' as the div instruction uses it
0127   04D0 AE            div a, b ; %, a: quotient, b: remainder
0128   04D1 11            mov a, b
0129   04D2 FD F1         pop g
0130   04D4 FD 38         mov c, g
0131   04D6 27            mov b, a
0132   04D7 FD F1         pop g
0133   04D9 E4            pop a
0134   04DA             ; --- END FACTORS
0135   04DA FD 15         add32 cb, ga
0136   04DC E4            pop a
0137   04DD             ; --- END TERMS
0138   04DD E7            pop d
0139   04DE FD 3E         mov [d], bl
0140   04E0             ; num = num / 10; 
0141   04E0 FA 05 00      lea d, [bp + 5] ; $num
0142   04E3 DA            push d
0143   04E4 FA 05 00      lea d, [bp + 5] ; $num
0144   04E7 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0145   04EA FD 39         mov c, b ; And place it into C
0146   04EC 2A            mov b, [d] ; Lower Word in B
0147   04ED             ; --- START FACTORS
0148   04ED D7            push a
0149   04EE FD D8         push g
0150   04F0 11            mov a, b
0151   04F1 FD 7A         mov g, c
0152   04F3 FD 2E 0A 00   mov32 cb, $0000000a
0152   04F7 00 00 
0153   04F9 FD D8         push g ; save 'g' as the div instruction uses it
0154   04FB AE            div a, b ; /, a: quotient, b: remainder
0155   04FC FD F1         pop g
0156   04FE FD 38         mov c, g
0157   0500 27            mov b, a
0158   0501 FD F1         pop g
0159   0503 E4            pop a
0160   0504             ; --- END FACTORS
0161   0504 E7            pop d
0162   0505 FD 43         mov [d], b
0163   0507 28            mov b, c
0164   0508 FD 44 02 00   mov [d + 2], b
0165   050C             ; i++; 
0166   050C FA F5 FF      lea d, [bp + -11] ; $i
0167   050F 2A            mov b, [d]
0168   0510 38 00 00      mov c, 0
0169   0513 11            mov a, b
0170   0514 FD 77         inc b
0171   0516 FA F5 FF      lea d, [bp + -11] ; $i
0172   0519 FD 43         mov [d], b
0173   051B 27            mov b, a
0174   051C 0A 7F 04      jmp _while2_cond
0175   051F             _while2_exit:
0176   051F             ; while (i > 0) { 
0177   051F             _while9_cond:
0178   051F FA F5 FF      lea d, [bp + -11] ; $i
0179   0522 2A            mov b, [d]
0180   0523 38 00 00      mov c, 0
0181   0526             ; --- START RELATIONAL
0182   0526 D7            push a
0183   0527 11            mov a, b
0184   0528 FD 2E 00 00   mov32 cb, $00000000
0184   052C 00 00 
0185   052E B0            cmp a, b
0186   052F FD 7F         sgt ; >
0187   0531 E4            pop a
0188   0532             ; --- END RELATIONAL
0189   0532 C0 00 00      cmp b, 0
0190   0535 C6 67 05      je _while9_exit
0191   0538             _while9_block:
0192   0538             ; i--; 
0193   0538 FA F5 FF      lea d, [bp + -11] ; $i
0194   053B 2A            mov b, [d]
0195   053C 38 00 00      mov c, 0
0196   053F 11            mov a, b
0197   0540 FD 7D         dec b
0198   0542 FA F5 FF      lea d, [bp + -11] ; $i
0199   0545 FD 43         mov [d], b
0200   0547 27            mov b, a
0201   0548             ; putchar(digits[i]); 
0202   0548             ; --- START FUNCTION CALL
0203   0548 FA F7 FF      lea d, [bp + -9] ; $digits
0204   054B D7            push a
0205   054C DA            push d
0206   054D FA F5 FF      lea d, [bp + -11] ; $i
0207   0550 2A            mov b, [d]
0208   0551 38 00 00      mov c, 0
0209   0554 E7            pop d
0210   0555 5A            add d, b
0211   0556 E4            pop a
0212   0557 32            mov bl, [d]
0213   0558 A7 00         mov bh, 0
0214   055A 38 00 00      mov c, 0
0215   055D DD            push bl
0216   055E 07 69 05      call putchar
0217   0561 51 01 00      add sp, 1
0218   0564             ; --- END FUNCTION CALL
0219   0564 0A 1F 05      jmp _while9_cond
0220   0567             _while9_exit:
0221   0567 F9            leave
0222   0568 09            ret
0223   0569             
0224   0569             putchar:
0225   0569 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0226   056C             ; --- BEGIN INLINE ASM SEGMENT
0227   056C FA 05 00      lea d, [bp + 5] ; $c
0228   056F 1E            mov al, [d]
0229   0570 23            mov ah, al
0230   0571 19 00         mov al, 0
0231   0573 05 03         syscall sys_io      ; char in AH
0232   0575             ; --- END INLINE ASM SEGMENT
0233   0575 F9            leave
0234   0576 09            ret
0235   0577             ; --- END TEXT SEGMENT
0236   0577             
0237   0577             ; --- BEGIN DATA SEGMENT
0238   0577             
0239   0577 79 05       _heap_top: .dw _heap
0240   0579 00          _heap: .db 0
0241   057A             ; --- END DATA SEGMENT
0242   057A             
0243   057A             .end
tasm: Number of errors = 0
