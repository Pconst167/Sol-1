0001   0000             ; --- FILENAME: test.c
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0000             
0005   0000             ; --- BEGIN TEXT SEGMENT
0006   0400             .org text_org
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; hide_cursor(1); 
0011   0408             ; --- START FUNCTION CALL
0012   0408 FD 2E 01 00   mov32 cb, $00000001
0012   040C 00 00 
0013   040E DD            push bl
0014   040F 07 08 08      call hide_cursor
0015   0412 51 01 00      add sp, 1
0016   0415             ; --- END FUNCTION CALL
0017   0415             ; --- BEGIN INLINE ASM SEGMENT
0018   0415 38 FF FF      mov c, 65535
0019   0418             label:
0020   0418 D9            push c
0021   0419             ; --- END INLINE ASM SEGMENT
0022   0419             ; move_cursor(10,10); 
0023   0419             ; --- START FUNCTION CALL
0024   0419 FD 2E 0A 00   mov32 cb, $0000000a
0024   041D 00 00 
0025   041F FD AB         swp b
0026   0421 D8            push b
0027   0422 FD 2E 0A 00   mov32 cb, $0000000a
0027   0426 00 00 
0028   0428 FD AB         swp b
0029   042A D8            push b
0030   042B 07 34 11      call move_cursor
0031   042E 51 04 00      add sp, 4
0032   0431             ; --- END FUNCTION CALL
0033   0431             ; --- BEGIN INLINE ASM SEGMENT
0034   0431 E6            pop c
0035   0432 28            mov b, c
0036   0433 07 D2 06      call print_u16x
0037   0436 A9 18 04      loopc label
0038   0439             ; --- END INLINE ASM SEGMENT
0039   0439             ; hide_cursor(0); 
0040   0439             ; --- START FUNCTION CALL
0041   0439 FD 2E 00 00   mov32 cb, $00000000
0041   043D 00 00 
0042   043F DD            push bl
0043   0440 07 08 08      call hide_cursor
0044   0443 51 01 00      add sp, 1
0045   0446             ; --- END FUNCTION CALL
0046   0446             ; return; 
0047   0446 F9            leave
0048   0447 05 0B         syscall sys_terminate_proc
0049   0449             ; --- BEGIN INLINE ASM SEGMENT
0050   0449             .include "lib/asm/stdio.asm"
0001+  0449             ;-----------------------------------------------------------------------------
0002+  0449             ; stdio.s
0003+  0449             ;-----------------------------------------------------------------------------
0004+  0449             .include "lib/asm/string.asm"
0001++ 0449             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0449             ; string.s
0003++ 0449             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0449             
0005++ 0449             
0006++ 0449             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0449             ; _strrev
0008++ 0449             ; reverse a string
0009++ 0449             ; D = string address
0010++ 0449             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0449             ; 01234
0012++ 0449             _strrev:
0013++ 0449 4B          	pusha
0014++ 044A 07 90 04    	call _strlen	; length in C
0015++ 044D 12          	mov a, c
0016++ 044E AF 01 00    	cmp a, 1
0017++ 0451 D0 6B 04    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 0454 7D          	dec a
0019++ 0455 FD 4E       	mov si, d	; beginning of string
0020++ 0457 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0459 59          	add d, a	; end of string
0022++ 045A 12          	mov a, c
0023++ 045B FD 9B       	shr a		; divide by 2
0024++ 045D 39          	mov c, a	; C now counts the steps
0025++ 045E             _strrev_L0:
0026++ 045E 32          	mov bl, [d]	; save load right-side char into BL
0027++ 045F F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0460 3E          	mov [d], al	; store left char into right side
0029++ 0461 1B          	mov al, bl
0030++ 0462 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0463 7E          	dec c
0032++ 0464 7F          	dec d
0033++ 0465 C2 00 00    	cmp c, 0
0034++ 0468 C7 5E 04    	jne _strrev_L0
0035++ 046B             _strrev_end:
0036++ 046B 4C          	popa
0037++ 046C 09          	ret
0038++ 046D             	
0039++ 046D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 046D             ; _strchr
0041++ 046D             ; search string in D for char in AL
0042++ 046D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 046D             _strchr:
0044++ 046D             _strchr_L0:
0045++ 046D 32          	mov bl, [d]
0046++ 046E C1 00       	cmp bl, 0
0047++ 0470 C6 7B 04    	je _strchr_end
0048++ 0473 BA          	cmp al, bl
0049++ 0474 C6 7B 04    	je _strchr_end
0050++ 0477 79          	inc d
0051++ 0478 0A 6D 04    	jmp _strchr_L0
0052++ 047B             _strchr_end:
0053++ 047B 1B          	mov al, bl
0054++ 047C 09          	ret
0055++ 047D             
0056++ 047D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 047D             ; _strstr
0058++ 047D             ; find sub-string
0059++ 047D             ; str1 in SI
0060++ 047D             ; str2 in DI
0061++ 047D             ; SI points to end of source string
0062++ 047D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 047D             _strstr:
0064++ 047D DB          	push al
0065++ 047E DA          	push d
0066++ 047F E3          	push di
0067++ 0480             _strstr_loop:
0068++ 0480 F3          	cmpsb					; compare a byte of the strings
0069++ 0481 C7 8C 04    	jne _strstr_ret
0070++ 0484 FC 00 00    	lea d, [di + 0]
0071++ 0487 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0489 C7 80 04    	jne _strstr_loop				; equal chars but not at end
0073++ 048C             _strstr_ret:
0074++ 048C F0          	pop di
0075++ 048D E7          	pop d
0076++ 048E E8          	pop al
0077++ 048F 09          	ret
0078++ 0490             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0490             ; length of null terminated string
0080++ 0490             ; result in C
0081++ 0490             ; pointer in D
0082++ 0490             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0490             _strlen:
0084++ 0490 DA          	push d
0085++ 0491 38 00 00    	mov c, 0
0086++ 0494             _strlen_L1:
0087++ 0494 BD 00       	cmp byte [d], 0
0088++ 0496 C6 9E 04    	je _strlen_ret
0089++ 0499 79          	inc d
0090++ 049A 78          	inc c
0091++ 049B 0A 94 04    	jmp _strlen_L1
0092++ 049E             _strlen_ret:
0093++ 049E E7          	pop d
0094++ 049F 09          	ret
0095++ 04A0             
0096++ 04A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 04A0             ; STRCMP
0098++ 04A0             ; compare two strings
0099++ 04A0             ; str1 in SI
0100++ 04A0             ; str2 in DI
0101++ 04A0             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 04A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 04A0             _strcmp:
0104++ 04A0 DB          	push al
0105++ 04A1 DA          	push d
0106++ 04A2 E3          	push di
0107++ 04A3 E2          	push si
0108++ 04A4             _strcmp_loop:
0109++ 04A4 F3          	cmpsb					; compare a byte of the strings
0110++ 04A5 C7 B0 04    	jne _strcmp_ret
0111++ 04A8 FB FF FF    	lea d, [si +- 1]
0112++ 04AB BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 04AD C7 A4 04    	jne _strcmp_loop				; equal chars but not at end
0114++ 04B0             _strcmp_ret:
0115++ 04B0 EF          	pop si
0116++ 04B1 F0          	pop di
0117++ 04B2 E7          	pop d
0118++ 04B3 E8          	pop al
0119++ 04B4 09          	ret
0120++ 04B5             
0121++ 04B5             
0122++ 04B5             ; STRCPY
0123++ 04B5             ; copy null terminated string from SI to DI
0124++ 04B5             ; source in SI
0125++ 04B5             ; destination in DI
0126++ 04B5             _strcpy:
0127++ 04B5 E2          	push si
0128++ 04B6 E3          	push di
0129++ 04B7 DB          	push al
0130++ 04B8             _strcpy_L1:
0131++ 04B8 F6          	lodsb
0132++ 04B9 F7          	stosb
0133++ 04BA B9 00       	cmp al, 0
0134++ 04BC C7 B8 04    	jne _strcpy_L1
0135++ 04BF             _strcpy_end:
0136++ 04BF E8          	pop al
0137++ 04C0 F0          	pop di
0138++ 04C1 EF          	pop si
0139++ 04C2 09          	ret
0140++ 04C3             
0141++ 04C3             ; STRCAT
0142++ 04C3             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 04C3             ; source in SI
0144++ 04C3             ; destination in DI
0145++ 04C3             _strcat:
0146++ 04C3 E2          	push si
0147++ 04C4 E3          	push di
0148++ 04C5 D7          	push a
0149++ 04C6 DA          	push d
0150++ 04C7 50          	mov a, di
0151++ 04C8 3C          	mov d, a
0152++ 04C9             _strcat_goto_end_L1:
0153++ 04C9 BD 00       	cmp byte[d], 0
0154++ 04CB C6 D2 04    	je _strcat_start
0155++ 04CE 79          	inc d
0156++ 04CF 0A C9 04    	jmp _strcat_goto_end_L1
0157++ 04D2             _strcat_start:
0158++ 04D2 FD 50       	mov di, d
0159++ 04D4             _strcat_L1:
0160++ 04D4 F6          	lodsb
0161++ 04D5 F7          	stosb
0162++ 04D6 B9 00       	cmp al, 0
0163++ 04D8 C7 D4 04    	jne _strcat_L1
0164++ 04DB             _strcat_end:
0165++ 04DB E7          	pop d
0166++ 04DC E4          	pop a
0167++ 04DD F0          	pop di
0168++ 04DE EF          	pop si
0169++ 04DF 09          	ret
0170++ 04E0             
0171++ 04E0             
0005+  04E0             
0006+  04E0             ;-----------------------------------------------------------------------------
0007+  04E0             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0008+  04E0             ; ASCII in BL
0009+  04E0             ; result in AL
0010+  04E0             ; ascii for F = 0100 0110
0011+  04E0             ; ascii for 9 = 0011 1001
0012+  04E0             ;-----------------------------------------------------------------------------
0013+  04E0             hex_ascii_encode:
0014+  04E0 1B            mov al, bl
0015+  04E1 93 40         test al, $40        ; test if letter or number
0016+  04E3 C7 E9 04      jnz hex_letter
0017+  04E6 87 0F         and al, $0F        ; get number
0018+  04E8 09            ret
0019+  04E9             hex_letter:
0020+  04E9 87 0F         and al, $0F        ; get letter
0021+  04EB 6A 09         add al, 9
0022+  04ED 09            ret
0023+  04EE             
0024+  04EE             ;-----------------------------------------------------------------------------
0025+  04EE             ; ATOI
0026+  04EE             ; 2 letter hex string in B
0027+  04EE             ; 8bit integer returned in AL
0028+  04EE             ;-----------------------------------------------------------------------------
0029+  04EE             _atoi:
0030+  04EE D8            push b
0031+  04EF 07 E0 04      call hex_ascii_encode      ; convert BL to 4bit code in AL
0032+  04F2 30            mov bl, bh
0033+  04F3 DB            push al          ; save a
0034+  04F4 07 E0 04      call hex_ascii_encode
0035+  04F7 EA            pop bl  
0036+  04F8 FD 9E 04      shl al, 4
0037+  04FB 8C            or al, bl
0038+  04FC E5            pop b
0039+  04FD 09            ret  
0040+  04FE             
0041+  04FE             
0042+  04FE             ;-----------------------------------------------------------------------------
0043+  04FE             ; ITOA
0044+  04FE             ; 8bit value in BL
0045+  04FE             ; 2 byte ASCII result in A
0046+  04FE             ;-----------------------------------------------------------------------------
0047+  04FE             _itoa:
0048+  04FE DA            push d
0049+  04FF D8            push b
0050+  0500 A7 00         mov bh, 0
0051+  0502 FD A4 04      shr bl, 4  
0052+  0505 74            mov d, b
0053+  0506 1F E4 07      mov al, [d + s_hex_digits]
0054+  0509 23            mov ah, al
0055+  050A               
0056+  050A E5            pop b
0057+  050B D8            push b
0058+  050C A7 00         mov bh, 0
0059+  050E FD 87 0F      and bl, $0F
0060+  0511 74            mov d, b
0061+  0512 1F E4 07      mov al, [d + s_hex_digits]
0062+  0515 E5            pop b
0063+  0516 E7            pop d
0064+  0517 09            ret
0065+  0518             
0066+  0518             ;-----------------------------------------------------------------------------
0067+  0518             ; HEX STRING TO BINARY
0068+  0518             ; di = destination address
0069+  0518             ; si = source
0070+  0518             ;-----------------------------------------------------------------------------
0071+  0518             _hex_to_int:
0072+  0518             _hex_to_int_L1:
0073+  0518 F6            lodsb          ; load from [SI] to AL
0074+  0519 B9 00         cmp al, 0        ; check if ASCII 0
0075+  051B C6 28 05      jz _hex_to_int_ret
0076+  051E 36            mov bh, al
0077+  051F F6            lodsb
0078+  0520 2F            mov bl, al
0079+  0521 07 EE 04      call _atoi        ; convert ASCII byte in B to int (to AL)
0080+  0524 F7            stosb          ; store AL to [DI]
0081+  0525 0A 18 05      jmp _hex_to_int_L1
0082+  0528             _hex_to_int_ret:
0083+  0528 09            ret    
0084+  0529             
0085+  0529             ;-----------------------------------------------------------------------------
0086+  0529             ; GETCHAR
0087+  0529             ; char in ah
0088+  0529             ;-----------------------------------------------------------------------------
0089+  0529             getch:
0090+  0529 DB            push al
0091+  052A             getch_retry:
0092+  052A 19 01         mov al, 1
0093+  052C 05 03         syscall sys_io      ; receive in AH
0094+  052E E8            pop al
0095+  052F 09            ret
0096+  0530             
0097+  0530             ;-----------------------------------------------------------------------------
0098+  0530             ; PUTCHAR
0099+  0530             ; char in ah
0100+  0530             ;-----------------------------------------------------------------------------
0101+  0530             _putchar:
0102+  0530 D7            push a
0103+  0531 19 00         mov al, 0
0104+  0533 05 03         syscall sys_io      ; char in AH
0105+  0535 E4            pop a
0106+  0536 09            ret
0107+  0537             
0108+  0537             ;-----------------------------------------------------------------------------
0109+  0537             ;; INPUT A STRING
0110+  0537             ;; terminates with null
0111+  0537             ;; pointer in D
0112+  0537             ;-----------------------------------------------------------------------------
0113+  0537             _gets:
0114+  0537 D7            push a
0115+  0538 DA            push d
0116+  0539             _gets_loop:
0117+  0539 19 01         mov al, 1
0118+  053B 05 03         syscall sys_io      ; receive in AH
0119+  053D B9 00         cmp al, 0        ; check error code (AL)
0120+  053F C6 39 05      je _gets_loop      ; if no char received, retry
0121+  0542             
0122+  0542 76 1B         cmp ah, 27
0123+  0544 C6 65 05      je _gets_ansi_esc
0124+  0547 76 0A         cmp ah, $0A        ; LF
0125+  0549 C6 D0 05      je _gets_end
0126+  054C 76 0D         cmp ah, $0D        ; CR
0127+  054E C6 D0 05      je _gets_end
0128+  0551 76 5C         cmp ah, $5C        ; '\\'
0129+  0553 C6 91 05      je _gets_escape
0130+  0556               
0131+  0556 76 08         cmp ah, $08      ; check for backspace
0132+  0558 C6 61 05      je _gets_backspace
0133+  055B             
0134+  055B 1A            mov al, ah
0135+  055C 3E            mov [d], al
0136+  055D 79            inc d
0137+  055E 0A 39 05      jmp _gets_loop
0138+  0561             _gets_backspace:
0139+  0561 7F            dec d
0140+  0562 0A 39 05      jmp _gets_loop
0141+  0565             _gets_ansi_esc:
0142+  0565 19 01         mov al, 1
0143+  0567 05 03         syscall sys_io        ; receive in AH without echo
0144+  0569 B9 00         cmp al, 0          ; check error code (AL)
0145+  056B C6 65 05      je _gets_ansi_esc    ; if no char received, retry
0146+  056E 76 5B         cmp ah, '['
0147+  0570 C7 39 05      jne _gets_loop
0148+  0573             _gets_ansi_esc_2:
0149+  0573 19 01         mov al, 1
0150+  0575 05 03         syscall sys_io          ; receive in AH without echo
0151+  0577 B9 00         cmp al, 0            ; check error code (AL)
0152+  0579 C6 73 05      je _gets_ansi_esc_2  ; if no char received, retry
0153+  057C 76 44         cmp ah, 'D'
0154+  057E C6 89 05      je _gets_left_arrow
0155+  0581 76 43         cmp ah, 'C'
0156+  0583 C6 8D 05      je _gets_right_arrow
0157+  0586 0A 39 05      jmp _gets_loop
0158+  0589             _gets_left_arrow:
0159+  0589 7F            dec d
0160+  058A 0A 39 05      jmp _gets_loop
0161+  058D             _gets_right_arrow:
0162+  058D 79            inc d
0163+  058E 0A 39 05      jmp _gets_loop
0164+  0591             _gets_escape:
0165+  0591 19 01         mov al, 1
0166+  0593 05 03         syscall sys_io      ; receive in AH
0167+  0595 B9 00         cmp al, 0        ; check error code (AL)
0168+  0597 C6 91 05      je _gets_escape      ; if no char received, retry
0169+  059A 76 6E         cmp ah, 'n'
0170+  059C C6 BB 05      je _gets_LF
0171+  059F 76 72         cmp ah, 'r'
0172+  05A1 C6 C2 05      je _gets_CR
0173+  05A4 76 30         cmp ah, '0'
0174+  05A6 C6 C9 05      je _gets_NULL
0175+  05A9 76 5C         cmp ah, $5C  ; '\'
0176+  05AB C6 B4 05      je _gets_slash
0177+  05AE 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0178+  05AF 3E            mov [d], al
0179+  05B0 79            inc d
0180+  05B1 0A 39 05      jmp _gets_loop
0181+  05B4             _gets_slash:
0182+  05B4 19 5C         mov al, $5C
0183+  05B6 3E            mov [d], al
0184+  05B7 79            inc d
0185+  05B8 0A 39 05      jmp _gets_loop
0186+  05BB             _gets_LF:
0187+  05BB 19 0A         mov al, $0A
0188+  05BD 3E            mov [d], al
0189+  05BE 79            inc d
0190+  05BF 0A 39 05      jmp _gets_loop
0191+  05C2             _gets_CR:
0192+  05C2 19 0D         mov al, $0D
0193+  05C4 3E            mov [d], al
0194+  05C5 79            inc d
0195+  05C6 0A 39 05      jmp _gets_loop
0196+  05C9             _gets_NULL:
0197+  05C9 19 00         mov al, $00
0198+  05CB 3E            mov [d], al
0199+  05CC 79            inc d
0200+  05CD 0A 39 05      jmp _gets_loop
0201+  05D0             _gets_end:
0202+  05D0 19 00         mov al, 0
0203+  05D2 3E            mov [d], al        ; terminate string
0204+  05D3 E7            pop d
0205+  05D4 E4            pop a
0206+  05D5 09            ret
0207+  05D6             
0208+  05D6             ;-----------------------------------------------------------------------------
0209+  05D6             ;; INPUT TEXT
0210+  05D6             ;; terminated with CTRL+D
0211+  05D6             ;; pointer in D
0212+  05D6             ;-----------------------------------------------------------------------------
0213+  05D6             _gettxt:
0214+  05D6 D7            push a
0215+  05D7 DA            push d
0216+  05D8             _gettxt_loop:
0217+  05D8 19 01         mov al, 1
0218+  05DA 05 03         syscall sys_io      ; receive in AH
0219+  05DC B9 00         cmp al, 0        ; check error code (AL)
0220+  05DE C6 D8 05      je _gettxt_loop    ; if no char received, retry
0221+  05E1 76 04         cmp ah, 4      ; EOT
0222+  05E3 C6 21 06      je _gettxt_end
0223+  05E6 76 08         cmp ah, $08      ; check for backspace
0224+  05E8 C6 1D 06      je _gettxt_backspace
0225+  05EB 76 5C         cmp ah, $5C        ; '\'
0226+  05ED C6 F6 05      je _gettxt_escape
0227+  05F0 1A            mov al, ah
0228+  05F1 3E            mov [d], al
0229+  05F2 79            inc d
0230+  05F3 0A D8 05      jmp _gettxt_loop
0231+  05F6             _gettxt_escape:
0232+  05F6 19 01         mov al, 1
0233+  05F8 05 03         syscall sys_io      ; receive in AH
0234+  05FA B9 00         cmp al, 0        ; check error code (AL)
0235+  05FC C6 F6 05      je _gettxt_escape    ; if no char received, retry
0236+  05FF 76 6E         cmp ah, 'n'
0237+  0601 C6 0F 06      je _gettxt_LF
0238+  0604 76 72         cmp ah, 'r'
0239+  0606 C6 16 06      je _gettxt_CR
0240+  0609 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0241+  060A 3E            mov [d], al
0242+  060B 79            inc d
0243+  060C 0A D8 05      jmp _gettxt_loop
0244+  060F             _gettxt_LF:
0245+  060F 19 0A         mov al, $0A
0246+  0611 3E            mov [d], al
0247+  0612 79            inc d
0248+  0613 0A D8 05      jmp _gettxt_loop
0249+  0616             _gettxt_CR:
0250+  0616 19 0D         mov al, $0D
0251+  0618 3E            mov [d], al
0252+  0619 79            inc d
0253+  061A 0A D8 05      jmp _gettxt_loop
0254+  061D             _gettxt_backspace:
0255+  061D 7F            dec d
0256+  061E 0A D8 05      jmp _gettxt_loop
0257+  0621             _gettxt_end:
0258+  0621 19 00         mov al, 0
0259+  0623 3E            mov [d], al        ; terminate string
0260+  0624 E7            pop d
0261+  0625 E4            pop a
0262+  0626 09            ret
0263+  0627             
0264+  0627             ;-----------------------------------------------------------------------------
0265+  0627             ; PRINT NEW LINE
0266+  0627             ;-----------------------------------------------------------------------------
0267+  0627             printnl:
0268+  0627 D7            push a
0269+  0628 10 00 0A      mov a, $0A00
0270+  062B 05 03         syscall sys_io
0271+  062D 10 00 0D      mov a, $0D00
0272+  0630 05 03         syscall sys_io
0273+  0632 E4            pop a
0274+  0633 09            ret
0275+  0634             
0276+  0634             ;-----------------------------------------------------------------------------
0277+  0634             ; _strtoint
0278+  0634             ; 4 digit hex string number in d
0279+  0634             ; integer returned in A
0280+  0634             ;-----------------------------------------------------------------------------
0281+  0634             _strtointx:
0282+  0634 D8            push b
0283+  0635 32            mov bl, [d]
0284+  0636 37            mov bh, bl
0285+  0637 33 01 00      mov bl, [d + 1]
0286+  063A 07 EE 04      call _atoi        ; convert to int in AL
0287+  063D 23            mov ah, al        ; move to AH
0288+  063E 33 02 00      mov bl, [d + 2]
0289+  0641 37            mov bh, bl
0290+  0642 33 03 00      mov bl, [d + 3]
0291+  0645 07 EE 04      call _atoi        ; convert to int in AL
0292+  0648 E5            pop b
0293+  0649 09            ret
0294+  064A             
0295+  064A             ;-----------------------------------------------------------------------------
0296+  064A             ; _strtoint
0297+  064A             ; 5 digit base10 string number in d
0298+  064A             ; integer returned in A
0299+  064A             ;-----------------------------------------------------------------------------
0300+  064A             _strtoint:
0301+  064A E2            push si
0302+  064B D8            push b
0303+  064C D9            push c
0304+  064D DA            push d
0305+  064E 07 90 04      call _strlen      ; get string length in C
0306+  0651 7E            dec c
0307+  0652 FD 4E         mov si, d
0308+  0654 12            mov a, c
0309+  0655 FD 99         shl a
0310+  0657 3B FC 07      mov d, table_power
0311+  065A 59            add d, a
0312+  065B 38 00 00      mov c, 0
0313+  065E             _strtoint_L0:
0314+  065E F6            lodsb      ; load ASCII to al
0315+  065F B9 00         cmp al, 0
0316+  0661 C6 74 06      je _strtoint_end
0317+  0664 6F 30         sub al, $30    ; make into integer
0318+  0666 22 00         mov ah, 0
0319+  0668 2A            mov b, [d]
0320+  0669 AC            mul a, b      ; result in B since it fits in 16bits
0321+  066A 11            mov a, b
0322+  066B 28            mov b, c
0323+  066C 54            add a, b
0324+  066D 39            mov c, a
0325+  066E 63 02 00      sub d, 2
0326+  0671 0A 5E 06      jmp _strtoint_L0
0327+  0674             _strtoint_end:
0328+  0674 12            mov a, c
0329+  0675 E7            pop d
0330+  0676 E6            pop c
0331+  0677 E5            pop b
0332+  0678 EF            pop si
0333+  0679 09            ret
0334+  067A             
0335+  067A             ;-----------------------------------------------------------------------------
0336+  067A             ; PRINT NULL TERMINATED STRING
0337+  067A             ; pointer in D
0338+  067A             ;-----------------------------------------------------------------------------
0339+  067A             _puts:
0340+  067A D7            push a
0341+  067B DA            push d
0342+  067C             _puts_L1:
0343+  067C 1E            mov al, [d]
0344+  067D B9 00         cmp al, 0
0345+  067F C6 8B 06      jz _puts_END
0346+  0682 23            mov ah, al
0347+  0683 19 00         mov al, 0
0348+  0685 05 03         syscall sys_io
0349+  0687 79            inc d
0350+  0688 0A 7C 06      jmp _puts_L1
0351+  068B             _puts_END:
0352+  068B E7            pop d
0353+  068C E4            pop a
0354+  068D 09            ret
0355+  068E             
0356+  068E             ;-----------------------------------------------------------------------------
0357+  068E             ; PRINT N SIZE STRING
0358+  068E             ; pointer in D
0359+  068E             ; size in C
0360+  068E             ;-----------------------------------------------------------------------------
0361+  068E             _putsn:
0362+  068E DB            push al
0363+  068F DA            push d
0364+  0690 D9            push c
0365+  0691             _putsn_L0:
0366+  0691 1E            mov al, [d]
0367+  0692 23            mov ah, al
0368+  0693 19 00         mov al, 0
0369+  0695 05 03         syscall sys_io
0370+  0697 79            inc d
0371+  0698 7E            dec c  
0372+  0699 C2 00 00      cmp c, 0
0373+  069C C7 91 06      jne _putsn_L0
0374+  069F             _putsn_end:
0375+  069F E6            pop c
0376+  06A0 E7            pop d
0377+  06A1 E8            pop al
0378+  06A2 09            ret
0379+  06A3             
0380+  06A3             ;-----------------------------------------------------------------------------
0381+  06A3             ; print 16bit decimal number
0382+  06A3             ; input number in A
0383+  06A3             ;-----------------------------------------------------------------------------
0384+  06A3             print_u16d:
0385+  06A3 D7            push a
0386+  06A4 D8            push b
0387+  06A5 26 10 27      mov b, 10000
0388+  06A8 AE            div a, b      ; get 10000's coeff.
0389+  06A9 07 CB 06      call print_number
0390+  06AC 11            mov a, b
0391+  06AD 26 E8 03      mov b, 1000
0392+  06B0 AE            div a, b      ; get 1000's coeff.
0393+  06B1 07 CB 06      call print_number
0394+  06B4 11            mov a, b
0395+  06B5 26 64 00      mov b, 100
0396+  06B8 AE            div a, b
0397+  06B9 07 CB 06      call print_number
0398+  06BC 11            mov a, b
0399+  06BD 26 0A 00      mov b, 10
0400+  06C0 AE            div a, b
0401+  06C1 07 CB 06      call print_number
0402+  06C4 1B            mov al, bl      ; 1's coeff in bl
0403+  06C5 07 CB 06      call print_number
0404+  06C8 E5            pop b
0405+  06C9 E4            pop a
0406+  06CA 09            ret
0407+  06CB             
0408+  06CB             ;-----------------------------------------------------------------------------
0409+  06CB             ; print AL
0410+  06CB             ;-----------------------------------------------------------------------------
0411+  06CB             print_number:
0412+  06CB 6A 30         add al, $30
0413+  06CD 23            mov ah, al
0414+  06CE 07 30 05      call _putchar
0415+  06D1 09            ret
0416+  06D2             
0417+  06D2             ;-----------------------------------------------------------------------------
0418+  06D2             ; PRINT 16BIT HEX INTEGER
0419+  06D2             ; integer value in reg B
0420+  06D2             ;-----------------------------------------------------------------------------
0421+  06D2             print_u16x:
0422+  06D2 D7            push a
0423+  06D3 D8            push b
0424+  06D4 DD            push bl
0425+  06D5 30            mov bl, bh
0426+  06D6 07 FE 04      call _itoa        ; convert bh to char in A
0427+  06D9 2F            mov bl, al        ; save al
0428+  06DA 19 00         mov al, 0
0429+  06DC 05 03         syscall sys_io        ; display AH
0430+  06DE 24            mov ah, bl        ; retrieve al
0431+  06DF 19 00         mov al, 0
0432+  06E1 05 03         syscall sys_io        ; display AL
0433+  06E3             
0434+  06E3 EA            pop bl
0435+  06E4 07 FE 04      call _itoa        ; convert bh to char in A
0436+  06E7 2F            mov bl, al        ; save al
0437+  06E8 19 00         mov al, 0
0438+  06EA 05 03         syscall sys_io        ; display AH
0439+  06EC 24            mov ah, bl        ; retrieve al
0440+  06ED 19 00         mov al, 0
0441+  06EF 05 03         syscall sys_io        ; display AL
0442+  06F1             
0443+  06F1 E5            pop b
0444+  06F2 E4            pop a
0445+  06F3 09            ret
0446+  06F4             
0447+  06F4             ;-----------------------------------------------------------------------------
0448+  06F4             ; input 32bit hex integer
0449+  06F4             ; read 32bit integer into GA
0450+  06F4             ; UNFINISHED !!
0451+  06F4             ;-----------------------------------------------------------------------------
0452+  06F4             scan_u32x:
0453+  06F4 F8 09 00      enter 9
0454+  06F7 D8            push b
0455+  06F8 DA            push d
0456+  06F9             
0457+  06F9 FA F8 FF      lea d, [bp + -8]
0458+  06FC 07 37 05      call _gets        ; get number
0459+  06FF             
0460+  06FF 32            mov bl, [d]
0461+  0700 37            mov bh, bl
0462+  0701 33 01 00      mov bl, [d + 1]
0463+  0704 07 EE 04      call _atoi        ; convert to int in AL
0464+  0707 23            mov ah, al        ; move to AH
0465+  0708             
0466+  0708 33 02 00      mov bl, [d + 2]
0467+  070B 37            mov bh, bl
0468+  070C 33 03 00      mov bl, [d + 3]
0469+  070F 07 EE 04      call _atoi        ; convert to int in AL
0470+  0712             
0471+  0712 33 04 00      mov bl, [d + 4]
0472+  0715 37            mov bh, bl
0473+  0716 33 05 00      mov bl, [d + 5]
0474+  0719 07 EE 04      call _atoi        ; convert to int in AL
0475+  071C             
0476+  071C 33 06 00      mov bl, [d + 6]
0477+  071F 37            mov bh, bl
0478+  0720 33 07 00      mov bl, [d + 7]
0479+  0723 07 EE 04      call _atoi        ; convert to int in AL
0480+  0726             
0481+  0726 E7            pop d
0482+  0727 E5            pop b
0483+  0728 F9            leave
0484+  0729 09            ret
0485+  072A             
0486+  072A             ;-----------------------------------------------------------------------------
0487+  072A             ; input 16bit hex integer
0488+  072A             ; read 16bit integer into A
0489+  072A             ;-----------------------------------------------------------------------------
0490+  072A             scan_u16x:
0491+  072A F8 0F 00      enter 15
0492+  072D D8            push b
0493+  072E DA            push d
0494+  072F             
0495+  072F FA FC FF      lea d, [bp + -4]
0496+  0732 07 37 05      call _gets        ; get number
0497+  0735             
0498+  0735 32            mov bl, [d]
0499+  0736 37            mov bh, bl
0500+  0737 33 01 00      mov bl, [d + 1]
0501+  073A 07 EE 04      call _atoi        ; convert to int in AL
0502+  073D 23            mov ah, al        ; move to AH
0503+  073E             
0504+  073E 33 02 00      mov bl, [d + 2]
0505+  0741 37            mov bh, bl
0506+  0742 33 03 00      mov bl, [d + 3]
0507+  0745 07 EE 04      call _atoi        ; convert to int in AL
0508+  0748             
0509+  0748 E7            pop d
0510+  0749 E5            pop b
0511+  074A F9            leave
0512+  074B 09            ret
0513+  074C             
0514+  074C             ;-----------------------------------------------------------------------------
0515+  074C             ; PRINT 8bit HEX INTEGER
0516+  074C             ; integer value in reg bl
0517+  074C             ;-----------------------------------------------------------------------------
0518+  074C             print_u8x:
0519+  074C D7            push a
0520+  074D DD            push bl
0521+  074E             
0522+  074E 07 FE 04      call _itoa        ; convert bl to char in A
0523+  0751 2F            mov bl, al        ; save al
0524+  0752 19 00         mov al, 0
0525+  0754 05 03         syscall sys_io        ; display AH
0526+  0756 24            mov ah, bl        ; retrieve al
0527+  0757 19 00         mov al, 0
0528+  0759 05 03         syscall sys_io        ; display AL
0529+  075B             
0530+  075B EA            pop bl
0531+  075C E4            pop a
0532+  075D 09            ret
0533+  075E             
0534+  075E             ;-----------------------------------------------------------------------------
0535+  075E             ; print 8bit decimal unsigned number
0536+  075E             ; input number in AL
0537+  075E             ;-----------------------------------------------------------------------------
0538+  075E             print_u8d:
0539+  075E D7            push a
0540+  075F D8            push b
0541+  0760             
0542+  0760 22 00         mov ah, 0
0543+  0762 26 64 00      mov b, 100
0544+  0765 AE            div a, b
0545+  0766 D8            push b      ; save remainder
0546+  0767 B9 00         cmp al, 0
0547+  0769 C6 73 07      je skip100
0548+  076C 6A 30         add al, $30
0549+  076E 23            mov ah, al
0550+  076F 19 00         mov al, 0
0551+  0771 05 03         syscall sys_io  ; print coeff
0552+  0773             skip100:
0553+  0773 E4            pop a
0554+  0774 22 00         mov ah, 0
0555+  0776 26 0A 00      mov b, 10
0556+  0779 AE            div a, b
0557+  077A D8            push b      ; save remainder
0558+  077B B9 00         cmp al, 0
0559+  077D C6 87 07      je skip10
0560+  0780 6A 30         add al, $30
0561+  0782 23            mov ah, al
0562+  0783 19 00         mov al, 0
0563+  0785 05 03         syscall sys_io  ; print coeff
0564+  0787             skip10:
0565+  0787 E4            pop a
0566+  0788 1B            mov al, bl
0567+  0789 6A 30         add al, $30
0568+  078B 23            mov ah, al
0569+  078C 19 00         mov al, 0
0570+  078E 05 03         syscall sys_io  ; print coeff
0571+  0790 E5            pop b
0572+  0791 E4            pop a
0573+  0792 09            ret
0574+  0793             
0575+  0793             ;-----------------------------------------------------------------------------
0576+  0793             ; INPUT 8BIT HEX INTEGER
0577+  0793             ; read 8bit integer into AL
0578+  0793             ;-----------------------------------------------------------------------------
0579+  0793             scan_u8x:
0580+  0793 F8 04 00      enter 4
0581+  0796 D8            push b
0582+  0797 DA            push d
0583+  0798             
0584+  0798 FA FD FF      lea d, [bp + -3]
0585+  079B 07 37 05      call _gets        ; get number
0586+  079E             
0587+  079E 32            mov bl, [d]
0588+  079F 37            mov bh, bl
0589+  07A0 33 01 00      mov bl, [d + 1]
0590+  07A3 07 EE 04      call _atoi        ; convert to int in AL
0591+  07A6             
0592+  07A6 E7            pop d
0593+  07A7 E5            pop b
0594+  07A8 F9            leave
0595+  07A9 09            ret
0596+  07AA             
0597+  07AA             ;-----------------------------------------------------------------------------
0598+  07AA             ; input decimal number
0599+  07AA             ; result in A
0600+  07AA             ; 655'\0'
0601+  07AA             ; low--------high
0602+  07AA             ;-----------------------------------------------------------------------------
0603+  07AA             scan_u16d:
0604+  07AA F8 08 00      enter 8
0605+  07AD E2            push si
0606+  07AE D8            push b
0607+  07AF D9            push c
0608+  07B0 DA            push d
0609+  07B1 FA F9 FF      lea d, [bp +- 7]
0610+  07B4 07 37 05      call _gets
0611+  07B7 07 90 04      call _strlen      ; get string length in C
0612+  07BA 7E            dec c
0613+  07BB FD 4E         mov si, d
0614+  07BD 12            mov a, c
0615+  07BE FD 99         shl a
0616+  07C0 3B FC 07      mov d, table_power
0617+  07C3 59            add d, a
0618+  07C4 38 00 00      mov c, 0
0619+  07C7             mul_loop:
0620+  07C7 F6            lodsb      ; load ASCII to al
0621+  07C8 B9 00         cmp al, 0
0622+  07CA C6 DD 07      je mul_exit
0623+  07CD 6F 30         sub al, $30    ; make into integer
0624+  07CF 22 00         mov ah, 0
0625+  07D1 2A            mov b, [d]
0626+  07D2 AC            mul a, b      ; result in B since it fits in 16bits
0627+  07D3 11            mov a, b
0628+  07D4 28            mov b, c
0629+  07D5 54            add a, b
0630+  07D6 39            mov c, a
0631+  07D7 63 02 00      sub d, 2
0632+  07DA 0A C7 07      jmp mul_loop
0633+  07DD             mul_exit:
0634+  07DD 12            mov a, c
0635+  07DE E7            pop d
0636+  07DF E6            pop c
0637+  07E0 E5            pop b
0638+  07E1 EF            pop si
0639+  07E2 F9            leave
0640+  07E3 09            ret
0641+  07E4             
0642+  07E4 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0642+  07E8 34 35 36 37 
0642+  07EC 38 39 41 42 
0642+  07F0 43 44 45 46 
0643+  07F4 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0643+  07F8 1B 5B 48 00 
0644+  07FC             
0645+  07FC             table_power:
0646+  07FC 01 00         .dw 1
0647+  07FE 0A 00         .dw 10
0648+  0800 64 00         .dw 100
0649+  0802 E8 03         .dw 1000
0650+  0804 10 27         .dw 100000051   0806             ; --- END INLINE ASM SEGMENT
0052   0806 05 0B         syscall sys_terminate_proc
0053   0808             
0054   0808             hide_cursor:
0055   0808 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0056   080B             ; if(hide){ 
0057   080B             _if1_cond:
0058   080B FA 05 00      lea d, [bp + 5] ; $hide
0059   080E 32            mov bl, [d]
0060   080F A7 00         mov bh, 0
0061   0811 38 00 00      mov c, 0
0062   0814 C0 00 00      cmp b, 0
0063   0817 C6 29 08      je _if1_else
0064   081A             _if1_TRUE:
0065   081A             ; printf("\033[?25l"); 
0066   081A             ; --- START FUNCTION CALL
0067   081A 26 59 11      mov b, _s0 ; "\033[?25l"
0068   081D FD AB         swp b
0069   081F D8            push b
0070   0820 07 37 08      call printf
0071   0823 51 02 00      add sp, 2
0072   0826             ; --- END FUNCTION CALL
0073   0826 0A 35 08      jmp _if1_exit
0074   0829             _if1_else:
0075   0829             ; printf("\033[?25h"); 
0076   0829             ; --- START FUNCTION CALL
0077   0829 26 60 11      mov b, _s1 ; "\033[?25h"
0078   082C FD AB         swp b
0079   082E D8            push b
0080   082F 07 37 08      call printf
0081   0832 51 02 00      add sp, 2
0082   0835             ; --- END FUNCTION CALL
0083   0835             _if1_exit:
0084   0835 F9            leave
0085   0836 09            ret
0086   0837             
0087   0837             printf:
0088   0837 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0089   083A             ; char *p, *format_p; 
0090   083A 52 02 00      sub sp, 2
0091   083D 52 02 00      sub sp, 2
0092   0840             ; format_p = format; 
0093   0840 FA FD FF      lea d, [bp + -3] ; $format_p
0094   0843 DA            push d
0095   0844 FA 05 00      lea d, [bp + 5] ; $format
0096   0847 2A            mov b, [d]
0097   0848 38 00 00      mov c, 0
0098   084B E7            pop d
0099   084C FD 43         mov [d], b
0100   084E             ; p = &format + 2; 
0101   084E FA FF FF      lea d, [bp + -1] ; $p
0102   0851 DA            push d
0103   0852 FA 05 00      lea d, [bp + 5] ; $format
0104   0855 2D            mov b, d
0105   0856             ; --- START TERMS
0106   0856 D7            push a
0107   0857 11            mov a, b
0108   0858 FD 2E 02 00   mov32 cb, $00000002
0108   085C 00 00 
0109   085E 56            add b, a
0110   085F E4            pop a
0111   0860             ; --- END TERMS
0112   0860 E7            pop d
0113   0861 FD 43         mov [d], b
0114   0863             ; for(;;){ 
0115   0863             _for2_init:
0116   0863             _for2_cond:
0117   0863             _for2_block:
0118   0863             ; if(!*format_p) break; 
0119   0863             _if3_cond:
0120   0863 FA FD FF      lea d, [bp + -3] ; $format_p
0121   0866 2A            mov b, [d]
0122   0867 38 00 00      mov c, 0
0123   086A 74            mov d, b
0124   086B 32            mov bl, [d]
0125   086C A7 00         mov bh, 0
0126   086E 38 00 00      mov c, 0
0127   0871 C0 00 00      cmp b, 0
0128   0874 FD 71         seq ; !
0129   0876 C0 00 00      cmp b, 0
0130   0879 C6 82 08      je _if3_else
0131   087C             _if3_TRUE:
0132   087C             ; break; 
0133   087C 0A 22 0B      jmp _for2_exit ; for break
0134   087F 0A 0F 0B      jmp _if3_exit
0135   0882             _if3_else:
0136   0882             ; if(*format_p == '%'){ 
0137   0882             _if4_cond:
0138   0882 FA FD FF      lea d, [bp + -3] ; $format_p
0139   0885 2A            mov b, [d]
0140   0886 38 00 00      mov c, 0
0141   0889 74            mov d, b
0142   088A 32            mov bl, [d]
0143   088B A7 00         mov bh, 0
0144   088D 38 00 00      mov c, 0
0145   0890             ; --- START RELATIONAL
0146   0890 D7            push a
0147   0891 11            mov a, b
0148   0892 FD 2E 25 00   mov32 cb, $00000025
0148   0896 00 00 
0149   0898 B0            cmp a, b
0150   0899 FD 71         seq ; ==
0151   089B E4            pop a
0152   089C             ; --- END RELATIONAL
0153   089C C0 00 00      cmp b, 0
0154   089F C6 FA 0A      je _if4_else
0155   08A2             _if4_TRUE:
0156   08A2             ; format_p++; 
0157   08A2 FA FD FF      lea d, [bp + -3] ; $format_p
0158   08A5 2A            mov b, [d]
0159   08A6 38 00 00      mov c, 0
0160   08A9 FD 77         inc b
0161   08AB FA FD FF      lea d, [bp + -3] ; $format_p
0162   08AE FD 43         mov [d], b
0163   08B0 FD 7D         dec b
0164   08B2             ; switch(*format_p){ 
0165   08B2             _switch5_expr:
0166   08B2 FA FD FF      lea d, [bp + -3] ; $format_p
0167   08B5 2A            mov b, [d]
0168   08B6 38 00 00      mov c, 0
0169   08B9 74            mov d, b
0170   08BA 32            mov bl, [d]
0171   08BB A7 00         mov bh, 0
0172   08BD 38 00 00      mov c, 0
0173   08C0             _switch5_comparisons:
0174   08C0 C1 6C         cmp bl, $6c
0175   08C2 C6 EE 08      je _switch5_case0
0176   08C5 C1 4C         cmp bl, $4c
0177   08C7 C6 EE 08      je _switch5_case1
0178   08CA C1 64         cmp bl, $64
0179   08CC C6 FE 09      je _switch5_case2
0180   08CF C1 69         cmp bl, $69
0181   08D1 C6 FE 09      je _switch5_case3
0182   08D4 C1 75         cmp bl, $75
0183   08D6 C6 2E 0A      je _switch5_case4
0184   08D9 C1 78         cmp bl, $78
0185   08DB C6 5E 0A      je _switch5_case5
0186   08DE C1 63         cmp bl, $63
0187   08E0 C6 8E 0A      je _switch5_case6
0188   08E3 C1 73         cmp bl, $73
0189   08E5 C6 BE 0A      je _switch5_case7
0190   08E8 0A EB 0A      jmp _switch5_default
0191   08EB 0A F7 0A      jmp _switch5_exit
0192   08EE             _switch5_case0:
0193   08EE             _switch5_case1:
0194   08EE             ; format_p++; 
0195   08EE FA FD FF      lea d, [bp + -3] ; $format_p
0196   08F1 2A            mov b, [d]
0197   08F2 38 00 00      mov c, 0
0198   08F5 FD 77         inc b
0199   08F7 FA FD FF      lea d, [bp + -3] ; $format_p
0200   08FA FD 43         mov [d], b
0201   08FC FD 7D         dec b
0202   08FE             ; if(*format_p == 'd' || *format_p == 'i') 
0203   08FE             _if6_cond:
0204   08FE FA FD FF      lea d, [bp + -3] ; $format_p
0205   0901 2A            mov b, [d]
0206   0902 38 00 00      mov c, 0
0207   0905 74            mov d, b
0208   0906 32            mov bl, [d]
0209   0907 A7 00         mov bh, 0
0210   0909 38 00 00      mov c, 0
0211   090C             ; --- START RELATIONAL
0212   090C D7            push a
0213   090D 11            mov a, b
0214   090E FD 2E 64 00   mov32 cb, $00000064
0214   0912 00 00 
0215   0914 B0            cmp a, b
0216   0915 FD 71         seq ; ==
0217   0917 E4            pop a
0218   0918             ; --- END RELATIONAL
0219   0918             ; --- START LOGICAL OR
0220   0918 D7            push a
0221   0919 11            mov a, b
0222   091A FA FD FF      lea d, [bp + -3] ; $format_p
0223   091D 2A            mov b, [d]
0224   091E 38 00 00      mov c, 0
0225   0921 74            mov d, b
0226   0922 32            mov bl, [d]
0227   0923 A7 00         mov bh, 0
0228   0925 38 00 00      mov c, 0
0229   0928             ; --- START RELATIONAL
0230   0928 D7            push a
0231   0929 11            mov a, b
0232   092A FD 2E 69 00   mov32 cb, $00000069
0232   092E 00 00 
0233   0930 B0            cmp a, b
0234   0931 FD 71         seq ; ==
0235   0933 E4            pop a
0236   0934             ; --- END RELATIONAL
0237   0934 FD A8         sor a, b ; ||
0238   0936 E4            pop a
0239   0937             ; --- END LOGICAL OR
0240   0937 C0 00 00      cmp b, 0
0241   093A C6 5B 09      je _if6_else
0242   093D             _if6_TRUE:
0243   093D             ; print_signed_long(*(long *)p); 
0244   093D             ; --- START FUNCTION CALL
0245   093D FA FF FF      lea d, [bp + -1] ; $p
0246   0940 2A            mov b, [d]
0247   0941 38 00 00      mov c, 0
0248   0944 74            mov d, b
0249   0945 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0250   0948 FD 39         mov c, b ; And place it into C
0251   094A 2A            mov b, [d] ; Lower Word in B
0252   094B 12            mov a, c
0253   094C FD AA         swp a
0254   094E D7            push a
0255   094F FD AB         swp b
0256   0951 D8            push b
0257   0952 07 24 0B      call print_signed_long
0258   0955 51 04 00      add sp, 4
0259   0958             ; --- END FUNCTION CALL
0260   0958 0A E3 09      jmp _if6_exit
0261   095B             _if6_else:
0262   095B             ; if(*format_p == 'u') 
0263   095B             _if7_cond:
0264   095B FA FD FF      lea d, [bp + -3] ; $format_p
0265   095E 2A            mov b, [d]
0266   095F 38 00 00      mov c, 0
0267   0962 74            mov d, b
0268   0963 32            mov bl, [d]
0269   0964 A7 00         mov bh, 0
0270   0966 38 00 00      mov c, 0
0271   0969             ; --- START RELATIONAL
0272   0969 D7            push a
0273   096A 11            mov a, b
0274   096B FD 2E 75 00   mov32 cb, $00000075
0274   096F 00 00 
0275   0971 B0            cmp a, b
0276   0972 FD 71         seq ; ==
0277   0974 E4            pop a
0278   0975             ; --- END RELATIONAL
0279   0975 C0 00 00      cmp b, 0
0280   0978 C6 99 09      je _if7_else
0281   097B             _if7_TRUE:
0282   097B             ; print_unsigned_long(*(unsigned long *)p); 
0283   097B             ; --- START FUNCTION CALL
0284   097B FA FF FF      lea d, [bp + -1] ; $p
0285   097E 2A            mov b, [d]
0286   097F 38 00 00      mov c, 0
0287   0982 74            mov d, b
0288   0983 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0289   0986 FD 39         mov c, b ; And place it into C
0290   0988 2A            mov b, [d] ; Lower Word in B
0291   0989 12            mov a, c
0292   098A FD AA         swp a
0293   098C D7            push a
0294   098D FD AB         swp b
0295   098F D8            push b
0296   0990 07 B7 0C      call print_unsigned_long
0297   0993 51 04 00      add sp, 4
0298   0996             ; --- END FUNCTION CALL
0299   0996 0A E3 09      jmp _if7_exit
0300   0999             _if7_else:
0301   0999             ; if(*format_p == 'x') 
0302   0999             _if8_cond:
0303   0999 FA FD FF      lea d, [bp + -3] ; $format_p
0304   099C 2A            mov b, [d]
0305   099D 38 00 00      mov c, 0
0306   09A0 74            mov d, b
0307   09A1 32            mov bl, [d]
0308   09A2 A7 00         mov bh, 0
0309   09A4 38 00 00      mov c, 0
0310   09A7             ; --- START RELATIONAL
0311   09A7 D7            push a
0312   09A8 11            mov a, b
0313   09A9 FD 2E 78 00   mov32 cb, $00000078
0313   09AD 00 00 
0314   09AF B0            cmp a, b
0315   09B0 FD 71         seq ; ==
0316   09B2 E4            pop a
0317   09B3             ; --- END RELATIONAL
0318   09B3 C0 00 00      cmp b, 0
0319   09B6 C6 D7 09      je _if8_else
0320   09B9             _if8_TRUE:
0321   09B9             ; printx32(*(long int *)p); 
0322   09B9             ; --- START FUNCTION CALL
0323   09B9 FA FF FF      lea d, [bp + -1] ; $p
0324   09BC 2A            mov b, [d]
0325   09BD 38 00 00      mov c, 0
0326   09C0 74            mov d, b
0327   09C1 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0328   09C4 FD 39         mov c, b ; And place it into C
0329   09C6 2A            mov b, [d] ; Lower Word in B
0330   09C7 12            mov a, c
0331   09C8 FD AA         swp a
0332   09CA D7            push a
0333   09CB FD AB         swp b
0334   09CD D8            push b
0335   09CE 07 EB 0D      call printx32
0336   09D1 51 04 00      add sp, 4
0337   09D4             ; --- END FUNCTION CALL
0338   09D4 0A E3 09      jmp _if8_exit
0339   09D7             _if8_else:
0340   09D7             ; err("Unexpected format in printf."); 
0341   09D7             ; --- START FUNCTION CALL
0342   09D7 26 67 11      mov b, _s2 ; "Unexpected format in printf."
0343   09DA FD AB         swp b
0344   09DC D8            push b
0345   09DD 07 4B 0E      call err
0346   09E0 51 02 00      add sp, 2
0347   09E3             ; --- END FUNCTION CALL
0348   09E3             _if8_exit:
0349   09E3             _if7_exit:
0350   09E3             _if6_exit:
0351   09E3             ; p = p + 4; 
0352   09E3 FA FF FF      lea d, [bp + -1] ; $p
0353   09E6 DA            push d
0354   09E7 FA FF FF      lea d, [bp + -1] ; $p
0355   09EA 2A            mov b, [d]
0356   09EB 38 00 00      mov c, 0
0357   09EE             ; --- START TERMS
0358   09EE D7            push a
0359   09EF 11            mov a, b
0360   09F0 FD 2E 04 00   mov32 cb, $00000004
0360   09F4 00 00 
0361   09F6 56            add b, a
0362   09F7 E4            pop a
0363   09F8             ; --- END TERMS
0364   09F8 E7            pop d
0365   09F9 FD 43         mov [d], b
0366   09FB             ; break; 
0367   09FB 0A F7 0A      jmp _switch5_exit ; case break
0368   09FE             _switch5_case2:
0369   09FE             _switch5_case3:
0370   09FE             ; print_signed(*(int*)p); 
0371   09FE             ; --- START FUNCTION CALL
0372   09FE FA FF FF      lea d, [bp + -1] ; $p
0373   0A01 2A            mov b, [d]
0374   0A02 38 00 00      mov c, 0
0375   0A05 74            mov d, b
0376   0A06 2A            mov b, [d]
0377   0A07 38 00 00      mov c, 0
0378   0A0A FD AB         swp b
0379   0A0C D8            push b
0380   0A0D 07 79 0E      call print_signed
0381   0A10 51 02 00      add sp, 2
0382   0A13             ; --- END FUNCTION CALL
0383   0A13             ; p = p + 2; 
0384   0A13 FA FF FF      lea d, [bp + -1] ; $p
0385   0A16 DA            push d
0386   0A17 FA FF FF      lea d, [bp + -1] ; $p
0387   0A1A 2A            mov b, [d]
0388   0A1B 38 00 00      mov c, 0
0389   0A1E             ; --- START TERMS
0390   0A1E D7            push a
0391   0A1F 11            mov a, b
0392   0A20 FD 2E 02 00   mov32 cb, $00000002
0392   0A24 00 00 
0393   0A26 56            add b, a
0394   0A27 E4            pop a
0395   0A28             ; --- END TERMS
0396   0A28 E7            pop d
0397   0A29 FD 43         mov [d], b
0398   0A2B             ; break; 
0399   0A2B 0A F7 0A      jmp _switch5_exit ; case break
0400   0A2E             _switch5_case4:
0401   0A2E             ; print_unsigned(*(unsigned int*)p); 
0402   0A2E             ; --- START FUNCTION CALL
0403   0A2E FA FF FF      lea d, [bp + -1] ; $p
0404   0A31 2A            mov b, [d]
0405   0A32 38 00 00      mov c, 0
0406   0A35 74            mov d, b
0407   0A36 2A            mov b, [d]
0408   0A37 38 00 00      mov c, 0
0409   0A3A FD AB         swp b
0410   0A3C D8            push b
0411   0A3D 07 CA 0F      call print_unsigned
0412   0A40 51 02 00      add sp, 2
0413   0A43             ; --- END FUNCTION CALL
0414   0A43             ; p = p + 2; 
0415   0A43 FA FF FF      lea d, [bp + -1] ; $p
0416   0A46 DA            push d
0417   0A47 FA FF FF      lea d, [bp + -1] ; $p
0418   0A4A 2A            mov b, [d]
0419   0A4B 38 00 00      mov c, 0
0420   0A4E             ; --- START TERMS
0421   0A4E D7            push a
0422   0A4F 11            mov a, b
0423   0A50 FD 2E 02 00   mov32 cb, $00000002
0423   0A54 00 00 
0424   0A56 56            add b, a
0425   0A57 E4            pop a
0426   0A58             ; --- END TERMS
0427   0A58 E7            pop d
0428   0A59 FD 43         mov [d], b
0429   0A5B             ; break; 
0430   0A5B 0A F7 0A      jmp _switch5_exit ; case break
0431   0A5E             _switch5_case5:
0432   0A5E             ; printx16(*(int*)p); 
0433   0A5E             ; --- START FUNCTION CALL
0434   0A5E FA FF FF      lea d, [bp + -1] ; $p
0435   0A61 2A            mov b, [d]
0436   0A62 38 00 00      mov c, 0
0437   0A65 74            mov d, b
0438   0A66 2A            mov b, [d]
0439   0A67 38 00 00      mov c, 0
0440   0A6A FD AB         swp b
0441   0A6C D8            push b
0442   0A6D 07 E2 10      call printx16
0443   0A70 51 02 00      add sp, 2
0444   0A73             ; --- END FUNCTION CALL
0445   0A73             ; p = p + 2; 
0446   0A73 FA FF FF      lea d, [bp + -1] ; $p
0447   0A76 DA            push d
0448   0A77 FA FF FF      lea d, [bp + -1] ; $p
0449   0A7A 2A            mov b, [d]
0450   0A7B 38 00 00      mov c, 0
0451   0A7E             ; --- START TERMS
0452   0A7E D7            push a
0453   0A7F 11            mov a, b
0454   0A80 FD 2E 02 00   mov32 cb, $00000002
0454   0A84 00 00 
0455   0A86 56            add b, a
0456   0A87 E4            pop a
0457   0A88             ; --- END TERMS
0458   0A88 E7            pop d
0459   0A89 FD 43         mov [d], b
0460   0A8B             ; break; 
0461   0A8B 0A F7 0A      jmp _switch5_exit ; case break
0462   0A8E             _switch5_case6:
0463   0A8E             ; putchar(*(char*)p); 
0464   0A8E             ; --- START FUNCTION CALL
0465   0A8E FA FF FF      lea d, [bp + -1] ; $p
0466   0A91 2A            mov b, [d]
0467   0A92 38 00 00      mov c, 0
0468   0A95 74            mov d, b
0469   0A96 32            mov bl, [d]
0470   0A97 A7 00         mov bh, 0
0471   0A99 38 00 00      mov c, 0
0472   0A9C DD            push bl
0473   0A9D 07 A9 0C      call putchar
0474   0AA0 51 01 00      add sp, 1
0475   0AA3             ; --- END FUNCTION CALL
0476   0AA3             ; p = p + 2; 
0477   0AA3 FA FF FF      lea d, [bp + -1] ; $p
0478   0AA6 DA            push d
0479   0AA7 FA FF FF      lea d, [bp + -1] ; $p
0480   0AAA 2A            mov b, [d]
0481   0AAB 38 00 00      mov c, 0
0482   0AAE             ; --- START TERMS
0483   0AAE D7            push a
0484   0AAF 11            mov a, b
0485   0AB0 FD 2E 02 00   mov32 cb, $00000002
0485   0AB4 00 00 
0486   0AB6 56            add b, a
0487   0AB7 E4            pop a
0488   0AB8             ; --- END TERMS
0489   0AB8 E7            pop d
0490   0AB9 FD 43         mov [d], b
0491   0ABB             ; break; 
0492   0ABB 0A F7 0A      jmp _switch5_exit ; case break
0493   0ABE             _switch5_case7:
0494   0ABE             ; print(*(char**)p); 
0495   0ABE             ; --- START FUNCTION CALL
0496   0ABE FA FF FF      lea d, [bp + -1] ; $p
0497   0AC1 2A            mov b, [d]
0498   0AC2 38 00 00      mov c, 0
0499   0AC5 74            mov d, b
0500   0AC6 2A            mov b, [d]
0501   0AC7 FD AB         swp b
0502   0AC9 D8            push b
0503   0ACA 07 60 0E      call print
0504   0ACD 51 02 00      add sp, 2
0505   0AD0             ; --- END FUNCTION CALL
0506   0AD0             ; p = p + 2; 
0507   0AD0 FA FF FF      lea d, [bp + -1] ; $p
0508   0AD3 DA            push d
0509   0AD4 FA FF FF      lea d, [bp + -1] ; $p
0510   0AD7 2A            mov b, [d]
0511   0AD8 38 00 00      mov c, 0
0512   0ADB             ; --- START TERMS
0513   0ADB D7            push a
0514   0ADC 11            mov a, b
0515   0ADD FD 2E 02 00   mov32 cb, $00000002
0515   0AE1 00 00 
0516   0AE3 56            add b, a
0517   0AE4 E4            pop a
0518   0AE5             ; --- END TERMS
0519   0AE5 E7            pop d
0520   0AE6 FD 43         mov [d], b
0521   0AE8             ; break; 
0522   0AE8 0A F7 0A      jmp _switch5_exit ; case break
0523   0AEB             _switch5_default:
0524   0AEB             ; print("Error: Unknown argument type.\n"); 
0525   0AEB             ; --- START FUNCTION CALL
0526   0AEB 26 84 11      mov b, _s3 ; "Error: Unknown argument type.\n"
0527   0AEE FD AB         swp b
0528   0AF0 D8            push b
0529   0AF1 07 60 0E      call print
0530   0AF4 51 02 00      add sp, 2
0531   0AF7             ; --- END FUNCTION CALL
0532   0AF7             _switch5_exit:
0533   0AF7 0A 0F 0B      jmp _if4_exit
0534   0AFA             _if4_else:
0535   0AFA             ; putchar(*format_p); 
0536   0AFA             ; --- START FUNCTION CALL
0537   0AFA FA FD FF      lea d, [bp + -3] ; $format_p
0538   0AFD 2A            mov b, [d]
0539   0AFE 38 00 00      mov c, 0
0540   0B01 74            mov d, b
0541   0B02 32            mov bl, [d]
0542   0B03 A7 00         mov bh, 0
0543   0B05 38 00 00      mov c, 0
0544   0B08 DD            push bl
0545   0B09 07 A9 0C      call putchar
0546   0B0C 51 01 00      add sp, 1
0547   0B0F             ; --- END FUNCTION CALL
0548   0B0F             _if4_exit:
0549   0B0F             _if3_exit:
0550   0B0F             ; format_p++; 
0551   0B0F FA FD FF      lea d, [bp + -3] ; $format_p
0552   0B12 2A            mov b, [d]
0553   0B13 38 00 00      mov c, 0
0554   0B16 FD 77         inc b
0555   0B18 FA FD FF      lea d, [bp + -3] ; $format_p
0556   0B1B FD 43         mov [d], b
0557   0B1D FD 7D         dec b
0558   0B1F             _for2_update:
0559   0B1F 0A 63 08      jmp _for2_cond
0560   0B22             _for2_exit:
0561   0B22 F9            leave
0562   0B23 09            ret
0563   0B24             
0564   0B24             print_signed_long:
0565   0B24 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0566   0B27             ; char digits[10]; 
0567   0B27 52 0A 00      sub sp, 10
0568   0B2A             ; int i = 0; 
0569   0B2A 52 02 00      sub sp, 2
0570   0B2D             ; --- START LOCAL VAR INITIALIZATION
0571   0B2D FA F5 FF      lea d, [bp + -11] ; $i
0572   0B30 DA            push d
0573   0B31 FD 2E 00 00   mov32 cb, $00000000
0573   0B35 00 00 
0574   0B37 E7            pop d
0575   0B38 FD 43         mov [d], b
0576   0B3A             ; --- END LOCAL VAR INITIALIZATION
0577   0B3A             ; if (num < 0) { 
0578   0B3A             _if9_cond:
0579   0B3A FA 05 00      lea d, [bp + 5] ; $num
0580   0B3D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0581   0B40 FD 39         mov c, b ; And place it into C
0582   0B42 2A            mov b, [d] ; Lower Word in B
0583   0B43             ; --- START RELATIONAL
0584   0B43 D7            push a
0585   0B44 FD D8         push g
0586   0B46 11            mov a, b
0587   0B47 FD 7A         mov g, c
0588   0B49 FD 2E 00 00   mov32 cb, $00000000
0588   0B4D 00 00 
0589   0B4F FD AF         cmp32 ga, cb
0590   0B51 FD 73         slt ; <
0591   0B53 FD F1         pop g
0592   0B55 E4            pop a
0593   0B56             ; --- END RELATIONAL
0594   0B56 C0 00 00      cmp b, 0
0595   0B59 C6 8B 0B      je _if9_else
0596   0B5C             _if9_TRUE:
0597   0B5C             ; putchar('-'); 
0598   0B5C             ; --- START FUNCTION CALL
0599   0B5C FD 2E 2D 00   mov32 cb, $0000002d
0599   0B60 00 00 
0600   0B62 DD            push bl
0601   0B63 07 A9 0C      call putchar
0602   0B66 51 01 00      add sp, 1
0603   0B69             ; --- END FUNCTION CALL
0604   0B69             ; num = -num; 
0605   0B69 FA 05 00      lea d, [bp + 5] ; $num
0606   0B6C DA            push d
0607   0B6D FA 05 00      lea d, [bp + 5] ; $num
0608   0B70 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0609   0B73 FD 39         mov c, b ; And place it into C
0610   0B75 2A            mov b, [d] ; Lower Word in B
0611   0B76 12            mov a, c
0612   0B77 95            not a
0613   0B78 97            not b
0614   0B79 55 01 00      add b, 1
0615   0B7C 5B 00 00      adc a, 0
0616   0B7F 39            mov c, a
0617   0B80 E7            pop d
0618   0B81 FD 43         mov [d], b
0619   0B83 28            mov b, c
0620   0B84 FD 44 02 00   mov [d + 2], b
0621   0B88 0A BF 0B      jmp _if9_exit
0622   0B8B             _if9_else:
0623   0B8B             ; if (num == 0) { 
0624   0B8B             _if10_cond:
0625   0B8B FA 05 00      lea d, [bp + 5] ; $num
0626   0B8E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0627   0B91 FD 39         mov c, b ; And place it into C
0628   0B93 2A            mov b, [d] ; Lower Word in B
0629   0B94             ; --- START RELATIONAL
0630   0B94 D7            push a
0631   0B95 FD D8         push g
0632   0B97 11            mov a, b
0633   0B98 FD 7A         mov g, c
0634   0B9A FD 2E 00 00   mov32 cb, $00000000
0634   0B9E 00 00 
0635   0BA0 FD AF         cmp32 ga, cb
0636   0BA2 FD 71         seq ; ==
0637   0BA4 FD F1         pop g
0638   0BA6 E4            pop a
0639   0BA7             ; --- END RELATIONAL
0640   0BA7 C0 00 00      cmp b, 0
0641   0BAA C6 BF 0B      je _if10_exit
0642   0BAD             _if10_TRUE:
0643   0BAD             ; putchar('0'); 
0644   0BAD             ; --- START FUNCTION CALL
0645   0BAD FD 2E 30 00   mov32 cb, $00000030
0645   0BB1 00 00 
0646   0BB3 DD            push bl
0647   0BB4 07 A9 0C      call putchar
0648   0BB7 51 01 00      add sp, 1
0649   0BBA             ; --- END FUNCTION CALL
0650   0BBA             ; return; 
0651   0BBA F9            leave
0652   0BBB 09            ret
0653   0BBC 0A BF 0B      jmp _if10_exit
0654   0BBF             _if10_exit:
0655   0BBF             _if9_exit:
0656   0BBF             ; while (num > 0) { 
0657   0BBF             _while11_cond:
0658   0BBF FA 05 00      lea d, [bp + 5] ; $num
0659   0BC2 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0660   0BC5 FD 39         mov c, b ; And place it into C
0661   0BC7 2A            mov b, [d] ; Lower Word in B
0662   0BC8             ; --- START RELATIONAL
0663   0BC8 D7            push a
0664   0BC9 FD D8         push g
0665   0BCB 11            mov a, b
0666   0BCC FD 7A         mov g, c
0667   0BCE FD 2E 00 00   mov32 cb, $00000000
0667   0BD2 00 00 
0668   0BD4 FD AF         cmp32 ga, cb
0669   0BD6 FD 7F         sgt
0670   0BD8 FD F1         pop g
0671   0BDA E4            pop a
0672   0BDB             ; --- END RELATIONAL
0673   0BDB C0 00 00      cmp b, 0
0674   0BDE C6 5F 0C      je _while11_exit
0675   0BE1             _while11_block:
0676   0BE1             ; digits[i] = '0' + (num % 10); 
0677   0BE1 FA F7 FF      lea d, [bp + -9] ; $digits
0678   0BE4 D7            push a
0679   0BE5 DA            push d
0680   0BE6 FA F5 FF      lea d, [bp + -11] ; $i
0681   0BE9 2A            mov b, [d]
0682   0BEA 38 00 00      mov c, 0
0683   0BED E7            pop d
0684   0BEE 5A            add d, b
0685   0BEF E4            pop a
0686   0BF0 DA            push d
0687   0BF1 FD 2E 30 00   mov32 cb, $00000030
0687   0BF5 00 00 
0688   0BF7             ; --- START TERMS
0689   0BF7 D7            push a
0690   0BF8 11            mov a, b
0691   0BF9 FA 05 00      lea d, [bp + 5] ; $num
0692   0BFC 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0693   0BFF FD 39         mov c, b ; And place it into C
0694   0C01 2A            mov b, [d] ; Lower Word in B
0695   0C02             ; --- START FACTORS
0696   0C02 D7            push a
0697   0C03 FD D8         push g
0698   0C05 11            mov a, b
0699   0C06 FD 7A         mov g, c
0700   0C08 FD 2E 0A 00   mov32 cb, $0000000a
0700   0C0C 00 00 
0701   0C0E FD D8         push g ; save 'g' as the div instruction uses it
0702   0C10 AE            div a, b ; %, a: quotient, b: remainder
0703   0C11 11            mov a, b
0704   0C12 FD F1         pop g
0705   0C14 FD 38         mov c, g
0706   0C16 27            mov b, a
0707   0C17 FD F1         pop g
0708   0C19 E4            pop a
0709   0C1A             ; --- END FACTORS
0710   0C1A FD 15         add32 cb, ga
0711   0C1C E4            pop a
0712   0C1D             ; --- END TERMS
0713   0C1D E7            pop d
0714   0C1E FD 3E         mov [d], bl
0715   0C20             ; num = num / 10; 
0716   0C20 FA 05 00      lea d, [bp + 5] ; $num
0717   0C23 DA            push d
0718   0C24 FA 05 00      lea d, [bp + 5] ; $num
0719   0C27 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0720   0C2A FD 39         mov c, b ; And place it into C
0721   0C2C 2A            mov b, [d] ; Lower Word in B
0722   0C2D             ; --- START FACTORS
0723   0C2D D7            push a
0724   0C2E FD D8         push g
0725   0C30 11            mov a, b
0726   0C31 FD 7A         mov g, c
0727   0C33 FD 2E 0A 00   mov32 cb, $0000000a
0727   0C37 00 00 
0728   0C39 FD D8         push g ; save 'g' as the div instruction uses it
0729   0C3B AE            div a, b ; /, a: quotient, b: remainder
0730   0C3C FD F1         pop g
0731   0C3E FD 38         mov c, g
0732   0C40 27            mov b, a
0733   0C41 FD F1         pop g
0734   0C43 E4            pop a
0735   0C44             ; --- END FACTORS
0736   0C44 E7            pop d
0737   0C45 FD 43         mov [d], b
0738   0C47 28            mov b, c
0739   0C48 FD 44 02 00   mov [d + 2], b
0740   0C4C             ; i++; 
0741   0C4C FA F5 FF      lea d, [bp + -11] ; $i
0742   0C4F 2A            mov b, [d]
0743   0C50 38 00 00      mov c, 0
0744   0C53 11            mov a, b
0745   0C54 FD 77         inc b
0746   0C56 FA F5 FF      lea d, [bp + -11] ; $i
0747   0C59 FD 43         mov [d], b
0748   0C5B 27            mov b, a
0749   0C5C 0A BF 0B      jmp _while11_cond
0750   0C5F             _while11_exit:
0751   0C5F             ; while (i > 0) { 
0752   0C5F             _while18_cond:
0753   0C5F FA F5 FF      lea d, [bp + -11] ; $i
0754   0C62 2A            mov b, [d]
0755   0C63 38 00 00      mov c, 0
0756   0C66             ; --- START RELATIONAL
0757   0C66 D7            push a
0758   0C67 11            mov a, b
0759   0C68 FD 2E 00 00   mov32 cb, $00000000
0759   0C6C 00 00 
0760   0C6E B0            cmp a, b
0761   0C6F FD 7F         sgt ; >
0762   0C71 E4            pop a
0763   0C72             ; --- END RELATIONAL
0764   0C72 C0 00 00      cmp b, 0
0765   0C75 C6 A7 0C      je _while18_exit
0766   0C78             _while18_block:
0767   0C78             ; i--; 
0768   0C78 FA F5 FF      lea d, [bp + -11] ; $i
0769   0C7B 2A            mov b, [d]
0770   0C7C 38 00 00      mov c, 0
0771   0C7F 11            mov a, b
0772   0C80 FD 7D         dec b
0773   0C82 FA F5 FF      lea d, [bp + -11] ; $i
0774   0C85 FD 43         mov [d], b
0775   0C87 27            mov b, a
0776   0C88             ; putchar(digits[i]); 
0777   0C88             ; --- START FUNCTION CALL
0778   0C88 FA F7 FF      lea d, [bp + -9] ; $digits
0779   0C8B D7            push a
0780   0C8C DA            push d
0781   0C8D FA F5 FF      lea d, [bp + -11] ; $i
0782   0C90 2A            mov b, [d]
0783   0C91 38 00 00      mov c, 0
0784   0C94 E7            pop d
0785   0C95 5A            add d, b
0786   0C96 E4            pop a
0787   0C97 32            mov bl, [d]
0788   0C98 A7 00         mov bh, 0
0789   0C9A 38 00 00      mov c, 0
0790   0C9D DD            push bl
0791   0C9E 07 A9 0C      call putchar
0792   0CA1 51 01 00      add sp, 1
0793   0CA4             ; --- END FUNCTION CALL
0794   0CA4 0A 5F 0C      jmp _while18_cond
0795   0CA7             _while18_exit:
0796   0CA7 F9            leave
0797   0CA8 09            ret
0798   0CA9             
0799   0CA9             putchar:
0800   0CA9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0801   0CAC             ; --- BEGIN INLINE ASM SEGMENT
0802   0CAC FA 05 00      lea d, [bp + 5] ; $c
0803   0CAF 1E            mov al, [d]
0804   0CB0 23            mov ah, al
0805   0CB1 19 00         mov al, 0
0806   0CB3 05 03         syscall sys_io      ; char in AH
0807   0CB5             ; --- END INLINE ASM SEGMENT
0808   0CB5 F9            leave
0809   0CB6 09            ret
0810   0CB7             
0811   0CB7             print_unsigned_long:
0812   0CB7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0813   0CBA             ; char digits[10]; 
0814   0CBA 52 0A 00      sub sp, 10
0815   0CBD             ; int i; 
0816   0CBD 52 02 00      sub sp, 2
0817   0CC0             ; i = 0; 
0818   0CC0 FA F5 FF      lea d, [bp + -11] ; $i
0819   0CC3 DA            push d
0820   0CC4 FD 2E 00 00   mov32 cb, $00000000
0820   0CC8 00 00 
0821   0CCA E7            pop d
0822   0CCB FD 43         mov [d], b
0823   0CCD             ; if(num == 0){ 
0824   0CCD             _if19_cond:
0825   0CCD FA 05 00      lea d, [bp + 5] ; $num
0826   0CD0 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0827   0CD3 FD 39         mov c, b ; And place it into C
0828   0CD5 2A            mov b, [d] ; Lower Word in B
0829   0CD6             ; --- START RELATIONAL
0830   0CD6 D7            push a
0831   0CD7 FD D8         push g
0832   0CD9 11            mov a, b
0833   0CDA FD 7A         mov g, c
0834   0CDC FD 2E 00 00   mov32 cb, $00000000
0834   0CE0 00 00 
0835   0CE2 FD AF         cmp32 ga, cb
0836   0CE4 FD 71         seq ; ==
0837   0CE6 FD F1         pop g
0838   0CE8 E4            pop a
0839   0CE9             ; --- END RELATIONAL
0840   0CE9 C0 00 00      cmp b, 0
0841   0CEC C6 01 0D      je _if19_exit
0842   0CEF             _if19_TRUE:
0843   0CEF             ; putchar('0'); 
0844   0CEF             ; --- START FUNCTION CALL
0845   0CEF FD 2E 30 00   mov32 cb, $00000030
0845   0CF3 00 00 
0846   0CF5 DD            push bl
0847   0CF6 07 A9 0C      call putchar
0848   0CF9 51 01 00      add sp, 1
0849   0CFC             ; --- END FUNCTION CALL
0850   0CFC             ; return; 
0851   0CFC F9            leave
0852   0CFD 09            ret
0853   0CFE 0A 01 0D      jmp _if19_exit
0854   0D01             _if19_exit:
0855   0D01             ; while (num > 0) { 
0856   0D01             _while20_cond:
0857   0D01 FA 05 00      lea d, [bp + 5] ; $num
0858   0D04 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0859   0D07 FD 39         mov c, b ; And place it into C
0860   0D09 2A            mov b, [d] ; Lower Word in B
0861   0D0A             ; --- START RELATIONAL
0862   0D0A D7            push a
0863   0D0B FD D8         push g
0864   0D0D 11            mov a, b
0865   0D0E FD 7A         mov g, c
0866   0D10 FD 2E 00 00   mov32 cb, $00000000
0866   0D14 00 00 
0867   0D16 FD AF         cmp32 ga, cb
0868   0D18 FD 81         sgu
0869   0D1A FD F1         pop g
0870   0D1C E4            pop a
0871   0D1D             ; --- END RELATIONAL
0872   0D1D C0 00 00      cmp b, 0
0873   0D20 C6 A1 0D      je _while20_exit
0874   0D23             _while20_block:
0875   0D23             ; digits[i] = '0' + (num % 10); 
0876   0D23 FA F7 FF      lea d, [bp + -9] ; $digits
0877   0D26 D7            push a
0878   0D27 DA            push d
0879   0D28 FA F5 FF      lea d, [bp + -11] ; $i
0880   0D2B 2A            mov b, [d]
0881   0D2C 38 00 00      mov c, 0
0882   0D2F E7            pop d
0883   0D30 5A            add d, b
0884   0D31 E4            pop a
0885   0D32 DA            push d
0886   0D33 FD 2E 30 00   mov32 cb, $00000030
0886   0D37 00 00 
0887   0D39             ; --- START TERMS
0888   0D39 D7            push a
0889   0D3A 11            mov a, b
0890   0D3B FA 05 00      lea d, [bp + 5] ; $num
0891   0D3E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0892   0D41 FD 39         mov c, b ; And place it into C
0893   0D43 2A            mov b, [d] ; Lower Word in B
0894   0D44             ; --- START FACTORS
0895   0D44 D7            push a
0896   0D45 FD D8         push g
0897   0D47 11            mov a, b
0898   0D48 FD 7A         mov g, c
0899   0D4A FD 2E 0A 00   mov32 cb, $0000000a
0899   0D4E 00 00 
0900   0D50 FD D8         push g ; save 'g' as the div instruction uses it
0901   0D52 AE            div a, b ; %, a: quotient, b: remainder
0902   0D53 11            mov a, b
0903   0D54 FD F1         pop g
0904   0D56 FD 38         mov c, g
0905   0D58 27            mov b, a
0906   0D59 FD F1         pop g
0907   0D5B E4            pop a
0908   0D5C             ; --- END FACTORS
0909   0D5C FD 15         add32 cb, ga
0910   0D5E E4            pop a
0911   0D5F             ; --- END TERMS
0912   0D5F E7            pop d
0913   0D60 FD 3E         mov [d], bl
0914   0D62             ; num = num / 10; 
0915   0D62 FA 05 00      lea d, [bp + 5] ; $num
0916   0D65 DA            push d
0917   0D66 FA 05 00      lea d, [bp + 5] ; $num
0918   0D69 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0919   0D6C FD 39         mov c, b ; And place it into C
0920   0D6E 2A            mov b, [d] ; Lower Word in B
0921   0D6F             ; --- START FACTORS
0922   0D6F D7            push a
0923   0D70 FD D8         push g
0924   0D72 11            mov a, b
0925   0D73 FD 7A         mov g, c
0926   0D75 FD 2E 0A 00   mov32 cb, $0000000a
0926   0D79 00 00 
0927   0D7B FD D8         push g ; save 'g' as the div instruction uses it
0928   0D7D AE            div a, b ; /, a: quotient, b: remainder
0929   0D7E FD F1         pop g
0930   0D80 FD 38         mov c, g
0931   0D82 27            mov b, a
0932   0D83 FD F1         pop g
0933   0D85 E4            pop a
0934   0D86             ; --- END FACTORS
0935   0D86 E7            pop d
0936   0D87 FD 43         mov [d], b
0937   0D89 28            mov b, c
0938   0D8A FD 44 02 00   mov [d + 2], b
0939   0D8E             ; i++; 
0940   0D8E FA F5 FF      lea d, [bp + -11] ; $i
0941   0D91 2A            mov b, [d]
0942   0D92 38 00 00      mov c, 0
0943   0D95 11            mov a, b
0944   0D96 FD 77         inc b
0945   0D98 FA F5 FF      lea d, [bp + -11] ; $i
0946   0D9B FD 43         mov [d], b
0947   0D9D 27            mov b, a
0948   0D9E 0A 01 0D      jmp _while20_cond
0949   0DA1             _while20_exit:
0950   0DA1             ; while (i > 0) { 
0951   0DA1             _while27_cond:
0952   0DA1 FA F5 FF      lea d, [bp + -11] ; $i
0953   0DA4 2A            mov b, [d]
0954   0DA5 38 00 00      mov c, 0
0955   0DA8             ; --- START RELATIONAL
0956   0DA8 D7            push a
0957   0DA9 11            mov a, b
0958   0DAA FD 2E 00 00   mov32 cb, $00000000
0958   0DAE 00 00 
0959   0DB0 B0            cmp a, b
0960   0DB1 FD 7F         sgt ; >
0961   0DB3 E4            pop a
0962   0DB4             ; --- END RELATIONAL
0963   0DB4 C0 00 00      cmp b, 0
0964   0DB7 C6 E9 0D      je _while27_exit
0965   0DBA             _while27_block:
0966   0DBA             ; i--; 
0967   0DBA FA F5 FF      lea d, [bp + -11] ; $i
0968   0DBD 2A            mov b, [d]
0969   0DBE 38 00 00      mov c, 0
0970   0DC1 11            mov a, b
0971   0DC2 FD 7D         dec b
0972   0DC4 FA F5 FF      lea d, [bp + -11] ; $i
0973   0DC7 FD 43         mov [d], b
0974   0DC9 27            mov b, a
0975   0DCA             ; putchar(digits[i]); 
0976   0DCA             ; --- START FUNCTION CALL
0977   0DCA FA F7 FF      lea d, [bp + -9] ; $digits
0978   0DCD D7            push a
0979   0DCE DA            push d
0980   0DCF FA F5 FF      lea d, [bp + -11] ; $i
0981   0DD2 2A            mov b, [d]
0982   0DD3 38 00 00      mov c, 0
0983   0DD6 E7            pop d
0984   0DD7 5A            add d, b
0985   0DD8 E4            pop a
0986   0DD9 32            mov bl, [d]
0987   0DDA A7 00         mov bh, 0
0988   0DDC 38 00 00      mov c, 0
0989   0DDF DD            push bl
0990   0DE0 07 A9 0C      call putchar
0991   0DE3 51 01 00      add sp, 1
0992   0DE6             ; --- END FUNCTION CALL
0993   0DE6 0A A1 0D      jmp _while27_cond
0994   0DE9             _while27_exit:
0995   0DE9 F9            leave
0996   0DEA 09            ret
0997   0DEB             
0998   0DEB             printx32:
0999   0DEB F8 00 00      enter 0 ; (push bp; mov bp, sp)
1000   0DEE             ; --- BEGIN INLINE ASM SEGMENT
1001   0DEE FA 05 00      lea d, [bp + 5] ; $hex
1002   0DF1 2B 02 00      mov b, [d+2]
1003   0DF4 07 FD 0D      call print_u16x_printx32
1004   0DF7 2A            mov b, [d]
1005   0DF8 07 FD 0D      call print_u16x_printx32
1006   0DFB             ; --- END INLINE ASM SEGMENT
1007   0DFB             ; return; 
1008   0DFB F9            leave
1009   0DFC 09            ret
1010   0DFD             ; --- BEGIN INLINE ASM SEGMENT
1011   0DFD             print_u16x_printx32:
1012   0DFD D7            push a
1013   0DFE D8            push b
1014   0DFF DD            push bl
1015   0E00 30            mov bl, bh
1016   0E01 07 1F 0E      call _itoa_printx32        ; convert bh to char in A
1017   0E04 2F            mov bl, al        ; save al
1018   0E05 19 00         mov al, 0
1019   0E07 05 03         syscall sys_io        ; display AH
1020   0E09 24            mov ah, bl        ; retrieve al
1021   0E0A 19 00         mov al, 0
1022   0E0C 05 03         syscall sys_io        ; display AL
1023   0E0E EA            pop bl
1024   0E0F 07 1F 0E      call _itoa_printx32        ; convert bh to char in A
1025   0E12 2F            mov bl, al        ; save al
1026   0E13 19 00         mov al, 0
1027   0E15 05 03         syscall sys_io        ; display AH
1028   0E17 24            mov ah, bl        ; retrieve al
1029   0E18 19 00         mov al, 0
1030   0E1A 05 03         syscall sys_io        ; display AL
1031   0E1C E5            pop b
1032   0E1D E4            pop a
1033   0E1E 09            ret
1034   0E1F             _itoa_printx32:
1035   0E1F DA            push d
1036   0E20 D8            push b
1037   0E21 A7 00         mov bh, 0
1038   0E23 FD A4 04      shr bl, 4  
1039   0E26 74            mov d, b
1040   0E27 1F 39 0E      mov al, [d + s_hex_digits_printx32]
1041   0E2A 23            mov ah, al
1042   0E2B E5            pop b
1043   0E2C D8            push b
1044   0E2D A7 00         mov bh, 0
1045   0E2F FD 87 0F      and bl, $0F
1046   0E32 74            mov d, b
1047   0E33 1F 39 0E      mov al, [d + s_hex_digits_printx32]
1048   0E36 E5            pop b
1049   0E37 E7            pop d
1050   0E38 09            ret
1051   0E39 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
1051   0E3D 34 35 36 37 
1051   0E41 38 39 41 42 
1051   0E45 43 44 45 46 
1052   0E49             ; --- END INLINE ASM SEGMENT
1053   0E49 F9            leave
1054   0E4A 09            ret
1055   0E4B             
1056   0E4B             err:
1057   0E4B F8 00 00      enter 0 ; (push bp; mov bp, sp)
1058   0E4E             ; print(e); 
1059   0E4E             ; --- START FUNCTION CALL
1060   0E4E FA 05 00      lea d, [bp + 5] ; $e
1061   0E51 2A            mov b, [d]
1062   0E52 38 00 00      mov c, 0
1063   0E55 FD AB         swp b
1064   0E57 D8            push b
1065   0E58 07 60 0E      call print
1066   0E5B 51 02 00      add sp, 2
1067   0E5E             ; --- END FUNCTION CALL
1068   0E5E F9            leave
1069   0E5F 09            ret
1070   0E60             
1071   0E60             print:
1072   0E60 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1073   0E63             ; --- BEGIN INLINE ASM SEGMENT
1074   0E63 FA 05 00      lea d, [bp + 5] ; $s
1075   0E66 FD 2A         mov d, [d]
1076   0E68             _puts_L1_print:
1077   0E68 1E            mov al, [d]
1078   0E69 B9 00         cmp al, 0
1079   0E6B C6 77 0E      jz _puts_END_print
1080   0E6E 23            mov ah, al
1081   0E6F 19 00         mov al, 0
1082   0E71 05 03         syscall sys_io
1083   0E73 79            inc d
1084   0E74 0A 68 0E      jmp _puts_L1_print
1085   0E77             _puts_END_print:
1086   0E77             ; --- END INLINE ASM SEGMENT
1087   0E77 F9            leave
1088   0E78 09            ret
1089   0E79             
1090   0E79             print_signed:
1091   0E79 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1092   0E7C             ; char digits[5]; 
1093   0E7C 52 05 00      sub sp, 5
1094   0E7F             ; int i = 0; 
1095   0E7F 52 02 00      sub sp, 2
1096   0E82             ; --- START LOCAL VAR INITIALIZATION
1097   0E82 FA FA FF      lea d, [bp + -6] ; $i
1098   0E85 DA            push d
1099   0E86 FD 2E 00 00   mov32 cb, $00000000
1099   0E8A 00 00 
1100   0E8C E7            pop d
1101   0E8D FD 43         mov [d], b
1102   0E8F             ; --- END LOCAL VAR INITIALIZATION
1103   0E8F             ; if (num < 0) { 
1104   0E8F             _if28_cond:
1105   0E8F FA 05 00      lea d, [bp + 5] ; $num
1106   0E92 2A            mov b, [d]
1107   0E93 38 00 00      mov c, 0
1108   0E96             ; --- START RELATIONAL
1109   0E96 D7            push a
1110   0E97 11            mov a, b
1111   0E98 FD 2E 00 00   mov32 cb, $00000000
1111   0E9C 00 00 
1112   0E9E B0            cmp a, b
1113   0E9F FD 73         slt ; < (signed)
1114   0EA1 E4            pop a
1115   0EA2             ; --- END RELATIONAL
1116   0EA2 C0 00 00      cmp b, 0
1117   0EA5 C6 C8 0E      je _if28_else
1118   0EA8             _if28_TRUE:
1119   0EA8             ; putchar('-'); 
1120   0EA8             ; --- START FUNCTION CALL
1121   0EA8 FD 2E 2D 00   mov32 cb, $0000002d
1121   0EAC 00 00 
1122   0EAE DD            push bl
1123   0EAF 07 A9 0C      call putchar
1124   0EB2 51 01 00      add sp, 1
1125   0EB5             ; --- END FUNCTION CALL
1126   0EB5             ; num = -num; 
1127   0EB5 FA 05 00      lea d, [bp + 5] ; $num
1128   0EB8 DA            push d
1129   0EB9 FA 05 00      lea d, [bp + 5] ; $num
1130   0EBC 2A            mov b, [d]
1131   0EBD 38 00 00      mov c, 0
1132   0EC0 FD 97         neg b
1133   0EC2 E7            pop d
1134   0EC3 FD 43         mov [d], b
1135   0EC5 0A F3 0E      jmp _if28_exit
1136   0EC8             _if28_else:
1137   0EC8             ; if (num == 0) { 
1138   0EC8             _if29_cond:
1139   0EC8 FA 05 00      lea d, [bp + 5] ; $num
1140   0ECB 2A            mov b, [d]
1141   0ECC 38 00 00      mov c, 0
1142   0ECF             ; --- START RELATIONAL
1143   0ECF D7            push a
1144   0ED0 11            mov a, b
1145   0ED1 FD 2E 00 00   mov32 cb, $00000000
1145   0ED5 00 00 
1146   0ED7 B0            cmp a, b
1147   0ED8 FD 71         seq ; ==
1148   0EDA E4            pop a
1149   0EDB             ; --- END RELATIONAL
1150   0EDB C0 00 00      cmp b, 0
1151   0EDE C6 F3 0E      je _if29_exit
1152   0EE1             _if29_TRUE:
1153   0EE1             ; putchar('0'); 
1154   0EE1             ; --- START FUNCTION CALL
1155   0EE1 FD 2E 30 00   mov32 cb, $00000030
1155   0EE5 00 00 
1156   0EE7 DD            push bl
1157   0EE8 07 A9 0C      call putchar
1158   0EEB 51 01 00      add sp, 1
1159   0EEE             ; --- END FUNCTION CALL
1160   0EEE             ; return; 
1161   0EEE F9            leave
1162   0EEF 09            ret
1163   0EF0 0A F3 0E      jmp _if29_exit
1164   0EF3             _if29_exit:
1165   0EF3             _if28_exit:
1166   0EF3             ; while (num > 0) { 
1167   0EF3             _while30_cond:
1168   0EF3 FA 05 00      lea d, [bp + 5] ; $num
1169   0EF6 2A            mov b, [d]
1170   0EF7 38 00 00      mov c, 0
1171   0EFA             ; --- START RELATIONAL
1172   0EFA D7            push a
1173   0EFB 11            mov a, b
1174   0EFC FD 2E 00 00   mov32 cb, $00000000
1174   0F00 00 00 
1175   0F02 B0            cmp a, b
1176   0F03 FD 7F         sgt ; >
1177   0F05 E4            pop a
1178   0F06             ; --- END RELATIONAL
1179   0F06 C0 00 00      cmp b, 0
1180   0F09 C6 80 0F      je _while30_exit
1181   0F0C             _while30_block:
1182   0F0C             ; digits[i] = '0' + (num % 10); 
1183   0F0C FA FC FF      lea d, [bp + -4] ; $digits
1184   0F0F D7            push a
1185   0F10 DA            push d
1186   0F11 FA FA FF      lea d, [bp + -6] ; $i
1187   0F14 2A            mov b, [d]
1188   0F15 38 00 00      mov c, 0
1189   0F18 E7            pop d
1190   0F19 5A            add d, b
1191   0F1A E4            pop a
1192   0F1B DA            push d
1193   0F1C FD 2E 30 00   mov32 cb, $00000030
1193   0F20 00 00 
1194   0F22             ; --- START TERMS
1195   0F22 D7            push a
1196   0F23 11            mov a, b
1197   0F24 FA 05 00      lea d, [bp + 5] ; $num
1198   0F27 2A            mov b, [d]
1199   0F28 38 00 00      mov c, 0
1200   0F2B             ; --- START FACTORS
1201   0F2B D7            push a
1202   0F2C FD D8         push g
1203   0F2E 11            mov a, b
1204   0F2F FD 7A         mov g, c
1205   0F31 FD 2E 0A 00   mov32 cb, $0000000a
1205   0F35 00 00 
1206   0F37 FD D8         push g ; save 'g' as the div instruction uses it
1207   0F39 AE            div a, b ; %, a: quotient, b: remainder
1208   0F3A 11            mov a, b
1209   0F3B FD F1         pop g
1210   0F3D FD 38         mov c, g
1211   0F3F 27            mov b, a
1212   0F40 FD F1         pop g
1213   0F42 E4            pop a
1214   0F43             ; --- END FACTORS
1215   0F43 56            add b, a
1216   0F44 E4            pop a
1217   0F45             ; --- END TERMS
1218   0F45 E7            pop d
1219   0F46 FD 3E         mov [d], bl
1220   0F48             ; num = num / 10; 
1221   0F48 FA 05 00      lea d, [bp + 5] ; $num
1222   0F4B DA            push d
1223   0F4C FA 05 00      lea d, [bp + 5] ; $num
1224   0F4F 2A            mov b, [d]
1225   0F50 38 00 00      mov c, 0
1226   0F53             ; --- START FACTORS
1227   0F53 D7            push a
1228   0F54 FD D8         push g
1229   0F56 11            mov a, b
1230   0F57 FD 7A         mov g, c
1231   0F59 FD 2E 0A 00   mov32 cb, $0000000a
1231   0F5D 00 00 
1232   0F5F FD D8         push g ; save 'g' as the div instruction uses it
1233   0F61 AE            div a, b ; /, a: quotient, b: remainder
1234   0F62 FD F1         pop g
1235   0F64 FD 38         mov c, g
1236   0F66 27            mov b, a
1237   0F67 FD F1         pop g
1238   0F69 E4            pop a
1239   0F6A             ; --- END FACTORS
1240   0F6A E7            pop d
1241   0F6B FD 43         mov [d], b
1242   0F6D             ; i++; 
1243   0F6D FA FA FF      lea d, [bp + -6] ; $i
1244   0F70 2A            mov b, [d]
1245   0F71 38 00 00      mov c, 0
1246   0F74 11            mov a, b
1247   0F75 FD 77         inc b
1248   0F77 FA FA FF      lea d, [bp + -6] ; $i
1249   0F7A FD 43         mov [d], b
1250   0F7C 27            mov b, a
1251   0F7D 0A F3 0E      jmp _while30_cond
1252   0F80             _while30_exit:
1253   0F80             ; while (i > 0) { 
1254   0F80             _while37_cond:
1255   0F80 FA FA FF      lea d, [bp + -6] ; $i
1256   0F83 2A            mov b, [d]
1257   0F84 38 00 00      mov c, 0
1258   0F87             ; --- START RELATIONAL
1259   0F87 D7            push a
1260   0F88 11            mov a, b
1261   0F89 FD 2E 00 00   mov32 cb, $00000000
1261   0F8D 00 00 
1262   0F8F B0            cmp a, b
1263   0F90 FD 7F         sgt ; >
1264   0F92 E4            pop a
1265   0F93             ; --- END RELATIONAL
1266   0F93 C0 00 00      cmp b, 0
1267   0F96 C6 C8 0F      je _while37_exit
1268   0F99             _while37_block:
1269   0F99             ; i--; 
1270   0F99 FA FA FF      lea d, [bp + -6] ; $i
1271   0F9C 2A            mov b, [d]
1272   0F9D 38 00 00      mov c, 0
1273   0FA0 11            mov a, b
1274   0FA1 FD 7D         dec b
1275   0FA3 FA FA FF      lea d, [bp + -6] ; $i
1276   0FA6 FD 43         mov [d], b
1277   0FA8 27            mov b, a
1278   0FA9             ; putchar(digits[i]); 
1279   0FA9             ; --- START FUNCTION CALL
1280   0FA9 FA FC FF      lea d, [bp + -4] ; $digits
1281   0FAC D7            push a
1282   0FAD DA            push d
1283   0FAE FA FA FF      lea d, [bp + -6] ; $i
1284   0FB1 2A            mov b, [d]
1285   0FB2 38 00 00      mov c, 0
1286   0FB5 E7            pop d
1287   0FB6 5A            add d, b
1288   0FB7 E4            pop a
1289   0FB8 32            mov bl, [d]
1290   0FB9 A7 00         mov bh, 0
1291   0FBB 38 00 00      mov c, 0
1292   0FBE DD            push bl
1293   0FBF 07 A9 0C      call putchar
1294   0FC2 51 01 00      add sp, 1
1295   0FC5             ; --- END FUNCTION CALL
1296   0FC5 0A 80 0F      jmp _while37_cond
1297   0FC8             _while37_exit:
1298   0FC8 F9            leave
1299   0FC9 09            ret
1300   0FCA             
1301   0FCA             print_unsigned:
1302   0FCA F8 00 00      enter 0 ; (push bp; mov bp, sp)
1303   0FCD             ; char digits[5]; 
1304   0FCD 52 05 00      sub sp, 5
1305   0FD0             ; int i; 
1306   0FD0 52 02 00      sub sp, 2
1307   0FD3             ; i = 0; 
1308   0FD3 FA FA FF      lea d, [bp + -6] ; $i
1309   0FD6 DA            push d
1310   0FD7 FD 2E 00 00   mov32 cb, $00000000
1310   0FDB 00 00 
1311   0FDD E7            pop d
1312   0FDE FD 43         mov [d], b
1313   0FE0             ; if(num == 0){ 
1314   0FE0             _if38_cond:
1315   0FE0 FA 05 00      lea d, [bp + 5] ; $num
1316   0FE3 2A            mov b, [d]
1317   0FE4 38 00 00      mov c, 0
1318   0FE7             ; --- START RELATIONAL
1319   0FE7 D7            push a
1320   0FE8 11            mov a, b
1321   0FE9 FD 2E 00 00   mov32 cb, $00000000
1321   0FED 00 00 
1322   0FEF B0            cmp a, b
1323   0FF0 FD 71         seq ; ==
1324   0FF2 E4            pop a
1325   0FF3             ; --- END RELATIONAL
1326   0FF3 C0 00 00      cmp b, 0
1327   0FF6 C6 0B 10      je _if38_exit
1328   0FF9             _if38_TRUE:
1329   0FF9             ; putchar('0'); 
1330   0FF9             ; --- START FUNCTION CALL
1331   0FF9 FD 2E 30 00   mov32 cb, $00000030
1331   0FFD 00 00 
1332   0FFF DD            push bl
1333   1000 07 A9 0C      call putchar
1334   1003 51 01 00      add sp, 1
1335   1006             ; --- END FUNCTION CALL
1336   1006             ; return; 
1337   1006 F9            leave
1338   1007 09            ret
1339   1008 0A 0B 10      jmp _if38_exit
1340   100B             _if38_exit:
1341   100B             ; while (num > 0) { 
1342   100B             _while39_cond:
1343   100B FA 05 00      lea d, [bp + 5] ; $num
1344   100E 2A            mov b, [d]
1345   100F 38 00 00      mov c, 0
1346   1012             ; --- START RELATIONAL
1347   1012 D7            push a
1348   1013 11            mov a, b
1349   1014 FD 2E 00 00   mov32 cb, $00000000
1349   1018 00 00 
1350   101A B0            cmp a, b
1351   101B FD 81         sgu ; > (unsigned)
1352   101D E4            pop a
1353   101E             ; --- END RELATIONAL
1354   101E C0 00 00      cmp b, 0
1355   1021 C6 98 10      je _while39_exit
1356   1024             _while39_block:
1357   1024             ; digits[i] = '0' + (num % 10); 
1358   1024 FA FC FF      lea d, [bp + -4] ; $digits
1359   1027 D7            push a
1360   1028 DA            push d
1361   1029 FA FA FF      lea d, [bp + -6] ; $i
1362   102C 2A            mov b, [d]
1363   102D 38 00 00      mov c, 0
1364   1030 E7            pop d
1365   1031 5A            add d, b
1366   1032 E4            pop a
1367   1033 DA            push d
1368   1034 FD 2E 30 00   mov32 cb, $00000030
1368   1038 00 00 
1369   103A             ; --- START TERMS
1370   103A D7            push a
1371   103B 11            mov a, b
1372   103C FA 05 00      lea d, [bp + 5] ; $num
1373   103F 2A            mov b, [d]
1374   1040 38 00 00      mov c, 0
1375   1043             ; --- START FACTORS
1376   1043 D7            push a
1377   1044 FD D8         push g
1378   1046 11            mov a, b
1379   1047 FD 7A         mov g, c
1380   1049 FD 2E 0A 00   mov32 cb, $0000000a
1380   104D 00 00 
1381   104F FD D8         push g ; save 'g' as the div instruction uses it
1382   1051 AE            div a, b ; %, a: quotient, b: remainder
1383   1052 11            mov a, b
1384   1053 FD F1         pop g
1385   1055 FD 38         mov c, g
1386   1057 27            mov b, a
1387   1058 FD F1         pop g
1388   105A E4            pop a
1389   105B             ; --- END FACTORS
1390   105B 56            add b, a
1391   105C E4            pop a
1392   105D             ; --- END TERMS
1393   105D E7            pop d
1394   105E FD 3E         mov [d], bl
1395   1060             ; num = num / 10; 
1396   1060 FA 05 00      lea d, [bp + 5] ; $num
1397   1063 DA            push d
1398   1064 FA 05 00      lea d, [bp + 5] ; $num
1399   1067 2A            mov b, [d]
1400   1068 38 00 00      mov c, 0
1401   106B             ; --- START FACTORS
1402   106B D7            push a
1403   106C FD D8         push g
1404   106E 11            mov a, b
1405   106F FD 7A         mov g, c
1406   1071 FD 2E 0A 00   mov32 cb, $0000000a
1406   1075 00 00 
1407   1077 FD D8         push g ; save 'g' as the div instruction uses it
1408   1079 AE            div a, b ; /, a: quotient, b: remainder
1409   107A FD F1         pop g
1410   107C FD 38         mov c, g
1411   107E 27            mov b, a
1412   107F FD F1         pop g
1413   1081 E4            pop a
1414   1082             ; --- END FACTORS
1415   1082 E7            pop d
1416   1083 FD 43         mov [d], b
1417   1085             ; i++; 
1418   1085 FA FA FF      lea d, [bp + -6] ; $i
1419   1088 2A            mov b, [d]
1420   1089 38 00 00      mov c, 0
1421   108C 11            mov a, b
1422   108D FD 77         inc b
1423   108F FA FA FF      lea d, [bp + -6] ; $i
1424   1092 FD 43         mov [d], b
1425   1094 27            mov b, a
1426   1095 0A 0B 10      jmp _while39_cond
1427   1098             _while39_exit:
1428   1098             ; while (i > 0) { 
1429   1098             _while46_cond:
1430   1098 FA FA FF      lea d, [bp + -6] ; $i
1431   109B 2A            mov b, [d]
1432   109C 38 00 00      mov c, 0
1433   109F             ; --- START RELATIONAL
1434   109F D7            push a
1435   10A0 11            mov a, b
1436   10A1 FD 2E 00 00   mov32 cb, $00000000
1436   10A5 00 00 
1437   10A7 B0            cmp a, b
1438   10A8 FD 7F         sgt ; >
1439   10AA E4            pop a
1440   10AB             ; --- END RELATIONAL
1441   10AB C0 00 00      cmp b, 0
1442   10AE C6 E0 10      je _while46_exit
1443   10B1             _while46_block:
1444   10B1             ; i--; 
1445   10B1 FA FA FF      lea d, [bp + -6] ; $i
1446   10B4 2A            mov b, [d]
1447   10B5 38 00 00      mov c, 0
1448   10B8 11            mov a, b
1449   10B9 FD 7D         dec b
1450   10BB FA FA FF      lea d, [bp + -6] ; $i
1451   10BE FD 43         mov [d], b
1452   10C0 27            mov b, a
1453   10C1             ; putchar(digits[i]); 
1454   10C1             ; --- START FUNCTION CALL
1455   10C1 FA FC FF      lea d, [bp + -4] ; $digits
1456   10C4 D7            push a
1457   10C5 DA            push d
1458   10C6 FA FA FF      lea d, [bp + -6] ; $i
1459   10C9 2A            mov b, [d]
1460   10CA 38 00 00      mov c, 0
1461   10CD E7            pop d
1462   10CE 5A            add d, b
1463   10CF E4            pop a
1464   10D0 32            mov bl, [d]
1465   10D1 A7 00         mov bh, 0
1466   10D3 38 00 00      mov c, 0
1467   10D6 DD            push bl
1468   10D7 07 A9 0C      call putchar
1469   10DA 51 01 00      add sp, 1
1470   10DD             ; --- END FUNCTION CALL
1471   10DD 0A 98 10      jmp _while46_cond
1472   10E0             _while46_exit:
1473   10E0 F9            leave
1474   10E1 09            ret
1475   10E2             
1476   10E2             printx16:
1477   10E2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1478   10E5             ; --- BEGIN INLINE ASM SEGMENT
1479   10E5 FA 05 00      lea d, [bp + 5] ; $hex
1480   10E8 2A            mov b, [d]
1481   10E9             print_u16x_printx16:
1482   10E9 DD            push bl
1483   10EA 30            mov bl, bh
1484   10EB 07 08 11      call _itoa_printx16        ; convert bh to char in A
1485   10EE 2F            mov bl, al        ; save al
1486   10EF 19 00         mov al, 0
1487   10F1 05 03         syscall sys_io        ; display AH
1488   10F3 24            mov ah, bl        ; retrieve al
1489   10F4 19 00         mov al, 0
1490   10F6 05 03         syscall sys_io        ; display AL
1491   10F8 EA            pop bl
1492   10F9 07 08 11      call _itoa_printx16        ; convert bh to char in A
1493   10FC 2F            mov bl, al        ; save al
1494   10FD 19 00         mov al, 0
1495   10FF 05 03         syscall sys_io        ; display AH
1496   1101 24            mov ah, bl        ; retrieve al
1497   1102 19 00         mov al, 0
1498   1104 05 03         syscall sys_io        ; display AL
1499   1106             ; --- END INLINE ASM SEGMENT
1500   1106             ; return; 
1501   1106 F9            leave
1502   1107 09            ret
1503   1108             ; --- BEGIN INLINE ASM SEGMENT
1504   1108             _itoa_printx16:
1505   1108 DA            push d
1506   1109 D8            push b
1507   110A A7 00         mov bh, 0
1508   110C FD A4 04      shr bl, 4  
1509   110F 74            mov d, b
1510   1110 1F 22 11      mov al, [d + s_hex_digits_printx16]
1511   1113 23            mov ah, al
1512   1114 E5            pop b
1513   1115 D8            push b
1514   1116 A7 00         mov bh, 0
1515   1118 FD 87 0F      and bl, $0F
1516   111B 74            mov d, b
1517   111C 1F 22 11      mov al, [d + s_hex_digits_printx16]
1518   111F E5            pop b
1519   1120 E7            pop d
1520   1121 09            ret
1521   1122 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
1521   1126 34 35 36 37 
1521   112A 38 39 41 42 
1521   112E 43 44 45 46 
1522   1132             ; --- END INLINE ASM SEGMENT
1523   1132 F9            leave
1524   1133 09            ret
1525   1134             
1526   1134             move_cursor:
1527   1134 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1528   1137             ; printf("\033[%d;%dH", y, x); 
1529   1137             ; --- START FUNCTION CALL
1530   1137 FA 05 00      lea d, [bp + 5] ; $x
1531   113A 2A            mov b, [d]
1532   113B 38 00 00      mov c, 0
1533   113E FD AB         swp b
1534   1140 D8            push b
1535   1141 FA 07 00      lea d, [bp + 7] ; $y
1536   1144 2A            mov b, [d]
1537   1145 38 00 00      mov c, 0
1538   1148 FD AB         swp b
1539   114A D8            push b
1540   114B 26 A3 11      mov b, _s4 ; "\033[%d;%dH"
1541   114E FD AB         swp b
1542   1150 D8            push b
1543   1151 07 37 08      call printf
1544   1154 51 06 00      add sp, 6
1545   1157             ; --- END FUNCTION CALL
1546   1157 F9            leave
1547   1158 09            ret
1548   1159             ; --- END TEXT SEGMENT
1549   1159             
1550   1159             ; --- BEGIN DATA SEGMENT
1551   1159 1B 5B 3F 32 _s0: .db "\033[?25l", 0
1551   115D 35 6C 00 
1552   1160 1B 5B 3F 32 _s1: .db "\033[?25h", 0
1552   1164 35 68 00 
1553   1167 55 6E 65 78 _s2: .db "Unexpected format in printf.", 0
1553   116B 70 65 63 74 
1553   116F 65 64 20 66 
1553   1173 6F 72 6D 61 
1553   1177 74 20 69 6E 
1553   117B 20 70 72 69 
1553   117F 6E 74 66 2E 
1553   1183 00 
1554   1184 45 72 72 6F _s3: .db "Error: Unknown argument type.\n", 0
1554   1188 72 3A 20 55 
1554   118C 6E 6B 6E 6F 
1554   1190 77 6E 20 61 
1554   1194 72 67 75 6D 
1554   1198 65 6E 74 20 
1554   119C 74 79 70 65 
1554   11A0 2E 0A 00 
1555   11A3 1B 5B 25 64 _s4: .db "\033[%d;%dH", 0
1555   11A7 3B 25 64 48 
1555   11AB 00 
1556   11AC             
1557   11AC AE 11       _heap_top: .dw _heap
1558   11AE 00          _heap: .db 0
1559   11AF             ; --- END DATA SEGMENT
1560   11AF             
1561   11AF             .end
tasm: Number of errors = 0
