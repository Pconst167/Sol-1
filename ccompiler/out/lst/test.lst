0001   0000             ; --- FILENAME: test
0002   0000             .include "lib/asm/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ;; base64_decode(input, output); 
0011   0408 3B 39 22      mov d, _output_data ; $output
0012   040B 2D            mov b, d
0013   040C FD AB         swp b
0014   040E D8            push b
0015   040F 3B 37 22      mov d, _input ; $input
0016   0412 2A            mov b, [d]
0017   0413 FD AB         swp b
0018   0415 D8            push b
0019   0416 07 69 1A      call base64_decode
0020   0419 51 04 00      add sp, 4
0021   041C             ;; printf("\nResult: %d. Section: %d\n", pass, section); 
0022   041C 3B 3B 24      mov d, _section ; $section
0023   041F 2A            mov b, [d]
0024   0420 FD AB         swp b
0025   0422 D8            push b
0026   0423 3B 39 24      mov d, _pass ; $pass
0027   0426 2A            mov b, [d]
0028   0427 FD AB         swp b
0029   0429 D8            push b
0030   042A 26 3D 24      mov b, _s0 ; "\nResult: %d. Section: %d\n"
0031   042D FD AB         swp b
0032   042F D8            push b
0033   0430 07 DC 07      call printf
0034   0433 51 06 00      add sp, 6
0035   0436 05 0B         syscall sys_terminate_proc
0036   0438             
0037   0438             strcpy:
0038   0438 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0039   043B             ;; char *psrc; 
0040   043B 52 02 00      sub sp, 2 ; psrc
0041   043E             ;; char *pdest; 
0042   043E 52 02 00      sub sp, 2 ; pdest
0043   0441             ;; psrc = src; 
0044   0441 FA FF FF      lea d, [bp + -1] ; $psrc
0045   0444 DA            push d
0046   0445 FA 07 00      lea d, [bp + 7] ; $src
0047   0448 2A            mov b, [d]
0048   0449 E7            pop d
0049   044A FD 43         mov [d], b
0050   044C             ;; pdest = dest; 
0051   044C FA FD FF      lea d, [bp + -3] ; $pdest
0052   044F DA            push d
0053   0450 FA 05 00      lea d, [bp + 5] ; $dest
0054   0453 2A            mov b, [d]
0055   0454 E7            pop d
0056   0455 FD 43         mov [d], b
0057   0457             ;; while(*psrc) *pdest++ = *psrc++; 
0058   0457             _while1_cond:
0059   0457 FA FF FF      lea d, [bp + -1] ; $psrc
0060   045A 2A            mov b, [d]
0061   045B 74            mov d, b
0062   045C 32            mov bl, [d]
0063   045D A7 00         mov bh, 0
0064   045F C0 00 00      cmp b, 0
0065   0462 C6 8A 04      je _while1_exit
0066   0465             _while1_block:
0067   0465             ;; *pdest++ = *psrc++; 
0068   0465 FA FD FF      lea d, [bp + -3] ; $pdest
0069   0468 2A            mov b, [d]
0070   0469 FD 77         inc b
0071   046B FA FD FF      lea d, [bp + -3] ; $pdest
0072   046E FD 43         mov [d], b
0073   0470 FD 7D         dec b
0074   0472 D8            push b
0075   0473 FA FF FF      lea d, [bp + -1] ; $psrc
0076   0476 2A            mov b, [d]
0077   0477 FD 77         inc b
0078   0479 FA FF FF      lea d, [bp + -1] ; $psrc
0079   047C FD 43         mov [d], b
0080   047E FD 7D         dec b
0081   0480 74            mov d, b
0082   0481 32            mov bl, [d]
0083   0482 A7 00         mov bh, 0
0084   0484 E7            pop d
0085   0485 FD 3E         mov [d], bl
0086   0487 0A 57 04      jmp _while1_cond
0087   048A             _while1_exit:
0088   048A             ;; *pdest = '\0'; 
0089   048A FA FD FF      lea d, [bp + -3] ; $pdest
0090   048D 2A            mov b, [d]
0091   048E D8            push b
0092   048F 26 00 00      mov b, $0
0093   0492 E7            pop d
0094   0493 FD 3E         mov [d], bl
0095   0495 F9            leave
0096   0496 09            ret
0097   0497             
0098   0497             strcmp:
0099   0497 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0100   049A             ;; while (*s1 && (*s1 == *s2)) { 
0101   049A             _while2_cond:
0102   049A FA 05 00      lea d, [bp + 5] ; $s1
0103   049D 2A            mov b, [d]
0104   049E 74            mov d, b
0105   049F 32            mov bl, [d]
0106   04A0 A7 00         mov bh, 0
0107   04A2             ; START LOGICAL AND
0108   04A2 D7            push a
0109   04A3 11            mov a, b
0110   04A4 FA 05 00      lea d, [bp + 5] ; $s1
0111   04A7 2A            mov b, [d]
0112   04A8 74            mov d, b
0113   04A9 32            mov bl, [d]
0114   04AA A7 00         mov bh, 0
0115   04AC             ; START RELATIONAL
0116   04AC D7            push a
0117   04AD 11            mov a, b
0118   04AE FA 07 00      lea d, [bp + 7] ; $s2
0119   04B1 2A            mov b, [d]
0120   04B2 74            mov d, b
0121   04B3 32            mov bl, [d]
0122   04B4 A7 00         mov bh, 0
0123   04B6 B0            cmp a, b
0124   04B7 FD 71         seq ; ==
0125   04B9 E4            pop a
0126   04BA             ; END RELATIONAL
0127   04BA FD A7         sand a, b
0128   04BC E4            pop a
0129   04BD             ; END LOGICAL AND
0130   04BD C0 00 00      cmp b, 0
0131   04C0 C6 E0 04      je _while2_exit
0132   04C3             _while2_block:
0133   04C3             ;; s1++; 
0134   04C3 FA 05 00      lea d, [bp + 5] ; $s1
0135   04C6 2A            mov b, [d]
0136   04C7 FD 77         inc b
0137   04C9 FA 05 00      lea d, [bp + 5] ; $s1
0138   04CC FD 43         mov [d], b
0139   04CE FD 7D         dec b
0140   04D0             ;; s2++; 
0141   04D0 FA 07 00      lea d, [bp + 7] ; $s2
0142   04D3 2A            mov b, [d]
0143   04D4 FD 77         inc b
0144   04D6 FA 07 00      lea d, [bp + 7] ; $s2
0145   04D9 FD 43         mov [d], b
0146   04DB FD 7D         dec b
0147   04DD 0A 9A 04      jmp _while2_cond
0148   04E0             _while2_exit:
0149   04E0             ;; return *s1 - *s2; 
0150   04E0 FA 05 00      lea d, [bp + 5] ; $s1
0151   04E3 2A            mov b, [d]
0152   04E4 74            mov d, b
0153   04E5 32            mov bl, [d]
0154   04E6 A7 00         mov bh, 0
0155   04E8             ; START TERMS
0156   04E8 D7            push a
0157   04E9 11            mov a, b
0158   04EA FA 07 00      lea d, [bp + 7] ; $s2
0159   04ED 2A            mov b, [d]
0160   04EE 74            mov d, b
0161   04EF 32            mov bl, [d]
0162   04F0 A7 00         mov bh, 0
0163   04F2 60            sub a, b
0164   04F3 27            mov b, a
0165   04F4 E4            pop a
0166   04F5             ; END TERMS
0167   04F5 F9            leave
0168   04F6 09            ret
0169   04F7             
0170   04F7             strncmp:
0171   04F7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0172   04FA F9            leave
0173   04FB 09            ret
0174   04FC             
0175   04FC             strcat:
0176   04FC F8 00 00      enter 0 ; (push bp; mov bp, sp)
0177   04FF             ;; int dest_len; 
0178   04FF 52 02 00      sub sp, 2 ; dest_len
0179   0502             ;; int i; 
0180   0502 52 02 00      sub sp, 2 ; i
0181   0505             ;; dest_len = strlen(dest); 
0182   0505 FA FF FF      lea d, [bp + -1] ; $dest_len
0183   0508 DA            push d
0184   0509 FA 05 00      lea d, [bp + 5] ; $dest
0185   050C 2A            mov b, [d]
0186   050D FD AB         swp b
0187   050F D8            push b
0188   0510 07 B2 05      call strlen
0189   0513 51 02 00      add sp, 2
0190   0516 E7            pop d
0191   0517 FD 43         mov [d], b
0192   0519             ;; for (i = 0; src[i] != 0; i=i+1) { 
0193   0519             _for3_init:
0194   0519 FA FD FF      lea d, [bp + -3] ; $i
0195   051C DA            push d
0196   051D 26 00 00      mov b, $0
0197   0520 E7            pop d
0198   0521 FD 43         mov [d], b
0199   0523             _for3_cond:
0200   0523 FA 07 00      lea d, [bp + 7] ; $src
0201   0526 FD 2A         mov d, [d]
0202   0528 D7            push a
0203   0529 DA            push d
0204   052A FA FD FF      lea d, [bp + -3] ; $i
0205   052D 2A            mov b, [d]
0206   052E E7            pop d
0207   052F FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0208   0533 E4            pop a
0209   0534 32            mov bl, [d]
0210   0535 A7 00         mov bh, 0
0211   0537             ; START RELATIONAL
0212   0537 D7            push a
0213   0538 11            mov a, b
0214   0539 26 00 00      mov b, $0
0215   053C B0            cmp a, b
0216   053D FD 72         sneq ; !=
0217   053F E4            pop a
0218   0540             ; END RELATIONAL
0219   0540 C0 00 00      cmp b, 0
0220   0543 C6 8C 05      je _for3_exit
0221   0546             _for3_block:
0222   0546             ;; dest[dest_len + i] = src[i]; 
0223   0546 FA 05 00      lea d, [bp + 5] ; $dest
0224   0549 FD 2A         mov d, [d]
0225   054B D7            push a
0226   054C DA            push d
0227   054D FA FF FF      lea d, [bp + -1] ; $dest_len
0228   0550 2A            mov b, [d]
0229   0551             ; START TERMS
0230   0551 D7            push a
0231   0552 11            mov a, b
0232   0553 FA FD FF      lea d, [bp + -3] ; $i
0233   0556 2A            mov b, [d]
0234   0557 56            add b, a
0235   0558 E4            pop a
0236   0559             ; END TERMS
0237   0559 E7            pop d
0238   055A FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0239   055E E4            pop a
0240   055F DA            push d
0241   0560 FA 07 00      lea d, [bp + 7] ; $src
0242   0563 FD 2A         mov d, [d]
0243   0565 D7            push a
0244   0566 DA            push d
0245   0567 FA FD FF      lea d, [bp + -3] ; $i
0246   056A 2A            mov b, [d]
0247   056B E7            pop d
0248   056C FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0249   0570 E4            pop a
0250   0571 32            mov bl, [d]
0251   0572 A7 00         mov bh, 0
0252   0574 E7            pop d
0253   0575 FD 3E         mov [d], bl
0254   0577             _for3_update:
0255   0577 FA FD FF      lea d, [bp + -3] ; $i
0256   057A DA            push d
0257   057B FA FD FF      lea d, [bp + -3] ; $i
0258   057E 2A            mov b, [d]
0259   057F             ; START TERMS
0260   057F D7            push a
0261   0580 11            mov a, b
0262   0581 26 01 00      mov b, $1
0263   0584 56            add b, a
0264   0585 E4            pop a
0265   0586             ; END TERMS
0266   0586 E7            pop d
0267   0587 FD 43         mov [d], b
0268   0589 0A 23 05      jmp _for3_cond
0269   058C             _for3_exit:
0270   058C             ;; dest[dest_len + i] = 0; 
0271   058C FA 05 00      lea d, [bp + 5] ; $dest
0272   058F FD 2A         mov d, [d]
0273   0591 D7            push a
0274   0592 DA            push d
0275   0593 FA FF FF      lea d, [bp + -1] ; $dest_len
0276   0596 2A            mov b, [d]
0277   0597             ; START TERMS
0278   0597 D7            push a
0279   0598 11            mov a, b
0280   0599 FA FD FF      lea d, [bp + -3] ; $i
0281   059C 2A            mov b, [d]
0282   059D 56            add b, a
0283   059E E4            pop a
0284   059F             ; END TERMS
0285   059F E7            pop d
0286   05A0 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0287   05A4 E4            pop a
0288   05A5 DA            push d
0289   05A6 26 00 00      mov b, $0
0290   05A9 E7            pop d
0291   05AA FD 3E         mov [d], bl
0292   05AC             ;; return dest; 
0293   05AC FA 05 00      lea d, [bp + 5] ; $dest
0294   05AF 2A            mov b, [d]
0295   05B0 F9            leave
0296   05B1 09            ret
0297   05B2             
0298   05B2             strlen:
0299   05B2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0300   05B5             ;; int length; 
0301   05B5 52 02 00      sub sp, 2 ; length
0302   05B8             ;; length = 0; 
0303   05B8 FA FF FF      lea d, [bp + -1] ; $length
0304   05BB DA            push d
0305   05BC 26 00 00      mov b, $0
0306   05BF E7            pop d
0307   05C0 FD 43         mov [d], b
0308   05C2             ;; while (str[length] != 0) { 
0309   05C2             _while4_cond:
0310   05C2 FA 05 00      lea d, [bp + 5] ; $str
0311   05C5 FD 2A         mov d, [d]
0312   05C7 D7            push a
0313   05C8 DA            push d
0314   05C9 FA FF FF      lea d, [bp + -1] ; $length
0315   05CC 2A            mov b, [d]
0316   05CD E7            pop d
0317   05CE FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0318   05D2 E4            pop a
0319   05D3 32            mov bl, [d]
0320   05D4 A7 00         mov bh, 0
0321   05D6             ; START RELATIONAL
0322   05D6 D7            push a
0323   05D7 11            mov a, b
0324   05D8 26 00 00      mov b, $0
0325   05DB B0            cmp a, b
0326   05DC FD 72         sneq ; !=
0327   05DE E4            pop a
0328   05DF             ; END RELATIONAL
0329   05DF C0 00 00      cmp b, 0
0330   05E2 C6 F5 05      je _while4_exit
0331   05E5             _while4_block:
0332   05E5             ;; length++; 
0333   05E5 FA FF FF      lea d, [bp + -1] ; $length
0334   05E8 2A            mov b, [d]
0335   05E9 FD 77         inc b
0336   05EB FA FF FF      lea d, [bp + -1] ; $length
0337   05EE FD 43         mov [d], b
0338   05F0 FD 7D         dec b
0339   05F2 0A C2 05      jmp _while4_cond
0340   05F5             _while4_exit:
0341   05F5             ;; return length; 
0342   05F5 FA FF FF      lea d, [bp + -1] ; $length
0343   05F8 2A            mov b, [d]
0344   05F9 F9            leave
0345   05FA 09            ret
0346   05FB             
0347   05FB             exit:
0348   05FB F8 00 00      enter 0 ; (push bp; mov bp, sp)
0349   05FE             
0350   05FE             ; --- BEGIN INLINE ASM BLOCK
0351   05FE 05 0B         syscall sys_terminate_proc
0352   0600             ; --- END INLINE ASM BLOCK
0353   0600             
0354   0600 F9            leave
0355   0601 09            ret
0356   0602             
0357   0602             memset:
0358   0602 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0359   0605             ;; int i; 
0360   0605 52 02 00      sub sp, 2 ; i
0361   0608             ;; for(i = 0; i < size; i++){ 
0362   0608             _for5_init:
0363   0608 FA FF FF      lea d, [bp + -1] ; $i
0364   060B DA            push d
0365   060C 26 00 00      mov b, $0
0366   060F E7            pop d
0367   0610 FD 43         mov [d], b
0368   0612             _for5_cond:
0369   0612 FA FF FF      lea d, [bp + -1] ; $i
0370   0615 2A            mov b, [d]
0371   0616             ; START RELATIONAL
0372   0616 D7            push a
0373   0617 11            mov a, b
0374   0618 FA 08 00      lea d, [bp + 8] ; $size
0375   061B 2A            mov b, [d]
0376   061C B0            cmp a, b
0377   061D FD 73         slt ; < (signed)
0378   061F E4            pop a
0379   0620             ; END RELATIONAL
0380   0620 C0 00 00      cmp b, 0
0381   0623 C6 4C 06      je _for5_exit
0382   0626             _for5_block:
0383   0626             ;; *(s+i) = c; 
0384   0626 FA 05 00      lea d, [bp + 5] ; $s
0385   0629 2A            mov b, [d]
0386   062A             ; START TERMS
0387   062A D7            push a
0388   062B 11            mov a, b
0389   062C FA FF FF      lea d, [bp + -1] ; $i
0390   062F 2A            mov b, [d]
0391   0630 56            add b, a
0392   0631 E4            pop a
0393   0632             ; END TERMS
0394   0632 D8            push b
0395   0633 FA 07 00      lea d, [bp + 7] ; $c
0396   0636 32            mov bl, [d]
0397   0637 A7 00         mov bh, 0
0398   0639 E7            pop d
0399   063A FD 3E         mov [d], bl
0400   063C             _for5_update:
0401   063C FA FF FF      lea d, [bp + -1] ; $i
0402   063F 2A            mov b, [d]
0403   0640 FD 77         inc b
0404   0642 FA FF FF      lea d, [bp + -1] ; $i
0405   0645 FD 43         mov [d], b
0406   0647 FD 7D         dec b
0407   0649 0A 12 06      jmp _for5_cond
0408   064C             _for5_exit:
0409   064C             ;; return s; 
0410   064C FA 05 00      lea d, [bp + 5] ; $s
0411   064F 2A            mov b, [d]
0412   0650 F9            leave
0413   0651 09            ret
0414   0652             
0415   0652             atoi:
0416   0652 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0417   0655             ;; int result = 0;  // Initialize result 
0418   0655 52 02 00      sub sp, 2 ; result
0419   0658             ; --- START LOCAL VAR INITIALIZATION
0420   0658 FA FF FF      lea d, [bp + -1] ; $result
0421   065B DA            push d
0422   065C 26 00 00      mov b, $0
0423   065F E7            pop d
0424   0660 FD 43         mov [d], b
0425   0662             ; --- END LOCAL VAR INITIALIZATION
0426   0662             ;; int sign = 1;    // Initialize sign as positive 
0427   0662 52 02 00      sub sp, 2 ; sign
0428   0665             ; --- START LOCAL VAR INITIALIZATION
0429   0665 FA FD FF      lea d, [bp + -3] ; $sign
0430   0668 DA            push d
0431   0669 26 01 00      mov b, $1
0432   066C E7            pop d
0433   066D FD 43         mov [d], b
0434   066F             ; --- END LOCAL VAR INITIALIZATION
0435   066F             ;; while (*str == ' ') str++; 
0436   066F             _while6_cond:
0437   066F FA 05 00      lea d, [bp + 5] ; $str
0438   0672 2A            mov b, [d]
0439   0673 74            mov d, b
0440   0674 32            mov bl, [d]
0441   0675 A7 00         mov bh, 0
0442   0677             ; START RELATIONAL
0443   0677 D7            push a
0444   0678 11            mov a, b
0445   0679 26 20 00      mov b, $20
0446   067C B0            cmp a, b
0447   067D FD 71         seq ; ==
0448   067F E4            pop a
0449   0680             ; END RELATIONAL
0450   0680 C0 00 00      cmp b, 0
0451   0683 C6 96 06      je _while6_exit
0452   0686             _while6_block:
0453   0686             ;; str++; 
0454   0686 FA 05 00      lea d, [bp + 5] ; $str
0455   0689 2A            mov b, [d]
0456   068A FD 77         inc b
0457   068C FA 05 00      lea d, [bp + 5] ; $str
0458   068F FD 43         mov [d], b
0459   0691 FD 7D         dec b
0460   0693 0A 6F 06      jmp _while6_cond
0461   0696             _while6_exit:
0462   0696             ;; if (*str == '-' || *str == '+') { 
0463   0696             _if7_cond:
0464   0696 FA 05 00      lea d, [bp + 5] ; $str
0465   0699 2A            mov b, [d]
0466   069A 74            mov d, b
0467   069B 32            mov bl, [d]
0468   069C A7 00         mov bh, 0
0469   069E             ; START RELATIONAL
0470   069E D7            push a
0471   069F 11            mov a, b
0472   06A0 26 2D 00      mov b, $2d
0473   06A3 B0            cmp a, b
0474   06A4 FD 71         seq ; ==
0475   06A6 E4            pop a
0476   06A7             ; END RELATIONAL
0477   06A7             ; START LOGICAL OR
0478   06A7 D7            push a
0479   06A8 11            mov a, b
0480   06A9 FA 05 00      lea d, [bp + 5] ; $str
0481   06AC 2A            mov b, [d]
0482   06AD 74            mov d, b
0483   06AE 32            mov bl, [d]
0484   06AF A7 00         mov bh, 0
0485   06B1             ; START RELATIONAL
0486   06B1 D7            push a
0487   06B2 11            mov a, b
0488   06B3 26 2B 00      mov b, $2b
0489   06B6 B0            cmp a, b
0490   06B7 FD 71         seq ; ==
0491   06B9 E4            pop a
0492   06BA             ; END RELATIONAL
0493   06BA FD A8         sor a, b ; ||
0494   06BC E4            pop a
0495   06BD             ; END LOGICAL OR
0496   06BD C0 00 00      cmp b, 0
0497   06C0 C6 F7 06      je _if7_exit
0498   06C3             _if7_true:
0499   06C3             ;; if (*str == '-') sign = -1; 
0500   06C3             _if8_cond:
0501   06C3 FA 05 00      lea d, [bp + 5] ; $str
0502   06C6 2A            mov b, [d]
0503   06C7 74            mov d, b
0504   06C8 32            mov bl, [d]
0505   06C9 A7 00         mov bh, 0
0506   06CB             ; START RELATIONAL
0507   06CB D7            push a
0508   06CC 11            mov a, b
0509   06CD 26 2D 00      mov b, $2d
0510   06D0 B0            cmp a, b
0511   06D1 FD 71         seq ; ==
0512   06D3 E4            pop a
0513   06D4             ; END RELATIONAL
0514   06D4 C0 00 00      cmp b, 0
0515   06D7 C6 E7 06      je _if8_exit
0516   06DA             _if8_true:
0517   06DA             ;; sign = -1; 
0518   06DA FA FD FF      lea d, [bp + -3] ; $sign
0519   06DD DA            push d
0520   06DE 26 FF FF      mov b, $ffff
0521   06E1 E7            pop d
0522   06E2 FD 43         mov [d], b
0523   06E4 0A E7 06      jmp _if8_exit
0524   06E7             _if8_exit:
0525   06E7             ;; str++; 
0526   06E7 FA 05 00      lea d, [bp + 5] ; $str
0527   06EA 2A            mov b, [d]
0528   06EB FD 77         inc b
0529   06ED FA 05 00      lea d, [bp + 5] ; $str
0530   06F0 FD 43         mov [d], b
0531   06F2 FD 7D         dec b
0532   06F4 0A F7 06      jmp _if7_exit
0533   06F7             _if7_exit:
0534   06F7             ;; while (*str >= '0' && *str <= '9') { 
0535   06F7             _while9_cond:
0536   06F7 FA 05 00      lea d, [bp + 5] ; $str
0537   06FA 2A            mov b, [d]
0538   06FB 74            mov d, b
0539   06FC 32            mov bl, [d]
0540   06FD A7 00         mov bh, 0
0541   06FF             ; START RELATIONAL
0542   06FF D7            push a
0543   0700 11            mov a, b
0544   0701 26 30 00      mov b, $30
0545   0704 B0            cmp a, b
0546   0705 FD 82         sgeu ; >= (unsigned)
0547   0707 E4            pop a
0548   0708             ; END RELATIONAL
0549   0708             ; START LOGICAL AND
0550   0708 D7            push a
0551   0709 11            mov a, b
0552   070A FA 05 00      lea d, [bp + 5] ; $str
0553   070D 2A            mov b, [d]
0554   070E 74            mov d, b
0555   070F 32            mov bl, [d]
0556   0710 A7 00         mov bh, 0
0557   0712             ; START RELATIONAL
0558   0712 D7            push a
0559   0713 11            mov a, b
0560   0714 26 39 00      mov b, $39
0561   0717 B0            cmp a, b
0562   0718 FD 76         sleu ; <= (unsigned)
0563   071A E4            pop a
0564   071B             ; END RELATIONAL
0565   071B FD A7         sand a, b
0566   071D E4            pop a
0567   071E             ; END LOGICAL AND
0568   071E C0 00 00      cmp b, 0
0569   0721 C6 5C 07      je _while9_exit
0570   0724             _while9_block:
0571   0724             ;; result = result * 10 + (*str - '0'); 
0572   0724 FA FF FF      lea d, [bp + -1] ; $result
0573   0727 DA            push d
0574   0728 FA FF FF      lea d, [bp + -1] ; $result
0575   072B 2A            mov b, [d]
0576   072C             ; START FACTORS
0577   072C D7            push a
0578   072D 11            mov a, b
0579   072E 26 0A 00      mov b, $a
0580   0731 AC            mul a, b ; *
0581   0732 11            mov a, b
0582   0733 27            mov b, a
0583   0734 E4            pop a
0584   0735             ; END FACTORS
0585   0735             ; START TERMS
0586   0735 D7            push a
0587   0736 11            mov a, b
0588   0737 FA 05 00      lea d, [bp + 5] ; $str
0589   073A 2A            mov b, [d]
0590   073B 74            mov d, b
0591   073C 32            mov bl, [d]
0592   073D A7 00         mov bh, 0
0593   073F             ; START TERMS
0594   073F D7            push a
0595   0740 11            mov a, b
0596   0741 26 30 00      mov b, $30
0597   0744 60            sub a, b
0598   0745 27            mov b, a
0599   0746 E4            pop a
0600   0747             ; END TERMS
0601   0747 56            add b, a
0602   0748 E4            pop a
0603   0749             ; END TERMS
0604   0749 E7            pop d
0605   074A FD 43         mov [d], b
0606   074C             ;; str++; 
0607   074C FA 05 00      lea d, [bp + 5] ; $str
0608   074F 2A            mov b, [d]
0609   0750 FD 77         inc b
0610   0752 FA 05 00      lea d, [bp + 5] ; $str
0611   0755 FD 43         mov [d], b
0612   0757 FD 7D         dec b
0613   0759 0A F7 06      jmp _while9_cond
0614   075C             _while9_exit:
0615   075C             ;; return sign * result; 
0616   075C FA FD FF      lea d, [bp + -3] ; $sign
0617   075F 2A            mov b, [d]
0618   0760             ; START FACTORS
0619   0760 D7            push a
0620   0761 11            mov a, b
0621   0762 FA FF FF      lea d, [bp + -1] ; $result
0622   0765 2A            mov b, [d]
0623   0766 AC            mul a, b ; *
0624   0767 11            mov a, b
0625   0768 27            mov b, a
0626   0769 E4            pop a
0627   076A             ; END FACTORS
0628   076A F9            leave
0629   076B 09            ret
0630   076C             
0631   076C             rand:
0632   076C F8 00 00      enter 0 ; (push bp; mov bp, sp)
0633   076F             ;; int  sec; 
0634   076F 52 02 00      sub sp, 2 ; sec
0635   0772             
0636   0772             ; --- BEGIN INLINE ASM BLOCK
0637   0772 19 00         mov al, 0
0638   0774 05 01         syscall sys_rtc					
0639   0776 1A            mov al, ah
0640   0777 FA FF FF      lea d, [bp + -1] ; $sec
0641   077A 1E            mov al, [d]
0642   077B 22 00         mov ah, 0
0643   077D             ; --- END INLINE ASM BLOCK
0644   077D             
0645   077D             ;; return sec; 
0646   077D FA FF FF      lea d, [bp + -1] ; $sec
0647   0780 2A            mov b, [d]
0648   0781 F9            leave
0649   0782 09            ret
0650   0783             
0651   0783             alloc:
0652   0783 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0653   0786             ;; heap_top = heap_top + bytes; 
0654   0786 3B C5 25      mov d, _heap_top ; $heap_top
0655   0789 DA            push d
0656   078A 3B C5 25      mov d, _heap_top ; $heap_top
0657   078D 2A            mov b, [d]
0658   078E             ; START TERMS
0659   078E D7            push a
0660   078F 11            mov a, b
0661   0790 FA 05 00      lea d, [bp + 5] ; $bytes
0662   0793 2A            mov b, [d]
0663   0794 56            add b, a
0664   0795 E4            pop a
0665   0796             ; END TERMS
0666   0796 E7            pop d
0667   0797 FD 43         mov [d], b
0668   0799             ;; return heap_top - bytes; 
0669   0799 3B C5 25      mov d, _heap_top ; $heap_top
0670   079C 2A            mov b, [d]
0671   079D             ; START TERMS
0672   079D D7            push a
0673   079E 11            mov a, b
0674   079F FA 05 00      lea d, [bp + 5] ; $bytes
0675   07A2 2A            mov b, [d]
0676   07A3 60            sub a, b
0677   07A4 27            mov b, a
0678   07A5 E4            pop a
0679   07A6             ; END TERMS
0680   07A6 F9            leave
0681   07A7 09            ret
0682   07A8             
0683   07A8             free:
0684   07A8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0685   07AB             ;; return heap_top = heap_top - bytes; 
0686   07AB 3B C5 25      mov d, _heap_top ; $heap_top
0687   07AE DA            push d
0688   07AF 3B C5 25      mov d, _heap_top ; $heap_top
0689   07B2 2A            mov b, [d]
0690   07B3             ; START TERMS
0691   07B3 D7            push a
0692   07B4 11            mov a, b
0693   07B5 FA 05 00      lea d, [bp + 5] ; $bytes
0694   07B8 2A            mov b, [d]
0695   07B9 60            sub a, b
0696   07BA 27            mov b, a
0697   07BB E4            pop a
0698   07BC             ; END TERMS
0699   07BC E7            pop d
0700   07BD FD 43         mov [d], b
0701   07BF F9            leave
0702   07C0 09            ret
0703   07C1             
0704   07C1             fopen:
0705   07C1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0706   07C4             ;; FILE *fp; 
0707   07C4 52 02 00      sub sp, 2 ; fp
0708   07C7             ;; fp = alloc(sizeof(int)); 
0709   07C7 FA FF FF      lea d, [bp + -1] ; $fp
0710   07CA DA            push d
0711   07CB 26 02 00      mov b, 2
0712   07CE FD AB         swp b
0713   07D0 D8            push b
0714   07D1 07 83 07      call alloc
0715   07D4 51 02 00      add sp, 2
0716   07D7 E7            pop d
0717   07D8 FD 43         mov [d], b
0718   07DA F9            leave
0719   07DB 09            ret
0720   07DC             
0721   07DC             printf:
0722   07DC F8 00 00      enter 0 ; (push bp; mov bp, sp)
0723   07DF             ;; char *p, *format_p; 
0724   07DF 52 02 00      sub sp, 2 ; p
0725   07E2 52 02 00      sub sp, 2 ; format_p
0726   07E5             ;; format_p = format; 
0727   07E5 FA FD FF      lea d, [bp + -3] ; $format_p
0728   07E8 DA            push d
0729   07E9 FA 05 00      lea d, [bp + 5] ; $format
0730   07EC 2A            mov b, [d]
0731   07ED E7            pop d
0732   07EE FD 43         mov [d], b
0733   07F0             ;; p = &format + 2; 
0734   07F0 FA FF FF      lea d, [bp + -1] ; $p
0735   07F3 DA            push d
0736   07F4 FA 05 00      lea d, [bp + 5] ; $format
0737   07F7 2D            mov b, d
0738   07F8             ; START TERMS
0739   07F8 D7            push a
0740   07F9 11            mov a, b
0741   07FA 26 02 00      mov b, $2
0742   07FD 56            add b, a
0743   07FE E4            pop a
0744   07FF             ; END TERMS
0745   07FF E7            pop d
0746   0800 FD 43         mov [d], b
0747   0802             ;; for(;;){ 
0748   0802             _for10_init:
0749   0802             _for10_cond:
0750   0802             _for10_block:
0751   0802             ;; if(!*format_p) break; 
0752   0802             _if11_cond:
0753   0802 FA FD FF      lea d, [bp + -3] ; $format_p
0754   0805 2A            mov b, [d]
0755   0806 74            mov d, b
0756   0807 32            mov bl, [d]
0757   0808 A7 00         mov bh, 0
0758   080A C0 00 00      cmp b, 0
0759   080D FD 71         seq ; !
0760   080F C0 00 00      cmp b, 0
0761   0812 C6 1B 08      je _if11_else
0762   0815             _if11_true:
0763   0815             ;; break; 
0764   0815 0A 42 0A      jmp _for10_exit ; for break
0765   0818 0A 3F 0A      jmp _if11_exit
0766   081B             _if11_else:
0767   081B             ;; if(*format_p == '%'){ 
0768   081B             _if12_cond:
0769   081B FA FD FF      lea d, [bp + -3] ; $format_p
0770   081E 2A            mov b, [d]
0771   081F 74            mov d, b
0772   0820 32            mov bl, [d]
0773   0821 A7 00         mov bh, 0
0774   0823             ; START RELATIONAL
0775   0823 D7            push a
0776   0824 11            mov a, b
0777   0825 26 25 00      mov b, $25
0778   0828 B0            cmp a, b
0779   0829 FD 71         seq ; ==
0780   082B E4            pop a
0781   082C             ; END RELATIONAL
0782   082C C0 00 00      cmp b, 0
0783   082F C6 23 0A      je _if12_else
0784   0832             _if12_true:
0785   0832             ;; format_p++; 
0786   0832 FA FD FF      lea d, [bp + -3] ; $format_p
0787   0835 2A            mov b, [d]
0788   0836 FD 77         inc b
0789   0838 FA FD FF      lea d, [bp + -3] ; $format_p
0790   083B FD 43         mov [d], b
0791   083D FD 7D         dec b
0792   083F             ;; switch(*format_p){ 
0793   083F             _switch13_expr:
0794   083F FA FD FF      lea d, [bp + -3] ; $format_p
0795   0842 2A            mov b, [d]
0796   0843 74            mov d, b
0797   0844 32            mov bl, [d]
0798   0845 A7 00         mov bh, 0
0799   0847             _switch13_comparisons:
0800   0847 C1 6C         cmp bl, $6c
0801   0849 C6 75 08      je _switch13_case0
0802   084C C1 4C         cmp bl, $4c
0803   084E C6 75 08      je _switch13_case1
0804   0851 C1 64         cmp bl, $64
0805   0853 C6 63 09      je _switch13_case2
0806   0856 C1 69         cmp bl, $69
0807   0858 C6 63 09      je _switch13_case3
0808   085B C1 75         cmp bl, $75
0809   085D C6 87 09      je _switch13_case4
0810   0860 C1 78         cmp bl, $78
0811   0862 C6 AB 09      je _switch13_case5
0812   0865 C1 63         cmp bl, $63
0813   0867 C6 C9 09      je _switch13_case6
0814   086A C1 73         cmp bl, $73
0815   086C C6 E8 09      je _switch13_case7
0816   086F 0A 07 0A      jmp _switch13_default
0817   0872 0A 13 0A      jmp _switch13_exit
0818   0875             _switch13_case0:
0819   0875             _switch13_case1:
0820   0875             ;; format_p++; 
0821   0875 FA FD FF      lea d, [bp + -3] ; $format_p
0822   0878 2A            mov b, [d]
0823   0879 FD 77         inc b
0824   087B FA FD FF      lea d, [bp + -3] ; $format_p
0825   087E FD 43         mov [d], b
0826   0880 FD 7D         dec b
0827   0882             ;; if(*format_p == 'd' || *format_p == 'i') 
0828   0882             _if14_cond:
0829   0882 FA FD FF      lea d, [bp + -3] ; $format_p
0830   0885 2A            mov b, [d]
0831   0886 74            mov d, b
0832   0887 32            mov bl, [d]
0833   0888 A7 00         mov bh, 0
0834   088A             ; START RELATIONAL
0835   088A D7            push a
0836   088B 11            mov a, b
0837   088C 26 64 00      mov b, $64
0838   088F B0            cmp a, b
0839   0890 FD 71         seq ; ==
0840   0892 E4            pop a
0841   0893             ; END RELATIONAL
0842   0893             ; START LOGICAL OR
0843   0893 D7            push a
0844   0894 11            mov a, b
0845   0895 FA FD FF      lea d, [bp + -3] ; $format_p
0846   0898 2A            mov b, [d]
0847   0899 74            mov d, b
0848   089A 32            mov bl, [d]
0849   089B A7 00         mov bh, 0
0850   089D             ; START RELATIONAL
0851   089D D7            push a
0852   089E 11            mov a, b
0853   089F 26 69 00      mov b, $69
0854   08A2 B0            cmp a, b
0855   08A3 FD 71         seq ; ==
0856   08A5 E4            pop a
0857   08A6             ; END RELATIONAL
0858   08A6 FD A8         sor a, b ; ||
0859   08A8 E4            pop a
0860   08A9             ; END LOGICAL OR
0861   08A9 C0 00 00      cmp b, 0
0862   08AC C6 D1 08      je _if14_else
0863   08AF             _if14_true:
0864   08AF             ;; print_signed_long(*(long *)p); 
0865   08AF FA FF FF      lea d, [bp + -1] ; $p
0866   08B2 2A            mov b, [d]
0867   08B3 AB            snex b
0868   08B4 FD 39         mov c, b
0869   08B6 74            mov d, b
0870   08B7 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0871   08BA FD 39         mov c, b ; And place it into C
0872   08BC 2A            mov b, [d] ; Lower Word in B
0873   08BD FD 79         mov g, b
0874   08BF 28            mov b, c
0875   08C0 FD AB         swp b
0876   08C2 D8            push b
0877   08C3 FD 27         mov b, g
0878   08C5 FD AB         swp b
0879   08C7 D8            push b
0880   08C8 07 28 0F      call print_signed_long
0881   08CB 51 04 00      add sp, 4
0882   08CE 0A 4E 09      jmp _if14_exit
0883   08D1             _if14_else:
0884   08D1             ;; if(*format_p == 'u') 
0885   08D1             _if15_cond:
0886   08D1 FA FD FF      lea d, [bp + -3] ; $format_p
0887   08D4 2A            mov b, [d]
0888   08D5 74            mov d, b
0889   08D6 32            mov bl, [d]
0890   08D7 A7 00         mov bh, 0
0891   08D9             ; START RELATIONAL
0892   08D9 D7            push a
0893   08DA 11            mov a, b
0894   08DB 26 75 00      mov b, $75
0895   08DE B0            cmp a, b
0896   08DF FD 71         seq ; ==
0897   08E1 E4            pop a
0898   08E2             ; END RELATIONAL
0899   08E2 C0 00 00      cmp b, 0
0900   08E5 C6 0C 09      je _if15_else
0901   08E8             _if15_true:
0902   08E8             ;; print_unsigned_long(*(unsigned long *)p); 
0903   08E8 FA FF FF      lea d, [bp + -1] ; $p
0904   08EB 2A            mov b, [d]
0905   08EC A7 00         mov bh, 0
0906   08EE 38 00 00      mov c, 0
0907   08F1 74            mov d, b
0908   08F2 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0909   08F5 FD 39         mov c, b ; And place it into C
0910   08F7 2A            mov b, [d] ; Lower Word in B
0911   08F8 FD 79         mov g, b
0912   08FA 28            mov b, c
0913   08FB FD AB         swp b
0914   08FD D8            push b
0915   08FE FD 27         mov b, g
0916   0900 FD AB         swp b
0917   0902 D8            push b
0918   0903 07 68 12      call print_unsigned_long
0919   0906 51 04 00      add sp, 4
0920   0909 0A 4E 09      jmp _if15_exit
0921   090C             _if15_else:
0922   090C             ;; if(*format_p == 'x') 
0923   090C             _if16_cond:
0924   090C FA FD FF      lea d, [bp + -3] ; $format_p
0925   090F 2A            mov b, [d]
0926   0910 74            mov d, b
0927   0911 32            mov bl, [d]
0928   0912 A7 00         mov bh, 0
0929   0914             ; START RELATIONAL
0930   0914 D7            push a
0931   0915 11            mov a, b
0932   0916 26 78 00      mov b, $78
0933   0919 B0            cmp a, b
0934   091A FD 71         seq ; ==
0935   091C E4            pop a
0936   091D             ; END RELATIONAL
0937   091D C0 00 00      cmp b, 0
0938   0920 C6 42 09      je _if16_else
0939   0923             _if16_true:
0940   0923             ;; printx32(*(long int *)p); 
0941   0923 FA FF FF      lea d, [bp + -1] ; $p
0942   0926 2A            mov b, [d]
0943   0927 74            mov d, b
0944   0928 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0945   092B FD 39         mov c, b ; And place it into C
0946   092D 2A            mov b, [d] ; Lower Word in B
0947   092E FD 79         mov g, b
0948   0930 28            mov b, c
0949   0931 FD AB         swp b
0950   0933 D8            push b
0951   0934 FD 27         mov b, g
0952   0936 FD AB         swp b
0953   0938 D8            push b
0954   0939 07 9D 0C      call printx32
0955   093C 51 04 00      add sp, 4
0956   093F 0A 4E 09      jmp _if16_exit
0957   0942             _if16_else:
0958   0942             ;; err("Unexpected format in printf."); 
0959   0942 26 57 24      mov b, _s1 ; "Unexpected format in printf."
0960   0945 FD AB         swp b
0961   0947 D8            push b
0962   0948 07 8B 0C      call err
0963   094B 51 02 00      add sp, 2
0964   094E             _if16_exit:
0965   094E             _if15_exit:
0966   094E             _if14_exit:
0967   094E             ;; p = p + 4; 
0968   094E FA FF FF      lea d, [bp + -1] ; $p
0969   0951 DA            push d
0970   0952 FA FF FF      lea d, [bp + -1] ; $p
0971   0955 2A            mov b, [d]
0972   0956             ; START TERMS
0973   0956 D7            push a
0974   0957 11            mov a, b
0975   0958 26 04 00      mov b, $4
0976   095B 56            add b, a
0977   095C E4            pop a
0978   095D             ; END TERMS
0979   095D E7            pop d
0980   095E FD 43         mov [d], b
0981   0960             ;; break; 
0982   0960 0A 13 0A      jmp _switch13_exit ; case break
0983   0963             _switch13_case2:
0984   0963             _switch13_case3:
0985   0963             ;; print_signed(*(int*)p); 
0986   0963 FA FF FF      lea d, [bp + -1] ; $p
0987   0966 2A            mov b, [d]
0988   0967 74            mov d, b
0989   0968 2A            mov b, [d]
0990   0969 FD AB         swp b
0991   096B D8            push b
0992   096C 07 31 0E      call print_signed
0993   096F 51 02 00      add sp, 2
0994   0972             ;; p = p + 2; 
0995   0972 FA FF FF      lea d, [bp + -1] ; $p
0996   0975 DA            push d
0997   0976 FA FF FF      lea d, [bp + -1] ; $p
0998   0979 2A            mov b, [d]
0999   097A             ; START TERMS
1000   097A D7            push a
1001   097B 11            mov a, b
1002   097C 26 02 00      mov b, $2
1003   097F 56            add b, a
1004   0980 E4            pop a
1005   0981             ; END TERMS
1006   0981 E7            pop d
1007   0982 FD 43         mov [d], b
1008   0984             ;; break; 
1009   0984 0A 13 0A      jmp _switch13_exit ; case break
1010   0987             _switch13_case4:
1011   0987             ;; print_unsigned(*(unsigned int*)p); 
1012   0987 FA FF FF      lea d, [bp + -1] ; $p
1013   098A 2A            mov b, [d]
1014   098B 74            mov d, b
1015   098C 2A            mov b, [d]
1016   098D FD AB         swp b
1017   098F D8            push b
1018   0990 07 63 14      call print_unsigned
1019   0993 51 02 00      add sp, 2
1020   0996             ;; p = p + 2; 
1021   0996 FA FF FF      lea d, [bp + -1] ; $p
1022   0999 DA            push d
1023   099A FA FF FF      lea d, [bp + -1] ; $p
1024   099D 2A            mov b, [d]
1025   099E             ; START TERMS
1026   099E D7            push a
1027   099F 11            mov a, b
1028   09A0 26 02 00      mov b, $2
1029   09A3 56            add b, a
1030   09A4 E4            pop a
1031   09A5             ; END TERMS
1032   09A5 E7            pop d
1033   09A6 FD 43         mov [d], b
1034   09A8             ;; break; 
1035   09A8 0A 13 0A      jmp _switch13_exit ; case break
1036   09AB             _switch13_case5:
1037   09AB             
1038   09AB             ; --- BEGIN INLINE ASM BLOCK
1039   09AB FA FF FF      lea d, [bp + -1] ; $p
1040   09AE FD 2A         mov d, [d]
1041   09B0 2A            mov b, [d]
1042   09B1 07 69 18      call print_u16x
1043   09B4             ; --- END INLINE ASM BLOCK
1044   09B4             
1045   09B4             ;; p = p + 2; 
1046   09B4 FA FF FF      lea d, [bp + -1] ; $p
1047   09B7 DA            push d
1048   09B8 FA FF FF      lea d, [bp + -1] ; $p
1049   09BB 2A            mov b, [d]
1050   09BC             ; START TERMS
1051   09BC D7            push a
1052   09BD 11            mov a, b
1053   09BE 26 02 00      mov b, $2
1054   09C1 56            add b, a
1055   09C2 E4            pop a
1056   09C3             ; END TERMS
1057   09C3 E7            pop d
1058   09C4 FD 43         mov [d], b
1059   09C6             ;; break; 
1060   09C6 0A 13 0A      jmp _switch13_exit ; case break
1061   09C9             _switch13_case6:
1062   09C9             
1063   09C9             ; --- BEGIN INLINE ASM BLOCK
1064   09C9 FA FF FF      lea d, [bp + -1] ; $p
1065   09CC FD 2A         mov d, [d]
1066   09CE 1E            mov al, [d]
1067   09CF 23            mov ah, al
1068   09D0 07 C7 16      call _putchar
1069   09D3             ; --- END INLINE ASM BLOCK
1070   09D3             
1071   09D3             ;; p = p + 2; 
1072   09D3 FA FF FF      lea d, [bp + -1] ; $p
1073   09D6 DA            push d
1074   09D7 FA FF FF      lea d, [bp + -1] ; $p
1075   09DA 2A            mov b, [d]
1076   09DB             ; START TERMS
1077   09DB D7            push a
1078   09DC 11            mov a, b
1079   09DD 26 02 00      mov b, $2
1080   09E0 56            add b, a
1081   09E1 E4            pop a
1082   09E2             ; END TERMS
1083   09E2 E7            pop d
1084   09E3 FD 43         mov [d], b
1085   09E5             ;; break; 
1086   09E5 0A 13 0A      jmp _switch13_exit ; case break
1087   09E8             _switch13_case7:
1088   09E8             
1089   09E8             ; --- BEGIN INLINE ASM BLOCK
1090   09E8 FA FF FF      lea d, [bp + -1] ; $p
1091   09EB FD 2A         mov d, [d]
1092   09ED FD 2A         mov d, [d]
1093   09EF 07 11 18      call _puts
1094   09F2             ; --- END INLINE ASM BLOCK
1095   09F2             
1096   09F2             ;; p = p + 2; 
1097   09F2 FA FF FF      lea d, [bp + -1] ; $p
1098   09F5 DA            push d
1099   09F6 FA FF FF      lea d, [bp + -1] ; $p
1100   09F9 2A            mov b, [d]
1101   09FA             ; START TERMS
1102   09FA D7            push a
1103   09FB 11            mov a, b
1104   09FC 26 02 00      mov b, $2
1105   09FF 56            add b, a
1106   0A00 E4            pop a
1107   0A01             ; END TERMS
1108   0A01 E7            pop d
1109   0A02 FD 43         mov [d], b
1110   0A04             ;; break; 
1111   0A04 0A 13 0A      jmp _switch13_exit ; case break
1112   0A07             _switch13_default:
1113   0A07             ;; print("Error: Unknown argument type.\n"); 
1114   0A07 26 74 24      mov b, _s2 ; "Error: Unknown argument type.\n"
1115   0A0A FD AB         swp b
1116   0A0C D8            push b
1117   0A0D 07 7E 15      call print
1118   0A10 51 02 00      add sp, 2
1119   0A13             _switch13_exit:
1120   0A13             ;; format_p++; 
1121   0A13 FA FD FF      lea d, [bp + -3] ; $format_p
1122   0A16 2A            mov b, [d]
1123   0A17 FD 77         inc b
1124   0A19 FA FD FF      lea d, [bp + -3] ; $format_p
1125   0A1C FD 43         mov [d], b
1126   0A1E FD 7D         dec b
1127   0A20 0A 3F 0A      jmp _if12_exit
1128   0A23             _if12_else:
1129   0A23             ;; putchar(*format_p); 
1130   0A23 FA FD FF      lea d, [bp + -3] ; $format_p
1131   0A26 2A            mov b, [d]
1132   0A27 74            mov d, b
1133   0A28 32            mov bl, [d]
1134   0A29 A7 00         mov bh, 0
1135   0A2B DD            push bl
1136   0A2C 07 36 15      call putchar
1137   0A2F 51 01 00      add sp, 1
1138   0A32             ;; format_p++; 
1139   0A32 FA FD FF      lea d, [bp + -3] ; $format_p
1140   0A35 2A            mov b, [d]
1141   0A36 FD 77         inc b
1142   0A38 FA FD FF      lea d, [bp + -3] ; $format_p
1143   0A3B FD 43         mov [d], b
1144   0A3D FD 7D         dec b
1145   0A3F             _if12_exit:
1146   0A3F             _if11_exit:
1147   0A3F             _for10_update:
1148   0A3F 0A 02 08      jmp _for10_cond
1149   0A42             _for10_exit:
1150   0A42 F9            leave
1151   0A43 09            ret
1152   0A44             
1153   0A44             scanf:
1154   0A44 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1155   0A47             ;; char *p, *format_p; 
1156   0A47 52 02 00      sub sp, 2 ; p
1157   0A4A 52 02 00      sub sp, 2 ; format_p
1158   0A4D             ;; char c; 
1159   0A4D 52 01 00      sub sp, 1 ; c
1160   0A50             ;; int i; 
1161   0A50 52 02 00      sub sp, 2 ; i
1162   0A53             ;; char input_string[  512                    ]; 
1163   0A53 52 00 02      sub sp, 512 ; input_string
1164   0A56             ;; format_p = format; 
1165   0A56 FA FD FF      lea d, [bp + -3] ; $format_p
1166   0A59 DA            push d
1167   0A5A FA 05 00      lea d, [bp + 5] ; $format
1168   0A5D 2A            mov b, [d]
1169   0A5E E7            pop d
1170   0A5F FD 43         mov [d], b
1171   0A61             ;; p = &format + 2; 
1172   0A61 FA FF FF      lea d, [bp + -1] ; $p
1173   0A64 DA            push d
1174   0A65 FA 05 00      lea d, [bp + 5] ; $format
1175   0A68 2D            mov b, d
1176   0A69             ; START TERMS
1177   0A69 D7            push a
1178   0A6A 11            mov a, b
1179   0A6B 26 02 00      mov b, $2
1180   0A6E 56            add b, a
1181   0A6F E4            pop a
1182   0A70             ; END TERMS
1183   0A70 E7            pop d
1184   0A71 FD 43         mov [d], b
1185   0A73             ;; for(;;){ 
1186   0A73             _for17_init:
1187   0A73             _for17_cond:
1188   0A73             _for17_block:
1189   0A73             ;; if(!*format_p) break; 
1190   0A73             _if18_cond:
1191   0A73 FA FD FF      lea d, [bp + -3] ; $format_p
1192   0A76 2A            mov b, [d]
1193   0A77 74            mov d, b
1194   0A78 32            mov bl, [d]
1195   0A79 A7 00         mov bh, 0
1196   0A7B C0 00 00      cmp b, 0
1197   0A7E FD 71         seq ; !
1198   0A80 C0 00 00      cmp b, 0
1199   0A83 C6 8C 0A      je _if18_else
1200   0A86             _if18_true:
1201   0A86             ;; break; 
1202   0A86 0A 89 0C      jmp _for17_exit ; for break
1203   0A89 0A 86 0C      jmp _if18_exit
1204   0A8C             _if18_else:
1205   0A8C             ;; if(*format_p == '%'){ 
1206   0A8C             _if19_cond:
1207   0A8C FA FD FF      lea d, [bp + -3] ; $format_p
1208   0A8F 2A            mov b, [d]
1209   0A90 74            mov d, b
1210   0A91 32            mov bl, [d]
1211   0A92 A7 00         mov bh, 0
1212   0A94             ; START RELATIONAL
1213   0A94 D7            push a
1214   0A95 11            mov a, b
1215   0A96 26 25 00      mov b, $25
1216   0A99 B0            cmp a, b
1217   0A9A FD 71         seq ; ==
1218   0A9C E4            pop a
1219   0A9D             ; END RELATIONAL
1220   0A9D C0 00 00      cmp b, 0
1221   0AA0 C6 6A 0C      je _if19_else
1222   0AA3             _if19_true:
1223   0AA3             ;; format_p++; 
1224   0AA3 FA FD FF      lea d, [bp + -3] ; $format_p
1225   0AA6 2A            mov b, [d]
1226   0AA7 FD 77         inc b
1227   0AA9 FA FD FF      lea d, [bp + -3] ; $format_p
1228   0AAC FD 43         mov [d], b
1229   0AAE FD 7D         dec b
1230   0AB0             ;; switch(*format_p){ 
1231   0AB0             _switch20_expr:
1232   0AB0 FA FD FF      lea d, [bp + -3] ; $format_p
1233   0AB3 2A            mov b, [d]
1234   0AB4 74            mov d, b
1235   0AB5 32            mov bl, [d]
1236   0AB6 A7 00         mov bh, 0
1237   0AB8             _switch20_comparisons:
1238   0AB8 C1 6C         cmp bl, $6c
1239   0ABA C6 E6 0A      je _switch20_case0
1240   0ABD C1 4C         cmp bl, $4c
1241   0ABF C6 E6 0A      je _switch20_case1
1242   0AC2 C1 64         cmp bl, $64
1243   0AC4 C6 78 0B      je _switch20_case2
1244   0AC7 C1 69         cmp bl, $69
1245   0AC9 C6 78 0B      je _switch20_case3
1246   0ACC C1 75         cmp bl, $75
1247   0ACE C6 A5 0B      je _switch20_case4
1248   0AD1 C1 78         cmp bl, $78
1249   0AD3 C6 D2 0B      je _switch20_case5
1250   0AD6 C1 63         cmp bl, $63
1251   0AD8 C6 E7 0B      je _switch20_case6
1252   0ADB C1 73         cmp bl, $73
1253   0ADD C6 16 0C      je _switch20_case7
1254   0AE0 0A 4E 0C      jmp _switch20_default
1255   0AE3 0A 5A 0C      jmp _switch20_exit
1256   0AE6             _switch20_case0:
1257   0AE6             _switch20_case1:
1258   0AE6             ;; format_p++; 
1259   0AE6 FA FD FF      lea d, [bp + -3] ; $format_p
1260   0AE9 2A            mov b, [d]
1261   0AEA FD 77         inc b
1262   0AEC FA FD FF      lea d, [bp + -3] ; $format_p
1263   0AEF FD 43         mov [d], b
1264   0AF1 FD 7D         dec b
1265   0AF3             ;; if(*format_p == 'd' || *format_p == 'i'); 
1266   0AF3             _if21_cond:
1267   0AF3 FA FD FF      lea d, [bp + -3] ; $format_p
1268   0AF6 2A            mov b, [d]
1269   0AF7 74            mov d, b
1270   0AF8 32            mov bl, [d]
1271   0AF9 A7 00         mov bh, 0
1272   0AFB             ; START RELATIONAL
1273   0AFB D7            push a
1274   0AFC 11            mov a, b
1275   0AFD 26 64 00      mov b, $64
1276   0B00 B0            cmp a, b
1277   0B01 FD 71         seq ; ==
1278   0B03 E4            pop a
1279   0B04             ; END RELATIONAL
1280   0B04             ; START LOGICAL OR
1281   0B04 D7            push a
1282   0B05 11            mov a, b
1283   0B06 FA FD FF      lea d, [bp + -3] ; $format_p
1284   0B09 2A            mov b, [d]
1285   0B0A 74            mov d, b
1286   0B0B 32            mov bl, [d]
1287   0B0C A7 00         mov bh, 0
1288   0B0E             ; START RELATIONAL
1289   0B0E D7            push a
1290   0B0F 11            mov a, b
1291   0B10 26 69 00      mov b, $69
1292   0B13 B0            cmp a, b
1293   0B14 FD 71         seq ; ==
1294   0B16 E4            pop a
1295   0B17             ; END RELATIONAL
1296   0B17 FD A8         sor a, b ; ||
1297   0B19 E4            pop a
1298   0B1A             ; END LOGICAL OR
1299   0B1A C0 00 00      cmp b, 0
1300   0B1D C6 23 0B      je _if21_else
1301   0B20             _if21_true:
1302   0B20             ;; ; 
1303   0B20 0A 63 0B      jmp _if21_exit
1304   0B23             _if21_else:
1305   0B23             ;; if(*format_p == 'u'); 
1306   0B23             _if22_cond:
1307   0B23 FA FD FF      lea d, [bp + -3] ; $format_p
1308   0B26 2A            mov b, [d]
1309   0B27 74            mov d, b
1310   0B28 32            mov bl, [d]
1311   0B29 A7 00         mov bh, 0
1312   0B2B             ; START RELATIONAL
1313   0B2B D7            push a
1314   0B2C 11            mov a, b
1315   0B2D 26 75 00      mov b, $75
1316   0B30 B0            cmp a, b
1317   0B31 FD 71         seq ; ==
1318   0B33 E4            pop a
1319   0B34             ; END RELATIONAL
1320   0B34 C0 00 00      cmp b, 0
1321   0B37 C6 3D 0B      je _if22_else
1322   0B3A             _if22_true:
1323   0B3A             ;; ; 
1324   0B3A 0A 63 0B      jmp _if22_exit
1325   0B3D             _if22_else:
1326   0B3D             ;; if(*format_p == 'x'); 
1327   0B3D             _if23_cond:
1328   0B3D FA FD FF      lea d, [bp + -3] ; $format_p
1329   0B40 2A            mov b, [d]
1330   0B41 74            mov d, b
1331   0B42 32            mov bl, [d]
1332   0B43 A7 00         mov bh, 0
1333   0B45             ; START RELATIONAL
1334   0B45 D7            push a
1335   0B46 11            mov a, b
1336   0B47 26 78 00      mov b, $78
1337   0B4A B0            cmp a, b
1338   0B4B FD 71         seq ; ==
1339   0B4D E4            pop a
1340   0B4E             ; END RELATIONAL
1341   0B4E C0 00 00      cmp b, 0
1342   0B51 C6 57 0B      je _if23_else
1343   0B54             _if23_true:
1344   0B54             ;; ; 
1345   0B54 0A 63 0B      jmp _if23_exit
1346   0B57             _if23_else:
1347   0B57             ;; err("Unexpected format in printf."); 
1348   0B57 26 57 24      mov b, _s1 ; "Unexpected format in printf."
1349   0B5A FD AB         swp b
1350   0B5C D8            push b
1351   0B5D 07 8B 0C      call err
1352   0B60 51 02 00      add sp, 2
1353   0B63             _if23_exit:
1354   0B63             _if22_exit:
1355   0B63             _if21_exit:
1356   0B63             ;; p = p + 4; 
1357   0B63 FA FF FF      lea d, [bp + -1] ; $p
1358   0B66 DA            push d
1359   0B67 FA FF FF      lea d, [bp + -1] ; $p
1360   0B6A 2A            mov b, [d]
1361   0B6B             ; START TERMS
1362   0B6B D7            push a
1363   0B6C 11            mov a, b
1364   0B6D 26 04 00      mov b, $4
1365   0B70 56            add b, a
1366   0B71 E4            pop a
1367   0B72             ; END TERMS
1368   0B72 E7            pop d
1369   0B73 FD 43         mov [d], b
1370   0B75             ;; break; 
1371   0B75 0A 5A 0C      jmp _switch20_exit ; case break
1372   0B78             _switch20_case2:
1373   0B78             _switch20_case3:
1374   0B78             ;; i = scann(); 
1375   0B78 FA FA FF      lea d, [bp + -6] ; $i
1376   0B7B DA            push d
1377   0B7C 07 59 15      call scann
1378   0B7F E7            pop d
1379   0B80 FD 43         mov [d], b
1380   0B82             ;; **(int **)p = i; 
1381   0B82 FA FF FF      lea d, [bp + -1] ; $p
1382   0B85 2A            mov b, [d]
1383   0B86 74            mov d, b
1384   0B87 2A            mov b, [d]
1385   0B88 D8            push b
1386   0B89 FA FA FF      lea d, [bp + -6] ; $i
1387   0B8C 2A            mov b, [d]
1388   0B8D E7            pop d
1389   0B8E FD 43         mov [d], b
1390   0B90             ;; p = p + 2; 
1391   0B90 FA FF FF      lea d, [bp + -1] ; $p
1392   0B93 DA            push d
1393   0B94 FA FF FF      lea d, [bp + -1] ; $p
1394   0B97 2A            mov b, [d]
1395   0B98             ; START TERMS
1396   0B98 D7            push a
1397   0B99 11            mov a, b
1398   0B9A 26 02 00      mov b, $2
1399   0B9D 56            add b, a
1400   0B9E E4            pop a
1401   0B9F             ; END TERMS
1402   0B9F E7            pop d
1403   0BA0 FD 43         mov [d], b
1404   0BA2             ;; break; 
1405   0BA2 0A 5A 0C      jmp _switch20_exit ; case break
1406   0BA5             _switch20_case4:
1407   0BA5             ;; i = scann(); 
1408   0BA5 FA FA FF      lea d, [bp + -6] ; $i
1409   0BA8 DA            push d
1410   0BA9 07 59 15      call scann
1411   0BAC E7            pop d
1412   0BAD FD 43         mov [d], b
1413   0BAF             ;; **(int **)p = i; 
1414   0BAF FA FF FF      lea d, [bp + -1] ; $p
1415   0BB2 2A            mov b, [d]
1416   0BB3 74            mov d, b
1417   0BB4 2A            mov b, [d]
1418   0BB5 D8            push b
1419   0BB6 FA FA FF      lea d, [bp + -6] ; $i
1420   0BB9 2A            mov b, [d]
1421   0BBA E7            pop d
1422   0BBB FD 43         mov [d], b
1423   0BBD             ;; p = p + 2; 
1424   0BBD FA FF FF      lea d, [bp + -1] ; $p
1425   0BC0 DA            push d
1426   0BC1 FA FF FF      lea d, [bp + -1] ; $p
1427   0BC4 2A            mov b, [d]
1428   0BC5             ; START TERMS
1429   0BC5 D7            push a
1430   0BC6 11            mov a, b
1431   0BC7 26 02 00      mov b, $2
1432   0BCA 56            add b, a
1433   0BCB E4            pop a
1434   0BCC             ; END TERMS
1435   0BCC E7            pop d
1436   0BCD FD 43         mov [d], b
1437   0BCF             ;; break; 
1438   0BCF 0A 5A 0C      jmp _switch20_exit ; case break
1439   0BD2             _switch20_case5:
1440   0BD2             ;; p = p + 2; 
1441   0BD2 FA FF FF      lea d, [bp + -1] ; $p
1442   0BD5 DA            push d
1443   0BD6 FA FF FF      lea d, [bp + -1] ; $p
1444   0BD9 2A            mov b, [d]
1445   0BDA             ; START TERMS
1446   0BDA D7            push a
1447   0BDB 11            mov a, b
1448   0BDC 26 02 00      mov b, $2
1449   0BDF 56            add b, a
1450   0BE0 E4            pop a
1451   0BE1             ; END TERMS
1452   0BE1 E7            pop d
1453   0BE2 FD 43         mov [d], b
1454   0BE4             ;; break; 
1455   0BE4 0A 5A 0C      jmp _switch20_exit ; case break
1456   0BE7             _switch20_case6:
1457   0BE7             ;; c = getchar(); 
1458   0BE7 FA FC FF      lea d, [bp + -4] ; $c
1459   0BEA DA            push d
1460   0BEB 07 43 15      call getchar
1461   0BEE E7            pop d
1462   0BEF FD 3E         mov [d], bl
1463   0BF1             ;; **(char **)p = c; 
1464   0BF1 FA FF FF      lea d, [bp + -1] ; $p
1465   0BF4 2A            mov b, [d]
1466   0BF5 74            mov d, b
1467   0BF6 2A            mov b, [d]
1468   0BF7 D8            push b
1469   0BF8 FA FC FF      lea d, [bp + -4] ; $c
1470   0BFB 32            mov bl, [d]
1471   0BFC A7 00         mov bh, 0
1472   0BFE E7            pop d
1473   0BFF FD 43         mov [d], b
1474   0C01             ;; p = p + 2; 
1475   0C01 FA FF FF      lea d, [bp + -1] ; $p
1476   0C04 DA            push d
1477   0C05 FA FF FF      lea d, [bp + -1] ; $p
1478   0C08 2A            mov b, [d]
1479   0C09             ; START TERMS
1480   0C09 D7            push a
1481   0C0A 11            mov a, b
1482   0C0B 26 02 00      mov b, $2
1483   0C0E 56            add b, a
1484   0C0F E4            pop a
1485   0C10             ; END TERMS
1486   0C10 E7            pop d
1487   0C11 FD 43         mov [d], b
1488   0C13             ;; break; 
1489   0C13 0A 5A 0C      jmp _switch20_exit ; case break
1490   0C16             _switch20_case7:
1491   0C16             ;; gets(input_string); 
1492   0C16 FA FA FD      lea d, [bp + -518] ; $input_string
1493   0C19 2D            mov b, d
1494   0C1A FD AB         swp b
1495   0C1C D8            push b
1496   0C1D 07 17 0E      call gets
1497   0C20 51 02 00      add sp, 2
1498   0C23             ;; strcpy(*(char **)p, input_string); 
1499   0C23 FA FA FD      lea d, [bp + -518] ; $input_string
1500   0C26 2D            mov b, d
1501   0C27 FD AB         swp b
1502   0C29 D8            push b
1503   0C2A FA FF FF      lea d, [bp + -1] ; $p
1504   0C2D 2A            mov b, [d]
1505   0C2E 74            mov d, b
1506   0C2F 2A            mov b, [d]
1507   0C30 FD AB         swp b
1508   0C32 D8            push b
1509   0C33 07 38 04      call strcpy
1510   0C36 51 04 00      add sp, 4
1511   0C39             ;; p = p + 2; 
1512   0C39 FA FF FF      lea d, [bp + -1] ; $p
1513   0C3C DA            push d
1514   0C3D FA FF FF      lea d, [bp + -1] ; $p
1515   0C40 2A            mov b, [d]
1516   0C41             ; START TERMS
1517   0C41 D7            push a
1518   0C42 11            mov a, b
1519   0C43 26 02 00      mov b, $2
1520   0C46 56            add b, a
1521   0C47 E4            pop a
1522   0C48             ; END TERMS
1523   0C48 E7            pop d
1524   0C49 FD 43         mov [d], b
1525   0C4B             ;; break; 
1526   0C4B 0A 5A 0C      jmp _switch20_exit ; case break
1527   0C4E             _switch20_default:
1528   0C4E             ;; print("Error: Unknown argument type.\n"); 
1529   0C4E 26 74 24      mov b, _s2 ; "Error: Unknown argument type.\n"
1530   0C51 FD AB         swp b
1531   0C53 D8            push b
1532   0C54 07 7E 15      call print
1533   0C57 51 02 00      add sp, 2
1534   0C5A             _switch20_exit:
1535   0C5A             ;; format_p++; 
1536   0C5A FA FD FF      lea d, [bp + -3] ; $format_p
1537   0C5D 2A            mov b, [d]
1538   0C5E FD 77         inc b
1539   0C60 FA FD FF      lea d, [bp + -3] ; $format_p
1540   0C63 FD 43         mov [d], b
1541   0C65 FD 7D         dec b
1542   0C67 0A 86 0C      jmp _if19_exit
1543   0C6A             _if19_else:
1544   0C6A             ;; putchar(*format_p); 
1545   0C6A FA FD FF      lea d, [bp + -3] ; $format_p
1546   0C6D 2A            mov b, [d]
1547   0C6E 74            mov d, b
1548   0C6F 32            mov bl, [d]
1549   0C70 A7 00         mov bh, 0
1550   0C72 DD            push bl
1551   0C73 07 36 15      call putchar
1552   0C76 51 01 00      add sp, 1
1553   0C79             ;; format_p++; 
1554   0C79 FA FD FF      lea d, [bp + -3] ; $format_p
1555   0C7C 2A            mov b, [d]
1556   0C7D FD 77         inc b
1557   0C7F FA FD FF      lea d, [bp + -3] ; $format_p
1558   0C82 FD 43         mov [d], b
1559   0C84 FD 7D         dec b
1560   0C86             _if19_exit:
1561   0C86             _if18_exit:
1562   0C86             _for17_update:
1563   0C86 0A 73 0A      jmp _for17_cond
1564   0C89             _for17_exit:
1565   0C89 F9            leave
1566   0C8A 09            ret
1567   0C8B             
1568   0C8B             err:
1569   0C8B F8 00 00      enter 0 ; (push bp; mov bp, sp)
1570   0C8E             ;; print(e); 
1571   0C8E FA 05 00      lea d, [bp + 5] ; $e
1572   0C91 2A            mov b, [d]
1573   0C92 FD AB         swp b
1574   0C94 D8            push b
1575   0C95 07 7E 15      call print
1576   0C98 51 02 00      add sp, 2
1577   0C9B F9            leave
1578   0C9C 09            ret
1579   0C9D             
1580   0C9D             printx32:
1581   0C9D F8 00 00      enter 0 ; (push bp; mov bp, sp)
1582   0CA0             
1583   0CA0             ; --- BEGIN INLINE ASM BLOCK
1584   0CA0 FA 05 00      lea d, [bp + 5] ; $hex
1585   0CA3 2B 02 00      mov b, [d+2]
1586   0CA6 07 69 18      call print_u16x
1587   0CA9 2A            mov b, [d]
1588   0CAA 07 69 18      call print_u16x
1589   0CAD             ; --- END INLINE ASM BLOCK
1590   0CAD             
1591   0CAD F9            leave
1592   0CAE 09            ret
1593   0CAF             
1594   0CAF             printx16:
1595   0CAF F8 00 00      enter 0 ; (push bp; mov bp, sp)
1596   0CB2             
1597   0CB2             ; --- BEGIN INLINE ASM BLOCK
1598   0CB2 FA 05 00      lea d, [bp + 5] ; $hex
1599   0CB5 2A            mov b, [d]
1600   0CB6 07 69 18      call print_u16x
1601   0CB9             ; --- END INLINE ASM BLOCK
1602   0CB9             
1603   0CB9 F9            leave
1604   0CBA 09            ret
1605   0CBB             
1606   0CBB             printx8:
1607   0CBB F8 00 00      enter 0 ; (push bp; mov bp, sp)
1608   0CBE             
1609   0CBE             ; --- BEGIN INLINE ASM BLOCK
1610   0CBE FA 05 00      lea d, [bp + 5] ; $hex
1611   0CC1 32            mov bl, [d]
1612   0CC2 07 AD 18      call print_u8x
1613   0CC5             ; --- END INLINE ASM BLOCK
1614   0CC5             
1615   0CC5 F9            leave
1616   0CC6 09            ret
1617   0CC7             
1618   0CC7             hex_str_to_int:
1619   0CC7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1620   0CCA             ;; int value = 0; 
1621   0CCA 52 02 00      sub sp, 2 ; value
1622   0CCD             ; --- START LOCAL VAR INITIALIZATION
1623   0CCD FA FF FF      lea d, [bp + -1] ; $value
1624   0CD0 DA            push d
1625   0CD1 26 00 00      mov b, $0
1626   0CD4 E7            pop d
1627   0CD5 FD 43         mov [d], b
1628   0CD7             ; --- END LOCAL VAR INITIALIZATION
1629   0CD7             ;; int i; 
1630   0CD7 52 02 00      sub sp, 2 ; i
1631   0CDA             ;; char hex_char; 
1632   0CDA 52 01 00      sub sp, 1 ; hex_char
1633   0CDD             ;; int len; 
1634   0CDD 52 02 00      sub sp, 2 ; len
1635   0CE0             ;; len = strlen(hex_string); 
1636   0CE0 FA FA FF      lea d, [bp + -6] ; $len
1637   0CE3 DA            push d
1638   0CE4 FA 05 00      lea d, [bp + 5] ; $hex_string
1639   0CE7 2A            mov b, [d]
1640   0CE8 FD AB         swp b
1641   0CEA D8            push b
1642   0CEB 07 B2 05      call strlen
1643   0CEE 51 02 00      add sp, 2
1644   0CF1 E7            pop d
1645   0CF2 FD 43         mov [d], b
1646   0CF4             ;; for (i = 0; i < len; i++) { 
1647   0CF4             _for24_init:
1648   0CF4 FA FD FF      lea d, [bp + -3] ; $i
1649   0CF7 DA            push d
1650   0CF8 26 00 00      mov b, $0
1651   0CFB E7            pop d
1652   0CFC FD 43         mov [d], b
1653   0CFE             _for24_cond:
1654   0CFE FA FD FF      lea d, [bp + -3] ; $i
1655   0D01 2A            mov b, [d]
1656   0D02             ; START RELATIONAL
1657   0D02 D7            push a
1658   0D03 11            mov a, b
1659   0D04 FA FA FF      lea d, [bp + -6] ; $len
1660   0D07 2A            mov b, [d]
1661   0D08 B0            cmp a, b
1662   0D09 FD 73         slt ; < (signed)
1663   0D0B E4            pop a
1664   0D0C             ; END RELATIONAL
1665   0D0C C0 00 00      cmp b, 0
1666   0D0F C6 11 0E      je _for24_exit
1667   0D12             _for24_block:
1668   0D12             ;; hex_char = hex_string[i]; 
1669   0D12 FA FC FF      lea d, [bp + -4] ; $hex_char
1670   0D15 DA            push d
1671   0D16 FA 05 00      lea d, [bp + 5] ; $hex_string
1672   0D19 FD 2A         mov d, [d]
1673   0D1B D7            push a
1674   0D1C DA            push d
1675   0D1D FA FD FF      lea d, [bp + -3] ; $i
1676   0D20 2A            mov b, [d]
1677   0D21 E7            pop d
1678   0D22 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
1679   0D26 E4            pop a
1680   0D27 32            mov bl, [d]
1681   0D28 A7 00         mov bh, 0
1682   0D2A E7            pop d
1683   0D2B FD 3E         mov [d], bl
1684   0D2D             ;; if (hex_char >= 'a' && hex_char <= 'f')  
1685   0D2D             _if25_cond:
1686   0D2D FA FC FF      lea d, [bp + -4] ; $hex_char
1687   0D30 32            mov bl, [d]
1688   0D31 A7 00         mov bh, 0
1689   0D33             ; START RELATIONAL
1690   0D33 D7            push a
1691   0D34 11            mov a, b
1692   0D35 26 61 00      mov b, $61
1693   0D38 B0            cmp a, b
1694   0D39 FD 80         sge ; >=
1695   0D3B E4            pop a
1696   0D3C             ; END RELATIONAL
1697   0D3C             ; START LOGICAL AND
1698   0D3C D7            push a
1699   0D3D 11            mov a, b
1700   0D3E FA FC FF      lea d, [bp + -4] ; $hex_char
1701   0D41 32            mov bl, [d]
1702   0D42 A7 00         mov bh, 0
1703   0D44             ; START RELATIONAL
1704   0D44 D7            push a
1705   0D45 11            mov a, b
1706   0D46 26 66 00      mov b, $66
1707   0D49 B0            cmp a, b
1708   0D4A FD 74         sle ; <= (signed)
1709   0D4C E4            pop a
1710   0D4D             ; END RELATIONAL
1711   0D4D FD A7         sand a, b
1712   0D4F E4            pop a
1713   0D50             ; END LOGICAL AND
1714   0D50 C0 00 00      cmp b, 0
1715   0D53 C6 84 0D      je _if25_else
1716   0D56             _if25_true:
1717   0D56             ;; value = (value * 16) + (hex_char - 'a' + 10); 
1718   0D56 FA FF FF      lea d, [bp + -1] ; $value
1719   0D59 DA            push d
1720   0D5A FA FF FF      lea d, [bp + -1] ; $value
1721   0D5D 2A            mov b, [d]
1722   0D5E             ; START FACTORS
1723   0D5E D7            push a
1724   0D5F 11            mov a, b
1725   0D60 26 10 00      mov b, $10
1726   0D63 AC            mul a, b ; *
1727   0D64 11            mov a, b
1728   0D65 27            mov b, a
1729   0D66 E4            pop a
1730   0D67             ; END FACTORS
1731   0D67             ; START TERMS
1732   0D67 D7            push a
1733   0D68 11            mov a, b
1734   0D69 FA FC FF      lea d, [bp + -4] ; $hex_char
1735   0D6C 32            mov bl, [d]
1736   0D6D A7 00         mov bh, 0
1737   0D6F             ; START TERMS
1738   0D6F D7            push a
1739   0D70 11            mov a, b
1740   0D71 26 61 00      mov b, $61
1741   0D74 60            sub a, b
1742   0D75 27            mov b, a
1743   0D76 11            mov a, b
1744   0D77 26 0A 00      mov b, $a
1745   0D7A 56            add b, a
1746   0D7B E4            pop a
1747   0D7C             ; END TERMS
1748   0D7C 56            add b, a
1749   0D7D E4            pop a
1750   0D7E             ; END TERMS
1751   0D7E E7            pop d
1752   0D7F FD 43         mov [d], b
1753   0D81 0A 01 0E      jmp _if25_exit
1754   0D84             _if25_else:
1755   0D84             ;; if (hex_char >= 'A' && hex_char <= 'F')  
1756   0D84             _if26_cond:
1757   0D84 FA FC FF      lea d, [bp + -4] ; $hex_char
1758   0D87 32            mov bl, [d]
1759   0D88 A7 00         mov bh, 0
1760   0D8A             ; START RELATIONAL
1761   0D8A D7            push a
1762   0D8B 11            mov a, b
1763   0D8C 26 41 00      mov b, $41
1764   0D8F B0            cmp a, b
1765   0D90 FD 80         sge ; >=
1766   0D92 E4            pop a
1767   0D93             ; END RELATIONAL
1768   0D93             ; START LOGICAL AND
1769   0D93 D7            push a
1770   0D94 11            mov a, b
1771   0D95 FA FC FF      lea d, [bp + -4] ; $hex_char
1772   0D98 32            mov bl, [d]
1773   0D99 A7 00         mov bh, 0
1774   0D9B             ; START RELATIONAL
1775   0D9B D7            push a
1776   0D9C 11            mov a, b
1777   0D9D 26 46 00      mov b, $46
1778   0DA0 B0            cmp a, b
1779   0DA1 FD 74         sle ; <= (signed)
1780   0DA3 E4            pop a
1781   0DA4             ; END RELATIONAL
1782   0DA4 FD A7         sand a, b
1783   0DA6 E4            pop a
1784   0DA7             ; END LOGICAL AND
1785   0DA7 C0 00 00      cmp b, 0
1786   0DAA C6 DB 0D      je _if26_else
1787   0DAD             _if26_true:
1788   0DAD             ;; value = (value * 16) + (hex_char - 'A' + 10); 
1789   0DAD FA FF FF      lea d, [bp + -1] ; $value
1790   0DB0 DA            push d
1791   0DB1 FA FF FF      lea d, [bp + -1] ; $value
1792   0DB4 2A            mov b, [d]
1793   0DB5             ; START FACTORS
1794   0DB5 D7            push a
1795   0DB6 11            mov a, b
1796   0DB7 26 10 00      mov b, $10
1797   0DBA AC            mul a, b ; *
1798   0DBB 11            mov a, b
1799   0DBC 27            mov b, a
1800   0DBD E4            pop a
1801   0DBE             ; END FACTORS
1802   0DBE             ; START TERMS
1803   0DBE D7            push a
1804   0DBF 11            mov a, b
1805   0DC0 FA FC FF      lea d, [bp + -4] ; $hex_char
1806   0DC3 32            mov bl, [d]
1807   0DC4 A7 00         mov bh, 0
1808   0DC6             ; START TERMS
1809   0DC6 D7            push a
1810   0DC7 11            mov a, b
1811   0DC8 26 41 00      mov b, $41
1812   0DCB 60            sub a, b
1813   0DCC 27            mov b, a
1814   0DCD 11            mov a, b
1815   0DCE 26 0A 00      mov b, $a
1816   0DD1 56            add b, a
1817   0DD2 E4            pop a
1818   0DD3             ; END TERMS
1819   0DD3 56            add b, a
1820   0DD4 E4            pop a
1821   0DD5             ; END TERMS
1822   0DD5 E7            pop d
1823   0DD6 FD 43         mov [d], b
1824   0DD8 0A 01 0E      jmp _if26_exit
1825   0DDB             _if26_else:
1826   0DDB             ;; value = (value * 16) + (hex_char - '0'); 
1827   0DDB FA FF FF      lea d, [bp + -1] ; $value
1828   0DDE DA            push d
1829   0DDF FA FF FF      lea d, [bp + -1] ; $value
1830   0DE2 2A            mov b, [d]
1831   0DE3             ; START FACTORS
1832   0DE3 D7            push a
1833   0DE4 11            mov a, b
1834   0DE5 26 10 00      mov b, $10
1835   0DE8 AC            mul a, b ; *
1836   0DE9 11            mov a, b
1837   0DEA 27            mov b, a
1838   0DEB E4            pop a
1839   0DEC             ; END FACTORS
1840   0DEC             ; START TERMS
1841   0DEC D7            push a
1842   0DED 11            mov a, b
1843   0DEE FA FC FF      lea d, [bp + -4] ; $hex_char
1844   0DF1 32            mov bl, [d]
1845   0DF2 A7 00         mov bh, 0
1846   0DF4             ; START TERMS
1847   0DF4 D7            push a
1848   0DF5 11            mov a, b
1849   0DF6 26 30 00      mov b, $30
1850   0DF9 60            sub a, b
1851   0DFA 27            mov b, a
1852   0DFB E4            pop a
1853   0DFC             ; END TERMS
1854   0DFC 56            add b, a
1855   0DFD E4            pop a
1856   0DFE             ; END TERMS
1857   0DFE E7            pop d
1858   0DFF FD 43         mov [d], b
1859   0E01             _if26_exit:
1860   0E01             _if25_exit:
1861   0E01             _for24_update:
1862   0E01 FA FD FF      lea d, [bp + -3] ; $i
1863   0E04 2A            mov b, [d]
1864   0E05 FD 77         inc b
1865   0E07 FA FD FF      lea d, [bp + -3] ; $i
1866   0E0A FD 43         mov [d], b
1867   0E0C FD 7D         dec b
1868   0E0E 0A FE 0C      jmp _for24_cond
1869   0E11             _for24_exit:
1870   0E11             ;; return value; 
1871   0E11 FA FF FF      lea d, [bp + -1] ; $value
1872   0E14 2A            mov b, [d]
1873   0E15 F9            leave
1874   0E16 09            ret
1875   0E17             
1876   0E17             gets:
1877   0E17 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1878   0E1A             
1879   0E1A             ; --- BEGIN INLINE ASM BLOCK
1880   0E1A FA 05 00      lea d, [bp + 5] ; $s
1881   0E1D 15            mov a, [d]
1882   0E1E 3C            mov d, a
1883   0E1F 07 CE 16      call _gets
1884   0E22             ; --- END INLINE ASM BLOCK
1885   0E22             
1886   0E22             ;; return strlen(s); 
1887   0E22 FA 05 00      lea d, [bp + 5] ; $s
1888   0E25 2A            mov b, [d]
1889   0E26 FD AB         swp b
1890   0E28 D8            push b
1891   0E29 07 B2 05      call strlen
1892   0E2C 51 02 00      add sp, 2
1893   0E2F F9            leave
1894   0E30 09            ret
1895   0E31             
1896   0E31             print_signed:
1897   0E31 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1898   0E34             ;; char digits[5]; 
1899   0E34 52 05 00      sub sp, 5 ; digits
1900   0E37             ;; int i = 0; 
1901   0E37 52 02 00      sub sp, 2 ; i
1902   0E3A             ; --- START LOCAL VAR INITIALIZATION
1903   0E3A FA FA FF      lea d, [bp + -6] ; $i
1904   0E3D DA            push d
1905   0E3E 26 00 00      mov b, $0
1906   0E41 E7            pop d
1907   0E42 FD 43         mov [d], b
1908   0E44             ; --- END LOCAL VAR INITIALIZATION
1909   0E44             ;; if (num < 0) { 
1910   0E44             _if27_cond:
1911   0E44 FA 05 00      lea d, [bp + 5] ; $num
1912   0E47 2A            mov b, [d]
1913   0E48             ; START RELATIONAL
1914   0E48 D7            push a
1915   0E49 11            mov a, b
1916   0E4A 26 00 00      mov b, $0
1917   0E4D B0            cmp a, b
1918   0E4E FD 73         slt ; < (signed)
1919   0E50 E4            pop a
1920   0E51             ; END RELATIONAL
1921   0E51 C0 00 00      cmp b, 0
1922   0E54 C6 71 0E      je _if27_else
1923   0E57             _if27_true:
1924   0E57             ;; putchar('-'); 
1925   0E57 26 2D 00      mov b, $2d
1926   0E5A DD            push bl
1927   0E5B 07 36 15      call putchar
1928   0E5E 51 01 00      add sp, 1
1929   0E61             ;; num = -num; 
1930   0E61 FA 05 00      lea d, [bp + 5] ; $num
1931   0E64 DA            push d
1932   0E65 FA 05 00      lea d, [bp + 5] ; $num
1933   0E68 2A            mov b, [d]
1934   0E69 FD 97         neg b
1935   0E6B E7            pop d
1936   0E6C FD 43         mov [d], b
1937   0E6E 0A 93 0E      jmp _if27_exit
1938   0E71             _if27_else:
1939   0E71             ;; if (num == 0) { 
1940   0E71             _if28_cond:
1941   0E71 FA 05 00      lea d, [bp + 5] ; $num
1942   0E74 2A            mov b, [d]
1943   0E75             ; START RELATIONAL
1944   0E75 D7            push a
1945   0E76 11            mov a, b
1946   0E77 26 00 00      mov b, $0
1947   0E7A B0            cmp a, b
1948   0E7B FD 71         seq ; ==
1949   0E7D E4            pop a
1950   0E7E             ; END RELATIONAL
1951   0E7E C0 00 00      cmp b, 0
1952   0E81 C6 93 0E      je _if28_exit
1953   0E84             _if28_true:
1954   0E84             ;; putchar('0'); 
1955   0E84 26 30 00      mov b, $30
1956   0E87 DD            push bl
1957   0E88 07 36 15      call putchar
1958   0E8B 51 01 00      add sp, 1
1959   0E8E             ;; return; 
1960   0E8E F9            leave
1961   0E8F 09            ret
1962   0E90 0A 93 0E      jmp _if28_exit
1963   0E93             _if28_exit:
1964   0E93             _if27_exit:
1965   0E93             ;; while (num > 0) { 
1966   0E93             _while29_cond:
1967   0E93 FA 05 00      lea d, [bp + 5] ; $num
1968   0E96 2A            mov b, [d]
1969   0E97             ; START RELATIONAL
1970   0E97 D7            push a
1971   0E98 11            mov a, b
1972   0E99 26 00 00      mov b, $0
1973   0E9C B0            cmp a, b
1974   0E9D FD 7F         sgt ; >
1975   0E9F E4            pop a
1976   0EA0             ; END RELATIONAL
1977   0EA0 C0 00 00      cmp b, 0
1978   0EA3 C6 ED 0E      je _while29_exit
1979   0EA6             _while29_block:
1980   0EA6             ;; digits[i] = '0' + (num % 10); 
1981   0EA6 FA FC FF      lea d, [bp + -4] ; $digits
1982   0EA9 D7            push a
1983   0EAA DA            push d
1984   0EAB FA FA FF      lea d, [bp + -6] ; $i
1985   0EAE 2A            mov b, [d]
1986   0EAF E7            pop d
1987   0EB0 5A            add d, b
1988   0EB1 E4            pop a
1989   0EB2 DA            push d
1990   0EB3 26 30 00      mov b, $30
1991   0EB6             ; START TERMS
1992   0EB6 D7            push a
1993   0EB7 11            mov a, b
1994   0EB8 FA 05 00      lea d, [bp + 5] ; $num
1995   0EBB 2A            mov b, [d]
1996   0EBC             ; START FACTORS
1997   0EBC D7            push a
1998   0EBD 11            mov a, b
1999   0EBE 26 0A 00      mov b, $a
2000   0EC1 AE            div a, b ; 
2001   0EC2 11            mov a, b
2002   0EC3 27            mov b, a
2003   0EC4 E4            pop a
2004   0EC5             ; END FACTORS
2005   0EC5 56            add b, a
2006   0EC6 E4            pop a
2007   0EC7             ; END TERMS
2008   0EC7 E7            pop d
2009   0EC8 FD 3E         mov [d], bl
2010   0ECA             ;; num = num / 10; 
2011   0ECA FA 05 00      lea d, [bp + 5] ; $num
2012   0ECD DA            push d
2013   0ECE FA 05 00      lea d, [bp + 5] ; $num
2014   0ED1 2A            mov b, [d]
2015   0ED2             ; START FACTORS
2016   0ED2 D7            push a
2017   0ED3 11            mov a, b
2018   0ED4 26 0A 00      mov b, $a
2019   0ED7 AE            div a, b
2020   0ED8 27            mov b, a
2021   0ED9 E4            pop a
2022   0EDA             ; END FACTORS
2023   0EDA E7            pop d
2024   0EDB FD 43         mov [d], b
2025   0EDD             ;; i++; 
2026   0EDD FA FA FF      lea d, [bp + -6] ; $i
2027   0EE0 2A            mov b, [d]
2028   0EE1 FD 77         inc b
2029   0EE3 FA FA FF      lea d, [bp + -6] ; $i
2030   0EE6 FD 43         mov [d], b
2031   0EE8 FD 7D         dec b
2032   0EEA 0A 93 0E      jmp _while29_cond
2033   0EED             _while29_exit:
2034   0EED             ;; while (i > 0) { 
2035   0EED             _while30_cond:
2036   0EED FA FA FF      lea d, [bp + -6] ; $i
2037   0EF0 2A            mov b, [d]
2038   0EF1             ; START RELATIONAL
2039   0EF1 D7            push a
2040   0EF2 11            mov a, b
2041   0EF3 26 00 00      mov b, $0
2042   0EF6 B0            cmp a, b
2043   0EF7 FD 7F         sgt ; >
2044   0EF9 E4            pop a
2045   0EFA             ; END RELATIONAL
2046   0EFA C0 00 00      cmp b, 0
2047   0EFD C6 26 0F      je _while30_exit
2048   0F00             _while30_block:
2049   0F00             ;; i--; 
2050   0F00 FA FA FF      lea d, [bp + -6] ; $i
2051   0F03 2A            mov b, [d]
2052   0F04 FD 7D         dec b
2053   0F06 FA FA FF      lea d, [bp + -6] ; $i
2054   0F09 FD 43         mov [d], b
2055   0F0B FD 77         inc b
2056   0F0D             ;; putchar(digits[i]); 
2057   0F0D FA FC FF      lea d, [bp + -4] ; $digits
2058   0F10 D7            push a
2059   0F11 DA            push d
2060   0F12 FA FA FF      lea d, [bp + -6] ; $i
2061   0F15 2A            mov b, [d]
2062   0F16 E7            pop d
2063   0F17 5A            add d, b
2064   0F18 E4            pop a
2065   0F19 32            mov bl, [d]
2066   0F1A A7 00         mov bh, 0
2067   0F1C DD            push bl
2068   0F1D 07 36 15      call putchar
2069   0F20 51 01 00      add sp, 1
2070   0F23 0A ED 0E      jmp _while30_cond
2071   0F26             _while30_exit:
2072   0F26 F9            leave
2073   0F27 09            ret
2074   0F28             
2075   0F28             print_signed_long:
2076   0F28 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2077   0F2B             ;; char digits[10]; 
2078   0F2B 52 0A 00      sub sp, 10 ; digits
2079   0F2E             ;; int i = 0; 
2080   0F2E 52 02 00      sub sp, 2 ; i
2081   0F31             ; --- START LOCAL VAR INITIALIZATION
2082   0F31 FA F5 FF      lea d, [bp + -11] ; $i
2083   0F34 DA            push d
2084   0F35 26 00 00      mov b, $0
2085   0F38 E7            pop d
2086   0F39 FD 43         mov [d], b
2087   0F3B             ; --- END LOCAL VAR INITIALIZATION
2088   0F3B             ;; if (num < 0) { 
2089   0F3B             _if31_cond:
2090   0F3B FA 05 00      lea d, [bp + 5] ; $num
2091   0F3E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2092   0F41 FD 39         mov c, b ; And place it into C
2093   0F43 2A            mov b, [d] ; Lower Word in B
2094   0F44             ; START RELATIONAL
2095   0F44 D7            push a
2096   0F45 FD D8         push g
2097   0F47 11            mov a, b
2098   0F48 FD 7A         mov g, c
2099   0F4A 26 00 00      mov b, $0
2100   0F4D 38 00 00      mov c, 0
2101   0F50 FD AF 00 00   cmp32 ga, cb
2101   0F54 00 00 00 00 
2101   0F58 00 00 00 00 
2101   0F5C 00 00 00 00 
2101   0F60 00 00 00 00 
2101   0F64 00 00 00 00 
2101   0F68 00 00 00 00 
2101   0F6C 00 00 00 00 
2101   0F70 00 00 00 00 
2101   0F74 00 00 00 00 
2101   0F78 00 00 00 00 
2101   0F7C 00 00 00 00 
2101   0F80 00 00 00 00 
2101   0F84 00 00 00 00 
2101   0F88 00 00 00 00 
2101   0F8C 00 00 00 00 
2101   0F90 00 00 00 00 
2101   0F94 00 00 00 00 
2101   0F98 00 00 00 00 
2101   0F9C 00 00 00 00 
2101   0FA0 00 00 00 00 
2101   0FA4 00 00 00 00 
2101   0FA8 00 00 00 00 
2101   0FAC 00 00 00 00 
2101   0FB0 00 00 00 00 
2101   0FB4 00 00 00 00 
2101   0FB8 00 00 00 00 
2101   0FBC 00 00 00 00 
2101   0FC0 00 00 00 00 
2101   0FC4 00 00 00 00 
2101   0FC8 00 00 00 00 
2101   0FCC 00 00 00 00 
2101   0FD0 00 00 00 00 
2101   0FD4 00 00 00 00 
2101   0FD8 00 00 00 00 
2101   0FDC 00 00 00 00 
2101   0FE0 00 00 00 00 
2101   0FE4 00 00 00 00 
2101   0FE8 00 00 00 00 
2101   0FEC 00 00 00 00 
2101   0FF0 00 00 00 00 
2101   0FF4 00 00 00 00 
2101   0FF8 00 00 00 00 
2101   0FFC 00 00 00 00 
2101   1000 00 00 00 00 
2101   1004 00 00 00 00 
2101   1008 00 00 00 00 
2101   100C 00 00 00 00 
2101   1010 00 00 00 00 
2101   1014 00 00 00 00 
2101   1018 00 00 00 00 
2101   101C 00 00 00 00 
2101   1020 00 00 00 00 
2101   1024 00 00 00 00 
2101   1028 00 00 00 00 
2101   102C 00 00 00 00 
2101   1030 00 00 00 00 
2101   1034 00 00 00 00 
2101   1038 00 00 00 00 
2101   103C 00 00 00 00 
2101   1040 00 00 00 00 
2101   1044 00 00 00 00 
2101   1048 00 00 00 00 
2101   104C 00 00 00 00 
2101   1050 00 
2102   1051 FD 73         slt ; <
2103   1053 FD F1         pop g
2104   1055 E4            pop a
2105   1056             ; END RELATIONAL
2106   1056 C0 00 00      cmp b, 0
2107   1059 C6 80 10      je _if31_else
2108   105C             _if31_true:
2109   105C             ;; putchar('-'); 
2110   105C 26 2D 00      mov b, $2d
2111   105F DD            push bl
2112   1060 07 36 15      call putchar
2113   1063 51 01 00      add sp, 1
2114   1066             ;; num = -num; 
2115   1066 FA 05 00      lea d, [bp + 5] ; $num
2116   1069 DA            push d
2117   106A FA 05 00      lea d, [bp + 5] ; $num
2118   106D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2119   1070 FD 39         mov c, b ; And place it into C
2120   1072 2A            mov b, [d] ; Lower Word in B
2121   1073 FD 97         neg b
2122   1075 E7            pop d
2123   1076 FD 43         mov [d], b
2124   1078 28            mov b, c
2125   1079 FD 44 02 00   mov [d + 2], b
2126   107D 0A B0 11      jmp _if31_exit
2127   1080             _if31_else:
2128   1080             ;; if (num == 0) { 
2129   1080             _if32_cond:
2130   1080 FA 05 00      lea d, [bp + 5] ; $num
2131   1083 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2132   1086 FD 39         mov c, b ; And place it into C
2133   1088 2A            mov b, [d] ; Lower Word in B
2134   1089             ; START RELATIONAL
2135   1089 D7            push a
2136   108A FD D8         push g
2137   108C 11            mov a, b
2138   108D FD 7A         mov g, c
2139   108F 26 00 00      mov b, $0
2140   1092 38 00 00      mov c, 0
2141   1095 FD AF 00 00   cmp32 ga, cb
2141   1099 00 00 00 00 
2141   109D 00 00 00 00 
2141   10A1 00 00 00 00 
2141   10A5 00 00 00 00 
2141   10A9 00 00 00 00 
2141   10AD 00 00 00 00 
2141   10B1 00 00 00 00 
2141   10B5 00 00 00 00 
2141   10B9 00 00 00 00 
2141   10BD 00 00 00 00 
2141   10C1 00 00 00 00 
2141   10C5 00 00 00 00 
2141   10C9 00 00 00 00 
2141   10CD 00 00 00 00 
2141   10D1 00 00 00 00 
2141   10D5 00 00 00 00 
2141   10D9 00 00 00 00 
2141   10DD 00 00 00 00 
2141   10E1 00 00 00 00 
2141   10E5 00 00 00 00 
2141   10E9 00 00 00 00 
2141   10ED 00 00 00 00 
2141   10F1 00 00 00 00 
2141   10F5 00 00 00 00 
2141   10F9 00 00 00 00 
2141   10FD 00 00 00 00 
2141   1101 00 00 00 00 
2141   1105 00 00 00 00 
2141   1109 00 00 00 00 
2141   110D 00 00 00 00 
2141   1111 00 00 00 00 
2141   1115 00 00 00 00 
2141   1119 00 00 00 00 
2141   111D 00 00 00 00 
2141   1121 00 00 00 00 
2141   1125 00 00 00 00 
2141   1129 00 00 00 00 
2141   112D 00 00 00 00 
2141   1131 00 00 00 00 
2141   1135 00 00 00 00 
2141   1139 00 00 00 00 
2141   113D 00 00 00 00 
2141   1141 00 00 00 00 
2141   1145 00 00 00 00 
2141   1149 00 00 00 00 
2141   114D 00 00 00 00 
2141   1151 00 00 00 00 
2141   1155 00 00 00 00 
2141   1159 00 00 00 00 
2141   115D 00 00 00 00 
2141   1161 00 00 00 00 
2141   1165 00 00 00 00 
2141   1169 00 00 00 00 
2141   116D 00 00 00 00 
2141   1171 00 00 00 00 
2141   1175 00 00 00 00 
2141   1179 00 00 00 00 
2141   117D 00 00 00 00 
2141   1181 00 00 00 00 
2141   1185 00 00 00 00 
2141   1189 00 00 00 00 
2141   118D 00 00 00 00 
2141   1191 00 00 00 00 
2141   1195 00 
2142   1196 FD 71         seq ; ==
2143   1198 FD F1         pop g
2144   119A E4            pop a
2145   119B             ; END RELATIONAL
2146   119B C0 00 00      cmp b, 0
2147   119E C6 B0 11      je _if32_exit
2148   11A1             _if32_true:
2149   11A1             ;; putchar('0'); 
2150   11A1 26 30 00      mov b, $30
2151   11A4 DD            push bl
2152   11A5 07 36 15      call putchar
2153   11A8 51 01 00      add sp, 1
2154   11AB             ;; return; 
2155   11AB F9            leave
2156   11AC 09            ret
2157   11AD 0A B0 11      jmp _if32_exit
2158   11B0             _if32_exit:
2159   11B0             _if31_exit:
2160   11B0             ;; while (num > 0) { 
2161   11B0             _while33_cond:
2162   11B0 FA 05 00      lea d, [bp + 5] ; $num
2163   11B3 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2164   11B6 FD 39         mov c, b ; And place it into C
2165   11B8 2A            mov b, [d] ; Lower Word in B
2166   11B9             ; START RELATIONAL
2167   11B9 D7            push a
2168   11BA FD D8         push g
2169   11BC 11            mov a, b
2170   11BD FD 7A         mov g, c
2171   11BF 26 00 00      mov b, $0
2172   11C2 38 00 00      mov c, 0
2173   11C5 FD 7F         sgt
2174   11C7 FD F1         pop g
2175   11C9 E4            pop a
2176   11CA             ; END RELATIONAL
2177   11CA C0 00 00      cmp b, 0
2178   11CD C6 2D 12      je _while33_exit
2179   11D0             _while33_block:
2180   11D0             ;; digits[i] = '0' + (num % 10); 
2181   11D0 FA F7 FF      lea d, [bp + -9] ; $digits
2182   11D3 D7            push a
2183   11D4 DA            push d
2184   11D5 FA F5 FF      lea d, [bp + -11] ; $i
2185   11D8 2A            mov b, [d]
2186   11D9 E7            pop d
2187   11DA 5A            add d, b
2188   11DB E4            pop a
2189   11DC DA            push d
2190   11DD 26 30 00      mov b, $30
2191   11E0             ; START TERMS
2192   11E0 D7            push a
2193   11E1 11            mov a, b
2194   11E2 FA 05 00      lea d, [bp + 5] ; $num
2195   11E5 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2196   11E8 FD 39         mov c, b ; And place it into C
2197   11EA 2A            mov b, [d] ; Lower Word in B
2198   11EB             ; START FACTORS
2199   11EB D7            push a
2200   11EC 11            mov a, b
2201   11ED 26 0A 00      mov b, $a
2202   11F0 AE            div a, b ; 
2203   11F1 11            mov a, b
2204   11F2 27            mov b, a
2205   11F3 E4            pop a
2206   11F4             ; END FACTORS
2207   11F4 54            add a, b
2208   11F5 D7            push a
2209   11F6 FD 12         mov a, g
2210   11F8 28            mov b, c
2211   11F9 5C            adc a, b
2212   11FA 39            mov c, a
2213   11FB E5            pop b
2214   11FC E4            pop a
2215   11FD             ; END TERMS
2216   11FD E7            pop d
2217   11FE FD 3E         mov [d], bl
2218   1200             ;; num = num / 10; 
2219   1200 FA 05 00      lea d, [bp + 5] ; $num
2220   1203 DA            push d
2221   1204 FA 05 00      lea d, [bp + 5] ; $num
2222   1207 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2223   120A FD 39         mov c, b ; And place it into C
2224   120C 2A            mov b, [d] ; Lower Word in B
2225   120D             ; START FACTORS
2226   120D D7            push a
2227   120E 11            mov a, b
2228   120F 26 0A 00      mov b, $a
2229   1212 AE            div a, b
2230   1213 27            mov b, a
2231   1214 E4            pop a
2232   1215             ; END FACTORS
2233   1215 E7            pop d
2234   1216 FD 43         mov [d], b
2235   1218 28            mov b, c
2236   1219 FD 44 02 00   mov [d + 2], b
2237   121D             ;; i++; 
2238   121D FA F5 FF      lea d, [bp + -11] ; $i
2239   1220 2A            mov b, [d]
2240   1221 FD 77         inc b
2241   1223 FA F5 FF      lea d, [bp + -11] ; $i
2242   1226 FD 43         mov [d], b
2243   1228 FD 7D         dec b
2244   122A 0A B0 11      jmp _while33_cond
2245   122D             _while33_exit:
2246   122D             ;; while (i > 0) { 
2247   122D             _while34_cond:
2248   122D FA F5 FF      lea d, [bp + -11] ; $i
2249   1230 2A            mov b, [d]
2250   1231             ; START RELATIONAL
2251   1231 D7            push a
2252   1232 11            mov a, b
2253   1233 26 00 00      mov b, $0
2254   1236 B0            cmp a, b
2255   1237 FD 7F         sgt ; >
2256   1239 E4            pop a
2257   123A             ; END RELATIONAL
2258   123A C0 00 00      cmp b, 0
2259   123D C6 66 12      je _while34_exit
2260   1240             _while34_block:
2261   1240             ;; i--; 
2262   1240 FA F5 FF      lea d, [bp + -11] ; $i
2263   1243 2A            mov b, [d]
2264   1244 FD 7D         dec b
2265   1246 FA F5 FF      lea d, [bp + -11] ; $i
2266   1249 FD 43         mov [d], b
2267   124B FD 77         inc b
2268   124D             ;; putchar(digits[i]); 
2269   124D FA F7 FF      lea d, [bp + -9] ; $digits
2270   1250 D7            push a
2271   1251 DA            push d
2272   1252 FA F5 FF      lea d, [bp + -11] ; $i
2273   1255 2A            mov b, [d]
2274   1256 E7            pop d
2275   1257 5A            add d, b
2276   1258 E4            pop a
2277   1259 32            mov bl, [d]
2278   125A A7 00         mov bh, 0
2279   125C DD            push bl
2280   125D 07 36 15      call putchar
2281   1260 51 01 00      add sp, 1
2282   1263 0A 2D 12      jmp _while34_cond
2283   1266             _while34_exit:
2284   1266 F9            leave
2285   1267 09            ret
2286   1268             
2287   1268             print_unsigned_long:
2288   1268 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2289   126B             ;; char digits[10]; 
2290   126B 52 0A 00      sub sp, 10 ; digits
2291   126E             ;; int i; 
2292   126E 52 02 00      sub sp, 2 ; i
2293   1271             ;; i = 0; 
2294   1271 FA F5 FF      lea d, [bp + -11] ; $i
2295   1274 DA            push d
2296   1275 26 00 00      mov b, $0
2297   1278 E7            pop d
2298   1279 FD 43         mov [d], b
2299   127B             ;; if(num == 0){ 
2300   127B             _if35_cond:
2301   127B FA 05 00      lea d, [bp + 5] ; $num
2302   127E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2303   1281 FD 39         mov c, b ; And place it into C
2304   1283 2A            mov b, [d] ; Lower Word in B
2305   1284             ; START RELATIONAL
2306   1284 D7            push a
2307   1285 FD D8         push g
2308   1287 11            mov a, b
2309   1288 FD 7A         mov g, c
2310   128A 26 00 00      mov b, $0
2311   128D 38 00 00      mov c, 0
2312   1290 FD AF 00 00   cmp32 ga, cb
2312   1294 00 00 00 00 
2312   1298 00 00 00 00 
2312   129C 00 00 00 00 
2312   12A0 00 00 00 00 
2312   12A4 00 00 00 00 
2312   12A8 00 00 00 00 
2312   12AC 00 00 00 00 
2312   12B0 00 00 00 00 
2312   12B4 00 00 00 00 
2312   12B8 00 00 00 00 
2312   12BC 00 00 00 00 
2312   12C0 00 00 00 00 
2312   12C4 00 00 00 00 
2312   12C8 00 00 00 00 
2312   12CC 00 00 00 00 
2312   12D0 00 00 00 00 
2312   12D4 00 00 00 00 
2312   12D8 00 00 00 00 
2312   12DC 00 00 00 00 
2312   12E0 00 00 00 00 
2312   12E4 00 00 00 00 
2312   12E8 00 00 00 00 
2312   12EC 00 00 00 00 
2312   12F0 00 00 00 00 
2312   12F4 00 00 00 00 
2312   12F8 00 00 00 00 
2312   12FC 00 00 00 00 
2312   1300 00 00 00 00 
2312   1304 00 00 00 00 
2312   1308 00 00 00 00 
2312   130C 00 00 00 00 
2312   1310 00 00 00 00 
2312   1314 00 00 00 00 
2312   1318 00 00 00 00 
2312   131C 00 00 00 00 
2312   1320 00 00 00 00 
2312   1324 00 00 00 00 
2312   1328 00 00 00 00 
2312   132C 00 00 00 00 
2312   1330 00 00 00 00 
2312   1334 00 00 00 00 
2312   1338 00 00 00 00 
2312   133C 00 00 00 00 
2312   1340 00 00 00 00 
2312   1344 00 00 00 00 
2312   1348 00 00 00 00 
2312   134C 00 00 00 00 
2312   1350 00 00 00 00 
2312   1354 00 00 00 00 
2312   1358 00 00 00 00 
2312   135C 00 00 00 00 
2312   1360 00 00 00 00 
2312   1364 00 00 00 00 
2312   1368 00 00 00 00 
2312   136C 00 00 00 00 
2312   1370 00 00 00 00 
2312   1374 00 00 00 00 
2312   1378 00 00 00 00 
2312   137C 00 00 00 00 
2312   1380 00 00 00 00 
2312   1384 00 00 00 00 
2312   1388 00 00 00 00 
2312   138C 00 00 00 00 
2312   1390 00 
2313   1391 FD 71         seq ; ==
2314   1393 FD F1         pop g
2315   1395 E4            pop a
2316   1396             ; END RELATIONAL
2317   1396 C0 00 00      cmp b, 0
2318   1399 C6 AB 13      je _if35_exit
2319   139C             _if35_true:
2320   139C             ;; putchar('0'); 
2321   139C 26 30 00      mov b, $30
2322   139F DD            push bl
2323   13A0 07 36 15      call putchar
2324   13A3 51 01 00      add sp, 1
2325   13A6             ;; return; 
2326   13A6 F9            leave
2327   13A7 09            ret
2328   13A8 0A AB 13      jmp _if35_exit
2329   13AB             _if35_exit:
2330   13AB             ;; while (num > 0) { 
2331   13AB             _while36_cond:
2332   13AB FA 05 00      lea d, [bp + 5] ; $num
2333   13AE 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2334   13B1 FD 39         mov c, b ; And place it into C
2335   13B3 2A            mov b, [d] ; Lower Word in B
2336   13B4             ; START RELATIONAL
2337   13B4 D7            push a
2338   13B5 FD D8         push g
2339   13B7 11            mov a, b
2340   13B8 FD 7A         mov g, c
2341   13BA 26 00 00      mov b, $0
2342   13BD 38 00 00      mov c, 0
2343   13C0 FD 81         sgu
2344   13C2 FD F1         pop g
2345   13C4 E4            pop a
2346   13C5             ; END RELATIONAL
2347   13C5 C0 00 00      cmp b, 0
2348   13C8 C6 28 14      je _while36_exit
2349   13CB             _while36_block:
2350   13CB             ;; digits[i] = '0' + (num % 10); 
2351   13CB FA F7 FF      lea d, [bp + -9] ; $digits
2352   13CE D7            push a
2353   13CF DA            push d
2354   13D0 FA F5 FF      lea d, [bp + -11] ; $i
2355   13D3 2A            mov b, [d]
2356   13D4 E7            pop d
2357   13D5 5A            add d, b
2358   13D6 E4            pop a
2359   13D7 DA            push d
2360   13D8 26 30 00      mov b, $30
2361   13DB             ; START TERMS
2362   13DB D7            push a
2363   13DC 11            mov a, b
2364   13DD FA 05 00      lea d, [bp + 5] ; $num
2365   13E0 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2366   13E3 FD 39         mov c, b ; And place it into C
2367   13E5 2A            mov b, [d] ; Lower Word in B
2368   13E6             ; START FACTORS
2369   13E6 D7            push a
2370   13E7 11            mov a, b
2371   13E8 26 0A 00      mov b, $a
2372   13EB AE            div a, b ; 
2373   13EC 11            mov a, b
2374   13ED 27            mov b, a
2375   13EE E4            pop a
2376   13EF             ; END FACTORS
2377   13EF 54            add a, b
2378   13F0 D7            push a
2379   13F1 FD 12         mov a, g
2380   13F3 28            mov b, c
2381   13F4 5C            adc a, b
2382   13F5 39            mov c, a
2383   13F6 E5            pop b
2384   13F7 E4            pop a
2385   13F8             ; END TERMS
2386   13F8 E7            pop d
2387   13F9 FD 3E         mov [d], bl
2388   13FB             ;; num = num / 10; 
2389   13FB FA 05 00      lea d, [bp + 5] ; $num
2390   13FE DA            push d
2391   13FF FA 05 00      lea d, [bp + 5] ; $num
2392   1402 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2393   1405 FD 39         mov c, b ; And place it into C
2394   1407 2A            mov b, [d] ; Lower Word in B
2395   1408             ; START FACTORS
2396   1408 D7            push a
2397   1409 11            mov a, b
2398   140A 26 0A 00      mov b, $a
2399   140D AE            div a, b
2400   140E 27            mov b, a
2401   140F E4            pop a
2402   1410             ; END FACTORS
2403   1410 E7            pop d
2404   1411 FD 43         mov [d], b
2405   1413 28            mov b, c
2406   1414 FD 44 02 00   mov [d + 2], b
2407   1418             ;; i++; 
2408   1418 FA F5 FF      lea d, [bp + -11] ; $i
2409   141B 2A            mov b, [d]
2410   141C FD 77         inc b
2411   141E FA F5 FF      lea d, [bp + -11] ; $i
2412   1421 FD 43         mov [d], b
2413   1423 FD 7D         dec b
2414   1425 0A AB 13      jmp _while36_cond
2415   1428             _while36_exit:
2416   1428             ;; while (i > 0) { 
2417   1428             _while37_cond:
2418   1428 FA F5 FF      lea d, [bp + -11] ; $i
2419   142B 2A            mov b, [d]
2420   142C             ; START RELATIONAL
2421   142C D7            push a
2422   142D 11            mov a, b
2423   142E 26 00 00      mov b, $0
2424   1431 B0            cmp a, b
2425   1432 FD 7F         sgt ; >
2426   1434 E4            pop a
2427   1435             ; END RELATIONAL
2428   1435 C0 00 00      cmp b, 0
2429   1438 C6 61 14      je _while37_exit
2430   143B             _while37_block:
2431   143B             ;; i--; 
2432   143B FA F5 FF      lea d, [bp + -11] ; $i
2433   143E 2A            mov b, [d]
2434   143F FD 7D         dec b
2435   1441 FA F5 FF      lea d, [bp + -11] ; $i
2436   1444 FD 43         mov [d], b
2437   1446 FD 77         inc b
2438   1448             ;; putchar(digits[i]); 
2439   1448 FA F7 FF      lea d, [bp + -9] ; $digits
2440   144B D7            push a
2441   144C DA            push d
2442   144D FA F5 FF      lea d, [bp + -11] ; $i
2443   1450 2A            mov b, [d]
2444   1451 E7            pop d
2445   1452 5A            add d, b
2446   1453 E4            pop a
2447   1454 32            mov bl, [d]
2448   1455 A7 00         mov bh, 0
2449   1457 DD            push bl
2450   1458 07 36 15      call putchar
2451   145B 51 01 00      add sp, 1
2452   145E 0A 28 14      jmp _while37_cond
2453   1461             _while37_exit:
2454   1461 F9            leave
2455   1462 09            ret
2456   1463             
2457   1463             print_unsigned:
2458   1463 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2459   1466             ;; char digits[5]; 
2460   1466 52 05 00      sub sp, 5 ; digits
2461   1469             ;; int i; 
2462   1469 52 02 00      sub sp, 2 ; i
2463   146C             ;; i = 0; 
2464   146C FA FA FF      lea d, [bp + -6] ; $i
2465   146F DA            push d
2466   1470 26 00 00      mov b, $0
2467   1473 E7            pop d
2468   1474 FD 43         mov [d], b
2469   1476             ;; if(num == 0){ 
2470   1476             _if38_cond:
2471   1476 FA 05 00      lea d, [bp + 5] ; $num
2472   1479 2A            mov b, [d]
2473   147A             ; START RELATIONAL
2474   147A D7            push a
2475   147B 11            mov a, b
2476   147C 26 00 00      mov b, $0
2477   147F B0            cmp a, b
2478   1480 FD 71         seq ; ==
2479   1482 E4            pop a
2480   1483             ; END RELATIONAL
2481   1483 C0 00 00      cmp b, 0
2482   1486 C6 98 14      je _if38_exit
2483   1489             _if38_true:
2484   1489             ;; putchar('0'); 
2485   1489 26 30 00      mov b, $30
2486   148C DD            push bl
2487   148D 07 36 15      call putchar
2488   1490 51 01 00      add sp, 1
2489   1493             ;; return; 
2490   1493 F9            leave
2491   1494 09            ret
2492   1495 0A 98 14      jmp _if38_exit
2493   1498             _if38_exit:
2494   1498             ;; while (num > 0) { 
2495   1498             _while39_cond:
2496   1498 FA 05 00      lea d, [bp + 5] ; $num
2497   149B 2A            mov b, [d]
2498   149C             ; START RELATIONAL
2499   149C D7            push a
2500   149D 11            mov a, b
2501   149E 26 00 00      mov b, $0
2502   14A1 B0            cmp a, b
2503   14A2 FD 81         sgu ; > (unsigned)
2504   14A4 E4            pop a
2505   14A5             ; END RELATIONAL
2506   14A5 C0 00 00      cmp b, 0
2507   14A8 C6 F2 14      je _while39_exit
2508   14AB             _while39_block:
2509   14AB             ;; digits[i] = '0' + (num % 10); 
2510   14AB FA FC FF      lea d, [bp + -4] ; $digits
2511   14AE D7            push a
2512   14AF DA            push d
2513   14B0 FA FA FF      lea d, [bp + -6] ; $i
2514   14B3 2A            mov b, [d]
2515   14B4 E7            pop d
2516   14B5 5A            add d, b
2517   14B6 E4            pop a
2518   14B7 DA            push d
2519   14B8 26 30 00      mov b, $30
2520   14BB             ; START TERMS
2521   14BB D7            push a
2522   14BC 11            mov a, b
2523   14BD FA 05 00      lea d, [bp + 5] ; $num
2524   14C0 2A            mov b, [d]
2525   14C1             ; START FACTORS
2526   14C1 D7            push a
2527   14C2 11            mov a, b
2528   14C3 26 0A 00      mov b, $a
2529   14C6 AE            div a, b ; 
2530   14C7 11            mov a, b
2531   14C8 27            mov b, a
2532   14C9 E4            pop a
2533   14CA             ; END FACTORS
2534   14CA 56            add b, a
2535   14CB E4            pop a
2536   14CC             ; END TERMS
2537   14CC E7            pop d
2538   14CD FD 3E         mov [d], bl
2539   14CF             ;; num = num / 10; 
2540   14CF FA 05 00      lea d, [bp + 5] ; $num
2541   14D2 DA            push d
2542   14D3 FA 05 00      lea d, [bp + 5] ; $num
2543   14D6 2A            mov b, [d]
2544   14D7             ; START FACTORS
2545   14D7 D7            push a
2546   14D8 11            mov a, b
2547   14D9 26 0A 00      mov b, $a
2548   14DC AE            div a, b
2549   14DD 27            mov b, a
2550   14DE E4            pop a
2551   14DF             ; END FACTORS
2552   14DF E7            pop d
2553   14E0 FD 43         mov [d], b
2554   14E2             ;; i++; 
2555   14E2 FA FA FF      lea d, [bp + -6] ; $i
2556   14E5 2A            mov b, [d]
2557   14E6 FD 77         inc b
2558   14E8 FA FA FF      lea d, [bp + -6] ; $i
2559   14EB FD 43         mov [d], b
2560   14ED FD 7D         dec b
2561   14EF 0A 98 14      jmp _while39_cond
2562   14F2             _while39_exit:
2563   14F2             ;; while (i > 0) { 
2564   14F2             _while40_cond:
2565   14F2 FA FA FF      lea d, [bp + -6] ; $i
2566   14F5 2A            mov b, [d]
2567   14F6             ; START RELATIONAL
2568   14F6 D7            push a
2569   14F7 11            mov a, b
2570   14F8 26 00 00      mov b, $0
2571   14FB B0            cmp a, b
2572   14FC FD 7F         sgt ; >
2573   14FE E4            pop a
2574   14FF             ; END RELATIONAL
2575   14FF C0 00 00      cmp b, 0
2576   1502 C6 2B 15      je _while40_exit
2577   1505             _while40_block:
2578   1505             ;; i--; 
2579   1505 FA FA FF      lea d, [bp + -6] ; $i
2580   1508 2A            mov b, [d]
2581   1509 FD 7D         dec b
2582   150B FA FA FF      lea d, [bp + -6] ; $i
2583   150E FD 43         mov [d], b
2584   1510 FD 77         inc b
2585   1512             ;; putchar(digits[i]); 
2586   1512 FA FC FF      lea d, [bp + -4] ; $digits
2587   1515 D7            push a
2588   1516 DA            push d
2589   1517 FA FA FF      lea d, [bp + -6] ; $i
2590   151A 2A            mov b, [d]
2591   151B E7            pop d
2592   151C 5A            add d, b
2593   151D E4            pop a
2594   151E 32            mov bl, [d]
2595   151F A7 00         mov bh, 0
2596   1521 DD            push bl
2597   1522 07 36 15      call putchar
2598   1525 51 01 00      add sp, 1
2599   1528 0A F2 14      jmp _while40_cond
2600   152B             _while40_exit:
2601   152B F9            leave
2602   152C 09            ret
2603   152D             
2604   152D             date:
2605   152D F8 00 00      enter 0 ; (push bp; mov bp, sp)
2606   1530             
2607   1530             ; --- BEGIN INLINE ASM BLOCK
2608   1530 19 00         mov al, 0 
2609   1532 05 07         syscall sys_datetime
2610   1534             ; --- END INLINE ASM BLOCK
2611   1534             
2612   1534 F9            leave
2613   1535 09            ret
2614   1536             
2615   1536             putchar:
2616   1536 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2617   1539             
2618   1539             ; --- BEGIN INLINE ASM BLOCK
2619   1539 FA 05 00      lea d, [bp + 5] ; $c
2620   153C 1E            mov al, [d]
2621   153D 23            mov ah, al
2622   153E 07 C7 16      call _putchar
2623   1541             ; --- END INLINE ASM BLOCK
2624   1541             
2625   1541 F9            leave
2626   1542 09            ret
2627   1543             
2628   1543             getchar:
2629   1543 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2630   1546             ;; char c; 
2631   1546 52 01 00      sub sp, 1 ; c
2632   1549             
2633   1549             ; --- BEGIN INLINE ASM BLOCK
2634   1549 07 C0 16      call getch
2635   154C 1A            mov al, ah
2636   154D FA 00 00      lea d, [bp + 0] ; $c
2637   1550 3E            mov [d], al
2638   1551             ; --- END INLINE ASM BLOCK
2639   1551             
2640   1551             ;; return c; 
2641   1551 FA 00 00      lea d, [bp + 0] ; $c
2642   1554 32            mov bl, [d]
2643   1555 A7 00         mov bh, 0
2644   1557 F9            leave
2645   1558 09            ret
2646   1559             
2647   1559             scann:
2648   1559 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2649   155C             ;; int m; 
2650   155C 52 02 00      sub sp, 2 ; m
2651   155F             
2652   155F             ; --- BEGIN INLINE ASM BLOCK
2653   155F 07 0B 19      call scan_u16d
2654   1562 FA FF FF      lea d, [bp + -1] ; $m
2655   1565 43            mov [d], a
2656   1566             ; --- END INLINE ASM BLOCK
2657   1566             
2658   1566             ;; return m; 
2659   1566 FA FF FF      lea d, [bp + -1] ; $m
2660   1569 2A            mov b, [d]
2661   156A F9            leave
2662   156B 09            ret
2663   156C             
2664   156C             puts:
2665   156C F8 00 00      enter 0 ; (push bp; mov bp, sp)
2666   156F             
2667   156F             ; --- BEGIN INLINE ASM BLOCK
2668   156F FA 05 00      lea d, [bp + 5] ; $s
2669   1572 15            mov a, [d]
2670   1573 3C            mov d, a
2671   1574 07 11 18      call _puts
2672   1577 10 00 0A      mov a, $0A00
2673   157A 05 03         syscall sys_io
2674   157C             ; --- END INLINE ASM BLOCK
2675   157C             
2676   157C F9            leave
2677   157D 09            ret
2678   157E             
2679   157E             print:
2680   157E F8 00 00      enter 0 ; (push bp; mov bp, sp)
2681   1581             
2682   1581             ; --- BEGIN INLINE ASM BLOCK
2683   1581 FA 05 00      lea d, [bp + 5] ; $s
2684   1584 FD 2A         mov d, [d]
2685   1586 07 11 18      call _puts
2686   1589             ; --- END INLINE ASM BLOCK
2687   1589             
2688   1589 F9            leave
2689   158A 09            ret
2690   158B             
2691   158B             getparam:
2692   158B F8 00 00      enter 0 ; (push bp; mov bp, sp)
2693   158E             ;; char data; 
2694   158E 52 01 00      sub sp, 1 ; data
2695   1591             
2696   1591             ; --- BEGIN INLINE ASM BLOCK
2697   1591 19 04         mov al, 4
2698   1593 FA 05 00      lea d, [bp + 5] ; $address
2699   1596 FD 2A         mov d, [d]
2700   1598 05 0C         syscall sys_system
2701   159A FA 00 00      lea d, [bp + 0] ; $data
2702   159D FD 3E         mov [d], bl
2703   159F             ; --- END INLINE ASM BLOCK
2704   159F             
2705   159F             ;; return data; 
2706   159F FA 00 00      lea d, [bp + 0] ; $data
2707   15A2 32            mov bl, [d]
2708   15A3 A7 00         mov bh, 0
2709   15A5 F9            leave
2710   15A6 09            ret
2711   15A7             
2712   15A7             clear:
2713   15A7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2714   15AA             ;; print("\033[2J\033[H"); 
2715   15AA 26 93 24      mov b, _s3 ; "\033[2J\033[H"
2716   15AD FD AB         swp b
2717   15AF D8            push b
2718   15B0 07 7E 15      call print
2719   15B3 51 02 00      add sp, 2
2720   15B6 F9            leave
2721   15B7 09            ret
2722   15B8             
2723   15B8             abs:
2724   15B8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2725   15BB             ;; return i < 0 ? -i : i; 
2726   15BB             _ternary41_cond:
2727   15BB FA 05 00      lea d, [bp + 5] ; $i
2728   15BE 2A            mov b, [d]
2729   15BF             ; START RELATIONAL
2730   15BF D7            push a
2731   15C0 11            mov a, b
2732   15C1 26 00 00      mov b, $0
2733   15C4 B0            cmp a, b
2734   15C5 FD 73         slt ; < (signed)
2735   15C7 E4            pop a
2736   15C8             ; END RELATIONAL
2737   15C8 C0 00 00      cmp b, 0
2738   15CB C6 D7 15      je _ternary41_false
2739   15CE             _ternary41_true:
2740   15CE FA 05 00      lea d, [bp + 5] ; $i
2741   15D1 2A            mov b, [d]
2742   15D2 FD 97         neg b
2743   15D4 0A DB 15      jmp _ternary41_exit
2744   15D7             _ternary41_false:
2745   15D7 FA 05 00      lea d, [bp + 5] ; $i
2746   15DA 2A            mov b, [d]
2747   15DB             _ternary41_exit:
2748   15DB F9            leave
2749   15DC 09            ret
2750   15DD             
2751   15DD             include_stdio_asm:
2752   15DD F8 00 00      enter 0 ; (push bp; mov bp, sp)
2753   15E0             
2754   15E0             ; --- BEGIN INLINE ASM BLOCK
2755   15E0             .include "lib/asm/stdio.asm"
0001+  15E0             ;-----------------------------------------------------------------------------
0002+  15E0             ; stdio.s
0003+  15E0             ;-----------------------------------------------------------------------------
0004+  15E0             .include "lib/asm/string.asm"
0001++ 15E0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 15E0             ; string.s
0003++ 15E0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 15E0             
0005++ 15E0             
0006++ 15E0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 15E0             ; _strrev
0008++ 15E0             ; reverse a string
0009++ 15E0             ; D = string address
0010++ 15E0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 15E0             ; 01234
0012++ 15E0             _strrev:
0013++ 15E0 4B          	pusha
0014++ 15E1 07 27 16    	call _strlen	; length in C
0015++ 15E4 12          	mov a, c
0016++ 15E5 AF 01 00    	cmp a, 1
0017++ 15E8 D0 02 16    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 15EB 7D          	dec a
0019++ 15EC FD 4E       	mov si, d	; beginning of string
0020++ 15EE FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 15F0 59          	add d, a	; end of string
0022++ 15F1 12          	mov a, c
0023++ 15F2 FD 9B       	shr a		; divide by 2
0024++ 15F4 39          	mov c, a	; C now counts the steps
0025++ 15F5             _strrev_L0:
0026++ 15F5 32          	mov bl, [d]	; save load right-side char into BL
0027++ 15F6 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 15F7 3E          	mov [d], al	; store left char into right side
0029++ 15F8 1B          	mov al, bl
0030++ 15F9 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 15FA 7E          	dec c
0032++ 15FB 7F          	dec d
0033++ 15FC C2 00 00    	cmp c, 0
0034++ 15FF C7 F5 15    	jne _strrev_L0
0035++ 1602             _strrev_end:
0036++ 1602 4C          	popa
0037++ 1603 09          	ret
0038++ 1604             	
0039++ 1604             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 1604             ; _strchr
0041++ 1604             ; search string in D for char in AL
0042++ 1604             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 1604             _strchr:
0044++ 1604             _strchr_L0:
0045++ 1604 32          	mov bl, [d]
0046++ 1605 C1 00       	cmp bl, 0
0047++ 1607 C6 12 16    	je _strchr_end
0048++ 160A BA          	cmp al, bl
0049++ 160B C6 12 16    	je _strchr_end
0050++ 160E 79          	inc d
0051++ 160F 0A 04 16    	jmp _strchr_L0
0052++ 1612             _strchr_end:
0053++ 1612 1B          	mov al, bl
0054++ 1613 09          	ret
0055++ 1614             
0056++ 1614             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 1614             ; _strstr
0058++ 1614             ; find sub-string
0059++ 1614             ; str1 in SI
0060++ 1614             ; str2 in DI
0061++ 1614             ; SI points to end of source string
0062++ 1614             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 1614             _strstr:
0064++ 1614 DB          	push al
0065++ 1615 DA          	push d
0066++ 1616 E3          	push di
0067++ 1617             _strstr_loop:
0068++ 1617 F3          	cmpsb					; compare a byte of the strings
0069++ 1618 C7 23 16    	jne _strstr_ret
0070++ 161B FC 00 00    	lea d, [di + 0]
0071++ 161E BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1620 C7 17 16    	jne _strstr_loop				; equal chars but not at end
0073++ 1623             _strstr_ret:
0074++ 1623 F0          	pop di
0075++ 1624 E7          	pop d
0076++ 1625 E8          	pop al
0077++ 1626 09          	ret
0078++ 1627             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1627             ; length of null terminated string
0080++ 1627             ; result in C
0081++ 1627             ; pointer in D
0082++ 1627             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1627             _strlen:
0084++ 1627 DA          	push d
0085++ 1628 38 00 00    	mov c, 0
0086++ 162B             _strlen_L1:
0087++ 162B BD 00       	cmp byte [d], 0
0088++ 162D C6 35 16    	je _strlen_ret
0089++ 1630 79          	inc d
0090++ 1631 78          	inc c
0091++ 1632 0A 2B 16    	jmp _strlen_L1
0092++ 1635             _strlen_ret:
0093++ 1635 E7          	pop d
0094++ 1636 09          	ret
0095++ 1637             
0096++ 1637             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1637             ; STRCMP
0098++ 1637             ; compare two strings
0099++ 1637             ; str1 in SI
0100++ 1637             ; str2 in DI
0101++ 1637             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 1637             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1637             _strcmp:
0104++ 1637 DB          	push al
0105++ 1638 DA          	push d
0106++ 1639 E3          	push di
0107++ 163A E2          	push si
0108++ 163B             _strcmp_loop:
0109++ 163B F3          	cmpsb					; compare a byte of the strings
0110++ 163C C7 47 16    	jne _strcmp_ret
0111++ 163F FB FF FF    	lea d, [si +- 1]
0112++ 1642 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1644 C7 3B 16    	jne _strcmp_loop				; equal chars but not at end
0114++ 1647             _strcmp_ret:
0115++ 1647 EF          	pop si
0116++ 1648 F0          	pop di
0117++ 1649 E7          	pop d
0118++ 164A E8          	pop al
0119++ 164B 09          	ret
0120++ 164C             
0121++ 164C             
0122++ 164C             ; STRCPY
0123++ 164C             ; copy null terminated string from SI to DI
0124++ 164C             ; source in SI
0125++ 164C             ; destination in DI
0126++ 164C             _strcpy:
0127++ 164C E2          	push si
0128++ 164D E3          	push di
0129++ 164E DB          	push al
0130++ 164F             _strcpy_L1:
0131++ 164F F6          	lodsb
0132++ 1650 F7          	stosb
0133++ 1651 B9 00       	cmp al, 0
0134++ 1653 C7 4F 16    	jne _strcpy_L1
0135++ 1656             _strcpy_end:
0136++ 1656 E8          	pop al
0137++ 1657 F0          	pop di
0138++ 1658 EF          	pop si
0139++ 1659 09          	ret
0140++ 165A             
0141++ 165A             ; STRCAT
0142++ 165A             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 165A             ; source in SI
0144++ 165A             ; destination in DI
0145++ 165A             _strcat:
0146++ 165A E2          	push si
0147++ 165B E3          	push di
0148++ 165C D7          	push a
0149++ 165D DA          	push d
0150++ 165E 50          	mov a, di
0151++ 165F 3C          	mov d, a
0152++ 1660             _strcat_goto_end_L1:
0153++ 1660 BD 00       	cmp byte[d], 0
0154++ 1662 C6 69 16    	je _strcat_start
0155++ 1665 79          	inc d
0156++ 1666 0A 60 16    	jmp _strcat_goto_end_L1
0157++ 1669             _strcat_start:
0158++ 1669 FD 50       	mov di, d
0159++ 166B             _strcat_L1:
0160++ 166B F6          	lodsb
0161++ 166C F7          	stosb
0162++ 166D B9 00       	cmp al, 0
0163++ 166F C7 6B 16    	jne _strcat_L1
0164++ 1672             _strcat_end:
0165++ 1672 E7          	pop d
0166++ 1673 E4          	pop a
0167++ 1674 F0          	pop di
0168++ 1675 EF          	pop si
0169++ 1676 09          	ret
0170++ 1677             
0171++ 1677             
0005+  1677             
0006+  1677             ;-----------------------------------------------------------------------------
0007+  1677             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0008+  1677             ; ASCII in BL
0009+  1677             ; result in AL
0010+  1677             ; ascii for F = 0100 0110
0011+  1677             ; ascii for 9 = 0011 1001
0012+  1677             ;-----------------------------------------------------------------------------
0013+  1677             hex_ascii_encode:
0014+  1677 1B            mov al, bl
0015+  1678 93 40         test al, $40        ; test if letter or number
0016+  167A C7 80 16      jnz hex_letter
0017+  167D 87 0F         and al, $0F        ; get number
0018+  167F 09            ret
0019+  1680             hex_letter:
0020+  1680 87 0F         and al, $0F        ; get letter
0021+  1682 6A 09         add al, 9
0022+  1684 09            ret
0023+  1685             
0024+  1685             ;-----------------------------------------------------------------------------
0025+  1685             ; ATOI
0026+  1685             ; 2 letter hex string in B
0027+  1685             ; 8bit integer returned in AL
0028+  1685             ;-----------------------------------------------------------------------------
0029+  1685             _atoi:
0030+  1685 D8            push b
0031+  1686 07 77 16      call hex_ascii_encode      ; convert BL to 4bit code in AL
0032+  1689 30            mov bl, bh
0033+  168A DB            push al          ; save a
0034+  168B 07 77 16      call hex_ascii_encode
0035+  168E EA            pop bl  
0036+  168F FD 9E 04      shl al, 4
0037+  1692 8C            or al, bl
0038+  1693 E5            pop b
0039+  1694 09            ret  
0040+  1695             
0041+  1695             
0042+  1695             ;-----------------------------------------------------------------------------
0043+  1695             ; ITOA
0044+  1695             ; 8bit value in BL
0045+  1695             ; 2 byte ASCII result in A
0046+  1695             ;-----------------------------------------------------------------------------
0047+  1695             _itoa:
0048+  1695 DA            push d
0049+  1696 D8            push b
0050+  1697 A7 00         mov bh, 0
0051+  1699 FD A4 04      shr bl, 4  
0052+  169C 74            mov d, b
0053+  169D 1F 45 19      mov al, [d + s_hex_digits]
0054+  16A0 23            mov ah, al
0055+  16A1               
0056+  16A1 E5            pop b
0057+  16A2 D8            push b
0058+  16A3 A7 00         mov bh, 0
0059+  16A5 FD 87 0F      and bl, $0F
0060+  16A8 74            mov d, b
0061+  16A9 1F 45 19      mov al, [d + s_hex_digits]
0062+  16AC E5            pop b
0063+  16AD E7            pop d
0064+  16AE 09            ret
0065+  16AF             
0066+  16AF             ;-----------------------------------------------------------------------------
0067+  16AF             ; HEX STRING TO BINARY
0068+  16AF             ; di = destination address
0069+  16AF             ; si = source
0070+  16AF             ;-----------------------------------------------------------------------------
0071+  16AF             _hex_to_int:
0072+  16AF             _hex_to_int_L1:
0073+  16AF F6            lodsb          ; load from [SI] to AL
0074+  16B0 B9 00         cmp al, 0        ; check if ASCII 0
0075+  16B2 C6 BF 16      jz _hex_to_int_ret
0076+  16B5 36            mov bh, al
0077+  16B6 F6            lodsb
0078+  16B7 2F            mov bl, al
0079+  16B8 07 85 16      call _atoi        ; convert ASCII byte in B to int (to AL)
0080+  16BB F7            stosb          ; store AL to [DI]
0081+  16BC 0A AF 16      jmp _hex_to_int_L1
0082+  16BF             _hex_to_int_ret:
0083+  16BF 09            ret    
0084+  16C0             
0085+  16C0             ;-----------------------------------------------------------------------------
0086+  16C0             ; GETCHAR
0087+  16C0             ; char in ah
0088+  16C0             ;-----------------------------------------------------------------------------
0089+  16C0             getch:
0090+  16C0 DB            push al
0091+  16C1             getch_retry:
0092+  16C1 19 01         mov al, 1
0093+  16C3 05 03         syscall sys_io      ; receive in AH
0094+  16C5 E8            pop al
0095+  16C6 09            ret
0096+  16C7             
0097+  16C7             ;-----------------------------------------------------------------------------
0098+  16C7             ; PUTCHAR
0099+  16C7             ; char in ah
0100+  16C7             ;-----------------------------------------------------------------------------
0101+  16C7             _putchar:
0102+  16C7 D7            push a
0103+  16C8 19 00         mov al, 0
0104+  16CA 05 03         syscall sys_io      ; char in AH
0105+  16CC E4            pop a
0106+  16CD 09            ret
0107+  16CE             
0108+  16CE             ;-----------------------------------------------------------------------------
0109+  16CE             ;; INPUT A STRING
0110+  16CE             ;; terminates with null
0111+  16CE             ;; pointer in D
0112+  16CE             ;-----------------------------------------------------------------------------
0113+  16CE             _gets:
0114+  16CE D7            push a
0115+  16CF DA            push d
0116+  16D0             _gets_loop:
0117+  16D0 19 01         mov al, 1
0118+  16D2 05 03         syscall sys_io      ; receive in AH
0119+  16D4 B9 00         cmp al, 0        ; check error code (AL)
0120+  16D6 C6 D0 16      je _gets_loop      ; if no char received, retry
0121+  16D9             
0122+  16D9 76 1B         cmp ah, 27
0123+  16DB C6 FC 16      je _gets_ansi_esc
0124+  16DE 76 0A         cmp ah, $0A        ; LF
0125+  16E0 C6 67 17      je _gets_end
0126+  16E3 76 0D         cmp ah, $0D        ; CR
0127+  16E5 C6 67 17      je _gets_end
0128+  16E8 76 5C         cmp ah, $5C        ; '\\'
0129+  16EA C6 28 17      je _gets_escape
0130+  16ED               
0131+  16ED 76 08         cmp ah, $08      ; check for backspace
0132+  16EF C6 F8 16      je _gets_backspace
0133+  16F2             
0134+  16F2 1A            mov al, ah
0135+  16F3 3E            mov [d], al
0136+  16F4 79            inc d
0137+  16F5 0A D0 16      jmp _gets_loop
0138+  16F8             _gets_backspace:
0139+  16F8 7F            dec d
0140+  16F9 0A D0 16      jmp _gets_loop
0141+  16FC             _gets_ansi_esc:
0142+  16FC 19 01         mov al, 1
0143+  16FE 05 03         syscall sys_io        ; receive in AH without echo
0144+  1700 B9 00         cmp al, 0          ; check error code (AL)
0145+  1702 C6 FC 16      je _gets_ansi_esc    ; if no char received, retry
0146+  1705 76 5B         cmp ah, '['
0147+  1707 C7 D0 16      jne _gets_loop
0148+  170A             _gets_ansi_esc_2:
0149+  170A 19 01         mov al, 1
0150+  170C 05 03         syscall sys_io          ; receive in AH without echo
0151+  170E B9 00         cmp al, 0            ; check error code (AL)
0152+  1710 C6 0A 17      je _gets_ansi_esc_2  ; if no char received, retry
0153+  1713 76 44         cmp ah, 'D'
0154+  1715 C6 20 17      je _gets_left_arrow
0155+  1718 76 43         cmp ah, 'C'
0156+  171A C6 24 17      je _gets_right_arrow
0157+  171D 0A D0 16      jmp _gets_loop
0158+  1720             _gets_left_arrow:
0159+  1720 7F            dec d
0160+  1721 0A D0 16      jmp _gets_loop
0161+  1724             _gets_right_arrow:
0162+  1724 79            inc d
0163+  1725 0A D0 16      jmp _gets_loop
0164+  1728             _gets_escape:
0165+  1728 19 01         mov al, 1
0166+  172A 05 03         syscall sys_io      ; receive in AH
0167+  172C B9 00         cmp al, 0        ; check error code (AL)
0168+  172E C6 28 17      je _gets_escape      ; if no char received, retry
0169+  1731 76 6E         cmp ah, 'n'
0170+  1733 C6 52 17      je _gets_LF
0171+  1736 76 72         cmp ah, 'r'
0172+  1738 C6 59 17      je _gets_CR
0173+  173B 76 30         cmp ah, '0'
0174+  173D C6 60 17      je _gets_NULL
0175+  1740 76 5C         cmp ah, $5C  ; '\'
0176+  1742 C6 4B 17      je _gets_slash
0177+  1745 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0178+  1746 3E            mov [d], al
0179+  1747 79            inc d
0180+  1748 0A D0 16      jmp _gets_loop
0181+  174B             _gets_slash:
0182+  174B 19 5C         mov al, $5C
0183+  174D 3E            mov [d], al
0184+  174E 79            inc d
0185+  174F 0A D0 16      jmp _gets_loop
0186+  1752             _gets_LF:
0187+  1752 19 0A         mov al, $0A
0188+  1754 3E            mov [d], al
0189+  1755 79            inc d
0190+  1756 0A D0 16      jmp _gets_loop
0191+  1759             _gets_CR:
0192+  1759 19 0D         mov al, $0D
0193+  175B 3E            mov [d], al
0194+  175C 79            inc d
0195+  175D 0A D0 16      jmp _gets_loop
0196+  1760             _gets_NULL:
0197+  1760 19 00         mov al, $00
0198+  1762 3E            mov [d], al
0199+  1763 79            inc d
0200+  1764 0A D0 16      jmp _gets_loop
0201+  1767             _gets_end:
0202+  1767 19 00         mov al, 0
0203+  1769 3E            mov [d], al        ; terminate string
0204+  176A E7            pop d
0205+  176B E4            pop a
0206+  176C 09            ret
0207+  176D             
0208+  176D             ;-----------------------------------------------------------------------------
0209+  176D             ;; INPUT TEXT
0210+  176D             ;; terminated with CTRL+D
0211+  176D             ;; pointer in D
0212+  176D             ;-----------------------------------------------------------------------------
0213+  176D             _gettxt:
0214+  176D D7            push a
0215+  176E DA            push d
0216+  176F             _gettxt_loop:
0217+  176F 19 01         mov al, 1
0218+  1771 05 03         syscall sys_io      ; receive in AH
0219+  1773 B9 00         cmp al, 0        ; check error code (AL)
0220+  1775 C6 6F 17      je _gettxt_loop    ; if no char received, retry
0221+  1778 76 04         cmp ah, 4      ; EOT
0222+  177A C6 B8 17      je _gettxt_end
0223+  177D 76 08         cmp ah, $08      ; check for backspace
0224+  177F C6 B4 17      je _gettxt_backspace
0225+  1782 76 5C         cmp ah, $5C        ; '\'
0226+  1784 C6 8D 17      je _gettxt_escape
0227+  1787 1A            mov al, ah
0228+  1788 3E            mov [d], al
0229+  1789 79            inc d
0230+  178A 0A 6F 17      jmp _gettxt_loop
0231+  178D             _gettxt_escape:
0232+  178D 19 01         mov al, 1
0233+  178F 05 03         syscall sys_io      ; receive in AH
0234+  1791 B9 00         cmp al, 0        ; check error code (AL)
0235+  1793 C6 8D 17      je _gettxt_escape    ; if no char received, retry
0236+  1796 76 6E         cmp ah, 'n'
0237+  1798 C6 A6 17      je _gettxt_LF
0238+  179B 76 72         cmp ah, 'r'
0239+  179D C6 AD 17      je _gettxt_CR
0240+  17A0 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0241+  17A1 3E            mov [d], al
0242+  17A2 79            inc d
0243+  17A3 0A 6F 17      jmp _gettxt_loop
0244+  17A6             _gettxt_LF:
0245+  17A6 19 0A         mov al, $0A
0246+  17A8 3E            mov [d], al
0247+  17A9 79            inc d
0248+  17AA 0A 6F 17      jmp _gettxt_loop
0249+  17AD             _gettxt_CR:
0250+  17AD 19 0D         mov al, $0D
0251+  17AF 3E            mov [d], al
0252+  17B0 79            inc d
0253+  17B1 0A 6F 17      jmp _gettxt_loop
0254+  17B4             _gettxt_backspace:
0255+  17B4 7F            dec d
0256+  17B5 0A 6F 17      jmp _gettxt_loop
0257+  17B8             _gettxt_end:
0258+  17B8 19 00         mov al, 0
0259+  17BA 3E            mov [d], al        ; terminate string
0260+  17BB E7            pop d
0261+  17BC E4            pop a
0262+  17BD 09            ret
0263+  17BE             
0264+  17BE             ;-----------------------------------------------------------------------------
0265+  17BE             ; PRINT NEW LINE
0266+  17BE             ;-----------------------------------------------------------------------------
0267+  17BE             printnl:
0268+  17BE D7            push a
0269+  17BF 10 00 0A      mov a, $0A00
0270+  17C2 05 03         syscall sys_io
0271+  17C4 10 00 0D      mov a, $0D00
0272+  17C7 05 03         syscall sys_io
0273+  17C9 E4            pop a
0274+  17CA 09            ret
0275+  17CB             
0276+  17CB             ;-----------------------------------------------------------------------------
0277+  17CB             ; _strtoint
0278+  17CB             ; 4 digit hex string number in d
0279+  17CB             ; integer returned in A
0280+  17CB             ;-----------------------------------------------------------------------------
0281+  17CB             _strtointx:
0282+  17CB D8            push b
0283+  17CC 32            mov bl, [d]
0284+  17CD 37            mov bh, bl
0285+  17CE 33 01 00      mov bl, [d + 1]
0286+  17D1 07 85 16      call _atoi        ; convert to int in AL
0287+  17D4 23            mov ah, al        ; move to AH
0288+  17D5 33 02 00      mov bl, [d + 2]
0289+  17D8 37            mov bh, bl
0290+  17D9 33 03 00      mov bl, [d + 3]
0291+  17DC 07 85 16      call _atoi        ; convert to int in AL
0292+  17DF E5            pop b
0293+  17E0 09            ret
0294+  17E1             
0295+  17E1             ;-----------------------------------------------------------------------------
0296+  17E1             ; _strtoint
0297+  17E1             ; 5 digit base10 string number in d
0298+  17E1             ; integer returned in A
0299+  17E1             ;-----------------------------------------------------------------------------
0300+  17E1             _strtoint:
0301+  17E1 E2            push si
0302+  17E2 D8            push b
0303+  17E3 D9            push c
0304+  17E4 DA            push d
0305+  17E5 07 27 16      call _strlen      ; get string length in C
0306+  17E8 7E            dec c
0307+  17E9 FD 4E         mov si, d
0308+  17EB 12            mov a, c
0309+  17EC FD 99         shl a
0310+  17EE 3B 5D 19      mov d, table_power
0311+  17F1 59            add d, a
0312+  17F2 38 00 00      mov c, 0
0313+  17F5             _strtoint_L0:
0314+  17F5 F6            lodsb      ; load ASCII to al
0315+  17F6 B9 00         cmp al, 0
0316+  17F8 C6 0B 18      je _strtoint_end
0317+  17FB 6F 30         sub al, $30    ; make into integer
0318+  17FD 22 00         mov ah, 0
0319+  17FF 2A            mov b, [d]
0320+  1800 AC            mul a, b      ; result in B since it fits in 16bits
0321+  1801 11            mov a, b
0322+  1802 28            mov b, c
0323+  1803 54            add a, b
0324+  1804 39            mov c, a
0325+  1805 63 02 00      sub d, 2
0326+  1808 0A F5 17      jmp _strtoint_L0
0327+  180B             _strtoint_end:
0328+  180B 12            mov a, c
0329+  180C E7            pop d
0330+  180D E6            pop c
0331+  180E E5            pop b
0332+  180F EF            pop si
0333+  1810 09            ret
0334+  1811             
0335+  1811             ;-----------------------------------------------------------------------------
0336+  1811             ; PRINT NULL TERMINATED STRING
0337+  1811             ; pointer in D
0338+  1811             ;-----------------------------------------------------------------------------
0339+  1811             _puts:
0340+  1811 D7            push a
0341+  1812 DA            push d
0342+  1813             _puts_L1:
0343+  1813 1E            mov al, [d]
0344+  1814 B9 00         cmp al, 0
0345+  1816 C6 22 18      jz _puts_END
0346+  1819 23            mov ah, al
0347+  181A 19 00         mov al, 0
0348+  181C 05 03         syscall sys_io
0349+  181E 79            inc d
0350+  181F 0A 13 18      jmp _puts_L1
0351+  1822             _puts_END:
0352+  1822 E7            pop d
0353+  1823 E4            pop a
0354+  1824 09            ret
0355+  1825             
0356+  1825             ;-----------------------------------------------------------------------------
0357+  1825             ; PRINT N SIZE STRING
0358+  1825             ; pointer in D
0359+  1825             ; size in C
0360+  1825             ;-----------------------------------------------------------------------------
0361+  1825             _putsn:
0362+  1825 DB            push al
0363+  1826 DA            push d
0364+  1827 D9            push c
0365+  1828             _putsn_L0:
0366+  1828 1E            mov al, [d]
0367+  1829 23            mov ah, al
0368+  182A 19 00         mov al, 0
0369+  182C 05 03         syscall sys_io
0370+  182E 79            inc d
0371+  182F 7E            dec c  
0372+  1830 C2 00 00      cmp c, 0
0373+  1833 C7 28 18      jne _putsn_L0
0374+  1836             _putsn_end:
0375+  1836 E6            pop c
0376+  1837 E7            pop d
0377+  1838 E8            pop al
0378+  1839 09            ret
0379+  183A             
0380+  183A             ;-----------------------------------------------------------------------------
0381+  183A             ; print 16bit decimal number
0382+  183A             ; input number in A
0383+  183A             ;-----------------------------------------------------------------------------
0384+  183A             print_u16d:
0385+  183A D7            push a
0386+  183B D8            push b
0387+  183C 26 10 27      mov b, 10000
0388+  183F AE            div a, b      ; get 10000's coeff.
0389+  1840 07 62 18      call print_number
0390+  1843 11            mov a, b
0391+  1844 26 E8 03      mov b, 1000
0392+  1847 AE            div a, b      ; get 1000's coeff.
0393+  1848 07 62 18      call print_number
0394+  184B 11            mov a, b
0395+  184C 26 64 00      mov b, 100
0396+  184F AE            div a, b
0397+  1850 07 62 18      call print_number
0398+  1853 11            mov a, b
0399+  1854 26 0A 00      mov b, 10
0400+  1857 AE            div a, b
0401+  1858 07 62 18      call print_number
0402+  185B 1B            mov al, bl      ; 1's coeff in bl
0403+  185C 07 62 18      call print_number
0404+  185F E5            pop b
0405+  1860 E4            pop a
0406+  1861 09            ret
0407+  1862             
0408+  1862             ;-----------------------------------------------------------------------------
0409+  1862             ; print AL
0410+  1862             ;-----------------------------------------------------------------------------
0411+  1862             print_number:
0412+  1862 6A 30         add al, $30
0413+  1864 23            mov ah, al
0414+  1865 07 C7 16      call _putchar
0415+  1868 09            ret
0416+  1869             
0417+  1869             ;-----------------------------------------------------------------------------
0418+  1869             ; PRINT 16BIT HEX INTEGER
0419+  1869             ; integer value in reg B
0420+  1869             ;-----------------------------------------------------------------------------
0421+  1869             print_u16x:
0422+  1869 D7            push a
0423+  186A D8            push b
0424+  186B DD            push bl
0425+  186C 30            mov bl, bh
0426+  186D 07 95 16      call _itoa        ; convert bh to char in A
0427+  1870 2F            mov bl, al        ; save al
0428+  1871 19 00         mov al, 0
0429+  1873 05 03         syscall sys_io        ; display AH
0430+  1875 24            mov ah, bl        ; retrieve al
0431+  1876 19 00         mov al, 0
0432+  1878 05 03         syscall sys_io        ; display AL
0433+  187A             
0434+  187A EA            pop bl
0435+  187B 07 95 16      call _itoa        ; convert bh to char in A
0436+  187E 2F            mov bl, al        ; save al
0437+  187F 19 00         mov al, 0
0438+  1881 05 03         syscall sys_io        ; display AH
0439+  1883 24            mov ah, bl        ; retrieve al
0440+  1884 19 00         mov al, 0
0441+  1886 05 03         syscall sys_io        ; display AL
0442+  1888             
0443+  1888 E5            pop b
0444+  1889 E4            pop a
0445+  188A 09            ret
0446+  188B             
0447+  188B             ;-----------------------------------------------------------------------------
0448+  188B             ; INPUT 16BIT HEX INTEGER
0449+  188B             ; read 16bit integer into A
0450+  188B             ;-----------------------------------------------------------------------------
0451+  188B             scan_u16x:
0452+  188B F8 10 00      enter 16
0453+  188E D8            push b
0454+  188F DA            push d
0455+  1890             
0456+  1890 FA F1 FF      lea d, [bp + -15]
0457+  1893 07 CE 16      call _gets        ; get number
0458+  1896             
0459+  1896 32            mov bl, [d]
0460+  1897 37            mov bh, bl
0461+  1898 33 01 00      mov bl, [d + 1]
0462+  189B 07 85 16      call _atoi        ; convert to int in AL
0463+  189E 23            mov ah, al        ; move to AH
0464+  189F             
0465+  189F 33 02 00      mov bl, [d + 2]
0466+  18A2 37            mov bh, bl
0467+  18A3 33 03 00      mov bl, [d + 3]
0468+  18A6 07 85 16      call _atoi        ; convert to int in AL
0469+  18A9             
0470+  18A9 E7            pop d
0471+  18AA E5            pop b
0472+  18AB F9            leave
0473+  18AC 09            ret
0474+  18AD             
0475+  18AD             ;-----------------------------------------------------------------------------
0476+  18AD             ; PRINT 8bit HEX INTEGER
0477+  18AD             ; integer value in reg bl
0478+  18AD             ;-----------------------------------------------------------------------------
0479+  18AD             print_u8x:
0480+  18AD D7            push a
0481+  18AE DD            push bl
0482+  18AF             
0483+  18AF 07 95 16      call _itoa        ; convert bl to char in A
0484+  18B2 2F            mov bl, al        ; save al
0485+  18B3 19 00         mov al, 0
0486+  18B5 05 03         syscall sys_io        ; display AH
0487+  18B7 24            mov ah, bl        ; retrieve al
0488+  18B8 19 00         mov al, 0
0489+  18BA 05 03         syscall sys_io        ; display AL
0490+  18BC             
0491+  18BC EA            pop bl
0492+  18BD E4            pop a
0493+  18BE 09            ret
0494+  18BF             
0495+  18BF             ;-----------------------------------------------------------------------------
0496+  18BF             ; print 8bit decimal unsigned number
0497+  18BF             ; input number in AL
0498+  18BF             ;-----------------------------------------------------------------------------
0499+  18BF             print_u8d:
0500+  18BF D7            push a
0501+  18C0 D8            push b
0502+  18C1             
0503+  18C1 22 00         mov ah, 0
0504+  18C3 26 64 00      mov b, 100
0505+  18C6 AE            div a, b
0506+  18C7 D8            push b      ; save remainder
0507+  18C8 B9 00         cmp al, 0
0508+  18CA C6 D4 18      je skip100
0509+  18CD 6A 30         add al, $30
0510+  18CF 23            mov ah, al
0511+  18D0 19 00         mov al, 0
0512+  18D2 05 03         syscall sys_io  ; print coeff
0513+  18D4             skip100:
0514+  18D4 E4            pop a
0515+  18D5 22 00         mov ah, 0
0516+  18D7 26 0A 00      mov b, 10
0517+  18DA AE            div a, b
0518+  18DB D8            push b      ; save remainder
0519+  18DC B9 00         cmp al, 0
0520+  18DE C6 E8 18      je skip10
0521+  18E1 6A 30         add al, $30
0522+  18E3 23            mov ah, al
0523+  18E4 19 00         mov al, 0
0524+  18E6 05 03         syscall sys_io  ; print coeff
0525+  18E8             skip10:
0526+  18E8 E4            pop a
0527+  18E9 1B            mov al, bl
0528+  18EA 6A 30         add al, $30
0529+  18EC 23            mov ah, al
0530+  18ED 19 00         mov al, 0
0531+  18EF 05 03         syscall sys_io  ; print coeff
0532+  18F1 E5            pop b
0533+  18F2 E4            pop a
0534+  18F3 09            ret
0535+  18F4             
0536+  18F4             ;-----------------------------------------------------------------------------
0537+  18F4             ; INPUT 8BIT HEX INTEGER
0538+  18F4             ; read 8bit integer into AL
0539+  18F4             ;-----------------------------------------------------------------------------
0540+  18F4             scan_u8x:
0541+  18F4 F8 04 00      enter 4
0542+  18F7 D8            push b
0543+  18F8 DA            push d
0544+  18F9             
0545+  18F9 FA FD FF      lea d, [bp + -3]
0546+  18FC 07 CE 16      call _gets        ; get number
0547+  18FF             
0548+  18FF 32            mov bl, [d]
0549+  1900 37            mov bh, bl
0550+  1901 33 01 00      mov bl, [d + 1]
0551+  1904 07 85 16      call _atoi        ; convert to int in AL
0552+  1907             
0553+  1907 E7            pop d
0554+  1908 E5            pop b
0555+  1909 F9            leave
0556+  190A 09            ret
0557+  190B             
0558+  190B             ;-----------------------------------------------------------------------------
0559+  190B             ; input decimal number
0560+  190B             ; result in A
0561+  190B             ; 655'\0'
0562+  190B             ; low--------high
0563+  190B             ;-----------------------------------------------------------------------------
0564+  190B             scan_u16d:
0565+  190B F8 08 00      enter 8
0566+  190E E2            push si
0567+  190F D8            push b
0568+  1910 D9            push c
0569+  1911 DA            push d
0570+  1912 FA F9 FF      lea d, [bp +- 7]
0571+  1915 07 CE 16      call _gets
0572+  1918 07 27 16      call _strlen      ; get string length in C
0573+  191B 7E            dec c
0574+  191C FD 4E         mov si, d
0575+  191E 12            mov a, c
0576+  191F FD 99         shl a
0577+  1921 3B 5D 19      mov d, table_power
0578+  1924 59            add d, a
0579+  1925 38 00 00      mov c, 0
0580+  1928             mul_loop:
0581+  1928 F6            lodsb      ; load ASCII to al
0582+  1929 B9 00         cmp al, 0
0583+  192B C6 3E 19      je mul_exit
0584+  192E 6F 30         sub al, $30    ; make into integer
0585+  1930 22 00         mov ah, 0
0586+  1932 2A            mov b, [d]
0587+  1933 AC            mul a, b      ; result in B since it fits in 16bits
0588+  1934 11            mov a, b
0589+  1935 28            mov b, c
0590+  1936 54            add a, b
0591+  1937 39            mov c, a
0592+  1938 63 02 00      sub d, 2
0593+  193B 0A 28 19      jmp mul_loop
0594+  193E             mul_exit:
0595+  193E 12            mov a, c
0596+  193F E7            pop d
0597+  1940 E6            pop c
0598+  1941 E5            pop b
0599+  1942 EF            pop si
0600+  1943 F9            leave
0601+  1944 09            ret
0602+  1945             
0603+  1945 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0603+  1949 34 35 36 37 
0603+  194D 38 39 41 42 
0603+  1951 43 44 45 46 
0604+  1955 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0604+  1959 1B 5B 48 00 
0605+  195D             
0606+  195D             table_power:
0607+  195D 01 00         .dw 1
0608+  195F 0A 00         .dw 10
0609+  1961 64 00         .dw 100
0610+  1963 E8 03         .dw 1000
0611+  1965 10 27         .dw 100002756   1967             ; --- END INLINE ASM BLOCK
2757   1967             
2758   1967 F9            leave
2759   1968 09            ret
2760   1969             
2761   1969             base64_char_value:
2762   1969 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2763   196C             ;; if (c >= 'A' && c <= 'Z') return c - 'A'; 
2764   196C             _if42_cond:
2765   196C FA 05 00      lea d, [bp + 5] ; $c
2766   196F 32            mov bl, [d]
2767   1970 A7 00         mov bh, 0
2768   1972             ; START RELATIONAL
2769   1972 D7            push a
2770   1973 11            mov a, b
2771   1974 26 41 00      mov b, $41
2772   1977 B0            cmp a, b
2773   1978 FD 80         sge ; >=
2774   197A E4            pop a
2775   197B             ; END RELATIONAL
2776   197B             ; START LOGICAL AND
2777   197B D7            push a
2778   197C 11            mov a, b
2779   197D FA 05 00      lea d, [bp + 5] ; $c
2780   1980 32            mov bl, [d]
2781   1981 A7 00         mov bh, 0
2782   1983             ; START RELATIONAL
2783   1983 D7            push a
2784   1984 11            mov a, b
2785   1985 26 5A 00      mov b, $5a
2786   1988 B0            cmp a, b
2787   1989 FD 74         sle ; <= (signed)
2788   198B E4            pop a
2789   198C             ; END RELATIONAL
2790   198C FD A7         sand a, b
2791   198E E4            pop a
2792   198F             ; END LOGICAL AND
2793   198F C0 00 00      cmp b, 0
2794   1992 C6 A8 19      je _if42_exit
2795   1995             _if42_true:
2796   1995             ;; return c - 'A'; 
2797   1995 FA 05 00      lea d, [bp + 5] ; $c
2798   1998 32            mov bl, [d]
2799   1999 A7 00         mov bh, 0
2800   199B             ; START TERMS
2801   199B D7            push a
2802   199C 11            mov a, b
2803   199D 26 41 00      mov b, $41
2804   19A0 60            sub a, b
2805   19A1 27            mov b, a
2806   19A2 E4            pop a
2807   19A3             ; END TERMS
2808   19A3 F9            leave
2809   19A4 09            ret
2810   19A5 0A A8 19      jmp _if42_exit
2811   19A8             _if42_exit:
2812   19A8             ;; if (c >= 'a' && c <= 'z') return c - 'a' + 26; 
2813   19A8             _if43_cond:
2814   19A8 FA 05 00      lea d, [bp + 5] ; $c
2815   19AB 32            mov bl, [d]
2816   19AC A7 00         mov bh, 0
2817   19AE             ; START RELATIONAL
2818   19AE D7            push a
2819   19AF 11            mov a, b
2820   19B0 26 61 00      mov b, $61
2821   19B3 B0            cmp a, b
2822   19B4 FD 80         sge ; >=
2823   19B6 E4            pop a
2824   19B7             ; END RELATIONAL
2825   19B7             ; START LOGICAL AND
2826   19B7 D7            push a
2827   19B8 11            mov a, b
2828   19B9 FA 05 00      lea d, [bp + 5] ; $c
2829   19BC 32            mov bl, [d]
2830   19BD A7 00         mov bh, 0
2831   19BF             ; START RELATIONAL
2832   19BF D7            push a
2833   19C0 11            mov a, b
2834   19C1 26 7A 00      mov b, $7a
2835   19C4 B0            cmp a, b
2836   19C5 FD 74         sle ; <= (signed)
2837   19C7 E4            pop a
2838   19C8             ; END RELATIONAL
2839   19C8 FD A7         sand a, b
2840   19CA E4            pop a
2841   19CB             ; END LOGICAL AND
2842   19CB C0 00 00      cmp b, 0
2843   19CE C6 E9 19      je _if43_exit
2844   19D1             _if43_true:
2845   19D1             ;; return c - 'a' + 26; 
2846   19D1 FA 05 00      lea d, [bp + 5] ; $c
2847   19D4 32            mov bl, [d]
2848   19D5 A7 00         mov bh, 0
2849   19D7             ; START TERMS
2850   19D7 D7            push a
2851   19D8 11            mov a, b
2852   19D9 26 61 00      mov b, $61
2853   19DC 60            sub a, b
2854   19DD 27            mov b, a
2855   19DE 11            mov a, b
2856   19DF 26 1A 00      mov b, $1a
2857   19E2 56            add b, a
2858   19E3 E4            pop a
2859   19E4             ; END TERMS
2860   19E4 F9            leave
2861   19E5 09            ret
2862   19E6 0A E9 19      jmp _if43_exit
2863   19E9             _if43_exit:
2864   19E9             ;; if (c >= '0' && c <= '9') return c - '0' + 52; 
2865   19E9             _if44_cond:
2866   19E9 FA 05 00      lea d, [bp + 5] ; $c
2867   19EC 32            mov bl, [d]
2868   19ED A7 00         mov bh, 0
2869   19EF             ; START RELATIONAL
2870   19EF D7            push a
2871   19F0 11            mov a, b
2872   19F1 26 30 00      mov b, $30
2873   19F4 B0            cmp a, b
2874   19F5 FD 80         sge ; >=
2875   19F7 E4            pop a
2876   19F8             ; END RELATIONAL
2877   19F8             ; START LOGICAL AND
2878   19F8 D7            push a
2879   19F9 11            mov a, b
2880   19FA FA 05 00      lea d, [bp + 5] ; $c
2881   19FD 32            mov bl, [d]
2882   19FE A7 00         mov bh, 0
2883   1A00             ; START RELATIONAL
2884   1A00 D7            push a
2885   1A01 11            mov a, b
2886   1A02 26 39 00      mov b, $39
2887   1A05 B0            cmp a, b
2888   1A06 FD 74         sle ; <= (signed)
2889   1A08 E4            pop a
2890   1A09             ; END RELATIONAL
2891   1A09 FD A7         sand a, b
2892   1A0B E4            pop a
2893   1A0C             ; END LOGICAL AND
2894   1A0C C0 00 00      cmp b, 0
2895   1A0F C6 2A 1A      je _if44_exit
2896   1A12             _if44_true:
2897   1A12             ;; return c - '0' + 52; 
2898   1A12 FA 05 00      lea d, [bp + 5] ; $c
2899   1A15 32            mov bl, [d]
2900   1A16 A7 00         mov bh, 0
2901   1A18             ; START TERMS
2902   1A18 D7            push a
2903   1A19 11            mov a, b
2904   1A1A 26 30 00      mov b, $30
2905   1A1D 60            sub a, b
2906   1A1E 27            mov b, a
2907   1A1F 11            mov a, b
2908   1A20 26 34 00      mov b, $34
2909   1A23 56            add b, a
2910   1A24 E4            pop a
2911   1A25             ; END TERMS
2912   1A25 F9            leave
2913   1A26 09            ret
2914   1A27 0A 2A 1A      jmp _if44_exit
2915   1A2A             _if44_exit:
2916   1A2A             ;; if (c == '+') return 62; 
2917   1A2A             _if45_cond:
2918   1A2A FA 05 00      lea d, [bp + 5] ; $c
2919   1A2D 32            mov bl, [d]
2920   1A2E A7 00         mov bh, 0
2921   1A30             ; START RELATIONAL
2922   1A30 D7            push a
2923   1A31 11            mov a, b
2924   1A32 26 2B 00      mov b, $2b
2925   1A35 B0            cmp a, b
2926   1A36 FD 71         seq ; ==
2927   1A38 E4            pop a
2928   1A39             ; END RELATIONAL
2929   1A39 C0 00 00      cmp b, 0
2930   1A3C C6 47 1A      je _if45_exit
2931   1A3F             _if45_true:
2932   1A3F             ;; return 62; 
2933   1A3F 26 3E 00      mov b, $3e
2934   1A42 F9            leave
2935   1A43 09            ret
2936   1A44 0A 47 1A      jmp _if45_exit
2937   1A47             _if45_exit:
2938   1A47             ;; if (c == '/') return 63; 
2939   1A47             _if46_cond:
2940   1A47 FA 05 00      lea d, [bp + 5] ; $c
2941   1A4A 32            mov bl, [d]
2942   1A4B A7 00         mov bh, 0
2943   1A4D             ; START RELATIONAL
2944   1A4D D7            push a
2945   1A4E 11            mov a, b
2946   1A4F 26 2F 00      mov b, $2f
2947   1A52 B0            cmp a, b
2948   1A53 FD 71         seq ; ==
2949   1A55 E4            pop a
2950   1A56             ; END RELATIONAL
2951   1A56 C0 00 00      cmp b, 0
2952   1A59 C6 64 1A      je _if46_exit
2953   1A5C             _if46_true:
2954   1A5C             ;; return 63; 
2955   1A5C 26 3F 00      mov b, $3f
2956   1A5F F9            leave
2957   1A60 09            ret
2958   1A61 0A 64 1A      jmp _if46_exit
2959   1A64             _if46_exit:
2960   1A64             ;; return -1; 
2961   1A64 26 FF FF      mov b, $ffff
2962   1A67 F9            leave
2963   1A68 09            ret
2964   1A69             
2965   1A69             base64_decode:
2966   1A69 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2967   1A6C             ;; int i = 0, j = 0, k = 0; 
2968   1A6C 52 02 00      sub sp, 2 ; i
2969   1A6F             ; --- START LOCAL VAR INITIALIZATION
2970   1A6F FA FF FF      lea d, [bp + -1] ; $i
2971   1A72 DA            push d
2972   1A73 26 00 00      mov b, $0
2973   1A76 E7            pop d
2974   1A77 FD 43         mov [d], b
2975   1A79             ; --- END LOCAL VAR INITIALIZATION
2976   1A79 52 02 00      sub sp, 2 ; j
2977   1A7C             ; --- START LOCAL VAR INITIALIZATION
2978   1A7C FA FD FF      lea d, [bp + -3] ; $j
2979   1A7F DA            push d
2980   1A80 26 00 00      mov b, $0
2981   1A83 E7            pop d
2982   1A84 FD 43         mov [d], b
2983   1A86             ; --- END LOCAL VAR INITIALIZATION
2984   1A86 52 02 00      sub sp, 2 ; k
2985   1A89             ; --- START LOCAL VAR INITIALIZATION
2986   1A89 FA FB FF      lea d, [bp + -5] ; $k
2987   1A8C DA            push d
2988   1A8D 26 00 00      mov b, $0
2989   1A90 E7            pop d
2990   1A91 FD 43         mov [d], b
2991   1A93             ; --- END LOCAL VAR INITIALIZATION
2992   1A93             ;; int input_len; 
2993   1A93 52 02 00      sub sp, 2 ; input_len
2994   1A96             ;; unsigned char input_buffer[4]; 
2995   1A96 52 04 00      sub sp, 4 ; input_buffer
2996   1A99             ;; unsigned char output_buffer[3]; 
2997   1A99 52 03 00      sub sp, 3 ; output_buffer
2998   1A9C             ;; char a; 
2999   1A9C 52 01 00      sub sp, 1 ; a
3000   1A9F             ;; input_len = strlen(input); 
3001   1A9F FA F9 FF      lea d, [bp + -7] ; $input_len
3002   1AA2 DA            push d
3003   1AA3 FA 05 00      lea d, [bp + 5] ; $input
3004   1AA6 2A            mov b, [d]
3005   1AA7 FD AB         swp b
3006   1AA9 D8            push b
3007   1AAA 07 B2 05      call strlen
3008   1AAD 51 02 00      add sp, 2
3009   1AB0 E7            pop d
3010   1AB1 FD 43         mov [d], b
3011   1AB3             ;; printf("Len: %d\n", input_len); 
3012   1AB3 FA F9 FF      lea d, [bp + -7] ; $input_len
3013   1AB6 2A            mov b, [d]
3014   1AB7 FD AB         swp b
3015   1AB9 D8            push b
3016   1ABA 26 9B 24      mov b, _s4 ; "Len: %d\n"
3017   1ABD FD AB         swp b
3018   1ABF D8            push b
3019   1AC0 07 DC 07      call printf
3020   1AC3 51 04 00      add sp, 4
3021   1AC6             ;; while (input_len-- && (input[k] != '=') && base64_char_value(input[k]) != -1){ 
3022   1AC6             _while47_cond:
3023   1AC6 FA F9 FF      lea d, [bp + -7] ; $input_len
3024   1AC9 2A            mov b, [d]
3025   1ACA FD 7D         dec b
3026   1ACC FA F9 FF      lea d, [bp + -7] ; $input_len
3027   1ACF FD 43         mov [d], b
3028   1AD1 FD 77         inc b
3029   1AD3             ; START LOGICAL AND
3030   1AD3 D7            push a
3031   1AD4 11            mov a, b
3032   1AD5 FA 05 00      lea d, [bp + 5] ; $input
3033   1AD8 FD 2A         mov d, [d]
3034   1ADA D7            push a
3035   1ADB DA            push d
3036   1ADC FA FB FF      lea d, [bp + -5] ; $k
3037   1ADF 2A            mov b, [d]
3038   1AE0 E7            pop d
3039   1AE1 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
3040   1AE5 E4            pop a
3041   1AE6 32            mov bl, [d]
3042   1AE7 A7 00         mov bh, 0
3043   1AE9             ; START RELATIONAL
3044   1AE9 D7            push a
3045   1AEA 11            mov a, b
3046   1AEB 26 3D 00      mov b, $3d
3047   1AEE B0            cmp a, b
3048   1AEF FD 72         sneq ; !=
3049   1AF1 E4            pop a
3050   1AF2             ; END RELATIONAL
3051   1AF2 FD A7         sand a, b
3052   1AF4 11            mov a, b
3053   1AF5 FA 05 00      lea d, [bp + 5] ; $input
3054   1AF8 FD 2A         mov d, [d]
3055   1AFA D7            push a
3056   1AFB DA            push d
3057   1AFC FA FB FF      lea d, [bp + -5] ; $k
3058   1AFF 2A            mov b, [d]
3059   1B00 E7            pop d
3060   1B01 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
3061   1B05 E4            pop a
3062   1B06 32            mov bl, [d]
3063   1B07 A7 00         mov bh, 0
3064   1B09 DD            push bl
3065   1B0A 07 69 19      call base64_char_value
3066   1B0D 51 01 00      add sp, 1
3067   1B10             ; START RELATIONAL
3068   1B10 D7            push a
3069   1B11 11            mov a, b
3070   1B12 26 FF FF      mov b, $ffff
3071   1B15 B0            cmp a, b
3072   1B16 FD 72         sneq ; !=
3073   1B18 E4            pop a
3074   1B19             ; END RELATIONAL
3075   1B19 FD A7         sand a, b
3076   1B1B E4            pop a
3077   1B1C             ; END LOGICAL AND
3078   1B1C C0 00 00      cmp b, 0
3079   1B1F C6 16 1F      je _while47_exit
3080   1B22             _while47_block:
3081   1B22             ;; printf("input_len: %d, i: %d, j: %d, k: %d, input[k]: %c, base64: %d\n", 
3082   1B22 FA 05 00      lea d, [bp + 5] ; $input
3083   1B25 FD 2A         mov d, [d]
3084   1B27 D7            push a
3085   1B28 DA            push d
3086   1B29 FA FB FF      lea d, [bp + -5] ; $k
3087   1B2C 2A            mov b, [d]
3088   1B2D E7            pop d
3089   1B2E FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
3090   1B32 E4            pop a
3091   1B33 32            mov bl, [d]
3092   1B34 A7 00         mov bh, 0
3093   1B36 DD            push bl
3094   1B37 07 69 19      call base64_char_value
3095   1B3A 51 01 00      add sp, 1
3096   1B3D FD AB         swp b
3097   1B3F D8            push b
3098   1B40 FA 05 00      lea d, [bp + 5] ; $input
3099   1B43 FD 2A         mov d, [d]
3100   1B45 D7            push a
3101   1B46 DA            push d
3102   1B47 FA FB FF      lea d, [bp + -5] ; $k
3103   1B4A 2A            mov b, [d]
3104   1B4B E7            pop d
3105   1B4C FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
3106   1B50 E4            pop a
3107   1B51 32            mov bl, [d]
3108   1B52 A7 00         mov bh, 0
3109   1B54 DD            push bl
3110   1B55 FA FB FF      lea d, [bp + -5] ; $k
3111   1B58 2A            mov b, [d]
3112   1B59 FD AB         swp b
3113   1B5B D8            push b
3114   1B5C FA FD FF      lea d, [bp + -3] ; $j
3115   1B5F 2A            mov b, [d]
3116   1B60 FD AB         swp b
3117   1B62 D8            push b
3118   1B63 FA FF FF      lea d, [bp + -1] ; $i
3119   1B66 2A            mov b, [d]
3120   1B67 FD AB         swp b
3121   1B69 D8            push b
3122   1B6A FA F9 FF      lea d, [bp + -7] ; $input_len
3123   1B6D 2A            mov b, [d]
3124   1B6E FD AB         swp b
3125   1B70 D8            push b
3126   1B71 26 A4 24      mov b, _s5 ; "input_len: %d, i: %d, j: %d, k: %d, input[k]: %c, base64: %d\n"
3127   1B74 FD AB         swp b
3128   1B76 D8            push b
3129   1B77 07 DC 07      call printf
3130   1B7A 51 0D 00      add sp, 13
3131   1B7D             ;; printf("Inside while loop. condition: %d\n", input_len-- && (input[k] != '=') && base64_char_value(input[k]) != -1); 
3132   1B7D FA F9 FF      lea d, [bp + -7] ; $input_len
3133   1B80 2A            mov b, [d]
3134   1B81 FD 7D         dec b
3135   1B83 FA F9 FF      lea d, [bp + -7] ; $input_len
3136   1B86 FD 43         mov [d], b
3137   1B88 FD 77         inc b
3138   1B8A             ; START LOGICAL AND
3139   1B8A D7            push a
3140   1B8B 11            mov a, b
3141   1B8C FA 05 00      lea d, [bp + 5] ; $input
3142   1B8F FD 2A         mov d, [d]
3143   1B91 D7            push a
3144   1B92 DA            push d
3145   1B93 FA FB FF      lea d, [bp + -5] ; $k
3146   1B96 2A            mov b, [d]
3147   1B97 E7            pop d
3148   1B98 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
3149   1B9C E4            pop a
3150   1B9D 32            mov bl, [d]
3151   1B9E A7 00         mov bh, 0
3152   1BA0             ; START RELATIONAL
3153   1BA0 D7            push a
3154   1BA1 11            mov a, b
3155   1BA2 26 3D 00      mov b, $3d
3156   1BA5 B0            cmp a, b
3157   1BA6 FD 72         sneq ; !=
3158   1BA8 E4            pop a
3159   1BA9             ; END RELATIONAL
3160   1BA9 FD A7         sand a, b
3161   1BAB 11            mov a, b
3162   1BAC FA 05 00      lea d, [bp + 5] ; $input
3163   1BAF FD 2A         mov d, [d]
3164   1BB1 D7            push a
3165   1BB2 DA            push d
3166   1BB3 FA FB FF      lea d, [bp + -5] ; $k
3167   1BB6 2A            mov b, [d]
3168   1BB7 E7            pop d
3169   1BB8 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
3170   1BBC E4            pop a
3171   1BBD 32            mov bl, [d]
3172   1BBE A7 00         mov bh, 0
3173   1BC0 DD            push bl
3174   1BC1 07 69 19      call base64_char_value
3175   1BC4 51 01 00      add sp, 1
3176   1BC7             ; START RELATIONAL
3177   1BC7 D7            push a
3178   1BC8 11            mov a, b
3179   1BC9 26 FF FF      mov b, $ffff
3180   1BCC B0            cmp a, b
3181   1BCD FD 72         sneq ; !=
3182   1BCF E4            pop a
3183   1BD0             ; END RELATIONAL
3184   1BD0 FD A7         sand a, b
3185   1BD2 E4            pop a
3186   1BD3             ; END LOGICAL AND
3187   1BD3 FD AB         swp b
3188   1BD5 D8            push b
3189   1BD6 26 E2 24      mov b, _s6 ; "Inside while loop. condition: %d\n"
3190   1BD9 FD AB         swp b
3191   1BDB D8            push b
3192   1BDC 07 DC 07      call printf
3193   1BDF 51 04 00      add sp, 4
3194   1BE2             ;; pass = pass && (input_len-- && (input[k] != '=') && base64_char_value(input[k]) != -1); 
3195   1BE2 3B 39 24      mov d, _pass ; $pass
3196   1BE5 DA            push d
3197   1BE6 3B 39 24      mov d, _pass ; $pass
3198   1BE9 2A            mov b, [d]
3199   1BEA             ; START LOGICAL AND
3200   1BEA D7            push a
3201   1BEB 11            mov a, b
3202   1BEC FA F9 FF      lea d, [bp + -7] ; $input_len
3203   1BEF 2A            mov b, [d]
3204   1BF0 FD 7D         dec b
3205   1BF2 FA F9 FF      lea d, [bp + -7] ; $input_len
3206   1BF5 FD 43         mov [d], b
3207   1BF7 FD 77         inc b
3208   1BF9             ; START LOGICAL AND
3209   1BF9 D7            push a
3210   1BFA 11            mov a, b
3211   1BFB FA 05 00      lea d, [bp + 5] ; $input
3212   1BFE FD 2A         mov d, [d]
3213   1C00 D7            push a
3214   1C01 DA            push d
3215   1C02 FA FB FF      lea d, [bp + -5] ; $k
3216   1C05 2A            mov b, [d]
3217   1C06 E7            pop d
3218   1C07 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
3219   1C0B E4            pop a
3220   1C0C 32            mov bl, [d]
3221   1C0D A7 00         mov bh, 0
3222   1C0F             ; START RELATIONAL
3223   1C0F D7            push a
3224   1C10 11            mov a, b
3225   1C11 26 3D 00      mov b, $3d
3226   1C14 B0            cmp a, b
3227   1C15 FD 72         sneq ; !=
3228   1C17 E4            pop a
3229   1C18             ; END RELATIONAL
3230   1C18 FD A7         sand a, b
3231   1C1A 11            mov a, b
3232   1C1B FA 05 00      lea d, [bp + 5] ; $input
3233   1C1E FD 2A         mov d, [d]
3234   1C20 D7            push a
3235   1C21 DA            push d
3236   1C22 FA FB FF      lea d, [bp + -5] ; $k
3237   1C25 2A            mov b, [d]
3238   1C26 E7            pop d
3239   1C27 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
3240   1C2B E4            pop a
3241   1C2C 32            mov bl, [d]
3242   1C2D A7 00         mov bh, 0
3243   1C2F DD            push bl
3244   1C30 07 69 19      call base64_char_value
3245   1C33 51 01 00      add sp, 1
3246   1C36             ; START RELATIONAL
3247   1C36 D7            push a
3248   1C37 11            mov a, b
3249   1C38 26 FF FF      mov b, $ffff
3250   1C3B B0            cmp a, b
3251   1C3C FD 72         sneq ; !=
3252   1C3E E4            pop a
3253   1C3F             ; END RELATIONAL
3254   1C3F FD A7         sand a, b
3255   1C41 E4            pop a
3256   1C42             ; END LOGICAL AND
3257   1C42 FD A7         sand a, b
3258   1C44 E4            pop a
3259   1C45             ; END LOGICAL AND
3260   1C45 E7            pop d
3261   1C46 FD 43         mov [d], b
3262   1C48             ;; if(!pass){ 
3263   1C48             _if48_cond:
3264   1C48 3B 39 24      mov d, _pass ; $pass
3265   1C4B 2A            mov b, [d]
3266   1C4C C0 00 00      cmp b, 0
3267   1C4F FD 71         seq ; !
3268   1C51 C0 00 00      cmp b, 0
3269   1C54 C6 66 1C      je _if48_exit
3270   1C57             _if48_true:
3271   1C57             ;; section = 0; 
3272   1C57 3B 3B 24      mov d, _section ; $section
3273   1C5A DA            push d
3274   1C5B 26 00 00      mov b, $0
3275   1C5E E7            pop d
3276   1C5F FD 43         mov [d], b
3277   1C61             ;; return; 
3278   1C61 F9            leave
3279   1C62 09            ret
3280   1C63 0A 66 1C      jmp _if48_exit
3281   1C66             _if48_exit:
3282   1C66             ;; input_buffer[i++] = input[k++]; 
3283   1C66 FA F5 FF      lea d, [bp + -11] ; $input_buffer
3284   1C69 D7            push a
3285   1C6A DA            push d
3286   1C6B FA FF FF      lea d, [bp + -1] ; $i
3287   1C6E 2A            mov b, [d]
3288   1C6F FD 77         inc b
3289   1C71 FA FF FF      lea d, [bp + -1] ; $i
3290   1C74 FD 43         mov [d], b
3291   1C76 FD 7D         dec b
3292   1C78 E7            pop d
3293   1C79 5A            add d, b
3294   1C7A E4            pop a
3295   1C7B DA            push d
3296   1C7C FA 05 00      lea d, [bp + 5] ; $input
3297   1C7F FD 2A         mov d, [d]
3298   1C81 D7            push a
3299   1C82 DA            push d
3300   1C83 FA FB FF      lea d, [bp + -5] ; $k
3301   1C86 2A            mov b, [d]
3302   1C87 FD 77         inc b
3303   1C89 FA FB FF      lea d, [bp + -5] ; $k
3304   1C8C FD 43         mov [d], b
3305   1C8E FD 7D         dec b
3306   1C90 E7            pop d
3307   1C91 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
3308   1C95 E4            pop a
3309   1C96 32            mov bl, [d]
3310   1C97 A7 00         mov bh, 0
3311   1C99 E7            pop d
3312   1C9A FD 3E         mov [d], bl
3313   1C9C             ;; if (i == 4) { 
3314   1C9C             _if49_cond:
3315   1C9C FA FF FF      lea d, [bp + -1] ; $i
3316   1C9F 2A            mov b, [d]
3317   1CA0             ; START RELATIONAL
3318   1CA0 D7            push a
3319   1CA1 11            mov a, b
3320   1CA2 26 04 00      mov b, $4
3321   1CA5 B0            cmp a, b
3322   1CA6 FD 71         seq ; ==
3323   1CA8 E4            pop a
3324   1CA9             ; END RELATIONAL
3325   1CA9 C0 00 00      cmp b, 0
3326   1CAC C6 13 1F      je _if49_exit
3327   1CAF             _if49_true:
3328   1CAF             ;; printf("is i 4? %d\n", i==4); 
3329   1CAF FA FF FF      lea d, [bp + -1] ; $i
3330   1CB2 2A            mov b, [d]
3331   1CB3             ; START RELATIONAL
3332   1CB3 D7            push a
3333   1CB4 11            mov a, b
3334   1CB5 26 04 00      mov b, $4
3335   1CB8 B0            cmp a, b
3336   1CB9 FD 71         seq ; ==
3337   1CBB E4            pop a
3338   1CBC             ; END RELATIONAL
3339   1CBC FD AB         swp b
3340   1CBE D8            push b
3341   1CBF 26 04 25      mov b, _s7 ; "is i 4? %d\n"
3342   1CC2 FD AB         swp b
3343   1CC4 D8            push b
3344   1CC5 07 DC 07      call printf
3345   1CC8 51 04 00      add sp, 4
3346   1CCB             ;; pass=pass && i==4; 
3347   1CCB 3B 39 24      mov d, _pass ; $pass
3348   1CCE DA            push d
3349   1CCF 3B 39 24      mov d, _pass ; $pass
3350   1CD2 2A            mov b, [d]
3351   1CD3             ; START LOGICAL AND
3352   1CD3 D7            push a
3353   1CD4 11            mov a, b
3354   1CD5 FA FF FF      lea d, [bp + -1] ; $i
3355   1CD8 2A            mov b, [d]
3356   1CD9             ; START RELATIONAL
3357   1CD9 D7            push a
3358   1CDA 11            mov a, b
3359   1CDB 26 04 00      mov b, $4
3360   1CDE B0            cmp a, b
3361   1CDF FD 71         seq ; ==
3362   1CE1 E4            pop a
3363   1CE2             ; END RELATIONAL
3364   1CE2 FD A7         sand a, b
3365   1CE4 E4            pop a
3366   1CE5             ; END LOGICAL AND
3367   1CE5 E7            pop d
3368   1CE6 FD 43         mov [d], b
3369   1CE8             ;; if(!pass){ 
3370   1CE8             _if50_cond:
3371   1CE8 3B 39 24      mov d, _pass ; $pass
3372   1CEB 2A            mov b, [d]
3373   1CEC C0 00 00      cmp b, 0
3374   1CEF FD 71         seq ; !
3375   1CF1 C0 00 00      cmp b, 0
3376   1CF4 C6 06 1D      je _if50_exit
3377   1CF7             _if50_true:
3378   1CF7             ;; section = 1; 
3379   1CF7 3B 3B 24      mov d, _section ; $section
3380   1CFA DA            push d
3381   1CFB 26 01 00      mov b, $1
3382   1CFE E7            pop d
3383   1CFF FD 43         mov [d], b
3384   1D01             ;; return; 
3385   1D01 F9            leave
3386   1D02 09            ret
3387   1D03 0A 06 1D      jmp _if50_exit
3388   1D06             _if50_exit:
3389   1D06             ;; for (i = 0; i < 4; i++) { 
3390   1D06             _for51_init:
3391   1D06 FA FF FF      lea d, [bp + -1] ; $i
3392   1D09 DA            push d
3393   1D0A 26 00 00      mov b, $0
3394   1D0D E7            pop d
3395   1D0E FD 43         mov [d], b
3396   1D10             _for51_cond:
3397   1D10 FA FF FF      lea d, [bp + -1] ; $i
3398   1D13 2A            mov b, [d]
3399   1D14             ; START RELATIONAL
3400   1D14 D7            push a
3401   1D15 11            mov a, b
3402   1D16 26 04 00      mov b, $4
3403   1D19 B0            cmp a, b
3404   1D1A FD 73         slt ; < (signed)
3405   1D1C E4            pop a
3406   1D1D             ; END RELATIONAL
3407   1D1D C0 00 00      cmp b, 0
3408   1D20 C6 FC 1D      je _for51_exit
3409   1D23             _for51_block:
3410   1D23             ;; printf("inside first for loop for i=0 to 3. i = %d\n", i); 
3411   1D23 FA FF FF      lea d, [bp + -1] ; $i
3412   1D26 2A            mov b, [d]
3413   1D27 FD AB         swp b
3414   1D29 D8            push b
3415   1D2A 26 10 25      mov b, _s8 ; "inside first for loop for i=0 to 3. i = %d\n"
3416   1D2D FD AB         swp b
3417   1D2F D8            push b
3418   1D30 07 DC 07      call printf
3419   1D33 51 04 00      add sp, 4
3420   1D36             ;; a = base64_char_value(input_buffer[i]); 
3421   1D36 FA F1 FF      lea d, [bp + -15] ; $a
3422   1D39 DA            push d
3423   1D3A FA F5 FF      lea d, [bp + -11] ; $input_buffer
3424   1D3D D7            push a
3425   1D3E DA            push d
3426   1D3F FA FF FF      lea d, [bp + -1] ; $i
3427   1D42 2A            mov b, [d]
3428   1D43 E7            pop d
3429   1D44 5A            add d, b
3430   1D45 E4            pop a
3431   1D46 32            mov bl, [d]
3432   1D47 A7 00         mov bh, 0
3433   1D49 DD            push bl
3434   1D4A 07 69 19      call base64_char_value
3435   1D4D 51 01 00      add sp, 1
3436   1D50 E7            pop d
3437   1D51 FD 3E         mov [d], bl
3438   1D53             ;; input_buffer[i] = base64_char_value(input_buffer[i]); 
3439   1D53 FA F5 FF      lea d, [bp + -11] ; $input_buffer
3440   1D56 D7            push a
3441   1D57 DA            push d
3442   1D58 FA FF FF      lea d, [bp + -1] ; $i
3443   1D5B 2A            mov b, [d]
3444   1D5C E7            pop d
3445   1D5D 5A            add d, b
3446   1D5E E4            pop a
3447   1D5F DA            push d
3448   1D60 FA F5 FF      lea d, [bp + -11] ; $input_buffer
3449   1D63 D7            push a
3450   1D64 DA            push d
3451   1D65 FA FF FF      lea d, [bp + -1] ; $i
3452   1D68 2A            mov b, [d]
3453   1D69 E7            pop d
3454   1D6A 5A            add d, b
3455   1D6B E4            pop a
3456   1D6C 32            mov bl, [d]
3457   1D6D A7 00         mov bh, 0
3458   1D6F DD            push bl
3459   1D70 07 69 19      call base64_char_value
3460   1D73 51 01 00      add sp, 1
3461   1D76 E7            pop d
3462   1D77 FD 3E         mov [d], bl
3463   1D79             ;; printf("input_buffer[i] == base64_char_val(input_buffer[i]): %d\n", input_buffer[i] == a); 
3464   1D79 FA F5 FF      lea d, [bp + -11] ; $input_buffer
3465   1D7C D7            push a
3466   1D7D DA            push d
3467   1D7E FA FF FF      lea d, [bp + -1] ; $i
3468   1D81 2A            mov b, [d]
3469   1D82 E7            pop d
3470   1D83 5A            add d, b
3471   1D84 E4            pop a
3472   1D85 32            mov bl, [d]
3473   1D86 A7 00         mov bh, 0
3474   1D88             ; START RELATIONAL
3475   1D88 D7            push a
3476   1D89 11            mov a, b
3477   1D8A FA F1 FF      lea d, [bp + -15] ; $a
3478   1D8D 32            mov bl, [d]
3479   1D8E A7 00         mov bh, 0
3480   1D90 B0            cmp a, b
3481   1D91 FD 71         seq ; ==
3482   1D93 E4            pop a
3483   1D94             ; END RELATIONAL
3484   1D94 FD AB         swp b
3485   1D96 D8            push b
3486   1D97 26 3C 25      mov b, _s9 ; "input_buffer[i] == base64_char_val(input_buffer[i]): %d\n"
3487   1D9A FD AB         swp b
3488   1D9C D8            push b
3489   1D9D 07 DC 07      call printf
3490   1DA0 51 04 00      add sp, 4
3491   1DA3             ;; pass=pass && input_buffer[i] == a; 
3492   1DA3 3B 39 24      mov d, _pass ; $pass
3493   1DA6 DA            push d
3494   1DA7 3B 39 24      mov d, _pass ; $pass
3495   1DAA 2A            mov b, [d]
3496   1DAB             ; START LOGICAL AND
3497   1DAB D7            push a
3498   1DAC 11            mov a, b
3499   1DAD FA F5 FF      lea d, [bp + -11] ; $input_buffer
3500   1DB0 D7            push a
3501   1DB1 DA            push d
3502   1DB2 FA FF FF      lea d, [bp + -1] ; $i
3503   1DB5 2A            mov b, [d]
3504   1DB6 E7            pop d
3505   1DB7 5A            add d, b
3506   1DB8 E4            pop a
3507   1DB9 32            mov bl, [d]
3508   1DBA A7 00         mov bh, 0
3509   1DBC             ; START RELATIONAL
3510   1DBC D7            push a
3511   1DBD 11            mov a, b
3512   1DBE FA F1 FF      lea d, [bp + -15] ; $a
3513   1DC1 32            mov bl, [d]
3514   1DC2 A7 00         mov bh, 0
3515   1DC4 B0            cmp a, b
3516   1DC5 FD 71         seq ; ==
3517   1DC7 E4            pop a
3518   1DC8             ; END RELATIONAL
3519   1DC8 FD A7         sand a, b
3520   1DCA E4            pop a
3521   1DCB             ; END LOGICAL AND
3522   1DCB E7            pop d
3523   1DCC FD 43         mov [d], b
3524   1DCE             ;; if(!pass){ 
3525   1DCE             _if52_cond:
3526   1DCE 3B 39 24      mov d, _pass ; $pass
3527   1DD1 2A            mov b, [d]
3528   1DD2 C0 00 00      cmp b, 0
3529   1DD5 FD 71         seq ; !
3530   1DD7 C0 00 00      cmp b, 0
3531   1DDA C6 EC 1D      je _if52_exit
3532   1DDD             _if52_true:
3533   1DDD             ;; section = 2; 
3534   1DDD 3B 3B 24      mov d, _section ; $section
3535   1DE0 DA            push d
3536   1DE1 26 02 00      mov b, $2
3537   1DE4 E7            pop d
3538   1DE5 FD 43         mov [d], b
3539   1DE7             ;; return; 
3540   1DE7 F9            leave
3541   1DE8 09            ret
3542   1DE9 0A EC 1D      jmp _if52_exit
3543   1DEC             _if52_exit:
3544   1DEC             _for51_update:
3545   1DEC FA FF FF      lea d, [bp + -1] ; $i
3546   1DEF 2A            mov b, [d]
3547   1DF0 FD 77         inc b
3548   1DF2 FA FF FF      lea d, [bp + -1] ; $i
3549   1DF5 FD 43         mov [d], b
3550   1DF7 FD 7D         dec b
3551   1DF9 0A 10 1D      jmp _for51_cond
3552   1DFC             _for51_exit:
3553   1DFC             ;; for (i = 0; i < 3; i++) { 
3554   1DFC             _for53_init:
3555   1DFC FA FF FF      lea d, [bp + -1] ; $i
3556   1DFF DA            push d
3557   1E00 26 00 00      mov b, $0
3558   1E03 E7            pop d
3559   1E04 FD 43         mov [d], b
3560   1E06             _for53_cond:
3561   1E06 FA FF FF      lea d, [bp + -1] ; $i
3562   1E09 2A            mov b, [d]
3563   1E0A             ; START RELATIONAL
3564   1E0A D7            push a
3565   1E0B 11            mov a, b
3566   1E0C 26 03 00      mov b, $3
3567   1E0F B0            cmp a, b
3568   1E10 FD 73         slt ; < (signed)
3569   1E12 E4            pop a
3570   1E13             ; END RELATIONAL
3571   1E13 C0 00 00      cmp b, 0
3572   1E16 C6 06 1F      je _for53_exit
3573   1E19             _for53_block:
3574   1E19             ;; printf("inside second for loop for i=0 to 2. i = %d\n", i); 
3575   1E19 FA FF FF      lea d, [bp + -1] ; $i
3576   1E1C 2A            mov b, [d]
3577   1E1D FD AB         swp b
3578   1E1F D8            push b
3579   1E20 26 75 25      mov b, _s10 ; "inside second for loop for i=0 to 2. i = %d\n"
3580   1E23 FD AB         swp b
3581   1E25 D8            push b
3582   1E26 07 DC 07      call printf
3583   1E29 51 04 00      add sp, 4
3584   1E2C             ;; output[j++] = output_buffer[i]; 
3585   1E2C FA 07 00      lea d, [bp + 7] ; $output
3586   1E2F FD 2A         mov d, [d]
3587   1E31 D7            push a
3588   1E32 DA            push d
3589   1E33 FA FD FF      lea d, [bp + -3] ; $j
3590   1E36 2A            mov b, [d]
3591   1E37 FD 77         inc b
3592   1E39 FA FD FF      lea d, [bp + -3] ; $j
3593   1E3C FD 43         mov [d], b
3594   1E3E FD 7D         dec b
3595   1E40 E7            pop d
3596   1E41 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
3597   1E45 E4            pop a
3598   1E46 DA            push d
3599   1E47 FA F2 FF      lea d, [bp + -14] ; $output_buffer
3600   1E4A D7            push a
3601   1E4B DA            push d
3602   1E4C FA FF FF      lea d, [bp + -1] ; $i
3603   1E4F 2A            mov b, [d]
3604   1E50 E7            pop d
3605   1E51 5A            add d, b
3606   1E52 E4            pop a
3607   1E53 32            mov bl, [d]
3608   1E54 A7 00         mov bh, 0
3609   1E56 E7            pop d
3610   1E57 FD 3E         mov [d], bl
3611   1E59             ;; printf("output[j] == output_buffer[i]: %d\n", output[j+-1] == output_buffer[i]); 
3612   1E59 FA 07 00      lea d, [bp + 7] ; $output
3613   1E5C FD 2A         mov d, [d]
3614   1E5E D7            push a
3615   1E5F DA            push d
3616   1E60 FA FD FF      lea d, [bp + -3] ; $j
3617   1E63 2A            mov b, [d]
3618   1E64             ; START TERMS
3619   1E64 D7            push a
3620   1E65 11            mov a, b
3621   1E66 26 FF FF      mov b, $ffff
3622   1E69 56            add b, a
3623   1E6A E4            pop a
3624   1E6B             ; END TERMS
3625   1E6B E7            pop d
3626   1E6C FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
3627   1E70 E4            pop a
3628   1E71 32            mov bl, [d]
3629   1E72 A7 00         mov bh, 0
3630   1E74             ; START RELATIONAL
3631   1E74 D7            push a
3632   1E75 11            mov a, b
3633   1E76 FA F2 FF      lea d, [bp + -14] ; $output_buffer
3634   1E79 D7            push a
3635   1E7A DA            push d
3636   1E7B FA FF FF      lea d, [bp + -1] ; $i
3637   1E7E 2A            mov b, [d]
3638   1E7F E7            pop d
3639   1E80 5A            add d, b
3640   1E81 E4            pop a
3641   1E82 32            mov bl, [d]
3642   1E83 A7 00         mov bh, 0
3643   1E85 B0            cmp a, b
3644   1E86 FD 71         seq ; ==
3645   1E88 E4            pop a
3646   1E89             ; END RELATIONAL
3647   1E89 FD AB         swp b
3648   1E8B D8            push b
3649   1E8C 26 A2 25      mov b, _s11 ; "output[j] == output_buffer[i]: %d\n"
3650   1E8F FD AB         swp b
3651   1E91 D8            push b
3652   1E92 07 DC 07      call printf
3653   1E95 51 04 00      add sp, 4
3654   1E98             ;; pass=pass && output[j+-1] == output_buffer[i]; 
3655   1E98 3B 39 24      mov d, _pass ; $pass
3656   1E9B DA            push d
3657   1E9C 3B 39 24      mov d, _pass ; $pass
3658   1E9F 2A            mov b, [d]
3659   1EA0             ; START LOGICAL AND
3660   1EA0 D7            push a
3661   1EA1 11            mov a, b
3662   1EA2 FA 07 00      lea d, [bp + 7] ; $output
3663   1EA5 FD 2A         mov d, [d]
3664   1EA7 D7            push a
3665   1EA8 DA            push d
3666   1EA9 FA FD FF      lea d, [bp + -3] ; $j
3667   1EAC 2A            mov b, [d]
3668   1EAD             ; START TERMS
3669   1EAD D7            push a
3670   1EAE 11            mov a, b
3671   1EAF 26 FF FF      mov b, $ffff
3672   1EB2 56            add b, a
3673   1EB3 E4            pop a
3674   1EB4             ; END TERMS
3675   1EB4 E7            pop d
3676   1EB5 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
3677   1EB9 E4            pop a
3678   1EBA 32            mov bl, [d]
3679   1EBB A7 00         mov bh, 0
3680   1EBD             ; START RELATIONAL
3681   1EBD D7            push a
3682   1EBE 11            mov a, b
3683   1EBF FA F2 FF      lea d, [bp + -14] ; $output_buffer
3684   1EC2 D7            push a
3685   1EC3 DA            push d
3686   1EC4 FA FF FF      lea d, [bp + -1] ; $i
3687   1EC7 2A            mov b, [d]
3688   1EC8 E7            pop d
3689   1EC9 5A            add d, b
3690   1ECA E4            pop a
3691   1ECB 32            mov bl, [d]
3692   1ECC A7 00         mov bh, 0
3693   1ECE B0            cmp a, b
3694   1ECF FD 71         seq ; ==
3695   1ED1 E4            pop a
3696   1ED2             ; END RELATIONAL
3697   1ED2 FD A7         sand a, b
3698   1ED4 E4            pop a
3699   1ED5             ; END LOGICAL AND
3700   1ED5 E7            pop d
3701   1ED6 FD 43         mov [d], b
3702   1ED8             ;; if(!pass){ 
3703   1ED8             _if54_cond:
3704   1ED8 3B 39 24      mov d, _pass ; $pass
3705   1EDB 2A            mov b, [d]
3706   1EDC C0 00 00      cmp b, 0
3707   1EDF FD 71         seq ; !
3708   1EE1 C0 00 00      cmp b, 0
3709   1EE4 C6 F6 1E      je _if54_exit
3710   1EE7             _if54_true:
3711   1EE7             ;; section = 3; 
3712   1EE7 3B 3B 24      mov d, _section ; $section
3713   1EEA DA            push d
3714   1EEB 26 03 00      mov b, $3
3715   1EEE E7            pop d
3716   1EEF FD 43         mov [d], b
3717   1EF1             ;; return; 
3718   1EF1 F9            leave
3719   1EF2 09            ret
3720   1EF3 0A F6 1E      jmp _if54_exit
3721   1EF6             _if54_exit:
3722   1EF6             _for53_update:
3723   1EF6 FA FF FF      lea d, [bp + -1] ; $i
3724   1EF9 2A            mov b, [d]
3725   1EFA FD 77         inc b
3726   1EFC FA FF FF      lea d, [bp + -1] ; $i
3727   1EFF FD 43         mov [d], b
3728   1F01 FD 7D         dec b
3729   1F03 0A 06 1E      jmp _for53_cond
3730   1F06             _for53_exit:
3731   1F06             ;; i = 0; 
3732   1F06 FA FF FF      lea d, [bp + -1] ; $i
3733   1F09 DA            push d
3734   1F0A 26 00 00      mov b, $0
3735   1F0D E7            pop d
3736   1F0E FD 43         mov [d], b
3737   1F10 0A 13 1F      jmp _if49_exit
3738   1F13             _if49_exit:
3739   1F13 0A C6 1A      jmp _while47_cond
3740   1F16             _while47_exit:
3741   1F16             ;; if (i) { 
3742   1F16             _if55_cond:
3743   1F16 FA FF FF      lea d, [bp + -1] ; $i
3744   1F19 2A            mov b, [d]
3745   1F1A C0 00 00      cmp b, 0
3746   1F1D C6 F4 21      je _if55_exit
3747   1F20             _if55_true:
3748   1F20             ;; pass=pass && i; 
3749   1F20 3B 39 24      mov d, _pass ; $pass
3750   1F23 DA            push d
3751   1F24 3B 39 24      mov d, _pass ; $pass
3752   1F27 2A            mov b, [d]
3753   1F28             ; START LOGICAL AND
3754   1F28 D7            push a
3755   1F29 11            mov a, b
3756   1F2A FA FF FF      lea d, [bp + -1] ; $i
3757   1F2D 2A            mov b, [d]
3758   1F2E FD A7         sand a, b
3759   1F30 E4            pop a
3760   1F31             ; END LOGICAL AND
3761   1F31 E7            pop d
3762   1F32 FD 43         mov [d], b
3763   1F34             ;; if(!pass){ 
3764   1F34             _if56_cond:
3765   1F34 3B 39 24      mov d, _pass ; $pass
3766   1F37 2A            mov b, [d]
3767   1F38 C0 00 00      cmp b, 0
3768   1F3B FD 71         seq ; !
3769   1F3D C0 00 00      cmp b, 0
3770   1F40 C6 52 1F      je _if56_exit
3771   1F43             _if56_true:
3772   1F43             ;; section = 4; 
3773   1F43 3B 3B 24      mov d, _section ; $section
3774   1F46 DA            push d
3775   1F47 26 04 00      mov b, $4
3776   1F4A E7            pop d
3777   1F4B FD 43         mov [d], b
3778   1F4D             ;; return; 
3779   1F4D F9            leave
3780   1F4E 09            ret
3781   1F4F 0A 52 1F      jmp _if56_exit
3782   1F52             _if56_exit:
3783   1F52             ;; for (k = i; k < 4; k++) { 
3784   1F52             _for57_init:
3785   1F52 FA FB FF      lea d, [bp + -5] ; $k
3786   1F55 DA            push d
3787   1F56 FA FF FF      lea d, [bp + -1] ; $i
3788   1F59 2A            mov b, [d]
3789   1F5A E7            pop d
3790   1F5B FD 43         mov [d], b
3791   1F5D             _for57_cond:
3792   1F5D FA FB FF      lea d, [bp + -5] ; $k
3793   1F60 2A            mov b, [d]
3794   1F61             ; START RELATIONAL
3795   1F61 D7            push a
3796   1F62 11            mov a, b
3797   1F63 26 04 00      mov b, $4
3798   1F66 B0            cmp a, b
3799   1F67 FD 73         slt ; < (signed)
3800   1F69 E4            pop a
3801   1F6A             ; END RELATIONAL
3802   1F6A C0 00 00      cmp b, 0
3803   1F6D C6 D9 1F      je _for57_exit
3804   1F70             _for57_block:
3805   1F70             ;; input_buffer[k] = 0; 
3806   1F70 FA F5 FF      lea d, [bp + -11] ; $input_buffer
3807   1F73 D7            push a
3808   1F74 DA            push d
3809   1F75 FA FB FF      lea d, [bp + -5] ; $k
3810   1F78 2A            mov b, [d]
3811   1F79 E7            pop d
3812   1F7A 5A            add d, b
3813   1F7B E4            pop a
3814   1F7C DA            push d
3815   1F7D 26 00 00      mov b, $0
3816   1F80 E7            pop d
3817   1F81 FD 3E         mov [d], bl
3818   1F83             ;; pass=pass && input_buffer[k]==0; 
3819   1F83 3B 39 24      mov d, _pass ; $pass
3820   1F86 DA            push d
3821   1F87 3B 39 24      mov d, _pass ; $pass
3822   1F8A 2A            mov b, [d]
3823   1F8B             ; START LOGICAL AND
3824   1F8B D7            push a
3825   1F8C 11            mov a, b
3826   1F8D FA F5 FF      lea d, [bp + -11] ; $input_buffer
3827   1F90 D7            push a
3828   1F91 DA            push d
3829   1F92 FA FB FF      lea d, [bp + -5] ; $k
3830   1F95 2A            mov b, [d]
3831   1F96 E7            pop d
3832   1F97 5A            add d, b
3833   1F98 E4            pop a
3834   1F99 32            mov bl, [d]
3835   1F9A A7 00         mov bh, 0
3836   1F9C             ; START RELATIONAL
3837   1F9C D7            push a
3838   1F9D 11            mov a, b
3839   1F9E 26 00 00      mov b, $0
3840   1FA1 B0            cmp a, b
3841   1FA2 FD 71         seq ; ==
3842   1FA4 E4            pop a
3843   1FA5             ; END RELATIONAL
3844   1FA5 FD A7         sand a, b
3845   1FA7 E4            pop a
3846   1FA8             ; END LOGICAL AND
3847   1FA8 E7            pop d
3848   1FA9 FD 43         mov [d], b
3849   1FAB             ;; if(!pass){ 
3850   1FAB             _if58_cond:
3851   1FAB 3B 39 24      mov d, _pass ; $pass
3852   1FAE 2A            mov b, [d]
3853   1FAF C0 00 00      cmp b, 0
3854   1FB2 FD 71         seq ; !
3855   1FB4 C0 00 00      cmp b, 0
3856   1FB7 C6 C9 1F      je _if58_exit
3857   1FBA             _if58_true:
3858   1FBA             ;; section = 5; 
3859   1FBA 3B 3B 24      mov d, _section ; $section
3860   1FBD DA            push d
3861   1FBE 26 05 00      mov b, $5
3862   1FC1 E7            pop d
3863   1FC2 FD 43         mov [d], b
3864   1FC4             ;; return; 
3865   1FC4 F9            leave
3866   1FC5 09            ret
3867   1FC6 0A C9 1F      jmp _if58_exit
3868   1FC9             _if58_exit:
3869   1FC9             _for57_update:
3870   1FC9 FA FB FF      lea d, [bp + -5] ; $k
3871   1FCC 2A            mov b, [d]
3872   1FCD FD 77         inc b
3873   1FCF FA FB FF      lea d, [bp + -5] ; $k
3874   1FD2 FD 43         mov [d], b
3875   1FD4 FD 7D         dec b
3876   1FD6 0A 5D 1F      jmp _for57_cond
3877   1FD9             _for57_exit:
3878   1FD9             ;; for (k = 0; k < 4; k++) { 
3879   1FD9             _for59_init:
3880   1FD9 FA FB FF      lea d, [bp + -5] ; $k
3881   1FDC DA            push d
3882   1FDD 26 00 00      mov b, $0
3883   1FE0 E7            pop d
3884   1FE1 FD 43         mov [d], b
3885   1FE3             _for59_cond:
3886   1FE3 FA FB FF      lea d, [bp + -5] ; $k
3887   1FE6 2A            mov b, [d]
3888   1FE7             ; START RELATIONAL
3889   1FE7 D7            push a
3890   1FE8 11            mov a, b
3891   1FE9 26 04 00      mov b, $4
3892   1FEC B0            cmp a, b
3893   1FED FD 73         slt ; < (signed)
3894   1FEF E4            pop a
3895   1FF0             ; END RELATIONAL
3896   1FF0 C0 00 00      cmp b, 0
3897   1FF3 C6 92 20      je _for59_exit
3898   1FF6             _for59_block:
3899   1FF6             ;; a = base64_char_value(input_buffer[k]); 
3900   1FF6 FA F1 FF      lea d, [bp + -15] ; $a
3901   1FF9 DA            push d
3902   1FFA FA F5 FF      lea d, [bp + -11] ; $input_buffer
3903   1FFD D7            push a
3904   1FFE DA            push d
3905   1FFF FA FB FF      lea d, [bp + -5] ; $k
3906   2002 2A            mov b, [d]
3907   2003 E7            pop d
3908   2004 5A            add d, b
3909   2005 E4            pop a
3910   2006 32            mov bl, [d]
3911   2007 A7 00         mov bh, 0
3912   2009 DD            push bl
3913   200A 07 69 19      call base64_char_value
3914   200D 51 01 00      add sp, 1
3915   2010 E7            pop d
3916   2011 FD 3E         mov [d], bl
3917   2013             ;; input_buffer[k] = base64_char_value(input_buffer[k]); 
3918   2013 FA F5 FF      lea d, [bp + -11] ; $input_buffer
3919   2016 D7            push a
3920   2017 DA            push d
3921   2018 FA FB FF      lea d, [bp + -5] ; $k
3922   201B 2A            mov b, [d]
3923   201C E7            pop d
3924   201D 5A            add d, b
3925   201E E4            pop a
3926   201F DA            push d
3927   2020 FA F5 FF      lea d, [bp + -11] ; $input_buffer
3928   2023 D7            push a
3929   2024 DA            push d
3930   2025 FA FB FF      lea d, [bp + -5] ; $k
3931   2028 2A            mov b, [d]
3932   2029 E7            pop d
3933   202A 5A            add d, b
3934   202B E4            pop a
3935   202C 32            mov bl, [d]
3936   202D A7 00         mov bh, 0
3937   202F DD            push bl
3938   2030 07 69 19      call base64_char_value
3939   2033 51 01 00      add sp, 1
3940   2036 E7            pop d
3941   2037 FD 3E         mov [d], bl
3942   2039             ;; pass=pass && input_buffer[k] == a; 
3943   2039 3B 39 24      mov d, _pass ; $pass
3944   203C DA            push d
3945   203D 3B 39 24      mov d, _pass ; $pass
3946   2040 2A            mov b, [d]
3947   2041             ; START LOGICAL AND
3948   2041 D7            push a
3949   2042 11            mov a, b
3950   2043 FA F5 FF      lea d, [bp + -11] ; $input_buffer
3951   2046 D7            push a
3952   2047 DA            push d
3953   2048 FA FB FF      lea d, [bp + -5] ; $k
3954   204B 2A            mov b, [d]
3955   204C E7            pop d
3956   204D 5A            add d, b
3957   204E E4            pop a
3958   204F 32            mov bl, [d]
3959   2050 A7 00         mov bh, 0
3960   2052             ; START RELATIONAL
3961   2052 D7            push a
3962   2053 11            mov a, b
3963   2054 FA F1 FF      lea d, [bp + -15] ; $a
3964   2057 32            mov bl, [d]
3965   2058 A7 00         mov bh, 0
3966   205A B0            cmp a, b
3967   205B FD 71         seq ; ==
3968   205D E4            pop a
3969   205E             ; END RELATIONAL
3970   205E FD A7         sand a, b
3971   2060 E4            pop a
3972   2061             ; END LOGICAL AND
3973   2061 E7            pop d
3974   2062 FD 43         mov [d], b
3975   2064             ;; if(!pass){ 
3976   2064             _if60_cond:
3977   2064 3B 39 24      mov d, _pass ; $pass
3978   2067 2A            mov b, [d]
3979   2068 C0 00 00      cmp b, 0
3980   206B FD 71         seq ; !
3981   206D C0 00 00      cmp b, 0
3982   2070 C6 82 20      je _if60_exit
3983   2073             _if60_true:
3984   2073             ;; section = 6; 
3985   2073 3B 3B 24      mov d, _section ; $section
3986   2076 DA            push d
3987   2077 26 06 00      mov b, $6
3988   207A E7            pop d
3989   207B FD 43         mov [d], b
3990   207D             ;; return; 
3991   207D F9            leave
3992   207E 09            ret
3993   207F 0A 82 20      jmp _if60_exit
3994   2082             _if60_exit:
3995   2082             _for59_update:
3996   2082 FA FB FF      lea d, [bp + -5] ; $k
3997   2085 2A            mov b, [d]
3998   2086 FD 77         inc b
3999   2088 FA FB FF      lea d, [bp + -5] ; $k
4000   208B FD 43         mov [d], b
4001   208D FD 7D         dec b
4002   208F 0A E3 1F      jmp _for59_cond
4003   2092             _for59_exit:
4004   2092             ;; output_buffer[0] = (input_buffer[0] << 2) + ((input_buffer[1] & 0x30) >> 4); 
4005   2092 FA F2 FF      lea d, [bp + -14] ; $output_buffer
4006   2095 D7            push a
4007   2096 DA            push d
4008   2097 26 00 00      mov b, $0
4009   209A E7            pop d
4010   209B 5A            add d, b
4011   209C E4            pop a
4012   209D DA            push d
4013   209E FA F5 FF      lea d, [bp + -11] ; $input_buffer
4014   20A1 D7            push a
4015   20A2 DA            push d
4016   20A3 26 00 00      mov b, $0
4017   20A6 E7            pop d
4018   20A7 5A            add d, b
4019   20A8 E4            pop a
4020   20A9 32            mov bl, [d]
4021   20AA A7 00         mov bh, 0
4022   20AC             ; START SHIFT
4023   20AC D7            push a
4024   20AD 11            mov a, b
4025   20AE 26 02 00      mov b, $2
4026   20B1 FD 39         mov c, b
4027   20B3 9D            shl a, cl
4028   20B4 27            mov b, a
4029   20B5 E4            pop a
4030   20B6             ; END SHIFT
4031   20B6             ; START TERMS
4032   20B6 D7            push a
4033   20B7 11            mov a, b
4034   20B8 FA F5 FF      lea d, [bp + -11] ; $input_buffer
4035   20BB D7            push a
4036   20BC DA            push d
4037   20BD 26 01 00      mov b, $1
4038   20C0 E7            pop d
4039   20C1 5A            add d, b
4040   20C2 E4            pop a
4041   20C3 32            mov bl, [d]
4042   20C4 A7 00         mov bh, 0
4043   20C6 D7            push a
4044   20C7 11            mov a, b
4045   20C8 26 30 00      mov b, $30
4046   20CB FD 92         and b, a ; &
4047   20CD E4            pop a
4048   20CE             ; START SHIFT
4049   20CE D7            push a
4050   20CF 11            mov a, b
4051   20D0 26 04 00      mov b, $4
4052   20D3 FD 39         mov c, b
4053   20D5 A5            ashr a, cl
4054   20D6 27            mov b, a
4055   20D7 E4            pop a
4056   20D8             ; END SHIFT
4057   20D8 56            add b, a
4058   20D9 E4            pop a
4059   20DA             ; END TERMS
4060   20DA E7            pop d
4061   20DB FD 3E         mov [d], bl
4062   20DD             ;; output_buffer[1] = ((input_buffer[1] & 0x0F) << 4) + ((input_buffer[2] & 0x3C) >> 2); 
4063   20DD FA F2 FF      lea d, [bp + -14] ; $output_buffer
4064   20E0 D7            push a
4065   20E1 DA            push d
4066   20E2 26 01 00      mov b, $1
4067   20E5 E7            pop d
4068   20E6 5A            add d, b
4069   20E7 E4            pop a
4070   20E8 DA            push d
4071   20E9 FA F5 FF      lea d, [bp + -11] ; $input_buffer
4072   20EC D7            push a
4073   20ED DA            push d
4074   20EE 26 01 00      mov b, $1
4075   20F1 E7            pop d
4076   20F2 5A            add d, b
4077   20F3 E4            pop a
4078   20F4 32            mov bl, [d]
4079   20F5 A7 00         mov bh, 0
4080   20F7 D7            push a
4081   20F8 11            mov a, b
4082   20F9 26 0F 00      mov b, $f
4083   20FC FD 92         and b, a ; &
4084   20FE E4            pop a
4085   20FF             ; START SHIFT
4086   20FF D7            push a
4087   2100 11            mov a, b
4088   2101 26 04 00      mov b, $4
4089   2104 FD 39         mov c, b
4090   2106 9D            shl a, cl
4091   2107 27            mov b, a
4092   2108 E4            pop a
4093   2109             ; END SHIFT
4094   2109             ; START TERMS
4095   2109 D7            push a
4096   210A 11            mov a, b
4097   210B FA F5 FF      lea d, [bp + -11] ; $input_buffer
4098   210E D7            push a
4099   210F DA            push d
4100   2110 26 02 00      mov b, $2
4101   2113 E7            pop d
4102   2114 5A            add d, b
4103   2115 E4            pop a
4104   2116 32            mov bl, [d]
4105   2117 A7 00         mov bh, 0
4106   2119 D7            push a
4107   211A 11            mov a, b
4108   211B 26 3C 00      mov b, $3c
4109   211E FD 92         and b, a ; &
4110   2120 E4            pop a
4111   2121             ; START SHIFT
4112   2121 D7            push a
4113   2122 11            mov a, b
4114   2123 26 02 00      mov b, $2
4115   2126 FD 39         mov c, b
4116   2128 A5            ashr a, cl
4117   2129 27            mov b, a
4118   212A E4            pop a
4119   212B             ; END SHIFT
4120   212B 56            add b, a
4121   212C E4            pop a
4122   212D             ; END TERMS
4123   212D E7            pop d
4124   212E FD 3E         mov [d], bl
4125   2130             ;; for (k = 0; k < i - 1; k++) { 
4126   2130             _for61_init:
4127   2130 FA FB FF      lea d, [bp + -5] ; $k
4128   2133 DA            push d
4129   2134 26 00 00      mov b, $0
4130   2137 E7            pop d
4131   2138 FD 43         mov [d], b
4132   213A             _for61_cond:
4133   213A FA FB FF      lea d, [bp + -5] ; $k
4134   213D 2A            mov b, [d]
4135   213E             ; START RELATIONAL
4136   213E D7            push a
4137   213F 11            mov a, b
4138   2140 FA FF FF      lea d, [bp + -1] ; $i
4139   2143 2A            mov b, [d]
4140   2144             ; START TERMS
4141   2144 D7            push a
4142   2145 11            mov a, b
4143   2146 26 01 00      mov b, $1
4144   2149 60            sub a, b
4145   214A 27            mov b, a
4146   214B E4            pop a
4147   214C             ; END TERMS
4148   214C B0            cmp a, b
4149   214D FD 73         slt ; < (signed)
4150   214F E4            pop a
4151   2150             ; END RELATIONAL
4152   2150 C0 00 00      cmp b, 0
4153   2153 C6 F1 21      je _for61_exit
4154   2156             _for61_block:
4155   2156             ;; output[j++] = output_buffer[k]; 
4156   2156 FA 07 00      lea d, [bp + 7] ; $output
4157   2159 FD 2A         mov d, [d]
4158   215B D7            push a
4159   215C DA            push d
4160   215D FA FD FF      lea d, [bp + -3] ; $j
4161   2160 2A            mov b, [d]
4162   2161 FD 77         inc b
4163   2163 FA FD FF      lea d, [bp + -3] ; $j
4164   2166 FD 43         mov [d], b
4165   2168 FD 7D         dec b
4166   216A E7            pop d
4167   216B FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
4168   216F E4            pop a
4169   2170 DA            push d
4170   2171 FA F2 FF      lea d, [bp + -14] ; $output_buffer
4171   2174 D7            push a
4172   2175 DA            push d
4173   2176 FA FB FF      lea d, [bp + -5] ; $k
4174   2179 2A            mov b, [d]
4175   217A E7            pop d
4176   217B 5A            add d, b
4177   217C E4            pop a
4178   217D 32            mov bl, [d]
4179   217E A7 00         mov bh, 0
4180   2180 E7            pop d
4181   2181 FD 3E         mov [d], bl
4182   2183             ;; pass=pass && output[j+-1] == output_buffer[k]; 
4183   2183 3B 39 24      mov d, _pass ; $pass
4184   2186 DA            push d
4185   2187 3B 39 24      mov d, _pass ; $pass
4186   218A 2A            mov b, [d]
4187   218B             ; START LOGICAL AND
4188   218B D7            push a
4189   218C 11            mov a, b
4190   218D FA 07 00      lea d, [bp + 7] ; $output
4191   2190 FD 2A         mov d, [d]
4192   2192 D7            push a
4193   2193 DA            push d
4194   2194 FA FD FF      lea d, [bp + -3] ; $j
4195   2197 2A            mov b, [d]
4196   2198             ; START TERMS
4197   2198 D7            push a
4198   2199 11            mov a, b
4199   219A 26 FF FF      mov b, $ffff
4200   219D 56            add b, a
4201   219E E4            pop a
4202   219F             ; END TERMS
4203   219F E7            pop d
4204   21A0 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
4205   21A4 E4            pop a
4206   21A5 32            mov bl, [d]
4207   21A6 A7 00         mov bh, 0
4208   21A8             ; START RELATIONAL
4209   21A8 D7            push a
4210   21A9 11            mov a, b
4211   21AA FA F2 FF      lea d, [bp + -14] ; $output_buffer
4212   21AD D7            push a
4213   21AE DA            push d
4214   21AF FA FB FF      lea d, [bp + -5] ; $k
4215   21B2 2A            mov b, [d]
4216   21B3 E7            pop d
4217   21B4 5A            add d, b
4218   21B5 E4            pop a
4219   21B6 32            mov bl, [d]
4220   21B7 A7 00         mov bh, 0
4221   21B9 B0            cmp a, b
4222   21BA FD 71         seq ; ==
4223   21BC E4            pop a
4224   21BD             ; END RELATIONAL
4225   21BD FD A7         sand a, b
4226   21BF E4            pop a
4227   21C0             ; END LOGICAL AND
4228   21C0 E7            pop d
4229   21C1 FD 43         mov [d], b
4230   21C3             ;; if(!pass){ 
4231   21C3             _if62_cond:
4232   21C3 3B 39 24      mov d, _pass ; $pass
4233   21C6 2A            mov b, [d]
4234   21C7 C0 00 00      cmp b, 0
4235   21CA FD 71         seq ; !
4236   21CC C0 00 00      cmp b, 0
4237   21CF C6 E1 21      je _if62_exit
4238   21D2             _if62_true:
4239   21D2             ;; section = 7; 
4240   21D2 3B 3B 24      mov d, _section ; $section
4241   21D5 DA            push d
4242   21D6 26 07 00      mov b, $7
4243   21D9 E7            pop d
4244   21DA FD 43         mov [d], b
4245   21DC             ;; return; 
4246   21DC F9            leave
4247   21DD 09            ret
4248   21DE 0A E1 21      jmp _if62_exit
4249   21E1             _if62_exit:
4250   21E1             _for61_update:
4251   21E1 FA FB FF      lea d, [bp + -5] ; $k
4252   21E4 2A            mov b, [d]
4253   21E5 FD 77         inc b
4254   21E7 FA FB FF      lea d, [bp + -5] ; $k
4255   21EA FD 43         mov [d], b
4256   21EC FD 7D         dec b
4257   21EE 0A 3A 21      jmp _for61_cond
4258   21F1             _for61_exit:
4259   21F1 0A F4 21      jmp _if55_exit
4260   21F4             _if55_exit:
4261   21F4             ;; output[j] = '\0'; 
4262   21F4 FA 07 00      lea d, [bp + 7] ; $output
4263   21F7 FD 2A         mov d, [d]
4264   21F9 D7            push a
4265   21FA DA            push d
4266   21FB FA FD FF      lea d, [bp + -3] ; $j
4267   21FE 2A            mov b, [d]
4268   21FF E7            pop d
4269   2200 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
4270   2204 E4            pop a
4271   2205 DA            push d
4272   2206 26 00 00      mov b, $0
4273   2209 E7            pop d
4274   220A FD 3E         mov [d], bl
4275   220C F9            leave
4276   220D 09            ret
4277   220E             ; --- END TEXT BLOCK
4278   220E             
4279   220E             ; --- BEGIN DATA BLOCK
4280   220E 61 47 56 73 _input_data: .db "aGVsbG8gd29ybGQgbXkgbmFtZSBpcyBzb2wtMS4=", 0
4280   2212 62 47 38 67 
4280   2216 64 32 39 79 
4280   221A 62 47 51 67 
4280   221E 62 58 6B 67 
4280   2222 62 6D 46 74 
4280   2226 5A 53 42 70 
4280   222A 63 79 42 7A 
4280   222E 62 32 77 74 
4280   2232 4D 53 34 3D 
4280   2236 00 
4281   2237 0E 22       _input: .dw _input_data
4282   2239 00 00 00 00 _output_data: .fill 512, 0
4282   223D 00 00 00 00 
4282   2241 00 00 00 00 
4282   2245 00 00 00 00 
4282   2249 00 00 00 00 
4282   224D 00 00 00 00 
4282   2251 00 00 00 00 
4282   2255 00 00 00 00 
4282   2259 00 00 00 00 
4282   225D 00 00 00 00 
4282   2261 00 00 00 00 
4282   2265 00 00 00 00 
4282   2269 00 00 00 00 
4282   226D 00 00 00 00 
4282   2271 00 00 00 00 
4282   2275 00 00 00 00 
4282   2279 00 00 00 00 
4282   227D 00 00 00 00 
4282   2281 00 00 00 00 
4282   2285 00 00 00 00 
4282   2289 00 00 00 00 
4282   228D 00 00 00 00 
4282   2291 00 00 00 00 
4282   2295 00 00 00 00 
4282   2299 00 00 00 00 
4282   229D 00 00 00 00 
4282   22A1 00 00 00 00 
4282   22A5 00 00 00 00 
4282   22A9 00 00 00 00 
4282   22AD 00 00 00 00 
4282   22B1 00 00 00 00 
4282   22B5 00 00 00 00 
4282   22B9 00 00 00 00 
4282   22BD 00 00 00 00 
4282   22C1 00 00 00 00 
4282   22C5 00 00 00 00 
4282   22C9 00 00 00 00 
4282   22CD 00 00 00 00 
4282   22D1 00 00 00 00 
4282   22D5 00 00 00 00 
4282   22D9 00 00 00 00 
4282   22DD 00 00 00 00 
4282   22E1 00 00 00 00 
4282   22E5 00 00 00 00 
4282   22E9 00 00 00 00 
4282   22ED 00 00 00 00 
4282   22F1 00 00 00 00 
4282   22F5 00 00 00 00 
4282   22F9 00 00 00 00 
4282   22FD 00 00 00 00 
4282   2301 00 00 00 00 
4282   2305 00 00 00 00 
4282   2309 00 00 00 00 
4282   230D 00 00 00 00 
4282   2311 00 00 00 00 
4282   2315 00 00 00 00 
4282   2319 00 00 00 00 
4282   231D 00 00 00 00 
4282   2321 00 00 00 00 
4282   2325 00 00 00 00 
4282   2329 00 00 00 00 
4282   232D 00 00 00 00 
4282   2331 00 00 00 00 
4282   2335 00 00 00 00 
4282   2339 00 00 00 00 
4282   233D 00 00 00 00 
4282   2341 00 00 00 00 
4282   2345 00 00 00 00 
4282   2349 00 00 00 00 
4282   234D 00 00 00 00 
4282   2351 00 00 00 00 
4282   2355 00 00 00 00 
4282   2359 00 00 00 00 
4282   235D 00 00 00 00 
4282   2361 00 00 00 00 
4282   2365 00 00 00 00 
4282   2369 00 00 00 00 
4282   236D 00 00 00 00 
4282   2371 00 00 00 00 
4282   2375 00 00 00 00 
4282   2379 00 00 00 00 
4282   237D 00 00 00 00 
4282   2381 00 00 00 00 
4282   2385 00 00 00 00 
4282   2389 00 00 00 00 
4282   238D 00 00 00 00 
4282   2391 00 00 00 00 
4282   2395 00 00 00 00 
4282   2399 00 00 00 00 
4282   239D 00 00 00 00 
4282   23A1 00 00 00 00 
4282   23A5 00 00 00 00 
4282   23A9 00 00 00 00 
4282   23AD 00 00 00 00 
4282   23B1 00 00 00 00 
4282   23B5 00 00 00 00 
4282   23B9 00 00 00 00 
4282   23BD 00 00 00 00 
4282   23C1 00 00 00 00 
4282   23C5 00 00 00 00 
4282   23C9 00 00 00 00 
4282   23CD 00 00 00 00 
4282   23D1 00 00 00 00 
4282   23D5 00 00 00 00 
4282   23D9 00 00 00 00 
4282   23DD 00 00 00 00 
4282   23E1 00 00 00 00 
4282   23E5 00 00 00 00 
4282   23E9 00 00 00 00 
4282   23ED 00 00 00 00 
4282   23F1 00 00 00 00 
4282   23F5 00 00 00 00 
4282   23F9 00 00 00 00 
4282   23FD 00 00 00 00 
4282   2401 00 00 00 00 
4282   2405 00 00 00 00 
4282   2409 00 00 00 00 
4282   240D 00 00 00 00 
4282   2411 00 00 00 00 
4282   2415 00 00 00 00 
4282   2419 00 00 00 00 
4282   241D 00 00 00 00 
4282   2421 00 00 00 00 
4282   2425 00 00 00 00 
4282   2429 00 00 00 00 
4282   242D 00 00 00 00 
4282   2431 00 00 00 00 
4282   2435 00 00 00 00 
4283   2439 01 00       _pass: .dw 1
4284   243B 00 00       _section: .fill 2, 0
4285   243D 0A 52 65 73 _s0: .db "\nResult: %d. Section: %d\n", 0
4285   2441 75 6C 74 3A 
4285   2445 20 25 64 2E 
4285   2449 20 53 65 63 
4285   244D 74 69 6F 6E 
4285   2451 3A 20 25 64 
4285   2455 0A 00 
4286   2457 55 6E 65 78 _s1: .db "Unexpected format in printf.", 0
4286   245B 70 65 63 74 
4286   245F 65 64 20 66 
4286   2463 6F 72 6D 61 
4286   2467 74 20 69 6E 
4286   246B 20 70 72 69 
4286   246F 6E 74 66 2E 
4286   2473 00 
4287   2474 45 72 72 6F _s2: .db "Error: Unknown argument type.\n", 0
4287   2478 72 3A 20 55 
4287   247C 6E 6B 6E 6F 
4287   2480 77 6E 20 61 
4287   2484 72 67 75 6D 
4287   2488 65 6E 74 20 
4287   248C 74 79 70 65 
4287   2490 2E 0A 00 
4288   2493 1B 5B 32 4A _s3: .db "\033[2J\033[H", 0
4288   2497 1B 5B 48 00 
4289   249B 4C 65 6E 3A _s4: .db "Len: %d\n", 0
4289   249F 20 25 64 0A 
4289   24A3 00 
4290   24A4 69 6E 70 75 _s5: .db "input_len: %d, i: %d, j: %d, k: %d, input[k]: %c, base64: %d\n", 0
4290   24A8 74 5F 6C 65 
4290   24AC 6E 3A 20 25 
4290   24B0 64 2C 20 69 
4290   24B4 3A 20 25 64 
4290   24B8 2C 20 6A 3A 
4290   24BC 20 25 64 2C 
4290   24C0 20 6B 3A 20 
4290   24C4 25 64 2C 20 
4290   24C8 69 6E 70 75 
4290   24CC 74 5B 6B 5D 
4290   24D0 3A 20 25 63 
4290   24D4 2C 20 62 61 
4290   24D8 73 65 36 34 
4290   24DC 3A 20 25 64 
4290   24E0 0A 00 
4291   24E2 49 6E 73 69 _s6: .db "Inside while loop. condition: %d\n", 0
4291   24E6 64 65 20 77 
4291   24EA 68 69 6C 65 
4291   24EE 20 6C 6F 6F 
4291   24F2 70 2E 20 63 
4291   24F6 6F 6E 64 69 
4291   24FA 74 69 6F 6E 
4291   24FE 3A 20 25 64 
4291   2502 0A 00 
4292   2504 69 73 20 69 _s7: .db "is i 4? %d\n", 0
4292   2508 20 34 3F 20 
4292   250C 25 64 0A 00 
4293   2510 69 6E 73 69 _s8: .db "inside first for loop for i=0 to 3. i = %d\n", 0
4293   2514 64 65 20 66 
4293   2518 69 72 73 74 
4293   251C 20 66 6F 72 
4293   2520 20 6C 6F 6F 
4293   2524 70 20 66 6F 
4293   2528 72 20 69 3D 
4293   252C 30 20 74 6F 
4293   2530 20 33 2E 20 
4293   2534 69 20 3D 20 
4293   2538 25 64 0A 00 
4294   253C 69 6E 70 75 _s9: .db "input_buffer[i] == base64_char_val(input_buffer[i]): %d\n", 0
4294   2540 74 5F 62 75 
4294   2544 66 66 65 72 
4294   2548 5B 69 5D 20 
4294   254C 3D 3D 20 62 
4294   2550 61 73 65 36 
4294   2554 34 5F 63 68 
4294   2558 61 72 5F 76 
4294   255C 61 6C 28 69 
4294   2560 6E 70 75 74 
4294   2564 5F 62 75 66 
4294   2568 66 65 72 5B 
4294   256C 69 5D 29 3A 
4294   2570 20 25 64 0A 
4294   2574 00 
4295   2575 69 6E 73 69 _s10: .db "inside second for loop for i=0 to 2. i = %d\n", 0
4295   2579 64 65 20 73 
4295   257D 65 63 6F 6E 
4295   2581 64 20 66 6F 
4295   2585 72 20 6C 6F 
4295   2589 6F 70 20 66 
4295   258D 6F 72 20 69 
4295   2591 3D 30 20 74 
4295   2595 6F 20 32 2E 
4295   2599 20 69 20 3D 
4295   259D 20 25 64 0A 
4295   25A1 00 
4296   25A2 6F 75 74 70 _s11: .db "output[j] == output_buffer[i]: %d\n", 0
4296   25A6 75 74 5B 6A 
4296   25AA 5D 20 3D 3D 
4296   25AE 20 6F 75 74 
4296   25B2 70 75 74 5F 
4296   25B6 62 75 66 66 
4296   25BA 65 72 5B 69 
4296   25BE 5D 3A 20 25 
4296   25C2 64 0A 00 
4297   25C5             
4298   25C5 C7 25       _heap_top: .dw _heap
4299   25C7 00          _heap: .db 0
4300   25C8             ; --- END DATA BLOCK
4301   25C8             
4302   25C8             .end
tasm: Number of errors = 0
