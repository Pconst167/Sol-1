0001   0000             ; --- FILENAME: ../solarium/usr/bin/ansitest
0002   0000             .include "lib/kernel.exp"
0001+  0000             text_org    .EQU  $0400
0002+  0000             sys_bkpt         .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_spawn_proc   .EQU  $0005
0008+  0000             sys_list         .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_boot_install .EQU  $000d
0003   0000             .include "lib/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0004   0400             .org text_org
0005   0400             
0006   0400             ; --- BEGIN TEXT BLOCK
0007   0400             main:
0008   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0009   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0010   0408             ; $fg 
0011   0408             ; $bg 
0012   0408             ; $color 
0013   0408 52 06 00      sub sp, 6
0014   040B             ;; printf("\033[2J"); 
0015   040B 26 65 12      mov b, __s0 ; "\033[2J"
0016   040E FD AB         swp b
0017   0410 D8            push b
0018   0411 07 5A 08      call printf
0019   0414 51 02 00      add sp, 2
0020   0417             ;; printf("\033[H"); 
0021   0417 26 6A 12      mov b, __s1 ; "\033[H"
0022   041A FD AB         swp b
0023   041C D8            push b
0024   041D 07 5A 08      call printf
0025   0420 51 02 00      add sp, 2
0026   0423             ;; printf("\033[1m"); 
0027   0423 26 6E 12      mov b, __s2 ; "\033[1m"
0028   0426 FD AB         swp b
0029   0428 D8            push b
0030   0429 07 5A 08      call printf
0031   042C 51 02 00      add sp, 2
0032   042F             ;; printf("Bold Text"); 
0033   042F 26 73 12      mov b, __s3 ; "Bold Text"
0034   0432 FD AB         swp b
0035   0434 D8            push b
0036   0435 07 5A 08      call printf
0037   0438 51 02 00      add sp, 2
0038   043B             ;; printf("\033[0m\n"); 
0039   043B 26 7D 12      mov b, __s4 ; "\033[0m\n"
0040   043E FD AB         swp b
0041   0440 D8            push b
0042   0441 07 5A 08      call printf
0043   0444 51 02 00      add sp, 2
0044   0447             ;; printf("\033[4m"); 
0045   0447 26 83 12      mov b, __s5 ; "\033[4m"
0046   044A FD AB         swp b
0047   044C D8            push b
0048   044D 07 5A 08      call printf
0049   0450 51 02 00      add sp, 2
0050   0453             ;; printf("Underlined Text"); 
0051   0453 26 88 12      mov b, __s6 ; "Underlined Text"
0052   0456 FD AB         swp b
0053   0458 D8            push b
0054   0459 07 5A 08      call printf
0055   045C 51 02 00      add sp, 2
0056   045F             ;; printf("\033[0m\n"); 
0057   045F 26 7D 12      mov b, __s4 ; "\033[0m\n"
0058   0462 FD AB         swp b
0059   0464 D8            push b
0060   0465 07 5A 08      call printf
0061   0468 51 02 00      add sp, 2
0062   046B             ;; printf("\033[5m"); 
0063   046B 26 98 12      mov b, __s7 ; "\033[5m"
0064   046E FD AB         swp b
0065   0470 D8            push b
0066   0471 07 5A 08      call printf
0067   0474 51 02 00      add sp, 2
0068   0477             ;; printf("Blinking Text"); 
0069   0477 26 9D 12      mov b, __s8 ; "Blinking Text"
0070   047A FD AB         swp b
0071   047C D8            push b
0072   047D 07 5A 08      call printf
0073   0480 51 02 00      add sp, 2
0074   0483             ;; printf("\033[0m\n"); 
0075   0483 26 7D 12      mov b, __s4 ; "\033[0m\n"
0076   0486 FD AB         swp b
0077   0488 D8            push b
0078   0489 07 5A 08      call printf
0079   048C 51 02 00      add sp, 2
0080   048F             ;; printf("\033[7m"); 
0081   048F 26 AB 12      mov b, __s9 ; "\033[7m"
0082   0492 FD AB         swp b
0083   0494 D8            push b
0084   0495 07 5A 08      call printf
0085   0498 51 02 00      add sp, 2
0086   049B             ;; printf("Inverted Colors"); 
0087   049B 26 B0 12      mov b, __s10 ; "Inverted Colors"
0088   049E FD AB         swp b
0089   04A0 D8            push b
0090   04A1 07 5A 08      call printf
0091   04A4 51 02 00      add sp, 2
0092   04A7             ;; printf("\033[0m\n"); 
0093   04A7 26 7D 12      mov b, __s4 ; "\033[0m\n"
0094   04AA FD AB         swp b
0095   04AC D8            push b
0096   04AD 07 5A 08      call printf
0097   04B0 51 02 00      add sp, 2
0098   04B3             ;; printf("\033[0m"); 
0099   04B3 26 C0 12      mov b, __s11 ; "\033[0m"
0100   04B6 FD AB         swp b
0101   04B8 D8            push b
0102   04B9 07 5A 08      call printf
0103   04BC 51 02 00      add sp, 2
0104   04BF             ;; printf("Reset All\n"); 
0105   04BF 26 C5 12      mov b, __s12 ; "Reset All\n"
0106   04C2 FD AB         swp b
0107   04C4 D8            push b
0108   04C5 07 5A 08      call printf
0109   04C8 51 02 00      add sp, 2
0110   04CB             ;; for (bg = 40; bg <= 47; ++bg) { 
0111   04CB             _for1_init:
0112   04CB FA FD FF      lea d, [bp + -3] ; $bg         
0113   04CE 26 28 00      mov b, $28        
0114   04D1 FD 43         mov [d], b
0115   04D3             _for1_cond:
0116   04D3 2C FD FF      mov b, [bp + -3] ; $bg             
0117   04D6             ; START RELATIONAL
0118   04D6 D7            push a
0119   04D7 11            mov a, b
0120   04D8 26 2F 00      mov b, $2f
0121   04DB B0            cmp a, b
0122   04DC FD 74         sle ; <=
0123   04DE E4            pop a
0124   04DF             ; END RELATIONAL
0125   04DF C0 00 00      cmp b, 0
0126   04E2 C6 91 05      je _for1_exit
0127   04E5             _for1_block:
0128   04E5             ;; for (fg = 30; fg <= 37; ++fg) { 
0129   04E5             _for2_init:
0130   04E5 FA FF FF      lea d, [bp + -1] ; $fg         
0131   04E8 26 1E 00      mov b, $1e        
0132   04EB FD 43         mov [d], b
0133   04ED             _for2_cond:
0134   04ED 2C FF FF      mov b, [bp + -1] ; $fg             
0135   04F0             ; START RELATIONAL
0136   04F0 D7            push a
0137   04F1 11            mov a, b
0138   04F2 26 25 00      mov b, $25
0139   04F5 B0            cmp a, b
0140   04F6 FD 74         sle ; <=
0141   04F8 E4            pop a
0142   04F9             ; END RELATIONAL
0143   04F9 C0 00 00      cmp b, 0
0144   04FC C6 78 05      je _for2_exit
0145   04FF             _for2_block:
0146   04FF             ;; printf("\033["); 
0147   04FF 26 D0 12      mov b, __s13 ; "\033["
0148   0502 FD AB         swp b
0149   0504 D8            push b
0150   0505 07 5A 08      call printf
0151   0508 51 02 00      add sp, 2
0152   050B             ;; printu(fg); 
0153   050B 2C FF FF      mov b, [bp + -1] ; $fg             
0154   050E FD AB         swp b
0155   0510 D8            push b
0156   0511 07 01 0D      call printu
0157   0514 51 02 00      add sp, 2
0158   0517             ;; printf("m\033["); 
0159   0517 26 D3 12      mov b, __s14 ; "m\033["
0160   051A FD AB         swp b
0161   051C D8            push b
0162   051D 07 5A 08      call printf
0163   0520 51 02 00      add sp, 2
0164   0523             ;; printu(bg); 
0165   0523 2C FD FF      mov b, [bp + -3] ; $bg             
0166   0526 FD AB         swp b
0167   0528 D8            push b
0168   0529 07 01 0D      call printu
0169   052C 51 02 00      add sp, 2
0170   052F             ;; printf("m "); 
0171   052F 26 D7 12      mov b, __s15 ; "m "
0172   0532 FD AB         swp b
0173   0534 D8            push b
0174   0535 07 5A 08      call printf
0175   0538 51 02 00      add sp, 2
0176   053B             ;; printu(fg); 
0177   053B 2C FF FF      mov b, [bp + -1] ; $fg             
0178   053E FD AB         swp b
0179   0540 D8            push b
0180   0541 07 01 0D      call printu
0181   0544 51 02 00      add sp, 2
0182   0547             ;; printf("/"); 
0183   0547 26 DA 12      mov b, __s16 ; "/"
0184   054A FD AB         swp b
0185   054C D8            push b
0186   054D 07 5A 08      call printf
0187   0550 51 02 00      add sp, 2
0188   0553             ;; printu(bg); 
0189   0553 2C FD FF      mov b, [bp + -3] ; $bg             
0190   0556 FD AB         swp b
0191   0558 D8            push b
0192   0559 07 01 0D      call printu
0193   055C 51 02 00      add sp, 2
0194   055F             ;; printf(" "); 
0195   055F 26 DC 12      mov b, __s17 ; " "
0196   0562 FD AB         swp b
0197   0564 D8            push b
0198   0565 07 5A 08      call printf
0199   0568 51 02 00      add sp, 2
0200   056B             _for2_update:
0201   056B 2C FF FF      mov b, [bp + -1] ; $fg             
0202   056E FD 77         inc b
0203   0570 FA FF FF      lea d, [bp + -1] ; $fg
0204   0573 FD 43         mov [d], b
0205   0575 0A ED 04      jmp _for2_cond
0206   0578             _for2_exit:
0207   0578             ;; printf("\033[0m\n"); 
0208   0578 26 7D 12      mov b, __s4 ; "\033[0m\n"
0209   057B FD AB         swp b
0210   057D D8            push b
0211   057E 07 5A 08      call printf
0212   0581 51 02 00      add sp, 2
0213   0584             _for1_update:
0214   0584 2C FD FF      mov b, [bp + -3] ; $bg             
0215   0587 FD 77         inc b
0216   0589 FA FD FF      lea d, [bp + -3] ; $bg
0217   058C FD 43         mov [d], b
0218   058E 0A D3 04      jmp _for1_cond
0219   0591             _for1_exit:
0220   0591             ;; printf("256-Color Chart:\n"); 
0221   0591 26 DE 12      mov b, __s18 ; "256-Color Chart:\n"
0222   0594 FD AB         swp b
0223   0596 D8            push b
0224   0597 07 5A 08      call printf
0225   059A 51 02 00      add sp, 2
0226   059D             ;; for (color = 0; color < 256; ++color) { 
0227   059D             _for3_init:
0228   059D FA FB FF      lea d, [bp + -5] ; $color         
0229   05A0 26 00 00      mov b, $0        
0230   05A3 FD 43         mov [d], b
0231   05A5             _for3_cond:
0232   05A5 2C FB FF      mov b, [bp + -5] ; $color             
0233   05A8             ; START RELATIONAL
0234   05A8 D7            push a
0235   05A9 11            mov a, b
0236   05AA 26 00 01      mov b, $100
0237   05AD B0            cmp a, b
0238   05AE FD 73         slt ; < 
0239   05B0 E4            pop a
0240   05B1             ; END RELATIONAL
0241   05B1 C0 00 00      cmp b, 0
0242   05B4 C6 32 06      je _for3_exit
0243   05B7             _for3_block:
0244   05B7             ;; printf("\033[48;5;"); 
0245   05B7 26 F0 12      mov b, __s19 ; "\033[48;5;"
0246   05BA FD AB         swp b
0247   05BC D8            push b
0248   05BD 07 5A 08      call printf
0249   05C0 51 02 00      add sp, 2
0250   05C3             ;; printu(color); 
0251   05C3 2C FB FF      mov b, [bp + -5] ; $color             
0252   05C6 FD AB         swp b
0253   05C8 D8            push b
0254   05C9 07 01 0D      call printu
0255   05CC 51 02 00      add sp, 2
0256   05CF             ;; printf("m  "); 
0257   05CF 26 F8 12      mov b, __s20 ; "m  "
0258   05D2 FD AB         swp b
0259   05D4 D8            push b
0260   05D5 07 5A 08      call printf
0261   05D8 51 02 00      add sp, 2
0262   05DB             ;; printu(color); 
0263   05DB 2C FB FF      mov b, [bp + -5] ; $color             
0264   05DE FD AB         swp b
0265   05E0 D8            push b
0266   05E1 07 01 0D      call printu
0267   05E4 51 02 00      add sp, 2
0268   05E7             ;; printf(" \033[0m"); 
0269   05E7 26 FC 12      mov b, __s21 ; " \033[0m"
0270   05EA FD AB         swp b
0271   05EC D8            push b
0272   05ED 07 5A 08      call printf
0273   05F0 51 02 00      add sp, 2
0274   05F3             ;; if ((color + 1) % 16 == 0) { 
0275   05F3             _if4_cond:
0276   05F3 2C FB FF      mov b, [bp + -5] ; $color             
0277   05F6             ; START TERMS
0278   05F6 D7            push a
0279   05F7 11            mov a, b
0280   05F8 26 01 00      mov b, $1
0281   05FB 54            add a, b
0282   05FC 27            mov b, a
0283   05FD E4            pop a
0284   05FE             ; END TERMS
0285   05FE             ; START FACTORS
0286   05FE D7            push a
0287   05FF 11            mov a, b
0288   0600 26 10 00      mov b, $10
0289   0603 AE            div a, b ; 
0290   0604 11            mov a, b
0291   0605 27            mov b, a
0292   0606 E4            pop a
0293   0607             ; END FACTORS
0294   0607             ; START RELATIONAL
0295   0607 D7            push a
0296   0608 11            mov a, b
0297   0609 26 00 00      mov b, $0
0298   060C B0            cmp a, b
0299   060D FD 71         seq ; ==
0300   060F E4            pop a
0301   0610             ; END RELATIONAL
0302   0610 C0 00 00      cmp b, 0
0303   0613 C6 25 06      je _if4_exit
0304   0616             _if4_true:
0305   0616             ;; printf("\n"); 
0306   0616 26 02 13      mov b, __s22 ; "\n"
0307   0619 FD AB         swp b
0308   061B D8            push b
0309   061C 07 5A 08      call printf
0310   061F 51 02 00      add sp, 2
0311   0622 0A 25 06      jmp _if4_exit
0312   0625             _if4_exit:
0313   0625             _for3_update:
0314   0625 2C FB FF      mov b, [bp + -5] ; $color             
0315   0628 FD 77         inc b
0316   062A FA FB FF      lea d, [bp + -5] ; $color
0317   062D FD 43         mov [d], b
0318   062F 0A A5 05      jmp _for3_cond
0319   0632             _for3_exit:
0320   0632             ;; return 0; 
0321   0632 26 00 00      mov b, $0
0322   0635 F9            leave
0323   0636 05 0B         syscall sys_terminate_proc
0324   0638             
0325   0638             strcpy:
0326   0638 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0327   063B             ; $psrc 
0328   063B             ; $pdest 
0329   063B 52 04 00      sub sp, 4
0330   063E             ;; psrc = src; 
0331   063E FA FF FF      lea d, [bp + -1] ; $psrc         
0332   0641 2C 05 00      mov b, [bp + 5] ; $src                     
0333   0644 FD 43         mov [d], b
0334   0646             ;; pdest = dest; 
0335   0646 FA FD FF      lea d, [bp + -3] ; $pdest         
0336   0649 2C 07 00      mov b, [bp + 7] ; $dest                     
0337   064C FD 43         mov [d], b
0338   064E             ;; while(*psrc) *pdest++ = *psrc++; 
0339   064E             _while5_cond:
0340   064E 2C FF FF      mov b, [bp + -1] ; $psrc             
0341   0651 74            mov d, b
0342   0652 32            mov bl, [d]
0343   0653 A7 00         mov bh, 0
0344   0655 C0 00 00      cmp b, 0
0345   0658 C6 82 06      je _while5_exit
0346   065B             _while5_block:
0347   065B             ;; *pdest++ = *psrc++; 
0348   065B 2C FD FF      mov b, [bp + -3] ; $pdest             
0349   065E FD 79         mov g, b
0350   0660 FD 77         inc b
0351   0662 FA FD FF      lea d, [bp + -3] ; $pdest
0352   0665 FD 43         mov [d], b
0353   0667 FD 27         mov b, g
0354   0669 D8            push b
0355   066A 2C FF FF      mov b, [bp + -1] ; $psrc             
0356   066D FD 79         mov g, b
0357   066F FD 77         inc b
0358   0671 FA FF FF      lea d, [bp + -1] ; $psrc
0359   0674 FD 43         mov [d], b
0360   0676 FD 27         mov b, g
0361   0678 74            mov d, b
0362   0679 32            mov bl, [d]
0363   067A A7 00         mov bh, 0
0364   067C E7            pop d
0365   067D FD 3E         mov [d], bl
0366   067F 0A 4E 06      jmp _while5_cond
0367   0682             _while5_exit:
0368   0682             ;; *pdest = '\0'; 
0369   0682 2C FD FF      mov b, [bp + -3] ; $pdest             
0370   0685 D8            push b
0371   0686 26 00 00      mov b, $0
0372   0689 E7            pop d
0373   068A FD 3E         mov [d], bl
0374   068C F9            leave
0375   068D 09            ret
0376   068E             
0377   068E             strcmp:
0378   068E F8 00 00      enter 0 ; (push bp; mov bp, sp)
0379   0691             ;; while (*s1 && (*s1 == *s2)) { 
0380   0691             _while6_cond:
0381   0691 2C 07 00      mov b, [bp + 7] ; $s1             
0382   0694 74            mov d, b
0383   0695 32            mov bl, [d]
0384   0696 A7 00         mov bh, 0
0385   0698 D7            push a
0386   0699 11            mov a, b
0387   069A 2C 07 00      mov b, [bp + 7] ; $s1             
0388   069D 74            mov d, b
0389   069E 32            mov bl, [d]
0390   069F A7 00         mov bh, 0
0391   06A1             ; START RELATIONAL
0392   06A1 D7            push a
0393   06A2 11            mov a, b
0394   06A3 2C 05 00      mov b, [bp + 5] ; $s2             
0395   06A6 74            mov d, b
0396   06A7 32            mov bl, [d]
0397   06A8 A7 00         mov bh, 0
0398   06AA B0            cmp a, b
0399   06AB FD 71         seq ; ==
0400   06AD E4            pop a
0401   06AE             ; END RELATIONAL
0402   06AE FD A7         sand a, b ; &&
0403   06B0 E4            pop a
0404   06B1 C0 00 00      cmp b, 0
0405   06B4 C6 D6 06      je _while6_exit
0406   06B7             _while6_block:
0407   06B7             ;; s1++; 
0408   06B7 2C 07 00      mov b, [bp + 7] ; $s1             
0409   06BA FD 79         mov g, b
0410   06BC FD 77         inc b
0411   06BE FA 07 00      lea d, [bp + 7] ; $s1
0412   06C1 FD 43         mov [d], b
0413   06C3 FD 27         mov b, g
0414   06C5             ;; s2++; 
0415   06C5 2C 05 00      mov b, [bp + 5] ; $s2             
0416   06C8 FD 79         mov g, b
0417   06CA FD 77         inc b
0418   06CC FA 05 00      lea d, [bp + 5] ; $s2
0419   06CF FD 43         mov [d], b
0420   06D1 FD 27         mov b, g
0421   06D3 0A 91 06      jmp _while6_cond
0422   06D6             _while6_exit:
0423   06D6             ;; return *s1 - *s2; 
0424   06D6 2C 07 00      mov b, [bp + 7] ; $s1             
0425   06D9 74            mov d, b
0426   06DA 32            mov bl, [d]
0427   06DB A7 00         mov bh, 0
0428   06DD             ; START TERMS
0429   06DD D7            push a
0430   06DE 11            mov a, b
0431   06DF 2C 05 00      mov b, [bp + 5] ; $s2             
0432   06E2 74            mov d, b
0433   06E3 32            mov bl, [d]
0434   06E4 A7 00         mov bh, 0
0435   06E6 60            sub a, b
0436   06E7 27            mov b, a
0437   06E8 E4            pop a
0438   06E9             ; END TERMS
0439   06E9 F9            leave
0440   06EA 09            ret
0441   06EB             
0442   06EB             strcat:
0443   06EB F8 00 00      enter 0 ; (push bp; mov bp, sp)
0444   06EE             ; $dest_len 
0445   06EE             ; $i 
0446   06EE 52 04 00      sub sp, 4
0447   06F1             ;; dest_len = strlen(dest); 
0448   06F1 FA FF FF      lea d, [bp + -1] ; $dest_len
0449   06F4 DA            push d
0450   06F5 2C 07 00      mov b, [bp + 7] ; $dest             
0451   06F8 FD AB         swp b
0452   06FA D8            push b
0453   06FB 07 8A 07      call strlen
0454   06FE 51 02 00      add sp, 2
0455   0701 E7            pop d
0456   0702 FD 43         mov [d], b
0457   0704             ;; for (i = 0; src[i] != 0; i=i+1) { 
0458   0704             _for7_init:
0459   0704 FA FD FF      lea d, [bp + -3] ; $i         
0460   0707 26 00 00      mov b, $0        
0461   070A FD 43         mov [d], b
0462   070C             _for7_cond:
0463   070C FA 05 00      lea d, [bp + 5] ; $src
0464   070F FD 2A         mov d, [d]
0465   0711 D7            push a         
0466   0712 2C FD FF      mov b, [bp + -3] ; $i                     
0467   0715 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0468   0719 E4            pop a
0469   071A 32            mov bl, [d]
0470   071B A7 00         mov bh, 0
0471   071D             ; START RELATIONAL
0472   071D D7            push a
0473   071E 11            mov a, b
0474   071F 26 00 00      mov b, $0
0475   0722 B0            cmp a, b
0476   0723 FD 72         sneq ; !=
0477   0725 E4            pop a
0478   0726             ; END RELATIONAL
0479   0726 C0 00 00      cmp b, 0
0480   0729 C6 6A 07      je _for7_exit
0481   072C             _for7_block:
0482   072C             ;; dest[dest_len + i] = src[i]; 
0483   072C FA 07 00      lea d, [bp + 7] ; $dest
0484   072F FD 2A         mov d, [d]
0485   0731 D7            push a         
0486   0732 2C FF FF      mov b, [bp + -1] ; $dest_len             
0487   0735             ; START TERMS
0488   0735 D7            push a
0489   0736 11            mov a, b
0490   0737 2C FD FF      mov b, [bp + -3] ; $i             
0491   073A 54            add a, b
0492   073B 27            mov b, a
0493   073C E4            pop a
0494   073D             ; END TERMS        
0495   073D FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0496   0741 E4            pop a
0497   0742 DA            push d
0498   0743 FA 05 00      lea d, [bp + 5] ; $src
0499   0746 FD 2A         mov d, [d]
0500   0748 D7            push a         
0501   0749 2C FD FF      mov b, [bp + -3] ; $i                     
0502   074C FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0503   0750 E4            pop a
0504   0751 32            mov bl, [d]
0505   0752 A7 00         mov bh, 0
0506   0754 E7            pop d
0507   0755 FD 3E         mov [d], bl
0508   0757             _for7_update:
0509   0757 FA FD FF      lea d, [bp + -3] ; $i         
0510   075A 2C FD FF      mov b, [bp + -3] ; $i             
0511   075D             ; START TERMS
0512   075D D7            push a
0513   075E 11            mov a, b
0514   075F 26 01 00      mov b, $1
0515   0762 54            add a, b
0516   0763 27            mov b, a
0517   0764 E4            pop a
0518   0765             ; END TERMS        
0519   0765 FD 43         mov [d], b
0520   0767 0A 0C 07      jmp _for7_cond
0521   076A             _for7_exit:
0522   076A             ;; dest[dest_len + i] = 0; 
0523   076A FA 07 00      lea d, [bp + 7] ; $dest
0524   076D FD 2A         mov d, [d]
0525   076F D7            push a         
0526   0770 2C FF FF      mov b, [bp + -1] ; $dest_len             
0527   0773             ; START TERMS
0528   0773 D7            push a
0529   0774 11            mov a, b
0530   0775 2C FD FF      mov b, [bp + -3] ; $i             
0531   0778 54            add a, b
0532   0779 27            mov b, a
0533   077A E4            pop a
0534   077B             ; END TERMS        
0535   077B FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0536   077F E4            pop a         
0537   0780 26 00 00      mov b, $0        
0538   0783 FD 3E         mov [d], bl
0539   0785             ;; return dest; 
0540   0785 2C 07 00      mov b, [bp + 7] ; $dest             
0541   0788 F9            leave
0542   0789 09            ret
0543   078A             
0544   078A             strlen:
0545   078A F8 00 00      enter 0 ; (push bp; mov bp, sp)
0546   078D             ; $length 
0547   078D 52 02 00      sub sp, 2
0548   0790             ;; length = 0; 
0549   0790 FA FF FF      lea d, [bp + -1] ; $length         
0550   0793 26 00 00      mov b, $0        
0551   0796 FD 43         mov [d], b
0552   0798             ;; while (str[length] != 0) { 
0553   0798             _while8_cond:
0554   0798 FA 05 00      lea d, [bp + 5] ; $str
0555   079B FD 2A         mov d, [d]
0556   079D D7            push a         
0557   079E 2C FF FF      mov b, [bp + -1] ; $length                     
0558   07A1 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0559   07A5 E4            pop a
0560   07A6 32            mov bl, [d]
0561   07A7 A7 00         mov bh, 0
0562   07A9             ; START RELATIONAL
0563   07A9 D7            push a
0564   07AA 11            mov a, b
0565   07AB 26 00 00      mov b, $0
0566   07AE B0            cmp a, b
0567   07AF FD 72         sneq ; !=
0568   07B1 E4            pop a
0569   07B2             ; END RELATIONAL
0570   07B2 C0 00 00      cmp b, 0
0571   07B5 C6 C9 07      je _while8_exit
0572   07B8             _while8_block:
0573   07B8             ;; length++; 
0574   07B8 2C FF FF      mov b, [bp + -1] ; $length             
0575   07BB FD 79         mov g, b
0576   07BD FD 77         inc b
0577   07BF FA FF FF      lea d, [bp + -1] ; $length
0578   07C2 FD 43         mov [d], b
0579   07C4 FD 27         mov b, g
0580   07C6 0A 98 07      jmp _while8_cond
0581   07C9             _while8_exit:
0582   07C9             ;; return length; 
0583   07C9 2C FF FF      mov b, [bp + -1] ; $length             
0584   07CC F9            leave
0585   07CD 09            ret
0586   07CE             
0587   07CE             va_arg:
0588   07CE F8 00 00      enter 0 ; (push bp; mov bp, sp)
0589   07D1             ; $val 
0590   07D1 52 02 00      sub sp, 2
0591   07D4             ;; if(size == 1){ 
0592   07D4             _if9_cond:
0593   07D4 2C 05 00      mov b, [bp + 5] ; $size             
0594   07D7             ; START RELATIONAL
0595   07D7 D7            push a
0596   07D8 11            mov a, b
0597   07D9 26 01 00      mov b, $1
0598   07DC B0            cmp a, b
0599   07DD FD 71         seq ; ==
0600   07DF E4            pop a
0601   07E0             ; END RELATIONAL
0602   07E0 C0 00 00      cmp b, 0
0603   07E3 C6 FF 07      je _if9_else
0604   07E6             _if9_true:
0605   07E6             ;; val = *(char*)arg->p; 
0606   07E6 FA FF FF      lea d, [bp + -1] ; $val
0607   07E9 DA            push d
0608   07EA FA 07 00      lea d, [bp + 7] ; $arg
0609   07ED FD 2A         mov d, [d]
0610   07EF 58 00 00      add d, 0
0611   07F2 FD 14         clb
0612   07F4 2A            mov b, [d]
0613   07F5 74            mov d, b
0614   07F6 32            mov bl, [d]
0615   07F7 A7 00         mov bh, 0
0616   07F9 E7            pop d
0617   07FA FD 43         mov [d], b
0618   07FC 0A 34 08      jmp _if9_exit
0619   07FF             _if9_else:
0620   07FF             ;; if(size == 2){ 
0621   07FF             _if10_cond:
0622   07FF 2C 05 00      mov b, [bp + 5] ; $size             
0623   0802             ; START RELATIONAL
0624   0802 D7            push a
0625   0803 11            mov a, b
0626   0804 26 02 00      mov b, $2
0627   0807 B0            cmp a, b
0628   0808 FD 71         seq ; ==
0629   080A E4            pop a
0630   080B             ; END RELATIONAL
0631   080B C0 00 00      cmp b, 0
0632   080E C6 28 08      je _if10_else
0633   0811             _if10_true:
0634   0811             ;; val = *(int*)arg->p; 
0635   0811 FA FF FF      lea d, [bp + -1] ; $val
0636   0814 DA            push d
0637   0815 FA 07 00      lea d, [bp + 7] ; $arg
0638   0818 FD 2A         mov d, [d]
0639   081A 58 00 00      add d, 0
0640   081D FD 14         clb
0641   081F 2A            mov b, [d]
0642   0820 74            mov d, b
0643   0821 2A            mov b, [d]
0644   0822 E7            pop d
0645   0823 FD 43         mov [d], b
0646   0825 0A 34 08      jmp _if10_exit
0647   0828             _if10_else:
0648   0828             ;; print("Unknown type size in va_arg() call. Size needs to be either 1 or 2."); 
0649   0828 26 04 13      mov b, __s23 ; "Unknown type size in va_arg() call. Size needs to be either 1 or 2."
0650   082B FD AB         swp b
0651   082D D8            push b
0652   082E 07 1D 0E      call print
0653   0831 51 02 00      add sp, 2
0654   0834             _if10_exit:
0655   0834             _if9_exit:
0656   0834             ;; arg->p = arg->p + size; 
0657   0834 FA 07 00      lea d, [bp + 7] ; $arg
0658   0837 FD 2A         mov d, [d]
0659   0839 58 00 00      add d, 0
0660   083C FD 14         clb
0661   083E DA            push d
0662   083F FA 07 00      lea d, [bp + 7] ; $arg
0663   0842 FD 2A         mov d, [d]
0664   0844 58 00 00      add d, 0
0665   0847 FD 14         clb
0666   0849 2A            mov b, [d]
0667   084A             ; START TERMS
0668   084A D7            push a
0669   084B 11            mov a, b
0670   084C 2C 05 00      mov b, [bp + 5] ; $size             
0671   084F 54            add a, b
0672   0850 27            mov b, a
0673   0851 E4            pop a
0674   0852             ; END TERMS
0675   0852 E7            pop d
0676   0853 FD 43         mov [d], b
0677   0855             ;; return val; 
0678   0855 2C FF FF      mov b, [bp + -1] ; $val             
0679   0858 F9            leave
0680   0859 09            ret
0681   085A             
0682   085A             printf:
0683   085A F8 00 00      enter 0 ; (push bp; mov bp, sp)
0684   085D             ; $p 
0685   085D             ; $fp 
0686   085D             ; $i 
0687   085D 52 06 00      sub sp, 6
0688   0860             ;; fp = format; 
0689   0860 FA FD FF      lea d, [bp + -3] ; $fp         
0690   0863 2C 05 00      mov b, [bp + 5] ; $format                     
0691   0866 FD 43         mov [d], b
0692   0868             ;; p = &format; 
0693   0868 FA FF FF      lea d, [bp + -1] ; $p
0694   086B DA            push d
0695   086C FA 05 00      lea d, [bp + 5] ; $format
0696   086F 2D            mov b, d
0697   0870 E7            pop d
0698   0871 FD 43         mov [d], b
0699   0873             ;; for(;;){ 
0700   0873             _for11_init:
0701   0873             _for11_cond:
0702   0873             _for11_block:
0703   0873             ;; if(!*fp) break; 
0704   0873             _if12_cond:
0705   0873 2C FD FF      mov b, [bp + -3] ; $fp             
0706   0876 74            mov d, b
0707   0877 32            mov bl, [d]
0708   0878 A7 00         mov bh, 0
0709   087A C0 00 00      cmp b, 0
0710   087D FD 71         seq ; !
0711   087F C0 00 00      cmp b, 0
0712   0882 C6 8B 08      je _if12_exit
0713   0885             _if12_true:
0714   0885             ;; break; 
0715   0885 0A BB 09      jmp _for11_exit ; for break
0716   0888 0A 8B 08      jmp _if12_exit
0717   088B             _if12_exit:
0718   088B             ;; if(*fp == '%'){ 
0719   088B             _if13_cond:
0720   088B 2C FD FF      mov b, [bp + -3] ; $fp             
0721   088E 74            mov d, b
0722   088F 32            mov bl, [d]
0723   0890 A7 00         mov bh, 0
0724   0892             ; START RELATIONAL
0725   0892 D7            push a
0726   0893 11            mov a, b
0727   0894 26 25 00      mov b, $25
0728   0897 B0            cmp a, b
0729   0898 FD 71         seq ; ==
0730   089A E4            pop a
0731   089B             ; END RELATIONAL
0732   089B C0 00 00      cmp b, 0
0733   089E C6 9C 09      je _if13_else
0734   08A1             _if13_true:
0735   08A1             ;; fp++; 
0736   08A1 2C FD FF      mov b, [bp + -3] ; $fp             
0737   08A4 FD 79         mov g, b
0738   08A6 FD 77         inc b
0739   08A8 FA FD FF      lea d, [bp + -3] ; $fp
0740   08AB FD 43         mov [d], b
0741   08AD FD 27         mov b, g
0742   08AF             ;; switch(*fp){ 
0743   08AF             _switch14_expr:
0744   08AF 2C FD FF      mov b, [bp + -3] ; $fp             
0745   08B2 74            mov d, b
0746   08B3 32            mov bl, [d]
0747   08B4 A7 00         mov bh, 0
0748   08B6             _switch14_comparisons:
0749   08B6 C1 64         cmp bl, $64
0750   08B8 C6 DA 08      je _switch14_case0
0751   08BB C1 69         cmp bl, $69
0752   08BD C6 DA 08      je _switch14_case1
0753   08C0 C1 75         cmp bl, $75
0754   08C2 C6 FB 08      je _switch14_case2
0755   08C5 C1 78         cmp bl, $78
0756   08C7 C6 1C 09      je _switch14_case3
0757   08CA C1 63         cmp bl, $63
0758   08CC C6 3D 09      je _switch14_case4
0759   08CF C1 73         cmp bl, $73
0760   08D1 C6 5E 09      je _switch14_case5
0761   08D4 0A 7F 09      jmp _switch14_default
0762   08D7 0A 8B 09      jmp _switch14_exit
0763   08DA             _switch14_case0:
0764   08DA             _switch14_case1:
0765   08DA             ;; p = p - 2; 
0766   08DA FA FF FF      lea d, [bp + -1] ; $p         
0767   08DD 2C FF FF      mov b, [bp + -1] ; $p             
0768   08E0             ; START TERMS
0769   08E0 D7            push a
0770   08E1 11            mov a, b
0771   08E2 26 02 00      mov b, $2
0772   08E5 60            sub a, b
0773   08E6 27            mov b, a
0774   08E7 E4            pop a
0775   08E8             ; END TERMS        
0776   08E8 FD 43         mov [d], b
0777   08EA             ;; prints(*(int*)p); 
0778   08EA 2C FF FF      mov b, [bp + -1] ; $p             
0779   08ED 74            mov d, b
0780   08EE 2A            mov b, [d]
0781   08EF FD AB         swp b
0782   08F1 D8            push b
0783   08F2 07 21 0C      call prints
0784   08F5 51 02 00      add sp, 2
0785   08F8             ;; break; 
0786   08F8 0A 8B 09      jmp _switch14_exit ; case break
0787   08FB             _switch14_case2:
0788   08FB             ;; p = p - 2; 
0789   08FB FA FF FF      lea d, [bp + -1] ; $p         
0790   08FE 2C FF FF      mov b, [bp + -1] ; $p             
0791   0901             ; START TERMS
0792   0901 D7            push a
0793   0902 11            mov a, b
0794   0903 26 02 00      mov b, $2
0795   0906 60            sub a, b
0796   0907 27            mov b, a
0797   0908 E4            pop a
0798   0909             ; END TERMS        
0799   0909 FD 43         mov [d], b
0800   090B             ;; printu(*(unsigned int*)p); 
0801   090B 2C FF FF      mov b, [bp + -1] ; $p             
0802   090E 74            mov d, b
0803   090F 2A            mov b, [d]
0804   0910 FD AB         swp b
0805   0912 D8            push b
0806   0913 07 01 0D      call printu
0807   0916 51 02 00      add sp, 2
0808   0919             ;; break; 
0809   0919 0A 8B 09      jmp _switch14_exit ; case break
0810   091C             _switch14_case3:
0811   091C             ;; p = p - 2; 
0812   091C FA FF FF      lea d, [bp + -1] ; $p         
0813   091F 2C FF FF      mov b, [bp + -1] ; $p             
0814   0922             ; START TERMS
0815   0922 D7            push a
0816   0923 11            mov a, b
0817   0924 26 02 00      mov b, $2
0818   0927 60            sub a, b
0819   0928 27            mov b, a
0820   0929 E4            pop a
0821   092A             ; END TERMS        
0822   092A FD 43         mov [d], b
0823   092C             ;; printx16(*(unsigned int*)p); 
0824   092C 2C FF FF      mov b, [bp + -1] ; $p             
0825   092F 74            mov d, b
0826   0930 2A            mov b, [d]
0827   0931 FD AB         swp b
0828   0933 D8            push b
0829   0934 07 BD 09      call printx16
0830   0937 51 02 00      add sp, 2
0831   093A             ;; break; 
0832   093A 0A 8B 09      jmp _switch14_exit ; case break
0833   093D             _switch14_case4:
0834   093D             ;; p = p - 2; 
0835   093D FA FF FF      lea d, [bp + -1] ; $p         
0836   0940 2C FF FF      mov b, [bp + -1] ; $p             
0837   0943             ; START TERMS
0838   0943 D7            push a
0839   0944 11            mov a, b
0840   0945 26 02 00      mov b, $2
0841   0948 60            sub a, b
0842   0949 27            mov b, a
0843   094A E4            pop a
0844   094B             ; END TERMS        
0845   094B FD 43         mov [d], b
0846   094D             ;; putchar(*(char*)p); 
0847   094D 2C FF FF      mov b, [bp + -1] ; $p             
0848   0950 74            mov d, b
0849   0951 32            mov bl, [d]
0850   0952 A7 00         mov bh, 0
0851   0954 DD            push bl
0852   0955 07 D8 0D      call putchar
0853   0958 51 01 00      add sp, 1
0854   095B             ;; break; 
0855   095B 0A 8B 09      jmp _switch14_exit ; case break
0856   095E             _switch14_case5:
0857   095E             ;; p = p - 2; 
0858   095E FA FF FF      lea d, [bp + -1] ; $p         
0859   0961 2C FF FF      mov b, [bp + -1] ; $p             
0860   0964             ; START TERMS
0861   0964 D7            push a
0862   0965 11            mov a, b
0863   0966 26 02 00      mov b, $2
0864   0969 60            sub a, b
0865   096A 27            mov b, a
0866   096B E4            pop a
0867   096C             ; END TERMS        
0868   096C FD 43         mov [d], b
0869   096E             ;; print(*(char**)p); 
0870   096E 2C FF FF      mov b, [bp + -1] ; $p             
0871   0971 74            mov d, b
0872   0972 2A            mov b, [d]
0873   0973 FD AB         swp b
0874   0975 D8            push b
0875   0976 07 1D 0E      call print
0876   0979 51 02 00      add sp, 2
0877   097C             ;; break; 
0878   097C 0A 8B 09      jmp _switch14_exit ; case break
0879   097F             _switch14_default:
0880   097F             ;; print("Error: Unknown argument type.\n"); 
0881   097F 26 48 13      mov b, __s24 ; "Error: Unknown argument type.\n"
0882   0982 FD AB         swp b
0883   0984 D8            push b
0884   0985 07 1D 0E      call print
0885   0988 51 02 00      add sp, 2
0886   098B             _switch14_exit:
0887   098B             ;; fp++; 
0888   098B 2C FD FF      mov b, [bp + -3] ; $fp             
0889   098E FD 79         mov g, b
0890   0990 FD 77         inc b
0891   0992 FA FD FF      lea d, [bp + -3] ; $fp
0892   0995 FD 43         mov [d], b
0893   0997 FD 27         mov b, g
0894   0999 0A B8 09      jmp _if13_exit
0895   099C             _if13_else:
0896   099C             ;; putchar(*fp); 
0897   099C 2C FD FF      mov b, [bp + -3] ; $fp             
0898   099F 74            mov d, b
0899   09A0 32            mov bl, [d]
0900   09A1 A7 00         mov bh, 0
0901   09A3 DD            push bl
0902   09A4 07 D8 0D      call putchar
0903   09A7 51 01 00      add sp, 1
0904   09AA             ;; fp++; 
0905   09AA 2C FD FF      mov b, [bp + -3] ; $fp             
0906   09AD FD 79         mov g, b
0907   09AF FD 77         inc b
0908   09B1 FA FD FF      lea d, [bp + -3] ; $fp
0909   09B4 FD 43         mov [d], b
0910   09B6 FD 27         mov b, g
0911   09B8             _if13_exit:
0912   09B8             _for11_update:
0913   09B8 0A 73 08      jmp _for11_cond
0914   09BB             _for11_exit:
0915   09BB F9            leave
0916   09BC 09            ret
0917   09BD             
0918   09BD             printx16:
0919   09BD F8 00 00      enter 0 ; (push bp; mov bp, sp)
0920   09C0             
0921   09C0             ; --- BEGIN INLINE ASM BLOCK
0922   09C0 2C 05 00      mov b, [bp + 5] ; $hex             
0923   09C3 07 65 11      call print_u16x
0924   09C6             ; --- END INLINE ASM BLOCK
0925   09C6             
0926   09C6 F9            leave
0927   09C7 09            ret
0928   09C8             
0929   09C8             printx8:
0930   09C8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0931   09CB             
0932   09CB             ; --- BEGIN INLINE ASM BLOCK
0933   09CB FA 05 00      lea d, [bp + 5] ; $hex
0934   09CE 32            mov bl, [d]
0935   09CF 07 A9 11      call print_u8x
0936   09D2             ; --- END INLINE ASM BLOCK
0937   09D2             
0938   09D2 F9            leave
0939   09D3 09            ret
0940   09D4             
0941   09D4             hex_to_int:
0942   09D4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0943   09D7             ; $value 
0944   09D7 10 00 00      mov a, $0
0945   09DA 45 FF FF      mov [bp + -1], a
0946   09DD             ; $i 
0947   09DD             ; $hex_char 
0948   09DD             ; $len 
0949   09DD 52 07 00      sub sp, 7
0950   09E0             ;; len = strlen(hex_string); 
0951   09E0 FA FA FF      lea d, [bp + -6] ; $len
0952   09E3 DA            push d
0953   09E4 2C 05 00      mov b, [bp + 5] ; $hex_string             
0954   09E7 FD AB         swp b
0955   09E9 D8            push b
0956   09EA 07 8A 07      call strlen
0957   09ED 51 02 00      add sp, 2
0958   09F0 E7            pop d
0959   09F1 FD 43         mov [d], b
0960   09F3             ;; for (i = 0; i < len; i++) { 
0961   09F3             _for15_init:
0962   09F3 FA FD FF      lea d, [bp + -3] ; $i         
0963   09F6 26 00 00      mov b, $0        
0964   09F9 FD 43         mov [d], b
0965   09FB             _for15_cond:
0966   09FB 2C FD FF      mov b, [bp + -3] ; $i             
0967   09FE             ; START RELATIONAL
0968   09FE D7            push a
0969   09FF 11            mov a, b
0970   0A00 2C FA FF      mov b, [bp + -6] ; $len             
0971   0A03 B0            cmp a, b
0972   0A04 FD 73         slt ; < 
0973   0A06 E4            pop a
0974   0A07             ; END RELATIONAL
0975   0A07 C0 00 00      cmp b, 0
0976   0A0A C6 FB 0A      je _for15_exit
0977   0A0D             _for15_block:
0978   0A0D             ;; hex_char = hex_string[i]; 
0979   0A0D FA FC FF      lea d, [bp + -4] ; $hex_char
0980   0A10 DA            push d
0981   0A11 FA 05 00      lea d, [bp + 5] ; $hex_string
0982   0A14 FD 2A         mov d, [d]
0983   0A16 D7            push a         
0984   0A17 2C FD FF      mov b, [bp + -3] ; $i                     
0985   0A1A FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
0986   0A1E E4            pop a
0987   0A1F 32            mov bl, [d]
0988   0A20 A7 00         mov bh, 0
0989   0A22 E7            pop d
0990   0A23 FD 3E         mov [d], bl
0991   0A25             ;; if (hex_char >= 'a' && hex_char <= 'f')  
0992   0A25             _if16_cond:
0993   0A25 34 FC FF      mov bl, [bp + -4] ; $hex_char
0994   0A28 A7 00         mov bh, 0             
0995   0A2A             ; START RELATIONAL
0996   0A2A D7            push a
0997   0A2B 11            mov a, b
0998   0A2C 26 61 00      mov b, $61
0999   0A2F B0            cmp a, b
1000   0A30 FD 80         sge ; >=
1001   0A32 E4            pop a
1002   0A33             ; END RELATIONAL
1003   0A33 D7            push a
1004   0A34 11            mov a, b
1005   0A35 34 FC FF      mov bl, [bp + -4] ; $hex_char
1006   0A38 A7 00         mov bh, 0             
1007   0A3A             ; START RELATIONAL
1008   0A3A D7            push a
1009   0A3B 11            mov a, b
1010   0A3C 26 66 00      mov b, $66
1011   0A3F B0            cmp a, b
1012   0A40 FD 74         sle ; <=
1013   0A42 E4            pop a
1014   0A43             ; END RELATIONAL
1015   0A43 FD A7         sand a, b ; &&
1016   0A45 E4            pop a
1017   0A46 C0 00 00      cmp b, 0
1018   0A49 C6 76 0A      je _if16_else
1019   0A4C             _if16_true:
1020   0A4C             ;; value = (value * 16) + (hex_char - 'a' + 10); 
1021   0A4C FA FF FF      lea d, [bp + -1] ; $value         
1022   0A4F 2C FF FF      mov b, [bp + -1] ; $value             
1023   0A52             ; START FACTORS
1024   0A52 D7            push a
1025   0A53 11            mov a, b
1026   0A54 26 10 00      mov b, $10
1027   0A57 AC            mul a, b ; *
1028   0A58 11            mov a, b
1029   0A59 27            mov b, a
1030   0A5A E4            pop a
1031   0A5B             ; END FACTORS
1032   0A5B             ; START TERMS
1033   0A5B D7            push a
1034   0A5C 11            mov a, b
1035   0A5D 34 FC FF      mov bl, [bp + -4] ; $hex_char
1036   0A60 A7 00         mov bh, 0             
1037   0A62             ; START TERMS
1038   0A62 D7            push a
1039   0A63 11            mov a, b
1040   0A64 26 61 00      mov b, $61
1041   0A67 60            sub a, b
1042   0A68 26 0A 00      mov b, $a
1043   0A6B 54            add a, b
1044   0A6C 27            mov b, a
1045   0A6D E4            pop a
1046   0A6E             ; END TERMS
1047   0A6E 54            add a, b
1048   0A6F 27            mov b, a
1049   0A70 E4            pop a
1050   0A71             ; END TERMS        
1051   0A71 FD 43         mov [d], b
1052   0A73 0A EA 0A      jmp _if16_exit
1053   0A76             _if16_else:
1054   0A76             ;; if (hex_char >= 'A' && hex_char <= 'F')  
1055   0A76             _if17_cond:
1056   0A76 34 FC FF      mov bl, [bp + -4] ; $hex_char
1057   0A79 A7 00         mov bh, 0             
1058   0A7B             ; START RELATIONAL
1059   0A7B D7            push a
1060   0A7C 11            mov a, b
1061   0A7D 26 41 00      mov b, $41
1062   0A80 B0            cmp a, b
1063   0A81 FD 80         sge ; >=
1064   0A83 E4            pop a
1065   0A84             ; END RELATIONAL
1066   0A84 D7            push a
1067   0A85 11            mov a, b
1068   0A86 34 FC FF      mov bl, [bp + -4] ; $hex_char
1069   0A89 A7 00         mov bh, 0             
1070   0A8B             ; START RELATIONAL
1071   0A8B D7            push a
1072   0A8C 11            mov a, b
1073   0A8D 26 46 00      mov b, $46
1074   0A90 B0            cmp a, b
1075   0A91 FD 74         sle ; <=
1076   0A93 E4            pop a
1077   0A94             ; END RELATIONAL
1078   0A94 FD A7         sand a, b ; &&
1079   0A96 E4            pop a
1080   0A97 C0 00 00      cmp b, 0
1081   0A9A C6 C7 0A      je _if17_else
1082   0A9D             _if17_true:
1083   0A9D             ;; value = (value * 16) + (hex_char - 'A' + 10); 
1084   0A9D FA FF FF      lea d, [bp + -1] ; $value         
1085   0AA0 2C FF FF      mov b, [bp + -1] ; $value             
1086   0AA3             ; START FACTORS
1087   0AA3 D7            push a
1088   0AA4 11            mov a, b
1089   0AA5 26 10 00      mov b, $10
1090   0AA8 AC            mul a, b ; *
1091   0AA9 11            mov a, b
1092   0AAA 27            mov b, a
1093   0AAB E4            pop a
1094   0AAC             ; END FACTORS
1095   0AAC             ; START TERMS
1096   0AAC D7            push a
1097   0AAD 11            mov a, b
1098   0AAE 34 FC FF      mov bl, [bp + -4] ; $hex_char
1099   0AB1 A7 00         mov bh, 0             
1100   0AB3             ; START TERMS
1101   0AB3 D7            push a
1102   0AB4 11            mov a, b
1103   0AB5 26 41 00      mov b, $41
1104   0AB8 60            sub a, b
1105   0AB9 26 0A 00      mov b, $a
1106   0ABC 54            add a, b
1107   0ABD 27            mov b, a
1108   0ABE E4            pop a
1109   0ABF             ; END TERMS
1110   0ABF 54            add a, b
1111   0AC0 27            mov b, a
1112   0AC1 E4            pop a
1113   0AC2             ; END TERMS        
1114   0AC2 FD 43         mov [d], b
1115   0AC4 0A EA 0A      jmp _if17_exit
1116   0AC7             _if17_else:
1117   0AC7             ;; value = (value * 16) + (hex_char - '0'); 
1118   0AC7 FA FF FF      lea d, [bp + -1] ; $value         
1119   0ACA 2C FF FF      mov b, [bp + -1] ; $value             
1120   0ACD             ; START FACTORS
1121   0ACD D7            push a
1122   0ACE 11            mov a, b
1123   0ACF 26 10 00      mov b, $10
1124   0AD2 AC            mul a, b ; *
1125   0AD3 11            mov a, b
1126   0AD4 27            mov b, a
1127   0AD5 E4            pop a
1128   0AD6             ; END FACTORS
1129   0AD6             ; START TERMS
1130   0AD6 D7            push a
1131   0AD7 11            mov a, b
1132   0AD8 34 FC FF      mov bl, [bp + -4] ; $hex_char
1133   0ADB A7 00         mov bh, 0             
1134   0ADD             ; START TERMS
1135   0ADD D7            push a
1136   0ADE 11            mov a, b
1137   0ADF 26 30 00      mov b, $30
1138   0AE2 60            sub a, b
1139   0AE3 27            mov b, a
1140   0AE4 E4            pop a
1141   0AE5             ; END TERMS
1142   0AE5 54            add a, b
1143   0AE6 27            mov b, a
1144   0AE7 E4            pop a
1145   0AE8             ; END TERMS        
1146   0AE8 FD 43         mov [d], b
1147   0AEA             _if17_exit:
1148   0AEA             _if16_exit:
1149   0AEA             _for15_update:
1150   0AEA 2C FD FF      mov b, [bp + -3] ; $i             
1151   0AED FD 79         mov g, b
1152   0AEF FD 77         inc b
1153   0AF1 FA FD FF      lea d, [bp + -3] ; $i
1154   0AF4 FD 43         mov [d], b
1155   0AF6 FD 27         mov b, g
1156   0AF8 0A FB 09      jmp _for15_cond
1157   0AFB             _for15_exit:
1158   0AFB             ;; return value; 
1159   0AFB 2C FF FF      mov b, [bp + -1] ; $value             
1160   0AFE F9            leave
1161   0AFF 09            ret
1162   0B00             
1163   0B00             atoi:
1164   0B00 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1165   0B03             ; $result 
1166   0B03 10 00 00      mov a, $0
1167   0B06 45 FF FF      mov [bp + -1], a
1168   0B09             ; $sign 
1169   0B09 10 01 00      mov a, $1
1170   0B0C 45 FD FF      mov [bp + -3], a
1171   0B0F 52 04 00      sub sp, 4
1172   0B12             ;; while (*str == ' ') str++; 
1173   0B12             _while18_cond:
1174   0B12 2C 05 00      mov b, [bp + 5] ; $str             
1175   0B15 74            mov d, b
1176   0B16 32            mov bl, [d]
1177   0B17 A7 00         mov bh, 0
1178   0B19             ; START RELATIONAL
1179   0B19 D7            push a
1180   0B1A 11            mov a, b
1181   0B1B 26 20 00      mov b, $20
1182   0B1E B0            cmp a, b
1183   0B1F FD 71         seq ; ==
1184   0B21 E4            pop a
1185   0B22             ; END RELATIONAL
1186   0B22 C0 00 00      cmp b, 0
1187   0B25 C6 39 0B      je _while18_exit
1188   0B28             _while18_block:
1189   0B28             ;; str++; 
1190   0B28 2C 05 00      mov b, [bp + 5] ; $str             
1191   0B2B FD 79         mov g, b
1192   0B2D FD 77         inc b
1193   0B2F FA 05 00      lea d, [bp + 5] ; $str
1194   0B32 FD 43         mov [d], b
1195   0B34 FD 27         mov b, g
1196   0B36 0A 12 0B      jmp _while18_cond
1197   0B39             _while18_exit:
1198   0B39             ;; if (*str == '-' || *str == '+') { 
1199   0B39             _if19_cond:
1200   0B39 2C 05 00      mov b, [bp + 5] ; $str             
1201   0B3C 74            mov d, b
1202   0B3D 32            mov bl, [d]
1203   0B3E A7 00         mov bh, 0
1204   0B40             ; START RELATIONAL
1205   0B40 D7            push a
1206   0B41 11            mov a, b
1207   0B42 26 2D 00      mov b, $2d
1208   0B45 B0            cmp a, b
1209   0B46 FD 71         seq ; ==
1210   0B48 E4            pop a
1211   0B49             ; END RELATIONAL
1212   0B49 D7            push a
1213   0B4A 11            mov a, b
1214   0B4B 2C 05 00      mov b, [bp + 5] ; $str             
1215   0B4E 74            mov d, b
1216   0B4F 32            mov bl, [d]
1217   0B50 A7 00         mov bh, 0
1218   0B52             ; START RELATIONAL
1219   0B52 D7            push a
1220   0B53 11            mov a, b
1221   0B54 26 2B 00      mov b, $2b
1222   0B57 B0            cmp a, b
1223   0B58 FD 71         seq ; ==
1224   0B5A E4            pop a
1225   0B5B             ; END RELATIONAL
1226   0B5B FD A8         sor a, b ; ||
1227   0B5D E4            pop a
1228   0B5E C0 00 00      cmp b, 0
1229   0B61 C6 98 0B      je _if19_exit
1230   0B64             _if19_true:
1231   0B64             ;; if (*str == '-') sign = -1; 
1232   0B64             _if20_cond:
1233   0B64 2C 05 00      mov b, [bp + 5] ; $str             
1234   0B67 74            mov d, b
1235   0B68 32            mov bl, [d]
1236   0B69 A7 00         mov bh, 0
1237   0B6B             ; START RELATIONAL
1238   0B6B D7            push a
1239   0B6C 11            mov a, b
1240   0B6D 26 2D 00      mov b, $2d
1241   0B70 B0            cmp a, b
1242   0B71 FD 71         seq ; ==
1243   0B73 E4            pop a
1244   0B74             ; END RELATIONAL
1245   0B74 C0 00 00      cmp b, 0
1246   0B77 C6 87 0B      je _if20_exit
1247   0B7A             _if20_true:
1248   0B7A             ;; sign = -1; 
1249   0B7A FA FD FF      lea d, [bp + -3] ; $sign         
1250   0B7D 26 01 00      mov b, $1
1251   0B80 FD 97         neg b        
1252   0B82 FD 43         mov [d], b
1253   0B84 0A 87 0B      jmp _if20_exit
1254   0B87             _if20_exit:
1255   0B87             ;; str++; 
1256   0B87 2C 05 00      mov b, [bp + 5] ; $str             
1257   0B8A FD 79         mov g, b
1258   0B8C FD 77         inc b
1259   0B8E FA 05 00      lea d, [bp + 5] ; $str
1260   0B91 FD 43         mov [d], b
1261   0B93 FD 27         mov b, g
1262   0B95 0A 98 0B      jmp _if19_exit
1263   0B98             _if19_exit:
1264   0B98             ;; while (*str >= '0' && *str <= '9') { 
1265   0B98             _while21_cond:
1266   0B98 2C 05 00      mov b, [bp + 5] ; $str             
1267   0B9B 74            mov d, b
1268   0B9C 32            mov bl, [d]
1269   0B9D A7 00         mov bh, 0
1270   0B9F             ; START RELATIONAL
1271   0B9F D7            push a
1272   0BA0 11            mov a, b
1273   0BA1 26 30 00      mov b, $30
1274   0BA4 B0            cmp a, b
1275   0BA5 FD 80         sge ; >=
1276   0BA7 E4            pop a
1277   0BA8             ; END RELATIONAL
1278   0BA8 D7            push a
1279   0BA9 11            mov a, b
1280   0BAA 2C 05 00      mov b, [bp + 5] ; $str             
1281   0BAD 74            mov d, b
1282   0BAE 32            mov bl, [d]
1283   0BAF A7 00         mov bh, 0
1284   0BB1             ; START RELATIONAL
1285   0BB1 D7            push a
1286   0BB2 11            mov a, b
1287   0BB3 26 39 00      mov b, $39
1288   0BB6 B0            cmp a, b
1289   0BB7 FD 74         sle ; <=
1290   0BB9 E4            pop a
1291   0BBA             ; END RELATIONAL
1292   0BBA FD A7         sand a, b ; &&
1293   0BBC E4            pop a
1294   0BBD C0 00 00      cmp b, 0
1295   0BC0 C6 FB 0B      je _while21_exit
1296   0BC3             _while21_block:
1297   0BC3             ;; result = result * 10 + (*str - '0'); 
1298   0BC3 FA FF FF      lea d, [bp + -1] ; $result
1299   0BC6 DA            push d
1300   0BC7 2C FF FF      mov b, [bp + -1] ; $result             
1301   0BCA             ; START FACTORS
1302   0BCA D7            push a
1303   0BCB 11            mov a, b
1304   0BCC 26 0A 00      mov b, $a
1305   0BCF AC            mul a, b ; *
1306   0BD0 11            mov a, b
1307   0BD1 27            mov b, a
1308   0BD2 E4            pop a
1309   0BD3             ; END FACTORS
1310   0BD3             ; START TERMS
1311   0BD3 D7            push a
1312   0BD4 11            mov a, b
1313   0BD5 2C 05 00      mov b, [bp + 5] ; $str             
1314   0BD8 74            mov d, b
1315   0BD9 32            mov bl, [d]
1316   0BDA A7 00         mov bh, 0
1317   0BDC             ; START TERMS
1318   0BDC D7            push a
1319   0BDD 11            mov a, b
1320   0BDE 26 30 00      mov b, $30
1321   0BE1 60            sub a, b
1322   0BE2 27            mov b, a
1323   0BE3 E4            pop a
1324   0BE4             ; END TERMS
1325   0BE4 54            add a, b
1326   0BE5 27            mov b, a
1327   0BE6 E4            pop a
1328   0BE7             ; END TERMS
1329   0BE7 E7            pop d
1330   0BE8 FD 43         mov [d], b
1331   0BEA             ;; str++; 
1332   0BEA 2C 05 00      mov b, [bp + 5] ; $str             
1333   0BED FD 79         mov g, b
1334   0BEF FD 77         inc b
1335   0BF1 FA 05 00      lea d, [bp + 5] ; $str
1336   0BF4 FD 43         mov [d], b
1337   0BF6 FD 27         mov b, g
1338   0BF8 0A 98 0B      jmp _while21_cond
1339   0BFB             _while21_exit:
1340   0BFB             ;; return sign * result; 
1341   0BFB 2C FD FF      mov b, [bp + -3] ; $sign             
1342   0BFE             ; START FACTORS
1343   0BFE D7            push a
1344   0BFF 11            mov a, b
1345   0C00 2C FF FF      mov b, [bp + -1] ; $result             
1346   0C03 AC            mul a, b ; *
1347   0C04 11            mov a, b
1348   0C05 27            mov b, a
1349   0C06 E4            pop a
1350   0C07             ; END FACTORS
1351   0C07 F9            leave
1352   0C08 09            ret
1353   0C09             
1354   0C09             gets:
1355   0C09 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1356   0C0C             
1357   0C0C             ; --- BEGIN INLINE ASM BLOCK
1358   0C0C 17 05 00      mov a, [bp + 5] ; $s             
1359   0C0F 3C            mov d, a
1360   0C10 07 CA 0F      call _gets
1361   0C13             ; --- END INLINE ASM BLOCK
1362   0C13             
1363   0C13             ;; return strlen(s); 
1364   0C13 2C 05 00      mov b, [bp + 5] ; $s             
1365   0C16 FD AB         swp b
1366   0C18 D8            push b
1367   0C19 07 8A 07      call strlen
1368   0C1C 51 02 00      add sp, 2
1369   0C1F F9            leave
1370   0C20 09            ret
1371   0C21             
1372   0C21             prints:
1373   0C21 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1374   0C24             ; $digits 
1375   0C24             ; $i 
1376   0C24 10 00 00      mov a, $0
1377   0C27 45 FA FF      mov [bp + -6], a
1378   0C2A 52 07 00      sub sp, 7
1379   0C2D             ;; if (num < 0) { 
1380   0C2D             _if22_cond:
1381   0C2D 2C 05 00      mov b, [bp + 5] ; $num             
1382   0C30             ; START RELATIONAL
1383   0C30 D7            push a
1384   0C31 11            mov a, b
1385   0C32 26 00 00      mov b, $0
1386   0C35 B0            cmp a, b
1387   0C36 FD 73         slt ; < 
1388   0C38 E4            pop a
1389   0C39             ; END RELATIONAL
1390   0C39 C0 00 00      cmp b, 0
1391   0C3C C6 56 0C      je _if22_else
1392   0C3F             _if22_true:
1393   0C3F             ;; putchar('-'); 
1394   0C3F 26 2D 00      mov b, $2d
1395   0C42 DD            push bl
1396   0C43 07 D8 0D      call putchar
1397   0C46 51 01 00      add sp, 1
1398   0C49             ;; num = -num; 
1399   0C49 FA 05 00      lea d, [bp + 5] ; $num         
1400   0C4C 2C 05 00      mov b, [bp + 5] ; $num             
1401   0C4F FD 97         neg b        
1402   0C51 FD 43         mov [d], b
1403   0C53 0A 77 0C      jmp _if22_exit
1404   0C56             _if22_else:
1405   0C56             ;; if (num == 0) { 
1406   0C56             _if23_cond:
1407   0C56 2C 05 00      mov b, [bp + 5] ; $num             
1408   0C59             ; START RELATIONAL
1409   0C59 D7            push a
1410   0C5A 11            mov a, b
1411   0C5B 26 00 00      mov b, $0
1412   0C5E B0            cmp a, b
1413   0C5F FD 71         seq ; ==
1414   0C61 E4            pop a
1415   0C62             ; END RELATIONAL
1416   0C62 C0 00 00      cmp b, 0
1417   0C65 C6 77 0C      je _if23_exit
1418   0C68             _if23_true:
1419   0C68             ;; putchar('0'); 
1420   0C68 26 30 00      mov b, $30
1421   0C6B DD            push bl
1422   0C6C 07 D8 0D      call putchar
1423   0C6F 51 01 00      add sp, 1
1424   0C72             ;; return; 
1425   0C72 F9            leave
1426   0C73 09            ret
1427   0C74 0A 77 0C      jmp _if23_exit
1428   0C77             _if23_exit:
1429   0C77             _if22_exit:
1430   0C77             ;; while (num > 0) { 
1431   0C77             _while24_cond:
1432   0C77 2C 05 00      mov b, [bp + 5] ; $num             
1433   0C7A             ; START RELATIONAL
1434   0C7A D7            push a
1435   0C7B 11            mov a, b
1436   0C7C 26 00 00      mov b, $0
1437   0C7F B0            cmp a, b
1438   0C80 FD 7F         sgt ; >
1439   0C82 E4            pop a
1440   0C83             ; END RELATIONAL
1441   0C83 C0 00 00      cmp b, 0
1442   0C86 C6 C9 0C      je _while24_exit
1443   0C89             _while24_block:
1444   0C89             ;; digits[i] = '0' + (num % 10); 
1445   0C89 FA FC FF      lea d, [bp + -4] ; $digits
1446   0C8C D7            push a         
1447   0C8D 2C FA FF      mov b, [bp + -6] ; $i                     
1448   0C90 5A            add d, b
1449   0C91 E4            pop a         
1450   0C92 26 30 00      mov b, $30
1451   0C95             ; START TERMS
1452   0C95 D7            push a
1453   0C96 11            mov a, b
1454   0C97 2C 05 00      mov b, [bp + 5] ; $num             
1455   0C9A             ; START FACTORS
1456   0C9A D7            push a
1457   0C9B 11            mov a, b
1458   0C9C 26 0A 00      mov b, $a
1459   0C9F AE            div a, b ; 
1460   0CA0 11            mov a, b
1461   0CA1 27            mov b, a
1462   0CA2 E4            pop a
1463   0CA3             ; END FACTORS
1464   0CA3 54            add a, b
1465   0CA4 27            mov b, a
1466   0CA5 E4            pop a
1467   0CA6             ; END TERMS        
1468   0CA6 FD 3E         mov [d], bl
1469   0CA8             ;; num = num / 10; 
1470   0CA8 FA 05 00      lea d, [bp + 5] ; $num         
1471   0CAB 2C 05 00      mov b, [bp + 5] ; $num             
1472   0CAE             ; START FACTORS
1473   0CAE D7            push a
1474   0CAF 11            mov a, b
1475   0CB0 26 0A 00      mov b, $a
1476   0CB3 AE            div a, b
1477   0CB4 27            mov b, a
1478   0CB5 E4            pop a
1479   0CB6             ; END FACTORS        
1480   0CB6 FD 43         mov [d], b
1481   0CB8             ;; i++; 
1482   0CB8 2C FA FF      mov b, [bp + -6] ; $i             
1483   0CBB FD 79         mov g, b
1484   0CBD FD 77         inc b
1485   0CBF FA FA FF      lea d, [bp + -6] ; $i
1486   0CC2 FD 43         mov [d], b
1487   0CC4 FD 27         mov b, g
1488   0CC6 0A 77 0C      jmp _while24_cond
1489   0CC9             _while24_exit:
1490   0CC9             ;; while (i > 0) { 
1491   0CC9             _while25_cond:
1492   0CC9 2C FA FF      mov b, [bp + -6] ; $i             
1493   0CCC             ; START RELATIONAL
1494   0CCC D7            push a
1495   0CCD 11            mov a, b
1496   0CCE 26 00 00      mov b, $0
1497   0CD1 B0            cmp a, b
1498   0CD2 FD 7F         sgt ; >
1499   0CD4 E4            pop a
1500   0CD5             ; END RELATIONAL
1501   0CD5 C0 00 00      cmp b, 0
1502   0CD8 C6 FF 0C      je _while25_exit
1503   0CDB             _while25_block:
1504   0CDB             ;; i--; 
1505   0CDB 2C FA FF      mov b, [bp + -6] ; $i             
1506   0CDE FD 79         mov g, b
1507   0CE0 FD 7D         dec b
1508   0CE2 FA FA FF      lea d, [bp + -6] ; $i
1509   0CE5 FD 43         mov [d], b
1510   0CE7 FD 27         mov b, g
1511   0CE9             ;; putchar(digits[i]); 
1512   0CE9 FA FC FF      lea d, [bp + -4] ; $digits
1513   0CEC D7            push a         
1514   0CED 2C FA FF      mov b, [bp + -6] ; $i                     
1515   0CF0 5A            add d, b
1516   0CF1 E4            pop a
1517   0CF2 32            mov bl, [d]
1518   0CF3 A7 00         mov bh, 0
1519   0CF5 DD            push bl
1520   0CF6 07 D8 0D      call putchar
1521   0CF9 51 01 00      add sp, 1
1522   0CFC 0A C9 0C      jmp _while25_cond
1523   0CFF             _while25_exit:
1524   0CFF F9            leave
1525   0D00 09            ret
1526   0D01             
1527   0D01             printu:
1528   0D01 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1529   0D04             ; $digits 
1530   0D04             ; $i 
1531   0D04 52 07 00      sub sp, 7
1532   0D07             ;; i = 0; 
1533   0D07 FA FA FF      lea d, [bp + -6] ; $i         
1534   0D0A 26 00 00      mov b, $0        
1535   0D0D FD 43         mov [d], b
1536   0D0F             ;; if(num == 0){ 
1537   0D0F             _if26_cond:
1538   0D0F 2C 05 00      mov b, [bp + 5] ; $num             
1539   0D12             ; START RELATIONAL
1540   0D12 D7            push a
1541   0D13 11            mov a, b
1542   0D14 26 00 00      mov b, $0
1543   0D17 B0            cmp a, b
1544   0D18 FD 71         seq ; ==
1545   0D1A E4            pop a
1546   0D1B             ; END RELATIONAL
1547   0D1B C0 00 00      cmp b, 0
1548   0D1E C6 30 0D      je _if26_exit
1549   0D21             _if26_true:
1550   0D21             ;; putchar('0'); 
1551   0D21 26 30 00      mov b, $30
1552   0D24 DD            push bl
1553   0D25 07 D8 0D      call putchar
1554   0D28 51 01 00      add sp, 1
1555   0D2B             ;; return; 
1556   0D2B F9            leave
1557   0D2C 09            ret
1558   0D2D 0A 30 0D      jmp _if26_exit
1559   0D30             _if26_exit:
1560   0D30             ;; while (num > 0) { 
1561   0D30             _while27_cond:
1562   0D30 2C 05 00      mov b, [bp + 5] ; $num             
1563   0D33             ; START RELATIONAL
1564   0D33 D7            push a
1565   0D34 11            mov a, b
1566   0D35 26 00 00      mov b, $0
1567   0D38 B0            cmp a, b
1568   0D39 FD 81         sgu ; > (unsigned)
1569   0D3B E4            pop a
1570   0D3C             ; END RELATIONAL
1571   0D3C C0 00 00      cmp b, 0
1572   0D3F C6 82 0D      je _while27_exit
1573   0D42             _while27_block:
1574   0D42             ;; digits[i] = '0' + (num % 10); 
1575   0D42 FA FC FF      lea d, [bp + -4] ; $digits
1576   0D45 D7            push a         
1577   0D46 2C FA FF      mov b, [bp + -6] ; $i                     
1578   0D49 5A            add d, b
1579   0D4A E4            pop a         
1580   0D4B 26 30 00      mov b, $30
1581   0D4E             ; START TERMS
1582   0D4E D7            push a
1583   0D4F 11            mov a, b
1584   0D50 2C 05 00      mov b, [bp + 5] ; $num             
1585   0D53             ; START FACTORS
1586   0D53 D7            push a
1587   0D54 11            mov a, b
1588   0D55 26 0A 00      mov b, $a
1589   0D58 AE            div a, b ; 
1590   0D59 11            mov a, b
1591   0D5A 27            mov b, a
1592   0D5B E4            pop a
1593   0D5C             ; END FACTORS
1594   0D5C 54            add a, b
1595   0D5D 27            mov b, a
1596   0D5E E4            pop a
1597   0D5F             ; END TERMS        
1598   0D5F FD 3E         mov [d], bl
1599   0D61             ;; num = num / 10; 
1600   0D61 FA 05 00      lea d, [bp + 5] ; $num         
1601   0D64 2C 05 00      mov b, [bp + 5] ; $num             
1602   0D67             ; START FACTORS
1603   0D67 D7            push a
1604   0D68 11            mov a, b
1605   0D69 26 0A 00      mov b, $a
1606   0D6C AE            div a, b
1607   0D6D 27            mov b, a
1608   0D6E E4            pop a
1609   0D6F             ; END FACTORS        
1610   0D6F FD 43         mov [d], b
1611   0D71             ;; i++; 
1612   0D71 2C FA FF      mov b, [bp + -6] ; $i             
1613   0D74 FD 79         mov g, b
1614   0D76 FD 77         inc b
1615   0D78 FA FA FF      lea d, [bp + -6] ; $i
1616   0D7B FD 43         mov [d], b
1617   0D7D FD 27         mov b, g
1618   0D7F 0A 30 0D      jmp _while27_cond
1619   0D82             _while27_exit:
1620   0D82             ;; while (i > 0) { 
1621   0D82             _while28_cond:
1622   0D82 2C FA FF      mov b, [bp + -6] ; $i             
1623   0D85             ; START RELATIONAL
1624   0D85 D7            push a
1625   0D86 11            mov a, b
1626   0D87 26 00 00      mov b, $0
1627   0D8A B0            cmp a, b
1628   0D8B FD 7F         sgt ; >
1629   0D8D E4            pop a
1630   0D8E             ; END RELATIONAL
1631   0D8E C0 00 00      cmp b, 0
1632   0D91 C6 B8 0D      je _while28_exit
1633   0D94             _while28_block:
1634   0D94             ;; i--; 
1635   0D94 2C FA FF      mov b, [bp + -6] ; $i             
1636   0D97 FD 79         mov g, b
1637   0D99 FD 7D         dec b
1638   0D9B FA FA FF      lea d, [bp + -6] ; $i
1639   0D9E FD 43         mov [d], b
1640   0DA0 FD 27         mov b, g
1641   0DA2             ;; putchar(digits[i]); 
1642   0DA2 FA FC FF      lea d, [bp + -4] ; $digits
1643   0DA5 D7            push a         
1644   0DA6 2C FA FF      mov b, [bp + -6] ; $i                     
1645   0DA9 5A            add d, b
1646   0DAA E4            pop a
1647   0DAB 32            mov bl, [d]
1648   0DAC A7 00         mov bh, 0
1649   0DAE DD            push bl
1650   0DAF 07 D8 0D      call putchar
1651   0DB2 51 01 00      add sp, 1
1652   0DB5 0A 82 0D      jmp _while28_cond
1653   0DB8             _while28_exit:
1654   0DB8 F9            leave
1655   0DB9 09            ret
1656   0DBA             
1657   0DBA             rand:
1658   0DBA F8 00 00      enter 0 ; (push bp; mov bp, sp)
1659   0DBD             ; $sec 
1660   0DBD 52 01 00      sub sp, 1
1661   0DC0             
1662   0DC0             ; --- BEGIN INLINE ASM BLOCK
1663   0DC0 19 00         mov al, 0
1664   0DC2 05 01         syscall sys_rtc					
1665   0DC4 1A            mov al, ah
1666   0DC5 20 00 00      mov al, [bp + 0] ; $sec
1667   0DC8                         
1668   0DC8             ; --- END INLINE ASM BLOCK
1669   0DC8             
1670   0DC8             ;; return sec; 
1671   0DC8 34 00 00      mov bl, [bp + 0] ; $sec
1672   0DCB A7 00         mov bh, 0             
1673   0DCD F9            leave
1674   0DCE 09            ret
1675   0DCF             
1676   0DCF             date:
1677   0DCF F8 00 00      enter 0 ; (push bp; mov bp, sp)
1678   0DD2             
1679   0DD2             ; --- BEGIN INLINE ASM BLOCK
1680   0DD2 19 00         mov al, 0 
1681   0DD4 05 07         syscall sys_datetime
1682   0DD6             ; --- END INLINE ASM BLOCK
1683   0DD6             
1684   0DD6 F9            leave
1685   0DD7 09            ret
1686   0DD8             
1687   0DD8             putchar:
1688   0DD8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1689   0DDB             
1690   0DDB             ; --- BEGIN INLINE ASM BLOCK
1691   0DDB 20 05 00      mov al, [bp + 5] ; $c
1692   0DDE                         
1693   0DDE 23            mov ah, al
1694   0DDF 07 C3 0F      call _putchar
1695   0DE2             ; --- END INLINE ASM BLOCK
1696   0DE2             
1697   0DE2 F9            leave
1698   0DE3 09            ret
1699   0DE4             
1700   0DE4             getchar:
1701   0DE4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1702   0DE7             ; $c 
1703   0DE7 52 01 00      sub sp, 1
1704   0DEA             
1705   0DEA             ; --- BEGIN INLINE ASM BLOCK
1706   0DEA 07 BC 0F      call getch
1707   0DED 1A            mov al, ah
1708   0DEE FA 00 00      lea d, [bp + 0] ; $c
1709   0DF1 3E            mov [d], al
1710   0DF2             ; --- END INLINE ASM BLOCK
1711   0DF2             
1712   0DF2             ;; return c; 
1713   0DF2 34 00 00      mov bl, [bp + 0] ; $c
1714   0DF5 A7 00         mov bh, 0             
1715   0DF7 F9            leave
1716   0DF8 09            ret
1717   0DF9             
1718   0DF9             scann:
1719   0DF9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1720   0DFC             ; $m 
1721   0DFC 52 02 00      sub sp, 2
1722   0DFF             
1723   0DFF             ; --- BEGIN INLINE ASM BLOCK
1724   0DFF 07 07 12      call scan_u16d
1725   0E02 FA FF FF      lea d, [bp + -1] ; $m
1726   0E05 43            mov [d], a
1727   0E06             ; --- END INLINE ASM BLOCK
1728   0E06             
1729   0E06             ;; return m; 
1730   0E06 2C FF FF      mov b, [bp + -1] ; $m             
1731   0E09 F9            leave
1732   0E0A 09            ret
1733   0E0B             
1734   0E0B             puts:
1735   0E0B F8 00 00      enter 0 ; (push bp; mov bp, sp)
1736   0E0E             
1737   0E0E             ; --- BEGIN INLINE ASM BLOCK
1738   0E0E 17 05 00      mov a, [bp + 5] ; $s             
1739   0E11 3C            mov d, a
1740   0E12 07 0D 11      call _puts
1741   0E15 22 0A         mov ah, $0A
1742   0E17 19 00         mov al, 0
1743   0E19 05 03         syscall sys_io
1744   0E1B             ; --- END INLINE ASM BLOCK
1745   0E1B             
1746   0E1B F9            leave
1747   0E1C 09            ret
1748   0E1D             
1749   0E1D             print:
1750   0E1D F8 00 00      enter 0 ; (push bp; mov bp, sp)
1751   0E20             
1752   0E20             ; --- BEGIN INLINE ASM BLOCK
1753   0E20 17 05 00      mov a, [bp + 5] ; $s             
1754   0E23 3C            mov d, a
1755   0E24 07 0D 11      call _puts
1756   0E27             ; --- END INLINE ASM BLOCK
1757   0E27             
1758   0E27 F9            leave
1759   0E28 09            ret
1760   0E29             
1761   0E29             loadfile:
1762   0E29 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1763   0E2C             
1764   0E2C             ; --- BEGIN INLINE ASM BLOCK
1765   0E2C 17 05 00      mov a, [bp + 5] ; $destination             
1766   0E2F 4F            mov di, a
1767   0E30 FA 07 00      lea d, [bp + 7] ; $filename
1768   0E33 FD 2A         mov d, [d]
1769   0E35 19 14         mov al, 20
1770   0E37 05 04         syscall sys_filesystem
1771   0E39             ; --- END INLINE ASM BLOCK
1772   0E39             
1773   0E39 F9            leave
1774   0E3A 09            ret
1775   0E3B             
1776   0E3B             create_file:
1777   0E3B F8 00 00      enter 0 ; (push bp; mov bp, sp)
1778   0E3E F9            leave
1779   0E3F 09            ret
1780   0E40             
1781   0E40             delete_file:
1782   0E40 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1783   0E43             
1784   0E43             ; --- BEGIN INLINE ASM BLOCK
1785   0E43 FA 05 00      lea d, [bp + 5] ; $filename
1786   0E46 19 0A         mov al, 10
1787   0E48 05 04         syscall sys_filesystem
1788   0E4A             ; --- END INLINE ASM BLOCK
1789   0E4A             
1790   0E4A F9            leave
1791   0E4B 09            ret
1792   0E4C             
1793   0E4C             fopen:
1794   0E4C F8 00 00      enter 0 ; (push bp; mov bp, sp)
1795   0E4F F9            leave
1796   0E50 09            ret
1797   0E51             
1798   0E51             fclose:
1799   0E51 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1800   0E54 F9            leave
1801   0E55 09            ret
1802   0E56             
1803   0E56             alloc:
1804   0E56 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1805   0E59             ;; heap_top = heap_top + bytes; 
1806   0E59 3B 67 13      mov d, _heap_top ; $heap_top         
1807   0E5C 29 67 13      mov b, [_heap_top] ; $heap_top           
1808   0E5F             ; START TERMS
1809   0E5F D7            push a
1810   0E60 11            mov a, b
1811   0E61 2C 05 00      mov b, [bp + 5] ; $bytes             
1812   0E64 54            add a, b
1813   0E65 27            mov b, a
1814   0E66 E4            pop a
1815   0E67             ; END TERMS        
1816   0E67 FD 43         mov [d], b
1817   0E69             ;; return heap_top - bytes; 
1818   0E69 29 67 13      mov b, [_heap_top] ; $heap_top           
1819   0E6C             ; START TERMS
1820   0E6C D7            push a
1821   0E6D 11            mov a, b
1822   0E6E 2C 05 00      mov b, [bp + 5] ; $bytes             
1823   0E71 60            sub a, b
1824   0E72 27            mov b, a
1825   0E73 E4            pop a
1826   0E74             ; END TERMS
1827   0E74 F9            leave
1828   0E75 09            ret
1829   0E76             
1830   0E76             free:
1831   0E76 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1832   0E79             ;; return heap_top = heap_top - bytes; 
1833   0E79 3B 67 13      mov d, _heap_top ; $heap_top         
1834   0E7C 29 67 13      mov b, [_heap_top] ; $heap_top           
1835   0E7F             ; START TERMS
1836   0E7F D7            push a
1837   0E80 11            mov a, b
1838   0E81 2C 05 00      mov b, [bp + 5] ; $bytes             
1839   0E84 60            sub a, b
1840   0E85 27            mov b, a
1841   0E86 E4            pop a
1842   0E87             ; END TERMS        
1843   0E87 FD 43         mov [d], b
1844   0E89 F9            leave
1845   0E8A 09            ret
1846   0E8B             
1847   0E8B             exit:
1848   0E8B F8 00 00      enter 0 ; (push bp; mov bp, sp)
1849   0E8E             
1850   0E8E             ; --- BEGIN INLINE ASM BLOCK
1851   0E8E 05 0B         syscall sys_terminate_proc
1852   0E90             ; --- END INLINE ASM BLOCK
1853   0E90             
1854   0E90 F9            leave
1855   0E91 09            ret
1856   0E92             
1857   0E92             load_hex:
1858   0E92 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1859   0E95             ; $temp 
1860   0E95 52 02 00      sub sp, 2
1861   0E98             ;; temp = alloc(32768); 
1862   0E98 FA FF FF      lea d, [bp + -1] ; $temp
1863   0E9B DA            push d
1864   0E9C 26 00 80      mov b, $8000
1865   0E9F FD AB         swp b
1866   0EA1 D8            push b
1867   0EA2 07 56 0E      call alloc
1868   0EA5 51 02 00      add sp, 2
1869   0EA8 E7            pop d
1870   0EA9 FD 43         mov [d], b
1871   0EAB             
1872   0EAB             ; --- BEGIN INLINE ASM BLOCK
1873   0EAB               
1874   0EAB               
1875   0EAB               
1876   0EAB               
1877   0EAB               
1878   0EAB             _load_hex:
1879   0EAB D7            push a
1880   0EAC D8            push b
1881   0EAD DA            push d
1882   0EAE E2            push si
1883   0EAF E3            push di
1884   0EB0 52 00 80      sub sp, $8000      
1885   0EB3 38 00 00      mov c, 0
1886   0EB6 48            mov a, sp
1887   0EB7 77            inc a
1888   0EB8 3C            mov d, a          
1889   0EB9 07 CA 0F      call _gets        
1890   0EBC 4D            mov si, a
1891   0EBD             __load_hex_loop:
1892   0EBD F6            lodsb             
1893   0EBE B9 00         cmp al, 0         
1894   0EC0 C6 CE 0E      jz __load_hex_ret
1895   0EC3 36            mov bh, al
1896   0EC4 F6            lodsb
1897   0EC5 2F            mov bl, al
1898   0EC6 07 80 0F      call _atoi        
1899   0EC9 F7            stosb             
1900   0ECA 78            inc c
1901   0ECB 0A BD 0E      jmp __load_hex_loop
1902   0ECE             __load_hex_ret:
1903   0ECE 51 00 80      add sp, $8000
1904   0ED1 F0            pop di
1905   0ED2 EF            pop si
1906   0ED3 E7            pop d
1907   0ED4 E5            pop b
1908   0ED5 E4            pop a
1909   0ED6             ; --- END INLINE ASM BLOCK
1910   0ED6             
1911   0ED6 F9            leave
1912   0ED7 09            ret
1913   0ED8             
1914   0ED8             include_stdio_asm:
1915   0ED8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1916   0EDB             
1917   0EDB             ; --- BEGIN INLINE ASM BLOCK
1918   0EDB             .include "lib/stdio.asm"
0001+  0EDB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0EDB             ; stdio.s
0003+  0EDB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0EDB             .include "lib/string.asm"
0001++ 0EDB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0EDB             ; string.s
0003++ 0EDB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0EDB             
0005++ 0EDB             
0006++ 0EDB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0EDB             ; _strrev
0008++ 0EDB             ; reverse a string
0009++ 0EDB             ; D = string address
0010++ 0EDB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0EDB             ; 01234
0012++ 0EDB             _strrev:
0013++ 0EDB 4B          	pusha
0014++ 0EDC 07 22 0F    	call _strlen	; length in C
0015++ 0EDF 12          	mov a, c
0016++ 0EE0 AF 01 00    	cmp a, 1
0017++ 0EE3 D0 FD 0E    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 0EE6 7D          	dec a
0019++ 0EE7 FD 4E       	mov si, d	; beginning of string
0020++ 0EE9 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0EEB 59          	add d, a	; end of string
0022++ 0EEC 12          	mov a, c
0023++ 0EED FD 9B       	shr a		; divide by 2
0024++ 0EEF 39          	mov c, a	; C now counts the steps
0025++ 0EF0             _strrev_L0:
0026++ 0EF0 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0EF1 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0EF2 3E          	mov [d], al	; store left char into right side
0029++ 0EF3 1B          	mov al, bl
0030++ 0EF4 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0EF5 7E          	dec c
0032++ 0EF6 7F          	dec d
0033++ 0EF7 C2 00 00    	cmp c, 0
0034++ 0EFA C7 F0 0E    	jne _strrev_L0
0035++ 0EFD             _strrev_end:
0036++ 0EFD 4C          	popa
0037++ 0EFE 09          	ret
0038++ 0EFF             	
0039++ 0EFF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0EFF             ; _strchr
0041++ 0EFF             ; search string in D for char in AL
0042++ 0EFF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0EFF             _strchr:
0044++ 0EFF             _strchr_L0:
0045++ 0EFF 32          	mov bl, [d]
0046++ 0F00 C1 00       	cmp bl, 0
0047++ 0F02 C6 0D 0F    	je _strchr_end
0048++ 0F05 BA          	cmp al, bl
0049++ 0F06 C6 0D 0F    	je _strchr_end
0050++ 0F09 79          	inc d
0051++ 0F0A 0A FF 0E    	jmp _strchr_L0
0052++ 0F0D             _strchr_end:
0053++ 0F0D 1B          	mov al, bl
0054++ 0F0E 09          	ret
0055++ 0F0F             
0056++ 0F0F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0F0F             ; _strstr
0058++ 0F0F             ; find sub-string
0059++ 0F0F             ; str1 in SI
0060++ 0F0F             ; str2 in DI
0061++ 0F0F             ; SI points to end of source string
0062++ 0F0F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0F0F             _strstr:
0064++ 0F0F DB          	push al
0065++ 0F10 DA          	push d
0066++ 0F11 E3          	push di
0067++ 0F12             _strstr_loop:
0068++ 0F12 F3          	cmpsb					; compare a byte of the strings
0069++ 0F13 C7 1E 0F    	jne _strstr_ret
0070++ 0F16 FC 00 00    	lea d, [di + 0]
0071++ 0F19 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0F1B C7 12 0F    	jne _strstr_loop				; equal chars but not at end
0073++ 0F1E             _strstr_ret:
0074++ 0F1E F0          	pop di
0075++ 0F1F E7          	pop d
0076++ 0F20 E8          	pop al
0077++ 0F21 09          	ret
0078++ 0F22             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0F22             ; length of null terminated string
0080++ 0F22             ; result in C
0081++ 0F22             ; pointer in D
0082++ 0F22             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0F22             _strlen:
0084++ 0F22 DA          	push d
0085++ 0F23 38 00 00    	mov c, 0
0086++ 0F26             _strlen_L1:
0087++ 0F26 BD 00       	cmp byte [d], 0
0088++ 0F28 C6 30 0F    	je _strlen_ret
0089++ 0F2B 79          	inc d
0090++ 0F2C 78          	inc c
0091++ 0F2D 0A 26 0F    	jmp _strlen_L1
0092++ 0F30             _strlen_ret:
0093++ 0F30 E7          	pop d
0094++ 0F31 09          	ret
0095++ 0F32             
0096++ 0F32             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0F32             ; STRCMP
0098++ 0F32             ; compare two strings
0099++ 0F32             ; str1 in SI
0100++ 0F32             ; str2 in DI
0101++ 0F32             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0F32             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0F32             _strcmp:
0104++ 0F32 DB          	push al
0105++ 0F33 DA          	push d
0106++ 0F34 E3          	push di
0107++ 0F35 E2          	push si
0108++ 0F36             _strcmp_loop:
0109++ 0F36 F3          	cmpsb					; compare a byte of the strings
0110++ 0F37 C7 42 0F    	jne _strcmp_ret
0111++ 0F3A FB FF FF    	lea d, [si +- 1]
0112++ 0F3D BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0F3F C7 36 0F    	jne _strcmp_loop				; equal chars but not at end
0114++ 0F42             _strcmp_ret:
0115++ 0F42 EF          	pop si
0116++ 0F43 F0          	pop di
0117++ 0F44 E7          	pop d
0118++ 0F45 E8          	pop al
0119++ 0F46 09          	ret
0120++ 0F47             
0121++ 0F47             
0122++ 0F47             ; STRCPY
0123++ 0F47             ; copy null terminated string from SI to DI
0124++ 0F47             ; source in SI
0125++ 0F47             ; destination in DI
0126++ 0F47             _strcpy:
0127++ 0F47 E2          	push si
0128++ 0F48 E3          	push di
0129++ 0F49 DB          	push al
0130++ 0F4A             _strcpy_L1:
0131++ 0F4A F6          	lodsb
0132++ 0F4B F7          	stosb
0133++ 0F4C B9 00       	cmp al, 0
0134++ 0F4E C7 4A 0F    	jne _strcpy_L1
0135++ 0F51             _strcpy_end:
0136++ 0F51 E8          	pop al
0137++ 0F52 F0          	pop di
0138++ 0F53 EF          	pop si
0139++ 0F54 09          	ret
0140++ 0F55             
0141++ 0F55             ; STRCAT
0142++ 0F55             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0F55             ; source in SI
0144++ 0F55             ; destination in DI
0145++ 0F55             _strcat:
0146++ 0F55 E2          	push si
0147++ 0F56 E3          	push di
0148++ 0F57 D7          	push a
0149++ 0F58 DA          	push d
0150++ 0F59 50          	mov a, di
0151++ 0F5A 3C          	mov d, a
0152++ 0F5B             _strcat_goto_end_L1:
0153++ 0F5B BD 00       	cmp byte[d], 0
0154++ 0F5D C6 64 0F    	je _strcat_start
0155++ 0F60 79          	inc d
0156++ 0F61 0A 5B 0F    	jmp _strcat_goto_end_L1
0157++ 0F64             _strcat_start:
0158++ 0F64 FD 50       	mov di, d
0159++ 0F66             _strcat_L1:
0160++ 0F66 F6          	lodsb
0161++ 0F67 F7          	stosb
0162++ 0F68 B9 00       	cmp al, 0
0163++ 0F6A C7 66 0F    	jne _strcat_L1
0164++ 0F6D             _strcat_end:
0165++ 0F6D E7          	pop d
0166++ 0F6E E4          	pop a
0167++ 0F6F F0          	pop di
0168++ 0F70 EF          	pop si
0169++ 0F71 09          	ret
0170++ 0F72             
0171++ 0F72             
0005+  0F72             
0006+  0F72             
0007+  0F72             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  0F72             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  0F72             ; ASCII in BL
0010+  0F72             ; result in AL
0011+  0F72             ; ascii for F = 0100 0110
0012+  0F72             ; ascii for 9 = 0011 1001
0013+  0F72             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  0F72             hex_ascii_encode:
0015+  0F72 1B            mov al, bl
0016+  0F73 93 40         test al, $40        ; test if letter or number
0017+  0F75 C7 7B 0F      jnz hex_letter
0018+  0F78 87 0F         and al, $0F        ; get number
0019+  0F7A 09            ret
0020+  0F7B             hex_letter:
0021+  0F7B 87 0F         and al, $0F        ; get letter
0022+  0F7D 6A 09         add al, 9
0023+  0F7F 09            ret
0024+  0F80             
0025+  0F80             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0F80             ; ATOI
0027+  0F80             ; 2 letter hex string in B
0028+  0F80             ; 8bit integer returned in AL
0029+  0F80             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  0F80             _atoi:
0031+  0F80 D8            push b
0032+  0F81 07 72 0F      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  0F84 30            mov bl, bh
0034+  0F85 DB            push al          ; save a
0035+  0F86 07 72 0F      call hex_ascii_encode
0036+  0F89 EA            pop bl  
0037+  0F8A FD 9E 04      shl al, 4
0038+  0F8D 8C            or al, bl
0039+  0F8E E5            pop b
0040+  0F8F 09            ret  
0041+  0F90             
0042+  0F90             
0043+  0F90             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  0F90             ; scanf
0045+  0F90             ; no need for explanations!
0046+  0F90             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  0F90             scanf:
0048+  0F90 09            ret
0049+  0F91             
0050+  0F91             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0F91             ; ITOA
0052+  0F91             ; 8bit value in BL
0053+  0F91             ; 2 byte ASCII result in A
0054+  0F91             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0F91             _itoa:
0056+  0F91 DA            push d
0057+  0F92 D8            push b
0058+  0F93 A7 00         mov bh, 0
0059+  0F95 FD A4 04      shr bl, 4  
0060+  0F98 74            mov d, b
0061+  0F99 1F 41 12      mov al, [d + s_hex_digits]
0062+  0F9C 23            mov ah, al
0063+  0F9D               
0064+  0F9D E5            pop b
0065+  0F9E D8            push b
0066+  0F9F A7 00         mov bh, 0
0067+  0FA1 FD 87 0F      and bl, $0F
0068+  0FA4 74            mov d, b
0069+  0FA5 1F 41 12      mov al, [d + s_hex_digits]
0070+  0FA8 E5            pop b
0071+  0FA9 E7            pop d
0072+  0FAA 09            ret
0073+  0FAB             
0074+  0FAB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  0FAB             ; HEX STRING TO BINARY
0076+  0FAB             ; di = destination address
0077+  0FAB             ; si = source
0078+  0FAB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  0FAB             _hex_to_int:
0080+  0FAB             _hex_to_int_L1:
0081+  0FAB F6            lodsb          ; load from [SI] to AL
0082+  0FAC B9 00         cmp al, 0        ; check if ASCII 0
0083+  0FAE C6 BB 0F      jz _hex_to_int_ret
0084+  0FB1 36            mov bh, al
0085+  0FB2 F6            lodsb
0086+  0FB3 2F            mov bl, al
0087+  0FB4 07 80 0F      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  0FB7 F7            stosb          ; store AL to [DI]
0089+  0FB8 0A AB 0F      jmp _hex_to_int_L1
0090+  0FBB             _hex_to_int_ret:
0091+  0FBB 09            ret    
0092+  0FBC             
0093+  0FBC             
0094+  0FBC             
0095+  0FBC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  0FBC             ; GETCHAR
0097+  0FBC             ; char in ah
0098+  0FBC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  0FBC             getch:
0100+  0FBC DB            push al
0101+  0FBD             getch_retry:
0102+  0FBD 19 01         mov al, 1
0103+  0FBF 05 03         syscall sys_io      ; receive in AH
0104+  0FC1 E8            pop al
0105+  0FC2 09            ret
0106+  0FC3             
0107+  0FC3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  0FC3             ; PUTCHAR
0109+  0FC3             ; char in ah
0110+  0FC3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0FC3             _putchar:
0112+  0FC3 D7            push a
0113+  0FC4 19 00         mov al, 0
0114+  0FC6 05 03         syscall sys_io      ; char in AH
0115+  0FC8 E4            pop a
0116+  0FC9 09            ret
0117+  0FCA             
0118+  0FCA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  0FCA             ;; INPUT A STRING
0120+  0FCA             ;; terminates with null
0121+  0FCA             ;; pointer in D
0122+  0FCA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  0FCA             _gets:
0124+  0FCA D7            push a
0125+  0FCB DA            push d
0126+  0FCC             _gets_loop:
0127+  0FCC 19 01         mov al, 1
0128+  0FCE 05 03         syscall sys_io      ; receive in AH
0129+  0FD0 B9 00         cmp al, 0        ; check error code (AL)
0130+  0FD2 C6 CC 0F      je _gets_loop      ; if no char received, retry
0131+  0FD5             
0132+  0FD5 76 1B         cmp ah, 27
0133+  0FD7 C6 F8 0F      je _gets_ansi_esc
0134+  0FDA 76 0A         cmp ah, $0A        ; LF
0135+  0FDC C6 63 10      je _gets_end
0136+  0FDF 76 0D         cmp ah, $0D        ; CR
0137+  0FE1 C6 63 10      je _gets_end
0138+  0FE4 76 5C         cmp ah, $5C        ; '\\'
0139+  0FE6 C6 24 10      je _gets_escape
0140+  0FE9               
0141+  0FE9 76 08         cmp ah, $08      ; check for backspace
0142+  0FEB C6 F4 0F      je _gets_backspace
0143+  0FEE             
0144+  0FEE 1A            mov al, ah
0145+  0FEF 3E            mov [d], al
0146+  0FF0 79            inc d
0147+  0FF1 0A CC 0F      jmp _gets_loop
0148+  0FF4             _gets_backspace:
0149+  0FF4 7F            dec d
0150+  0FF5 0A CC 0F      jmp _gets_loop
0151+  0FF8             _gets_ansi_esc:
0152+  0FF8 19 01         mov al, 1
0153+  0FFA 05 03         syscall sys_io        ; receive in AH without echo
0154+  0FFC B9 00         cmp al, 0          ; check error code (AL)
0155+  0FFE C6 F8 0F      je _gets_ansi_esc    ; if no char received, retry
0156+  1001 76 5B         cmp ah, '['
0157+  1003 C7 CC 0F      jne _gets_loop
0158+  1006             _gets_ansi_esc_2:
0159+  1006 19 01         mov al, 1
0160+  1008 05 03         syscall sys_io          ; receive in AH without echo
0161+  100A B9 00         cmp al, 0            ; check error code (AL)
0162+  100C C6 06 10      je _gets_ansi_esc_2  ; if no char received, retry
0163+  100F 76 44         cmp ah, 'D'
0164+  1011 C6 1C 10      je _gets_left_arrow
0165+  1014 76 43         cmp ah, 'C'
0166+  1016 C6 20 10      je _gets_right_arrow
0167+  1019 0A CC 0F      jmp _gets_loop
0168+  101C             _gets_left_arrow:
0169+  101C 7F            dec d
0170+  101D 0A CC 0F      jmp _gets_loop
0171+  1020             _gets_right_arrow:
0172+  1020 79            inc d
0173+  1021 0A CC 0F      jmp _gets_loop
0174+  1024             _gets_escape:
0175+  1024 19 01         mov al, 1
0176+  1026 05 03         syscall sys_io      ; receive in AH
0177+  1028 B9 00         cmp al, 0        ; check error code (AL)
0178+  102A C6 24 10      je _gets_escape      ; if no char received, retry
0179+  102D 76 6E         cmp ah, 'n'
0180+  102F C6 4E 10      je _gets_LF
0181+  1032 76 72         cmp ah, 'r'
0182+  1034 C6 55 10      je _gets_CR
0183+  1037 76 30         cmp ah, '0'
0184+  1039 C6 5C 10      je _gets_NULL
0185+  103C 76 5C         cmp ah, $5C  ; '\'
0186+  103E C6 47 10      je _gets_slash
0187+  1041 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0188+  1042 3E            mov [d], al
0189+  1043 79            inc d
0190+  1044 0A CC 0F      jmp _gets_loop
0191+  1047             _gets_slash:
0192+  1047 19 5C         mov al, $5C
0193+  1049 3E            mov [d], al
0194+  104A 79            inc d
0195+  104B 0A CC 0F      jmp _gets_loop
0196+  104E             _gets_LF:
0197+  104E 19 0A         mov al, $0A
0198+  1050 3E            mov [d], al
0199+  1051 79            inc d
0200+  1052 0A CC 0F      jmp _gets_loop
0201+  1055             _gets_CR:
0202+  1055 19 0D         mov al, $0D
0203+  1057 3E            mov [d], al
0204+  1058 79            inc d
0205+  1059 0A CC 0F      jmp _gets_loop
0206+  105C             _gets_NULL:
0207+  105C 19 00         mov al, $00
0208+  105E 3E            mov [d], al
0209+  105F 79            inc d
0210+  1060 0A CC 0F      jmp _gets_loop
0211+  1063             _gets_end:
0212+  1063 19 00         mov al, 0
0213+  1065 3E            mov [d], al        ; terminate string
0214+  1066 E7            pop d
0215+  1067 E4            pop a
0216+  1068 09            ret
0217+  1069             
0218+  1069             
0219+  1069             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0220+  1069             ;; INPUT TEXT
0221+  1069             ;; terminated with CTRL+D
0222+  1069             ;; pointer in D
0223+  1069             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0224+  1069             _gettxt:
0225+  1069 D7            push a
0226+  106A DA            push d
0227+  106B             _gettxt_loop:
0228+  106B 19 01         mov al, 1
0229+  106D 05 03         syscall sys_io      ; receive in AH
0230+  106F B9 00         cmp al, 0        ; check error code (AL)
0231+  1071 C6 6B 10      je _gettxt_loop    ; if no char received, retry
0232+  1074 76 04         cmp ah, 4      ; EOT
0233+  1076 C6 B4 10      je _gettxt_end
0234+  1079 76 08         cmp ah, $08      ; check for backspace
0235+  107B C6 B0 10      je _gettxt_backspace
0236+  107E 76 5C         cmp ah, $5C        ; '\'
0237+  1080 C6 89 10      je _gettxt_escape
0238+  1083 1A            mov al, ah
0239+  1084 3E            mov [d], al
0240+  1085 79            inc d
0241+  1086 0A 6B 10      jmp _gettxt_loop
0242+  1089             _gettxt_escape:
0243+  1089 19 01         mov al, 1
0244+  108B 05 03         syscall sys_io      ; receive in AH
0245+  108D B9 00         cmp al, 0        ; check error code (AL)
0246+  108F C6 89 10      je _gettxt_escape    ; if no char received, retry
0247+  1092 76 6E         cmp ah, 'n'
0248+  1094 C6 A2 10      je _gettxt_LF
0249+  1097 76 72         cmp ah, 'r'
0250+  1099 C6 A9 10      je _gettxt_CR
0251+  109C 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0252+  109D 3E            mov [d], al
0253+  109E 79            inc d
0254+  109F 0A 6B 10      jmp _gettxt_loop
0255+  10A2             _gettxt_LF:
0256+  10A2 19 0A         mov al, $0A
0257+  10A4 3E            mov [d], al
0258+  10A5 79            inc d
0259+  10A6 0A 6B 10      jmp _gettxt_loop
0260+  10A9             _gettxt_CR:
0261+  10A9 19 0D         mov al, $0D
0262+  10AB 3E            mov [d], al
0263+  10AC 79            inc d
0264+  10AD 0A 6B 10      jmp _gettxt_loop
0265+  10B0             _gettxt_backspace:
0266+  10B0 7F            dec d
0267+  10B1 0A 6B 10      jmp _gettxt_loop
0268+  10B4             _gettxt_end:
0269+  10B4 19 00         mov al, 0
0270+  10B6 3E            mov [d], al        ; terminate string
0271+  10B7 E7            pop d
0272+  10B8 E4            pop a
0273+  10B9 09            ret
0274+  10BA             
0275+  10BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  10BA             ; PRINT NEW LINE
0277+  10BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0278+  10BA             printnl:
0279+  10BA D7            push a
0280+  10BB 10 00 0A      mov a, $0A00
0281+  10BE 05 03         syscall sys_io
0282+  10C0 10 00 0D      mov a, $0D00
0283+  10C3 05 03         syscall sys_io
0284+  10C5 E4            pop a
0285+  10C6 09            ret
0286+  10C7             
0287+  10C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0288+  10C7             ; _strtoint
0289+  10C7             ; 4 digit hex string number in d
0290+  10C7             ; integer returned in A
0291+  10C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0292+  10C7             _strtointx:
0293+  10C7 D8            push b
0294+  10C8 32            mov bl, [d]
0295+  10C9 37            mov bh, bl
0296+  10CA 33 01 00      mov bl, [d + 1]
0297+  10CD 07 80 0F      call _atoi        ; convert to int in AL
0298+  10D0 23            mov ah, al        ; move to AH
0299+  10D1 33 02 00      mov bl, [d + 2]
0300+  10D4 37            mov bh, bl
0301+  10D5 33 03 00      mov bl, [d + 3]
0302+  10D8 07 80 0F      call _atoi        ; convert to int in AL
0303+  10DB E5            pop b
0304+  10DC 09            ret
0305+  10DD             
0306+  10DD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0307+  10DD             ; _strtoint
0308+  10DD             ; 5 digit base10 string number in d
0309+  10DD             ; integer returned in A
0310+  10DD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0311+  10DD             _strtoint:
0312+  10DD E2            push si
0313+  10DE D8            push b
0314+  10DF D9            push c
0315+  10E0 DA            push d
0316+  10E1 07 22 0F      call _strlen      ; get string length in C
0317+  10E4 7E            dec c
0318+  10E5 FD 4E         mov si, d
0319+  10E7 12            mov a, c
0320+  10E8 FD 99         shl a
0321+  10EA 3B 59 12      mov d, table_power
0322+  10ED 59            add d, a
0323+  10EE 38 00 00      mov c, 0
0324+  10F1             _strtoint_L0:
0325+  10F1 F6            lodsb      ; load ASCII to al
0326+  10F2 B9 00         cmp al, 0
0327+  10F4 C6 07 11      je _strtoint_end
0328+  10F7 6F 30         sub al, $30    ; make into integer
0329+  10F9 22 00         mov ah, 0
0330+  10FB 2A            mov b, [d]
0331+  10FC AC            mul a, b      ; result in B since it fits in 16bits
0332+  10FD 11            mov a, b
0333+  10FE 28            mov b, c
0334+  10FF 54            add a, b
0335+  1100 39            mov c, a
0336+  1101 63 02 00      sub d, 2
0337+  1104 0A F1 10      jmp _strtoint_L0
0338+  1107             _strtoint_end:
0339+  1107 12            mov a, c
0340+  1108 E7            pop d
0341+  1109 E6            pop c
0342+  110A E5            pop b
0343+  110B EF            pop si
0344+  110C 09            ret
0345+  110D             
0346+  110D             
0347+  110D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0348+  110D             ; PRINT NULL TERMINATED STRING
0349+  110D             ; pointer in D
0350+  110D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0351+  110D             _puts:
0352+  110D D7            push a
0353+  110E DA            push d
0354+  110F             _puts_L1:
0355+  110F 1E            mov al, [d]
0356+  1110 B9 00         cmp al, 0
0357+  1112 C6 1E 11      jz _puts_END
0358+  1115 23            mov ah, al
0359+  1116 19 00         mov al, 0
0360+  1118 05 03         syscall sys_io
0361+  111A 79            inc d
0362+  111B 0A 0F 11      jmp _puts_L1
0363+  111E             _puts_END:
0364+  111E E7            pop d
0365+  111F E4            pop a
0366+  1120 09            ret
0367+  1121             
0368+  1121             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0369+  1121             ; PRINT N SIZE STRING
0370+  1121             ; pointer in D
0371+  1121             ; size in C
0372+  1121             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0373+  1121             _putsn:
0374+  1121 DB            push al
0375+  1122 DA            push d
0376+  1123 D9            push c
0377+  1124             _putsn_L0:
0378+  1124 1E            mov al, [d]
0379+  1125 23            mov ah, al
0380+  1126 19 00         mov al, 0
0381+  1128 05 03         syscall sys_io
0382+  112A 79            inc d
0383+  112B 7E            dec c  
0384+  112C C2 00 00      cmp c, 0
0385+  112F C7 24 11      jne _putsn_L0
0386+  1132             _putsn_end:
0387+  1132 E6            pop c
0388+  1133 E7            pop d
0389+  1134 E8            pop al
0390+  1135 09            ret
0391+  1136             
0392+  1136             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0393+  1136             ; print 16bit decimal number
0394+  1136             ; input number in A
0395+  1136             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0396+  1136             print_u16d:
0397+  1136 D7            push a
0398+  1137 D8            push b
0399+  1138 26 10 27      mov b, 10000
0400+  113B AE            div a, b      ; get 10000's coeff.
0401+  113C 07 5E 11      call print_number
0402+  113F 11            mov a, b
0403+  1140 26 E8 03      mov b, 1000
0404+  1143 AE            div a, b      ; get 1000's coeff.
0405+  1144 07 5E 11      call print_number
0406+  1147 11            mov a, b
0407+  1148 26 64 00      mov b, 100
0408+  114B AE            div a, b
0409+  114C 07 5E 11      call print_number
0410+  114F 11            mov a, b
0411+  1150 26 0A 00      mov b, 10
0412+  1153 AE            div a, b
0413+  1154 07 5E 11      call print_number
0414+  1157 1B            mov al, bl      ; 1's coeff in bl
0415+  1158 07 5E 11      call print_number
0416+  115B E5            pop b
0417+  115C E4            pop a
0418+  115D 09            ret
0419+  115E             
0420+  115E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0421+  115E             ; print AL
0422+  115E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0423+  115E             print_number:
0424+  115E 6A 30         add al, $30
0425+  1160 23            mov ah, al
0426+  1161 07 C3 0F      call _putchar
0427+  1164 09            ret
0428+  1165             
0429+  1165             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0430+  1165             ; PRINT 16BIT HEX INTEGER
0431+  1165             ; integer value in reg B
0432+  1165             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0433+  1165             print_u16x:
0434+  1165 D7            push a
0435+  1166 D8            push b
0436+  1167 DD            push bl
0437+  1168 30            mov bl, bh
0438+  1169 07 91 0F      call _itoa        ; convert bh to char in A
0439+  116C 2F            mov bl, al        ; save al
0440+  116D 19 00         mov al, 0
0441+  116F 05 03         syscall sys_io        ; display AH
0442+  1171 24            mov ah, bl        ; retrieve al
0443+  1172 19 00         mov al, 0
0444+  1174 05 03         syscall sys_io        ; display AL
0445+  1176             
0446+  1176 EA            pop bl
0447+  1177 07 91 0F      call _itoa        ; convert bh to char in A
0448+  117A 2F            mov bl, al        ; save al
0449+  117B 19 00         mov al, 0
0450+  117D 05 03         syscall sys_io        ; display AH
0451+  117F 24            mov ah, bl        ; retrieve al
0452+  1180 19 00         mov al, 0
0453+  1182 05 03         syscall sys_io        ; display AL
0454+  1184             
0455+  1184 E5            pop b
0456+  1185 E4            pop a
0457+  1186 09            ret
0458+  1187             
0459+  1187             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0460+  1187             ; INPUT 16BIT HEX INTEGER
0461+  1187             ; read 16bit integer into A
0462+  1187             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0463+  1187             scan_u16x:
0464+  1187 F8 10 00      enter 16
0465+  118A D8            push b
0466+  118B DA            push d
0467+  118C             
0468+  118C FA F1 FF      lea d, [bp + -15]
0469+  118F 07 CA 0F      call _gets        ; get number
0470+  1192             
0471+  1192 32            mov bl, [d]
0472+  1193 37            mov bh, bl
0473+  1194 33 01 00      mov bl, [d + 1]
0474+  1197 07 80 0F      call _atoi        ; convert to int in AL
0475+  119A 23            mov ah, al        ; move to AH
0476+  119B             
0477+  119B 33 02 00      mov bl, [d + 2]
0478+  119E 37            mov bh, bl
0479+  119F 33 03 00      mov bl, [d + 3]
0480+  11A2 07 80 0F      call _atoi        ; convert to int in AL
0481+  11A5             
0482+  11A5 E7            pop d
0483+  11A6 E5            pop b
0484+  11A7 F9            leave
0485+  11A8 09            ret
0486+  11A9             
0487+  11A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0488+  11A9             ; PRINT 8bit HEX INTEGER
0489+  11A9             ; integer value in reg bl
0490+  11A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0491+  11A9             print_u8x:
0492+  11A9 D7            push a
0493+  11AA DD            push bl
0494+  11AB             
0495+  11AB 07 91 0F      call _itoa        ; convert bl to char in A
0496+  11AE 2F            mov bl, al        ; save al
0497+  11AF 19 00         mov al, 0
0498+  11B1 05 03         syscall sys_io        ; display AH
0499+  11B3 24            mov ah, bl        ; retrieve al
0500+  11B4 19 00         mov al, 0
0501+  11B6 05 03         syscall sys_io        ; display AL
0502+  11B8             
0503+  11B8 EA            pop bl
0504+  11B9 E4            pop a
0505+  11BA 09            ret
0506+  11BB             
0507+  11BB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0508+  11BB             ; print 8bit decimal unsigned number
0509+  11BB             ; input number in AL
0510+  11BB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0511+  11BB             print_u8d:
0512+  11BB D7            push a
0513+  11BC D8            push b
0514+  11BD             
0515+  11BD 22 00         mov ah, 0
0516+  11BF 26 64 00      mov b, 100
0517+  11C2 AE            div a, b
0518+  11C3 D8            push b      ; save remainder
0519+  11C4 B9 00         cmp al, 0
0520+  11C6 C6 D0 11      je skip100
0521+  11C9 6A 30         add al, $30
0522+  11CB 23            mov ah, al
0523+  11CC 19 00         mov al, 0
0524+  11CE 05 03         syscall sys_io  ; print coeff
0525+  11D0             skip100:
0526+  11D0 E4            pop a
0527+  11D1 22 00         mov ah, 0
0528+  11D3 26 0A 00      mov b, 10
0529+  11D6 AE            div a, b
0530+  11D7 D8            push b      ; save remainder
0531+  11D8 B9 00         cmp al, 0
0532+  11DA C6 E4 11      je skip10
0533+  11DD 6A 30         add al, $30
0534+  11DF 23            mov ah, al
0535+  11E0 19 00         mov al, 0
0536+  11E2 05 03         syscall sys_io  ; print coeff
0537+  11E4             skip10:
0538+  11E4 E4            pop a
0539+  11E5 1B            mov al, bl
0540+  11E6 6A 30         add al, $30
0541+  11E8 23            mov ah, al
0542+  11E9 19 00         mov al, 0
0543+  11EB 05 03         syscall sys_io  ; print coeff
0544+  11ED E5            pop b
0545+  11EE E4            pop a
0546+  11EF 09            ret
0547+  11F0             
0548+  11F0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0549+  11F0             ; INPUT 8BIT HEX INTEGER
0550+  11F0             ; read 8bit integer into AL
0551+  11F0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0552+  11F0             scan_u8x:
0553+  11F0 F8 04 00      enter 4
0554+  11F3 D8            push b
0555+  11F4 DA            push d
0556+  11F5             
0557+  11F5 FA FD FF      lea d, [bp + -3]
0558+  11F8 07 CA 0F      call _gets        ; get number
0559+  11FB             
0560+  11FB 32            mov bl, [d]
0561+  11FC 37            mov bh, bl
0562+  11FD 33 01 00      mov bl, [d + 1]
0563+  1200 07 80 0F      call _atoi        ; convert to int in AL
0564+  1203             
0565+  1203 E7            pop d
0566+  1204 E5            pop b
0567+  1205 F9            leave
0568+  1206 09            ret
0569+  1207             
0570+  1207             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0571+  1207             ; input decimal number
0572+  1207             ; result in A
0573+  1207             ; 655'\0'
0574+  1207             ; low--------high
0575+  1207             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0576+  1207             scan_u16d:
0577+  1207 F8 08 00      enter 8
0578+  120A E2            push si
0579+  120B D8            push b
0580+  120C D9            push c
0581+  120D DA            push d
0582+  120E FA F9 FF      lea d, [bp +- 7]
0583+  1211 07 CA 0F      call _gets
0584+  1214 07 22 0F      call _strlen      ; get string length in C
0585+  1217 7E            dec c
0586+  1218 FD 4E         mov si, d
0587+  121A 12            mov a, c
0588+  121B FD 99         shl a
0589+  121D 3B 59 12      mov d, table_power
0590+  1220 59            add d, a
0591+  1221 38 00 00      mov c, 0
0592+  1224             mul_loop:
0593+  1224 F6            lodsb      ; load ASCII to al
0594+  1225 B9 00         cmp al, 0
0595+  1227 C6 3A 12      je mul_exit
0596+  122A 6F 30         sub al, $30    ; make into integer
0597+  122C 22 00         mov ah, 0
0598+  122E 2A            mov b, [d]
0599+  122F AC            mul a, b      ; result in B since it fits in 16bits
0600+  1230 11            mov a, b
0601+  1231 28            mov b, c
0602+  1232 54            add a, b
0603+  1233 39            mov c, a
0604+  1234 63 02 00      sub d, 2
0605+  1237 0A 24 12      jmp mul_loop
0606+  123A             mul_exit:
0607+  123A 12            mov a, c
0608+  123B E7            pop d
0609+  123C E6            pop c
0610+  123D E5            pop b
0611+  123E EF            pop si
0612+  123F F9            leave
0613+  1240 09            ret
0614+  1241             
0615+  1241             
0616+  1241 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0616+  1245 34 35 36 37 
0616+  1249 38 39 41 42 
0616+  124D 43 44 45 46 
0617+  1251 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0617+  1255 1B 5B 48 00 
0618+  1259             
0619+  1259             table_power:
0620+  1259 01 00         .dw 1
0621+  125B 0A 00         .dw 10
0622+  125D 64 00         .dw 100
0623+  125F E8 03         .dw 1000
0624+  1261 10 27         .dw 100001919   1263             ; --- END INLINE ASM BLOCK
1920   1263             
1921   1263 F9            leave
1922   1264 09            ret
1923   1265             ; --- END TEXT BLOCK
1924   1265             
1925   1265             ; --- BEGIN DATA BLOCK
1926   1265 1B 5B 32 4A __s0: .db "\033[2J", 0
1926   1269 00 
1927   126A 1B 5B 48 00 __s1: .db "\033[H", 0
1928   126E 1B 5B 31 6D __s2: .db "\033[1m", 0
1928   1272 00 
1929   1273 42 6F 6C 64 __s3: .db "Bold Text", 0
1929   1277 20 54 65 78 
1929   127B 74 00 
1930   127D 1B 5B 30 6D __s4: .db "\033[0m\n", 0
1930   1281 0A 00 
1931   1283 1B 5B 34 6D __s5: .db "\033[4m", 0
1931   1287 00 
1932   1288 55 6E 64 65 __s6: .db "Underlined Text", 0
1932   128C 72 6C 69 6E 
1932   1290 65 64 20 54 
1932   1294 65 78 74 00 
1933   1298 1B 5B 35 6D __s7: .db "\033[5m", 0
1933   129C 00 
1934   129D 42 6C 69 6E __s8: .db "Blinking Text", 0
1934   12A1 6B 69 6E 67 
1934   12A5 20 54 65 78 
1934   12A9 74 00 
1935   12AB 1B 5B 37 6D __s9: .db "\033[7m", 0
1935   12AF 00 
1936   12B0 49 6E 76 65 __s10: .db "Inverted Colors", 0
1936   12B4 72 74 65 64 
1936   12B8 20 43 6F 6C 
1936   12BC 6F 72 73 00 
1937   12C0 1B 5B 30 6D __s11: .db "\033[0m", 0
1937   12C4 00 
1938   12C5 52 65 73 65 __s12: .db "Reset All\n", 0
1938   12C9 74 20 41 6C 
1938   12CD 6C 0A 00 
1939   12D0 1B 5B 00    __s13: .db "\033[", 0
1940   12D3 6D 1B 5B 00 __s14: .db "m\033[", 0
1941   12D7 6D 20 00    __s15: .db "m ", 0
1942   12DA 2F 00       __s16: .db "/", 0
1943   12DC 20 00       __s17: .db " ", 0
1944   12DE 32 35 36 2D __s18: .db "256-Color Chart:\n", 0
1944   12E2 43 6F 6C 6F 
1944   12E6 72 20 43 68 
1944   12EA 61 72 74 3A 
1944   12EE 0A 00 
1945   12F0 1B 5B 34 38 __s19: .db "\033[48;5;", 0
1945   12F4 3B 35 3B 00 
1946   12F8 6D 20 20 00 __s20: .db "m  ", 0
1947   12FC 20 1B 5B 30 __s21: .db " \033[0m", 0
1947   1300 6D 00 
1948   1302 0A 00       __s22: .db "\n", 0
1949   1304 55 6E 6B 6E __s23: .db "Unknown type size in va_arg() call. Size needs to be either 1 or 2.", 0
1949   1308 6F 77 6E 20 
1949   130C 74 79 70 65 
1949   1310 20 73 69 7A 
1949   1314 65 20 69 6E 
1949   1318 20 76 61 5F 
1949   131C 61 72 67 28 
1949   1320 29 20 63 61 
1949   1324 6C 6C 2E 20 
1949   1328 53 69 7A 65 
1949   132C 20 6E 65 65 
1949   1330 64 73 20 74 
1949   1334 6F 20 62 65 
1949   1338 20 65 69 74 
1949   133C 68 65 72 20 
1949   1340 31 20 6F 72 
1949   1344 20 32 2E 00 
1950   1348 45 72 72 6F __s24: .db "Error: Unknown argument type.\n", 0
1950   134C 72 3A 20 55 
1950   1350 6E 6B 6E 6F 
1950   1354 77 6E 20 61 
1950   1358 72 67 75 6D 
1950   135C 65 6E 74 20 
1950   1360 74 79 70 65 
1950   1364 2E 0A 00 
1951   1367             
1952   1367 69 13       _heap_top: .dw _heap
1953   1369 00          _heap: .db 0
1954   136A             ; --- END DATA BLOCK
1955   136A             
1956   136A             .end
tasm: Number of errors = 0
